procedure adr_rx68
/*
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
 \ Empresa.: PresServ Inform tica - Limeira (019)452.6623
 \ Programa: ADR_R068.PRG
 \ Data....: 21-01-99
 \ Sistema.: Administradora - RECEP€„O
 \ Funcao..: Resumo de Recebimento
 \ Analista: Ademilson Pedro Bom
 \ Criacao.: GAS-Pro v3.0 
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/

#include "adrbig.ch"    // inicializa constantes manifestas

LOCAL dele_atu, getlist:={},lindet:=[]
PARA  lin_menu, col_menu
PRIV  tem_borda:=.t., op_menu:=VAR_COMPL, l_s:=9, c_s:=20, l_i:=15, c_i:=61, tela_fundo:=SAVESCREEN(0,0,MAXROW(),79)
nucop=1
SETCOLOR(drvtittel)
vr_memo=NOVAPOSI(@l_s,@c_s,@l_i,@c_i)     // pega posicao atual da tela
CAIXA(mold,l_s,c_s,l_i,c_i)               // monta caixa da tela
@ l_s,c_s+10 SAY " RESUMO DE RECEBIMENTO "
SETCOLOR(drvcortel)
@ l_s+01,c_s+1 SAY " De:......:"
@ l_s+02,c_s+1 SAY " At‚:.....:"
@ l_s+03,c_s+1 SAY " Analitico:"
@ l_s+04,c_s+1 SAY " Filtragem:"
@ l_s+05,c_s+1 SAY " Confirme.:"
rde=CTOD('')                                       // De:
rate=CTOD('')                                      // At‚:
analit=SPAC(1)                                     // Analitico
rfiltr=space(50)
confirme=SPAC(1)                                   // Confirme
DO WHILE .t.
 rola_t=.f.
 cod_sos=56
 SET KEY K_ALT_F8 TO ROLATELA
 SETCOLOR(drvcortel+","+drvcorget+",,,"+corcampo)
 @ l_s+01 ,c_s+13 GET  rde;
                  PICT "@D";
                  VALI CRIT("!EMPT(rde)~Necess rio informar a data inicial a considerar")
                  DEFAULT "DATE()-DAY(DATE())+1"
                  AJUDA "Informe a data inicial a considerar"

 @ l_s+02 ,c_s+13 GET  rate;
                  PICT "@D";
                  VALI CRIT("!EMPT(rate)~Necess rio informar AT:")
                  DEFAULT "DATE()"
                  AJUDA "Informe a data final a considerar"

 @ l_s+03 ,c_s+13 GET  analit;
                  PICT "!";
                  VALI CRIT("analit$[SN]~ANALITICO n„o aceit vel|Digite S ou N")
                  DEFAULT "[N]"
                  AJUDA "Digite [S] para anal¡tico|ou N para totais"

 @ l_s+04 ,c_s+13 GET  rfiltr;
                  PICT "@KS20!"
                  AJUDA "Digite a condicao nescessaria|no contrato para ser impresso|Deixe sem preencher para todos"
                  DEFAULT "MEN_01F9()"

 @ l_s+05 ,c_s+13 GET  confirme;
                  PICT "!";
                  VALI CRIT("confirme= 'S'~CONFIRME n„o aceit vel|Digite S ou Tecle ESC")
                  AJUDA "Digite S para confirmar |ou|Tecle ESC para cancelar"

 READ
 SET KEY K_ALT_F8 TO
 IF rola_t
  ROLATELA(.f.)
  LOOP
 ENDI
 IF LASTKEY()=K_ESC                                // se quer cancelar
  RETU .F.                                             // retorna
 ENDI

 use f:\vip4\arquivos\bxrec shared

 IF !EMPT(rfiltr)
  PTAB(codigo,[GRUPOS],1)
  SET RELA TO codigo INTO grupos
 ENDI

 titrel:=criterio := ""                            // inicializa variaveis
 cpord="DTOS(emitido_)+codigo"
 titrel:=chv_rela:=chv_1:=chv_2 := ""
 tps:=op_x:=ccop := 1
 EXIT
ENDD
rcond=LEFT(rfiltr,AT("~",rfiltr)-1)               // condicao de validacao

? " Reorganizando arquivo "+ide_maq
copy to f:\vip41\bxrtmp for filtrok()
retu .t.

func filtrok()
   IF emitido_>=M->rde.and.emitido_<=M->rate       // se atender a condicao...

    IF !EMPT(rcond) // Se pediu filtragem do contrato, verifica...
     SELE GRUPOS
     IF !(&rcond.)    // Se nao for verdadeiro, tchau ...
      SELE BXREC
      retu .f.
     ENDI
     SELE BXREC
    ENDI
    retu .t.
   ENDI
retu .f.

DBOX("[ESC] Interrompe",15,,,NAO_APAGA)
dele_atu:=SET(_SET_DELETED,.t.)                    // os excluidos nao servem...
SET DEVI TO PRIN                                   // inicia a impressao
maxli=62                                           // maximo de linhas no relatorio
BEGIN SEQUENCE
 DO WHIL ccop<=nucop                               // imprime qde copias pedida
  pg_=1; cl=999
  INI_ARQ()                                        // acha 1o. reg valido do arquivo
  ccop++                                           // incrementa contador de copias
  tot040004 := 0                                   // inicializa variaves de totais
  qqu040=0                                         // contador de registros
  DO WHIL !EOF()
   #ifdef COM_TUTOR
    IF IN_KEY()=K_ESC                              // se quer cancelar
   #else
    IF INKEY()=K_ESC                               // se quer cancelar
   #endi
    IF canc()                                      // pede confirmacao
     BREAK                                         // confirmou...
    ENDI
   ENDI
   IF emitido_>=M->rde.and.emitido_<=M->rate       // se atender a condicao...

    IF !EMPT(rcond) // Se pediu filtragem do contrato, verifica...
     SELE GRUPOS
     IF !(&rcond.)    // Se nao for verdadeiro, tchau ...
      SELE BXREC
      SKIP
      LOOP
     ENDI
    ENDI
    SELE BXREC
    IF analit = [S]
     REL_CAB(2)                                     // soma cl/imprime cabecalho
     @ cl,000 SAY [Dia: ]+DTOC(emitido_)                  // titulo da quebra
     REL_CAB(1)                                     // soma cl/imprime cabecalho
    ELSE
     lindet:=[Dia: ]+DTOC(emitido_)
    ENDI
    qb04001=emitido_                               // campo para agrupar 1a quebra
    st04001004 := 0                                // inicializa sub-totais
    qqu04001=0                                     // contador de registros
    DO WHIL !EOF() .AND. emitido_=qb04001
     #ifdef COM_TUTOR
      IF IN_KEY()=K_ESC                            // se quer cancelar
     #else
      IF INKEY()=K_ESC                             // se quer cancelar
     #endi
      IF canc()                                    // pede confirmacao
       BREAK                                       // confirmou...
      ENDI
     ENDI
     IF emitido_>=M->rde.and.emitido_<=M->rate     // se atender a condicao...

    IF !EMPT(rcond) // Se pediu filtragem do contrato, verifica...
     SELE GRUPOS
     IF !(&rcond.)    // Se nao for verdadeiro, tchau ...
      SELE BXREC
      SKIP
      LOOP
     ENDI
    ENDI
    SELE BXREC

      IF ANALIT=[S]
       lindet+=TRAN(numero,"999999")+[ ]+;
               TRAN(codigo,"999999")+[ ]+;
               tipo+[-]+circ+[ ]+;
               TRAN(valorpg,"@E 9,999.99")+[ | ]   // Valor pago
       IF LEN(lindet)>110
        REL_CAB(1)                                   // soma cl/imprime cabecalho
        IMPCTL(drvpcom)
        @ cl,000 SAY lindet           // Numero
        IMPCTL(drvtcom)
        lindet:=[]
       ENDI
      ENDI
      st04001004+=valorpg
      tot040004+=valorpg
      qqu04001++                                   // soma contadores de registros
      qqu040++                                     // soma contadores de registros
      SKIP                                         // pega proximo registro
     ELSE                                          // se nao atende condicao
      SKIP                                         // pega proximo registro
     ENDI
    ENDD

    IF LEN(lindet)>0
     REL_CAB(1)                                   // soma cl/imprime cabecalho
     IMPCTL(drvpcom)
     @ cl,000 SAY lindet           // Numero
     IMPCTL(drvtcom)
     lindet:=[]
    ENDI

    IF analit = [S]
     @ ++cl,020 SAY REPL('-',10)
     cl++
    ENDI
    @ cl,020 SAY TRAN(qqu04001,"@E 999,999")
    @ cl,030 SAY TRAN(st04001004,"@E 999,999.99")// sub-tot Valor pago
   ELSE                                            // se nao atende condicao
    SKIP                                           // pega proximo registro
   ENDI
  ENDD
  IF cl+3>maxli                                    // se cabecalho do arq filho
   REL_CAB(0)                                      // nao cabe nesta pagina
  ENDI                                             // salta para a proxima pagina
  @ ++cl,020 SAY REPL('-',10)
  @ ++cl,020 SAY [R$ ]+LTRIM(TRAN(tot040004,"@E 999,999.99"))+[ em ]+;
    LTRIM(TRAN(qqu040,"@E 999,999"))+[ recebimentos]+;
    [ entre ]+DTOC(M->rde)+[ e ]+DTOC(M->rate)+[.]
 ENDD ccop
 EJEC                                              // salta pagina
END SEQUENCE
SET PRINTER TO (drvporta)                          // fecha arquivo gerado (se houver)
SET DEVI TO SCRE                                   // direciona saida p/ video
IF tps=2                                           // se vai para arquivo/video
 BROWSE_REL(arq_,2,3,MAXROW()-2,78)
ENDI                                               // mostra o arquivo gravado
GRELA(23)                                          // grava variacao do relatorio
SET(_SET_DELETED,dele_atu)                         // os excluidos serao vistos
RETU

STATIC PROC REL_CAB(qt)                            // cabecalho do relatorio
IF qt>0                                            // se parametro maior que 0
 cl=cl+qt                                          // soma no contador de linhas
ENDI
IF cl>maxli .OR. qt=0                              // quebra de pagina
 IMPAC(nemp,0,000)                                 // nome da empresa
 @ 0,070 SAY "PAG"
 @ 0,074 SAY TRAN(pg_,'9999')                      // n£mero da p gina
 IMPAC(nsis,1,000)                                 // t¡tulo aplica‡„o
 @ 1,070 SAY "ADR_R068"                            // c¢digo relat¢rio
 @ 2,000 SAY "RESUMO DE RECEBIMENTO"
 @ 2,024 SAY IIF(EMPT(rfiltr),titrel,rfiltr)                                // t¡tulo a definir
 @ 2,060 SAY NSEM(DATE())                          // dia da semana
 @ 2,068 SAY DTOC(DATE())                          // data do sistema
 @ 3,000 SAY "Numero Contrato Circ  Valor pago   ("+DTOC(M->rde)+[ e ]+DTOC(M->rate)+[)]
 @ 4,000 SAY REPL("-",78)
 cl=qt+4 ; pg_++
ENDI
RETU

* \\ Final de ADR_R068.PRG
FUNC MEN_01F9()
sit_dbf:=POINTER_DBF()
crit_ant:=criterio
auxiliar=space(210)
PTAB([],[GRUPOS],1,.T.)
SELE GRUPOS
filtra(.F.)
auxiliar=criterio+[~TRUE]
criterio :=crit_ant
POINTER_DBF(sit_dbf)
RETU auxiliar       // <- deve retornar um valor qualquer

* \\ Final de MEN_01F9.PRG
€
 ADM_R026S–Þ  ADM_R026CODEREL_CABCODEC_ETEXTENDCODE	_SYMSTARTSYMSTARTSYMBOLSSYMBOLS_SYMENDSYMENDNULLBEGDATA_DATADATA_SYMPBDATA_SYMPDATA_SYMPEDATA_CONSTCONST_MSGMSG_BEGBSSBEGBSS_BSSBSS_ENDBSSENDBSSDGROUP×˜ @ò˜ @d ³˜ H  ˜ h  	ç˜ `p
t˜ h  ß˜ h  Û˜ H  ÷˜ H  ó˜ H ç˜ H  ë˜ H  ç˜ (  /*
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
 \ Empresa.: PresServ Inform tica-Limeira (019)452.6623
 \ Programa: R07701F9.PRG
 \ Data....: 26-12-97
 \ Sistema.: Administradora -CRD/COBRAN€A
 \ Funcao..: Express„o de filtro do relat¢rio ADC_R077.PRG
 \ Analista: Ademilson Pedro Bom
 \ Criacao.: Programado manualmente pelo analista
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/

#include "adPbig.ch"    // inicializa constantes manifestas
donex:=(M->pag=[S].AND.TAXAS->valorpg>0)
donex:=donex.OR.(M->pend=[S].AND.TAXAS->valorpg=0)
//donex:=donex.AND.(EMPT(M->veni_).OR.TAXAS->emissao_>=M->veni_)
donex:=donex.AND.(EMPT(M->venf_).OR.TAXAS->emissao_<=M->venf_)

RETU M->donex       // <- deve retornar um valor L¢GICO

* \\ Final de R07701F9.PRG
€
 ADM_RS18/–Þ  ADM_RS18CODEREL_CABCODEC_ETEXTENDCODE	_SYMSTARTSYMSTARTSYMBOLSSYMBOLS_SYMENDSYMENDNULLBEGDATA_DATADATA_SYMPBDATA_SYMPDATA_SYMPEDATA_CONSTCONST_MSGMSG_BEGBSSBEGBSS_BSSBSS_ENDBSSENDBSSDGROUP³˜ @AÆ˜ @  w˜ H  ˜ h  	ç˜ `À
$˜ h  ß˜ h  Û˜ H  ÷˜ H  ó˜ H ç˜ H  ë˜ H  ç˜ (  €
 INS_02F9D–Ñ  INS_02F9CODEC_ETEXTENDCODE	_SYMSTARTSYMSTARTSYMBOLSSYMBOLS_SYMENDSYMENDNULLBEGDATA_DATADATA_SYMPBDATA_SYMPDATA_SYMPEDATA_CONSTCONST_MSGMSG_BEGBSSBEGBSS_BSSBSS_ENDBSSENDBSSDGROUP˜ @© r˜ H  ˜ h  ë˜ `€ 	o˜ h  
ã˜ h  ß˜ H  û˜ H  ÷˜ H ë˜ H  ï˜ H  ë˜ (  ˜ H  /*
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
 \ Empresa.: PresServ Inform tica - Limeira (019)452.6623
 \ Programa: ADP_R101.PRG
 \ Data....: 23-03-10
 \ Sistema.: Administradora - RECEP€„O
 \ Funcao..: Cartinha
 \ Analista: Ademilson Pedro Bom
 \ Criacao.: GAS-Pro v4.0o
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/

#include "adrbig.ch"    // inicializa constantes manifestas

PRIV dele_atu, cur_atual, getlist:={}
PARA lin_menu, col_menu
PRIV  tem_borda:=.t., op_menu:=VAR_COMPL, l_s:=7, c_s:=4, l_i:=17, c_i:=77, tela_fundo:=SAVESCREEN(0,0,MAXROW(),79)
nucop=1
SETCOLOR(drvtittel)
vr_memo=NOVAPOSI(@l_s,@c_s,@l_i,@c_i)     // pega posicao atual da tela
CAIXA(mold,l_s,c_s,l_i,c_i)               // monta caixa da tela
@ l_s,c_s+26 SAY " CARTINHA DE PROCESSOS "
SETCOLOR(drvcortel)
@ l_s+01,c_s+1 SAY " Contrato:            Grupo:     Circular:"
@ l_s+02,c_s+1 SAY " Mensagem:"
@ l_s+08,c_s+1 SAY " Confirme:"
PRIV rcodigo:=SPAC(9)                               // Grupo
PRIV rgrupo:=SPAC(2)                               // Grupo
PRIV rcirc:=SPAC(3)                                // Circular
PRIV rmens1:=SPAC(70)                              // Mens1
PRIV rmens2:=SPAC(70)                              // Mens2
PRIV rmens3:=SPAC(70)                              // Mens3
PRIV rmens4:=SPAC(70)                              // Mens4
PRIV rmens5:=SPAC(70)                              // Mens5
IF FILE('PR101VAR.MEM')
 REST FROM PR101VAR ADDITIVE
ENDI
PRIV confirme:=SPAC(1)                             // Confirme
DO WHILE .t.
 rola_t=.f.
 cod_sos=56
 SET KEY K_ALT_F8 TO ROLATELA
 SETCOLOR(drvcortel+","+drvcorget+",,,"+corcampo)
 @ l_s+01 ,c_s+12 GET  rcodigo;
                  PICT "999999999";
                  VALI CRIT("(PTAB(rcodigo,'GRUPOS',1).AND.!EMPT(rgrupo:=GRUPOS->grupo)).OR.EMPT(rcodigo)~GRUPO n„o existe na tabela|Informe um existente |ou|deixe sem preencher para listar todos")
                  AJUDA "Informe o nr. do contrato"
                  CMDF8 "VDBF(6,3,20,77,'GRUPOS',{'codigo','grupo','nome','endereco'},1,'codigo',[])"

 @ l_s+01 ,c_s+30 GET  rgrupo;
                  PICT "!!"
                  AJUDA "Circular de qual grupo?"
                  CMDF8 "VDBF(6,54,20,77,'ARQGRUP',{'grup','inicio','final'},1,'grup',[])"

 @ l_s+01 ,c_s+45 GET  rcirc;
                  PICT "999";
                  VALI CRIT("PTAB(rgrupo+rcirc,'CIRCULAR',1).OR.EMPT(rcirc)~Necess rio informar CIRCULAR v lida")
                  AJUDA "Informe o n£mero da circular a listar"
                  CMDF8 "VDBF(6,40,20,77,'CIRCULAR',{'grupo','circ','emissao_','valor'},1,'circ',[grupo=rgrupo])"

 @ l_s+03 ,c_s+02 GET  rmens1;
                  PICT "@!"
                  AJUDA "Mensagem 1"
                  CMDF8 "Informe a linha 1/5 da cartinha"

 @ l_s+04 ,c_s+02 GET  rmens2;
                  PICT "@!"
                  AJUDA "Mensagem 2"
                  CMDF8 "Informe a linha 2/5 da cartinha"

 @ l_s+05 ,c_s+02 GET  rmens3;
                  PICT "@!"
                  AJUDA "Mensagem 3"
                  CMDF8 "Informe a linha 3/5 da cartinha"

 @ l_s+06 ,c_s+02 GET  rmens4;
                  PICT "@!"
                  AJUDA "Mensagem 4"
                  CMDF8 "Informe a linha 4/5 da cartinha"

 @ l_s+07 ,c_s+02 GET  rmens5;
                  PICT "@!"
                  AJUDA "Mensagem 5"
                  CMDF8 "Informe a linha 5/5 da cartinha"

 @ l_s+08 ,c_s+12 GET  confirme;
                  PICT "!";
                  VALI CRIT("confirme= 'S'~CONFIRME n„o aceit vel|Digite S ou Tecle ESC")
                  AJUDA "Digite S para confirmar |ou|Tecle ESC para cancelar"

 READ
 SET KEY K_ALT_F8 TO
 IF rola_t
  ROLATELA(.f.)
  LOOP
 ENDI
 IF LASTKEY()=K_ESC                                // se quer cancelar
  RETU                                             // retorna
 ENDI

 SAVE TO PR101VAR ALL LIKE R*

 #ifdef COM_REDE
  IF !USEARQ("CIRCULAR",.f.,10,1)                  // se falhou a abertura do arq
   RETU                                            // volta ao menu anterior
  ENDI
 #else
  USEARQ("CIRCULAR")                               // abre o dbf e seus indices
 #endi

 titrel:=criterio := ""                            // inicializa variaveis
 cpord="grupo"
 chv_rela:=chv_1:=chv_2 := ""
 tps:=op_x:=ccop := 1
 fil_ini=""
 IF !opcoes_rel(lin_menu,col_menu,14,11,fil_ini)   // nao quis configurar...
  CLOS ALL                                         // fecha arquivos e
  LOOP                                             // volta ao menu
 ENDI
 IF tps=2                                          // se vai para arquivo/video
  arq_=ARQGER()                                    // entao pega nome do arquivo
  IF EMPTY(arq_)                                   // se cancelou ou nao informou
   LOOP                                            // retorna
  ENDI
 ELSE
  arq_=drvporta                                    // porta de saida configurada
 ENDI
 IF "4WIN"$UPPER(drvmarca) // nome da configuracao/marca impressora
   arq_:=drvdbf+"WIN"+ide_maq
   tps:=3                                         // se vai para arquivo/video
 ENDIF
 SET PRINTER TO (arq_)                             // redireciona saida
 EXIT
ENDD
cur_atual=SETCURSOR(0)
IF !EMPTY(drvtapg)                                 // existe configuracao de tam pag?
 op_=AT("NNN",drvtapg)                             // se o codigo que altera
 IF op_=0                                          // o tamanho da pagina
  msg="Configura‡„o do tamanho da p gina!"         // foi informado errado
  DBOX(msg,,,,,"ERRO!")                            // avisa
  CLOSE ALL                                        // fecha todos arquivos abertos
  RETU                                             // e cai fora...
 ENDI                                              // codigo para setar/resetar tam pag
 lpp_033=LEFT(drvtapg,op_-1)+"033"+SUBS(drvtapg,op_+3)
 lpp_066=LEFT(drvtapg,op_-1)+"066"+SUBS(drvtapg,op_+3)
ELSE
 lpp_033:=lpp_066 :=""                             // nao ira mudara o tamanho da pag
ENDI
criterio_=criterio                                 // salva criterio e ordenacao
cpord_=cpord                                       // definidos se huver
criterio=""

#ifdef COM_REDE
 IF !USEARQ("CPRCIRC",.f.,10,1)                    // se falhou a abertura do arq
  RETU                                             // volta ao menu anterior
 ENDI
#else
 USEARQ("CPRCIRC")                                 // abre o dbf e seus indices
#endi

cpord="grupo+circ+DTOS(dfal)"
criterio=""
INDTMP()
criterio=criterio_                                 // restabelece criterio e
cpord=cpord_                                       // ordenacao definidos
SELE CIRCULAR
dele_atu:=SET(_SET_DELETED,.t.)                    // os excluidos nao servem...
POE_GAUGE("[ESC] Interrompe","AGUARDE...","Emitidos:")
SET DEVI TO PRIN                                   // inicia a impressao
maxli=63
maxli=32                                           // maximo de linhas no relatorio
IMPCTL(lpp_033)                                    // seta pagina com 33 linhas
                                           // maximo de linhas no relatorio
SET MARG TO 1                                      // ajusta a margem esquerda
BEGIN SEQUENCE
 DO WHIL ccop<=nucop                               // imprime qde copias pedida
  pg_=1; cl=50000
  INI_ARQ()                                        // acha 1o. reg valido do arquivo
  IF EOF()
   EXIT
  ENDI
  ccop++                                           // incrementa contador de copias
  DO WHIL !EOF().AND.POE_GAUGE()
   IF IN_KEY()=K_ESC                               // se quer cancelar
    IF canc()                                      // pede confirmacao
     BREAK                                         // confirmou...
    ENDI
   ENDI
   IF grupo=M->rgrupo.AND.circ=M->rcirc            // se atender a condicao...
    IMPCTL(drvtc20)                               // comprime os dados
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY "Circular:"
    @ cl,012 SAY TRAN(M->rgrupo,"!!")+[-]+TRAN(M->rcirc,"999")              // Circular
    @ cl,031 SAY "Emissao:"
    @ cl,040 SAY TRAN(emissao_,"@D")               // Emiss„o
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY TRAN(M->rmens1,"@!")              // Mens1
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY TRAN(M->rmens2,"@!")              // Mens2
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY TRAN(M->rmens3,"@!")              // Mens3
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY TRAN(M->rmens4,"@!")              // Mens4
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY TRAN(M->rmens5,"@!")              // Mens5
    chv030=grupo+circ
    SELE CPRCIRC
    SEEK chv030
    IF FOUND()
     IF cl+3>maxli                                 // se cabecalho do arq filho
      REL_CAB(0)                                   // nao cabe nesta pagina
     ENDI                                          // salta para a proxima pagina
     IMPCTL(drvpc20)                               // comprime os dados
     cl+=1                                         // soma contador de linha
     IMPAC("Contrato Processo    Falecido(a)                         Endere‡o                                           Data Fal",cl,000)
     cl+=1                                         // soma contador de linha
     @ cl,000 SAY "======== =========== =================================== ================================================== =========="
     DO WHIL ! EOF() .AND. chv030=LEFT(&(INDEXKEY(0)),LEN(chv030)).AND.POE_GAUGE()
      IF IN_KEY()=K_ESC                            // se quer cancelar
       IF canc()                                   // pede confirmacao
        BREAK                                      // confirmou...
       ENDI
      ENDI
      REL_CAB(1)                                   // soma cl/imprime cabecalho
      @ cl,001 SAY num                             // Contrato
      @ cl,009 SAY TRAN(processo,"@R 99999/99/!!") // Processo
      @ cl,021 SAY TRAN(fal,"@!")                  // Falecido(a)
      @ cl,057 SAY TRAN(ALLTRIM(ends)+[-]+ALLTRIM(cids),"@!")// Endere‡o
      @ cl,108 SAY TRAN(dfal,"@D")                 // Data Fal
      SKIP                                         // pega proximo registro
     ENDD
     cl++
     @ cl,000 SAY "======== =========== =================================== ================================================== =========="
     cl+=3                                         // soma contador de linha
    ENDI
    IMPCTL(drvtc20)                               // comprime os dados
    SELE CIRCULAR                                  // volta ao arquivo pai
    SKIP                                           // pega proximo registro
    cl=50000                                       // forca salto de pagina
   ELSE                                            // se nao atende condicao
    SKIP                                           // pega proximo registro
   ENDI
  ENDD
 ENDD ccop
 EJEC                                              // salta pagina
END SEQUENCE
SETCURSOR(cur_atual)
SET MARG TO                                        // coloca margem esquerda = 0
IMPCTL(lpp_066)                                    // seta pagina com 66 linhas
SET PRINTER TO (drvporta)                          // fecha arquivo gerado (se houver)
SET DEVI TO SCRE                                   // direciona saida p/ video
IF tps=2                                           // se vai para arquivo/video
 BROWSE_REL(arq_,2,3,MAXROW()-2,78)
ENDI          // mostra o arquivo gravado
GRELA(14)                                          // grava variacao do relatorio
SET(_SET_DELETED,dele_atu)                         // os excluidos serao vistos
RETU

STATIC PROC REL_CAB(qt)                            // cabecalho do relatorio
IF qt>0                                            // se parametro maior que 0
 cl=cl+qt                                          // soma no contador de linhas
ENDI
IF cl>maxli .OR. qt=0                              // quebra de pagina
 IMPCTL(drvtc20)                               // comprime os dados
 IMPAC(nemp,0,000)                                 // nome da empresa
 @ 0,070 SAY "PAG"
 @ 0,074 SAY TRAN(pg_,'9999')                      // n£mero da p gina
 IMPAC(nsis,1,000)                                 // t¡tulo aplica‡„o
 @ 1,027 SAY titrel                                // t¡tulo a definir
 @ 1,068 SAY "ADP_R101"                            // c¢digo relat¢rio
 @ 2,000 SAY "Relacao dos funerais efetuados (cartinha)"
 @ 2,058 SAY NSEM(DATE())                          // dia da semana
 @ 2,066 SAY DTOC(DATE())                          // data do sistema
 @ 3,000 SAY REPL("-",76)
 cl=qt+3 ; pg_++
ENDI
RETU

* \\ Final de ADP_R101.PRG
€
 ADR_MENU–Ñ  ADR_MENUCODEC_ETEXTENDCODE	_SYMSTARTSYMSTARTSYMBOLSSYMBOLS_SYMENDSYMENDNULLBEGDATA_DATADATA_SYMPBDATA_SYMPDATA_SYMPEDATA_CONSTCONST_MSGMSG_BEGBSSBEGBSS_BSSBSS_ENDBSSENDBSSDGROUPÂ˜ @ê˜ H  ˜ h  ë˜ `ð	ú˜ h  
ã˜ h  ß˜ H  û˜ H  ÷˜ H ë˜ H  ï˜ H  ë˜ (  ˜ H  000000580000024200000358000022910000270700003835000066000000016200006820000010060000788400003329000112710000531100016640000116170002831500001701000300740000307900033211000011390003440800002207000366730000018900036920000009310003790900000495000384620000034000038860000026550004157300001433000430640000173500044857000014740004638900000528000469750000046400047497000003310004788600000238000481820000021200048452000004100004892000000404000493820000183400051274000003150005164700000213000519180000065600052632000013560005404600000230000543340000018400054576000004740005510800001057000562230000018800056469000001530005668000000367000571050000042400057587000028080006045300000261000607720000022000061050000016100006271800000362000631380000039400063590000002880006393600000412000644060000081900065283000003980006573900000479000662760000217500068509000002810006884800001575000704810000127400071813000002420007211300001331000735020000048300074043000002800007438100000232000746710000020400074933000001510007514200000184000753630000236800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000procedure obx_07f9
/*
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
 \ Empresa.: Ind£stria de Urnas Bignotto Ltda
 \ Programa: BXR_07F9.PRG
 \ Data....: 28-11-95
 \ Sistema.: Administradora de Funer rias
 \ Funcao..: Valor inicial do campo VALORPG, arquivo BXREC
 \ Analista: Ademilson Pedro Bom
 \ Criacao.: Programado manualmente pelo analista
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/

#include "adrbig.ch"    // inicializa constantes manifestas
LOCAL reg_dbf:=POINTER_DBF()
PRIVA respx,nomx:=space(35)
if op_menu#INCLUSAO
 retu PTAB(codigo,[GRUPOS],1)
endi
PTAB([],[GRUPOS],1,.t.)

nome:=space(35)
IF EMPT(codigo)
 nomx=DBOX("Nome",,,,,"Informe o nome a procurar",nomx,"@!")

 IF PTAB(alltrim(nomx),[GRUPOS],2,.t.)
	codigo:=GRUPOS->codigo
	codigo:=VDBF(6,3,20,77,'GRUPOS',{'nome','codigo','endereco','tcarencia'},5,'codigo')
	nome:=GRUPOS->nome

 ELSE
  msgt="Nome n„o encontrado como titular|Procurar como inscrito?"
  ALERTA()
  op_=DBOX("Prosseguir|Cancelar opera‡„o",,,E_MENU,,msgt)
  IF op_ = 1
   IF !PTAB(alltrim(nomx),[INSCRITS],2,.t.)
    PTAB(ALLTRIM(LEFT(nomx,AT(' ',nomx))),[INSCRITS],2,.t.)
   ENDI
	 codigo:=INSCRITS->codigo+INSCRITS->grau+STR(INSCRITS->seq,2)
   nome:=alltrim(inscrits->nome)
	 codiGO:=VDBF(6,3,20,77,'INSCRITS',{'nome','codigo','grau','seq','tcarencia','vivofalec','tipo'},2,'codigo')
	 nome:=INSCRITS->nome
   codigo:=IIF(codigo=NIL,SPACE(9),left(codigo,9))
  ENDI

 ENDI

 IF LASTKEY()=K_ESC             // se teclou ESC
	codigo=SPACE(9)
	POINTER_DBF(reg_dbf)
	RETU .f.
 ENDI

ENDI
respx:=LEFT(codigo,9)

IF PTAB(respx,[GRUPOS],1)
 titular:=GRUPOS->nome
// dbox(titular+respx)
ENDI

POINTER_DBF(reg_dbf)

retu PTAB(respx,[GRUPOS],1)	 // <- deve retornar um valor qualquer

/*
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
 \ Empresa.: PresServ Inform tica - Limeira (019)452.6623
 \ Programa: ADM_R022.PRG
 \ Data....: 04-11-03
 \ Sistema.: Administradora - RECEP€„O
 \ Funcao..: Endere‡os Alterados
 \ Analista: Ademilson Pedro Bom
 \ Criacao.: GAS-Pro v4.0n
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/
#include "adrbig.ch"    // inicializa constantes manifestas

PRIV dele_atu, cur_atual, getlist:={}
PARA lin_menu, col_menu
PRIV  tem_borda:=.t., op_menu:=VAR_COMPL, l_s:=10, c_s:=26, l_i:=14, c_i:=56, tela_fundo:=SAVESCREEN(0,0,MAXROW(),79)
nucop=1
IF nivelop < 2                                     // se usuario nao tem
 DBOX("Emiss„o negada, "+usuario,20)               // permissao, avisa
 RETU                                              // e retorna
ENDI
SETCOLOR(drvtittel)
vr_memo=NOVAPOSI(@l_s,@c_s,@l_i,@c_i)     // pega posicao atual da tela
CAIXA(mold,l_s,c_s,l_i,c_i)               // monta caixa da tela
@ l_s,c_s+5 SAY " ENDERE€OS ALTERADOS "
SETCOLOR(drvcortel)
@ l_s+01,c_s+1 SAY " Usu rio........:"
@ l_s+02,c_s+1 SAY " Lan‡to. inicial:"
@ l_s+03,c_s+1 SAY " Lan‡to. final..:"
PRIV musuario:=SPAC(10)                            // Usuario
PRIV emisini_:=CTOD('')                            // Lan‡to. inicial
PRIV emisfim_:=CTOD('')                            // Lan‡to. final
DO WHILE .t.
 rola_t=.f.
 cod_sos=56
 SET KEY K_ALT_F8 TO ROLATELA
 SETCOLOR(drvcortel+","+drvcorget+",,,"+corcampo)
 @ l_s+01 ,c_s+19 GET  musuario;
                  PICT "@!"
                  DEFAULT "M->usuario"
                  AJUDA "Informe o usu rio a listar|ou deixe sem preencher para listar todos."
                  CMDF8 "M->usuario"

 @ l_s+02 ,c_s+19 GET  emisini_;
                  PICT "@D";
                  VALI CRIT("!EMPT(emisini_).and. emisini_<=DATE()~Necess rio informar Lan‡to. inicial correta")
                  DEFAULT "DATE() - DAY(DATE()) + 1"
                  AJUDA "Informe a data inicial"

 @ l_s+03 ,c_s+19 GET  emisfim_;
                  PICT "@D";
                  VALI CRIT("!EMPT(emisfim_).and.emisfim_>=emisini_.and.emisfim_<=DATE()~Necess rio informar Lan‡to. final correta")
                  DEFAULT "DATE()"
                  AJUDA "Informe a data final"

 READ
 SET KEY K_ALT_F8 TO
 IF rola_t
  ROLATELA(.f.)
  LOOP
 ENDI
 IF LASTKEY()=K_ESC                                // se quer cancelar
  RETU                                             // retorna
 ENDI

 #ifdef COM_REDE
  IF !USEARQ("ALENDER",.f.,10,1)                   // se falhou a abertura do arq
   RETU                                            // volta ao menu anterior
  ENDI
 #else
  USEARQ("ALENDER")                                // abre o dbf e seus indices
 #endi

 PTAB(codigo,"GRUPOS",1,.t.)                       // abre arquivo p/ o relacionamento
 SET RELA TO codigo INTO GRUPOS                    // relacionamento dos arquivos
 titrel:=criterio := ""                            // inicializa variaveis
 cpord=""
 chv_rela:=chv_1:=chv_2 := ""
 tps:=op_x:=ccop := 1
 fil_ini=""
 IF !opcoes_rel(lin_menu,col_menu,11,11,fil_ini)   // nao quis configurar...
  CLOS ALL                                         // fecha arquivos e
  LOOP                                             // volta ao menu
 ENDI
 IF tps=2                                          // se vai para arquivo/video
  arq_=ARQGER()                                    // entao pega nome do arquivo
  IF EMPTY(arq_)                                   // se cancelou ou nao informou
   LOOP                                            // retorna
  ENDI
 ELSE
  arq_=drvporta                                    // porta de saida configurada
 ENDI
 SET PRINTER TO (arq_)                             // redireciona saida
 EXIT
ENDD
cur_atual=SETCURSOR(0)
dele_atu:=SET(_SET_DELETED,.t.)                    // os excluidos nao servem...
POE_GAUGE("[ESC] Interrompe","AGUARDE...","Emitidos:")
SET DEVI TO PRIN                                   // inicia a impressao
maxli=63                                           // maximo de linhas no relatorio
BEGIN SEQUENCE
 DO WHIL ccop<=nucop                               // imprime qde copias pedida
  pg_=1; cl=50000
  INI_ARQ()                                        // acha 1o. reg valido do arquivo
  IF EOF()
   EXIT
  ENDI
  ccop++                                           // incrementa contador de copias
  DO WHIL !EOF().AND.POE_GAUGE()
   IF IN_KEY()=K_ESC                               // se quer cancelar
    IF canc()                                      // pede confirmacao
     BREAK                                         // confirmou...
    ENDI
   ENDI
   IF EMPT(emitido_).AND.(EMPT(M->musuario).OR.por=M->musuario).AND.data_>=M->emisini_.AND.data_<=M->emisfim_// se atender a condicao...
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,042 SAY "³"
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY "Alterar"
    IMPCTL(drvpenf)
    IMPEXP(cl,008,dgrupo+'-'+codigo,18)            // Codigo
    IMPCTL(drvtenf)
    @ cl,028 SAY "DE:           ³ PARA:        ("
    @ cl,058 SAY por                               // Por
    @ cl,069 SAY TRAN(data_,"@D")                  // Data_
    @ cl,077 SAY ")"
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY "Ender.."
    @ cl,007 SAY dendereco                         // Endere‡o
    @ cl,042 SAY "³"
    @ cl,044 SAY endereco                          // Endere‡o
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY "Bairro."
    @ cl,007 SAY dbairro                           // Bairro
    @ cl,042 SAY "³"
    @ cl,044 SAY bairro                            // Bairro
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY "Cidade."
    @ cl,007 SAY dcidade                           // Cidade
    @ cl,033 SAY TRAN(dcep,"@R 99999-999")         // CEP
    @ cl,042 SAY "³"
    @ cl,044 SAY cidade                            // Cidade
    @ cl,070 SAY TRAN(cep,"@R 99999-999")          // CEP
    SKIP                                           // pega proximo registro
   ELSE                                            // se nao atende condicao
    SKIP                                           // pega proximo registro
   ENDI
  ENDD
 ENDD ccop
END SEQUENCE
SETCURSOR(cur_atual)
SET PRINTER TO (drvporta)                          // fecha arquivo gerado (se houver)
SET DEVI TO SCRE                                   // direciona saida p/ video
IF tps=2                                           // se vai para arquivo/video
 BROWSE_REL(arq_,2,3,MAXROW()-2,78)
ENDI          // mostra o arquivo gravado
GRELA(11)                                          // grava variacao do relatorio
msgp="PROCESSAMENTOS DO RELAT¢RIO|ENDERE€OS ALTERADOS"
POE_GAUGE("Processando registros","AGUARDE!","Feitos:")
SET(_SET_DELETED,.t.)                              // os excluidos nao servem...
SELE ALENDER                                       // processamentos apos emissao
INI_ARQ()                                          // acha 1o. reg valido do arquivo
DO WHIL !EOF().AND.POE_GAUGE()
 IF EMPT(emitido_).AND.(EMPT(M->musuario).OR.por=M->musuario).AND.data_>=M->emisini_.AND.data_<=M->emisfim_// se atender a condicao...

  #ifdef COM_REDE
   IF PTAB(codigo,'GRUPOS',1)
    REPBLO('GRUPOS->endereco',{||endereco})
   ENDI
   REPBLO('GRUPOS->bairro',{||bairro})
   REPBLO('GRUPOS->cidade',{||cidade})
   REPBLO('GRUPOS->cep',{||cep})
   REPBLO('GRUPOS->cobrador',{||cobrador})
   REPBLO('GRUPOS->ender_',{||DATE()})
   REPBLO('GRUPOS->ultend',{||M->usuario})
   REPBLO('ALENDER->emitido_',{||DATE()})
  #else
   IF PTAB(codigo,'GRUPOS',1)
    REPL GRUPOS->endereco WITH endereco
   ENDI
   REPL GRUPOS->bairro WITH bairro
   REPL GRUPOS->cidade WITH cidade
   REPL GRUPOS->cep WITH cep
   REPL GRUPOS->cobrador WITH cobrador
   REPL GRUPOS->ender_ WITH DATE()
   REPL GRUPOS->ultend WITH M->usuario
   REPL ALENDER->emitido_ WITH DATE()
  #endi

  SKIP                                             // pega proximo registro
 ELSE                                              // se nao atende condicao
  SKIP                                             // pega proximo registro
 ENDI
ENDD
ALERTA(2)
DBOX("Processo terminado com sucesso!",,,,,msgp)
SELE ALENDER                                       // seleciona arquivo
SET RELA TO                                        // retira os relacionamentos
SET(_SET_DELETED,dele_atu)                         // os excluidos serao vistos
RETU

STATIC PROC REL_CAB(qt)                            // cabecalho do relatorio
IF qt>0                                            // se parametro maior que 0
 cl=cl+qt                                          // soma no contador de linhas
ENDI
IF cl>maxli .OR. qt=0                              // quebra de pagina
 IMPAC(nemp,0,000)                                 // nome da empresa
 @ 0,070 SAY "PAG"
 @ 0,074 SAY TRAN(pg_,'9999')                      // n£mero da p gina
 IMPAC(nsis,1,000)                                 // t¡tulo aplica‡„o
 @ 1,070 SAY "ADM_R022"                            // c¢digo relat¢rio
 @ 2,000 SAY titrel                                // t¡tulo a definir
 IMPAC("ALTERA€ŽO DE ENDERE€OS",2,032)
 @ 2,062 SAY NSEM(DATE())                          // dia da semana
 @ 2,070 SAY DTOC(DATE())                          // data do sistema
 @ 3,000 SAY REPL("-",78)
 cl=qt+3 ; pg_++
ENDI
RETU

* \\ Final de ADM_R022.PRG
<?
$ip = '192.168.0.1';
$login = 'plano';
$senha = "bompastor";
$conexao = "mysql";

$dbf_name_associados = '/sys/BPCONV/PLANO/sql/ASSOCIAD.DBF';
$dbf_name_inscritos = '/sys/BPCONV/PLANO/sql/INSCRITS.DBF';
$dbf_name_rec_parcela = '/sys/BPCONV/PLANO/sql/PARCELA.DBF';
//$dbf_name_cre_cadastro = '/server/apache/htdocs/teste/sql2dbf/cre_cadastro.dbf';

?>
procedure adp_r101
/*
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
 \ Empresa.: PresServ Inform tica - Limeira (019)452.6623
 \ Programa: ADP_R101.PRG
 \ Data....: 23-03-10
 \ Sistema.: Administradora - RECEP€„O
 \ Funcao..: Cartinha
 \ Analista: Ademilson Pedro Bom
 \ Criacao.: GAS-Pro v4.0o
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/

#include "adrbig.ch"    // inicializa constantes manifestas

PRIV dele_atu, cur_atual, getlist:={}
PARA lin_menu, col_menu
PRIV  tem_borda:=.t., op_menu:=VAR_COMPL, l_s:=7, c_s:=4, l_i:=17, c_i:=77, tela_fundo:=SAVESCREEN(0,0,MAXROW(),79)
nucop=1
SETCOLOR(drvtittel)
vr_memo=NOVAPOSI(@l_s,@c_s,@l_i,@c_i)     // pega posicao atual da tela
CAIXA(mold,l_s,c_s,l_i,c_i)               // monta caixa da tela
@ l_s,c_s+26 SAY " CARTINHA DE PROCESSOS "
SETCOLOR(drvcortel)
@ l_s+01,c_s+1 SAY " Contrato:            Grupo:     Circular:"
@ l_s+02,c_s+1 SAY " Mensagem:"
@ l_s+08,c_s+1 SAY " Confirme:"
PRIV rcodigo:=SPAC(9)                               // Grupo
PRIV rgrupo:=SPAC(2)                               // Grupo
PRIV rcirc:=SPAC(3)                                // Circular
PRIV rmens1:=SPAC(70)                              // Mens1
PRIV rmens2:=SPAC(70)                              // Mens2
PRIV rmens3:=SPAC(70)                              // Mens3
PRIV rmens4:=SPAC(70)                              // Mens4
PRIV rmens5:=SPAC(70)                              // Mens5
IF FILE('PR101VAR.MEM')
 REST FROM PR101VAR ADDITIVE
ENDI
PRIV confirme:=SPAC(1)                             // Confirme
DO WHILE .t.
 rola_t=.f.
 cod_sos=56
 SET KEY K_ALT_F8 TO ROLATELA
 SETCOLOR(drvcortel+","+drvcorget+",,,"+corcampo)
 @ l_s+01 ,c_s+12 GET  rcodigo;
                  PICT "999999999";
                  VALI CRIT("(PTAB(rcodigo,'GRUPOS',1).AND.!EMPT(rgrupo:=GRUPOS->grupo)).OR.EMPT(rcodigo)~GRUPO n„o existe na tabela|Informe um existente |ou|deixe sem preencher para listar todos")
                  AJUDA "Informe o nr. do contrato"
                  CMDF8 "VDBF(6,3,20,77,'GRUPOS',{'codigo','grupo','nome','endereco'},1,'codigo',[])"

 @ l_s+01 ,c_s+30 GET  rgrupo;
                  PICT "!!"
                  AJUDA "Circular de qual grupo?"
                  CMDF8 "VDBF(6,54,20,77,'ARQGRUP',{'grup','inicio','final'},1,'grup',[])"

 @ l_s+01 ,c_s+45 GET  rcirc;
                  PICT "999";
                  VALI CRIT("PTAB(rgrupo+rcirc,'CIRCULAR',1).OR.EMPT(rcirc)~Necess rio informar CIRCULAR v lida")
                  AJUDA "Informe o n£mero da circular a listar"
                  CMDF8 "VDBF(6,40,20,77,'CIRCULAR',{'grupo','circ','emissao_','valor'},1,'circ',[grupo=rgrupo])"

 @ l_s+03 ,c_s+02 GET  rmens1;
                  PICT "@!"
                  AJUDA "Mensagem 1"
                  CMDF8 "Informe a linha 1/5 da cartinha"

 @ l_s+04 ,c_s+02 GET  rmens2;
                  PICT "@!"
                  AJUDA "Mensagem 2"
                  CMDF8 "Informe a linha 2/5 da cartinha"

 @ l_s+05 ,c_s+02 GET  rmens3;
                  PICT "@!"
                  AJUDA "Mensagem 3"
                  CMDF8 "Informe a linha 3/5 da cartinha"

 @ l_s+06 ,c_s+02 GET  rmens4;
                  PICT "@!"
                  AJUDA "Mensagem 4"
                  CMDF8 "Informe a linha 4/5 da cartinha"

 @ l_s+07 ,c_s+02 GET  rmens5;
                  PICT "@!"
                  AJUDA "Mensagem 5"
                  CMDF8 "Informe a linha 5/5 da cartinha"

 @ l_s+08 ,c_s+12 GET  confirme;
                  PICT "!";
                  VALI CRIT("confirme= 'S'~CONFIRME n„o aceit vel|Digite S ou Tecle ESC")
                  AJUDA "Digite S para confirmar |ou|Tecle ESC para cancelar"

 READ
 SET KEY K_ALT_F8 TO
 IF rola_t
  ROLATELA(.f.)
  LOOP
 ENDI
 IF LASTKEY()=K_ESC                                // se quer cancelar
  RETU                                             // retorna
 ENDI

 SAVE TO PR101VAR ALL LIKE R*

 #ifdef COM_REDE
  IF !USEARQ("CIRCULAR",.f.,10,1)                  // se falhou a abertura do arq
   RETU                                            // volta ao menu anterior
  ENDI
 #else
  USEARQ("CIRCULAR")                               // abre o dbf e seus indices
 #endi

 titrel:=criterio := ""                            // inicializa variaveis
 cpord="grupo"
 chv_rela:=chv_1:=chv_2 := ""
 tps:=op_x:=ccop := 1
 fil_ini=""
 IF !opcoes_rel(lin_menu,col_menu,14,11,fil_ini)   // nao quis configurar...
  CLOS ALL                                         // fecha arquivos e
  LOOP                                             // volta ao menu
 ENDI
 IF tps=2                                          // se vai para arquivo/video
  arq_=ARQGER()                                    // entao pega nome do arquivo
  IF EMPTY(arq_)                                   // se cancelou ou nao informou
   LOOP                                            // retorna
  ENDI
 ELSE
  arq_=drvporta                                    // porta de saida configurada
 ENDI
 IF "4WIN"$UPPER(drvmarca) // nome da configuracao/marca impressora
   arq_:=drvdbf+"WIN"+ide_maq
   tps:=3                                         // se vai para arquivo/video
 ENDIF
 SET PRINTER TO (arq_)                             // redireciona saida
 EXIT
ENDD
cur_atual=SETCURSOR(0)
IF !EMPTY(drvtapg)                                 // existe configuracao de tam pag?
 op_=AT("NNN",drvtapg)                             // se o codigo que altera
 IF op_=0                                          // o tamanho da pagina
  msg="Configura‡„o do tamanho da p gina!"         // foi informado errado
  DBOX(msg,,,,,"ERRO!")                            // avisa
  CLOSE ALL                                        // fecha todos arquivos abertos
  RETU                                             // e cai fora...
 ENDI                                              // codigo para setar/resetar tam pag
 lpp_033=LEFT(drvtapg,op_-1)+"033"+SUBS(drvtapg,op_+3)
 lpp_066=LEFT(drvtapg,op_-1)+"066"+SUBS(drvtapg,op_+3)
ELSE
 lpp_033:=lpp_066 :=""                             // nao ira mudara o tamanho da pag
ENDI
criterio_=criterio                                 // salva criterio e ordenacao
cpord_=cpord                                       // definidos se huver
criterio=""

#ifdef COM_REDE
 IF !USEARQ("CPRCIRC",.f.,10,1)                    // se falhou a abertura do arq
  RETU                                             // volta ao menu anterior
 ENDI
#else
 USEARQ("CPRCIRC")                                 // abre o dbf e seus indices
#endi

cpord="grupo+circ+DTOS(dfal)"
criterio=""
INDTMP()
criterio=criterio_                                 // restabelece criterio e
cpord=cpord_                                       // ordenacao definidos
SELE CIRCULAR
dele_atu:=SET(_SET_DELETED,.t.)                    // os excluidos nao servem...
POE_GAUGE("[ESC] Interrompe","AGUARDE...","Emitidos:")
SET DEVI TO PRIN                                   // inicia a impressao
maxli=63
maxli=32                                           // maximo de linhas no relatorio
IMPCTL(lpp_033)                                    // seta pagina com 33 linhas
                                           // maximo de linhas no relatorio
SET MARG TO 1                                      // ajusta a margem esquerda
BEGIN SEQUENCE
 DO WHIL ccop<=nucop                               // imprime qde copias pedida
  pg_=1; cl=50000
  INI_ARQ()                                        // acha 1o. reg valido do arquivo
  IF EOF()
   EXIT
  ENDI
  ccop++                                           // incrementa contador de copias
  DO WHIL !EOF().AND.POE_GAUGE()
   IF IN_KEY()=K_ESC                               // se quer cancelar
    IF canc()                                      // pede confirmacao
     BREAK                                         // confirmou...
    ENDI
   ENDI
   IF grupo=M->rgrupo.AND.circ=M->rcirc            // se atender a condicao...
    IMPCTL(drvtcom)                               // comprime os dados
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY "Circular:"
    @ cl,012 SAY TRAN(M->rgrupo,"!!")+[-]+TRAN(M->rcirc,"999")              // Circular
    @ cl,031 SAY "Emissao:"
    @ cl,040 SAY TRAN(emissao_,"@D")               // Emiss„o
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY TRAN(M->rmens1,"@!")              // Mens1
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY TRAN(M->rmens2,"@!")              // Mens2
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY TRAN(M->rmens3,"@!")              // Mens3
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY TRAN(M->rmens4,"@!")              // Mens4
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY TRAN(M->rmens5,"@!")              // Mens5
    chv030=grupo+circ
    SELE CPRCIRC
    SEEK chv030
    IF FOUND()
     IF cl+3>maxli                                 // se cabecalho do arq filho
      REL_CAB(0)                                   // nao cabe nesta pagina
     ENDI                                          // salta para a proxima pagina
     IMPCTL(drvpcom)                                    // comprime os dados
     cl+=1                                         // soma contador de linha
     IMPAC("Contrato Processo    Falecido(a)                         Endere‡o                                           Data Fal",cl,000)
     cl+=1                                         // soma contador de linha
     @ cl,000 SAY "======== =========== =================================== ================================================== =========="
     DO WHIL ! EOF() .AND. chv030=LEFT(&(INDEXKEY(0)),LEN(chv030)).AND.POE_GAUGE()
      IF IN_KEY()=K_ESC                            // se quer cancelar
       IF canc()                                   // pede confirmacao
        BREAK                                      // confirmou...
       ENDI
      ENDI
      REL_CAB(1)                                   // soma cl/imprime cabecalho
      @ cl,001 SAY num                             // Contrato
      @ cl,009 SAY TRAN(processo,"@R 99999/99/!!") // Processo
      @ cl,021 SAY TRAN(fal,"@!")                  // Falecido(a)
      @ cl,057 SAY TRAN(ALLTRIM(ends)+[-]+ALLTRIM(cids),"@!")// Endere‡o
      @ cl,108 SAY TRAN(dfal,"@D")                 // Data Fal
      SKIP                                         // pega proximo registro
     ENDD
     cl++
     @ cl,000 SAY "======== =========== =================================== ================================================== =========="
     cl+=3                                         // soma contador de linha
    ENDI
    IMPCTL(drvtcom)                               // comprime os dados
    SELE CIRCULAR                                  // volta ao arquivo pai
    SKIP                                           // pega proximo registro
    cl=50000                                       // forca salto de pagina
   ELSE                                            // se nao atende condicao
    SKIP                                           // pega proximo registro
   ENDI
  ENDD
 ENDD ccop
 EJEC                                              // salta pagina
END SEQUENCE
SETCURSOR(cur_atual)
SET MARG TO                                        // coloca margem esquerda = 0
IMPCTL(lpp_066)                                    // seta pagina com 66 linhas
SET PRINTER TO (drvporta)                          // fecha arquivo gerado (se houver)
SET DEVI TO SCRE                                   // direciona saida p/ video
IF tps=2                                           // se vai para arquivo/video
 BROWSE_REL(arq_,2,3,MAXROW()-2,78)
ENDI          // mostra o arquivo gravado
GRELA(14)                                          // grava variacao do relatorio
SET(_SET_DELETED,dele_atu)                         // os excluidos serao vistos
RETU

STATIC PROC REL_CAB(qt)                            // cabecalho do relatorio
IF qt>0                                            // se parametro maior que 0
 cl=cl+qt                                          // soma no contador de linhas
ENDI
IF cl>maxli .OR. qt=0                              // quebra de pagina
 IMPCTL(drvtcom)                               // comprime os dados
 IMPAC(nemp,0,000)                                 // nome da empresa
 @ 0,070 SAY "PAG"
 @ 0,074 SAY TRAN(pg_,'9999')                      // n£mero da p gina
 IMPAC(nsis,1,000)                                 // t¡tulo aplica‡„o
 @ 1,027 SAY titrel                                // t¡tulo a definir
 @ 1,068 SAY "ADP_R101"                            // c¢digo relat¢rio
 @ 2,000 SAY "Relacao dos funerais efetuados (cartinha)"
 @ 2,058 SAY NSEM(DATE())                          // dia da semana
 @ 2,066 SAY DTOC(DATE())                          // data do sistema
 @ 3,000 SAY REPL("-",76)
 cl=qt+3 ; pg_++
ENDI
RETU

* \\ Final de ADP_R101.PRG
procedure prcessos
/*
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
 \ Empresa.: PresServ Inform tica - Limeira (019)452.6623
 \ Programa: PRCESSOS.PRG
 \ Data....: 04-11-03
 \ Sistema.: Administradora - RECEP€„O
 \ Funcao..: Gerenciador do subsistema de processos
 \ Analista: Ademilson Pedro Bom
 \ Criacao.: GAS-Pro v4.0n
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/

#include "adrbig.ch"    // inicializa constantes manifestas

PARA lin_menu,col_menu
PRIV op_sis, tela_fundo:=SAVESCREEN(0,0,MAXROW(),79), l_s, c_s, l_i, c_i, l_a

op_sis=EVAL(qualsis,"PRCESSOS")
IF nivelop<sistema[op_sis,O_OUTROS,O_NIVEL]        // se usuario nao tem permissao,
 ALERTA()                                          // entao, beep, beep, beep
 DBOX(msg_auto,,,3)                                // lamentamos e
 RETU                                              // retornamos ao menu
ENDI
cn:=fgrep :=.f.

#ifdef COM_LOCK
 IF LEN(pr_ok)>0                                   // se a protecao acusou
  ? pr_ok                                          // erro, avisa e
  QUIT                                             // encerra a aplicacao
 ENDI
#endi

t_fundo=SAVESCREEN(0,0,MAXROW(),79)                // salva tela do fundo
op_cad=1
DO WHIL op_cad!=0
 criterio=""
 RESTSCREEN(0,0,MAXROW(),79,t_fundo)               // restaura tela do fundo
 cod_sos=5 ; cn=.f.
 CLEA TYPEAHEAD                                    // limpa o buffer do teclado
 fgrep=.f.
 SET KEY K_F3 TO                                   // retira das teclas F3 e F4 as
 SET KEY K_F4 TO                                   // funcoes de repeticao e confirmacao
 msg="Consulta Individual~1|"+;
     "Consulta Global~2"
 op_cad=DBOX(msg,lin_menu,col_menu,E_MENU,NAO_APAGA,MAIUSC(sistema[op_sis,O_MENU]),,,op_cad)
 IF op_cad!=0                                      // se escolheu uma opcao
  Tela_fundo=SAVESCREEN(0,0,MAXROW(),79)           // salva a tela para ROLATELA()
  PARAMETROS(dbfparam)
  SELE A                                           // e abre o arquivo e seus indices

  #ifdef COM_REDE
   IF !USEARQ(sistema[op_sis,O_ARQUI,O_NOME],.f.,20,1)
                                                   // se falhou a abertura do
    RETU                                           // arquivo volta ao menu anterior
   ENDI
  #else
   USEARQ(sistema[op_sis,O_ARQUI,O_NOME])
  #endi

  SET KEY K_F9 TO veoutros                         // habilita consulta em outros arquivos
 ENDI
 DO CASE
  CASE op_cad=01                                   // consulta individual
   op_menu=ALTERACAO
   cod_sos=7
   EDIT()

  CASE op_cad=02                                   // consulta global
   op_menu=PROJECOES
   cod_sos=8
   EDITA(03,03,MAXROW()-2,77)

 ENDC
 SET KEY K_F9 TO                                   // F9 nao mais consultara outros arquivos
 CLOS ALL                                          // fecha todos arquivos abertos
ENDD
RETU

PROC PRC_incl(reg_cop)  // inclusao no arquivo PRCESSOS
LOCAL getlist:={}, cabem:=1, rep:=ARRAY(FCOU()), ult_reg:=RECN(),;
      ctl_r, ctl_c, ctl_w, t_f3_, t_f4_, dele_atu:=SET(_SET_DELETED,.f.)
PRIV op_menu:=INCLUSAO, tem_borda, criterio:="", cpord:=""
FOR i=1 TO FCOU()                                  // cria/declara privadas as
 msg=FIEL(i)                                       // variaveis de memoria com
 PRIV &msg.                                        // o mesmo nome dos campos
NEXT                                               // do arquivo
IF reg_cop!=NIL                                    // quer repetir todo o reg atual
 FOR i=1 TO FCOU()                                 // para cada campo,
  msg=FIEL(i)                                      // salva o conteudo
  rep[i]=&msg.                                     // para repetir
 NEXT
ELSE
 AFILL(rep,"")                                     // eche com valor vazio
ENDI
t_f3_=SETKEY(K_F3,{||rep()})                       // repeticao reg anterior
t_f4_=SETKEY(K_F4,{||conf()})                      // confirma campos com ENTER
ctl_w=SETKEY(K_CTRL_W,{||nadafaz()})               // enganando o CA-Clipper...
ctl_c=SETKEY(K_CTRL_C,{||nadafaz()})
ctl_r=SETKEY(K_CTRL_R,{||nadafaz()})
DO WHIL cabem>0
 rola_t=.f.                                        // flag se quer rolar a tela
 SELE PRCESSOS
 GO BOTT                                           // forca o
 SKIP                                              // final do arquivo
 
 /*
    cria variaveis de memoria identicas as de arquivo, para inclusao
    de registros
 */
 FOR i=1 TO FCOU()
  msg=FIEL(i)
  M->&msg.=IF((fgrep .OR. reg_cop!=NIL).AND.!EMPT(rep[1]),rep[i],&msg.)
 NEXT
 DISPBEGIN()                                       // apresenta a tela de uma vez so
 PRC_TELA()
 INFOSIS(.t.)                                      // exibe informacao no rodape' da tela
 DISPEND()
 cabem=DISKSPACE(;
          IF(;
             LEN(sistema[op_sis,O_ARQUI,O_DIR_DBF])<2.OR.sistema[op_sis,O_ARQUI,O_DIR_DBF]="\",;
             0,;
             ASC(sistema[op_sis,O_ARQUI,O_DIR_DBF])-64;
          );
       )
 cabem=INT((cabem-2048)/PRCESSOS->(RECSIZE()))
 IF cabem<1                                        // mais nenhum!!!
  ALERTA()
  msg="Verifique ESPA€O EM DISCO, "+usuario
  DBOX(msg,,,,,"INCLUSŽO INTERROMPIDA!")           // vamos parar por aqui!
  EXIT
 ENDI
 SELE 0                                            // torna visiveis variaveis de memoria
 SETCOLOR(drvcortel+","+drvcorget+",,,"+corcampo)
 SET KEY K_ALT_F8 TO ROLATELA
 
 /*
    recebe chaves do arquivo de indice basico
 */
 @ l_s+01 ,c_s+13 GET  processo;
                  PICT sistema[op_sis,O_CAMPO,01,O_MASC]
                  DEFINICAO 1

 @ l_s+02 ,c_s+13 GET  categ;
                  PICT sistema[op_sis,O_CAMPO,02,O_MASC]
                  DEFINICAO 2

 READ
 SET KEY K_ALT_F8 TO
 IF rola_t
  ROLATELA()
  LOOP
 ENDI
 SELE PRCESSOS
 IF LASTKEY()=K_ESC                                // cancelou ou chave em branco
  cabem=0                                          // prepara saida da inclusao
  LOOP                                             // volta p/ menu de cadastramento
 ENDI
 SEEK M->processo+M->categ
 aprov_reg_=(FOUND().AND.DELE().AND.!drvvisivel)   // vai aproveitar o registro?
 IF FOUND() .AND. !aprov_reg_                      // pesquisou e achou!
  op_menu=ALTERACAO                                // seta flag de ateracao
  DISPBEGIN()
  PRC_GETS()                                       // mostra conteudo do registro
  INFOSIS(.f.)                                     // exibe informacao no rodape' da tela
  DISPEND()
  ALERTA()
  msg="Consultar/alterar|Retornar … inclus„o"      // pergunta se deseja
  op_=DBOX(msg,,,E_MENU,,"REGISTRO J EXISTE")     // alterar o registro
  IF op_ =1                                        // caso afirmativo
   EDIT()                                          // deixa alterar
  ENDI
  op_menu=INCLUSAO
  LOOP                                             // volta para inclusao
 ENDI
 SELE 0
 PRC_GET1(INCLUI)                                  // recebe campos
 SELE PRCESSOS
 IF LASTKEY()=K_ESC                                // se cancelou
  ALERTA()                                         // avisa que o registro
  DBOX("Registro n„o inclu¡do!",18,,1)             // nao foi incluido, e volta
  LOOP
 ENDI

 #ifdef COM_REDE
  GO BOTT                                          // vamos bloquear o final do
  SKIP                                             // arq para que nehum outro
  BLOREG(0,.5)                                     // usuario possa incluir
  SEEK M->processo+M->categ                        // se registro foi incluido
  aprov_reg_=(FOUND().AND.DELE().AND.!drvvisivel)  // vai aproveitar o registro?
  IF FOUND() .AND. !aprov_reg_                     // por outro usuario, entao
   BLOREG(0,.5)
   FOR i=1 TO FCOU()
    msg=FIEL(i)
    rep[i]=&msg.
    REPL &msg. WITH M->&msg.
   NEXT
   PRC_GET1(FORM_INVERSA)                          // executa formula inversa
   RECA
   FOR i=1 TO FCOU()
    msg=FIEL(i)
    REPL &msg. WITH rep[i]
   NEXT
   ALERTA(4)                                       // beep 4 vezes
   msg="Registro acabou de ser|inclu¡do por outro usu rio!"
   DBOX(msg,,,,,"ATEN€ŽO!")                        // avisa
   SELE PRCESSOS
   UNLOCK                                          // libera o registro
   LOOP                                            // e recebe chave novamente
  ENDI
 #endi

 IF aprov_reg_                                     // se vai aproveitar reg excluido

  #ifdef COM_REDE
   BLOREG(0,.5)
  #endi

  RECA                                             // excluido, vamos recupera-lo
 ELSE                                              // caso contrario
  APPEND BLANK                                     // inclui reg em branco no dbf
 ENDI
 FOR i=1 TO FCOU()                                 // para cada campo,
  msg=FIEL(i)                                      // salva o conteudo
  rep[i]=M->&msg.                                  // para repetir
  REPL &msg. WITH rep[i]                           // enche o campo do arquivo
 NEXT

 #ifdef COM_REDE
  UNLOCK                                           // libera o registro e
  COMMIT                                           // forca gravacao
 #else
  IF RECC()-INT(RECC()/20)*20=0                    // a cada 20 registros
   COMMIT                                          // digitados forca gravacao
  ENDI
 #endi

 ult_reg=RECN()                                    // ultimo registro digitado
 IF reg_cop!=NIL                                   // estava na consulta e quis rep o campo
  EXIT                                             // cai fora...
 ENDI
ENDD
GO ult_reg                                         // para o ultimo reg digitado
SETKEY(K_F3,t_f3_)                                 // restaura teclas de funcoes
SETKEY(K_F4,t_f4_)
SET(_SET_DELETED,dele_atu)                            // ecluidos visiveis/invisiveis
SETKEY(K_CTRL_W,ctl_w)
SETKEY(K_CTRL_C,ctl_c)
SETKEY(K_CTRL_R,ctl_r)
RETU


PROC PRC_tela     // tela do arquivo PRCESSOS
tem_borda=.t.
l_s=Sistema[op_sis,O_TELA,O_LS]           // coordenadas da tela
c_s=Sistema[op_sis,O_TELA,O_CS]
l_i=Sistema[op_sis,O_TELA,O_LI]
c_i=Sistema[op_sis,O_TELA,O_CI]
SETCOLOR(drvtittel)
vr_memo=NOVAPOSI(@l_s,@c_s,@l_i,@c_i)     // pega posicao atual da tela
CAIXA(mold,l_s,c_s,l_i,c_i)               // monta caixa da tela
i=LEN(sistema[op_sis,O_MENS])/2
@ l_s,c_s-1+(c_i-c_s+1)/2-i SAY " "+MAIUSC(sistema[op_sis,O_MENS])+" "
SETCOLOR(drvcortel)
@ l_s+01,c_s+1 SAY " Processo.:"
@ l_s+02,c_s+1 SAY " Categoria:    (PL=Plano, PD=Plano c/Dif.,AF=Auxilio)"
@ l_s+03,c_s+1 SAY " Saiu.....:"
@ l_s+04,c_s+1 SAY " Contrato.:   /      / /"
@ l_s+05,c_s+1 SAY " Segurado.:"
@ l_s+06,c_s+1 SAY " Endere‡o.:"
@ l_s+07,c_s+1 SAY " Cidade...:"
@ l_s+08,c_s+1 SAY " Falecido.:"
@ l_s+09,c_s+1 SAY " Sepultam.:"
@ l_s+10,c_s+1 SAY " Data Fal.:"
RETU

PROC PRC_gets     // mostra variaveis do arquivo PRCESSOS
LOCAL getlist := {}
PRC_TELA()
SETCOLOR(drvcortel+","+drvcorget+",,,"+corcampo)
PTAB(NUM,'INSCRITS',1)
@ l_s+01 ,c_s+13 GET  processo;
                 PICT sistema[op_sis,O_CAMPO,01,O_MASC]

@ l_s+02 ,c_s+13 GET  categ;
                 PICT sistema[op_sis,O_CAMPO,02,O_MASC]

@ l_s+03 ,c_s+13 GET  saiu

@ l_s+04 ,c_s+13 GET  grup;
                 PICT sistema[op_sis,O_CAMPO,04,O_MASC]

@ l_s+04 ,c_s+16 GET  num;
                 PICT sistema[op_sis,O_CAMPO,05,O_MASC]

@ l_s+04 ,c_s+23 GET  grau;
                 PICT sistema[op_sis,O_CAMPO,06,O_MASC]

@ l_s+04 ,c_s+25 GET  seq;
                 PICT sistema[op_sis,O_CAMPO,07,O_MASC]

@ l_s+05 ,c_s+13 GET  seg;
                 PICT sistema[op_sis,O_CAMPO,08,O_MASC]

@ l_s+06 ,c_s+13 GET  ends;
                 PICT sistema[op_sis,O_CAMPO,09,O_MASC]

@ l_s+07 ,c_s+13 GET  cids;
                 PICT sistema[op_sis,O_CAMPO,10,O_MASC]

@ l_s+08 ,c_s+13 GET  fal;
                 PICT sistema[op_sis,O_CAMPO,11,O_MASC]

@ l_s+09 ,c_s+13 GET  sep;
                 PICT sistema[op_sis,O_CAMPO,12,O_MASC]

@ l_s+10 ,c_s+13 GET  dfal;
                 PICT sistema[op_sis,O_CAMPO,13,O_MASC]
                 CRIT(sistema[op_sis,O_CAMPO,13,O_CRIT],,"1")

CLEAR GETS
RETU

PROC PRC_get1(tp_mov)     // capta variaveis do arquivo PRCESSOS
LOCAL getlist := {}
PRIV  blk_prcessos:=.t.

IF tp_mov=INCLUI
 DO WHILE .t.
  rola_t=.f.
  SET KEY K_ALT_F8 TO ROLATELA
  SETCOLOR(drvcortel+","+drvcorget+",,,"+corcampo)
  @ l_s+03 ,c_s+13 GET  saiu
                   DEFINICAO 3

  @ l_s+04 ,c_s+13 GET  grup;
                   PICT sistema[op_sis,O_CAMPO,04,O_MASC]
                   DEFINICAO 4

  @ l_s+04 ,c_s+16 GET  num;
                   PICT sistema[op_sis,O_CAMPO,05,O_MASC]
                   DEFINICAO 5

  @ l_s+04 ,c_s+23 GET  grau;
                   PICT sistema[op_sis,O_CAMPO,06,O_MASC]
                   DEFINICAO 6

  @ l_s+04 ,c_s+25 GET  seq;
                   PICT sistema[op_sis,O_CAMPO,07,O_MASC]
                   DEFINICAO 7

  @ l_s+05 ,c_s+13 GET  seg;
                   PICT sistema[op_sis,O_CAMPO,08,O_MASC]
                   DEFINICAO 8

  @ l_s+06 ,c_s+13 GET  ends;
                   PICT sistema[op_sis,O_CAMPO,09,O_MASC]
                   DEFINICAO 9

  @ l_s+07 ,c_s+13 GET  cids;
                   PICT sistema[op_sis,O_CAMPO,10,O_MASC]
                   DEFINICAO 10

  @ l_s+08 ,c_s+13 GET  fal;
                   PICT sistema[op_sis,O_CAMPO,11,O_MASC]
                   DEFINICAO 11

  @ l_s+09 ,c_s+13 GET  sep;
                   PICT sistema[op_sis,O_CAMPO,12,O_MASC]
                   DEFINICAO 12

  @ l_s+10 ,c_s+13 GET  dfal;
                   PICT sistema[op_sis,O_CAMPO,13,O_MASC]
                   DEFINICAO 13
                   MOSTRA sistema[op_sis,O_FORMULA,1]

  READ
  SET KEY K_ALT_F8 TO
  IF rola_t
   ROLATELA()
   LOOP
  ENDI
  IF LASTKEY()!=K_ESC .AND. drvincl .AND. op_menu=INCLUSAO
   IF !CONFINCL()
    LOOP
   ENDI
  ENDI
  EXIT
 ENDD
ENDI
PTAB(GRUP,'ARQGRUP',1)
PTAB(NUM,'GRUPOS',1)
PTAB(NUM,'INSCRITS',1)
IF tp_mov=EXCLUI .OR. tp_mov=FORM_INVERSA
 IF !EMPTY(codlan) .AND. tp_mov=EXCLUI
  ALERTA()       // existe registro validado aqui!
  msg="Registro de Lan‡amento"
  DBOX(msg,,,,,"IMPOSS¡VEL EXCLUIR!")
 ELSE

  #ifdef COM_REDE
   IF saiu<'001'.AND.PTAB(grup,'ARQGRUP',1)
    REPBLO('ARQGRUP->procpend',{||ARQGRUP->procpend - 1})
   ENDI
   IF saiu<'001'.AND.PTAB(grup,'ARQGRUP',1)
    REPBLO('ARQGRUP->partic',{||ARQGRUP->partic + 1})
   ENDI
   IF PTAB(num,'GRUPOS',1)
    REPBLO('GRUPOS->funerais',{||GRUPOS->funerais - 1})
   ENDI
   IF PTAB(num,'GRUPOS',1)
    REPBLO('GRUPOS->particv',{||GRUPOS->particv + 1})
   ENDI
   IF PTAB(num,'GRUPOS',1)
    REPBLO('GRUPOS->particf',{||GRUPOS->particf - 1})
   ENDI
   IF PTAB(num+grau+STR(seq,03,00),'INSCRITS',1)
    REPBLO('INSCRITS->vivofalec',{||[V]})
   ENDI
   IF PTAB(num+grau+STR(seq,03,00),'INSCRITS',1)
    REPBLO('INSCRITS->falecto_',{||ctod('  /  /  ')})
   ENDI
   IF PTAB(num+grau+STR(seq,03,00),'INSCRITS',1)
    REPBLO('INSCRITS->tipo',{||[  ]})
   ENDI
   IF PTAB(num+grau+STR(seq,03,00),'INSCRITS',1)
    REPBLO('INSCRITS->procnr',{||[ ]})
   ENDI
  #else
   IF saiu<'001'.AND.PTAB(grup,'ARQGRUP',1)
    REPL ARQGRUP->procpend WITH ARQGRUP->procpend - 1
   ENDI
   IF saiu<'001'.AND.PTAB(grup,'ARQGRUP',1)
    REPL ARQGRUP->partic WITH ARQGRUP->partic + 1
   ENDI
   IF PTAB(num,'GRUPOS',1)
    REPL GRUPOS->funerais WITH GRUPOS->funerais - 1
   ENDI
   IF PTAB(num,'GRUPOS',1)
    REPL GRUPOS->particv WITH GRUPOS->particv + 1
   ENDI
   IF PTAB(num,'GRUPOS',1)
    REPL GRUPOS->particf WITH GRUPOS->particf - 1
   ENDI
   IF PTAB(num+grau+STR(seq,03,00),'INSCRITS',1)
    REPL INSCRITS->vivofalec WITH [V]
   ENDI
   IF PTAB(num+grau+STR(seq,03,00),'INSCRITS',1)
    REPL INSCRITS->falecto_ WITH ctod('  /  /  ')
   ENDI
   IF PTAB(num+grau+STR(seq,03,00),'INSCRITS',1)
    REPL INSCRITS->tipo WITH [  ]
   ENDI
   IF PTAB(num+grau+STR(seq,03,00),'INSCRITS',1)
    REPL INSCRITS->procnr WITH [ ]
   ENDI
  #endi

  IF !EMPTY(ALIAS())
   DELE
  ENDI
 ENDI
ELSEIF tp_mov=INCLUI .OR. tp_mov=RECUPERA .OR. tp_mov=FORM_DIRETA
 IF (op_menu=INCLUSAO .AND. LASTKEY()!=K_ESC) .OR. op_menu!=INCLUSAO
  IF !EMPTY(codlan) .AND. tp_mov=RECUPERA
   ALERTA()      // existe registro validado aqui!
   msg="Registro de Lan‡amento"
   DBOX(msg,,,,,"IMPOSS¡VEL RECUPERAR!")
  ELSE

   #ifdef COM_REDE
    IF saiu<'001'.AND.PTAB(grup,'ARQGRUP',1)
     REPBLO('ARQGRUP->procpend',{||ARQGRUP->procpend + 1})
    ENDI
    IF saiu<'001'.AND.PTAB(grup,'ARQGRUP',1)
     REPBLO('ARQGRUP->partic',{||ARQGRUP->partic - 1})
    ENDI
    IF PTAB(num,'GRUPOS',1)
     REPBLO('GRUPOS->funerais',{||GRUPOS->funerais + 1})
    ENDI
    IF PTAB(num,'GRUPOS',1)
     REPBLO('GRUPOS->particv',{||GRUPOS->particv - 1})
    ENDI
    IF PTAB(num,'GRUPOS',1)
     REPBLO('GRUPOS->particf',{||GRUPOS->particf + 1})
    ENDI
    IF PTAB(num+grau+STR(seq,03,00),'INSCRITS',1)
     REPBLO('INSCRITS->vivofalec',{||[F]})
    ENDI
    IF PTAB(num+grau+STR(seq,03,00),'INSCRITS',1)
     REPBLO('INSCRITS->falecto_',{||dfal})
    ENDI
    IF PTAB(num+grau+STR(seq,03,00),'INSCRITS',1)
     REPBLO('INSCRITS->tipo',{||categ})
    ENDI
    IF PTAB(num+grau+STR(seq,03,00),'INSCRITS',1)
     REPBLO('INSCRITS->procnr',{||processo})
    ENDI
   #else
    IF saiu<'001'.AND.PTAB(grup,'ARQGRUP',1)
     REPL ARQGRUP->procpend WITH ARQGRUP->procpend + 1
    ENDI
    IF saiu<'001'.AND.PTAB(grup,'ARQGRUP',1)
     REPL ARQGRUP->partic WITH ARQGRUP->partic - 1
    ENDI
    IF PTAB(num,'GRUPOS',1)
     REPL GRUPOS->funerais WITH GRUPOS->funerais + 1
    ENDI
    IF PTAB(num,'GRUPOS',1)
     REPL GRUPOS->particv WITH GRUPOS->particv - 1
    ENDI
    IF PTAB(num,'GRUPOS',1)
     REPL GRUPOS->particf WITH GRUPOS->particf + 1
    ENDI
    IF PTAB(num+grau+STR(seq,03,00),'INSCRITS',1)
     REPL INSCRITS->vivofalec WITH [F]
    ENDI
    IF PTAB(num+grau+STR(seq,03,00),'INSCRITS',1)
     REPL INSCRITS->falecto_ WITH dfal
    ENDI
    IF PTAB(num+grau+STR(seq,03,00),'INSCRITS',1)
     REPL INSCRITS->tipo WITH categ
    ENDI
    IF PTAB(num+grau+STR(seq,03,00),'INSCRITS',1)
     REPL INSCRITS->procnr WITH processo
    ENDI
   #endi

   IF op_menu!=INCLUSAO
    RECA
   ENDI
  ENDI
 ENDI
ENDI
RETU

* \\ Final de PRCESSOS.PRG
/*
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
 \ Empresa.: Ind£stria de Urnas Bignotto Ltda
 \ Programa: CON_R001.PRG
 \ Data....: 15-05-97
 \ Sistema.: Controle de Convˆnios
 \ Funcao..: Emiss„o Guias 1¦ Parte
 \ Analista: Ademilson Pedro Bom
 \ Criacao.: GAS-Pro v3.0
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/

#include "adrbig.ch"    // inicializa constantes manifestas

LOCAL dele_atu, getlist:={}, so_um_reg, sit_dbf:=POINTER_DBF()
PARA  lin_menu, col_menu, imp_reg
PRIV  tem_borda:=.t., op_menu:=VAR_COMPL, l_s:=11, c_s:=20, l_i:=14, c_i:=61, tela_fundo:=SAVESCREEN(0,0,MAXROW(),79)
nucop=1
so_um_reg=(PCOU()>2)
IF !so_um_reg                             // vai receber a variaveis?
 SETCOLOR(drvtittel)
 vr_memo=NOVAPOSI(@l_s,@c_s,@l_i,@c_i)    // pega posicao atual da tela
 CAIXA(mold,l_s,c_s,l_i,c_i)              // monta caixa da tela
 @ l_s,c_s+12 SAY " EMISSŽO DE GUIAS "
 SETCOLOR(drvcortel)
 @ l_s+01,c_s+1 SAY " N£mero:"
ENDI
gnumero=SPAC(8)                                    // N£mero
DO WHILE .t.
 rola_t=.f.
 cod_sos=56
 IF !so_um_reg
  SET KEY K_ALT_F8 TO ROLATELA
  SETCOLOR(drvcortel+","+drvcorget+",,,"+corcampo)
  @ l_s+01 ,c_s+10 GET  gnumero;
		   PICT "@R 99-999999";
		   VALI CRIT("PTAB(gnumero,'GUIAS',1).AND.V00101F9()~N£MERO n„o existe na tabela")
		   DEFAULT "IIF(PTAB(PADR(SUBSTR(M->ide_maq,2),4)+[GUI],[IMPPAR],1),ALLTRIM(IMPPAR->docto),[])"
		   AJUDA "Emitir a guia de n£mero?"
		   CMDF8 "VDBF(6,8,20,77,'GUIAS',{'numero','contrato','nome'},1,'numero')"
		   MOSTRA {"LEFT(TRAN(GUIAS->nome,[@!]),35)", 2 , 5 }

  READ
  SET KEY K_ALT_F8 TO
  IF rola_t
   ROLATELA(.f.)
   LOOP
  ENDI
  IF LASTKEY()=K_ESC                               // se quer cancelar
   RETU                                            // retorna
  ENDI
 ENDI

 #ifdef COM_REDE
  IF !USEARQ("GUIAS",.f.,10,1)                     // se falhou a abertura do arq
   RETU                                            // volta ao menu anterior
  ENDI
 #else
  USEARQ("GUIAS")                                  // abre o dbf e seus indices
 #endi

 PTAB(medico,"MEDICOS",1,.t.)                      // abre arquivo p/ o relacionamento
 PTAB(contrato,"GRUPOS",1,.t.)                      // abre arquivo p/ o relacionamento
 PTAB(GRUPOS->tipcont,"CLASSES",1,.t.)                      // abre arquivo p/ o relacionamento
 SET RELA TO medico INTO MEDICOS                 // relacionamento dos arquivos

 titrel:=criterio:=cpord := ""                     // inicializa variaveis
 titrel:=chv_rela:=chv_1:=chv_2 := ""
 tps:=op_x:=ccop := 1
 arq_=drvporta                                     // porta de saida configurada
 IF !so_um_reg
  IF !opcoes_rel(lin_menu,col_menu,7,11)           // nao quis configurar...
   CLOS ALL                                        // fecha arquivos e
   LOOP                                            // volta ao menu
  ENDI

 #ifdef COM_REDE

  ELSE

   tps=lin_menu

 #endi

 ENDI
 IF tps=2                                          // se vai para arquivo/video
  arq_=ARQGER()                                    // entao pega nome do arquivo
  IF EMPTY(arq_)                                   // se cancelou ou nao informou
   LOOP                                            // retorna
  ENDI
 ELSE
  arq_=drvporta                                    // porta de saida configurada
 ENDI
 SET PRINTER TO (arq_)                             // redireciona saida
 EXIT
ENDD
IF !EMPTY(drvtapg)                                 // existe configuracao de tam pag?
 op_=AT("NNN",drvtapg)                             // se o codigo que altera
 IF op_=0                                          // o tamanho da pagina
  msg="Configura‡„o do tamanho da p gina!"         // foi informado errado
  DBOX(msg,,,,,"ERRO!")                            // avisa
  CLOSE ALL                                        // fecha todos arquivos abertos
  RETU                                             // e cai fora...
 ENDI                                              // codigo para setar/resetar tam pag
 lpp_024=LEFT(drvtapg,op_-1)+"033"+SUBS(drvtapg,op_+3)
 lpp_066=LEFT(drvtapg,op_-1)+"066"+SUBS(drvtapg,op_+3)
ELSE
 lpp_024:=lpp_066 :=""                             // nao ira mudara o tamanho da pag
ENDI
DBOX("[ESC] Interrompe",15,,,NAO_APAGA)
dele_atu:=SET(_SET_DELETED,.t.)                    // os excluidos nao servem...
SET DEVI TO PRIN                                   // inicia a impressao
maxli=17                                           // maximo de linhas no relatorio
IMPCTL(lpp_024)                                    // seta pagina com 24 linhas
SET MARG TO 1                                      // ajusta a margem esquerda
IF tps=2
 IMPCTL("' '+CHR(8)")
ENDI
BEGIN SEQUENCE
 DO WHIL ccop<=nucop				// imprime qde copias pedida
  pg_=1; cl=999
  IF so_um_reg
   GO imp_reg
  ELSE
   INI_ARQ()                                       // acha 1o. reg valido do arquivo
   IF PTAB(PADR(SUBSTR(M->ide_maq,2),4)+[GUI],[IMPPAR],1)
    SEEK ALLTRIM(IMPPAR->docto)
   ENDI
  ENDI
  ccop++                                           // incrementa contador de copias
  ult_imp=0                                        // ultimo reg impresso
  DO WHIL !EOF().AND.(!so_um_reg.OR.imp_reg=RECN())
   #ifdef COM_TUTOR
    IF IN_KEY()=K_ESC                              // se quer cancelar
   #else
    IF INKEY()=K_ESC                               // se quer cancelar
   #endi
    IF canc()                                      // pede confirmacao
     BREAK                                         // confirmou...
    ENDI
   ENDI
   IF (PTAB(PADR(SUBSTR(M->ide_maq,2),4)+[GUI],[IMPPAR],1).AND.numero=LEFT(IMPPAR->docto,7)) .OR. so_um_reg// se atender a condicao...
    PTAB(contrato,"GRUPOS",1,.t.)                      // abre arquivo p/ o relacionamento
    PTAB(GRUPOS->tipcont,"CLASSES",1,.t.)                      // abre arquivo p/ o relacionamento

    REL_CAB(1,.t.)                                 // soma cl/imprime cabecalho
    @ cl,000 SAY "GUIA DE IDENTIFICACAO  N§:"
    @ cl,027 SAY numero   // N£mero
//    @ cl,043 SAY IIF(guiapara='C',[Consulta],IIF(guiapara='E',[Exame],IIF(guiapara='I',[Interna‡„o],[     ])))// Guia Para
    IF M->combarra=[S]
     CODBARRAS({{numero+GDV1(numero),4,10,64}},10,6)
    ENDI
    ult_imp=RECNO()                                // ultimo reg impresso
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY "Para:"
    @ cl,008 SAY TRAN(MEDICOS->oldespec,"@!")    // Especialidade
    IF M->combarra=[S]
     CODBARRAS({{numero+GDV1(numero),4,10,64}},10,6)
    ENDI
    REL_CAB(2)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY "Nome ..................:"
    @ cl,025 SAY ALLTRIM(MEDICOS->nome)+[ (]+ALLTRIM(medico)+[) ]+;// M‚dico
		 [ tel: ]+ ALLTRIM(MEDICOS->fonesdiv)
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    IMPAC("Endere‡o...............:",cl,000)
    @ cl,025 SAY MEDICOS->endereco// Endere‡o
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY "Data...................:"
    @ cl,025 SAY TRAN(data,"@D")               // Emiss„o
    IMPAC("(V lido at‚ 30 dias)",cl,036)
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    IMPAC("Benefici rio principal.:",cl,000)
    @ cl,025 SAY TRAN([ (]+ALLTRIM(GRUPOS->nome)+[ / ]+ALLTRIM(contrato)+[)],"@!")+;// Titular
	 [ ] +&drvpcom+ALLTRIM(CLASSES->descricao)+&drvtcom
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY "Benefici rio..........:"
    IMPCTL(drvpenf)
    @ cl,025 SAY TRAN(nome,"@!")                   // Nome
    IMPCTL(drvtenf)
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY REPL("-",60)
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    SKIP                                           // pega proximo registro
    cl=999                                         // forca salto de pagina
   ELSE                                            // se nao atende condicao
    SKIP                                           // pega proximo registro
   ENDI
   exit
  ENDD
  REL_RDP(.t.)                                     // imprime rodape' do relatorio
 ENDD ccop
 EJEC                                              // salta pagina
END SEQUENCE
SET MARG TO                                        // coloca margem esquerda = 0
IMPCTL(lpp_066)                                    // seta pagina com 66 linhas
SET PRINTER TO (drvporta)                          // fecha arquivo gerado (se houver)
SET DEVI TO SCRE                                   // direciona saida p/ video
IF tps=2                                           // se vai para arquivo/video
 BROWSE_REL(arq_,2,3,MAXROW()-2,78)
ENDI                                               // mostra o arquivo gravado
GRELA(7)                                           // grava variacao do relatorio
SELE GUIAS                                         // salta pagina
SET RELA TO                                        // retira os relacionamentos
SET(_SET_DELETED,dele_atu)                         // os excluidos serao vistos
IF so_um_reg
 POINTER_DBF(sit_dbf)
ENDI
RETU

STATIC PROC REL_RDP(volta_reg)                     // rodape'
LOCAL reg_atual:=RECNO()
IF volta_reg
 GO ult_imp                                        // ajusta reg p/ imp de campos no rodape'
ENDI
@ 16,000 SAY "" //chr(15)                               // comprime
IMPCTL(drvpcom)
@ 16,002 SAY [IMPORTANTE:- Esta guia tem a finalidade principal de identificar o benefici rio em dia, ou seja,]// Mensagem 1
@ 17,002 SAY [sem pendencias, n„o sendo cobrado nenhum valor pela sua emiss„o.]// Mensagem 2
@ 18,002 SAY [ - Esta guia s¢ ter  validade com o carimbo e assinatura do respons vel pela emiss„o.]// Mensagem 4
@ 19,002 SAY [ ] //A BOM PASTOR n„o se responsabiliza por procedimentos medicos e outros, visto ser de]
@ 20,002 SAY [ ] //  livre escolha do associado.]
@ 21,000 SAY "" //chr(18)                               // normal
IMPCTL(drvtcom)
@ 22,060 SAY [FR-OPE-0017]
@ 23,001 SAY replicate('- ',36)                    // traco
IF volta_reg
 GO reg_atual                                      // retorna reg a posicao original
ENDI
RETU

STATIC PROC REL_CAB(qt, volta_reg)                 // cabecalho do relatorio
volta_reg=IF(volta_reg=NIL,.f.,volta_reg)
IF qt>0                                            // se parametro maior que 0
 cl=cl+qt                                          // soma no contador de linhas
ENDI
IF cl>maxli .OR. qt=0                              // quebra de pagina
 IF pg_>1
  REL_RDP(volta_reg)                               // imprime rodape' do relatorio
 ENDI
 IMPCTL(drvpenf)
 IMPEXP(0,000,LEFT(M->setup1,38),76)               // Setup1
 IMPCTL(drvtenf)
// @ 1,000 SAY M->defconv                            // Defconv
 @ 2,000 SAY M->setup2                             // setup2
 @ 3,000 SAY M->setup3                             // Setup3
 @ 4,000 SAY REPL("-",60)
 cl=qt+4 ; pg_++
ENDI
RETU

* \\ Final de CON_R001.PRG
FUNC R001GF9
RETURN numero
€ GUIASû–S GUIASCODEGUI_INCLCODEGUI_RELCODE
GUI_ANT_SECODE
GUI_CRIA_SCODE
GUI_GERA_SCODE
GUI_GRAVA_CODEGUI_TELACODEGUI_GETSCODEGUI_GET1CODEC_ETEXTENDCODE	_SYMSTARTSYMSTARTSYMBOLSSYMBOLS_SYMENDSYMENDNULLBEGDATA_DATADATA_SYMPBDATA_SYMPDATA_SYMPEDATA_CONSTCONST_MSGMSG_BEGBSSBEGBSS_BSSBSS_ENDBSSENDBSSDGROUP«˜ @ó&˜ @ÎE˜ @à 3˜ @| 	“˜ @G
Ã˜ @˜ @2 Ñ˜ @ç˜ @Û˜ @”]˜ H  ë˜ h  Ç˜ ``€
 R02901F9¡–Ñ  R02901F9CODEC_ETEXTENDCODE	_SYMSTARTSYMSTARTSYMBOLSSYMBOLS_SYMENDSYMENDNULLBEGDATA_DATADATA_SYMPBDATA_SYMPDATA_SYMPEDATA_CONSTCONST_MSGMSG_BEGBSSBEGBSS_BSSBSS_ENDBSSENDBSSDGROUP`˜ @ƒ–˜ H  ˜ h  ë˜ `  	O˜ h  
ã˜ h  ß˜ H  û˜ H  ÷˜ H ë˜ H  ï˜ H  ë˜ (  ˜ H  /*
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
 \ Empresa.: Funer ria GULLO Ltda.
 \ Programa: ADM_PUBL.CH
 \ Data....: 21-04-95
 \ Sistema.: Controle de Processos da Funer ria.
 \ Funcao..: Define vari veis p£blicas
 \ Analista: Ademilson Pedro Bom
 \ Criacao.: Programado manualmente pelo analista
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/
tbestciv   :=[SOlteiro   |CAsado     |VIuvo      |DEsquitado |OUtro      |IGnorado   |JUdici.sep.|COncens.sep]
tbestcivf  :=[SOlteira   |CAsada     |VIuva      |DEsquitada |OUtro      |IGnorado   |JUdici.sep.|COncens.sep]
tbsexo     :=[Masculino  |Feminino   |Ignorado   ]
tbgrauinstr:=[Nenhuma    |Fundamental|2§ grau    |Superior   |Ignorado   ]
tbtipgrau  :=[1-Titular|2-Pai|3-M„e|4-Sogro|5-Sogra|6-Esposa|7-Filhos|8-Depend.]
tbtipidade:=[ANos |MEses|DIas |HOras|MInut]
tbunid:=[UN=Unidade|CX=Caixa  |MT=Metro  |KG=Quilo  |LT=Litro ]
tbfpgto:=[Mensal       Bimestral    Trimestral   Quadrimestral]
SET EPOCH TO 1920          // prepara datas para o terceiro milˆnio

#ifdef COM_CALE
 SET KEY K_F5 TO cale      // F5 ativa calendario
#endi

#ifdef COM_MAQCALC
 SET KEY K_F6 TO maqcalc   // F6 ativa calculadora
 nu_calc=0.00; fgint = .f.
#endi

* \\ Final de ADM_PUBL.CH
GAS-Pro v4.0
PresServ Inform tica - Limeira (019)452.6623
Administradora - RECEP€„O
Ademilson Pedro Bom
 2 
 0 
15776136703598822960













-1 
-1 
 0 
-1 
-1 
-1 
-1 
-1 
-1 
-1 
-1 
 0 
-1 
-1 
-1 
 0 
 0 
 2 
 0 
-1 
 1 
 0 
 2 
-1 
 1 
 0 
 1 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
ADMINISTRADORA - RECEP€ŽO~~0000310000000000
 ÃÄê Lan‡amentos~~0100410000000000
÷³   ÃÄá Recebimentos~~0200510000000000BXREC.ATRÿÿÿ0ÿÿ1ÿ0
÷³   ÃÄá Endere‡os~~0200510000000000ALENDER.ATRÿÿÿ0ÿÿ1ÿ0
÷³   ÃÄá Outros Recebimentos~~0200510000000000OBXEC.ATRÿÿÿ0ÿÿ1ÿ0
÷³   ÃÄá Consulta Contratos~~0200510000000000GRUPOS.ATRÿÿÿ0ÿÿ1ÿ0
 ³   ³   ÃÄá Taxas~~0200510000000000TAXAS.ATRÿÿÿ0ÿÿ1ÿ0
 ³   ³   ÃÄá Outros Endere‡os~~0200510000000000ECOB.ATRÿÿÿ0ÿÿ1ÿ0
 ³   ³   ÀÄá Inscritos~~0200510000000000INSCRITS.ATRÿÿÿ0ÿÿ1ÿ0
÷³   ÀÄá Emiss„o de Guias~~0200510000000000GUIAS.ATRÿÿÿ0ÿÿ1ÿ0
 ÃÄê A.Funeral~~0100410000000000
÷³   ÃÄá Lan‡amento Aux.Funeral~~0200510000000000AFUNER.ATRÿÿÿ0ÿÿ1ÿ0
÷³   ÃÄå Impress„o Modelo 1~~0501110000000000ADM_R020.REL
÷³   ÃÄå Recibo Modelo 1~~0501110000000000ADR_R029.REL
÷³   ÃÄå Impress„o Modelo 2~~0501110000000000ADM_RX20.REL
÷³   ÃÄå Recibo Modelo 2~~0501110000000000ADR_RX29.REL
÷³   ÃÄå Relat¢rio de Processo~~0501110000000000ADM_R029.REL
÷³   ÃÄå Capa de Processo~~0501110000000000ADM_R026.REL
÷³   ÀÄå Processar Pgto em~~0501110000000000ADM_R021.REL
 ÃÄê Relat¢rios~~0100410000000000
÷³   ÃÄä Documento … Imprimir~~3700110000000000DCI_P001.GLO
 ³   ³   ÀÄä Processar~~3600110000000000DCI_P002.GLO
÷³   ÃÄå Recibos (2¦via)~~0501110000000000ADM_RS18.RELÿÿÿ0ÿÿ1ÿ1
÷³   ÃÄå Outros recibos (2¦Via)~~0501110000000000ADM_R023.RELÿÿÿ1ÿÿ1ÿ1
÷³   ÃÄå Endere‡os Alterados~~0501110000000000ADM_R022.REL
 ³   ÃÄâ Emissao de guia~~0300110000000000CON_RX01.PRGÿÿÿ0ÿÿ1ÿ0
÷³   ÀÄå Fechamento Caixa~~0501110000000000ADM_R039.REL
 ³       ÀÄå Taxas p/Transferir~~0501110000000000ADM_R040.REL
 ÃÄê Tabelas~~0100410000000000
÷³   ÃÄá Documento … Imprimir~~0200510000000000IMPPAR.ATR
÷³   ÃÄá Credenciados~~0200510000000000MEDICOS.ATRÿÿÿ0ÿÿ1ÿ0
÷³   ÃÄá Especialidades~~0200510000000000TESPEC.ATR
÷³   ÃÄá Parƒmetro de Juros~~0200510000000000JUROS.ATR
÷³   ÃÄá Filiais~~0200510000000000TFILIAIS.ATR
÷³   ÃÄá Grupos~~0200510000000000ARQGRUP.ATR
 ³   ÃÄê Tabelas Secund rias~~0100410000000000
÷³   ³   ÃÄá Regi”es~~0200510000000000REGIAO.ATR
÷³   ³   ÃÄá Cobradores/Vendedores~~0200510000000000COBRADOR.ATR
÷³   ³   ÃÄá Categoria dos Planos~~0200510000000000CLASSES.ATR
÷³   ³   ÃÄá Circulares~~0200510000000000CIRCULAR.ATR
 ³   ³   ³   ÀÄá Processos da Circular~~0200510000000000CPRCIRC.ATR
÷³   ³   ÃÄá Processos~~0200510000000000PRCESSOS.ATR
÷³   ³   ÃÄá Funcion rios~~0200510000000000FNCS.ATR
÷³   ³   ÃÄá Hist¢rico Padr„o~~0200510000000000HISTORIC.ATR
÷³   ³   ÃÄá Custos Adicionais~~0200510000000000CSTSEG.ATR
÷³   ³   ÀÄá Mensagem p/Contrato~~0200510000000000MENSAG.ATR
÷³   ÀÄá Caixas~~0200510000000000ORDPGRC.ATRÿÿÿ0ÿÿ1ÿ1
 ÀÄà Apoio~~0800910000000000
÷    ÃÄá Parƒmetros~~0705410000000000PAR_ADM.ATR
     ÃÄà Vˆ relat¢rio gravado~~1500110000000000
     ÃÄà Reconstr¢i ¡ndices~~1103910000000000
     ÃÄà Elimina reg apagados~~1204010000000000
     ÃÄà Configura ambiente~~1304110000000000
     ³   ÃÄà Diret¢rio de trabalho~~1800210000000000
     ³   ÃÄà Marca da impressora~~1404210000000000
     ³   ÃÄà Pano de fundo~~1604310000000000
     ³   ÃÄà Fontes de caracteres~~3105310000000000
     ³   ÃÄà Esquemas de cores~~1704410000000000
     ³   ÃÄà Confirma em campos~~1900010000000000
     ³   ÃÄà Confirma exclus”es~~2000010000000000
     ³   ÃÄà Confirma inclus”es~~3200010000000000
     ³   ÃÄà Excluidos vis¡veis~~3300010000000000
     ³   ÃÄà Ajuda de campo ativa~~2200010000000000ÿÿÿ0ÿÿ1ÿ1
     ³   ÃÄà Liga/desliga mouse~~2300010000000000
     ³   ÀÄà Sensibilidade mouse~~2404510000000000
     ÃÄà Plano de senhas~~2501710000000000
     ÀÄâ Sobre...~~0300110000000000ABOUT.PRG
GAS-Pro v3.0

[Ÿ]
 9 
TAXAS
Consulta Taxas



008









-1 
 1 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
Codigo
codigo
999999
 6 

 0 
 0 













Tipo
tipo
!
 1 

 0 
 0 













Circular
circ
999
 3 

 0 
 0 













Emissao
emissao_
@D
 8 

 0 
 0 













Valor
valor
@E 999,999.99
 10 

 0 
 0 













Pagamento
pgto_
@D
 8 

 0 
 0 













Valor pago
valorpg
@E 999,999.99
 10 

 0 
 0 













Cobrador
cobrador
!!
 2 

 0 
 0 













Forma
forma
!
 1 

 0 
 0 













 0 
 0 
 0 
 0 
 1 
GRUPOS
 1 
codigo



@echo off
REM - programa para preparar a execu‡„o/grava‡„o de tutorial
REM - (apaga *.DB*, *.NTX, *.SYS e consultas gravadas)
echo 
echo                       A T E N € Ž O !
echo Os arquivos de dados do sistema "ADMINISTRADORA - RECEP€ŽO" ser„o
echo eliminados para execu‡„o da macro. Se desejar cancelar esta opera‡„o
echo pressione CTRL-C AGORA!
PAUSE >NUL
if exist BXREC.DB* DEL BXREC.DB*
if exist BXR*..PRG DEL BXR*.NTX
if exist DB*.BXR DEL DB*.BXR
if exist ALENDER.DB* DEL ALENDER.DB*
if exist ALE*..PRG DEL ALE*.NTX
if exist DB*.ALE DEL DB*.ALE
if exist OBXEC.DB* DEL OBXEC.DB*
if exist OBX*..PRG DEL OBX*.NTX
if exist DB*.OBX DEL DB*.OBX
if exist GRUPOS.DB* DEL GRUPOS.DB*
if exist GRU*..PRG DEL GRU*.NTX
if exist DB*.GRU DEL DB*.GRU
if exist TAXAS.DB* DEL TAXAS.DB*
if exist TAX*..PRG DEL TAX*.NTX
if exist DB*.TAX DEL DB*.TAX
if exist ECOB.DB* DEL ECOB.DB*
if exist ECO*..PRG DEL ECO*.NTX
if exist DB*.ECO DEL DB*.ECO
if exist INSCRITS.DB* DEL INSCRITS.DB*
if exist INS*..PRG DEL INS*.NTX
if exist DB*.INS DEL DB*.INS
if exist GUIAS.DB* DEL GUIAS.DB*
if exist GUI*..PRG DEL GUI*.NTX
if exist DB*.GUI DEL DB*.GUI
if exist AFUNER.DB* DEL AFUNER.DB*
if exist AFU*..PRG DEL AFU*.NTX
if exist DB*.AFU DEL DB*.AFU
if exist IMPPAR.DB* DEL IMPPAR.DB*
if exist IMP*..PRG DEL IMP*.NTX
if exist DB*.IMP DEL DB*.IMP
if exist MEDICOS.DB* DEL MEDICOS.DB*
if exist MED*..PRG DEL MED*.NTX
if exist DB*.MED DEL DB*.MED
if exist TESPEC.DB* DEL TESPEC.DB*
if exist TES*..PRG DEL TES*.NTX
if exist DB*.TES DEL DB*.TES
if exist JUROS.DB* DEL JUROS.DB*
if exist JUR*..PRG DEL JUR*.NTX
if exist DB*.JUR DEL DB*.JUR
if exist TFILIAIS.DB* DEL TFILIAIS.DB*
if exist TFI*..PRG DEL TFI*.NTX
if exist DB*.TFI DEL DB*.TFI
if exist ARQGRUP.DB* DEL ARQGRUP.DB*
if exist ARQ*..PRG DEL ARQ*.NTX
if exist DB*.ARQ DEL DB*.ARQ
if exist REGIAO.DB* DEL REGIAO.DB*
if exist REG*..PRG DEL REG*.NTX
if exist DB*.REG DEL DB*.REG
if exist COBRADOR.DB* DEL COBRADOR.DB*
if exist COB*..PRG DEL COB*.NTX
if exist DB*.COB DEL DB*.COB
if exist CLASSES.DB* DEL CLASSES.DB*
if exist CLA*..PRG DEL CLA*.NTX
if exist DB*.CLA DEL DB*.CLA
if exist CIRCULAR.DB* DEL CIRCULAR.DB*
if exist CIR*..PRG DEL CIR*.NTX
if exist DB*.CIR DEL DB*.CIR
if exist CPRCIRC.DB* DEL CPRCIRC.DB*
if exist CPR*..PRG DEL CPR*.NTX
if exist DB*.CPR DEL DB*.CPR
if exist PRCESSOS.DB* DEL PRCESSOS.DB*
if exist PRC*..PRG DEL PRC*.NTX
if exist DB*.PRC DEL DB*.PRC
if exist FNCS.DB* DEL FNCS.DB*
if exist FNC*..PRG DEL FNC*.NTX
if exist DB*.FNC DEL DB*.FNC
if exist HISTORIC.DB* DEL HISTORIC.DB*
if exist HIS*..PRG DEL HIS*.NTX
if exist DB*.HIS DEL DB*.HIS
if exist CSTSEG.DB* DEL CSTSEG.DB*
if exist CST*..PRG DEL CST*.NTX
if exist DB*.CST DEL DB*.CST
if exist MENSAG.DB* DEL MENSAG.DB*
if exist MEN*..PRG DEL MEN*.NTX
if exist DB*.MEN DEL DB*.MEN
if exist ORDPGRC.DB* DEL ORDPGRC.DB*
if exist ORD*..PRG DEL ORD*.NTX
if exist DB*.ORD DEL DB*.ORD
if exist PAR_ADM.DB* DEL PAR_ADM.DB*
if exist ADR_*.SYS DEL ADR_*.SYS
procedure adm_r018
/*
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
 \ Empresa.: PresServ Inform tica-Limeira (019)452.6623
 \ Programa: ADM_R018.PRG
 \ Data....: 27-06-97
 \ Sistema.: Administradora - RECEP€„O
 \ Funcao..: Recibos c/Falecidos
 \ Analista: Ademilson Pedro Bom
 \ Criacao.: GAS-Pro v3.0 
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/

#include "adrbig.ch"    // inicializa constantes manifestas

LOCAL dele_atu, getlist:={}, so_um_reg, sit_dbf:=POINTER_DBF()
PARA  lin_menu, col_menu, imp_reg
PRIV  tem_borda:=.t., op_menu:=VAR_COMPL, l_s:=10, c_s:=20, l_i:=14, c_i:=61, tela_fundo:=SAVESCREEN(0,0,MAXROW(),79)
nucop=1
so_um_reg=(PCOU()>2)
IF !so_um_reg                             // vai receber a variaveis?
 IF nivelop < 2                                    // se usuario nao tem
  DBOX("Emiss„o negada, "+usuario,20)              // permissao, avisa
  RETU                                             // e retorna
 ENDI
 SETCOLOR(drvtittel)
 vr_memo=NOVAPOSI(@l_s,@c_s,@l_i,@c_i)    // pega posicao atual da tela
 CAIXA(mold,l_s,c_s,l_i,c_i)              // monta caixa da tela
 @ l_s,c_s+11 SAY " RECIBOS C/FALECIDOS "
 SETCOLOR(drvcortel)
 @ l_s+01,c_s+1 SAY " Ano.....:"
 @ l_s+02,c_s+1 SAY " Numero..:"
 @ l_s+03,c_s+1 SAY " Confirme:"
ENDI
rano=SPAC(2)                                       // Ano
rnumero=SPAC(6)                                    // Numero
confirme=SPAC(1)                                   // Confirme
DO WHILE .t.
 rola_t=.f.
 cod_sos=56
 IF !so_um_reg
  SET KEY K_ALT_F8 TO ROLATELA
  SETCOLOR(drvcortel+","+drvcorget+",,,"+corcampo)
  @ l_s+01 ,c_s+12 GET  rano;
		   PICT "99";
		   VALI CRIT("!EMPT(rano)~Necess rio informar ANO")
		   DEFAULT "IIF(PTAB(PADR(SUBSTR(M->ide_maq,2),4)+[BXR],[IMPPAR],1),LEFT(IMPPAR->docto,2),[ ])"
		   AJUDA "Ano da emiss„o"

  @ l_s+02 ,c_s+12 GET  rnumero;
		   PICT "999999";
		   VALI CRIT("PTAB(rano+rnumero,'BXREC',1)~Necess rio informar NUMERO|Tecle F8 para buscar em tabela")
		   DEFAULT "IIF(PTAB(PADR(SUBSTR(M->ide_maq,2),4)+[BXR],[IMPPAR],1),SUBSTR(IMPPAR->docto,3,6),[ ])"
		   AJUDA "N£mero do Recibo a emitir"
		   CMDF8 "VDBF(6,11,20,77,'BXREC',{'ano','numero','codigo','tipo','circ','valorpg','emitido_','numop'},1,'numero',[])"

  @ l_s+03 ,c_s+12 GET  confirme;
		   PICT "!";
		   VALI CRIT("confirme='S'.AND.V01801F9()~CONFIRME n„o aceit vel|Digite S para confirmar|ou|Tecle ESC para cancelar")
                   AJUDA "Digite S para confirmar|ou|tecle ESC para cancelar"

  READ
  SET KEY K_ALT_F8 TO
  IF rola_t
   ROLATELA(.f.)
   LOOP
  ENDI
  IF LASTKEY()=K_ESC                               // se quer cancelar
   RETU                                            // retorna
  ENDI
 ENDI

 #ifdef COM_REDE
  IF !USEARQ("BXREC",.f.,10,1)                     // se falhou a abertura do arq
   RETU                                            // volta ao menu anterior
  ENDI
 #else
  USEARQ("BXREC")                                  // abre o dbf e seus indices
 #endi

 PTAB(codigo,"GRUPOS",1,.t.)                       // abre arquivo p/ o relacionamento
 PTAB(codigo+tipo+circ,"TAXAS",1,.t.)
 PTAB(GRUPOS->grupo,"ARQGRUP",1,.t.)
 PTAB(GRUPOS->cobrador,"COBRADOR",1,.t.)
 PTAB(GRUPOS->grupo+circ,"CIRCULAR",1,.t.)
 PTAB(GRUPOS->regiao,"REGIAO",1,.t.)
 SET RELA TO codigo INTO GRUPOS,;                  // relacionamento dos arquivos
	  TO codigo+tipo+circ INTO TAXAS,;
          TO GRUPOS->grupo INTO ARQGRUP,;
          TO GRUPOS->cobrador INTO COBRADOR,;
          TO GRUPOS->grupo+circ INTO CIRCULAR,;
          TO GRUPOS->regiao INTO REGIAO
 titrel:=criterio:=cpord := ""                     // inicializa variaveis
 titrel:=chv_rela:=chv_1:=chv_2 := ""
 tps:=op_x:=ccop := 1
 arq_=drvporta                                     // porta de saida configurada
 IF !so_um_reg
  IF !opcoes_rel(lin_menu,col_menu,6,11)           // nao quis configurar...
   CLOS ALL                                        // fecha arquivos e
   LOOP                                            // volta ao menu
  ENDI

 #ifdef COM_REDE

  ELSE

   tps=lin_menu

 #endi

 ENDI
 IF tps=2                                          // se vai para arquivo/video
  arq_=ARQGER()                                    // entao pega nome do arquivo
  IF EMPTY(arq_)                                   // se cancelou ou nao informou
   LOOP                                            // retorna
  ENDI
 ELSE
  arq_=drvporta                                    // porta de saida configurada
 ENDI
 SET PRINTER TO (arq_)                             // redireciona saida
 EXIT
ENDD
criterio_=criterio                                 // salva criterio e ordenacao
cpord_=cpord                                       // definidos se huver
criterio=""

#ifdef COM_REDE
 IF !USEARQ("CPRCIRC",.f.,10,1)                    // se falhou a abertura do arq
  RETU                                             // volta ao menu anterior
 ENDI
#else
 USEARQ("CPRCIRC")                                 // abre o dbf e seus indices
#endi

cpord="grupo+circ+DTOS(dfal)"
INDTMP()
criterio=criterio_                                 // restabelece criterio e
cpord=cpord_                                       // ordenacao definidos
SELE BXREC
IF !EMPTY(drvtapg)                                 // existe configuracao de tam pag?
 op_=AT("NNN",drvtapg)                             // se o codigo que altera
 IF op_=0                                          // o tamanho da pagina
  msg="Configura‡„o do tamanho da p gina!"         // foi informado errado
  DBOX(msg,,,,,"ERRO!")                            // avisa
  CLOSE ALL                                        // fecha todos arquivos abertos
  RETU                                             // e cai fora...
 ENDI                                              // codigo para setar/resetar tam pag
 lpp_048=LEFT(drvtapg,op_-1)+"048"+SUBS(drvtapg,op_+3)
 lpp_066=LEFT(drvtapg,op_-1)+"066"+SUBS(drvtapg,op_+3)
ELSE
 lpp_048:=lpp_066 :=""                             // nao ira mudara o tamanho da pag
ENDI
DBOX("[ESC] Interrompe",15,,,NAO_APAGA)
dele_atu:=SET(_SET_DELETED,.t.)                    // os excluidos nao servem...
SET DEVI TO PRIN                                   // inicia a impressao
maxli=19                                           // maximo de linhas no relatorio
IMPCTL(lpp_048)                                    // seta pagina com 48 linhas
SET MARG TO 1                                      // ajusta a margem esquerda
IF tps=2
 IMPCTL("' '+CHR(8)")
ENDI
BEGIN SEQUENCE
 DO WHIL ccop<=nucop                               // imprime qde copias pedida
  pg_=1; cl=999
  IF so_um_reg
   GO imp_reg
  ELSE
   INI_ARQ()                                       // acha 1o. reg valido do arquivo
   IF PTAB(PADR(SUBSTR(M->ide_maq,2),4)+[BXR],[IMPPAR],1)
    PTAB(LEFT(IMPPAR->docto,8),'BXREC',1)
   ENDI
  ENDI
  ccop++                                           // incrementa contador de copias
  ult_imp=0                                        // ultimo reg impresso
  DO WHIL !EOF().AND.(!so_um_reg.OR.imp_reg=RECN())
   #ifdef COM_TUTOR
    IF IN_KEY()=K_ESC                              // se quer cancelar
   #else
    IF INKEY()=K_ESC                               // se quer cancelar
   #endi
    IF canc()                                      // pede confirmacao
     BREAK                                         // confirmou...
    ENDI
   ENDI
   IF (PTAB(PADR(SUBSTR(M->ide_maq,2),4)+[BXR],[IMPPAR],1).AND.ano+numero=LEFT(IMPPAR->docto,8)) .OR. so_um_reg// se atender a condicao...
    chv017=grupo+circ
    SELE CPRCIRC
    SEEK chv017
    IF FOUND()
     DO WHIL ! EOF() .AND. chv017=LEFT(&(INDEXKEY(0)),LEN(chv017))
      #ifdef COM_TUTOR
       IF IN_KEY()=K_ESC                           // se quer cancelar
      #else
       IF INKEY()=K_ESC                            // se quer cancelar
      #endi
       IF canc()                                   // pede confirmacao
	BREAK                                      // confirmou...
       ENDI
      ENDI
      REL_CAB(1,.t.)                               // soma cl/imprime cabecalho
      IMPCTL(drvpc20)                              // comprime os dados
      @ cl,030 SAY num                             // Contrato
      @ cl,041 SAY processo                        // Processo
      @ cl,054 SAY fal                             // Falecido
      @ cl,091 SAY TRAN(ALLTRIM(ends)+'-'+ALLTRIM(cids),"@!")// Ends
      @ cl,149 SAY TRAN(dfal,"@D")                 // Data
      IMPCTL(drvtc20)                              // retira comprimido
      SKIP                                         // pega proximo registro
     ENDD
    ENDI
    SELE BXREC                                     // volta ao arquivo pai
    ult_imp=RECNO()                                // ultimo reg impresso
    SKIP                                           // pega proximo registro
    cl=999                                         // forca salto de pagina
   ELSE                                            // se nao atende condicao
    SKIP                                           // pega proximo registro
   ENDI
   exit
  ENDD
  REL_RDP(.t.)                                     // imprime rodape' do relatorio
 ENDD ccop
 EJEC                                              // salta pagina
END SEQUENCE
SET MARG TO                                        // coloca margem esquerda = 0
IMPCTL(lpp_066)                                    // seta pagina com 66 linhas
SET PRINTER TO (drvporta)                          // fecha arquivo gerado (se houver)
SET DEVI TO SCRE                                   // direciona saida p/ video
IF tps=2                                           // se vai para arquivo/video
 BROWSE_REL(arq_,2,3,MAXROW()-2,78)
ENDI                                               // mostra o arquivo gravado
GRELA(6)                                           // grava variacao do relatorio
SELE BXREC                                         // salta pagina
SET RELA TO                                        // retira os relacionamentos
SET(_SET_DELETED,dele_atu)                         // os excluidos serao vistos
IF so_um_reg
 POINTER_DBF(sit_dbf)
ENDI
RETU

STATIC PROC REL_RDP(volta_reg)                     // rodape'
LOCAL ar_:=ALIAS(), reg_atual
SELE BXREC                                         // volta ao arquivo pai
reg_atual=RECNO()
IF volta_reg
 GO ult_imp                                        // ajusta reg p/ imp de campos no rodape'
ENDI
@ 21,008 SAY &drvpcom+CIRCULAR->menscirc            // Mensagem
@ 25,017 SAY TRAN(valorpg,"@E 999,999.99")         // Valor
@ 25,065 SAY TRAN(valorpg,"@E 999,999.99")         // Valor 2
@ 28,020 SAY TRAN(M->nrauxrec,"########")          // N§ Recibo
@ 28,068 SAY TRAN(M->nrauxrec,"########")          // N§ Recibo 2
@ 31,002 SAY circ+[     ]+DTOC(CIRCULAR->emissao_)+[     ]+STR(GRUPOS->funerais,2)// Circular 1
@ 31,038 SAY circ+[     ]+DTOC(CIRCULAR->emissao_)+[     ]+STR(GRUPOS->funerais,2)// Circular 2
@ 34,002 SAY GRUPOS->grupo +[        ]+codigo+[       ]+GRUPOS->cobrador// Grupo 1
@ 34,038 SAY GRUPOS->grupo +[        ]+codigo+[       ]+GRUPOS->cobrador// Grupo 2
@ 36,000 SAY GRUPOS->nome                          // Nome
@ 36,036 SAY GRUPOS->nome                          // Nome 2
@ 37,000 SAY GRUPOS->endereco                      // Endere‡o
@ 37,036 SAY GRUPOS->endereco                      // Endere‡o 2
@ 38,000 SAY GRUPOS->bairro                        // Bairro
@ 38,036 SAY GRUPOS->bairro                        // Bairro 2
@ 39,000 SAY GRUPOS->cidade+[ ] +GRUPOS->cep       // Cidade
@ 39,036 SAY GRUPOS->cidade+[ ] +GRUPOS->cep       // Cidade 2
@ 40,000 SAY [Inic:]+DTOC(GRUPOS->admissao)+[ Ult:]+GRUPOS->ultcirc+[ QtTx:]+STR(GRUPOS->qtcircs,3)// Inicio
@ 40,036 SAY [Inic:]+DTOC(GRUPOS->admissao)+[ Ult:]+GRUPOS->ultcirc+[ QtTx:]+STR(GRUPOS->qtcircs,3)// Inicio 2
@ 42,000 SAY ""
IF M->combarra=[S]
 CODBARRAS({{codigo+tipo+circ,1,13,18}},10,6)
ENDI
@ 43,002 SAY LEFT(DTOC(DATE()),2)+[  ]+SUBSTR(DTOC(DATE()),4,2)+[  ]+RIGHT(DTOC(DATE()),2)// data 1
@ 43,039 SAY LEFT(DTOC(DATE()),2)+[  ]+SUBSTR(DTOC(DATE()),4,2)+[  ]+RIGHT(DTOC(DATE()),2)// data 2
IF M->combarra=[S]
 CODBARRAS({{codigo+tipo+circ,1,13,18}},10,6)
ENDI
IF volta_reg
 GO reg_atual                                      // retorna reg a posicao original
ENDI
SELE (ar_)
RETU

STATIC PROC REL_CAB(qt, volta_reg)                 // cabecalho do relatorio
LOCAL ar_:=ALIAS()
volta_reg=IF(volta_reg=NIL,.f.,volta_reg)
IF qt>0                                            // se parametro maior que 0
 cl=cl+qt                                          // soma no contador de linhas
ENDI
IF cl>maxli .OR. qt=0                              // quebra de pagina
 IF pg_>1
  REL_RDP(volta_reg)                               // imprime rodape' do relatorio
 ENDI
 SELE BXREC                                        // volta ao arquivo pai
 @ 1,007 SAY GRUPOS->nome                          // Nome
 @ 1,058 SAY TRAN(codigo,"99999")                  // Codigo
 @ 1,076 SAY grupo                                 // Grupo
 @ 3,032 SAY TRAN(valorpg,"@E 999,999.99")         // Valor
 SELE (ar_)
 cl=qt+7 ; pg_++
ENDI
RETU

* \\ Final de ADM_R018.PRG
GAS-Pro v3.0
011021015062001001013001012000176001
 Ano.....:
 Numero..:
 Confirme:
[Ÿ]
[Ÿ]
 3 
 0 
Recibos c/Falecidos
Recibos c/Falecidos







056







 0 
 0 
-1 
-1 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
rano
C
E
99
 2 
 2 
 1 
 12 
 0 
Ano

!EMPT(rano)
Necess rio informar ANO
IIF(PTAB(UPPER(RIGHT(M->ide_maq,4))+[BXR],[IMPPAR],1),LEFT(IMPPAR->docto,2),[ ])
Ano da emiss„o

 0 
 0 


rnumero
C
E
999999
 6 
 6 
 2 
 12 
 0 
Numero

PTAB(rano+rnumero,'BXREC',1)
Necess rio informar NUMERO|Tecle F8 para buscar em tabela
IIF(PTAB(UPPER(RIGHT(M->ide_maq,4))+[BXR],[IMPPAR],1),SUBSTR(IMPPAR->docto,3,6),[ ])
N£mero do Recibo a emitir
VDBF(6,11,20,77,'BXREC',{'ano','numero','codigo','tipo','circ','valorpg','emitido_','numop'},1,'numero',[])
 0 
 0 


confirme
C
E
!
 1 
 1 
 3 
 12 
 0 
Confirme

confirme='S'.AND.V01801F9()
CONFIRME n„o aceit vel|Digite S para confirmar|ou|Tecle ESC para cancelar

Digite S para confirmar|ou|tecle ESC para cancelar

 0 
 0 


 0 
 0 
 0 
 0 
 0 
procedure men_01f9
/*
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
 \ Empresa.: PresServ Inform tica - Limeira (019)452.6623
 \ Programa: MEN_01F9.PRG
 \ Data....: 20-10-99
 \ Sistema.: Administradora - RECEP€„O
 \ Funcao..: Fun‡„o F8 do campo FILTRO, arquivo MENSAG
 \ Analista: Ademilson Pedro Bom
 \ Criacao.: Programado manualmente pelo analista
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/

#include "adrbig.ch"    // inicializa constantes manifestas
sit_dbf:=POINTER_DBF()
crit_ant:=criterio
auxiliar=space(210)
PTAB([],[GRUPOS],1,.T.)
SELE GRUPOS
filtra(.F.)
auxiliar=criterio+[~TRUE]
criterio :=crit_ant
POINTER_DBF(sit_dbf)
RETU auxiliar       // <- deve retornar um valor qualquer

* \\ Final de MEN_01F9.PRG
GAS-Pro v3.0
011027015057001003001001014000176001
 Nr.Conta...:
 Fechamento.:
[Ÿ]
[Ÿ]
 2 
 0 
Transf.Financeiro
Transf.Financeiro







056







 0 
 0 
-1 
-1 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
nrconta
C
E
 
 10 
 10 
 1 
 15 
 0 
Nr.Conta

!EMPT(nrconta)
Necess rio informar NR.CONTA
M->usuario
Informe a conta a fechar.|Tecle F8 para conta atual
IIF(EMPT(M->usuario),PADR(M->contarec+M->ide_maq,10,' '),PADR(M->usuario,10,' '))
 0 
 0 


emisini_
D
E
@D
 8 
 8 
 2 
 15 
 0 
Lan‡to. inicial

emisini_=DATE()
Deve ser exatamente a data de hoje |Data do sistema
DATE()
Informe a data inicial

 0 
 0 


 0 
 0 
 0 
 0 
 0 
procedure arqgrup
/*
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
 \ Empresa.: PresServ Inform tica - Limeira (019)452.6623
 \ Programa: ARQGRUP.PRG
 \ Data....: 04-11-03
 \ Sistema.: Administradora - RECEP€„O
 \ Funcao..: Gerenciador do subsistema de grupos
 \ Analista: Ademilson Pedro Bom
 \ Criacao.: GAS-Pro v4.0n
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/
#include "adrbig.ch"    // inicializa constantes manifestas

PARA lin_menu,col_menu
PRIV op_sis, tela_fundo:=SAVESCREEN(0,0,MAXROW(),79), l_s, c_s, l_i, c_i, l_a

op_sis=EVAL(qualsis,"ARQGRUP")
IF nivelop<sistema[op_sis,O_OUTROS,O_NIVEL]        // se usuario nao tem permissao,
 ALERTA()                                          // entao, beep, beep, beep
 DBOX(msg_auto,,,3)                                // lamentamos e
 RETU                                              // retornamos ao menu
ENDI
cn:=fgrep :=.f.

#ifdef COM_LOCK
 IF LEN(pr_ok)>0                                   // se a protecao acusou
  ? pr_ok                                          // erro, avisa e
  QUIT                                             // encerra a aplicacao
 ENDI
#endi

t_fundo=SAVESCREEN(0,0,MAXROW(),79)                // salva tela do fundo
op_cad=1
DO WHIL op_cad!=0
 criterio=""
 RESTSCREEN(0,0,MAXROW(),79,t_fundo)               // restaura tela do fundo
 cod_sos=5 ; cn=.f.
 CLEA TYPEAHEAD                                    // limpa o buffer do teclado
 fgrep=.f.
 SET KEY K_F3 TO                                   // retira das teclas F3 e F4 as
 SET KEY K_F4 TO                                   // funcoes de repeticao e confirmacao
 msg="Inclus„o~1|"+;
     "Manuten‡„o~2|"+;
     "Consulta~3"
 op_cad=DBOX(msg,lin_menu,col_menu,E_MENU,NAO_APAGA,MAIUSC(sistema[op_sis,O_MENU]),,,op_cad)
 IF op_cad!=0                                      // se escolheu uma opcao
  Tela_fundo=SAVESCREEN(0,0,MAXROW(),79)           // salva a tela para ROLATELA()
  PARAMETROS(dbfparam)
  SELE A                                           // e abre o arquivo e seus indices

  #ifdef COM_REDE
   IF !USEARQ(sistema[op_sis,O_ARQUI,O_NOME],.f.,20,1)
                                                   // se falhou a abertura do
    RETU                                           // arquivo volta ao menu anterior
   ENDI
  #else
   USEARQ(sistema[op_sis,O_ARQUI,O_NOME])
  #endi

  SET KEY K_F9 TO veoutros                         // habilita consulta em outros arquivos
 ENDI
 DO CASE
  CASE op_cad=01                                   // inclus„o
   op_menu=INCLUSAO
   IF AT("D",exrot[op_sis])=0                      // se usuario pode fazer inclusao
    ARQ_INCL()                                     // neste arquivo chama prg de inclusao
   ELSE                                            // caso contrario vamos avisar que
    ALERTA()                                       // ele nao tem permissao para isto
    DBOX(msg_auto,,,3)
   ENDI

  CASE op_cad=02                                   // manuten‡„o
   op_menu=ALTERACAO
   cod_sos=7
   EDIT()

  CASE op_cad=03                                   // consulta
   op_menu=PROJECOES
   cod_sos=8
   EDITA(05,07,MAXROW()-4,72)

 ENDC
 SET KEY K_F9 TO                                   // F9 nao mais consultara outros arquivos
 CLOS ALL                                          // fecha todos arquivos abertos
ENDD
RETU

PROC ARQ_incl(reg_cop)  // inclusao no arquivo ARQGRUP
LOCAL getlist:={}, cabem:=1, rep:=ARRAY(FCOU()), ult_reg:=RECN(),;
      ctl_r, ctl_c, ctl_w, t_f3_, t_f4_, dele_atu:=SET(_SET_DELETED,.f.)
PRIV op_menu:=INCLUSAO, tem_borda, criterio:="", cpord:=""
FOR i=1 TO FCOU()                                  // cria/declara privadas as
 msg=FIEL(i)                                       // variaveis de memoria com
 PRIV &msg.                                        // o mesmo nome dos campos
NEXT                                               // do arquivo
IF reg_cop!=NIL                                    // quer repetir todo o reg atual
 FOR i=1 TO FCOU()                                 // para cada campo,
  msg=FIEL(i)                                      // salva o conteudo
  rep[i]=&msg.                                     // para repetir
 NEXT
ELSE
 AFILL(rep,"")                                     // eche com valor vazio
ENDI
t_f3_=SETKEY(K_F3,{||rep()})                       // repeticao reg anterior
t_f4_=SETKEY(K_F4,{||conf()})                      // confirma campos com ENTER
ctl_w=SETKEY(K_CTRL_W,{||nadafaz()})               // enganando o CA-Clipper...
ctl_c=SETKEY(K_CTRL_C,{||nadafaz()})
ctl_r=SETKEY(K_CTRL_R,{||nadafaz()})
DO WHIL cabem>0
 cod_sos=6
 rola_t=.f.                                        // flag se quer rolar a tela
 SELE ARQGRUP
 GO BOTT                                           // forca o
 SKIP                                              // final do arquivo
 
 /*
    cria variaveis de memoria identicas as de arquivo, para inclusao
    de registros
 */
 FOR i=1 TO FCOU()
  msg=FIEL(i)
  M->&msg.=IF((fgrep .OR. reg_cop!=NIL).AND.!EMPT(rep[1]),rep[i],&msg.)
 NEXT
 DISPBEGIN()                                       // apresenta a tela de uma vez so
 ARQ_TELA()
 INFOSIS(.t.)                                      // exibe informacao no rodape' da tela
 DISPEND()
 cabem=DISKSPACE(;
          IF(;
             LEN(sistema[op_sis,O_ARQUI,O_DIR_DBF])<2.OR.sistema[op_sis,O_ARQUI,O_DIR_DBF]="\",;
             0,;
             ASC(sistema[op_sis,O_ARQUI,O_DIR_DBF])-64;
          );
       )
 cabem=INT((cabem-2048)/ARQGRUP->(RECSIZE()))
 IF cabem<1                                        // mais nenhum!!!
  ALERTA()
  msg="Verifique ESPA€O EM DISCO, "+usuario
  DBOX(msg,,,,,"INCLUSŽO INTERROMPIDA!")           // vamos parar por aqui!
  EXIT
 ENDI
 SELE 0                                            // torna visiveis variaveis de memoria
 SETCOLOR(drvcortel+","+drvcorget+",,,"+corcampo)
 SET KEY K_ALT_F8 TO ROLATELA
 
 /*
    recebe chaves do arquivo de indice basico
 */
 @ l_s+01 ,c_s+14 GET  grup;
                  PICT sistema[op_sis,O_CAMPO,01,O_MASC]
                  DEFINICAO 1

 READ
 SET KEY K_ALT_F8 TO
 IF rola_t
  ROLATELA()
  LOOP
 ENDI
 SELE ARQGRUP
 IF LASTKEY()=K_ESC                                // cancelou ou chave em branco
  cabem=0                                          // prepara saida da inclusao
  LOOP                                             // volta p/ menu de cadastramento
 ENDI
 SEEK M->grup
 aprov_reg_=(FOUND().AND.DELE().AND.!drvvisivel)   // vai aproveitar o registro?
 IF FOUND() .AND. !aprov_reg_                      // pesquisou e achou!
  op_menu=ALTERACAO                                // seta flag de ateracao
  DISPBEGIN()
  ARQ_GETS()                                       // mostra conteudo do registro
  INFOSIS(.f.)                                     // exibe informacao no rodape' da tela
  DISPEND()
  ALERTA()
  msg="Consultar/alterar|Retornar … inclus„o"      // pergunta se deseja
  op_=DBOX(msg,,,E_MENU,,"REGISTRO J EXISTE")     // alterar o registro
  IF op_ =1                                        // caso afirmativo
   EDIT()                                          // deixa alterar
  ENDI
  op_menu=INCLUSAO
  LOOP                                             // volta para inclusao
 ENDI
 SELE 0
 ARQ_GET1(INCLUI)                                  // recebe campos
 SELE ARQGRUP
 IF LASTKEY()=K_ESC                                // se cancelou
  ALERTA()                                         // avisa que o registro
  DBOX("Registro n„o inclu¡do!",18,,1)             // nao foi incluido, e volta
  LOOP
 ENDI

 #ifdef COM_REDE
  GO BOTT                                          // vamos bloquear o final do
  SKIP                                             // arq para que nehum outro
  BLOREG(0,.5)                                     // usuario possa incluir
  SEEK M->grup                                     // se registro foi incluido
  aprov_reg_=(FOUND().AND.DELE().AND.!drvvisivel)  // vai aproveitar o registro?
  IF FOUND() .AND. !aprov_reg_                     // por outro usuario, entao
   BLOREG(0,.5)
   FOR i=1 TO FCOU()
    msg=FIEL(i)
    rep[i]=&msg.
    REPL &msg. WITH M->&msg.
   NEXT
   ARQ_GET1(FORM_INVERSA)                          // executa formula inversa
   RECA
   FOR i=1 TO FCOU()
    msg=FIEL(i)
    REPL &msg. WITH rep[i]
   NEXT
   ALERTA(4)                                       // beep 4 vezes
   msg="Registro acabou de ser|inclu¡do por outro usu rio!"
   DBOX(msg,,,,,"ATEN€ŽO!")                        // avisa
   SELE ARQGRUP
   UNLOCK                                          // libera o registro
   LOOP                                            // e recebe chave novamente
  ENDI
 #endi

 IF aprov_reg_                                     // se vai aproveitar reg excluido

  #ifdef COM_REDE
   BLOREG(0,.5)
  #endi

  RECA                                             // excluido, vamos recupera-lo
 ELSE                                              // caso contrario
  APPEND BLANK                                     // inclui reg em branco no dbf
 ENDI
 FOR i=1 TO FCOU()                                 // para cada campo,
  msg=FIEL(i)                                      // salva o conteudo
  rep[i]=M->&msg.                                  // para repetir
  REPL &msg. WITH rep[i]                           // enche o campo do arquivo
 NEXT

 #ifdef COM_REDE
  UNLOCK                                           // libera o registro e
  COMMIT                                           // forca gravacao
 #else
  IF RECC()-INT(RECC()/20)*20=0                    // a cada 20 registros
   COMMIT                                          // digitados forca gravacao
  ENDI
 #endi

 ult_reg=RECN()                                    // ultimo registro digitado
 IF reg_cop!=NIL                                   // estava na consulta e quis rep o campo
  EXIT                                             // cai fora...
 ENDI
ENDD
GO ult_reg                                         // para o ultimo reg digitado
SETKEY(K_F3,t_f3_)                                 // restaura teclas de funcoes
SETKEY(K_F4,t_f4_)
SET(_SET_DELETED,dele_atu)                            // ecluidos visiveis/invisiveis
SETKEY(K_CTRL_W,ctl_w)
SETKEY(K_CTRL_C,ctl_c)
SETKEY(K_CTRL_R,ctl_r)
RETU


PROC ARQ_tela     // tela do arquivo ARQGRUP
tem_borda=.t.
l_s=Sistema[op_sis,O_TELA,O_LS]           // coordenadas da tela
c_s=Sistema[op_sis,O_TELA,O_CS]
l_i=Sistema[op_sis,O_TELA,O_LI]
c_i=Sistema[op_sis,O_TELA,O_CI]
SETCOLOR(drvtittel)
vr_memo=NOVAPOSI(@l_s,@c_s,@l_i,@c_i)     // pega posicao atual da tela
CAIXA(mold,l_s,c_s,l_i,c_i)               // monta caixa da tela
i=LEN(sistema[op_sis,O_MENS])/2
@ l_s,c_s-1+(c_i-c_s+1)/2-i SAY " "+MAIUSC(sistema[op_sis,O_MENS])+" "
SETCOLOR(drvcortel)
@ l_s+01,c_s+1 SAY " Grupo.....:"
@ l_s+02,c_s+1 SAY " Classe....:"
@ l_s+03,c_s+1 SAY " N§.Inicial:             N§.Final:"
@ l_s+04,c_s+1 SAY "ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ"
@ l_s+05,c_s+1 SAY " Emitir recibos com no m¡nimo      e no"
@ l_s+06,c_s+1 SAY "                    m ximo      processos."
@ l_s+07,c_s+1 SAY " Comparar admiss„o & atendimento ?"
@ l_s+08,c_s+1 SAY " Intervalo minimo de     dias."
@ l_s+09,c_s+1 SAY "ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ"
@ l_s+10,c_s+1 SAY " Os contratos estar„o remidos ap¢s     taxas"
@ l_s+11,c_s+1 SAY " (por atendimento?  )"
@ l_s+12,c_s+1 SAY "ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ"
@ l_s+13,c_s+1 SAY " Ultima circular:      Emiss„o:"
@ l_s+14,c_s+1 SAY "        contratos ativos,        participantes"
@ l_s+15,c_s+1 SAY " vivos e     processos pendentes."
@ l_s+16,c_s+1 SAY "ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ"
@ l_s+17,c_s+1 SAY " Emitir circular n§"
RETU

PROC ARQ_gets     // mostra variaveis do arquivo ARQGRUP
LOCAL getlist := {}
ARQ_TELA()
SETCOLOR(drvcortel+","+drvcorget+",,,"+corcampo)
PTAB(CLASSE,'CLASSES',1)
CRIT("",,"2|3|4|5|6")
@ l_s+01 ,c_s+14 GET  grup;
                 PICT sistema[op_sis,O_CAMPO,01,O_MASC]

@ l_s+02 ,c_s+14 GET  classe;
                 PICT sistema[op_sis,O_CAMPO,02,O_MASC]
                 CRIT(sistema[op_sis,O_CAMPO,02,O_CRIT],,"1")

@ l_s+03 ,c_s+14 GET  inicio;
                 PICT sistema[op_sis,O_CAMPO,03,O_MASC]

@ l_s+03 ,c_s+36 GET  final;
                 PICT sistema[op_sis,O_CAMPO,04,O_MASC]

@ l_s+05 ,c_s+32 GET  acumproc;
                 PICT sistema[op_sis,O_CAMPO,05,O_MASC]

@ l_s+06 ,c_s+29 GET  maxproc;
                 PICT sistema[op_sis,O_CAMPO,06,O_MASC]

@ l_s+07 ,c_s+36 GET  cpadmiss;
                 PICT sistema[op_sis,O_CAMPO,07,O_MASC]

@ l_s+08 ,c_s+22 GET  periodic;
                 PICT sistema[op_sis,O_CAMPO,08,O_MASC]

@ l_s+10 ,c_s+36 GET  qtdremir;
                 PICT sistema[op_sis,O_CAMPO,09,O_MASC]

@ l_s+11 ,c_s+20 GET  poratend;
                 PICT sistema[op_sis,O_CAMPO,10,O_MASC]

@ l_s+17 ,c_s+21 GET  proxcirc;
                 PICT sistema[op_sis,O_CAMPO,16,O_MASC]

CLEAR GETS
RETU

PROC ARQ_get1(tp_mov)     // capta variaveis do arquivo ARQGRUP
LOCAL getlist := {}
PRIV  blk_arqgrup:=.t.

IF tp_mov=INCLUI
 DO WHILE .t.
  rola_t=.f.
  SET KEY K_ALT_F8 TO ROLATELA
  SETCOLOR(drvcortel+","+drvcorget+",,,"+corcampo)
  CRIT("",,"2|3|4|5|6")
  @ l_s+02 ,c_s+14 GET  classe;
                   PICT sistema[op_sis,O_CAMPO,02,O_MASC]
                   DEFINICAO 2
                   MOSTRA sistema[op_sis,O_FORMULA,1]

  @ l_s+03 ,c_s+14 GET  inicio;
                   PICT sistema[op_sis,O_CAMPO,03,O_MASC]
                   DEFINICAO 3

  @ l_s+03 ,c_s+36 GET  final;
                   PICT sistema[op_sis,O_CAMPO,04,O_MASC]
                   DEFINICAO 4

  @ l_s+05 ,c_s+32 GET  acumproc;
                   PICT sistema[op_sis,O_CAMPO,05,O_MASC]
                   DEFINICAO 5

  @ l_s+06 ,c_s+29 GET  maxproc;
                   PICT sistema[op_sis,O_CAMPO,06,O_MASC]
                   DEFINICAO 6

  @ l_s+07 ,c_s+36 GET  cpadmiss;
                   PICT sistema[op_sis,O_CAMPO,07,O_MASC]
                   DEFINICAO 7

  @ l_s+08 ,c_s+22 GET  periodic;
                   PICT sistema[op_sis,O_CAMPO,08,O_MASC]
                   DEFINICAO 8

  @ l_s+10 ,c_s+36 GET  qtdremir;
                   PICT sistema[op_sis,O_CAMPO,09,O_MASC]
                   DEFINICAO 9

  @ l_s+11 ,c_s+20 GET  poratend;
                   PICT sistema[op_sis,O_CAMPO,10,O_MASC]
                   DEFINICAO 10

  @ l_s+17 ,c_s+21 GET  proxcirc;
                   PICT sistema[op_sis,O_CAMPO,16,O_MASC]
                   DEFINICAO 16

  READ
  SET KEY K_ALT_F8 TO
  IF rola_t
   ROLATELA()
   LOOP
  ENDI
  IF LASTKEY()!=K_ESC .AND. drvincl .AND. op_menu=INCLUSAO
   IF !CONFINCL()
    LOOP
   ENDI
  ENDI
  EXIT
 ENDD
ENDI
PTAB(CLASSE,'CLASSES',1)
IF tp_mov=EXCLUI .OR. tp_mov=FORM_INVERSA
 IF !EMPTY(ALIAS())
  DELE
 ENDI
ELSEIF tp_mov=INCLUI .OR. tp_mov=RECUPERA .OR. tp_mov=FORM_DIRETA
 IF (op_menu=INCLUSAO .AND. LASTKEY()!=K_ESC) .OR. op_menu!=INCLUSAO
  IF op_menu!=INCLUSAO
   RECA
  ENDI
 ENDI
ENDI
RETU

* \\ Final de ARQGRUP.PRG
€
 ADM_R039O–Þ  ADM_R039CODEREL_CABCODEC_ETEXTENDCODE	_SYMSTARTSYMSTARTSYMBOLSSYMBOLS_SYMENDSYMENDNULLBEGDATA_DATADATA_SYMPBDATA_SYMPDATA_SYMPEDATA_CONSTCONST_MSGMSG_BEGBSSBEGBSS_BSSBSS_ENDBSSENDBSSDGROUPÓ˜ @Ò9˜ @®h˜ H  ˜ h  	ç˜ `0
´˜ h  ß˜ h  Û˜ H  ÷˜ H  ó˜ H ç˜ H  ë˜ H  ç˜ (  €
 CAD_04F9d–Ñ  CAD_04F9CODEC_ETEXTENDCODE	_SYMSTARTSYMSTARTSYMBOLSSYMBOLS_SYMENDSYMENDNULLBEGDATA_DATADATA_SYMPBDATA_SYMPDATA_SYMPEDATA_CONSTCONST_MSGMSG_BEGBSSBEGBSS_BSSBSS_ENDBSSENDBSSDGROUP#˜ @˜ H  ˜ h  ë˜ `	]˜ h  
ã˜ h  ß˜ H  û˜ H  ÷˜ H ë˜ H  ï˜ H  ë˜ (  ˜ H  /*
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
 \ Empresa.: Ind£stria de Urnas Bignotto Ltda
 \ Programa: ADM_RS18.PRG
 \ Data....: 21-10-96
 \ Sistema.: Administradora - RECEP€„O
 \ Funcao..: Recibos Sem Falecidos
 \ Analista: Ademilson Pedro Bom
 \ Criacao.: GAS-Pro v3.0 
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/

#include "adrbig.ch"    // inicializa constantes manifestas

LOCAL dele_atu, so_um_reg, sit_dbf
PARA  lin_menu, col_menu, imp_reg
so_um_reg=(PCOU()>2)
IF so_um_reg
 sit_dbf=POINTER_DBF()
ENDI
nucop=1

#ifdef COM_REDE
 IF !USEARQ("BXREC",.f.,10,1)                      // se falhou a abertura do arq
  RETU                                             // volta ao menu anterior
 ENDI
#else
 USEARQ("BXREC")                                   // abre o dbf e seus indices
#endi

PTAB(codigo,"GRUPOS",3,.t.)                        // abre arquivo p/ o relacionamento
PTAB(codigo+tipo+circ,"TAXAS",1,.t.)
PTAB(GRUPOS->grupo,"ARQGRUP",1,.t.)
PTAB(TAXAS->cobrador,"COBRADOR",1,.t.)
PTAB(GRUPOS->grupo+circ,"CIRCULAR",1,.t.)
PTAB(GRUPOS->regiao,"REGIAO",1,.t.)
PTAB(GRUPOS->tipcont,"CLASSES",1,.t.)
SET RELA TO codigo INTO GRUPOS,;                   // relacionamento dos arquivos
         TO codigo+tipo+circ INTO TAXAS,;
         TO GRUPOS->grupo INTO ARQGRUP,;
         TO TAXAS->cobrador INTO COBRADOR,;
         TO GRUPOS->grupo+circ INTO CIRCULAR,;
         TO GRUPOS->regiao INTO REGIAO,;
         TO GRUPOS->tipcont INTO CLASSES
titrel:=criterio:=cpord := ""                      // inicializa variaveis
titrel:=chv_rela:=chv_1:=chv_2 := ""
tps:=op_x:=ccop := 1
arq_=drvporta                                      // porta de saida configurada
IF !so_um_reg
 IF !opcoes_rel(lin_menu,col_menu,6,11)            // nao quis configurar...
  CLOS ALL                                         // fecha arquivos e
  RETU                                             // volta ao menu
 ENDI

#ifdef COM_REDE

 ELSE

  tps=lin_menu

#endi

ENDI
IF tps=2                                           // se vai para arquivo/video
 arq_=ARQGER()                                     // entao pega nome do arquivo
 IF EMPTY(arq_)                                    // se cancelou ou nao informou
  RETU                                             // retorna
 ENDI
ELSE
 arq_=drvporta                                     // porta de saida configurada
ENDI
SET PRINTER TO (arq_)                              // redireciona saida
IF !EMPTY(drvtapg)                                 // existe configuracao de tam pag?
 op_=AT("NNN",drvtapg)                             // se o codigo que altera
 IF op_=0                                          // o tamanho da pagina
  msg="Configura‡„o do tamanho da p gina!"         // foi informado errado
  DBOX(msg,,,,,"ERRO!")                            // avisa
  CLOSE ALL                                        // fecha todos arquivos abertos
  RETU                                             // e cai fora...
 ENDI                                              // codigo para setar/resetar tam pag
 lpp_033=LEFT(drvtapg,op_-1)+"033"+SUBS(drvtapg,op_+3)
 lpp_066=LEFT(drvtapg,op_-1)+"066"+SUBS(drvtapg,op_+3)
ELSE
 lpp_033:=lpp_066 :=""                             // nao ira mudara o tamanho da pag
ENDI
DBOX("[ESC] Interrompe",15,,,NAO_APAGA)
dele_atu:=SET(_SET_DELETED,.t.)                    // os excluidos nao servem...
SET DEVI TO PRIN                                   // inicia a impressao
maxli=32                                           // maximo de linhas no relatorio
IMPCTL(lpp_033)                                    // seta pagina com 33 linhas
SET MARG TO 1                                      // ajusta a margem esquerda
IF tps=2
 IMPCTL("' '+CHR(8)")
ENDI
BEGIN SEQUENCE
 DO WHIL ccop<=nucop                               // imprime qde copias pedida
  pg_=1; cl=999
  IF so_um_reg
   GO imp_reg
  ELSE
   INI_ARQ()                                       // acha 1o. reg valido do arquivo
  ENDI
  ccop++                                           // incrementa contador de copias
  DO WHIL !EOF().AND.(!so_um_reg.OR.imp_reg=RECN())
   #ifdef COM_TUTOR
    IF IN_KEY()=K_ESC                              // se quer cancelar
   #else
    IF INKEY()=K_ESC                               // se quer cancelar
   #endi
    IF canc()                                      // pede confirmacao
     BREAK                                         // confirmou...
    ENDI
   ENDI
   IF (ano+numero=M->nrauxrec) .OR. so_um_reg      // se atender a condicao...
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY TRAN(M->nrauxrec,"@R 99-999999")  // N§ Recibo
    @ cl,014 SAY "Circular:"
    IMPCTL(drvpenf)
    @ cl,026 SAY tipo+'-'+circ                     // Circular
    IMPCTL(drvtenf)
    @ cl,050 SAY "Valor.:"
    IMPCTL(drvpenf)
    @ cl,058 SAY TRAN(valorpg,"@E 999,999.99")     // Valor
    IMPCTL(drvtenf)
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,012 SAY TRAN(CLASSES->descricao,"@!")     // Descri‡„o 1
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY "Contrato..:"
    IMPCTL(drvpenf)
    @ cl,012 SAY GRUPOS->grupo +[  ]+codigo        // Grupo 1
    IMPCTL(drvtenf)
    @ cl,050 SAY "Data..:"
    @ cl,058 SAY TRAN(emitido_,"@D")               // data 1
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY "Nome......:"
    IMPCTL(drvpenf)
    @ cl,012 SAY GRUPOS->nome                      // Nome
    IMPCTL(drvtenf)
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    IMPAC("Endere‡o..:",cl,000)
    @ cl,012 SAY GRUPOS->endereco                  // Endere‡o
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY "Bairro....:"
    @ cl,012 SAY GRUPOS->bairro                    // Bairro
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY "Cid./Cobr.:"
    @ cl,012 SAY GRUPOS->cidade+[ ] +GRUPOS->cobrador// Cidade
    @ cl,052 SAY REPL("Ä",19)
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,052 SAY "Op:"
    @ cl,056 SAY LEFT(por,1)+LOWER(SUBSTR(por,2))  // operador
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY "Valor:"
    @ cl,007 SAY chr(15)+'('+SUBSTR(EXT(valorpg),1,AT('/',EXT(valorpg))-1)+')'+chr(18)// Valor Ext
    REL_CAB(2)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY REPL("Ä",71)
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    IMPEXP(cl,000,LEFT(M->setup1,35),70)           // 2 Ident1
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY M->setup2                         // 2 Ident 2
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY REPL("-",71)
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY TRAN(M->nrauxrec,"@R 99-999999")  // 2 N§ Recibo
    @ cl,014 SAY "Circular:"
    IMPCTL(drvpenf)
    @ cl,025 SAY tipo+'-'+circ                     // Circular
    IMPCTL(drvtenf)
    @ cl,050 SAY "Valor.:"
    IMPCTL(drvpenf)
    @ cl,058 SAY TRAN(valorpg,"@E 999,999.99")     // Valor pago
    IMPCTL(drvtenf)
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,012 SAY TRAN(CLASSES->descricao,"@!")     // Descri‡„o 2
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY "Contrato..:"
    IMPCTL(drvpenf)
    @ cl,012 SAY GRUPOS->grupo +[  ]+codigo        // Grupo
    IMPCTL(drvtenf)
    @ cl,050 SAY "Data..:"
    @ cl,058 SAY TRAN(emitido_,"@D")               // Emitido em
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY "Nome......:"
    IMPCTL(drvpenf)
    @ cl,012 SAY GRUPOS->nome                      // Nome
    IMPCTL(drvtenf)
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    IMPAC("Endere‡o..:",cl,000)
    @ cl,012 SAY GRUPOS->endereco                  // Endere‡o
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY "Bairro....:"
    @ cl,012 SAY GRUPOS->bairro                    // Bairro
    @ cl,052 SAY REPL("Ä",19)
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY "Cid./Cobr.:"
    @ cl,012 SAY GRUPOS->cidade+[ ] +GRUPOS->cobrador// Cidade
    @ cl,052 SAY "Op:"
    @ cl,056 SAY LEFT(por,1)+LOWER(SUBSTR(por,2))  // Operador
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY "Valor:"
    @ cl,007 SAY chr(15)+'('+SUBSTR(EXT(valorpg),1,AT('/',EXT(valorpg))-1)+')'+chr(18)// Valor Ext
    REL_CAB(2)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY ""
IF M->combarra='S'
    CODBARRAS({{codigo+tipo+circ,1,13,9}},10,6)
ENDI
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY ""
IF M->combarra='S'
    CODBARRAS({{codigo+tipo+circ,1,13,9}},10,6)
ENDI
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY ""
IF M->combarra='S'
    CODBARRAS({{codigo+tipo+circ,1,13,9}},10,6)
ENDI
    SKIP                                           // pega proximo registro
    cl=999                                         // forca salto de pagina
   ELSE                                            // se nao atende condicao
    SKIP                                           // pega proximo registro
   ENDI
  ENDD
 ENDD ccop
 EJEC                                              // salta pagina
END SEQUENCE
SET MARG TO                                        // coloca margem esquerda = 0
IMPCTL(lpp_066)                                    // seta pagina com 66 linhas
SET PRINTER TO (drvporta)                          // fecha arquivo gerado (se houver)
SET DEVI TO SCRE                                   // direciona saida p/ video
IF tps=2                                           // se vai para arquivo/video
 BROWSE_REL(arq_,2,3,MAXROW()-2,78)
ENDI                                               // mostra o arquivo gravado
GRELA(6)                                           // grava variacao do relatorio
SELE BXREC                                         // salta pagina
SET RELA TO                                        // retira os relacionamentos
SET(_SET_DELETED,dele_atu)                         // os excluidos serao vistos
IF so_um_reg
 POINTER_DBF(sit_dbf)
ENDI
RETU

STATIC PROC REL_CAB(qt)                            // cabecalho do relatorio
IF qt>0                                            // se parametro maior que 0
 cl=cl+qt                                          // soma no contador de linhas
ENDI
IF cl>maxli .OR. qt=0                              // quebra de pagina
 IMPEXP(0,000,LEFT(M->setup1,35),70)               // Ident1
 @ 1,000 SAY M->setup2                             // Ident2
 @ 2,000 SAY REPL("-",71)
 cl=qt+2 ; pg_++
ENDI
RETU

* \\ Final de ADM_RS18.PRG
procedure con_rx41
€
 ALE_01F9]–Ñ  ALE_01F9CODEC_ETEXTENDCODE	_SYMSTARTSYMSTARTSYMBOLSSYMBOLS_SYMENDSYMENDNULLBEGDATA_DATADATA_SYMPBDATA_SYMPDATA_SYMPEDATA_CONSTCONST_MSGMSG_BEGBSSBEGBSS_BSSBSS_ENDBSSENDBSSDGROUP˜ @‹ ˜ H  ˜ h  ë˜ `	Þ˜ h  
ã˜ h  ß˜ H  û˜ H  ÷˜ H ë˜ H  ï˜ H  ë˜ (  ˜ H  procedure tax_02f9
/*
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
 \ Empresa.: PresServ Inform tica-Limeira (019)452.6623
 \ Programa: TAX_02F9.PRG
 \ Data....: 22-11-96
 \ Sistema.: Administradora - RECEP€„O
 \ Funcao..: F¢rmula (Status) a mostrar na tela de TAXAS
 \ Analista: Ademilson Pedro Bom
 \ Criacao.: Programado manualmente pelo analista
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/

#include "adrbig.ch"    // inicializa constantes manifestas

DO CASE
 CASE TAXAS->stat = [1]
  RETU [Gerada  ]
 CASE TAXAS->stat = [2]
  RETU [Impressa]
 CASE TAXAS->stat = [6]
  RETU [BxRecep‡]
 CASE TAXAS->stat = [7]
  RETU [Bx FCC  ]
 CASE TAXAS->stat = [9]
  RETU [Bx Plano]
ENDC
RETU [        ]       // <- deve retornar um valor qualquer

* \\ Final de TAX_02F9.PRG
.PRG.OBJ:
     CLIPPER $** /m
ADRBIG.OBJ   : ADRBIG.PRG
BXR_07F9.OBJ : BXR_07F9.PRG
BXR_06F9.OBJ : BXR_06F9.PRG
BXR_02F9.OBJ : BXR_02F9.PRG
BXR_01F9.OBJ : BXR_01F9.PRG
BXREC.OBJ    : BXREC.PRG
ALE_01F9.OBJ : ALE_01F9.PRG
ALENDER.OBJ  : ALENDER.PRG
OBX_07F9.OBJ : OBX_07F9.PRG
OBX_01F9.OBJ : OBX_01F9.PRG
OBXEC.OBJ    : OBXEC.PRG
GRU_01F9.OBJ : GRU_01F9.PRG
GRU_02F9.OBJ : GRU_02F9.PRG
GRUPOS.OBJ   : GRUPOS.PRG
CTAINSC.OBJ  : CTAINSC.PRG
CTXAS.OBJ    : CTXAS.PRG
TAX_02F9.OBJ : TAX_02F9.PRG
INS_01F9.OBJ : INS_01F9.PRG
INS_02F9.OBJ : INS_02F9.PRG
GUI_07F9.OBJ : GUI_07F9.PRG
GUI_06F9.OBJ : GUI_06F9.PRG
GUI_08F9.OBJ : GUI_08F9.PRG
GUI_02F9.OBJ : GUI_02F9.PRG
GUIAS.OBJ    : GUIAS.PRG
MFILIAL.OBJ  : MFILIAL.PRG
ADP_R101.OBJ : ADP_R101.PRG
ADC_RX76.OBJ : ADC_RX76.PRG
CAD_04F9.OBJ : CAD_04F9.PRG
KINSCF9.OBJ  : KINSCF9.PRG
AFUNER.OBJ   : AFUNER.PRG
R02001F9.OBJ : R02001F9.PRG
R02002F9.OBJ : R02002F9.PRG
ADM_R020.OBJ : ADM_R020.PRG
V02001F9.OBJ : V02001F9.PRG
V02002F9.OBJ : V02002F9.PRG
R02901F9.OBJ : R02901F9.PRG
ADR_R029.OBJ : ADR_R029.PRG
RX2001F9.OBJ : RX2001F9.PRG
RX2002F9.OBJ : RX2002F9.PRG
ADM_RX20.OBJ : ADM_RX20.PRG
RX2901F9.OBJ : RX2901F9.PRG
ADR_RX29.OBJ : ADR_RX29.PRG
ADM_R029.OBJ : ADM_R029.PRG
ADM_R026.OBJ : ADM_R026.PRG
ADM_R021.OBJ : ADM_R021.PRG
DCI_P001.OBJ : DCI_P001.PRG
DCI01F9.OBJ  : DCI01F9.PRG
DCI03F9.OBJ  : DCI03F9.PRG
DCI04F9.OBJ  : DCI04F9.PRG
ADM_RS18.OBJ : ADM_RS18.PRG
V01801F9.OBJ : V01801F9.PRG
ADM_R023.OBJ : ADM_R023.PRG
V02301F9.OBJ : V02301F9.PRG
ADM_R022.OBJ : ADM_R022.PRG
R03001F9.OBJ : R03001F9.PRG
ADM_R039.OBJ : ADM_R039.PRG
IMP_01F9.OBJ : IMP_01F9.PRG
IMPPAR.OBJ   : IMPPAR.PRG
MEDICOS.OBJ  : MEDICOS.PRG
TESPEC.OBJ   : TESPEC.PRG
JUROS.OBJ    : JUROS.PRG
TFILIAIS.OBJ : TFILIAIS.PRG
ARQGRUP.OBJ  : ARQGRUP.PRG
REGIAO.OBJ   : REGIAO.PRG
COB_01F9.OBJ : COB_01F9.PRG
COBRADOR.OBJ : COBRADOR.PRG
CLASSES.OBJ  : CLASSES.PRG
CIRCULAR.OBJ : CIRCULAR.PRG
PRCESSOS.OBJ : PRCESSOS.PRG
FNCS.OBJ     : FNCS.PRG
HISTORIC.OBJ : HISTORIC.PRG
CSTSEG.OBJ   : CSTSEG.PRG
MEN_01F9.OBJ : MEN_01F9.PRG
MENSAG.OBJ   : MENSAG.PRG
ORDPGRC.OBJ  : ORDPGRC.PRG
PAR_ADM.OBJ  : PAR_ADM.PRG
ADR_ESTR.OBJ : ADR_ESTR.PRG
ADR_ATRI.OBJ : ADR_ATRI.PRG
ADR_ATR1.OBJ : ADR_ATR1.PRG
ADR_ATR2.OBJ : ADR_ATR2.PRG
ADR_MENU.OBJ : ADR_MENU.PRG
CON_RX01.OBJ : CON_RX01.PRG
ABOUT.OBJ    : ABOUT.PRG
ADR_PROC.OBJ : ADR_PROC.PRG
ADR_FUNC.OBJ : ADR_FUNC.PRG
ADR_FUN2.OBJ : ADR_FUN2.PRG
ADR_OUTR.OBJ : ADR_OUTR.PRG
ADRBIG.EXE:
	 bLINKer @ADRBIG.LNK
/*
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
 \ Empresa.: Ind£stria de Urnas Bignotto Ltda
 \ Programa: ADM_R035.PRG
 \ Data....: 09-08-96
 \ Sistema.: Administradora de Funer rias
 \ Funcao..: Fechamento 2¦Via
 \ Analista: Ademilson Pedro Bom
 \ Criacao.: GAS-Pro v2.0d
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/

#include "admbig.ch"    // inicializa constantes manifestas

LOCAL dele_atu, getlist:={}, li_det:=[]
PARA  lin_menu, col_menu
PRIV  tem_borda:=.t., op_menu:=VAR_COMPL, l_s:=9, c_s:=26, l_i:=14, c_i:=56, tela_fundo:=SAVESCREEN(0,0,MAXROW(),79)
nucop=1
SETCOLOR(drvtittel)
vr_memo=NOVAPOSI(@l_s,@c_s,@l_i,@c_i)     // pega posicao atual da tela
CAIXA(mold,l_s,c_s,l_i,c_i)               // monta caixa da tela
@ l_s,c_s+6 SAY " TRANSF.FINANCEIRO "
SETCOLOR(drvcortel)
@ l_s+01,c_s+1 SAY " Nr.Conta......:"
@ l_s+03,c_s+1 SAY " Emitir 2¦ Via do fechamento"
@ l_s+04,c_s+1 SAY "      do dia...:"
nrconta=SPAC(10)                                   // Nr.Conta
emisini_=CTOD('')                                  // Lanto. inicial
DO WHILE .t.
 rola_t=.f.
 cod_sos=56
 SET KEY K_ALT_F8 TO ROLATELA
 SETCOLOR(drvcortel+","+drvcorget+",,,"+corcampo)
 @ l_s+01 ,c_s+18 GET  nrconta;
                  VALI CRIT("!EMPT(nrconta)~Necess rio informar NR.CONTA")
                  AJUDA "Informe a conta a fechar.|Tecle F8 para conta atual"
                  CMDF8 "IIF(EMPT(M->usuario),PADR(M->contaconv+M->ide_maq,10,' '),PADR(M->usuario,10,' '))"

 @ l_s+04 ,c_s+18 GET  emisini_;
		  PICT "@D";
		  VALI CRIT("!EMPT(emisini_).and. emisini_<=DATE()~Necess rio informar Lan‡to. inicial correta")
		  DEFAULT "DATE()-DAY(DATE()) + 1"
		  AJUDA "Informe a data inicial"

 READ
 SET KEY K_ALT_F8 TO
 IF rola_t
  ROLATELA(.f.)
  LOOP
 ENDI
 IF LASTKEY()=K_ESC                                // se quer cancelar
  RETU                                             // retorna
 ENDI

 #ifdef COM_REDE
  IF !USEARQ("ORDPGRC",.f.,10,1)                   // se falhou a abertura do arq
   RETU                                            // volta ao menu anterior
  ENDI
 #else
  USEARQ("ORDPGRC")                                // abre o dbf e seus indices
 #endi

 titrel:=criterio:=cpord := ""                     // inicializa variaveis
 titrel:=chv_rela:=chv_1:=chv_2 := ""
 tps:=op_x:=ccop := 1
 IF !opcoes_rel(lin_menu,col_menu,9,11)            // nao quis configurar...
  CLOS ALL                                         // fecha arquivos e
  LOOP                                             // volta ao menu
 ENDI
 IF tps=2                                          // se vai para arquivo/video
  arq_=ARQGER()                                    // entao pega nome do arquivo
  IF EMPTY(arq_)                                   // se cancelou ou nao informou
   LOOP                                            // retorna
  ENDI
 ELSE
  arq_=drvporta                                    // porta de saida configurada
 ENDI
 SET PRINTER TO (arq_)                             // redireciona saida
 EXIT
ENDD
criterio_=criterio                                 // salva criterio e ordenacao
cpord_=cpord                                       // definidos se huver
criterio=""

#ifdef COM_REDE
 IF !USEARQ("BXREC",.f.,10,1)                      // se falhou a abertura do arq
  RETU                                             // volta ao menu anterior
 ENDI
#else
 USEARQ("BXREC")                                   // abre o dbf e seus indices
#endi

cpord="numop+ano+numero"
INDTMP()

#ifdef COM_REDE
 IF !USEARQ("OBXEC",.f.,10,1)                      // se falhou a abertura do arq
  RETU                                             // volta ao menu anterior
 ENDI
#else
 USEARQ("OBXEC")                                   // abre o dbf e seus indices
#endi

cpord="numop+ano+numero"
INDTMP()
criterio=criterio_                                 // restabelece criterio e
cpord=cpord_                                       // ordenacao definidos
SELE ORDPGRC
DBOX("[ESC] Interrompe",15,,,NAO_APAGA)
dele_atu:=SET(_SET_DELETED,.t.)                    // os excluidos nao servem...
SET DEVI TO PRIN                                   // inicia a impressao
maxli=62                                           // maximo de linhas no relatorio
BEGIN SEQUENCE
 DO WHIL ccop<=nucop                               // imprime qde copias pedida
  pg_=1; cl=999
  INI_ARQ()                                        // acha 1o. reg valido do arquivo
  ccop++                                           // incrementa contador de copias
  tot018005 := 0                                   // inicializa variaves de totais
  DO WHIL !EOF()
   IF INKEY()=K_ESC                                // se quer cancelar
    IF canc()                                      // pede confirmacao
     BREAK                                         // confirmou...
    ENDI
   ENDI
   IF M->nrconta=numconta.AND.M->emisini_=fechto_  // se atender a condicao...
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    IMPCTL(drvtc20)                                // retira comprimido
    @ cl,000 SAY TRAN(numop+R03001F9(),"999999")   // N§ OP.
    @ cl,007 SAY TRAN(origem,"!!!")                // Ori
    @ cl,011 SAY TRAN(historico,"999")             // Hist
    @ cl,016 SAY TRAN(debcred,"!")                 // D/C
    tot018005+=valortotal * IIF(debcred='C',1,-1)
    @ cl,019 SAY TRAN(valortotal * IIF(debcred='C',1,-1),"99999999.99")// Val Lan‡to
    @ cl,031 SAY TRAN(documento,"@!")              // Documento
    @ cl,044 SAY TRAN(complement,"@!")             // Complemento de Hist¢rico
    tot021005 := 0                                 // inicializa variaves de totais
    chv021=numop
    SELE BXREC
    SEEK chv021
    IF FOUND()
     IF cl+3>maxli                                 // se cabecalho do arq filho
      REL_CAB(0)                                   // nao cabe nesta pagina
     ENDI                                          // salta para a proxima pagina
     IMPCTL(drvpc20)                               // comprime os dados
     cl+=1                                         // soma contador de linha
     @ cl,001 SAY "Numero  Codig Cir Valor pago"
     cl+=1                                         // soma contador de linha
     @ cl,000 SAY "======== ===== === =========="
     IMPCTL(drvtc20)                               // retira comprimido
     DO WHIL ! EOF() .AND. chv021=numop //LEFT(&(INDEXKEY(0)),LEN(chv021))
      IF INKEY()=K_ESC                             // se quer cancelar
       IF canc()                                   // pede confirmacao
	BREAK                                      // confirmou...
       ENDI
      ENDI
      li_det+=TRAN(ano,"99")+;           // Ano
	      TRAN(numero,"999999")+[ ]+;          // Numero
	      TRAN(codigo,"99999")+[ ]+;           // Codigo
	      TRAN(circ,"999")+[ ]+;               // Circular
	      TRAN(valorpg,"@E 999,999.99")+[  ||  ]        // Valor pago
      tot021005+=valorpg
      IF LEN(li_det) > 120
       REL_CAB(1)                                   // soma cl/imprime cabecalho
       IMPCTL(drvpc20)                              // comprime os dados
       @ cl,000 SAY li_det                          // linha
       IMPCTL(drvtc20)                              // retira comprimido
       li_det:=[]
      ENDIF
      SKIP                                         // pega proximo registro
     ENDD
     IF !EMPT(li_det)
      REL_CAB(1)                                   // soma cl/imprime cabecalho
      IMPCTL(drvpc20)                              // comprime os dados
      @ cl,000 SAY li_det                          // linha
      IMPCTL(drvtc20)                              // retira comprimido
      li_det:=[]
     ENDIF
     IF cl+3>maxli                                 // se cabecalho do arq filho
      REL_CAB(0)                                   // îao cabe nesôa pagina
     ENDI                                          // salta para a proxima pagina
     IMPCTL(drvpc20)                               // comprime os dados
     @ ++cl,019 SAY REPL('-',10)
     @ ++cl,019 SAY TRAN(tot021005,"@E 999,999.99")// total Valor pago
     IMPCTL(drvtc20)                               // retira comprimido
     cl+=1                                         // soma contador de linha
    ENDI
    SELE ORDPGRC                                   // volta ao arquivo pai
    tot021004 := 0                                 // inicializa variaves de totais
    chv021=numop
    SELE OBXEC
    SEEK chv021
    IF FOUND()
     IF cl+3>maxli                                 // se cabecalho do arq filho
      REL_CAB(0)                                   // nao cabe nesta pagina
     ENDI                                          // salta para a proxima pagina
     IMPCTL(drvpc20)                               // comprime os dados
     cl+=1                                         // soía cïntaäor de linha
     @ cl,001 SAY "Numero  Codig Valor pago Ref"
     cl+=1                                         // soma contador de linha
     @ cl,000 SAY "======== ===== ========== ======================="
     IMPCTL(drvtc20)                               // retira comprimido
     DO WHIL ! EOF() .AND. chv021=numop //LEFT(&(INDEXKEY(0)),LEN(chv021))
      IF INKEY()=K_ESC                             // se quer cancelar
       IF canc()                                   // pede confirmacao
	BREAK                                      // confirmou...
       ENDI
      ENDI
      li_det+=TRAN(ano,"99")+;                  // Ano
	      TRAN(numero,"999999")+[ ]+;           // Numero
	      TRAN(codigo,"99999")+[]+;             // Codigo
	      TRAN(valorpg,"@E 999,999.99")+[ ]+;   // Valor pago
	      ref+[|| ]                             // Ref
      tot021004+=valorpg
      IF LEN(li_det) > 120
       REL_CAB(1)                                   // soma cl/imprime cabecalho
       IMPCTL(drvpc20)                              // comprime os dados
       @ cl,000 SAY li_det                          // linha
       IMPCTL(drvtc20)                              // retira comprimido
       li_det:=[]
      ENDIF
      SKIP                                         // pega proximo registro
     ENDD
     IF !EMPT(li_det)
      REL_CAB(1)                                   // soma cl/imprime cabecalho
      IMPCTL(drvpc20)                              // comprime os dados
      @ cl,000 SAY li_det                          // linha
      IMPCTL(drvtc20)                              // retira comprimido
      li_det:=[]
     ENDIF
     IF cl+3>maxli                                 // se cabecalho do arq filho
      REL_CAB(0)                                   // nao cabe nesta pagina
     ENDI                                          // salta para a proxima pagina
     IMPCTL(drvpc20)                               // comprime os dados
     @ ++cl,015 SAY REPL('-',10)
     @ ++cl,015 SAY TRAN(tot021004,"@E 999,999.99")// total Valor pago
     IMPCTL(drvtc20)                               // retira comprimido
     cl+=1                                         // soma contador de linha
    ENDI
    SELE ORDPGRC                                   // volta ao arquivo pai
    SKIP                                           // pega proximo registro
   ELSE                                            // se nao atende condicao
    SKIP                                           // pega proximo registro
   ENDI
  ENDD
  IF cl+3>maxli                                    // se cabecalho do arq filho
   REL_CAB(0)                                      // nao cabe nesta pagina
  ENDI                                             // salta para a proxima pagina
  @ ++cl,019 SAY REPL('-',11)
  @ ++cl,019 SAY TRAN(tot018005,"99999999.99")     // total Val Lan‡to
 ENDD ccop
 EJEC                                              // salta pagina
END SEQUENCE
SET PRINTER TO (drvporta)                          // fecha arquivo gerado (se houver)
SET DEVI TO SCRE                                   // direciona saida p/ video
IF tps=2                                           // se vai para arquivo/video
 BROWSE_REL(arq_,2,3,MAXROW()-2,78)                // mostra o arquivo gravado
ENDI
GRELA(9)                                           // grava variacao do relatorio
SET(_SET_DELETED,dele_atu)                         // os excluidos serao vistos
RETU

STATIC PROC REL_CAB(qt)                            // cabecalho do relatorio
IF qt>0                                            // se parametro maior que 0
 cl=cl+qt                                          // soma no contador de linhas
ENDI
IF cl>maxli .OR. qt=0                              // quebra de pagina
 IMPAC(nemp,0,000)                                 // nome da empresa
 @ 0,071 SAY "PAG"
 @ 0,075 SAY TRAN(pg_,'9999')                      // n£mero da p gina
 IMPAC(nsis,1,000)                                 // t¡tulo aplica‡„o
 @ 1,071 SAY "ADM_R035"                            // c¢digo relat¢rio
 @ 2,000 SAY "TRANSF.FINANCEIRO "+M->nrconta
 @ 2,063 SAY NSEM(DATE())                          // dia da semana
 @ 2,071 SAY DTOC(DATE())                          // data do sistema
 @ 3,000 SAY titrel                                // t¡tulo a definir
 IMPAC("N§ OP. Ori Hist DC  Val Lan‡to Documento    Complemento de Hist¢rico",4,000)
 @ 5,000 SAY REPL("-",79)
 cl=qt+5 ; pg_++
ENDI
RETU

* \\ Final de ADM_R035.PRG
€ TESPEC®– TESPECCODETES_INCLCODETES_TELACODETES_GETSCODETES_GET1CODEC_ETEXTENDCODE	_SYMSTARTSYMSTARTSYMBOLSSYMBOLS_SYMENDSYMENDNULLBEGDATA_DATADATA_SYMPBDATA_SYMPDATA_SYMPEDATA_CONSTCONST_MSGMSG_BEGBSSBEGBSS_BSSBSS_ENDBSSENDBSSDGROUPÜ˜ @ô%˜ @§h˜ @xš˜ @e	©˜ @F
Ã˜ H  ÿ˜ h  Û˜ `P‰˜ h  Ó˜ h  Ï˜ H  ë˜ H  ç˜ H €
 BXR_01F9C–Ñ  BXR_01F9CODEC_ETEXTENDCODE	_SYMSTARTSYMSTARTSYMBOLSSYMBOLS_SYMENDSYMENDNULLBEGDATA_DATADATA_SYMPBDATA_SYMPDATA_SYMPEDATA_CONSTCONST_MSGMSG_BEGBSSBEGBSS_BSSBSS_ENDBSSENDBSSDGROUP˜ @÷ ˜ H  ˜ h  ë˜ `À	-˜ h  
ã˜ h  ß˜ H  û˜ H  ÷˜ H ë˜ H  ï˜ H  ë˜ (  ˜ H  procedure ctcgrup
/*
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
 \ Empresa.: PresServ Inform tica - Limeira (019)452.6623
 \ Programa: CTCGRUP.PRG
 \ Data....: 06-01-00
 \ Sistema.: Administradora - PLANO
 \ Funcao..: Contratos Cancelados
 \ Analista: Ademilson Pedro Bom
 \ Criacao.: GAS-Pro v3.0 
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/

#include "adrbig.ch"    // inicializa constantes manifestas

LOCAL t_, i_, col_cp, col_ti, ord_
PRIV  prefixo_dbf:="CTC", op_sis:=EVAL(qualsis,"CGRUPOS")
                                                   // arquivo a consultar
op_menu=PROJECOES                                  // flag consulta e faz projecoes
SELE 0

#ifdef COM_REDE
 IF !USEARQ("CGRUPOS",.f.,10,1)                    // se falhou a abertura do arq
  RETU                                             // volta ao menu anterior
 ENDI
#else
 USEARQ("CGRUPOS")                                 // abre o dbf e seus indices
#endi

col_cp={;                                          // conteudo das colunas
          "numero",;
          "codigo",;
          "motivo",;
          "canclto_",;
          "cancpor",;
          "reintnum",;
          "motreint",;
          "reintem_",;
          "reintpor",;
          "codreint",;
          "situacao",;
          "nome",;
          "nascto_",;
          "estcivil",;
          "cpf",;
          "rg",;
          "endereco",;
          "bairro",;
          "cidade",;
          "uf",;
          "cep",;
          "contato",;
          "telefone",;
          "tipcont",;
          "vlcarne",;
          "formapgto",;
          "admissao",;
          "tcarencia",;
          "saitxa",;
          "vendedor",;
          "regiao",;
          "cobrador",;
          "obs",;
          "renovar",;
          "funerais",;
          "circinic",;
          "ultcirc",;
          "qtcircs",;
          "qtcircpg";
       }
col_ti={;                                          // titulo das colunas
          "N£mero",;
          "Codigo",;
          "Motivo",;
          "Canclto_",;
          "Por",;
          "N£mero",;
          "Motreint",;
          "Reintem",;
          "Reintpor",;
          "Codigo",;
          "Situa‡„o",;
          "Nome",;
          "Nascto",;
          "Est Civil",;
          "CPF",;
          "R.G.",;
          "Endere‡o",;
          "Bairro",;
          "Cidade",;
          "UF",;
          "CEP",;
          "Contato",;
          "Telefone",;
          "TipCont",;
          "Vlcarne",;
          "FormaPgto",;
          "Admiss„o",;
          "T.Carˆncia",;
          "Saitxa",;
          "Vendedor",;
          "Regi„o",;
          "Cobrador",;
          "Obs",;
          "Renovar",;
          "Funerais",;
          "Circ.Inicial",;
          "Ult.Circular",;
          "Qt.Circulares",;
          "Circ.Pagas";
       }
ord_="nome"                                        // ordem inicial
GO TOP                                             // vai p/ inicio do arquivo
cod_sos=8
EDITA(3,3,MAXROW()-2,77,.t.,col_cp,col_ti,,ord_)
CLOSE ALL                                          // fecha todos os arquivos e
RETU                                               // volta para o menu anterior

* \\ Final de CTCGRUP.PRG
procedure adm_r039
/*
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
 \ Empresa.: PresServ Inform tica - Limeira (019)452.6623
 \ Programa: ADM_R039.PRG
 \ Data....: 04-11-03
 \ Sistema.: Administradora - RECEP€„O
 \ Funcao..: Fechamento Caixa
 \ Analista: Ademilson Pedro Bom
 \ Criacao.: GAS-Pro v4.0n
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/

#include "adrbig.ch"    // inicializa constantes manifestas

PRIV dele_atu, cur_atual, getlist:={}, lin_det:=[]
PARA lin_menu, col_menu
PRIV  tem_borda:=.t., op_menu:=VAR_COMPL, l_s:=09, c_s:=26, l_i:=15, c_i:=56, tela_fundo:=SAVESCREEN(0,0,MAXROW(),79)
nucop=1
IF nivelop < 2                                     // se usuario nao tem
 DBOX("Emiss„o negada, "+usuario,20)               // permissao, avisa
 RETU                                              // e retorna
ENDI
SETCOLOR(drvtittel)
vr_memo=NOVAPOSI(@l_s,@c_s,@l_i,@c_i)     // pega posicao atual da tela
CAIXA(mold,l_s,c_s,l_i,c_i)               // monta caixa da tela
@ l_s,c_s+6 SAY " TRANSF.FINANCEIRO "
SETCOLOR(drvcortel)
@ l_s+01,c_s+1 SAY " Nr.Conta...:"
@ l_s+02,c_s+1 SAY " Fechamento.:"
@ l_s+03,c_s+1 SAY " Segunda Via:"
PRIV nrconta:=SPAC(10)                             // Nr.Conta
PRIV emisini_:=CTOD('')                            // Lan‡to. inicial
PRIV ehsegvia:=[N]
DO WHILE .t.
 rola_t=.f.
 cod_sos=56
 SET KEY K_ALT_F8 TO ROLATELA
 SETCOLOR(drvcortel+","+drvcorget+",,,"+corcampo)
 @ l_s+01 ,c_s+15 GET  nrconta;
		  VALI CRIT("!EMPT(nrconta)~Necess rio informar NR.CONTA")
		  DEFAULT "M->usuario"
		  AJUDA "Informe a conta a fechar.|Tecle F8 para conta atual"
		  CMDF8 "IIF(EMPT(M->usuario),PADR(M->contarec+M->ide_maq,10,' '),PADR(M->usuario,10,' '))"

 @ l_s+02 ,c_s+15 GET  emisini_;
		  PICT "@D";
		  VALI CRIT("emisini_<=DATE()~Deve ser menor ou igual a data de hoje |Data do sistema")
      DEFAULT "DATE()"
      AJUDA "Informe a data inicial"

 @ l_s+03 ,c_s+15 GET  ehsegvia;
		  PICT "!";
		  VALI CRIT("ehsegvia$[SN]~Digite Sim ou Nao")
      DEFAULT "N"
      AJUDA "Digite S para listar os caixas de hoje"

 READ
 SET KEY K_ALT_F8 TO
 IF rola_t
  ROLATELA(.f.)
  LOOP
 ENDI
 IF LASTKEY()=K_ESC                                // se quer cancelar
  RETU                                             // retorna
 ENDI

 #ifdef COM_REDE
  IF !USEARQ("ORDPGRC",.f.,10,1)                   // se falhou a abertura do arq
   RETU                                            // volta ao menu anterior
  ENDI
 #else
  USEARQ("ORDPGRC")                                // abre o dbf e seus indices
 #endi

 titrel:=criterio := ""                            // inicializa variaveis
 cpord=""
 chv_rela:=chv_1:=chv_2 := ""
 tps:=op_x:=ccop := 1
 fil_ini=""
 IF !opcoes_rel(lin_menu,col_menu,12,11,fil_ini)   // nao quis configurar...
  CLOS ALL                                         // fecha arquivos e
  LOOP                                             // volta ao menu
 ENDI
 IF tps=2                                          // se vai para arquivo/video
  arq_=ARQGER()                                    // entao pega nome do arquivo
  IF EMPTY(arq_)                                   // se cancelou ou nao informou
   LOOP                                            // retorna
  ENDI
 ELSE
  arq_=drvporta                                    // porta de saida configurada
 ENDI
 IF "4WIN"$UPPER(drvmarca) // nome da configuracao/marca impressora
    arq_:=drvdbf+"WIN"+ide_maq
    tps:=3                                          // se vai para arquivo/video
 ENDIF
 SET PRINTER TO (arq_)                             // redireciona saida
 EXIT
ENDD
cur_atual=SETCURSOR(0)
criterio_=criterio                                 // salva criterio e ordenacao
cpord_=cpord                                       // definidos se huver
criterio=""

#ifdef COM_REDE
 IF !USEARQ("BXREC",.f.,10,1)                      // se falhou a abertura do arq
  RETU                                             // volta ao menu anterior
 ENDI
#else
 USEARQ("BXREC")                                   // abre o dbf e seus indices
#endi

cpord="numop+numero"
criterio=""
INDTMP()
#ifdef COM_REDE
 IF !USEARQ("OBXEC",.f.,10,1)                      // se falhou a abertura do arq
	RETU                                             // volta ao menu anterior
 ENDI
#else
 USEARQ("OBXEC")                                   // abre o dbf e seus indices
#endi

cpord="numop+numero"
INDTMP()
criterio=criterio_                                 // restabelece criterio e
cpord=cpord_                                       // ordenacao definidos
SELE ORDPGRC
dele_atu:=SET(_SET_DELETED,.t.)                    // os excluidos nao servem...
POE_GAUGE("[ESC] Interrompe","AGUARDE...","Emitidos:")
SET DEVI TO PRIN                                   // inicia a impressao
maxli=62                                           // maximo de linhas no relatorio
BEGIN SEQUENCE
 DO WHIL ccop<=nucop                               // imprime qde copias pedida
  pg_=1; cl=50000
  INI_ARQ()                                        // acha 1o. reg valido do arquivo
  IF EOF()
   EXIT
  ENDI
  ccop++                                           // incrementa contador de copias
  tot025005 := 0                                   // inicializa variaves de totais
  DO WHIL !EOF().AND.POE_GAUGE()
   IF IN_KEY()=K_ESC                               // se quer cancelar
    IF canc()                                      // pede confirmacao
     BREAK                                         // confirmou...
    ENDI
   ENDI
   IF numconta==M->nrconta.AND.;
      (EMPT(fechto_).and.ehsegvia#[S]).or.;
      (ehsegvia=[S].AND.fechto_=emisini_) // se atender a condicao...
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY TRAN(numop+R03001F9(),"999999")   // N§ OP.
    @ cl,007 SAY TRAN(origem,"!!!")                // Ori
    @ cl,011 SAY TRAN(historico,"999")             // Hist
    @ cl,016 SAY TRAN(debcred,"!")                 // D/C
    tot025005+=valortotal * IIF(debcred='C',1,-1)
    @ cl,019 SAY TRAN(valortotal * IIF(debcred='C',1,-1),"99999999.99")// Val Lan‡to
    @ cl,031 SAY TRAN(documento,"@!")              // Documento
    @ cl,044 SAY TRAN(LEFT(complement,20),"@!")             // Complemento de Hist¢rico
    @ cl,065 SAY DTOC(ORDPGRC->fechto_)
    chv026=numop
    SELE BXREC
    SEEK chv026
    IF FOUND()
     IF cl+3>maxli                                 // se cabecalho do arq filho
      REL_CAB(0)                                   // nao cabe nesta pagina
     ENDI                                          // salta para a proxima pagina
     cl+=1                                         // soma contador de linha
     IMPCTL(drvpcom)                              // comprime os dados
     @ cl,002 SAY "Numero  Codigo Circ. Valor pago"
     cl+=1                                         // soma contador de linha
     @ cl,000 SAY "========= ================== =========="
     DO WHIL ! EOF() .AND. chv026=numop //LEFT(&(INDEXKEY(0)),LEN(chv026)).AND.POE_GAUGE()
      IF IN_KEY()=K_ESC                            // se quer cancelar
       IF canc()                                   // pede confirmacao
	BREAK                                      // confirmou...
       ENDI
      ENDI
      lin_det+=TRAN(numero,"@R 99-999999")+;           // Numero
	       [ ]+LEFT(cobranca,15)+;      // Codigo
	       TRAN(valorpg,"@E 9,999.99")+[ ]   // Valor pago

      IF LEN(lin_det)>100
       REL_CAB(1)                                   // soma cl/imprime cabecalho
       @ cl,000 SAY lin_det
       lin_det:=[]
      ENDI
      SKIP                                         // pega proximo registro
     ENDD
    ENDI
    IF !EMPT(lin_det)
     REL_CAB(1)                                   // soma cl/imprime cabecalho
     @ cl,000 SAY lin_det
     lin_det:=[]
    ENDI
    IMPCTL(drvTcom)                              // comprime os dados
    cl++
    SELE ORDPGRC                                   // volta ao arquivo pai
    tot020004 := 0                                 // inicializa variaves de totais
    chv020=numop
    SELE OBXEC
    SEEK chv020
    IF FOUND()
     IF cl+3>maxli                                 // se cabecalho do arq filho
      REL_CAB(0)                                   // nao cabe nesta pagina
     ENDI                                          // salta para a proxima pagina
     IMPCTL(drvpcom)                               // comprime os dados
     cl+=1                                         // soma contador de linha
     @ cl,001 SAY "Numero  Codig Valor pago Ref"
     cl+=1                                         // soma contador de linha
     @ cl,000 SAY "======== ===== ========== ======================="
     IMPCTL(drvpcom)                               // retira comprimido
     DO WHIL ! EOF() .AND. chv020=numop //LEFT(&(INDEXKEY(0)),LEN(chv020))
      #ifdef COM_TUTOR
       IF IN_KEY()=K_ESC                           // se quer cancelar
      #else
       IF INKEY()=K_ESC                            // se quer cancelar
      #endi
       IF canc()                                   // pede confirmacao
        BREAK                                      // confirmou...
       ENDI
      ENDI
      lin_det+=TRAN(numero,"99-999999")+' '+;           // Numero
	       TRAN(codigo,"@!")+' '+;           // Codigo
	       TRAN(valorpg,"@E 9,999.99")+' '+;   // Valor pago
	       cobranca+' | '
      IF LEN(lin_det)>100
       REL_CAB(1)                                   // soma cl/imprime cabecalho
       IMPCTL(drvpcom)                              // comprime os dados
       @ cl,000 SAY lin_det
       IMPCTL(drvtcom)                              // retira comprimido
       lin_det:=[]
      ENDI
      tot020004+=valorpg
      SKIP                                         // pega proximo registro
     ENDD
     REL_CAB(1)                                   // soma cl/imprime cabecalho
     IMPCTL(drvpcom)                              // comprime os dados
     @ cl,000 SAY lin_det
     IMPCTL(drvtcom)                              // retira comprimido
     lin_det:=[]
     IF cl+3>maxli                                 // se cabecalho do arq filho
      REL_CAB(0)                                   // nao cabe nesta pagina
     ENDI                                          // salta para a proxima pagina
     IMPCTL(drvpcom)                               // comprime os dados
     @ ++cl,015 SAY REPL('-',10)
     @ ++cl,015 SAY TRAN(tot020004,"@E 999,999.99")// total Valor pago
     IMPCTL(drvtcom)                               // retira comprimido
     cl+=3                                         // soma contador de linha
    ENDI
    SELE ORDPGRC                                   // volta ao arquivo pai
    SKIP                                           // pega proximo registro
   ELSE                                            // se nao atende condicao
    SKIP                                           // pega proximo registro
   ENDI
  ENDD
  IF cl+3>maxli                                    // se cabecalho do arq filho
   REL_CAB(0)                                      // nao cabe nesta pagina
  ENDI                                             // salta para a proxima pagina
  @ ++cl,019 SAY REPL('-',11)
  @ ++cl,019 SAY TRAN(tot025005,"99999999.99")     // total Val Lan‡to
 ENDD ccop
 EJEC                                              // salta pagina
END SEQUENCE
SETCURSOR(cur_atual)
SET PRINTER TO (drvporta)                          // fecha arquivo gerado (se houver)
SET DEVI TO SCRE                                   // direciona saida p/ video
IF tps=2                                           // se vai para arquivo/video
 BROWSE_REL(arq_,2,3,MAXROW()-2,78)
ENDI          // mostra o arquivo gravado
GRELA(12)                                          // grava variacao do relatorio
msgp="PROCESSAMENTOS DO RELAT¢RIO|FECHAMENTO CAIXA"
POE_GAUGE("Processando registros","AGUARDE!","Feitos:")
SET(_SET_DELETED,.t.)                              // os excluidos nao servem...
SELE ORDPGRC                                       // processamentos apos emissao
INI_ARQ()                                          // acha 1o. reg valido do arquivo
DO WHIL !EOF().AND.POE_GAUGE().AND.!(ehsegvia=[S])
 IF numconta==M->nrconta.AND.EMPT(fechto_)         // se atender a condicao...

  #ifdef COM_REDE
   IF EMPT(fechto_)
    REPBLO('ORDPGRC->fechto_',{||DATE()})
   ENDI
   IF EMPT(fechpor)
    REPBLO('ORDPGRC->fechpor',{||M->usuario})
   ENDI
  #else
   IF EMPT(fechto_)
    REPL ORDPGRC->fechto_ WITH DATE()
   ENDI
   IF EMPT(fechpor)
    REPL ORDPGRC->fechpor WITH M->usuario
   ENDI
  #endi

  SELE ORDPGRC                                     // volta ao arquivo pai
  SKIP                                             // pega proximo registro
 ELSE                                              // se nao atende condicao
  SKIP                                             // pega proximo registro
 ENDI
ENDD
SET(_SET_DELETED,.f.)                              // os excluidos serao vistos
SELE BXREC                                         // arquivo origem do processamento

SET(_SET_DELETED,.t.)
ALERTA(2)
DBOX("Processo terminado com sucesso!",,,,,msgp)
SET(_SET_DELETED,dele_atu)                         // os excluidos serao vistos
RETU

STATIC PROC REL_CAB(qt)                            // cabecalho do relatorio
IF qt>0                                            // se parametro maior que 0
 cl=cl+qt                                          // soma no contador de linhas
ENDI
IF cl>maxli .OR. qt=0                              // quebra de pagina
 IMPAC(nemp,0,000)                                 // nome da empresa
 @ 0,071 SAY "PAG"
 @ 0,075 SAY TRAN(pg_,'9999')                      // n£mero da p gina
 IMPAC(nsis,1,000)                                 // t¡tulo aplica‡„o
 @ 1,071 SAY "ADM_R039"                            // c¢digo relat¢rio
 @ 2,000 SAY "TRANSF.FINANCEIRO"
 @ 2,063 SAY NSEM(DATE())                          // dia da semana
 @ 2,071 SAY DTOC(DATE())                          // data do sistema
 @ 3,000 SAY ALLtrim(titrel)+[ Conta:]+M->nrconta   // t¡tulo a definir
 IMPAC("N§ OP. Ori Hist DC  Val Lan‡to Documento    Complemento Hist¢rico Fechto.",4,000)
 @ 5,000 SAY REPL("-",79)
 cl=qt+5 ; pg_++
ENDI
RETU

* \\ Final de ADM_R039.PRG
procedure afuner
/*
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
 \ Empresa.: PresServ Inform tica - Limeira (019)452.6623
 \ Programa: AFUNER.PRG
 \ Data....: 04-11-03
 \ Sistema.: Administradora - RECEP€„O
 \ Funcao..: Gerenciador do subsistema de lan‡amento aux.funeral
 \ Analista: Ademilson Pedro Bom
 \ Criacao.: GAS-Pro v4.0n
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/

#include "adrbig.ch"    // inicializa constantes manifestas

PARA lin_menu,col_menu
PRIV op_sis, tela_fundo:=SAVESCREEN(0,0,MAXROW(),79), l_s, c_s, l_i, c_i, l_a

op_sis=EVAL(qualsis,"AFUNER")
IF nivelop<sistema[op_sis,O_OUTROS,O_NIVEL]        // se usuario nao tem permissao,
 ALERTA()                                          // entao, beep, beep, beep
 DBOX(msg_auto,,,3)                                // lamentamos e
 RETU                                              // retornamos ao menu
ENDI
cn:=fgrep :=.f.

#ifdef COM_LOCK
 IF LEN(pr_ok)>0                                   // se a protecao acusou
  ? pr_ok                                          // erro, avisa e
  QUIT                                             // encerra a aplicacao
 ENDI
#endi

t_fundo=SAVESCREEN(0,0,MAXROW(),79)                // salva tela do fundo
op_cad=1
DO WHIL op_cad!=0
 criterio=""
 RESTSCREEN(0,0,MAXROW(),79,t_fundo)               // restaura tela do fundo
 cod_sos=5 ; cn=.f.
 CLEA TYPEAHEAD                                    // limpa o buffer do teclado
 fgrep=.f.
 SET KEY K_F3 TO                                   // retira das teclas F3 e F4 as
 SET KEY K_F4 TO                                   // funcoes de repeticao e confirmacao
 msg="Inclus„o~1|"+;
     "Manuten‡„o~2|"+;
     "Consulta~3"
 op_cad=DBOX(msg,lin_menu,col_menu,E_MENU,NAO_APAGA,MAIUSC(sistema[op_sis,O_MENU]),,,op_cad)
 IF op_cad!=0                                      // se escolheu uma opcao
  Tela_fundo=SAVESCREEN(0,0,MAXROW(),79)           // salva a tela para ROLATELA()
  PARAMETROS(dbfparam)
  SELE A                                           // e abre o arquivo e seus indices

  #ifdef COM_REDE
   IF !USEARQ(sistema[op_sis,O_ARQUI,O_NOME],.f.,20,1)
                                                   // se falhou a abertura do
    RETU                                           // arquivo volta ao menu anterior
   ENDI
  #else
   USEARQ(sistema[op_sis,O_ARQUI,O_NOME])
  #endi

  SET KEY K_F9 TO veoutros                         // habilita consulta em outros arquivos
 ENDI
 DO CASE
  CASE op_cad=01                                   // inclus„o
   op_menu=INCLUSAO
   IF AT("D",exrot[op_sis])=0                      // se usuario pode fazer inclusao
    AFU_INCL()                                     // neste arquivo chama prg de inclusao
   ELSE                                            // caso contrario vamos avisar que
    ALERTA()                                       // ele nao tem permissao para isto
    DBOX(msg_auto,,,3)
   ENDI

  CASE op_cad=02                                   // manuten‡„o
   op_menu=ALTERACAO
   cod_sos=7
   EDIT()

  CASE op_cad=03                                   // consulta
   op_menu=PROJECOES
   cod_sos=8
   EDITA(03,03,MAXROW()-2,77)

 ENDC
 SET KEY K_F9 TO                                   // F9 nao mais consultara outros arquivos
 CLOS ALL                                          // fecha todos arquivos abertos
ENDD
RETU

PROC AFU_incl(reg_cop)  // inclusao no arquivo AFUNER
LOCAL getlist:={},cabem:=1,rep:=ARRAY(FCOU()),ult_reg:=RECN(),cond_incl_,dbfseq_,;
      ctl_r, ctl_c, ctl_w, t_f3_, t_f4_, dele_atu:=SET(_SET_DELETED,.f.)
PRIV op_menu:=INCLUSAO, sq_atual_, tem_borda, criterio:="", cpord:=""
cond_incl_={||nivelop>1}                           // condicao de inclusao de registros
IF !EVAL(cond_incl_)                               // se nao pode incluir
 ALERTA(2)                                         // avisa o motivo
 DBOX("Permitido apenas a usu rios cadastrados|com n¡vel de Manuten‡„o ou Maior",,,4,,"ATEN€ŽO, "+usuario)
 RETU                                              // e retorna
ENDI
FOR i=1 TO FCOU()                                  // cria/declara privadas as
 msg=FIEL(i)                                       // variaveis de memoria com
 PRIV &msg.                                        // o mesmo nome dos campos
NEXT                                               // do arquivo
IF reg_cop!=NIL                                    // quer repetir todo o reg atual
 FOR i=1 TO FCOU()                                 // para cada campo,
  msg=FIEL(i)                                      // salva o conteudo
  rep[i]=&msg.                                     // para repetir
 NEXT
ELSE
 AFILL(rep,"")                                     // eche com valor vazio
ENDI
t_f3_=SETKEY(K_F3,{||rep()})                       // repeticao reg anterior
t_f4_=SETKEY(K_F4,{||conf()})                      // confirma campos com ENTER
ctl_w=SETKEY(K_CTRL_W,{||nadafaz()})               // enganando o CA-Clipper...
ctl_c=SETKEY(K_CTRL_C,{||nadafaz()})
ctl_r=SETKEY(K_CTRL_R,{||nadafaz()})

#ifdef COM_REDE
 AFU_CRIA_SEQ()                                    // cria dbf de controle de cp sequenciais
 FOR i=1 TO FCOU()                                 // cria/declara privadas as
  msg="sq_"+FIEL(i)                                // variaveis de memoria com
  PRIV &msg.                                       // o mesmo nome dos campos
 NEXT                                              // do arquivo com extensao _seq
#endi

DO WHIL cabem>0
 cod_sos=6
 rola_t=.f.                                        // flag se quer rolar a tela
 SELE AFUNER
 GO BOTT                                           // forca o
 SKIP                                              // final do arquivo
 
 /*
    cria variaveis de memoria identicas as de arquivo, para inclusao
    de registros
 */
 FOR i=1 TO FCOU()
  msg=FIEL(i)
  M->&msg.=IF((fgrep .OR. reg_cop!=NIL).AND.!EMPT(rep[1]),rep[i],&msg.)
 NEXT
 DISPBEGIN()                                       // apresenta a tela de uma vez so
 AFU_TELA()
 INFOSIS(.t.)                                      // exibe informacao no rodape' da tela
 DISPEND()
 AFU_GERA_SEQ()
 IF !EVAL(cond_incl_)
  EXIT
 ENDI
 cabem=DISKSPACE(;
          IF(;
             LEN(sistema[op_sis,O_ARQUI,O_DIR_DBF])<2.OR.sistema[op_sis,O_ARQUI,O_DIR_DBF]="\",;
             0,;
             ASC(sistema[op_sis,O_ARQUI,O_DIR_DBF])-64;
          );
       )
 cabem=INT((cabem-2048)/AFUNER->(RECSIZE()))
 IF cabem<1                                        // mais nenhum!!!
  ALERTA()
  msg="Verifique ESPA€O EM DISCO, "+usuario
  DBOX(msg,,,,,"INCLUSŽO INTERROMPIDA!")           // vamos parar por aqui!
  EXIT
 ENDI
 SELE 0                                            // torna visiveis variaveis de memoria
 SETCOLOR(drvcortel+","+drvcorget+",,,"+corcampo)
 SET KEY K_ALT_F8 TO ROLATELA
 
 /*
    recebe chaves do arquivo de indice basico
 */
 @ l_s+01 ,c_s+14 GET  processo;
                  PICT sistema[op_sis,O_CAMPO,01,O_MASC]
                  DEFINICAO 1

 @ l_s+01 ,c_s+20 GET  proc2;
                  PICT sistema[op_sis,O_CAMPO,02,O_MASC]
                  DEFINICAO 2

 READ
 SET KEY K_ALT_F8 TO
 IF rola_t
  ROLATELA()

  #ifdef COM_REDE
   AFU_ANT_SEQ()                                   // decrementa sequencial
  #endi

  LOOP
 ENDI
 SELE AFUNER
 IF LASTKEY()=K_ESC                                // cancelou ou chave em branco
  cabem=0                                          // prepara saida da inclusao
  LOOP                                             // volta p/ menu de cadastramento
 ENDI
 SEEK M->processo+M->proc2
 aprov_reg_=(FOUND().AND.DELE().AND.!drvvisivel)   // vai aproveitar o registro?
 IF FOUND() .AND. !aprov_reg_                      // pesquisou e achou!
  op_menu=ALTERACAO                                // seta flag de ateracao

  #ifdef COM_REDE
   AFU_ANT_SEQ()                                   // decrementa sequencial
   SELE AFUNER
  #endi

  DISPBEGIN()
  AFU_GETS()                                       // mostra conteudo do registro
  INFOSIS(.f.)                                     // exibe informacao no rodape' da tela
  DISPEND()
  ALERTA()
  msg="Consultar/alterar|Retornar … inclus„o"      // pergunta se deseja
  op_=DBOX(msg,,,E_MENU,,"REGISTRO J EXISTE")     // alterar o registro
  IF op_ =1                                        // caso afirmativo
   EDIT()                                          // deixa alterar
  ENDI
  op_menu=INCLUSAO
  LOOP                                             // volta para inclusao
 ENDI
 SELE 0
 AFU_GET1(INCLUI)                                  // recebe campos
 SELE AFUNER
 IF LASTKEY()=K_ESC                                // se cancelou

  #ifdef COM_REDE
   AFU_ANT_SEQ()                                   // decrementa sequencial
  #endi

  ALERTA()                                         // avisa que o registro
  DBOX("Registro n„o inclu¡do!",18,,1)             // nao foi incluido, e volta
  LOOP
 ENDI

 #ifdef COM_REDE
  GO BOTT                                          // vamos bloquear o final do
  SKIP                                             // arq para que nehum outro
  BLOREG(0,.5)                                     // usuario possa incluir
  SEEK M->processo+M->proc2                        // se registro foi incluido
  aprov_reg_=(FOUND().AND.DELE().AND.!drvvisivel)  // vai aproveitar o registro?
  IF FOUND() .AND. !aprov_reg_                     // por outro usuario, entao
   BLOREG(0,.5)
   FOR i=1 TO FCOU()
    msg=FIEL(i)
    rep[i]=&msg.
    REPL &msg. WITH M->&msg.
   NEXT
   AFU_GET1(FORM_INVERSA)                          // executa formula inversa
   RECA
   FOR i=1 TO FCOU()
    msg=FIEL(i)
    REPL &msg. WITH rep[i]
   NEXT
   ALERTA(4)                                       // beep 4 vezes
   msg="Registro acabou de ser|inclu¡do por outro usu rio!"
   DBOX(msg,,,,,"ATEN€ŽO!")                        // avisa
   SELE AFUNER
   UNLOCK                                          // libera o registro
   LOOP                                            // e recebe chave novamente
  ENDI
 #endi

 IF aprov_reg_                                     // se vai aproveitar reg excluido

  #ifdef COM_REDE
   BLOREG(0,.5)
  #endi

  RECA                                             // excluido, vamos recupera-lo
 ELSE                                              // caso contrario
  APPEND BLANK                                     // inclui reg em branco no dbf
 ENDI
 FOR i=1 TO FCOU()                                 // para cada campo,
  msg=FIEL(i)                                      // salva o conteudo
  rep[i]=M->&msg.                                  // para repetir
  REPL &msg. WITH rep[i]                           // enche o campo do arquivo
 NEXT

 #ifdef COM_REDE
  UNLOCK                                           // libera o registro e
  COMMIT                                           // forca gravacao
 #else
  IF RECC()-INT(RECC()/20)*20=0                    // a cada 20 registros
   COMMIT                                          // digitados forca gravacao
  ENDI
 #endi

 ult_reg=RECN()                                    // ultimo registro digitado
 AFU_REL(ult_reg)                               // imprime relat apos inclusao
 IF reg_cop!=NIL                                   // estava na consulta e quis rep o campo
  sq_atual_=NIL
  EXIT                                             // cai fora...
 ENDI
ENDD

#ifdef COM_REDE
 AFU_ANT_SEQ()                                     // restaura sequencial anterior
 SELE AFUNER
#endi

GO ult_reg                                         // para o ultimo reg digitado
SETKEY(K_F3,t_f3_)                                 // restaura teclas de funcoes
SETKEY(K_F4,t_f4_)
SET(_SET_DELETED,dele_atu)                            // ecluidos visiveis/invisiveis
SETKEY(K_CTRL_W,ctl_w)
SETKEY(K_CTRL_C,ctl_c)
SETKEY(K_CTRL_R,ctl_r)
RETU


PROC AFU_REL(ult_reg)  // imprime relatorio apos inclusao
LOCAL p_imp:=.t., i_ok:=.f., imp_rel:=.f.
DO WHIL .t.
 SAVE SCREEN                     // salva a tela

 #ifdef COM_REDE
  tps=TP_SAIDA(,,.t.)            // escolhe a impressora
  IF LASTKEY()=K_ESC             // se teclou ESC
   EXIT                          // cai fora...
  ENDI
  IF tps=2 .OR. PREPIMP("AUXILIO FUNERAL")   // se nao vai para video conf impressora pronta
   IF categ=[AF]
    ADM_R020(tps,0,ult_reg)
    ADR_R029(tps,0,ult_reg)
   ELSE
    ADM_RX20(tps,0,ult_reg)
    ADR_RX29(tps,0,ult_reg)
   ENDI
   ADM_R029(tps,0,ult_reg)
 #else
  IF PREPIMP("AUXILIO FUNERAL")              // confima preparacao da impressora
   IF categ=[AF]
    ADM_R020(0,0,ult_reg)
    ADR_R029(0,0,ult_reg)
   ELSE
    ADM_RX20(0,0,ult_reg)
    ADR_RX29(0,0,ult_reg)
   ENDI
   ADM_R029(0,0,ult_reg)
 #endi

 REST SCREEN                    // restaura tela
  msg="Prosseguir|Outra c¢pia"
  op_=1 //DBOX(msg,,,E_MENU,,"FIM DE IMPRESSŽO") // quer emitir outra copia?
  IF op_=2
   LOOP                         // nao quer...
  ENDI
 ENDI
 EXIT
ENDD
RETU


#ifdef COM_REDE
 PROC AFU_ANT_SEQ(est_seq)     // restaura sequencial anterior
 SELE AFU_SEQ     // seleciona arquivo de controle de sequencial
 BLOARQ(0,.5)     // esta estacao foi a ultima a incluir?
 IF sq_atual_ == processo
  REPL processo WITH sq_processo
  REPL intlan WITH sq_intlan
 ENDI
 UNLOCK           // libera DBF para outros usuarios
 COMMIT           // atualiza cps sequenciais no disco
 RETU
#endi


PROC AFU_CRIA_SEQ   // cria dbf de controle de campos sequenciais
LOCAL dbfseq_:=sistema[op_sis,O_ARQUI,O_DIR_DBF]+"AFU_seq" // arq temporario
SELE 0                          // seleciona area vazia
IF !FILE(dbfseq_+".dbf")        // se o dbf nao existe
 DBCREATE(dbfseq_,{;            // vamos criar a sua estrutura
                    {"processo"  ,"C",  5, 0},;
                    {"intlan"    ,"C",  8, 0};
                  };
 )
ENDI
USEARQ(dbfseq_,.f.,,,.f.)       // abre arquivo de cps sequencial
IF RECC()=0                     // se o dbf foi criado agora
 BLOARQ(0,.5)                   // inclui um registro que tera
 APPEND BLANK                   // os ultomos cps sequenciais
 SELE AFUNER
 IF RECC()>0                    // se o DBF nao estiver
  SET ORDER TO 0                // vazio, entao enche DBF seq
  GO BOTT                       // com o ultimo reg digitado
  REPL AFU_SEQ->processo WITH processo
  REPL AFU_SEQ->intlan WITH intlan
  DBSETORDER(1)                 // retorna ao indice principal
 ENDI
 SELE AFU_SEQ                   // seleciona arq de sequencias
 UNLOCK                         // libera DBF para outros usuarios
 COMMIT                         // atualiza cps sequenciais no disco
ENDI
RETURN

PROC AFU_GERA_SEQ()

#ifdef COM_REDE
 LOCAL ar_:=SELEC()
#else
 LOCAL reg_:=RECNO(),ord_ind:=INDEXORD()
#endi


#ifdef COM_REDE
 SELE AFU_SEQ
 BLOARQ(0,.5)
 sq_processo=AFU_SEQ->processo
 sq_intlan=AFU_SEQ->intlan
#else
 DBSETORDER(0)
 GO BOTT
#endi

M->processo=LPAD(STR(VAL(processo)+1),05,[0])
M->intlan=LPAD(STR(VAL(intlan)+1),08,[0])

#ifdef COM_REDE
 AFU_GRAVA_SEQ()
 sq_atual_=AFU_SEQ->processo
 UNLOCK                                            // libera o registro
 COMMIT
 SELE (ar_)
#else
 DBSETORDER(ord_ind)
 GO reg_
#endi

RETU

PROC AFU_GRAVA_SEQ
REPL processo WITH M->processo
REPL intlan WITH M->intlan
RETU

PROC AFU_tela     // tela do arquivo AFUNER
tem_borda=.t.
l_s=Sistema[op_sis,O_TELA,O_LS]           // coordenadas da tela
c_s=Sistema[op_sis,O_TELA,O_CS]
l_i=Sistema[op_sis,O_TELA,O_LI]
c_i=Sistema[op_sis,O_TELA,O_CI]
SETCOLOR(drvtittel)
vr_memo=NOVAPOSI(@l_s,@c_s,@l_i,@c_i)     // pega posicao atual da tela
CAIXA(mold,l_s,c_s,l_i,c_i)               // monta caixa da tela
i=LEN(sistema[op_sis,O_MENS])/2
@ l_s,c_s-1+(c_i-c_s+1)/2-i SAY " "+MAIUSC(sistema[op_sis,O_MENS])+" "
SETCOLOR(drvcortel)
@ l_s+01,c_s+1 SAY " Processo..:      /  /    de             Categoria:"
@ l_s+02,c_s+1 SAY " ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ   Dados do Contratante  ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ"
@ l_s+03,c_s+1 SAY " Contrato...:"
@ l_s+04,c_s+1 SAY " Grau.......:"
@ l_s+05,c_s+1 SAY " Respons vel:                                     (Declarante)"
@ l_s+06,c_s+1 SAY " Endere‡o...:                                      Fone:"
@ l_s+07,c_s+1 SAY " ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ   Dados do Falecido   ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ"
@ l_s+08,c_s+1 SAY " Inscrito..:"
@ l_s+09,c_s+1 SAY " Rua...:                                 Bairro:"
@ l_s+10,c_s+1 SAY " Cidade:                           UF:     Dt.Nasc.:"
@ l_s+11,c_s+1 SAY " ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ   Dados do Falecimento   ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ"
@ l_s+12,c_s+1 SAY " Data:            hora:        Endere‡o:"
@ l_s+13,c_s+1 SAY "               Cidade:                           UF:"
@ l_s+14,c_s+1 SAY " Seu sepultamento ser  ..:            hora:"
@ l_s+15,c_s+1 SAY "                Cemit‚rio:"
@ l_s+16,c_s+1 SAY " Funcion rio respons vel.:"
@ l_s+18,c_s+1 SAY " Proc. Pgto em:              Vl.Auxilio:                Pago em"
RETU

PROC AFU_gets     // mostra variaveis do arquivo AFUNER
LOCAL getlist := {}, ord_, chv_, ar_get1:=ALIAS(), op_ant := op_menu
AFU_TELA()
SETCOLOR(drvcortel+","+drvcorget+",,,"+corcampo)
PTAB(CONTRATO,'GRUPOS',1)
PTAB(FUNCRESP,'FNCS',1)
PTAB(PROCESSO+PROC2+M->P_FILIAL+CATEG,[PRCESSOS],1)
PTAB(PADR(SUBSTR(M->IDE_MAQ,2),4)+[AFU],[IMPPAR],1)
CRIT("",,"5")
@ l_s+01 ,c_s+14 GET  processo;
                 PICT sistema[op_sis,O_CAMPO,01,O_MASC]

@ l_s+01 ,c_s+20 GET  proc2;
                 PICT sistema[op_sis,O_CAMPO,02,O_MASC]
		 CRIT(sistema[op_sis,O_CAMPO,02,O_CRIT],,"5")

@ l_s+01 ,c_s+30 GET  ocorr_;
		 PICT sistema[op_sis,O_CAMPO,04,O_MASC]

@ l_s+01 ,c_s+53 GET  categ;
		 PICT sistema[op_sis,O_CAMPO,05,O_MASC]
		 CRIT(sistema[op_sis,O_CAMPO,05,O_CRIT],,"4")

@ l_s+03 ,c_s+15 GET  contrato;
		 PICT sistema[op_sis,O_CAMPO,06,O_MASC]
		 CRIT(sistema[op_sis,O_CAMPO,06,O_CRIT],,"1|2|6")

@ l_s+04 ,c_s+15 GET  grauparcon

@ l_s+05 ,c_s+15 GET  nomedec;
		 PICT sistema[op_sis,O_CAMPO,08,O_MASC]

@ l_s+06 ,c_s+15 GET  ruadec;
                 PICT sistema[op_sis,O_CAMPO,09,O_MASC]

@ l_s+06 ,c_s+58 GET  fonedec;
                 PICT sistema[op_sis,O_CAMPO,10,O_MASC]

@ l_s+08 ,c_s+14 GET  codigofal

@ l_s+08 ,c_s+33 GET  falecido

@ l_s+09 ,c_s+10 GET  ruares

@ l_s+09 ,c_s+50 GET  baires

@ l_s+10 ,c_s+10 GET  munres

@ l_s+10 ,c_s+40 GET  estres;
                 PICT sistema[op_sis,O_CAMPO,16,O_MASC]

@ l_s+10 ,c_s+54 GET  nascto_;
                 PICT sistema[op_sis,O_CAMPO,17,O_MASC]

@ l_s+12 ,c_s+08 GET  falecto_;
                 PICT sistema[op_sis,O_CAMPO,18,O_MASC]

@ l_s+12 ,c_s+25 GET  horafal;
                 PICT sistema[op_sis,O_CAMPO,19,O_MASC]

@ l_s+12 ,c_s+42 GET  ruafal

@ l_s+13 ,c_s+24 GET  municfal

@ l_s+13 ,c_s+54 GET  estfal;
                 PICT sistema[op_sis,O_CAMPO,22,O_MASC]

@ l_s+14 ,c_s+28 GET  sepult_;
                 PICT sistema[op_sis,O_CAMPO,23,O_MASC]

@ l_s+14 ,c_s+45 GET  horasepult;
                 PICT sistema[op_sis,O_CAMPO,24,O_MASC]

@ l_s+15 ,c_s+28 GET  cemitsep

@ l_s+16 ,c_s+28 GET  funcresp;
                 PICT sistema[op_sis,O_CAMPO,26,O_MASC]
                 CRIT(sistema[op_sis,O_CAMPO,26,O_CRIT],,"3")

@ l_s+18 ,c_s+17 GET  procpagto_;
                 PICT sistema[op_sis,O_CAMPO,27,O_MASC]

@ l_s+18 ,c_s+42 GET  vlauxilio;
                 PICT sistema[op_sis,O_CAMPO,28,O_MASC]

@ l_s+18 ,c_s+65 GET  pagtoem_;
                 PICT sistema[op_sis,O_CAMPO,29,O_MASC]

CLEAR GETS
RETU

PROC AFU_get1(tp_mov)     // capta variaveis do arquivo AFUNER
LOCAL getlist := {}, ord_, chv_, ar_get1:=ALIAS(), op_ant := op_menu
PRIV  blk_afuner:=.t.

IF tp_mov=INCLUI
 DO WHILE .t.
  rola_t=.f.
  SET KEY K_ALT_F8 TO ROLATELA
  SETCOLOR(drvcortel+","+drvcorget+",,,"+corcampo)
  CRIT("",,"5")
  @ l_s+01 ,c_s+30 GET  ocorr_;
                   PICT sistema[op_sis,O_CAMPO,04,O_MASC]
                   DEFINICAO 4

  @ l_s+01 ,c_s+53 GET  categ;
                   PICT sistema[op_sis,O_CAMPO,05,O_MASC]
                   DEFINICAO 5
                   MOSTRA sistema[op_sis,O_FORMULA,4]

  @ l_s+03 ,c_s+15 GET  contrato;
                   PICT sistema[op_sis,O_CAMPO,06,O_MASC]
                   DEFINICAO 6
                   MOSTRA sistema[op_sis,O_FORMULA,1]
                   MOSTRA sistema[op_sis,O_FORMULA,2]
                   MOSTRA sistema[op_sis,O_FORMULA,6]

  @ l_s+04 ,c_s+15 GET  grauparcon
                   DEFINICAO 7

  @ l_s+05 ,c_s+15 GET  nomedec;
                   PICT sistema[op_sis,O_CAMPO,08,O_MASC]
                   DEFINICAO 8

  @ l_s+06 ,c_s+15 GET  ruadec;
                   PICT sistema[op_sis,O_CAMPO,09,O_MASC]
                   DEFINICAO 9

  @ l_s+06 ,c_s+58 GET  fonedec;
                   PICT sistema[op_sis,O_CAMPO,10,O_MASC]
                   DEFINICAO 10

  @ l_s+08 ,c_s+14 GET  codigofal
                   DEFINICAO 11

  @ l_s+08 ,c_s+33 GET  falecido
                   DEFINICAO 12

  @ l_s+09 ,c_s+10 GET  ruares
                   DEFINICAO 13

  @ l_s+09 ,c_s+50 GET  baires
                   DEFINICAO 14

  @ l_s+10 ,c_s+10 GET  munres
                   DEFINICAO 15

  @ l_s+10 ,c_s+40 GET  estres;
                   PICT sistema[op_sis,O_CAMPO,16,O_MASC]
                   DEFINICAO 16

  @ l_s+10 ,c_s+54 GET  nascto_;
                   PICT sistema[op_sis,O_CAMPO,17,O_MASC]
                   DEFINICAO 17

  @ l_s+12 ,c_s+08 GET  falecto_;
                   PICT sistema[op_sis,O_CAMPO,18,O_MASC]
                   DEFINICAO 18

  @ l_s+12 ,c_s+25 GET  horafal;
                   PICT sistema[op_sis,O_CAMPO,19,O_MASC]
                   DEFINICAO 19

  @ l_s+12 ,c_s+42 GET  ruafal
                   DEFINICAO 20

  @ l_s+13 ,c_s+24 GET  municfal
                   DEFINICAO 21

  @ l_s+13 ,c_s+54 GET  estfal;
                   PICT sistema[op_sis,O_CAMPO,22,O_MASC]
                   DEFINICAO 22

  @ l_s+14 ,c_s+28 GET  sepult_;
                   PICT sistema[op_sis,O_CAMPO,23,O_MASC]
                   DEFINICAO 23

  @ l_s+14 ,c_s+45 GET  horasepult;
                   PICT sistema[op_sis,O_CAMPO,24,O_MASC]
                   DEFINICAO 24

  @ l_s+15 ,c_s+28 GET  cemitsep
                   DEFINICAO 25

  @ l_s+16 ,c_s+28 GET  funcresp;
                   PICT sistema[op_sis,O_CAMPO,26,O_MASC]
                   DEFINICAO 26
                   MOSTRA sistema[op_sis,O_FORMULA,3]

  @ l_s+18 ,c_s+17 GET  procpagto_;
                   PICT sistema[op_sis,O_CAMPO,27,O_MASC]
                   DEFINICAO 27

  @ l_s+18 ,c_s+42 GET  vlauxilio;
                   PICT sistema[op_sis,O_CAMPO,28,O_MASC]
                   DEFINICAO 28

  @ l_s+18 ,c_s+65 GET  pagtoem_;
                   PICT sistema[op_sis,O_CAMPO,29,O_MASC]
                   DEFINICAO 29

  READ
  SET KEY K_ALT_F8 TO
  IF rola_t
   ROLATELA()
   LOOP
  ENDI
  IF LASTKEY()!=K_ESC .AND. drvincl .AND. op_menu=INCLUSAO
   IF !CONFINCL()
    LOOP
   ENDI
  ENDI
  EXIT
 ENDD
ENDI
PTAB(CONTRATO,'GRUPOS',1)
PTAB(CONTRATO,'TAXAS',1)
PTAB(GRUPOS->GRUPO,'ARQGRUP',1)
PTAB(CODIGOFAL,'INSCRITS',1)
PTAB(FUNCRESP,'FNCS',1)
PTAB(PROCESSO+PROC2+M->P_FILIAL+CATEG,[PRCESSOS],1)
PTAB(PADR(SUBSTR(M->IDE_MAQ,2),4)+[AFU],[IMPPAR],1)
IF tp_mov=EXCLUI .OR. tp_mov=FORM_INVERSA

 #ifdef COM_REDE
  PARAMETROS(dbfparam,'procimp',processo+proc2+filial)
 #else
  PARAMETROS(dbfparam,'procimp',processo+proc2+filial)
 #endi

 IF 1=3
  IF !EMPTY(PRCESSOS->codlan)
   TIRA_LANC("PRCESSOS",LEFT(PRCESSOS->codlan,16))
  ENDI
 ENDI
 IF 1=3
  IF !EMPTY(IMPPAR->codlan)
   TIRA_LANC("IMPPAR",LEFT(IMPPAR->codlan,16))
  ENDI
 ENDI
 IF !EMPTY(ALIAS())
  DELE
 ENDI
ELSEIF tp_mov=INCLUI .OR. tp_mov=RECUPERA .OR. tp_mov=FORM_DIRETA
 IF (op_menu=INCLUSAO .AND. LASTKEY()!=K_ESC) .OR. op_menu!=INCLUSAO
  IF !PTAB(processo+proc2+M->p_filial+categ,[PRCESSOS],1)
   ord_=LEN(sistema[EVAL(qualsis,"PRCESSOS"),O_CHAVE])
   IF !EMPTY(PRCESSOS->codlan)
    chv_=LEFT(PRCESSOS->codlan,16)
   ELSE
    IF TYPE("M->intlan")="C" .AND. EMPTY(intlan)
     chv_="AFU-"+M->intlan+"-001"
    ELSE
     chv_="AFU-"+intlan+"-001"
    ENDI
   ENDI
   PTAB(chv_,"PRCESSOS",ord_)
   FAZ_LANC("PRCESSOS",chv_)
   REPL PRCESSOS->processo WITH processo+proc2+M->p_filial,;
        PRCESSOS->categ WITH categ,;
        PRCESSOS->grup WITH GRUPOS->grupo,;
        PRCESSOS->num WITH contrato,;
        PRCESSOS->grau WITH SUBSTR(codigofal,10,1),;
        PRCESSOS->seq WITH VAL(SUBSTR(codigofal,11,2)),;
        PRCESSOS->seg WITH nomedec,;
        PRCESSOS->ends WITH ruares,;
        PRCESSOS->cids WITH munres,;
        PRCESSOS->fal WITH falecido,;
        PRCESSOS->sep WITH cemitsep,;
        PRCESSOS->dfal WITH falecto_
   SELE PRCESSOS                                   // arquivo alvo do lancamento
   op_menu=ALTERACAO
   PRC_GET1(FORM_DIRETA)                           // faz processo do arq do lancamento
   op_menu=op_ant

   #ifdef COM_REDE
    UNLOCK                                         // libera o registro
   #endi

   IF EMPT(ar_get1)                                // retorna para area original
    SELE 0
   ELSE
    SELE (ar_get1)
   ENDI
  ENDI
  IF !PTAB(PADR(SUBSTR(M->ide_maq,2),4)+[AFU],[IMPPAR],1)
   ord_=LEN(sistema[EVAL(qualsis,"IMPPAR"),O_CHAVE])
   IF !EMPTY(IMPPAR->codlan)
    chv_=LEFT(IMPPAR->codlan,16)
   ELSE
    IF TYPE("M->intlan")="C" .AND. EMPTY(intlan)
     chv_="AFU-"+M->intlan+"-002"
    ELSE
     chv_="AFU-"+intlan+"-002"
    ENDI
   ENDI
   PTAB(chv_,"IMPPAR",ord_)
   FAZ_LANC("IMPPAR",chv_)
   REPL IMPPAR->idmaq WITH PADR(SUBSTR(M->ide_maq,2),4),;
        IMPPAR->base WITH [AFU]

   #ifdef COM_REDE
    IMPPAR->(DBUNLOCK())                           // libera o registro
   #endi

  ENDI
  PARAMETROS(dbfparam,'procimp',processo+proc2+filial)

  #ifdef COM_REDE
   IF op_menu=INCLUSAO
    filial=M->p_filial
   ELSE
    REPL filial WITH M->p_filial
   ENDI
   IF PTAB(processo+proc2+M->p_filial+categ,[PRCESSOS],1).AND.(EMPT(PRCESSOS->saiu).OR.PRCESSOS->saiu=ARQGRUP->ultcirc)
    REPBLO('PRCESSOS->categ',{||categ})
   ENDI
   IF PTAB(processo+proc2+M->p_filial+categ,[PRCESSOS],1).AND.(EMPT(PRCESSOS->saiu).OR.PRCESSOS->saiu=ARQGRUP->ultcirc)
    REPBLO('PRCESSOS->ends',{||ruares})
   ENDI
   IF PTAB(processo+proc2+M->p_filial+categ,[PRCESSOS],1).AND.(EMPT(PRCESSOS->saiu).OR.PRCESSOS->saiu=ARQGRUP->ultcirc)
    REPBLO('PRCESSOS->cids',{||munres})
   ENDI
   IF PTAB(processo+proc2+M->p_filial+categ,[PRCESSOS],1).AND.(EMPT(PRCESSOS->saiu).OR.PRCESSOS->saiu=ARQGRUP->ultcirc)
    REPBLO('PRCESSOS->fal',{||falecido})
   ENDI
   IF PTAB(processo+proc2+M->p_filial+categ,[PRCESSOS],1).AND.(EMPT(PRCESSOS->saiu).OR.PRCESSOS->saiu=ARQGRUP->ultcirc)
    REPBLO('PRCESSOS->dfal',{||falecto_})
   ENDI
   IF PTAB(PADR(M->ide_maq,4)+[AFU],[IMPPAR],1)
    REPBLO('IMPPAR->docto',{||processo+proc2+filial+categ})
   ENDI
  #else
  PARAMETROS(dbfparam,'procimp',processo+proc2+filial)
   IF op_menu=INCLUSAO
    filial=M->p_filial
   ELSE
    REPL filial WITH M->p_filial
   ENDI
   IF PTAB(processo+proc2+M->p_filial+categ,[PRCESSOS],1).AND.(EMPT(PRCESSOS->saiu).OR.PRCESSOS->saiu=ARQGRUP->ultcirc)
    REPL PRCESSOS->categ WITH categ
   ENDI
   IF PTAB(processo+proc2+M->p_filial+categ,[PRCESSOS],1).AND.(EMPT(PRCESSOS->saiu).OR.PRCESSOS->saiu=ARQGRUP->ultcirc)
    REPL PRCESSOS->ends WITH ruares
   ENDI
   IF PTAB(processo+proc2+M->p_filial+categ,[PRCESSOS],1).AND.(EMPT(PRCESSOS->saiu).OR.PRCESSOS->saiu=ARQGRUP->ultcirc)
    REPL PRCESSOS->cids WITH munres
   ENDI
   IF PTAB(processo+proc2+M->p_filial+categ,[PRCESSOS],1).AND.(EMPT(PRCESSOS->saiu).OR.PRCESSOS->saiu=ARQGRUP->ultcirc)
    REPL PRCESSOS->fal WITH falecido
   ENDI
   IF PTAB(processo+proc2+M->p_filial+categ,[PRCESSOS],1).AND.(EMPT(PRCESSOS->saiu).OR.PRCESSOS->saiu=ARQGRUP->ultcirc)
    REPL PRCESSOS->dfal WITH falecto_
   ENDI
   IF PTAB(PADR(M->ide_maq,4)+[AFU],[IMPPAR],1)
    REPL IMPPAR->docto WITH processo+proc2+filial+categ
   ENDI
  #endi

  IF op_menu!=INCLUSAO
   RECA
  ENDI
 ENDI
ENDI
RETU

* \\ Final de AFUNER.PRG
GAS-Pro v4.0
011021015062001001015001012000176001
 Numero..:   -

 Confirme:
[Ÿ]
[Ÿ]
 2 
 0 
Recibo Sem Falecidos
Recibo Sem Falecidos







056
























 0 











 0 
 0 
-1 
-1 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
rnumero
C
E
99999999
 8 
 8 
 1 
 15 
 0 
Numero

!EMPT(rnumero)
Necess rio informar NUMERO
IF(PTAB(PADR(SUBSTR(M->ide_maq,2),4)+[BXR],[IMPPAR],1),IMPPAR->docto,[])
Informe o n£mero do recibo
VDBF(6,3,20,77,'BXREC',{'numero','codigo','cobranca','valorpg','emitido_','por'},1,'numero',[])
 0 
 0 


confirme
C
E
!
 1 
 1 
 3 
 12 
 0 
Confirme

confirme='S'.AND.V01801F9()
CONFIRME n„o aceit vel|Digite S para confirmar|ou|Tecle ESC para cancelar

Digite S para confirmar|ou|tecle ESC para cancelar

 0 
 0 


 0 
 0 
 0 
 0 
 0 
procedure grcompl
/*
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
 \ Empresa.: PresServ Inform tica-Limeira (019)452.6623
 \ Programa: GRCOMPL.PRG
 \ Data....: 13-09-96
 \ Sistema.: Administradora - RECEP€„O
 \ Funcao..: Tela complementar do subsistema de consulta contrato
 \ Analista: Ademilson Pedro Bom
 \ Criacao.: GAS-Pro v2.0d
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/
#include "admbig.ch"    // inicializa constantes manifestas

PARA lin_menu,col_menu
PRIV op_sis, tela_fundo:=SAVESCREEN(0,0,MAXROW(),79)
op_sis=EVAL(qualsis,"GRUPOS")
IF nivelop<1                                       // se usuario nao tem permissao,
 ALERTA()                                          // entao, beep, beep, beep
 DBOX(msg_auto,,,3)                                // lamentamos e
 RETU                                              // retornamos ao menu
ENDI
cn:=fgrep :=.f.
criterio=""
SELE A                                             // e abre o arquivo e seus indices

#ifdef COM_REDE
 IF !USEARQ(sistema[op_sis,O_ARQUI],.f.,20,1)      // se falhou a abertura do
  RETU                                             // arquivo volta ao menu anterior
 ENDI
#else
 USEARQ(sistema[op_sis,O_ARQUI])
#endi

SET KEY K_F9 TO veoutros                           // habilita consulta em outros arquivos
IF AT("D",exrot[op_sis])=0                         // se usuario pode fazer inclusao
 GRC_INCL()                                        // neste arquivo chama prg de inclusao
ELSE                                               // caso contrario vamos avisar que
 ALERTA()                                          // ele nao tem permissao para isto
 DBOX(msg_auto,,,3)
ENDI
SET KEY K_F9 TO                                    // F9 nao mais consultara outros arquivos
CLOS ALL                                           // fecha todos arquivos abertos
RETU

PROC GRC_incl     // inclusao no arquivo GRUPOS
LOCAL getlist:={}, cabem:=1, ult_reg:=RECN(),;
      ctl_r, ctl_c, ctl_w, t_f4_, dele_atu:=SET(_SET_DELETED,.f.)
PRIV op_menu:=TEL_EXTRA, blk_grupos:=.t., tem_borda, criterio:="", cpord:=""
ctl_w=SETKEY(K_CTRL_W,{||nadafaz()})               // enganando o CA-Clipper...
ctl_c=SETKEY(K_CTRL_C,{||nadafaz()})
ctl_r=SETKEY(K_CTRL_R,{||nadafaz()})
l_a=0
DO WHIL cabem>0
 cod_sos=6
 rola_t=.f.                                        // flag se quer rolar a tela
 SELE GRUPOS
 GO BOTT                                           // forca o
 SKIP                                              // final do arquivo
 
 /*
    cria variaveis de memoria identicas as de arquivo, para inclusao
    de registros
 */
 FOR i=1 TO FCOU()
  msg=FIEL(i)
  M->&msg.=&msg.
 NEXT
 DISPBEGIN()                                       // apresenta a tela de uma vez so
 GRC_TELA()
 INFOSIS()                                         // exibe informacao no rodape' da tela
 DISPEND()
 SELE 0                                            // torna visiveis variaveis de memoria
 SETCOLOR(drvcortel+","+drvcorget+",,,"+corcampo)
 SET KEY K_ALT_F8 TO ROLATELA
 
 /*
    recebe chaves do arquivo de indice basico
 */
 @ l_s+01 ,c_s+25 GET  codigo;
                  PICT sistema[op_sis,O_CAMPO,01,O_MASC]
                  DEFINICAO 1
                  MOSTRA sistema[op_sis,O_FORMULA,13]

 READ
 SET KEY K_ALT_F8 TO
 IF rola_t
  ROLATELA(.f.)
  LOOP
 ENDI
 SELE GRUPOS
 IF LASTKEY()=K_ESC                                // cancelou ou chave em branco
  cabem=0                                          // prepara saida da inclusao
  LOOP                                             // volta p/ menu de cadastramento
 ENDI
 SEEK M->codigo
 IF !FOUND() .OR. DELE()                           // se nao encontrou ou esta
  ALERTA()                                         // excluido, avisa e volta
  DBOX("REGISTRO NAO ENCONTRADO OU EXCLUIDO",12,,1)// para receber nova chave
  LOOP
 ENDI

 #ifdef COM_REDE
  IF !BLOREG(3,.5)                                 // se nao conseguiu bloquear o
   LOOP                                            // registro, volta ao menu
  ENDI
 #endi

 FOR i=1 TO FCOU()                                 // inicializa variaveis
  msg=FIEL(i)                                      // de memoria com o mesmo
  M->&msg.=&msg.                                   // valor valor dos campos
 NEXT                                              // do arquivo
 SELE 0
 GRC_GET1()                                        // modificando o registro
 SELE GRUPOS
 IF LASTKEY()!=K_ESC                               // se nao cancelou modificacoes
  FOR i=1 TO FCOU()                                // para cada campo,
   msg=FIEL(i)                                     // salva o conteudo
   REPL &msg. WITH M->&msg.                        // da memoria no arquivo
  NEXT
 ENDI

 #ifdef COM_REDE
  UNLOCK                                           // libera registro
 #endi

ENDD
GO ult_reg                                         // para o ultimo reg digitado
SET(_SET_DELETED,dele_atu)                            // ecluidos visiveis/invisiveis
SETKEY(K_CTRL_W,ctl_w)
SETKEY(K_CTRL_C,ctl_c)
SETKEY(K_CTRL_R,ctl_r)
RETU

PROC GRC_tela     // tela do arquivo GRUPOS
tem_borda=.t.
l_s=4                                     // coordenadas da tela
c_s=17
l_i=22
c_i=68
SETCOLOR(drvtittel)
vr_memo=NOVAPOSI(@l_s,@c_s,@l_i,@c_i)     // pega posicao atual da tela
CAIXA(mold,l_s,c_s,l_i,c_i)               // monta caixa da tela
@ l_s,c_s+17 SAY MAIUSC(" Consulta Contrato ")
SETCOLOR(drvcortel)
@ l_s+01,c_s+1 SAY " Grupo:      Contrato:"
@ l_s+02,c_s+1 SAY "ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄ"
@ l_s+03,c_s+1 SAY "                                     ³ Circulares"
@ l_s+04,c_s+1 SAY "                                     ³  Ini"
@ l_s+05,c_s+1 SAY "                           Reg.:     ³  £lt"
@ l_s+06,c_s+1 SAY "                                     ³  Qtd"
@ l_s+07,c_s+1 SAY " Admiss„o:           Sai Taxa:       ³"
@ l_s+08,c_s+1 SAY " Funerais:           Cobrador:       ³  Pend"
@ l_s+09,c_s+1 SAY "ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄ"
@ l_s+10,c_s+1 SAY "  Cir Emiss„o     Valor   Pago em     Valor"
RETU

PROC GRC_gets     // mostra variaveis do arquivo GRUPOS
LOCAL getlist := {}, t_f7_
GRC_TELA()
SETCOLOR(drvcortel+","+drvcorget+",,,"+corcampo)
CRIT("",,"14|15|16|17|18|19|20|21|22|23|24|25")
@ l_s+01 ,c_s+25 GET  codigo;
                 PICT sistema[op_sis,O_CAMPO,01,O_MASC]
                 CRIT(sistema[op_sis,O_CAMPO,01,O_CRIT],,"13")

@ l_s+01 ,c_s+09 GET  grupo;
                 PICT sistema[op_sis,O_CAMPO,02,O_MASC]

CLEAR GETS
RETU

PROC GRC_get1     // capta variaveis do arquivo GRUPOS
LOCAL getlist := {}, t_f7_
DO WHILE .t.
 rola_t=.f.
 memo24:="{F7}"
 t_f7_=SETKEY(K_F7,{||GRC_memo()})
 SET KEY K_ALT_F8 TO ROLATELA
 SETCOLOR(drvcortel+","+drvcorget+",,,"+corcampo)
 CRIT("",,"14|15|16|17|18|19|20|21|22|23|24|25")
 @ l_s+01 ,c_s+09 GET  grupo;
                  PICT sistema[op_sis,O_CAMPO,02,O_MASC]
                  DEFINICAO 2

 READ
 SETKEY(K_F7,t_f7_)
 SET KEY K_ALT_F8 TO
 IF rola_t
  ROLATELA(.f.)
  LOOP
 ENDI
 IF LASTKEY()!=K_ESC .AND. drvincl
  IF !CONFINCL()
   LOOP
  ENDI
 ENDI
 EXIT
ENDD
RETU

PROC GRC_MEMO
IF READVAR()="MEMO24"
 EDIMEMO("obs",sistema[op_sis,O_CAMPO,24,O_TITU],14,2,23,37)
ENDI
RETU

* \\ Final de GRCOMPL.PRG
€
 ADM_R023V–Þ  ADM_R023CODEREL_CABCODEC_ETEXTENDCODE	_SYMSTARTSYMSTARTSYMBOLSSYMBOLS_SYMENDSYMENDNULLBEGDATA_DATADATA_SYMPBDATA_SYMPDATA_SYMPEDATA_CONSTCONST_MSGMSG_BEGBSSBEGBSS_BSSBSS_ENDBSSENDBSSDGROUPÚ˜ @3Ö˜ @  w˜ H  ˜ h  	ç˜ ` 
Ä˜ h  ß˜ h  Û˜ H  ÷˜ H  ó˜ H ç˜ H  ë˜ H  ç˜ (  €
 BXR_07F9=–Ñ  BXR_07F9CODEC_ETEXTENDCODE	_SYMSTARTSYMSTARTSYMBOLSSYMBOLS_SYMENDSYMENDNULLBEGDATA_DATADATA_SYMPBDATA_SYMPDATA_SYMPEDATA_CONSTCONST_MSGMSG_BEGBSSBEGBSS_BSSBSS_ENDBSSENDBSSDGROUPü˜ @˜ H  ˜ h  ë˜ `À	.˜ h  
ã˜ h  ß˜ H  û˜ H  ÷˜ H ë˜ H  ï˜ H  ë˜ (  ˜ H  €
 ADR_ESTRú–Y ADR_ESTRCODEBXR_ESTRCODEALE_ESTRCODEOBX_ESTRCODEGRU_ESTRCODETAX_ESTRCODEECO_ESTRCODEINS_ESTRCODEGUI_ESTRCODEAFU_ESTRCODEIMP_ESTRCODEMED_ESTRCODETES_ESTRCODEJUR_ESTRCODETFI_ESTRCODEARQ_ESTRCODEREG_ESTRCODECOB_ESTRCODECLA_ESTRCODECIR_ESTRCODECPR_ESTRCODEPRC_ESTRCODEFNC_ESTRCODEHIS_ESTRCODECST_ESTRCODEMEN_ESTRCODEORD_ESTRCODEPAR_ESTRCODEMFI_ESTRCODEC_ETEXTENDCODE	_SYMSTARTSYMSTARTSYMBOLSSYMBOLS_SYMENDSYMENDNULLBEGDATA_DATADATA_SYMPBDATA_SYMPDATA_SYMPEDATA_CONSTCONST_MSGMSG_BEGBSSBEGBSS_BSSBSS_ENDBSSENDBSSDGROUP˜ @€ CTXASñ–Î  CTXASCODEC_ETEXTENDCODE	_SYMSTARTSYMSTARTSYMBOLSSYMBOLS_SYMENDSYMENDNULLBEGDATA_DATADATA_SYMPBDATA_SYMPDATA_SYMPEDATA_CONSTCONST_MSGMSG_BEGBSSBEGBSS_BSSBSS_ENDBSSENDBSSDGROUP°˜ @dµ˜ H  ˜ h  ë˜ `p	~˜ h  
ã˜ h  ß˜ H  û˜ H  ÷˜ H ë˜ H  ï˜ H  ë˜ (  ˜ H  procedure imppar
/*
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
 \ Empresa.: PresServ Inform tica - Limeira (019)452.6623
 \ Programa: IMPPAR.PRG
 \ Data....: 04-11-03
 \ Sistema.: Administradora - RECEP€„O
 \ Funcao..: Gerenciador do subsistema de documento … imprimir
 \ Analista: Ademilson Pedro Bom
 \ Criacao.: GAS-Pro v4.0n
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/
#include "adrbig.ch"    // inicializa constantes manifestas

PARA lin_menu,col_menu
PRIV op_sis, tela_fundo:=SAVESCREEN(0,0,MAXROW(),79), l_s, c_s, l_i, c_i, l_a

op_sis=EVAL(qualsis,"IMPPAR")
IF nivelop<sistema[op_sis,O_OUTROS,O_NIVEL]        // se usuario nao tem permissao,
 ALERTA()                                          // entao, beep, beep, beep
 DBOX(msg_auto,,,3)                                // lamentamos e
 RETU                                              // retornamos ao menu
ENDI
cn:=fgrep :=.f.

#ifdef COM_LOCK
 IF LEN(pr_ok)>0                                   // se a protecao acusou
  ? pr_ok                                          // erro, avisa e
  QUIT                                             // encerra a aplicacao
 ENDI
#endi

criterio=""
PARAMETROS(dbfparam)
SELE A                                             // e abre o arquivo e seus indices

#ifdef COM_REDE
 IF !USEARQ(sistema[op_sis,O_ARQUI,O_NOME],.f.,20,1)
                                                   // se falhou a abertura do
  RETU                                             // arquivo volta ao menu anterior
 ENDI
#else
 USEARQ(sistema[op_sis,O_ARQUI,O_NOME])
#endi

SET KEY K_F9 TO veoutros                           // habilita consulta em outros arquivos
op_menu=ALTERACAO
cod_sos=7
EDIT()
SET KEY K_F9 TO                                    // F9 nao mais consultara outros arquivos
CLOS ALL                                           // fecha todos arquivos abertos
RETU

PROC IMP_incl(reg_cop)  // inclusao no arquivo IMPPAR
LOCAL getlist:={}, cabem:=1, rep:=ARRAY(FCOU()), ult_reg:=RECN(),;
      ctl_r, ctl_c, t_f3_, t_f4_, l_max, dele_atu:=SET(_SET_DELETED,.f.)
PRIV op_menu:=INCLUSAO, tem_borda, criterio:="", cpord:="", l_a
FOR i=1 TO FCOU()                                  // cria/declara privadas as
 msg=FIEL(i)                                       // variaveis de memoria com
 PRIV &msg.                                        // o mesmo nome dos campos
NEXT                                               // do arquivo
IF reg_cop!=NIL                                    // quer repetir todo o reg atual
 FOR i=1 TO FCOU()                                 // para cada campo,
  msg=FIEL(i)                                      // salva o conteudo
  rep[i]=&msg.                                     // para repetir
 NEXT
ELSE
 AFILL(rep,"")                                     // eche com valor vazio
ENDI
t_f3_=SETKEY(K_F3,{||rep()})                       // repeticao reg anterior
t_f4_=SETKEY(K_F4,{||conf()})                      // confirma campos com ENTER
ctl_w=SETKEY(K_CTRL_W,{||nadafaz()})               // enganando o CA-Clipper...
ctl_c=SETKEY(K_CTRL_C,{||nadafaz()})
ctl_r=SETKEY(K_CTRL_R,{||nadafaz()})
DISPBEGIN()                                        // monta tela na pagina de traz
IMP_TELA()                                         // imp tela para inclusao
INFOSIS(.t.)                                       // exibe informacao no rodape' da tela
l_a=Sistema[op_sis,O_TELA,O_SCROLL]
DISPEND()                                          // apresenta tela de uma vez so
DO WHIL cabem>0
 rola_t=.f.                                        // flag se quer rolar a tela
 SELE IMPPAR
 GO BOTT                                           // forca o
 SKIP                                              // final do arquivo
 
 /*
    cria variaveis de memoria identicas as de arquivo, para inclusao
    de registros
 */
 FOR i=1 TO FCOU()
  msg=FIEL(i)
  M->&msg.=IF((fgrep .OR. reg_cop!=NIL).AND.!EMPT(rep[1]),rep[i],&msg.)
 NEXT
 cabem=DISKSPACE(;
          IF(;
             LEN(sistema[op_sis,O_ARQUI,O_DIR_DBF])<2.OR.sistema[op_sis,O_ARQUI,O_DIR_DBF]="\",;
             0,;
             ASC(sistema[op_sis,O_ARQUI,O_DIR_DBF])-64;
          );
       )
 cabem=INT((cabem-2048)/IMPPAR->(RECSIZE()))
 IF cabem<1                                        // mais nenhum!!!
  ALERTA()
  msg="Verifique ESPA€O EM DISCO, "+usuario
  DBOX(msg,,,,,"INCLUSŽO INTERROMPIDA!")           // vamos parar por aqui!
  EXIT
 ENDI
 SELE 0                                            // torna visiveis variaveis de memoria
 SETCOLOR(drvcortel+","+drvcorget+",,,"+corcampo)
 SET KEY K_ALT_F8 TO ROLATELA
 
 /*
    recebe chaves do arquivo de indice basico
 */
 @ l_s+l_a,c_s+03 GET  idmaq;
                  PICT sistema[op_sis,O_CAMPO,01,O_MASC]
                  DEFINICAO 1

 @ l_s+l_a,c_s+10 GET  base;
                  PICT sistema[op_sis,O_CAMPO,02,O_MASC]
                  DEFINICAO 2

 READ
 SET KEY K_ALT_F8 TO
 IF rola_t
  ROLATELA()
  LOOP
 ENDI
 SELE IMPPAR
 IF LASTKEY()=K_ESC                                // cancelou ou chave em branco
  cabem=0                                          // prepara saida da inclusao
  LOOP                                             // volta p/ menu de cadastramento
 ENDI
 SEEK M->idmaq+M->base
 aprov_reg_=(FOUND().AND.DELE().AND.!drvvisivel)   // vai aproveitar o registro?
 IF FOUND() .AND. !aprov_reg_                      // pesquisou e achou!
  l_a=Sistema[op_sis,O_TELA,O_SCROLL]
  op_menu=ALTERACAO                                // seta flag de ateracao
  DISPBEGIN()
  IMP_GETS()                                       // mostra conteudo do registro
  INFOSIS(.f.)                                     // exibe informacao no rodape' da tela
  DISPEND()
  ALERTA()
  msg="Consultar/alterar|Retornar … inclus„o"      // pergunta se deseja
  op_=DBOX(msg,,,E_MENU,,"REGISTRO J EXISTE")     // alterar o registro
  IF op_ =1                                        // caso afirmativo
   EDIT()                                          // deixa alterar
  ENDI
  op_menu=INCLUSAO
  DISPBEGIN()
  IMP_TELA()
  INFOSIS(.t.)                                     // exibe informacao no rodape' da tela
  DISPEND()
  LOOP                                             // volta para inclusao
 ENDI
 SELE 0
 IMP_GET1(INCLUI)                                  // recebe campos
 SELE IMPPAR
 IF LASTKEY()=K_ESC                                // se cancelou
  ALERTA()                                         // avisa que o registro
  DBOX("Registro n„o inclu¡do!",18,,1)             // nao foi incluido, e volta
  LOOP
 ENDI

 #ifdef COM_REDE
  GO BOTT                                          // vamos bloquear o final do
  SKIP                                             // arq para que nehum outro
  BLOREG(0,.5)                                     // usuario possa incluir
  SEEK M->idmaq+M->base                            // se registro foi incluido
  aprov_reg_=(FOUND().AND.DELE().AND.!drvvisivel)  // vai aproveitar o registro?
  IF FOUND() .AND. !aprov_reg_                     // por outro usuario, entao
   BLOREG(0,.5)
   FOR i=1 TO FCOU()
    msg=FIEL(i)
    rep[i]=&msg.
    REPL &msg. WITH M->&msg.
   NEXT
   IMP_GET1(FORM_INVERSA)                          // executa formula inversa
   RECA
   FOR i=1 TO FCOU()
    msg=FIEL(i)
    REPL &msg. WITH rep[i]
   NEXT
   ALERTA(4)                                       // beep 4 vezes
   msg="Registro acabou de ser|inclu¡do por outro usu rio!"
   DBOX(msg,,,,,"ATEN€ŽO!")                        // avisa
   SELE IMPPAR
   UNLOCK                                          // libera o registro
   LOOP                                            // e recebe chave novamente
  ENDI
 #endi

 IF aprov_reg_                                     // se vai aproveitar reg excluido

  #ifdef COM_REDE
   BLOREG(0,.5)
  #endi

  RECA                                             // excluido, vamos recupera-lo
 ELSE                                              // caso contrario
  APPEND BLANK                                     // inclui reg em branco no dbf
 ENDI
 FOR i=1 TO FCOU()                                 // para cada campo,
  msg=FIEL(i)                                      // salva o conteudo
  rep[i]=M->&msg.                                  // para repetir
  REPL &msg. WITH rep[i]                           // enche o campo do arquivo
 NEXT

 #ifdef COM_REDE
  UNLOCK                                           // libera o registro e
  COMMIT                                           // forca gravacao
 #else
  IF RECC()-INT(RECC()/20)*20=0                    // a cada 20 registros
   COMMIT                                          // digitados forca gravacao
  ENDI
 #endi

 ult_reg=RECN()                                    // ultimo registro digitado
 l_max=l_s+Sistema[op_sis,O_TELA,O_SCROLL]+Sistema[op_sis,O_TELA,O_QTDE]
 IF l_s+l_a+1<l_max                                // se nao atingiu o fim da tela
  l_a++                                            // digita na proxima linha
 ELSE                                              // se nao rola a campos para cima
  SCROLL(l_s+Sistema[op_sis,O_TELA,O_SCROLL],c_s+03,l_max-1,c_s+06,1)
  SCROLL(l_s+Sistema[op_sis,O_TELA,O_SCROLL],c_s+10,l_max-1,c_s+12,1)
  SCROLL(l_s+Sistema[op_sis,O_TELA,O_SCROLL],c_s+15,l_max-1,c_s+26,1)
  SCROLL(l_s+Sistema[op_sis,O_TELA,O_SCROLL],c_s+28,l_max-1,c_s+62,1)
 ENDI
 IF reg_cop!=NIL                                   // estava na consulta e quis rep o campo
  EXIT                                             // cai fora...
 ENDI
ENDD
GO ult_reg                                         // para o ultimo reg digitado
SETKEY(K_F3,t_f3_)                                 // restaura teclas de funcoes
SETKEY(K_F4,t_f4_)
SET(_SET_DELETED,dele_atu)                            // ecluidos visiveis/invisiveis
SETKEY(K_CTRL_W,ctl_w)
SETKEY(K_CTRL_C,ctl_c)
SETKEY(K_CTRL_R,ctl_r)
RETU


PROC IMP_tela     // tela do arquivo IMPPAR
tem_borda=.t.
l_s=Sistema[op_sis,O_TELA,O_LS]           // coordenadas da tela
c_s=Sistema[op_sis,O_TELA,O_CS]
l_i=Sistema[op_sis,O_TELA,O_LI]
c_i=Sistema[op_sis,O_TELA,O_CI]
SETCOLOR(drvtittel)
vr_memo=NOVAPOSI(@l_s,@c_s,@l_i,@c_i)     // pega posicao atual da tela
CAIXA(mold,l_s,c_s,l_i,c_i)               // monta caixa da tela
i=LEN(sistema[op_sis,O_MENS])/2
@ l_s,c_s-1+(c_i-c_s+1)/2-i SAY " "+MAIUSC(sistema[op_sis,O_MENS])+" "
SETCOLOR(drvcortel)
@ l_s+01,c_s+1 SAY " Esta‡„o Base   Documento"
@ l_s+02,c_s+1 SAY "ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ"
RETU

PROC IMP_gets     // mostra variaveis do arquivo IMPPAR
LOCAL getlist := {}, l_max, reg_atual:=RECNO()
PRIV  l_a:=Sistema[op_sis,O_TELA,O_SCROLL]
IMP_TELA()
l_max=l_s+Sistema[op_sis,O_TELA,O_SCROLL]+Sistema[op_sis,O_TELA,O_QTDE]
SETCOLOR(drvcortel+","+drvcorget+",,,"+corcampo)
DO WHILE !EOF() .AND. l_s+l_a<l_max
 CRIT("",,"1")
 @ l_s+l_a,c_s+03 GET  idmaq;
                  PICT sistema[op_sis,O_CAMPO,01,O_MASC]

 @ l_s+l_a,c_s+10 GET  base;
                  PICT sistema[op_sis,O_CAMPO,02,O_MASC]

 @ l_s+l_a,c_s+15 GET  docto

 SETCOLOR(drvcortel+","+drvcortel+",,,"+drvcortel)
 l_a++
 SKIP
ENDD
GO reg_atual
SETCOLOR(drvcortel+","+drvcorget+",,,"+corcampo)
CLEAR GETS
RETU

PROC IMP_get1(tp_mov)     // capta variaveis do arquivo IMPPAR
LOCAL getlist := {}
PRIV  blk_imppar:=.t.

IF tp_mov=INCLUI
 IF TYPE("l_a")!="N"
  l_a=Sistema[op_sis,O_TELA,O_SCROLL]
 ENDI
 DO WHILE .t.
  rola_t=.f.
  SET KEY K_ALT_F8 TO ROLATELA
  SETCOLOR(drvcortel+","+drvcorget+",,,"+corcampo)
  CRIT("",,"1")
  @ l_s+l_a,c_s+15 GET  docto
                   DEFINICAO 3

  READ
  SET KEY K_ALT_F8 TO
  IF rola_t
   ROLATELA()
   LOOP
  ENDI
  IF LASTKEY()!=K_ESC .AND. drvincl .AND. op_menu=INCLUSAO
   IF !CONFINCL()
    LOOP
   ENDI
  ENDI
  EXIT
 ENDD
ENDI
IF tp_mov=EXCLUI .OR. tp_mov=FORM_INVERSA
 IF !EMPTY(codlan) .AND. tp_mov=EXCLUI
  ALERTA()       // existe registro validado aqui!
  msg="Registro de Lan‡amento"
  DBOX(msg,,,,,"IMPOSS¡VEL EXCLUIR!")
 ELSE
  DELE
 ENDI
ELSEIF tp_mov=INCLUI .OR. tp_mov=RECUPERA .OR. tp_mov=FORM_DIRETA
 IF !EMPTY(codlan) .AND. tp_mov=RECUPERA
  ALERTA()       // existe registro validado aqui!
  msg="Registro de Lan‡amento"
  DBOX(msg,,,,,"IMPOSS¡VEL RECUPERAR!")
 ELSE
  IF op_menu!=INCLUSAO
   RECA
  ENDI
 ENDI
ENDI
RETU

* \\ Final de IMPPAR.PRG
/*
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
 \ Empresa.: Ind£stria de Urnas Bignotto Ltda
 \ Programa: BXR_01F9.PRG
 \ Data....: 20-11-95
 \ Sistema.: Administradora de Funer rias
 \ Funcao..: F¢rmula (Circ 1 - 4) a mostrar na tela de BXREC
 \ Analista: Ademilson Pedro Bom
 \ Criacao.: Programado manualmente pelo analista
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/

#include "adrbig.ch"    // inicializa constantes manifesta

 LOCAL reg_dbf:=POINTER_DBF()
 LOCAL circax1:=circax2:=circax3:=circax4:=circax5:=circax6:=SPACE(46)
 LOCAL cipend:=ciatrz:=nrd:=vladd:=0, jrok
 IF !op_menu = INCLUSAO
  codigo:=OBXEC->codigo
  RETU .T.
 ENDIF
 IF EMPT(codigo)
  RETU .T.
 ENDI

 dele_atu:=SET(_SET_DELETED,.t.)             // os excluidos nao servem...
 circax1:=circax2:=circax3:=circax4:=circax5:=circax6:=SPACE(46)

 PTAB(ALLTRIM(codigo),'GRUPOS',1)
 PTAB(ALLTRIM(codigo),'TAXAS',1)
 SELE TAXAS
// DBOX(CODIGO+[|TAXAS ]+TAXAS->codigo+[|Grupos ]+GRUPOS->codigo)
 DO WHILE !EOF().AND.TAXAS->codigo=GRUPOS->codigo
  IF DELE()
   SKIP
   LOOP
  ENDI
  vladd:=0
  IF EMPT(TAXAS->valorpg)
   cipend++
   IF TAXAS->emissao_< DATE()
    ciatrz++
    jrok:=PTAB(tipo,'JUROS',1)
    nrd:=(DATE() - TAXAS->emissao_)
    IF jrok .AND. (nrd > JUROS->mltcaren)
     vladd+=TAXAS->valor*JUROS->multa/100
    ENDI
    IF jrok .AND. (nrd > JUROS->jrscaren)
     vladd+=TAXAS->valor*JUROS->juros/100*nrd
    ENDI
   ENDI
  ENDI
  IF cipend < 5 .AND. TAXAS->emissao_ <= DATE()+60
   circax1:=circax2
   circax2:=circax3
   circax3:=circax4
   circax4:=[ ]+TAXAS->tipo+[ ]+TAXAS->circ+[ ]+DTOC(TAXAS->emissao_)+[ ]+;
      TRANSF(TAXAS->valor+M->vladd,"@E 99,999.99")+[ ]+DTOC(TAXAS->pgto_)+;
      TRANSF(TAXAS->valorpg,"@E 99,999.99") //+[ ]+TAXAS->cobrador
  ENDI
  SKIP
 ENDDO
 @ l_s+07, c_s+46 SAY [   ]
 @ l_s+07, c_s+46 SAY TRAN(GRUPOS->qtcircs,[999])
 IF !EMPT(GRUPOS->telefone)
  @ l_s+10, c_s+1 SAY [Tel.:]+GRUPOS->telefone
 ENDI
 @ l_s+11, c_s+1 SAY SPACE(46)
 @ l_s+12, c_s+1 SAY SPACE(46)
 @ l_s+13, c_s+1 SAY SPACE(46)
 @ l_s+14, c_s+1 SAY SPACE(46)
 @ l_s+11, c_s+1 SAY circax1
 @ l_s+12, c_s+1 SAY circax2
 @ l_s+13, c_s+1 SAY circax3
 @ l_s+14, c_s+1 SAY circax4
 IF .t. //ciatrz > 4
  IF .t. // OBXEC->tipo=' '
   DBOX(STRZERO(ciatrz,2)+" Circulares Pendentes Vencidas!",,,,,"ATEN€ŽO, "+usuario)
  ENDI
 ENDI
 POINTER_DBF(reg_dbf)
SET(_SET_DELETED,dele_atu)                         // os excluidos serao vistos

RETU []         // <- deve retornar um valor qualquer

* \\ Final de BXR_01F9.PRG
procedure r02901f9
/*
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
 \ Empresa.: PresServ Inform tica-Limeira (019)452.6623
 \ Programa: R02901F9.PRG
 \ Data....: 22-09-97
 \ Sistema.: Administradora - RECEP€„O
 \ Funcao..: pedido do relat¢rio ADR_R029
 \ Analista: Ademilson Pedro Bom
 \ Criacao.: Programado manualmente pelo analista
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/

#include "adrbig.ch"    // inicializa constantes manifestas

 li_aux:=space(1024)
 li_aux:=[O Contratante acima qualificado (ou seu representante legal) ]
 li_aux+=[declara que recebeu de ]
 li_aux+=ALLTRIM(M->setup1)+[, ]
 IF !EMPT(M->cgcsetup)
  li_aux+=[inscrita no CGC sob n§ ]+TRAN(M->cgcsetup,"@R 99.999.999/9999-99")+[, ]
 ENDI
 li_aux+=[o montante de ]
 li_aux+=[de ]+&drvpenf+[R$]+ALLTRIM(TRAN(vlauxilio,[@E 999,999.99]))+;
  [ (]+LEFT(EXT(vlauxilio),AT([/],EXT(vlauxilio))-1)+[)]+&drvtenf
 li_aux+=[ referente a ]+&drvpenf+[Restitui‡„o de Despesas Funerais]+&drvtenf+[, ]
 li_aux+=[por ocasi„o do falecimento abaixo descrito, conforme ]
 li_aux+=[processo administrativo contendo requerimento e as ]
 li_aux+=[respectivas notas fiscais e/ou recibos.]
RETU M->li_aux       // <- deve retornar um valor qualquer

* \\ Final de R02901F9.PRG
/*
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
 \ Empresa.: Ind£stria de Urnas Bignotto Ltda
 \ Programa: CAD_04F9.PRG
 \ Data....: 22-04-97
 \ Sistema.: Controle de Processos da Funer ria
 \ Funcao..: Valida‡„o do campo CONTRATO, arquivo CADPROC
 \ Analista: Ademilson Pedro Bom
 \ Criacao.: Programado manualmente pelo analista
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/

#include "adrbig.ch"    // inicializa constantes manifestas
para op_menu
LOCAL reg_dbf1:=POINTER_DBF() , contraux:=GRUPOS->codigo
LOCAL cipend:=vlpend:=0
IF !(op_menu=1)
 retu .t.
ENDI
msg:=MEMOLINE(GRUPOS->obs,35,1)
IF !EMPT(msg)
 msg+=[|]
ENDI
msg+=MEMOLINE(GRUPOS->obs,35,2)
IF !EMPT(msg)
 msg+=[|]
ELSE
 msg:=[]
ENDI
PTAB(GRUPOS->codigo,'TAXAS',1)
SELE TAXAS
DO WHILE !EOF() .AND.codigo=GRUPOS->codigo
 IF valorpg=0.AND.emissao_<=DATE()
  msg+=[Contrato com 1 ou + d‚bitos pendentes.|]
  exit
 ENDI
 SKIP
ENDD
IF !EMPT(msg)
 op_=DBOX(msg,,,E_MENU,,"SITUACAO DO CONTRATO!") //
 msg:=[]
ENDI
PTAB([],[MENSAG])
 SELE MENSAG
 DO WHILE ! EOF()
  qlin = MLCOUNT(MENSAG->mens1,50)
  SELE GRUPOS
  auxiliar=LEFT(MENSAG->filtro,AT("~",MENSAG->filtro))
//  dbox([Verificando mensagem |]+auxiliar+[|]+str(qlin))
  IF CRIT ( auxiliar )
   MSGAUX:=msg:=[]
   OP_=0
   DO WHILE qlin>0
    OP_++
    msgAUX:=MEMOLINE(MENSAG->mens1,50,OP_)
    msg+=msgaux+[|]
    qlin--
   ENDD
   IF !EMPT(msg)
    op_=DBOX(msg,,,E_MENU,,"ANOTACOES DO CONTRATO!") //
    msg:=[]
   ENDI
  ENDI
  SELE MENSAG
  SKIP
 ENDD


 POINTER_DBF(reg_dbf1)

RETU .t.  // <- deve retornar um valor L¢GICO

* \\ Final de CAD_04F9.PRG
€	 ARQGRUPN– ARQGRUPCODEARQ_INCLCODEARQ_TELACODEARQ_GETSCODEARQ_GET1CODEC_ETEXTENDCODE	_SYMSTARTSYMSTARTSYMBOLSSYMBOLS_SYMENDSYMENDNULLBEGDATA_DATADATA_SYMPBDATA_SYMPDATA_SYMPEDATA_CONSTCONST_MSGMSG_BEGBSSBEGBSS_BSSBSS_ENDBSSENDBSSDGROUPœ˜ @õ$˜ @â.˜ @ÿ˜ @y	“˜ @3
Ó˜ H  ÿ˜ h  Û˜ `pi˜ h  Ó˜ h  Ï˜ H  ë˜ H  ç˜ H € FNCSL–S FNCSCODEFNC_INCLCODE
FNC_ANT_SECODE
FNC_CRIA_SCODE
FNC_GERA_SCODE
FNC_GRAVA_CODEFNC_TELACODEFNC_GETSCODEFNC_GET1CODEFNC_MEMOCODEC_ETEXTENDCODE	_SYMSTARTSYMSTARTSYMBOLSSYMBOLS_SYMENDSYMENDNULLBEGDATA_DATADATA_SYMPBDATA_SYMPDATA_SYMPEDATA_CONSTCONST_MSGMSG_BEGBSSBEGBSS_BSSBSS_ENDBSSENDBSSDGROUP-˜ @ò'˜ @/*
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
 \ Empresa.: PresServ Inform tica - Limeira (019)452.6623
 \ Programa: ADM_R039.PRG
 \ Data....: 04-11-03
 \ Sistema.: Administradora - RECEP€„O
 \ Funcao..: Fechamento Caixa
 \ Analista: Ademilson Pedro Bom
 \ Criacao.: GAS-Pro v4.0n
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/

#include "adrbig.ch"    // inicializa constantes manifestas

PRIV dele_atu, cur_atual, getlist:={}, lin_det:=[]
PARA lin_menu, col_menu
PRIV  tem_borda:=.t., op_menu:=VAR_COMPL, l_s:=09, c_s:=26, l_i:=15, c_i:=56, tela_fundo:=SAVESCREEN(0,0,MAXROW(),79)
nucop=1
IF nivelop < 2                                     // se usuario nao tem
 DBOX("Emiss„o negada, "+usuario,20)               // permissao, avisa
 RETU                                              // e retorna
ENDI
SETCOLOR(drvtittel)
vr_memo=NOVAPOSI(@l_s,@c_s,@l_i,@c_i)     // pega posicao atual da tela
CAIXA(mold,l_s,c_s,l_i,c_i)               // monta caixa da tela
@ l_s,c_s+6 SAY " TRANSF.FINANCEIRO "
SETCOLOR(drvcortel)
@ l_s+01,c_s+1 SAY " Nr.Conta...:"
@ l_s+02,c_s+1 SAY " Fechamento.:"
@ l_s+03,c_s+1 SAY " Segunda Via:"
PRIV nrconta:=SPAC(10)                             // Nr.Conta
PRIV emisini_:=CTOD('')                            // Lan‡to. inicial
PRIV ehsegvia:=[N]
DO WHILE .t.
 rola_t=.f.
 cod_sos=56
 SET KEY K_ALT_F8 TO ROLATELA
 SETCOLOR(drvcortel+","+drvcorget+",,,"+corcampo)
 @ l_s+01 ,c_s+15 GET  nrconta;
		  VALI CRIT("!EMPT(nrconta)~Necess rio informar NR.CONTA")
		  DEFAULT "M->usuario"
		  AJUDA "Informe a conta a fechar.|Tecle F8 para conta atual"
		  CMDF8 "IIF(EMPT(M->usuario),PADR(M->contarec+M->ide_maq,10,' '),PADR(M->usuario,10,' '))"

 @ l_s+02 ,c_s+15 GET  emisini_;
		  PICT "@D";
		  VALI CRIT("emisini_<=DATE()~Deve ser menor ou igual a data de hoje |Data do sistema")
      DEFAULT "DATE()"
      AJUDA "Informe a data inicial"

 @ l_s+03 ,c_s+15 GET  ehsegvia;
		  PICT "!";
		  VALI CRIT("ehsegvia$[SN]~Digite Sim ou Nao")
      DEFAULT "N"
      AJUDA "Digite S para listar os caixas de hoje"

 READ
 SET KEY K_ALT_F8 TO
 IF rola_t
  ROLATELA(.f.)
  LOOP
 ENDI
 IF LASTKEY()=K_ESC                                // se quer cancelar
  RETU                                             // retorna
 ENDI

 #ifdef COM_REDE
  IF !USEARQ("ORDPGRC",.f.,10,1)                   // se falhou a abertura do arq
   RETU                                            // volta ao menu anterior
  ENDI
 #else
  USEARQ("ORDPGRC")                                // abre o dbf e seus indices
 #endi

 titrel:=criterio := ""                            // inicializa variaveis
 cpord=""
 chv_rela:=chv_1:=chv_2 := ""
 tps:=op_x:=ccop := 1
 fil_ini=""
 IF !opcoes_rel(lin_menu,col_menu,12,11,fil_ini)   // nao quis configurar...
  CLOS ALL                                         // fecha arquivos e
  LOOP                                             // volta ao menu
 ENDI
 IF tps=2                                          // se vai para arquivo/video
  arq_=ARQGER()                                    // entao pega nome do arquivo
  IF EMPTY(arq_)                                   // se cancelou ou nao informou
   LOOP                                            // retorna
  ENDI
 ELSE
  arq_=drvporta                                    // porta de saida configurada
 ENDI
 SET PRINTER TO (arq_)                             // redireciona saida
 EXIT
ENDD
cur_atual=SETCURSOR(0)
criterio_=criterio                                 // salva criterio e ordenacao
cpord_=cpord                                       // definidos se huver
criterio=""

#ifdef COM_REDE
 IF !USEARQ("BXREC",.f.,10,1)                      // se falhou a abertura do arq
  RETU                                             // volta ao menu anterior
 ENDI
#else
 USEARQ("BXREC")                                   // abre o dbf e seus indices
#endi

cpord="numop+numero"
criterio=""
INDTMP()
#ifdef COM_REDE
 IF !USEARQ("OBXEC",.f.,10,1)                      // se falhou a abertura do arq
	RETU                                             // volta ao menu anterior
 ENDI
#else
 USEARQ("OBXEC")                                   // abre o dbf e seus indices
#endi

cpord="numop+numero"
INDTMP()
criterio=criterio_                                 // restabelece criterio e
cpord=cpord_                                       // ordenacao definidos
SELE ORDPGRC
dele_atu:=SET(_SET_DELETED,.t.)                    // os excluidos nao servem...
POE_GAUGE("[ESC] Interrompe","AGUARDE...","Emitidos:")
SET DEVI TO PRIN                                   // inicia a impressao
maxli=62                                           // maximo de linhas no relatorio
BEGIN SEQUENCE
 DO WHIL ccop<=nucop                               // imprime qde copias pedida
  pg_=1; cl=50000
  INI_ARQ()                                        // acha 1o. reg valido do arquivo
  IF EOF()
   EXIT
  ENDI
  ccop++                                           // incrementa contador de copias
  tot025005 := 0                                   // inicializa variaves de totais
  DO WHIL !EOF().AND.POE_GAUGE()
   IF IN_KEY()=K_ESC                               // se quer cancelar
    IF canc()                                      // pede confirmacao
     BREAK                                         // confirmou...
    ENDI
   ENDI
   IF numconta==M->nrconta.AND.;
      (EMPT(fechto_).and.ehsegvia#[S]).or.;
      (ehsegvia=[S].AND.fechto_=emisini_) // se atender a condicao...
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY TRAN(numop+R03001F9(),"999999")   // N§ OP.
    @ cl,007 SAY TRAN(origem,"!!!")                // Ori
    @ cl,011 SAY TRAN(historico,"999")             // Hist
    @ cl,016 SAY TRAN(debcred,"!")                 // D/C
    tot025005+=valortotal * IIF(debcred='C',1,-1)
    @ cl,019 SAY TRAN(valortotal * IIF(debcred='C',1,-1),"99999999.99")// Val Lan‡to
    @ cl,031 SAY TRAN(documento,"@!")              // Documento
    @ cl,044 SAY TRAN(LEFT(complement,20),"@!")             // Complemento de Hist¢rico
    @ cl,065 SAY DTOC(ORDPGRC->fechto_)
    chv026=numop
    SELE BXREC
    SEEK chv026
    IF FOUND()
     IF cl+3>maxli                                 // se cabecalho do arq filho
      REL_CAB(0)                                   // nao cabe nesta pagina
     ENDI                                          // salta para a proxima pagina
     cl+=1                                         // soma contador de linha
     IMPCTL(drvpcom)                              // comprime os dados
     @ cl,002 SAY "Numero  Codigo Circ. Valor pago"
     cl+=1                                         // soma contador de linha
     @ cl,000 SAY "========= ================== =========="
     DO WHIL ! EOF() .AND. chv026=numop //LEFT(&(INDEXKEY(0)),LEN(chv026)).AND.POE_GAUGE()
      IF IN_KEY()=K_ESC                            // se quer cancelar
       IF canc()                                   // pede confirmacao
	BREAK                                      // confirmou...
       ENDI
      ENDI
      lin_det+=TRAN(numero,"@R 99-999999")+;           // Numero
	       [ ]+LEFT(cobranca,15)+;      // Codigo
	       TRAN(valorpg,"@E 9,999.99")+[ ]   // Valor pago

      IF LEN(lin_det)>100
       REL_CAB(1)                                   // soma cl/imprime cabecalho
       @ cl,000 SAY lin_det
       lin_det:=[]
      ENDI
      SKIP                                         // pega proximo registro
     ENDD
    ENDI
    IF !EMPT(lin_det)
     REL_CAB(1)                                   // soma cl/imprime cabecalho
     @ cl,000 SAY lin_det
     lin_det:=[]
    ENDI
    IMPCTL(drvTcom)                              // comprime os dados
    cl++
    SELE ORDPGRC                                   // volta ao arquivo pai
    tot020004 := 0                                 // inicializa variaves de totais
    chv020=numop
    SELE OBXEC
    SEEK chv020
    IF FOUND()
     IF cl+3>maxli                                 // se cabecalho do arq filho
      REL_CAB(0)                                   // nao cabe nesta pagina
     ENDI                                          // salta para a proxima pagina
     IMPCTL(drvpcom)                               // comprime os dados
     cl+=1                                         // soma contador de linha
     @ cl,001 SAY "Numero  Codig Valor pago Ref"
     cl+=1                                         // soma contador de linha
     @ cl,000 SAY "======== ===== ========== ======================="
     IMPCTL(drvpcom)                               // retira comprimido
     DO WHIL ! EOF() .AND. chv020=numop //LEFT(&(INDEXKEY(0)),LEN(chv020))
      #ifdef COM_TUTOR
       IF IN_KEY()=K_ESC                           // se quer cancelar
      #else
       IF INKEY()=K_ESC                            // se quer cancelar
      #endi
       IF canc()                                   // pede confirmacao
        BREAK                                      // confirmou...
       ENDI
      ENDI
      lin_det+=TRAN(numero,"99-999999")+' '+;           // Numero
	       TRAN(codigo,"@!")+' '+;           // Codigo
	       TRAN(valorpg,"@E 9,999.99")+' '+;   // Valor pago
	       cobranca+' | '
      IF LEN(lin_det)>100
       REL_CAB(1)                                   // soma cl/imprime cabecalho
       IMPCTL(drvpcom)                              // comprime os dados
       @ cl,000 SAY lin_det
       IMPCTL(drvtcom)                              // retira comprimido
       lin_det:=[]
      ENDI
      tot020004+=valorpg
      SKIP                                         // pega proximo registro
     ENDD
     REL_CAB(1)                                   // soma cl/imprime cabecalho
     IMPCTL(drvpcom)                              // comprime os dados
     @ cl,000 SAY lin_det
     IMPCTL(drvtcom)                              // retira comprimido
     lin_det:=[]
     IF cl+3>maxli                                 // se cabecalho do arq filho
      REL_CAB(0)                                   // nao cabe nesta pagina
     ENDI                                          // salta para a proxima pagina
     IMPCTL(drvpcom)                               // comprime os dados
     @ ++cl,015 SAY REPL('-',10)
     @ ++cl,015 SAY TRAN(tot020004,"@E 999,999.99")// total Valor pago
     IMPCTL(drvtcom)                               // retira comprimido
     cl+=3                                         // soma contador de linha
    ENDI
    SELE ORDPGRC                                   // volta ao arquivo pai
    SKIP                                           // pega proximo registro
   ELSE                                            // se nao atende condicao
    SKIP                                           // pega proximo registro
   ENDI
  ENDD
  IF cl+3>maxli                                    // se cabecalho do arq filho
   REL_CAB(0)                                      // nao cabe nesta pagina
  ENDI                                             // salta para a proxima pagina
  @ ++cl,019 SAY REPL('-',11)
  @ ++cl,019 SAY TRAN(tot025005,"99999999.99")     // total Val Lan‡to
 ENDD ccop
 EJEC                                              // salta pagina
END SEQUENCE
SETCURSOR(cur_atual)
SET PRINTER TO (drvporta)                          // fecha arquivo gerado (se houver)
SET DEVI TO SCRE                                   // direciona saida p/ video
IF tps=2                                           // se vai para arquivo/video
 BROWSE_REL(arq_,2,3,MAXROW()-2,78)
ENDI          // mostra o arquivo gravado
GRELA(12)                                          // grava variacao do relatorio
msgp="PROCESSAMENTOS DO RELAT¢RIO|FECHAMENTO CAIXA"
POE_GAUGE("Processando registros","AGUARDE!","Feitos:")
SET(_SET_DELETED,.t.)                              // os excluidos nao servem...
SELE ORDPGRC                                       // processamentos apos emissao
INI_ARQ()                                          // acha 1o. reg valido do arquivo
DO WHIL !EOF().AND.POE_GAUGE().AND.!(ehsegvia=[S])
 IF numconta==M->nrconta.AND.EMPT(fechto_)         // se atender a condicao...

  #ifdef COM_REDE
   IF EMPT(fechto_)
    REPBLO('ORDPGRC->fechto_',{||DATE()})
   ENDI
   IF EMPT(fechpor)
    REPBLO('ORDPGRC->fechpor',{||M->usuario})
   ENDI
  #else
   IF EMPT(fechto_)
    REPL ORDPGRC->fechto_ WITH DATE()
   ENDI
   IF EMPT(fechpor)
    REPL ORDPGRC->fechpor WITH M->usuario
   ENDI
  #endi

  SELE ORDPGRC                                     // volta ao arquivo pai
  SKIP                                             // pega proximo registro
 ELSE                                              // se nao atende condicao
  SKIP                                             // pega proximo registro
 ENDI
ENDD
SET(_SET_DELETED,.f.)                              // os excluidos serao vistos
SELE BXREC                                         // arquivo origem do processamento

SET(_SET_DELETED,.t.)
ALERTA(2)
DBOX("Processo terminado com sucesso!",,,,,msgp)
SET(_SET_DELETED,dele_atu)                         // os excluidos serao vistos
RETU

STATIC PROC REL_CAB(qt)                            // cabecalho do relatorio
IF qt>0                                            // se parametro maior que 0
 cl=cl+qt                                          // soma no contador de linhas
ENDI
IF cl>maxli .OR. qt=0                              // quebra de pagina
 IMPAC(nemp,0,000)                                 // nome da empresa
 @ 0,071 SAY "PAG"
 @ 0,075 SAY TRAN(pg_,'9999')                      // n£mero da p gina
 IMPAC(nsis,1,000)                                 // t¡tulo aplica‡„o
 @ 1,071 SAY "ADM_R039"                            // c¢digo relat¢rio
 @ 2,000 SAY "TRANSF.FINANCEIRO"
 @ 2,063 SAY NSEM(DATE())                          // dia da semana
 @ 2,071 SAY DTOC(DATE())                          // data do sistema
 @ 3,000 SAY ALLtrim(titrel)+[ Conta:]+M->nrconta   // t¡tulo a definir
 IMPAC("N§ OP. Ori Hist DC  Val Lan‡to Documento    Complemento Hist¢rico Fechto.",4,000)
 @ 5,000 SAY REPL("-",79)
 cl=qt+5 ; pg_++
ENDI
RETU

* \\ Final de ADM_R039.PRG
procedure adm_r041
/*
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
 \ Empresa.: Ind£stria de Urnas Bignotto Ltda
 \ Programa: ADM_R041.PRG
 \ Data....: 03-03-98
 \ Sistema.: Administradora - PLANO
 \ Funcao..: Contrato Brotas
 \ Analista: Ademilson Pedro Bom
 \ Criacao.: GAS-Pro v3.0
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/

#include "adrbig.ch"    // inicializa constantes manifestas

LOCAL dele_atu, getlist:={}, so_um_reg, sit_dbf:=POINTER_DBF()
PARA  lin_menu, col_menu, imp_reg
PRIV  tem_borda:=.t., op_menu:=VAR_COMPL, l_s:=8, c_s:=11, l_i:=15, c_i:=66, tela_fundo:=SAVESCREEN(0,0,MAXROW(),79)
nucop=1
so_um_reg=(PCOU()>2)
IF !so_um_reg                             // vai receber a variaveis?
 SETCOLOR(drvtittel)
 vr_memo=NOVAPOSI(@l_s,@c_s,@l_i,@c_i)    // pega posicao atual da tela
 CAIXA(mold,l_s,c_s,l_i,c_i)              // monta caixa da tela
 @ l_s,c_s+18 SAY " IMPRESSŽO CONTRATO "
 SETCOLOR(drvcortel)
 @ l_s+01,c_s+1 SAY " Imprimir os contratos do n§ :        at‚ o n§"
 @ l_s+02,c_s+1 SAY "          os lan‡ados entre..:           e"
 @ l_s+04,c_s+1 SAY "                   Reimpress„o?:"
 @ l_s+05,c_s+1 SAY "                    Confirme...:"
ENDI
rcodin=SPAC(6)                                     // Codigo
rcodfi=SPAC(6)                                     // Codigo
rlanc1_=CTOD('01/01/1998')                                   // Lan‡.Inic.
rlanc2_=CTOD('01/01/2010')                                   // Lan‡.Final
rreimp=[S] //PAC(1)                                     // Reimprimir?
confirme=SPAC(1)                                   // Confirme
DO WHILE .t.
 rola_t=.f.
 cod_sos=56
 IF !so_um_reg
	SET KEY K_ALT_F8 TO ROLATELA
	SETCOLOR(drvcortel+","+drvcorget+",,,"+corcampo)
	@ l_s+01 ,c_s+32 GET  rcodin;
									 PICT "999999";
									 VALI CRIT("PTAB(rcodin,'GRUPOS',1)~CODIGO n„o aceit vel")
									 AJUDA "Entre com o n£mero do |primeiro contrato a imprimir"
									 CMDF8 "VDBF(6,20,20,77,'GRUPOS',{'codigo','nome','admissao'},1,'codigo',[])"

	@ l_s+01 ,c_s+48 GET  rcodfi;
									 PICT "999999";
									 VALI CRIT("PTAB(rcodfi,'GRUPOS',1)~CODIGO n„o aceit vel")
									 AJUDA "Entre com o n£mero do |£ltimo contrato a imprimir"
									 CMDF8 "VDBF(6,20,20,77,'GRUPOS',{'codigo','nome','admissao'},1,'codigo',[])"
/*
	@ l_s+02 ,c_s+32 GET  rlanc1_;
									 PICT "@D";
									 VALI CRIT("!EMPT(Rlanc1_)~Deve ser informada uma data v lida.")
									 DEFAULT "DATE()"
									 AJUDA "Listar os contratos lan‡ados| a partir de qual data."

	@ l_s+02 ,c_s+45 GET  rlanc2_;
									 PICT "@D";
									 VALI CRIT("!EMPT(Rlanc2_)~Deve ser informada uma data v lida.")
									 DEFAULT "DATE()"
									 AJUDA "Listar os contratos lan‡ados| at‚ quel data."

	@ l_s+04 ,c_s+34 GET  rreimp;
									 PICT "!";
			 VALI CRIT("rreimp$[SN ]~Necess rio informar REIMPRIMIR?|Digite S ou N")
									 DEFAULT "[N]"
									 AJUDA "Digite S para imprimir| inclusive os j  impressos."
*/
	@ l_s+05 ,c_s+34 GET  confirme;
									 PICT "!";
									 VALI CRIT("confirme='S'~CONFIRME n„o aceit vel|Digite S ou tecle ESC para cancelar")
									 AJUDA "Digite S para imprimir o contrato|ou |Tecle ESC para cancelar"

	READ
	SET KEY K_ALT_F8 TO
	IF rola_t
	 ROLATELA(.f.)
   LOOP
  ENDI
  IF LASTKEY()=K_ESC                               // se quer cancelar
   RETU                                            // retorna
  ENDI
 ENDI

 #ifdef COM_REDE
  CLOSE GRUPOS
  IF !USEARQ("GRUPOS",.f.,10,1)                    // se falhou a abertura do arq
   RETU                                            // volta ao menu anterior
  ENDI
 #else
	USEARQ("GRUPOS")                                 // abre o dbf e seus indices
 #endi

 PTAB(codigo,"ECOB",1,.t.)                         // abre arquivo p/ o relacionamento
 SET RELA TO codigo INTO ECOB                      // relacionamento dos arquivos
 titrel:=criterio:=cpord := ""                     // inicializa variaveis
 titrel:=chv_rela:=chv_1:=chv_2 := ""
 tps:=op_x:=ccop := 1
 arq_=drvporta                                     // porta de saida configurada
 IF !so_um_reg
  IF !opcoes_rel(lin_menu,col_menu,17,11)          // nao quis configurar...
   CLOS ALL                                        // fecha arquivos e
   LOOP                                            // volta ao menu
  ENDI

 #ifdef COM_REDE

  ELSE

   tps=lin_menu

 #endi

 ENDI
 IF tps=2                                          // se vai para arquivo/video
  arq_=ARQGER()                                    // entao pega nome do arquivo
  IF EMPTY(arq_)                                   // se cancelou ou nao informou
   LOOP                                            // retorna
  ENDI
 ELSE
  arq_=drvporta                                    // porta de saida configurada
 ENDI
 SET PRINTER TO (arq_)                             // redireciona saida
 EXIT
ENDD
criterio_=criterio                                 // salva criterio e ordenacao
cpord_=cpord                                       // definidos se huver
criterio=""

#ifdef COM_REDE
 IF !USEARQ("INSCRITS",.f.,10,1)                   // se falhou a abertura do arq
  RETU                                             // volta ao menu anterior
 ENDI
#else
 USEARQ("INSCRITS")                                // abre o dbf e seus indices
#endi

cpord="codigo+grau+STR(seq,02,00)"
INDTMP()
criterio=criterio_                                 // restabelece criterio e
cpord=cpord_                                       // ordenacao definidos
confirme=[S]
SELE GRUPOS
IF !EMPTY(drvtapg)                                 // existe configuracao de tam pag?
 op_=AT("NNN",drvtapg)                             // se o codigo que altera
 IF op_=0                                          // o tamanho da pagina
	msg="Configura‡„o do tamanho da p gina!"         // foi informado errado
	DBOX(msg,,,,,"ERRO!")                            // avisa
	CLOSE ALL                                        // fecha todos arquivos abertos
	RETU                                             // e cai fora...
 ENDI                                              // codigo para setar/resetar tam pag
 lpp_018=LEFT(drvtapg,op_-1)+"130"+SUBS(drvtapg,op_+3)
 lpp_066=LEFT(drvtapg,op_-1)+"066"+SUBS(drvtapg,op_+3)
ELSE
 lpp_018:=lpp_066 :=""                             // nao ira mudara o tamanho da pag
ENDI
DBOX("[ESC] Interrompe",15,,,NAO_APAGA)
dele_atu:=SET(_SET_DELETED,.t.)                    // os excluidos nao servem...
SET DEVI TO PRIN                                   // inicia a impressao
maxli=125                                           // maximo de linhas no relatorio
SET MARG TO 3                                      // ajusta a margem esquerda
IMPCTL(lpp_018)                                    // seta pagina com 18 linhas
IF tps=2
 IMPCTL("' '+CHR(8)")
ENDI
BEGIN SEQUENCE
 DO WHIL ccop<=nucop                               // imprime qde copias pedida
	pg_=1; cl=999
	IF so_um_reg
	 GO imp_reg
	ELSE
	 INI_ARQ()                                       // acha 1o. reg valido do arquivo
	ENDI
	IF !EMPT(VAL(M->rcodin))
	 PTAB(M->rcodin,[GRUPOS],1)
	ENDI
	ccop++                                           // incrementa contador de copias
	DO WHIL !EOF().AND.(!so_um_reg.OR.imp_reg=RECN())
	 #ifdef COM_TUTOR
		IF IN_KEY()=K_ESC                              // se quer cancelar
	 #else
		IF INKEY()=K_ESC                               // se quer cancelar
	 #endi
		IF canc()                                      // pede confirmacao
		 BREAK                                         // confirmou...
		ENDI
	 ENDI
	 IF (R04101F9()) .OR. so_um_reg                  // se atender a condicao...
		confirme=[S]
		REL_CAB(5)                                     // soma cl/imprime cabecalho
		@ cl,044 SAY vendedor               // Vendedor
		@ cl,055 SAY TRAN(grupo,"!!")                  // Grupo
		@ cl,061 SAY LEFT(codigo,1)+[  ]+substr(codigo,2)  // Codigo
		REL_CAB(4)                                     // soma cl/imprime cabecalho
		@ cl,005 SAY nome                              // Nome
		@ cl,055 SAY TRAN(cpf,"@R 999.999.999-99")     // CPF
//		@ cl,063 SAY TRAN(LEFT(rg,13),"@!")            // R.G.
		REL_CAB(2)                                     // soma cl/imprime cabecalho
		@ cl,005 SAY endereco                          // Endere‡o
		@ cl,058 SAY LEFT(bairro,18)                            // Bairro
		REL_CAB(2)                                     // soma cl/imprime cabecalho
		@ cl,005 SAY TRAN(cep,"@R 99999-999")          // CEP
		@ cl,020 SAY cidade                            // Cidade
		@ cl,049 SAY TRAN(uf,"!!")                     // UF
		@ cl,056 SAY TRAN(telefone,"@!")               // Telefone
		REL_CAB(3)                                     // soma cl/imprime cabecalho
    @ cl,013 SAY left(dtoc(nascto_),2)+[  ]+substr(dtoc(nascto_),4,2)+[  ]+right(dtoc(nascto_),2)
		REL_CAB(2)                                     // soma cl/imprime cabecalho
    @ cl,005 SAY TRAN(natural,"@!")                // Nascto
		REL_CAB(2)                                     // soma cl/imprime cabecalho
    @ cl,005 SAY LEFT(MEMOLINE(GRUPOS->obs,60,3),25)  //Profissao
    @ cl,035 SAY LEFT(MEMOLINE(GRUPOS->obs,60,4),15)  //Profissao
    @ cl,055 SAY LEFT(MEMOLINE(GRUPOS->obs,60,5),15)  //Profissao
		REL_CAB(3)                                     // soma cl/imprime cabecalho
    @ cl,005 SAY LEFT(MEMOLINE(GRUPOS->obs,60,6),45)  //Profissao
    @ cl,055 SAY LEFT(MEMOLINE(GRUPOS->obs,60,7),20)  //Profissao
		REL_CAB(3)                                     // soma cl/imprime cabecalho
		@ cl,005 SAY ECOB->endereco                    // Endere‡o
		@ cl,058 SAY LEFT(ECOB->bairro,18)             // Bairro
		REL_CAB(2)                                     // soma cl/imprime cabecalho
		@ cl,005 SAY TRAN(ECOB->cep,"@R 99999-999")    // CEP
		@ cl,020 SAY ECOB->cidade                      // Cidade
		@ cl,047 SAY TRAN(ECOB->uf,"!!")               // UF
		@ cl,056 SAY TRAN(ECOB->telefone,"@!")         // Telefone
		REL_CAB(2)                                     // soma cl/imprime cabecalho
		@ cl,000 SAY "." //+STR(CL)
		chv031=codigo
		SELE INSCRITS
		SEEK chv031
		IF FOUND()
     @ cl,013 SAY CHR(27)+'3'+chr(15)              // Habilita 216/20
		 IMPINSAUX:=[]                                 // salta para a proxima pagina
		 DO WHIL ! EOF() .AND. chv031=codigo //LEFT(&(INDEXKEY(0)),LEN(chv031))
			#ifdef COM_TUTOR
			 IF IN_KEY()=K_ESC                           // se quer cancelar
			#else
			 IF INKEY()=K_ESC                            // se quer cancelar
			#endi
			  IF canc()                                   // pede confirmacao
			  	BREAK                                      // confirmou...
			  ENDI
			 ENDI
			 DO CASE
			  CASE grau=[2]
			   cl:=31
		    CASE grau=[3]
			   cl:=35
			  CASE grau=[4]
			   cl:=39
			  CASE grau=[5]
			   cl:=43
			  CASE grau=[6]
			   cl:=47
			  CASE grau=[7].and.!([7]$IMPINSAUX)
			   cl:=51
			   IMPINSAUX+=[7]
			  CASE grau=[8].and.!([8]$IMPINSAUX)
			   cl:=84
			   IMPINSAUX+=[8]
			 ENDCASE

			 IF grau>'1'                                  // se atender a condicao...
			  REL_CAB(2)                                  // soma cl/imprime cabecalho
			  @ cl,014 SAY nome                           // Nome
			  IF grau<'6'.and.vivofalec='V'               // pode imprimir?
			   @ cl,053 SAY 'X'                           // tab1
			  ENDI
			  @ cl,062 SAY IIF(grau<'6'.AND.vivofalec='F',' X',[ ])// tab2
			  IF grau>[5]                                 // pode imprimir?
			   @ cl,063 SAY LEFT(DTOC(nascto_),2)+[  ]+;
                      SUBSTR(DTOC(nascto_),4,2)+[  ]+;
                      RIGHT(DTOC(nascto_),2)
			   REL_CAB(2)                                  // soma cl/imprime cabecalho
			  ENDI
			  SKIP                                        // pega proximo registro
			 ELSE                                         // se nao atende condicao
			  SKIP                                        // pega proximo registro
			 ENDI
		 ENDD
     @ cl,013 SAY CHR(27)+'2'              // Habilita 6/1
     IMPCTL(drvtde8)                                    // ativa 6 lpp
     IMPCTL(drvtcom)                                    // ativa 6 lpp
		 cl+=3                                         // soma contador de linha
		ENDI
		SELE GRUPOS                                    // volta ao arquivo pai
//    @ 43,5 SAY admissao
		SKIP                                           // pega proximo registro
		cl=999                                         // forca salto de pagina
	 ELSE                                            // se nao atende condicao
    SKIP                                           // pega proximo registro
   ENDI
   IF !EMPT(VAL(M->rcodfi)).AND.codigo>M->rcodfi
    EXIT
   ENDI
  ENDD
 ENDD ccop
 EJEC                                              // salta pagina
END SEQUENCE
IMPCTL(lpp_066)                                    // seta pagina com 66 linhas
SET MARG TO                                        // ajusta a margem esquerda
SET PRINTER TO (drvporta)                          // fecha arquivo gerado (se houver)
SET DEVI TO SCRE                                   // direciona saida p/ video
IF tps=2                                           // se vai para arquivo/video
 BROWSE_REL(arq_,2,3,MAXROW()-2,78)
ENDI                                               // mostra o arquivo gravado
GRELA(17)                                          // grava variacao do relatorio
SELE GRUPOS                                        // salta pagina
SET RELA TO                                        // retira os relacionamentos
SET(_SET_DELETED,dele_atu)                         // os excluidos serao vistos
IF so_um_reg
 POINTER_DBF(sit_dbf)
ENDI
RETU

STATIC PROC REL_CAB(qt)                            // cabecalho do relatorio
IF qt>0                                            // se parametro maior que 0
 cl=cl+qt                                          // soma no contador de linhas
ENDI
IF cl>maxli .OR. qt=0                              // quebra de pagina
 IF tps=1                                          // se direcionado para impressora
  IF pg_ > 1
   EJEC
//  ENDI
  SET DEVI TO SCRE                                 // liga video
  ALERTA(2)                                        // beep, beep
  msg="Prosseguir Emiss„o|Cancelar Opera‡„o"       // e monta menu para a opcao de
  msgt="ATEN€ŽO, "+usuario+"|Verifique o Papel"    // troca de papel/pausa
  op_emi=DBOX(msg,,,E_MENU,,msgt)                  // na impressao
  IF op_emi!=1                                     // se cancelar ou ESC
   BREAK                                           // pula para o end sequence
  ENDI                                             // senao,
  SET DEVI TO PRIN                                 // direciona para impressora
  ENDI                                              // e continua...
 endi
 cl=qt ; pg_++
ENDI
RETU

* \\ Final de ADM_R041.PRG
STAT PROC r04101f9
DO CASE
CASE (codigo<M->rcodin.AND.!(M->rcodin='000000')) // Contrato menor que
 RETU .f.                                        // o pedido.
CASE (codigo>M->rcodfi.AND.!(M->rcodfi='000000')) // contrato maior.
 RETU .f.
CASE (GRUPOS->ender_<M->rlanc1_.AND.!EMPT(M->rlanc1_)) //Lan‡ado antes
 RETU .f.
CASE (GRUPOS->ender_>M->rlanc2_.AND.!EMPT(M->rlanc2_)) //Lan‡ado depois
 RETU .f.
CASE M->rreimp=[S] // Se j  foi impresso, imprimir novamente.
 RETU .t.
ENDCASE
RETU EMPT(GRUPOS->ultimp_)    //S¢ quero os n„o impressos

* \\ Final de R04101F9.PRG
procedure r08702f9
/*
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
 \ Empresa.: PresServ Inform tica-Limeira (019)452.6623
 \ Programa: R08701F9.PRG
 \ Data....: 17-09-97
 \ Sistema.: Administradora - PLANO
 \ Funcao..: Valor Total do relat¢rio ADP_R087
 \ Analista: Ademilson Pedro Bom
 \ Criacao.: Programado manualmente pelo analista
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/

#include "adrbig.ch"    // inicializa constantes manifestas

 LOCAL reg_dbf1:=POINTER_DBF()
 cod:=codigo     // C¢digo da taxa a imprimir
 emx:=emissao_   // Emiss„o da taxa a ser impressa...
 keycst:=TAXAS->codigo+SUBSTR('123  123',VAL(TAXAS->tipo),1)+TAXAS->circ
 M->recvalor:=IIF(M->racum=[S],0,valor)
 vlseg:=0
 IF PTAB(keycst,[CSTSEG],3)
  SELE CSTSEG
  DO WHILE ! EOF() .AND. keycst = codigo+tipo+circ
   vlseg+=CSTSEG->vlcontr
   SKIP
  ENDDO
  SELE TAXAS
 ENDI

 SELE TAXAS

 PTAB(codigo,'TAXAS',1,.t.)

 M->contx:=0
 lindeb:=[]

 DO WHILE !EOF().AND.TAXAS->codigo=cod.AND.M->racum=[S]
  IF TAXAS->valorpg>0         // Somente taxas pendentes
   SKIP
   LOOP
  ENDI

// Ser„o consideradas vencidas as taxas anteriores a emiss„o da
// que ser  impressa.

  IF TAXAS->emissao_ <= emx .AND. ;
     (SUBSTR('123  123',VAL(TAXAS->tipo),1)$M->rtipo) // Somente taxas pendentes

   M->recvalor+=TAXAS->valor
   keycst:=TAXAS->codigo+SUBSTR('123  123',VAL(TAXAS->tipo),1)+TAXAS->circ
   IF PTAB(keycst,[CSTSEG],3)
    SELE CSTSEG
    DO WHILE ! EOF() .AND. keycst = codigo+tipo+circ
     vlseg+=CSTSEG->vlcontr
     SKIP
    ENDDO
    SELE TAXAS
   ENDI

   contx+=1
   IF CONTX<11
    detdeb[contx]:=TAXAS->tipo+[ ]+TAXAS->circ+[ ]+DTOC(TAXAS->emissao_)+[ ]+;
    TRANSF(TAXAS->valor,"@E 9,999.99")+[ | ]
   ENDI
   lindeb+=TAXAS->tipo+[ ]+TAXAS->circ+[, ]
  ENDI
  SKIP
 ENDDO

 M->recvalor-=M->vlseg

 POINTER_DBF(reg_dbf1)

RETU M->recvalor          // <- deve retornar um valor qualquer

* \\ Final de R08701F9.PRG
€
 ADR_ATRI–Ñ  ADR_ATRICODEC_ETEXTENDCODE	_SYMSTARTSYMSTARTSYMBOLSSYMBOLS_SYMENDSYMENDNULLBEGDATA_DATADATA_SYMPBDATA_SYMPDATA_SYMPEDATA_CONSTCONST_MSGMSG_BEGBSSBEGBSS_BSSBSS_ENDBSSENDBSSDGROUPÇ˜ @
\µ˜ H  ˜ h  ë˜ `` 	˜ h  
ã˜ h  ß˜ H  û˜ H  ÷˜ H ë˜ H  ï˜ H  ë˜ (  ˜ H  €	 DCI03F9¾–Ð  DCI03F9CODEC_ETEXTENDCODE	_SYMSTARTSYMSTARTSYMBOLSSYMBOLS_SYMENDSYMENDNULLBEGDATA_DATADATA_SYMPBDATA_SYMPDATA_SYMPEDATA_CONSTCONST_MSGMSG_BEGBSSBEGBSS_BSSBSS_ENDBSSENDBSSDGROUP}˜ @˜ H  ˜ h  ë˜ `@ 	¯˜ h  
ã˜ h  ß˜ H  û˜ H  ÷˜ H ë˜ H  ï˜ H  ë˜ (  ˜ H  procedure r02701f9
/*
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
 \ Empresa.: PresServ Inform tica-Limeira (019)452.6623
 \ Programa: R02701F9.PRG
 \ Data....: 24-12-95
 \ Sistema.: Administradora de Funer rias
 \ Funcao..: motivo do relat¢rio ADM_R027 // N„o impress„o do recibo
 \ Analista: Ademilson Pedro Bom
 \ Criacao.: Programado manualmente pelo analista
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/

#include "admbig.ch"    // inicializa constantes manifestas
priva doneaux:=[]
DO CASE
 CASE GRUPOS->situacao!=[1]
  doneaux:=[Cancelado]
 CASE GRUPOS->qtcircs>=(GRUPOS->funerais+1)*ARQGRUP->qtdremir
  doneaux:=[Remido]
 CASE RIGHT(GRUPOS->saitxa,2)+LEFT(GRUPOS->saitxa,2)>RIGHT(CIRCULAR->mesref,2)+LEFT(CIRCULAR->mesref,2)
  doneaux:=[SaiTxa > Emissao]
ENDCASE

RETU doneaux      // <- retorna vazio se contrato em codic”es de emiss„o.

* \\ Final de R02701F9.PRG
procedure ctainsc
/*
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
 \ Empresa.: PresServ Inform tica - Limeira (019)452.6623
 \ Programa: CTAINSC.PRG
 \ Data....: 12-11-03
 \ Sistema.: Administradora - RECEP€„O
 \ Funcao..: Consulta Inscritos
 \ Analista: Ademilson Pedro Bom
 \ Criacao.: GAS-Pro v4.0n
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/
#include "adrbig.ch"    // inicializa constantes manifestas

PRIV t_, i_, col_cp, col_ti, cps_rela
PRIV  prefixo_dbf:="CTA", op_sis:=EVAL(qualsis,"INSCRITS")
                                                   // arquivo a consultar
op_menu=PROJECOES                                  // flag consulta e faz projecoes
SELE 0

#ifdef COM_REDE
 IF !USEARQ("INSCRITS",.f.,10,1)                   // se falhou a abertura do arq
  RETU                                             // volta ao menu anterior
 ENDI
#else
 USEARQ("INSCRITS")                                // abre o dbf e seus indices
#endi

PTAB(codigo,"GRUPOS",1,.t.)                        // abre arquivo p/ o relacionamento
SET RELA TO codigo INTO GRUPOS                     // relacionamento dos arquivos
col_cp={;                                          // conteudo das colunas
          "codigo",;
          "grau",;
          "seq",;
          "ehtitular",;
          "nome",;
          "nascto_",;
          "estcivil",;
          "interdito",;
          "sexo",;
          "tcarencia",;
          "vivofalec",;
          "falecto_",;
          "tipo",;
          "procnr";
       }
col_ti={;                                          // titulo das colunas
          "Codigo",;
          "Inscr.",;
          "Seq",;
          "Titular?",;
          "Nome",;
          "Nascto",;
          "Est Civil",;
          "Interdito",;
          "Sexo",;
          "T.Carˆncia",;
          "V/F",;
          "Falecto.",;
          "Tipo",;
          "N§Processo";
       }
GO TOP                                             // vai p/ inicio do arquivo
FOR i_=1 TO LEN(sistema[op_sis,O_CPRELA])          // libera os campos invisiveis
 sistema[op_sis,O_CAMPO,i_,O_CRIT]="V"             // que fazem a ligacao dos DBFs
NEXT                                               // para serem vistos na consulta
cod_sos=8
EDITA(03,03,MAXROW()-2,77,"V",col_cp,col_ti)
FOR i_=1 TO LEN(sistema[op_sis,O_CPRELA])          // e retorna com o atributo
 sistema[op_sis,O_CAMPO,i_,O_CRIT]="I"             // de invisivel nos campos da
NEXT                                               // ligacao pai-filho
SELE INSCRITS                                      // seleciona arquivo
SET RELA TO                                        // retira os relacionamentos
RETU                                               // volta para o menu anterior

* \\ Final de CTAINSC.PRG
               pw_nome+pw_pass                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            @ ] z — ´ Ñ î (Ebœ¹Öó-Jg„¡¾Ûø2Ol‰¦       ÇºÄªÅÊ®Ç´Å”…”…“µ©Æ…“”                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   GAS-Pro v4.0
008013021072001011039001019001176001
 N£mero de O.P. :
 Origem:        Lan‡ado em           por
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 Conta:
 Hist¢rico:
 Tipo.....:     Valor:              Vencto:
 Documento..:                    N§ Doctos:
 Complemento:
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 Fechamento.:
 Transferido:
[Ÿ]
Inclus„o~~26006
Manuten‡„o~~27007
Consulta~~28008
[Ÿ]
 17 
 2 
p/N£mero

 1 
[Ÿ]
p/Conta

 5 
 6 
 13 
[Ÿ]
Caixas
Caixas







005
























 0 











 0 
 3 
-1 
-1 
 0 
-1 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
numop
C
E
999999
 6 
 6 
 1 
 19 
 0 
N§ O.P.

!EMPT(numop)
Necess rio informar N§ O.P.



 0 
 1 


origem
C
E
!!!
 3 
 3 
 2 
 10 
 0 
Origem

origem $ [ADM|FUN|CON|EST|FIN|VIA]
ORIGEM n„o aceit vel

Informe o prefixo do sistema que|gerou o lan‡amento
MTAB([ADMinistradora|FUNer ria|CONvenio|ESToque|FINanceiro|VIAtura],[ORIGEM])
 0 
 0 


lancto_
D
V
@D
 8 
 10 
 2 
 28 
 0 
Lancto_






 0 
 0 


por
C
V
 
 10 
 10 
 2 
 42 
 0 
Por






 0 
 0 


numconta
C
E
@!
 10 
 10 
 4 
 9 
 0 
Conta

!EMPT(numconta)
Campo obrigat¢rio!|Identifique a Conta/Cadastro com um n£mero | ou nome qualquer.

Informe a conta que receber  este lan‡amento.

 0 
 0 


historico
C
E
999
 3 
 3 
 5 
 13 
 0 
Hist¢rico

EMPT(historico).OR.PTAB(historico,'HISTORIC',1)
HIST¢RICO n„o existe na tabela

Informe o hist¢rico do lan‡amento.
VDBF(6,24,20,77,'HISTORIC',{'historico','descricao','tipo'},1,'historico',[HISTORIC->origem$']+origem+[   '])
 0 
 0 


debcred
C
E
!
 1 
 1 
 6 
 13 
 0 
D‚b/Cr‚d

debcred$[CD]
Necess rio informar DB/CRD
HISTORIC->tipo
Se for um documento a pagar ser  D, sen„o C
MTAB([D‚bito|Cr‚dito],[DB/CRD])
 0 
 0 


valortotal
N
E
99999999.99
 11 
 11 
 6 
 24 
 2 
Valor Lan‡amento

!(VALORtotal<0.00)
VALOR TOTAL DO LAN€AMENTO| deve ser positivo ou zeros

Entre com o valor total do documento,|se valor = zero, ser  apenas agendado.

 0 
 0 


vencto_
D
E
@D
 8 
 10 
 6 
 45 
 0 
Vencto

!EMPT(vencto_)
Necess rio informar VENCTO

Entre com a data do vencimento deste.

 0 
 0 


documento
C
E
@!
 12 
 12 
 7 
 15 
 0 
Documento

!EMPTY(documento)
Digite algo para identificar o documento

Entre com o n£mero do documento

 0 
 0 


nrdoctos
N
E
99999
 5 
 5 
 7 
 45 
 0 
N§Doctos

!(nrdoctos<0)
N§DOCTOS n„o aceit vel



 0 
 0 


complement
C
E
@!
 35 
 35 
 8 
 15 
 0 
Complemento de Hist¢rico

!EMPT(complement)
Entre com uma informa‡„o que diferencie este|lan‡amento de outros com mesmo hist¢rico.



 0 
 0 


fechto_
D
V
@D
 8 
 10 
 10 
 15 
 0 
Fechto






 0 
 0 


fechpor
C
V
 
 10 
 10 
 10 
 24 
 0 
Fechpor






 0 
 0 


autoriz_
D
V
@D
 8 
 10 
 11 
 15 
 0 
Autorizado em






 0 
 0 


autorpor
C
V
 
 10 
 10 
 11 
 24 
 0 
Autorizado






 0 
 0 


numos
C
V
9999999
 7 
 7 
 11 
 35 
 0 
Lan‡amento N§






 0 
 0 


 1 
Descri‡„o de Hi
HISTORIC->descricao

 5 
 17 
 40 

 0 
 0 
 1 
HISTORIC
1
 4 
1=3 // For‡a INTLAN

 0 



historico
C



descricao
C



tipo
C



origem
C



 0 
€
 ADR_OUTRî–Q ADR_OUTRCODECALECODEMAQCALCCODE	SINAL_DIGCODE
VEINSCRITSCODEV00101F9CODE
V_CARENCIACODE
XCRIPTOGRACODEXENCRIPTCODEXDECRIPTCODEC_ETEXTENDCODE	_SYMSTARTSYMSTARTSYMBOLSSYMBOLS_SYMENDSYMENDNULLBEGDATA_DATADATA_SYMPBDATA_SYMPDATA_SYMPEDATA_CONSTCONST_MSGMSG_BEGBSSBEGBSS_BSSBSS_ENDBSSENDBSSDGROUP‹˜ @.PRG.OBJ:
     CLIPPER $** /m /l
ADR_ADAP.OBJ : ADR_ADAP.PRG
ADR_ATRI.OBJ : ADR_ATRI.PRG
ADR_ATR1.OBJ : ADR_ATR1.PRG
ADR_ATR2.OBJ : ADR_ATR2.PRG
ADR_ESTR.OBJ : ADR_ESTR.PRG
ADR_ADAP.EXE:
     RTLINK @ADR_ADAP.LNK
procedure cob_01f9
/*
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
 \ Empresa.: PresServ Inform tica - Limeira (019)452.6623
 \ Programa: COB_01F9.PRG
 \ Data....: 17-05-98
 \ Sistema.: Administradora - PLANO
 \ Funcao..: Fun‡„o F8 do campo COBRADOR, arquivo COBRADOR
 \ Analista: Ademilson Pedro Bom
 \ Criacao.: Programado manualmente pelo analista
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/

#include "adrbig.ch"    // inicializa constantes manifestas

 rcodin:=[001]

 DO WHILE PTAB(M->rcodin,[COBRADOR],1)
  rcodin:=sTRzero(VAL(rcodin)+1,3,0)
 ENDD

RETU M->rcodin       // <- deve retornar um valor qualquer

* \\ Final de COB_01F9.PRG
/*
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
 \ Empresa.: PresServ Inform tica - Limeira (019)452.6623
 \ Programa: OBXEC.PRG
 \ Data....: 29-01-04
 \ Sistema.: Administradora - RECEP€„O
 \ Funcao..: Gerenciador do subsistema de outros recebimentos
 \ Analista: Ademilson Pedro Bom
 \ Criacao.: GAS-Pro v4.0o
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/

#include "adrbig.ch"    // inicializa constantes manifestas

PARA lin_menu,col_menu
PRIV op_sis, tela_fundo:=SAVESCREEN(0,0,MAXROW(),79), l_s, c_s, l_i, c_i, l_a

op_sis=EVAL(qualsis,"OBXEC")
IF nivelop<sistema[op_sis,O_OUTROS,O_NIVEL]        // se usuario nao tem permissao,
 ALERTA()                                          // entao, beep, beep, beep
 DBOX(msg_auto,,,3)                                // lamentamos e
 RETU                                              // retornamos ao menu
ENDI
cn:=fgrep :=.f.

#ifdef COM_LOCK
 IF LEN(pr_ok)>0                                   // se a protecao acusou
  ? pr_ok                                          // erro, avisa e
  QUIT                                             // encerra a aplicacao
 ENDI
#endi

t_fundo=SAVESCREEN(0,0,MAXROW(),79)                // salva tela do fundo
op_cad=1
DO WHIL op_cad!=0
 criterio=""
 RESTSCREEN(0,0,MAXROW(),79,t_fundo)               // restaura tela do fundo
 cod_sos=5 ; cn=.f.
 CLEA TYPEAHEAD                                    // limpa o buffer do teclado
 fgrep=.f.
 SET KEY K_F3 TO                                   // retira das teclas F3 e F4 as
 SET KEY K_F4 TO                                   // funcoes de repeticao e confirmacao
 msg="Inclus„o~1|"+;
     "Manuten‡„o~2|"+;
     "Consulta~3"
 op_cad=DBOX(msg,lin_menu,col_menu,E_MENU,NAO_APAGA,MAIUSC(sistema[op_sis,O_MENU]),,,op_cad)
 IF op_cad!=0                                      // se escolheu uma opcao
  Tela_fundo=SAVESCREEN(0,0,MAXROW(),79)           // salva a tela para ROLATELA()
  PARAMETROS(dbfparam)
  SELE A                                           // e abre o arquivo e seus indices

  #ifdef COM_REDE
   IF !USEARQ(sistema[op_sis,O_ARQUI,O_NOME],.f.,20,1)
                                                   // se falhou a abertura do
    RETU                                           // arquivo volta ao menu anterior
   ENDI
  #else
   USEARQ(sistema[op_sis,O_ARQUI,O_NOME])
  #endi

  SET KEY K_F9 TO veoutros                         // habilita consulta em outros arquivos
  SET KEY K_F2 TO veinscrits()                         // habilita consulta em outros arquivos
 ENDI
 DO CASE
  CASE op_cad=01                                   // inclus„o
   op_menu=INCLUSAO
   IF AT("D",exrot[op_sis])=0                      // se usuario pode fazer inclusao
    OBX_INCL()                                     // neste arquivo chama prg de inclusao
   ELSE                                            // caso contrario vamos avisar que
    ALERTA()                                       // ele nao tem permissao para isto
    DBOX(msg_auto,,,3)
   ENDI

  CASE op_cad=02                                   // manuten‡„o
   op_menu=ALTERACAO
   cod_sos=7
   EDIT()

  CASE op_cad=03                                   // consulta
   op_menu=PROJECOES
   cod_sos=8
   EDITA(03,03,22,77)

 ENDC
 SET KEY K_F9 TO                                   // F9 nao mais consultara outros arquivos
 CLOS ALL                                          // fecha todos arquivos abertos
ENDD
RETU

PROC OBX_incl(reg_cop)  // inclusao no arquivo OBXEC
LOCAL getlist:={},cabem:=1,rep:=ARRAY(FCOU()),ult_reg:=RECN(),cond_incl_,dbfseq_,;
      ctl_r, ctl_c, ctl_w, t_f3_, t_f4_, dele_atu:=SET(_SET_DELETED,.f.)
PRIV op_menu:=INCLUSAO, sq_atual_, tem_borda, criterio:="", cpord:=""
cond_incl_={||nivelop>1}                           // condicao de inclusao de registros
IF !EVAL(cond_incl_)                               // se nao pode incluir
 ALERTA(2)                                         // avisa o motivo
 DBOX("Permitido apenas a usu rios cadastrados|com n¡vel de Manuten‡„o ou Maior",,,4,,"ATEN€ŽO, "+usuario)
 RETU                                              // e retorna
ENDI
FOR i=1 TO FCOU()                                  // cria/declara privadas as
 msg=FIEL(i)                                       // variaveis de memoria com
 PRIV &msg.                                        // o mesmo nome dos campos
NEXT                                               // do arquivo
IF reg_cop!=NIL                                    // quer repetir todo o reg atual
 FOR i=1 TO FCOU()                                 // para cada campo,
  msg=FIEL(i)                                      // salva o conteudo
  rep[i]=&msg.                                     // para repetir
 NEXT
ELSE
 AFILL(rep,"")                                     // eche com valor vazio
ENDI
t_f3_=SETKEY(K_F3,{||rep()})                       // repeticao reg anterior
t_f4_=SETKEY(K_F4,{||conf()})                      // confirma campos com ENTER
ctl_w=SETKEY(K_CTRL_W,{||nadafaz()})               // enganando o CA-Clipper...
ctl_c=SETKEY(K_CTRL_C,{||nadafaz()})
ctl_r=SETKEY(K_CTRL_R,{||nadafaz()})

#ifdef COM_REDE
 OBX_CRIA_SEQ()                                    // cria dbf de controle de cp sequenciais
 FOR i=1 TO FCOU()                                 // cria/declara privadas as
  msg="sq_"+FIEL(i)                                // variaveis de memoria com
  PRIV &msg.                                       // o mesmo nome dos campos
 NEXT                                              // do arquivo com extensao _seq
#endi

DO WHIL cabem>0
 cod_sos=6
 rola_t=.f.                                        // flag se quer rolar a tela
 SELE OBXEC
 GO BOTT                                           // forca o
 SKIP                                              // final do arquivo
 
 /*
    cria variaveis de memoria identicas as de arquivo, para inclusao
    de registros
 */
 FOR i=1 TO FCOU()
  msg=FIEL(i)
  M->&msg.=IF((fgrep .OR. reg_cop!=NIL).AND.!EMPT(rep[1]),rep[i],&msg.)
 NEXT
 DISPBEGIN()                                       // apresenta a tela de uma vez so
 OBX_TELA()
 INFOSIS(.t.)                                      // exibe informacao no rodape' da tela
 DISPEND()
 OBX_GERA_SEQ()
 IF !EVAL(cond_incl_)
  EXIT
 ENDI
 cabem=DISKSPACE(;
          IF(;
             LEN(sistema[op_sis,O_ARQUI,O_DIR_DBF])<2.OR.sistema[op_sis,O_ARQUI,O_DIR_DBF]="\",;
             0,;
             ASC(sistema[op_sis,O_ARQUI,O_DIR_DBF])-64;
          );
       )
 cabem=INT((cabem-2048)/OBXEC->(RECSIZE()))
 IF cabem<1                                        // mais nenhum!!!
  ALERTA()
  msg="Verifique ESPA€O EM DISCO, "+usuario
  DBOX(msg,,,,,"INCLUSŽO INTERROMPIDA!")           // vamos parar por aqui!
  EXIT
 ENDI
 SELE 0                                            // torna visiveis variaveis de memoria
 OBX_GET1(INCLUI)                                  // recebe campos
 SELE OBXEC
 IF LASTKEY()=K_ESC                                // se cancelou
  cabem=0                                          // prepara saida da inclusao
  LOOP
 ENDI

 #ifdef COM_REDE
  GO BOTT                                          // vamos bloquear o final do
  SKIP                                             // arq para que nehum outro
  BLOREG(0,.5)                                     // usuario possa incluir
 #endi

 APPEND BLANK                                      // inclui reg em branco no dbf
 FOR i=1 TO FCOU()                                 // para cada campo,
  msg=FIEL(i)                                      // salva o conteudo
  rep[i]=M->&msg.                                  // para repetir
  REPL &msg. WITH rep[i]                           // enche o campo do arquivo
 NEXT

 #ifdef COM_REDE
  UNLOCK                                           // libera o registro e
  COMMIT                                           // forca gravacao
 #else
  IF RECC()-INT(RECC()/20)*20=0                    // a cada 20 registros
   COMMIT                                          // digitados forca gravacao
  ENDI
 #endi

 ult_reg=RECN()                                    // ultimo registro digitado
 OBX_REL(ult_reg)                               // imprime relat apos inclusao
 IF reg_cop!=NIL                                   // estava na consulta e quis rep o campo
  sq_atual_=NIL
  EXIT                                             // cai fora...
 ENDI
ENDD

#ifdef COM_REDE
 OBX_ANT_SEQ()                                     // restaura sequencial anterior
 SELE OBXEC
#endi

GO ult_reg                                         // para o ultimo reg digitado
SETKEY(K_F3,t_f3_)                                 // restaura teclas de funcoes
SETKEY(K_F4,t_f4_)
SET(_SET_DELETED,dele_atu)                            // ecluidos visiveis/invisiveis
SETKEY(K_CTRL_W,ctl_w)
SETKEY(K_CTRL_C,ctl_c)
SETKEY(K_CTRL_R,ctl_r)
RETU


PROC OBX_REL(ult_reg)  // imprime relatorio apos inclusao
LOCAL p_imp:=.t., i_ok:=.f., imp_rel:=.f.
DO WHIL .t.
 SAVE SCREEN                     // salva a tela

 #ifdef COM_REDE
  tps=TP_SAIDA(,,.t.)
  IF LASTKEY()=K_ESC
   EXIT
  ENDI
  i_ok=(tps=2 .OR. PREPIMP("OUTROS RECIBOS (2¦VIA)"))
  IF i_ok
   ADM_R023(tps,0,ult_reg)
   imp_rel=.t.
  ENDI
 #else
  i_ok=PREPIMP("OUTROS RECIBOS (2¦VIA)")
  IF i_ok
   ADM_R023(0,0,ult_reg)
   imp_rel=.t.
  ENDI
 #endi

 REST SCREEN                    // restaura tela
 IF imp_rel                     // imprimiu algo?
  msg="Prosseguir|Outra c¢pia"
  op_=1 //DBOX(msg,,,E_MENU,,"FIM DE IMPRESSŽO") // quer emitir outra copia?
  IF op_=2
   LOOP                         // nao quer...
  ENDI
 ENDI
 EXIT
ENDD
RETU


#ifdef COM_REDE
 PROC OBX_ANT_SEQ(est_seq)     // restaura sequencial anterior
 SELE OBX_SEQ     // seleciona arquivo de controle de sequencial
 BLOARQ(0,.5)     // esta estacao foi a ultima a incluir?
 IF sq_atual_ == numero
  REPL numero WITH sq_numero
  REPL intlan WITH sq_intlan
 ENDI
 UNLOCK           // libera DBF para outros usuarios
 COMMIT           // atualiza cps sequenciais no disco
 RETU
#endi


PROC OBX_CRIA_SEQ   // cria dbf de controle de campos sequenciais
LOCAL dbfseq_:=sistema[op_sis,O_ARQUI,O_DIR_DBF]+"OBX_seq" // arq temporario
SELE 0                          // seleciona area vazia
IF !FILE(dbfseq_+".dbf")        // se o dbf nao existe
 DBCREATE(dbfseq_,{;            // vamos criar a sua estrutura
                    {"numero"    ,"C",  8, 0},;
                    {"intlan"    ,"C",  8, 0};
                  };
 )
ENDI
USEARQ(dbfseq_,.f.,,,.f.)       // abre arquivo de cps sequencial
IF RECC()=0                     // se o dbf foi criado agora
 BLOARQ(0,.5)                   // inclui um registro que tera
 APPEND BLANK                   // os ultomos cps sequenciais
 SELE OBXEC
 IF RECC()>0                    // se o DBF nao estiver
  SET ORDER TO 0                // vazio, entao enche DBF seq
  GO BOTT                       // com o ultimo reg digitado
  REPL OBX_SEQ->numero WITH numero
  REPL OBX_SEQ->intlan WITH intlan
  DBSETORDER(1)                 // retorna ao indice principal
 ENDI
 SELE OBX_SEQ                   // seleciona arq de sequencias
 UNLOCK                         // libera DBF para outros usuarios
 COMMIT                         // atualiza cps sequenciais no disco
ENDI
RETURN

PROC OBX_GERA_SEQ()

#ifdef COM_REDE
 LOCAL ar_:=SELEC()
#else
 LOCAL reg_:=RECNO(),ord_ind:=INDEXORD()
#endi


#ifdef COM_REDE
 SELE OBX_SEQ
 BLOARQ(0,.5)
 sq_numero=OBX_SEQ->numero
 sq_intlan=OBX_SEQ->intlan
#else
 DBSETORDER(0)
 GO BOTT
#endi

M->numero=LPAD(STR(VAL(numero)+1),08,[0])
IF VAL(M->numero)=1
 M->numero=LPAD(RIGHT(DTOC(DATE()),2)+[000001],08,[0])
ENDI
M->intlan=LPAD(STR(VAL(intlan)+1),08,[0])

#ifdef COM_REDE
 OBX_GRAVA_SEQ()
 sq_atual_=OBX_SEQ->numero
 UNLOCK                                            // libera o registro
 COMMIT
 SELE (ar_)
#else
 DBSETORDER(ord_ind)
 GO reg_
#endi

RETU

PROC OBX_GRAVA_SEQ
REPL numero WITH M->numero
REPL intlan WITH M->intlan
RETU

PROC OBX_tela     // tela do arquivo OBXEC
tem_borda=.t.
l_s=Sistema[op_sis,O_TELA,O_LS]           // coordenadas da tela
c_s=Sistema[op_sis,O_TELA,O_CS]
l_i=Sistema[op_sis,O_TELA,O_LI]
c_i=Sistema[op_sis,O_TELA,O_CI]
OBS2PRINT:=[Observacao apenas para impressao                           ]
SETCOLOR(drvtittel)
vr_memo=NOVAPOSI(@l_s,@c_s,@l_i,@c_i)     // pega posicao atual da tela
CAIXA(mold,l_s,c_s,l_i,c_i)               // monta caixa da tela
i=LEN(sistema[op_sis,O_MENS])/2
@ l_s,c_s-1+(c_i-c_s+1)/2-i SAY " "+MAIUSC(sistema[op_sis,O_MENS])+" "
SETCOLOR(drvcortel)
@ l_s+01,c_s+1 SAY " Numero:"
@ l_s+02,c_s+1 SAY " Contrato:"
@ l_s+03,c_s+1 SAY "ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ"
@ l_s+04,c_s+1 SAY "                                      ³Circulares"
@ l_s+05,c_s+1 SAY "                                      ³ Ini"
@ l_s+06,c_s+1 SAY "                            Reg.:     ³  £lt"
@ l_s+07,c_s+1 SAY "                                      ³"
@ l_s+08,c_s+1 SAY " Admiss„o:            Sai Taxa:       ³"
@ l_s+09,c_s+1 SAY " Funerais:            Cobrador:       ³"
@ l_s+10,c_s+1 SAY "ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ"
@ l_s+15,c_s+1 SAY "ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ"
@ l_s+16,c_s+1 SAY " Ref.:                       Vl.Pago:"
@ l_s+17,c_s+1 SAY " Pago com..:             Troco:"
@ l_s+18,c_s+1 SAY " OBS.:"
@ l_s+19,c_s+1 SAY "  emitida em             por"
RETU

PROC OBX_gets     // mostra variaveis do arquivo OBXEC
LOCAL getlist := {}, ord_, chv_, ar_get1:=ALIAS(), op_ant := op_menu
OBX_TELA()
SETCOLOR(drvcortel+","+drvcorget+",,,"+corcampo)
PTAB(CODIGO,[GRUPOS])
PTAB(IIF(EMPT(M->USUARIO),PADR(M->CONTAREC+IDE_MAQ,10,' '),PADR(M->USUARIO,10,' '))+M->HISTRCREC+[       ],'ORDPGRC',2)
PTAB(PADR(SUBSTR(M->IDE_MAQ,2),4)+[OBX],[IMPPAR],1)
CRIT("",,"16")
@ l_s+01 ,c_s+12 GET  numero;
		 PICT sistema[op_sis,O_CAMPO,01,O_MASC]

@ l_s+02 ,c_s+12 GET  codigo;
		 PICT sistema[op_sis,O_CAMPO,02,O_MASC]
		 CRIT(sistema[op_sis,O_CAMPO,02,O_CRIT],,"1|2|3|4|5|6|7|8|9|10|11|12|13|14")

@ l_s+16 ,c_s+08 GET  cobranca;
                 PICT sistema[op_sis,O_CAMPO,03,O_MASC]

@ l_s+16 ,c_s+39 GET  valorpg;
                 PICT sistema[op_sis,O_CAMPO,04,O_MASC]

@ l_s+17 ,c_s+14 GET  valoraux;
                 PICT sistema[op_sis,O_CAMPO,05,O_MASC]
                 CRIT(sistema[op_sis,O_CAMPO,05,O_CRIT],,"15")

@ l_s+16 ,c_s+08 GET  cobranca;
                 PICT sistema[op_sis,O_CAMPO,03,O_MASC]

@ l_s+19 ,c_s+14 GET  emitido_;
                 PICT sistema[op_sis,O_CAMPO,06,O_MASC]

@ l_s+19 ,c_s+30 GET  por

@ l_s+19 ,c_s+44 GET  numop;
                 PICT sistema[op_sis,O_CAMPO,08,O_MASC]

CRIT("",,"1|3|4|5|6|7|8|9|10|11|12|13|14")
CLEAR GETS
RETU

PROC OBX_get1(tp_mov)     // capta variaveis do arquivo OBXEC
LOCAL getlist := {}, ord_, chv_, ar_get1:=ALIAS(), op_ant := op_menu
PRIV  blk_obxec:=.t.

IF tp_mov=INCLUI
 DO WHILE .t.
  rola_t=.f.
  SET KEY K_ALT_F8 TO ROLATELA
  SETCOLOR(drvcortel+","+drvcorget+",,,"+corcampo)
  @ l_s+01 ,c_s+12 GET numero;
                   PICT sistema[op_sis,O_CAMPO,01,O_MASC]
  @ l_s+19 ,c_s+14 GET emitido_;
		   PICT sistema[op_sis,O_CAMPO,06,O_MASC]
  @ l_s+19 ,c_s+30 GET por
  @ l_s+19 ,c_s+44 GET numop;
                   PICT sistema[op_sis,O_CAMPO,08,O_MASC]
  CLEA GETS
  CRIT("",,"16")
  @ l_s+02 ,c_s+12 GET  codigo;
		   PICT sistema[op_sis,O_CAMPO,02,O_MASC]
		   DEFINICAO 2
		   MOSTRA sistema[op_sis,O_FORMULA,1]
                   MOSTRA sistema[op_sis,O_FORMULA,2]
                   MOSTRA sistema[op_sis,O_FORMULA,3]
                   MOSTRA sistema[op_sis,O_FORMULA,4]
                   MOSTRA sistema[op_sis,O_FORMULA,5]
                   MOSTRA sistema[op_sis,O_FORMULA,6]
                   MOSTRA sistema[op_sis,O_FORMULA,7]
                   MOSTRA sistema[op_sis,O_FORMULA,8]
                   MOSTRA sistema[op_sis,O_FORMULA,9]
                   MOSTRA sistema[op_sis,O_FORMULA,10]
                   MOSTRA sistema[op_sis,O_FORMULA,11]
		   MOSTRA sistema[op_sis,O_FORMULA,12]
                   MOSTRA sistema[op_sis,O_FORMULA,13]
                   MOSTRA sistema[op_sis,O_FORMULA,14]

  @ l_s+16 ,c_s+08 GET  cobranca;
                   PICT sistema[op_sis,O_CAMPO,03,O_MASC]
                   DEFINICAO 3

  @ l_s+16 ,c_s+39 GET  valorpg;
		   PICT sistema[op_sis,O_CAMPO,04,O_MASC]
                   DEFINICAO 4

  @ l_s+17 ,c_s+14 GET  valoraux;
                   PICT sistema[op_sis,O_CAMPO,05,O_MASC]
                   DEFINICAO 5
                   MOSTRA sistema[op_sis,O_FORMULA,15]

  READ
  SET KEY K_ALT_F8 TO
  IF rola_t
   ROLATELA()
   LOOP
  ENDI
  IF LASTKEY()!=K_ESC .AND. drvincl .AND. op_menu=INCLUSAO
   IF !CONFINCL()
    LOOP
   ENDI
  ENDI
  EXIT
 ENDD
ENDI
PTAB(CODIGO,[GRUPOS])
PTAB(CODIGO,'TAXAS',1)
PTAB(IIF(EMPT(M->USUARIO),PADR(M->CONTAREC+IDE_MAQ,10,' '),PADR(M->USUARIO,10,' '))+M->HISTRCREC+[       ],'ORDPGRC',2)
PTAB(PADR(SUBSTR(M->IDE_MAQ,2),4)+[OBX],[IMPPAR],1)
IF tp_mov=EXCLUI .OR. tp_mov=FORM_INVERSA

 #ifdef COM_REDE
  IF EMPT(numop)
   IF !EMPTY(ALIAS())
    REPL numop WITH ORDPGRC->numop
   ENDI
  ENDI
  IF PTAB(numop,'ORDPGRC',1)
   REPBLO('ORDPGRC->nrdoctos',{||ORDPGRC->nrdoctos - 1})
  ENDI
  IF EMPT(numop).AND.PTAB(IIF(EMPT(M->usuario),PADR(M->contarec+ide_maq,10,' '),PADR(M->usuario,10,' '))+M->histrcrec+[       ],'ORDPGRC',2)
   REPBLO('ORDPGRC->valortotal',{||ORDPGRC->valortotal-valorpg})
  ENDI
  IF !EMPT(numop).AND.PTAB(numop,'ORDPGRC',1)
   REPBLO('ORDPGRC->valortotal',{||ORDPGRC->valortotal -valorpg})
  ENDI
 #else
  IF EMPT(numop)
   IF !EMPTY(ALIAS())
    REPL numop WITH ORDPGRC->numop
   ENDI
  ENDI
  IF PTAB(numop,'ORDPGRC',1)
   REPL ORDPGRC->nrdoctos WITH ORDPGRC->nrdoctos - 1
  ENDI
  IF EMPT(numop).AND.PTAB(IIF(EMPT(M->usuario),PADR(M->contarec+ide_maq,10,' '),PADR(M->usuario,10,' '))+M->histrcrec+[       ],'ORDPGRC',2)
   REPL ORDPGRC->valortotal WITH ORDPGRC->valortotal-valorpg
  ENDI
  IF !EMPT(numop).AND.PTAB(numop,'ORDPGRC',1)
   REPL ORDPGRC->valortotal WITH ORDPGRC->valortotal -valorpg
  ENDI
 #endi

 IF 1=3
  IF !EMPTY(ORDPGRC->codlan)
   TIRA_LANC("ORDPGRC",LEFT(ORDPGRC->codlan,16),.f.)
  ENDI
 ENDI
 IF 1=3
  IF !EMPTY(IMPPAR->codlan)
   TIRA_LANC("IMPPAR",LEFT(IMPPAR->codlan,16))
  ENDI
 ENDI
 IF !EMPTY(ALIAS())
  DELE
 ENDI
ELSEIF tp_mov=INCLUI .OR. tp_mov=RECUPERA .OR. tp_mov=FORM_DIRETA
 IF (op_menu=INCLUSAO .AND. LASTKEY()!=K_ESC) .OR. op_menu!=INCLUSAO
  IF !EMPT(valorpg).AND. !PTAB(IIF(EMPT(M->usuario),PADR(M->contarec+ide_maq,10,' '),PADR(M->usuario,10,' '))+M->histrcrec+[       ],'ORDPGRC',2)
   ord_=LEN(sistema[EVAL(qualsis,"ORDPGRC"),O_CHAVE])
   IF !EMPTY(ORDPGRC->codlan)
    chv_=LEFT(ORDPGRC->codlan,16)
   ELSE
    IF TYPE("M->intlan")="C" .AND. EMPTY(intlan)
     chv_="OBX-"+M->intlan+"-001"
    ELSE
     chv_="OBX-"+intlan+"-001"
    ENDI
   ENDI
   PTAB(chv_,"ORDPGRC",ord_)
   FAZ_LANC("ORDPGRC",chv_,.t.)
   REPL ORDPGRC->origem WITH [ADM],;
        ORDPGRC->lancto_ WITH DATE(),;
        ORDPGRC->por WITH M->usuario,;
	ORDPGRC->numconta WITH IIF(EMPT(M->usuario),PADR(M->contarec+ide_maq,10,' '),PADR(M->usuario,10,' ')),;
        ORDPGRC->historico WITH M->histrcrec,;
        ORDPGRC->debcred WITH [C],;
        ORDPGRC->valortotal WITH 0,;
        ORDPGRC->vencto_ WITH DATE(),;
        ORDPGRC->documento WITH [FCC/Taxas],;
        ORDPGRC->complement WITH [FCC/Outros recebimentos]

   #ifdef COM_REDE
    ORDPGRC->(DBUNLOCK())                          // libera o registro
   #endi

  ENDI
  IF !PTAB(PADR(SUBSTR(M->ide_maq,2),4)+[OBX],[IMPPAR],1)
   ord_=LEN(sistema[EVAL(qualsis,"IMPPAR"),O_CHAVE])
   IF !EMPTY(IMPPAR->codlan)
    chv_=LEFT(IMPPAR->codlan,16)
   ELSE
    IF TYPE("M->intlan")="C" .AND. EMPTY(intlan)
     chv_="OBX-"+M->intlan+"-002"
    ELSE
     chv_="OBX-"+intlan+"-002"
    ENDI
   ENDI
   PTAB(chv_,"IMPPAR",ord_)
   FAZ_LANC("IMPPAR",chv_)
   REPL IMPPAR->idmaq WITH PADR(SUBSTR(M->ide_maq,2),4),;
        IMPPAR->base WITH [OBX]

   #ifdef COM_REDE
    IMPPAR->(DBUNLOCK())                           // libera o registro
   #endi

  ENDI
   IF EMPT(numop)
    IF op_menu=INCLUSAO
     numop=ORDPGRC->numop
    ELSE
     REPL numop WITH ORDPGRC->numop
    ENDI
   ENDI

  #ifdef COM_REDE
   IF PTAB(numop,'ORDPGRC',1)
    REPBLO('ORDPGRC->nrdoctos',{||ORDPGRC->nrdoctos + 1})
   ENDI
   IF op_menu=INCLUSAO
    emitido_=DATE()
   ELSE
    REPL emitido_ WITH DATE()
   ENDI
   IF op_menu=INCLUSAO
    por=M->usuario
   ELSE
    REPL por WITH M->usuario
   ENDI
   IF op_menu=INCLUSAO
    filial=M->p_filial
   ELSE
    REPL filial WITH M->p_filial
   ENDI
   IF EMPT(numop).AND.PTAB(IIF(EMPT(M->usuario),PADR(M->contarec+ide_maq,10,' '),PADR(M->usuario,10,' '))+M->histrcrec+[       ],'ORDPGRC',2)
    REPBLO('ORDPGRC->valortotal',{||ORDPGRC->valortotal+valorpg})
   ENDI
   IF !EMPT(numop).AND.PTAB(numop,'ORDPGRC',1)
    REPBLO('ORDPGRC->valortotal',{||ORDPGRC->valortotal +valorpg})
   ENDI
   IF PTAB(PADR(SUBSTR(M->ide_maq,2),4)+[OBX],[IMPPAR],1)
    REPBLO('IMPPAR->docto',{||numero})
   ENDI
  #else
   IF EMPT(numop)
    IF op_menu=INCLUSAO
     numop=ORDPGRC->numop
    ELSE
     REPL numop WITH ORDPGRC->numop
    ENDI
   ENDI
   IF PTAB(numop,'ORDPGRC',1)
    REPL ORDPGRC->nrdoctos WITH ORDPGRC->nrdoctos + 1
   ENDI
   IF op_menu=INCLUSAO
    emitido_=DATE()
   ELSE
    REPL emitido_ WITH DATE()
   ENDI
   IF op_menu=INCLUSAO
    por=M->usuario
   ELSE
    REPL por WITH M->usuario
   ENDI
   IF op_menu=INCLUSAO
    filial=M->p_filial
   ELSE
    REPL filial WITH M->p_filial
   ENDI
   IF EMPT(numop).AND.PTAB(IIF(EMPT(M->usuario),PADR(M->contarec+ide_maq,10,' '),PADR(M->usuario,10,' '))+M->histrcrec+[       ],'ORDPGRC',2)
    REPL ORDPGRC->valortotal WITH ORDPGRC->valortotal+valorpg
   ENDI
   IF !EMPT(numop).AND.PTAB(numop,'ORDPGRC',1)
    REPL ORDPGRC->valortotal WITH ORDPGRC->valortotal +valorpg
   ENDI
   IF PTAB(PADR(SUBSTR(M->ide_maq,2),4)+[OBX],[IMPPAR],1)
    REPL IMPPAR->docto WITH numero
   ENDI
  #endi

  IF op_menu!=INCLUSAO
   RECA
  ENDI
 ENDI
ENDI
RETU

* \\ Final de OBXEC.PRG
procedure bxr_02f9
/*
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
 \ Empresa.: Ind£stria de Urnas Bignotto Ltda
 \ Programa: BXR_02F9.PRG
 \ Data....: 28-11-95
 \ Sistema.: Administradora de Funer rias
 \ Funcao..: Valor inicial do campo VALORPG, arquivo BXREC
 \ Analista: Ademilson Pedro Bom
 \ Criacao.: Programado manualmente pelo analista
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/

#include "adrbig.ch"    // inicializa constantes manifestas
PRIV vladd:=0
IF op_menu = INCLUSAO
 grupo=GRUPOS->grupo
ELSE
 RETU .T.
 REPL grupo WITH GRUPOS->grupo
ENDIF
IF TAXAS->emissao_< DATE()
 jrok:=PTAB([],'JUROS',1)
 nrd:=(DATE() - TAXAS->emissao_)
 IF jrok .AND. (nrd > JUROS->mltcaren)
  vladd+=TAXAS->valor*JUROS->multa/100
 ENDI
 IF jrok .AND. (nrd > JUROS->jrscaren)
  vladd+=TAXAS->valor*JUROS->juros/100*nrd
 ENDI
ENDI

RETU IIF(EMPT(TAXAS->valorpg),TAXAS->valor+M->vladd,0)


* \\ Final de BXR_02F9.PRG


procedure gui_05f9
/*
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
 \ Empresa.: PresServ Inform tica-Limeira (019)452.6623
 \ Programa: GUI_05F9.PRG
 \ Data....: 24-11-96
 \ Sistema.: Controle de Convˆnios
 \ Funcao..: Fun‡„o F8 do campo CONTRINSC, arquivo GUIAS
 \ Analista: Ademilson Pedro Bom
 \ Criacao.: Programado manualmente pelo analista
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/

#include "ADRbig.ch"    // inicializa constantes manifestas

RETU INSCRITS->codigo+INSCRITS->grau+STR(INSCRITS->seq,2,0) // <- deve retornar um valor qualquer

* \\ Final de GUI_05F9.PRG
€
 ADM_RX201–Þ  ADM_RX20CODEREL_CABCODEC_ETEXTENDCODE	_SYMSTARTSYMSTARTSYMBOLSSYMBOLS_SYMENDSYMENDNULLBEGDATA_DATADATA_SYMPBDATA_SYMPDATA_SYMPEDATA_CONSTCONST_MSGMSG_BEGBSSBEGBSS_BSSBSS_ENDBSSENDBSSDGROUPµ˜ @¿J˜ @`¶˜ H  ˜ h  	ç˜ `€
d˜ h  ß˜ h  Û˜ H  ÷˜ H  ó˜ H ç˜ H  ë˜ H  ç˜ (  procedure gru_02f9
/*
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
 \ Empresa.: PresServ Inform tica-Limeira (019)452.6623
 \ Programa: GRU_02F9.PRG
 \ Data....: 22-02-98
 \ Sistema.: Administradora - PLANO
 \ Funcao..: Fun‡„o F8 do campo CODIGO, arquivo GRUPOS
 \ Analista: Ademilson Pedro Bom
 \ Criacao.: Programado manualmente pelo analista
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/

#include "adRbig.ch"    // inicializa constantes manifestas

//LOCAL reg_dbf:=POINTER_DBF()
DO WHILE .T.
 rgruin:=VDBF(6,32,20,77,'ARQGRUP',{'grup','classe','inicio','final','ultcirc','emissao_'},1,'grup',[])
 IF LASTKEY()=K_ESC          // nao confirmou...
  rcodin:=' '
  EXIT                                  // retorna para o DOS
 ENDI
 PTAB(rgruin,[ARQGRUP],1)
 rcodin:=ARQGRUP->inicio

 DO WHILE PTAB(M->rcodin,[GRUPOS],1).and.rcodin<=ARQGRUP->final
  rcodin:=sTRzero(VAL(rcodin)+1,6,0)
 ENDD

 IF M->rcodin>ARQGRUP->final
  M->rcodin:=ARQGRUP->inicio
  DO WHILE PTAB(rcodin,[GRUPOS],1).and.rcodin<=ARQGRUP->final
   IF GRUPOS->situacao='2'
    EXIT
   ENDI
   M->rcodin:=sTRzero(VAL(rcodin)+1,6,0)
  ENDD
 ENDI
 IF M->rcodin>ARQGRUP->final
  M->rcodin:='000000'
  DBOX("Grupo sem vagas, "+usuario,13,45,2)   // Grupo cheio!.Fazer oque?
 ELSE
  EXIT
 ENDI
ENDD

//POINTER_DBF(reg_dbf)

RETU M->rcodin       // <- deve retornar um valor qualquer

* \\ Final de GRU_02F9.PRG
€ IMPPAR©– IMPPARCODEIMP_INCLCODEIMP_TELACODEIMP_GETSCODEIMP_GET1CODEC_ETEXTENDCODE	_SYMSTARTSYMSTARTSYMBOLSSYMBOLS_SYMENDSYMENDNULLBEGDATA_DATADATA_SYMPBDATA_SYMPDATA_SYMPEDATA_CONSTCONST_MSGMSG_BEGBSSBEGBSS_BSSBSS_ENDBSSENDBSSDGROUPï˜ @d¶˜ @}	‘˜ @™y˜ @Ý	1˜ @š
o˜ H  ÿ˜ h  Û˜ `É˜ h  Ó˜ h  Ï˜ H  ë˜ H  ç˜ H €
 ADM_R022W–Þ  ADM_R022CODEREL_CABCODEC_ETEXTENDCODE	_SYMSTARTSYMSTARTSYMBOLSSYMBOLS_SYMENDSYMENDNULLBEGDATA_DATADATA_SYMPBDATA_SYMPDATA_SYMPEDATA_CONSTCONST_MSGMSG_BEGBSSBEGBSS_BSSBSS_ENDBSSENDBSSDGROUPÛ˜ @5Ù˜ @EÑ˜ H  ˜ h  	ç˜ ` 
E˜ h  ß˜ h  Û˜ H  ÷˜ H  ó˜ H ç˜ H  ë˜ H  ç˜ (  /*
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
 \ Empresa.: PresServ Inform tica - Limeira (019)452.6623
 \ Programa: GUI_07F9.PRG
 \ Data....: 23-05-98
 \ Sistema.: Administradora - RECEP€„O
 \ Funcao..: Fun‡„o de busca do inscrito, arquivo GUIAS
 \ Analista: Ademilson Pedro Bom
 \ Criacao.: Programado manualmente pelo analista
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/

#include "adrbig.ch"    // inicializa constantes manifestas
LOCAL reg_dbf
PTAB([],[GRUPOS],1,.t.)
IF !(op_menu=INCLUSAO)
 retu .t.
ENDI
PARA cod_igo
reg_dbf:=POINTER_DBF()
PRIVA respx,nomx:=space(35)
codigo:=contrato:=cod_igo
nome:=space(35)
IF EMPT(VAL(contrato)) //=[000000]
 nomx=DBOX("Nome",,,,,"Informe o nome a procurar",nomx,"@!")

 IF PTAB(alltrim(nomx),[GRUPOS],2,.t.)
	codigo:=contrato:=GRUPOS->codigo
	codigo:=VDBF(6,3,20,77,'GRUPOS',{'nome','codigo','endereco','tcarencia'},2,'codigo')
	nome:=GRUPOS->nome
  contrato:=M->codigo


 ELSEIF PTAB(alltrim(nomx),[INSCRITS],2,.t.)
	codigo:=contrato:=INSCRITS->codigo //+INSCRITS->grau+STR(INSCRITS->seq,2)
  nome:=alltrim(inscrits->nome)
	codigo:=VDBF(6,3,20,77,'INSCRITS',{'nome','codigo','grau','tcarencia'},2,'codigo')
	nome:=INSCRITS->nome
  codigo:=contrato:=IIF(codigo=NIL,[         ],left(codigo,9))

 ENDI

 IF LASTKEY()=K_ESC             // se teclou ESC
	codigo:=contrato:=[         ]
	POINTER_DBF(reg_dbf)
	RETU .f.
 ENDI
ELSEIF LEN(ALLTRIM(contrato))<9.AND.!EMPT(COntrato)
 msg_ins:=cod_msg:=[]
 nopc:=1
 tem10:=ptab('010'+strzero(VAL(contrato),6),[GRUPOS],1)
 IF tem10
  cod_msg+=GRUPOS->codigo
 	msg_ins+=GRUPOS->codigo+' '+GRUPOS->nome//+' '+GRUPOS->endereco+' '//+DTOC(GRUPOS->tcarencia)
 ENDI

 tem20:=ptab('020'+strzero(VAL(contrato),6),[GRUPOS],1)
 IF tem20
  IF tem10
   msg_ins+=[|]
  ENDI
  cod_msg+=GRUPOS->codigo
 	msg_ins+=GRUPOS->codigo+' '+GRUPOS->nome//+' '+GRUPOS->endereco//+' '+DTOC(GRUPOS->tcarencia)
 ENDI
 if len(cod_msg) > 9
  msg_:=[Escolha o contrato|Codigo Nome                           Endereco]
  nopc:=DBOX(msg_ins,,,E_MENU,,msg_,,,nopc)
 endi
 codigo:=SUBSTR(cod_msg,((nopc-1)*10)+1,10)


ENDI
respx:=contrato:=codigo

IF PTAB(respx,[GRUPOS],1)
 titular:=GRUPOS->nome
ENDI

POINTER_DBF(reg_dbf)

retu PTAB(respx,[GRUPOS])	 // <- deve retornar um valor qualquer

* \\ Final de GUI_02F9.PRG
€
 ADR_ATR1 –Ñ  ADR_ATR1CODEC_ETEXTENDCODE	_SYMSTARTSYMSTARTSYMBOLSSYMBOLS_SYMENDSYMENDNULLBEGDATA_DATADATA_SYMPBDATA_SYMPDATA_SYMPEDATA_CONSTCONST_MSGMSG_BEGBSSBEGBSS_BSSBSS_ENDBSSENDBSSDGROUPß˜ @øMÖ˜ H  ˜ h  ë˜ `` 	˜ h  
ã˜ h  ß˜ H  û˜ H  ÷˜ H ë˜ H  ï˜ H  ë˜ (  ˜ H  procedure kinscf9
/*
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
 \ Empresa.: PresServ Inform tica-Limeira (019)452.6623
 \ Programa: KINSCF9.PRG
 \ Data....: 19-08-95
 \ Sistema.: Controle de Processos da Funer ria V.á
 \ Funcao..: Fun‡„o F8 do campo CODDECL, arquivo CADPROC
 \ Analista: Ademilson Pedro Bom
 \ Criacao.: Programado manualmente pelo analista
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/

#include "adrbig.ch"    // inicializa constantes manifestas

RETU INSCRITS->codigo //+INSCRITS->grau+STR(INSCRITS->seq,02,00)

* \\ Final de KINSCF9.PRG
/*
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
 \ Empresa.: Ind£stria de Urnas Bignotto Ltda
 \ Programa: ADM_R026.PRG
 \ Data....: 30-06-97
 \ Sistema.: Administradora - RECEP€„O
 \ Funcao..: Capa de Processo
 \ Analista: Ademilson Pedro Bom
 \ Criacao.: GAS-Pro v3.0 
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/

#include "adrbig.ch"    // inicializa constantes manifestas

LOCAL dele_atu, getlist:={}
PARA  lin_menu, col_menu
PRIV  tem_borda:=.t., op_menu:=VAR_COMPL, l_s:=10, c_s:=20, l_i:=13, c_i:=61, tela_fundo:=SAVESCREEN(0,0,MAXROW(),79)
nucop=1
SETCOLOR(drvtittel)
vr_memo=NOVAPOSI(@l_s,@c_s,@l_i,@c_i)     // pega posicao atual da tela
CAIXA(mold,l_s,c_s,l_i,c_i)               // monta caixa da tela
@ l_s,c_s+10 SAY " IMPRESSŽO AUX.FUNERAL "
SETCOLOR(drvcortel)
@ l_s+01,c_s+1 SAY " Processo:"
@ l_s+02,c_s+1 SAY " Confirme:"
rproc=SPAC(11)                                     // Processo
confirme=SPAC(1)                                   // Confirme
DO WHILE .t.
 rola_t=.f.
 cod_sos=56
 SET KEY K_ALT_F8 TO ROLATELA
 SETCOLOR(drvcortel+","+drvcorget+",,,"+corcampo)
 @ l_s+01 ,c_s+12 GET  rproc;
                  PICT "@R 99999/9999-99";
		  VALI CRIT("!EMPT(RPROC).AND.PTAB(M->rproc,[AFUNER],1)~Campo utilizado para localiza‡„o dos documentos.|Tecle F8 para busca em tabela")
                  DEFAULT "IIF(PTAB(PADR(SUBSTR(M->ide_maq,2),4)+[AFU],[IMPPAR],1),ALLTRIM(IMPPAR->docto),[])"
                  AJUDA "Digite neste campo o n£mero de|identifica‡„o do processo"
                  CMDF8 "VDBF(6,12,20,77,'AFUNER',{'processo','proc2','categ','contrato','falecido'},1,'V02001F9()',[])"

 @ l_s+02 ,c_s+12 GET  confirme;
                  PICT "!";
                  VALI CRIT("confirme='S'.AND.V02002F9()~CONFIRME n„o aceit vel|Digite S para confirmar|ou|Tecle ESC para cancelar")
                  AJUDA "Digite S para confirmar|ou|tecle ESC para cancelar"

 READ
 SET KEY K_ALT_F8 TO
 IF rola_t
  ROLATELA(.f.)
  LOOP
 ENDI
 IF LASTKEY()=K_ESC                                // se quer cancelar
  RETU                                             // retorna
 ENDI

 #ifdef COM_REDE
  IF !USEARQ("AFUNER",.f.,10,1)                    // se falhou a abertura do arq
   RETU                                            // volta ao menu anterior
  ENDI
 #else
  USEARQ("AFUNER")                                 // abre o dbf e seus indices
 #endi

 PTAB(contrato,"GRUPOS",1,.t.)                     // abre arquivo p/ o relacionamento
 PTAB(funcresp,"FNCS",1,.t.)
 PTAB(GRUPOS->tipcont,"CLASSES",1,.t.)
 SET RELA TO contrato INTO GRUPOS,;                // relacionamento dos arquivos
          TO funcresp INTO FNCS,;
          TO GRUPOS->tipcont INTO CLASSES
 titrel:=criterio:=cpord := ""                     // inicializa variaveis
 titrel:=chv_rela:=chv_1:=chv_2 := ""
 tps:=op_x:=ccop := 1
 IF !opcoes_rel(lin_menu,col_menu,4,11)            // nao quis configurar...
  CLOS ALL                                         // fecha arquivos e
  LOOP                                             // volta ao menu
 ENDI
 IF tps=2                                          // se vai para arquivo/video
  arq_=ARQGER()                                    // entao pega nome do arquivo
  IF EMPTY(arq_)                                   // se cancelou ou nao informou
   LOOP                                            // retorna
  ENDI
 ELSE
  arq_=drvporta                                    // porta de saida configurada
 ENDI
 SET PRINTER TO (arq_)                             // redireciona saida
 EXIT
ENDD
IF !EMPTY(drvtapg)                                 // existe configuracao de tam pag?
 op_=AT("NNN",drvtapg)                             // se o codigo que altera
 IF op_=0                                          // o tamanho da pagina
  msg="Configura‡„o do tamanho da p gina!"         // foi informado errado
  DBOX(msg,,,,,"ERRO!")                            // avisa
  CLOSE ALL                                        // fecha todos arquivos abertos
  RETU                                             // e cai fora...
 ENDI                                              // codigo para setar/resetar tam pag
 lpp_050=LEFT(drvtapg,op_-1)+"088"+SUBS(drvtapg,op_+3)
 lpp_066=LEFT(drvtapg,op_-1)+"066"+SUBS(drvtapg,op_+3)
ELSE
 lpp_050:=lpp_066 :=""                             // nao ira mudara o tamanho da pag
ENDI
DBOX("[ESC] Interrompe",15,,,NAO_APAGA)
dele_atu:=SET(_SET_DELETED,.t.)                    // os excluidos nao servem...
SET DEVI TO PRIN                                   // inicia a impressao
maxli=65                                           // maximo de linhas no relatorio
IMPCTL(lpp_050)                                    // seta pagina com 50 linhas
IMPCTL(drvpde8)                                    // ativa 8 lpp
IF tps=2
 IMPCTL("' '+CHR(8)")
ENDI
BEGIN SEQUENCE
 DO WHIL ccop<=nucop                               // imprime qde copias pedida
  pg_=1; cl=999
  INI_ARQ()                                        // acha 1o. reg valido do arquivo
  ccop++                                           // incrementa contador de copias
  IF PTAB(PADR(SUBSTR(M->ide_maq,2),4)+[AFU],[IMPPAR],1)
   PTAB(ALLTRIM(IMPPAR->docto),[AFUNER],1)
  ENDI// se atender a condicao...
  DO WHIL !EOF()
   #ifdef COM_TUTOR
    IF IN_KEY()=K_ESC                              // se quer cancelar
   #else
    IF INKEY()=K_ESC                               // se quer cancelar
   #endi
    IF canc()                                      // pede confirmacao
     BREAK                                         // confirmou...
    ENDI
   ENDI
   IF PTAB(PADR(SUBSTR(M->ide_maq,2),4)+[AFU],[IMPPAR],1).and.processo+proc2+filial+categ=ALLTRIM(IMPPAR->docto)// se atender a condicao...
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,066 SAY TRAN(processo+proc2,"@R 99999/99")// N£mero Processo
    REL_CAB(6)                                     // soma cl/imprime cabecalho
    @ cl,015 SAY TRAN(falecido,"@!")               // Nome do falecido
    REL_CAB(2)                                     // soma cl/imprime cabecalho
    @ cl,015 SAY ALLTRIM(ruares)+[ ]+ALLTRIM(baires)+'-'+ALLTRIM(munres)// endereco (falecido)
    REL_CAB(3)                                     // soma cl/imprime cabecalho
    @ cl,019 SAY TRAN(falecto_,"@D")               // Data falcto.
    @ cl,062 SAY TRAN(horafal,"99:99")             // Hora Falcto.
    REL_CAB(2)                                     // soma cl/imprime cabecalho
    @ cl,020 SAY TRAN(ALLTRIM(ruafal),"@!")        // Rua Falecimento
    REL_CAB(2)                                     // soma cl/imprime cabecalho
    @ cl,020 SAY municfal                          // Munic¡pio de falecimento
    REL_CAB(3)                                     // soma cl/imprime cabecalho
    @ cl,016 SAY TRAN(nomedec,"@!")                // Declarante
    REL_CAB(2)                                     // soma cl/imprime cabecalho
    @ cl,016 SAY ALLTRIM(ruadec)                   // endereco (declarante)
    @ cl,066 SAY fonedec                           // fone declarante
    REL_CAB(7)                                     // soma cl/imprime cabecalho
    @ cl,015 SAY TRAN(cemitsep,"@!")               // Cemit‚rio Sepultamento
    REL_CAB(2)                                     // soma cl/imprime cabecalho
    @ cl,023 SAY horasepult                        // hora sepultamento
    IF !EMPT(sepult_)                              // pode imprimir?
     @ cl,063 SAY DTOC(sepult_)                    // data sepultamento
    ENDI
    REL_CAB(22)                                    // soma cl/imprime cabecalho
    IF GRUPOS->tipcont=[01]                        // pode imprimir?
     @ cl,076 SAY [A]                              // tipo de plano azul
    ENDI
    REL_CAB(2)                                     // soma cl/imprime cabecalho
    IF GRUPOS->tipcont=[02]                        // pode imprimir?
     @ cl,076 SAY [P]                              // tipo plano prata
    ENDI
    REL_CAB(2)                                     // soma cl/imprime cabecalho
    @ cl,016 SAY FNCS->nome                        // Motorista respons vel
    @ cl,054 SAY IIF(CLASSES->prior=[S],M->mgrupvip,GRUPOS->grupo)// GRUPO
    @ cl,057 SAY TRAN(contrato,"999999")           // CONTRATO
    IF GRUPOS->tipcont=[03]                        // pode imprimir?
     @ cl,076 SAY [O]                              // tipo plano ouro
    ENDI
    REL_CAB(4)                                     // soma cl/imprime cabecalho
    @ cl,020 SAY IIF(categ=[PD],[Plano c/Difer. ],IIF(categ=[PL],[Atend.Plano],[Auxilio Funeral  ]))// Categoria
    SKIP                                           // pega proximo registro
    cl=999                                         // forca salto de pagina
   ELSE                                            // se nao atende condicao
    SKIP                                           // pega proximo registro
   ENDI
   EXIT
  ENDD
 ENDD ccop
 EJEC                                              // salta pagina
END SEQUENCE
IMPCTL(drvtde8)                                    // ativa 6 lpp
IMPCTL(lpp_066)                                    // seta pagina com 66 linhas
SET PRINTER TO (drvporta)                          // fecha arquivo gerado (se houver)
SET DEVI TO SCRE                                   // direciona saida p/ video
IF tps=2                                           // se vai para arquivo/video
 BROWSE_REL(arq_,2,3,MAXROW()-2,78)
ENDI                                               // mostra o arquivo gravado
GRELA(4)                                           // grava variacao do relatorio
SELE AFUNER                                        // salta pagina
SET RELA TO                                        // retira os relacionamentos
SET(_SET_DELETED,dele_atu)                         // os excluidos serao vistos
RETU

STATIC PROC REL_CAB(qt)                            // cabecalho do relatorio
IF qt>0                                            // se parametro maior que 0
 cl=cl+qt                                          // soma no contador de linhas
ENDI
IF cl>maxli .OR. qt=0                              // quebra de pagina
 cl=qt+5 ; pg_++
ENDI
RETU

* \\ Final de ADM_R026.PRG
procedure ben_01f9
/*
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
 \ Empresa.: PresServ Inform tica - Limeira (019)452.6623
 \ Programa: BEN_01F9.PRG
 \ Data....: 22-05-01
 \ Sistema.: Administradora - RECEP€„O
 \ Funcao..: F¢rmula (meno1) a mostrar na tela de BENEFIC
 \ Analista: Ademilson Pedro Bom
 \ Criacao.: Programado manualmente pelo analista
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/

#include "adrbig.ch"    // inicializa constantes manifestas
PARA qual
linhas:=[]
memos:={[detalhes],[vantagens],[condicoes],[informutil]}
FOR contmem = 1 TO 4
 temobs=.f.
 FOR contlin = 1 TO 10
  campomemo=memos[contmem]
  linaux := MEMOLINE(&campomemo,60,contlin,.t.)
  IF !EMPT(linaux)
   linhas += ALLTRIM(linaux)+[ ]
   temobs=.t.
  ENDI
 NEXT
 IF temobs
  linhas+=[ - ]
 ENDI
NEXT
RETU memoline(linhas,60,qual)

       // <- deve retornar um valor qualquer

* \\ Final de BEN_01F9.PRG
procedure ordpgrc
/*
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
 \ Empresa.: PresServ Inform tica - Limeira (019)452.6623
 \ Programa: ORDPGRC.PRG
 \ Data....: 04-11-03
 \ Sistema.: Administradora - RECEP€„O
 \ Funcao..: Gerenciador do subsistema de caixas
 \ Analista: Ademilson Pedro Bom
 \ Criacao.: GAS-Pro v4.0n
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/

#include "adrbig.ch"    // inicializa constantes manifestas

PARA lin_menu,col_menu
PRIV op_sis, tela_fundo:=SAVESCREEN(0,0,MAXROW(),79), l_s, c_s, l_i, c_i, l_a

op_sis=EVAL(qualsis,"ORDPGRC")
IF nivelop<sistema[op_sis,O_OUTROS,O_NIVEL]        // se usuario nao tem permissao,
 ALERTA()                                          // entao, beep, beep, beep
 DBOX(msg_auto,,,3)                                // lamentamos e
 RETU                                              // retornamos ao menu
ENDI
cn:=fgrep :=.f.

#ifdef COM_LOCK
 IF LEN(pr_ok)>0                                   // se a protecao acusou
  ? pr_ok                                          // erro, avisa e
  QUIT                                             // encerra a aplicacao
 ENDI
#endi

t_fundo=SAVESCREEN(0,0,MAXROW(),79)                // salva tela do fundo
op_cad=1
DO WHIL op_cad!=0
 criterio=""
 RESTSCREEN(0,0,MAXROW(),79,t_fundo)               // restaura tela do fundo
 cod_sos=5 ; cn=.f.
 CLEA TYPEAHEAD                                    // limpa o buffer do teclado
 fgrep=.f.
 SET KEY K_F3 TO                                   // retira das teclas F3 e F4 as
 SET KEY K_F4 TO                                   // funcoes de repeticao e confirmacao
 msg="Inclus„o~1|"+;                               // menu do subsistema
     "Manuten‡„o~2|"+;
     "Consulta~3"
 op_cad=DBOX(msg,lin_menu,col_menu,E_MENU,NAO_APAGA,MAIUSC(sistema[op_sis,O_MENU]),,,op_cad)
 IF op_cad!=0                                      // se escolheu uma opcao
  Tela_fundo=SAVESCREEN(0,0,MAXROW(),79)           // salva a tela para ROLATELA()
  PARAMETROS(dbfparam)
  SELE A                                           // e abre o arquivo e seus indices

  #ifdef COM_REDE
   IF !USEARQ(sistema[op_sis,O_ARQUI,O_NOME],.f.,20,1)
                                                   // se falhou a abertura do
    RETU                                           // arquivo volta ao menu anterior
   ENDI
  #else
   USEARQ(sistema[op_sis,O_ARQUI,O_NOME])
  #endi

  SET KEY K_F9 TO veoutros                         // habilita consulta em outros arquivos
 ENDI
 DO CASE
  CASE op_cad=01                                   // inclus„o
   op_menu=INCLUSAO
   IF AT("D",exrot[op_sis])=0                      // se usuario pode fazer inclusao
    ORD_INCL()                                     // neste arquivo chama prg de inclusao
   ELSE                                            // caso contrario vamos avisar que
    ALERTA()                                       // ele nao tem permissao para isto
    DBOX(msg_auto,,,3)
   ENDI

  CASE op_cad=02                                   // manuten‡„o
   op_menu=ALTERACAO
   cod_sos=7
   EDIT()

  CASE op_cad=03                                   // consulta
   op_menu=PROJECOES
   cod_sos=8
   EDITA(03,03,MAXROW()-2,77)

 ENDC
 SET KEY K_F9 TO                                   // F9 nao mais consultara outros arquivos
 CLOS ALL                                          // fecha todos arquivos abertos
ENDD
RETU

PROC ORD_incl(reg_cop)  // inclusao no arquivo ORDPGRC
LOCAL getlist:={},cabem:=1,rep:=ARRAY(FCOU()),ult_reg:=RECN(),dbfseq_,;
      ctl_r, ctl_c, ctl_w, t_f3_, t_f4_, dele_atu:=SET(_SET_DELETED,.f.)
PRIV op_menu:=INCLUSAO, sq_atual_, tem_borda, criterio:="", cpord:=""
FOR i=1 TO FCOU()                                  // cria/declara privadas as
 msg=FIEL(i)                                       // variaveis de memoria com
 PRIV &msg.                                        // o mesmo nome dos campos
NEXT                                               // do arquivo
IF reg_cop!=NIL                                    // quer repetir todo o reg atual
 FOR i=1 TO FCOU()                                 // para cada campo,
  msg=FIEL(i)                                      // salva o conteudo
  rep[i]=&msg.                                     // para repetir
 NEXT
ELSE
 AFILL(rep,"")                                     // eche com valor vazio
ENDI
t_f3_=SETKEY(K_F3,{||rep()})                       // repeticao reg anterior
t_f4_=SETKEY(K_F4,{||conf()})                      // confirma campos com ENTER
ctl_w=SETKEY(K_CTRL_W,{||nadafaz()})               // enganando o CA-Clipper...
ctl_c=SETKEY(K_CTRL_C,{||nadafaz()})
ctl_r=SETKEY(K_CTRL_R,{||nadafaz()})

#ifdef COM_REDE
 ORD_CRIA_SEQ()                                    // cria dbf de controle de cp sequenciais
 FOR i=1 TO FCOU()                                 // cria/declara privadas as
  msg="sq_"+FIEL(i)                                // variaveis de memoria com
  PRIV &msg.                                       // o mesmo nome dos campos
 NEXT                                              // do arquivo com extensao _seq
#endi

DO WHIL cabem>0
 cod_sos=6
 rola_t=.f.                                        // flag se quer rolar a tela
 SELE ORDPGRC
 GO BOTT                                           // forca o
 SKIP                                              // final do arquivo
 
 /*
    cria variaveis de memoria identicas as de arquivo, para inclusao
    de registros
 */
 FOR i=1 TO FCOU()
  msg=FIEL(i)
  M->&msg.=IF((fgrep .OR. reg_cop!=NIL).AND.!EMPT(rep[1]),rep[i],&msg.)
 NEXT
 DISPBEGIN()                                       // apresenta a tela de uma vez so
 ORD_TELA()
 INFOSIS(.t.)                                      // exibe informacao no rodape' da tela
 DISPEND()
 ORD_GERA_SEQ()
 cabem=DISKSPACE(;
          IF(;
             LEN(sistema[op_sis,O_ARQUI,O_DIR_DBF])<2.OR.sistema[op_sis,O_ARQUI,O_DIR_DBF]="\",;
             0,;
             ASC(sistema[op_sis,O_ARQUI,O_DIR_DBF])-64;
          );
       )
 cabem=INT((cabem-2048)/ORDPGRC->(RECSIZE()))
 IF cabem<1                                        // mais nenhum!!!
  ALERTA()
  msg="Verifique ESPA€O EM DISCO, "+usuario
  DBOX(msg,,,,,"INCLUSŽO INTERROMPIDA!")           // vamos parar por aqui!
  EXIT
 ENDI
 SELE 0                                            // torna visiveis variaveis de memoria
 SETCOLOR(drvcortel+","+drvcorget+",,,"+corcampo)
 SET KEY K_ALT_F8 TO ROLATELA
 
 /*
    recebe chaves do arquivo de indice basico
 */
 @ l_s+01 ,c_s+19 GET  numop;
                  PICT sistema[op_sis,O_CAMPO,01,O_MASC]
                  DEFINICAO 1

 READ
 SET KEY K_ALT_F8 TO
 IF rola_t
  ROLATELA()

  #ifdef COM_REDE
   ORD_ANT_SEQ()                                   // decrementa sequencial
  #endi

  LOOP
 ENDI
 SELE ORDPGRC
 IF LASTKEY()=K_ESC                                // cancelou ou chave em branco
  cabem=0                                          // prepara saida da inclusao
  LOOP                                             // volta p/ menu de cadastramento
 ENDI
 SEEK M->numop
 aprov_reg_=(FOUND().AND.DELE().AND.!drvvisivel)   // vai aproveitar o registro?
 IF FOUND() .AND. !aprov_reg_                      // pesquisou e achou!
  op_menu=ALTERACAO                                // seta flag de ateracao

  #ifdef COM_REDE
   ORD_ANT_SEQ()                                   // decrementa sequencial
   SELE ORDPGRC
  #endi

  DISPBEGIN()
  ORD_GETS()                                       // mostra conteudo do registro
  INFOSIS(.f.)                                     // exibe informacao no rodape' da tela
  DISPEND()
  ALERTA()
  msg="Consultar/alterar|Retornar … inclus„o"      // pergunta se deseja
  op_=DBOX(msg,,,E_MENU,,"REGISTRO J EXISTE")     // alterar o registro
  IF op_ =1                                        // caso afirmativo
   EDIT()                                          // deixa alterar
  ENDI
  op_menu=INCLUSAO
  LOOP                                             // volta para inclusao
 ENDI
 SELE 0
 ORD_GET1(INCLUI)                                  // recebe campos
 SELE ORDPGRC
 IF LASTKEY()=K_ESC                                // se cancelou

  #ifdef COM_REDE
   ORD_ANT_SEQ()                                   // decrementa sequencial
  #endi

  ALERTA()                                         // avisa que o registro
  DBOX("Registro n„o inclu¡do!",18,,1)             // nao foi incluido, e volta
  LOOP
 ENDI

 #ifdef COM_REDE
  GO BOTT                                          // vamos bloquear o final do
  SKIP                                             // arq para que nehum outro
  BLOREG(0,.5)                                     // usuario possa incluir
  SEEK M->numop                                    // se registro foi incluido
  aprov_reg_=(FOUND().AND.DELE().AND.!drvvisivel)  // vai aproveitar o registro?
  IF FOUND() .AND. !aprov_reg_                     // por outro usuario, entao
   BLOREG(0,.5)
   FOR i=1 TO FCOU()
    msg=FIEL(i)
    rep[i]=&msg.
    REPL &msg. WITH M->&msg.
   NEXT
   ORD_GET1(FORM_INVERSA)                          // executa formula inversa
   RECA
   FOR i=1 TO FCOU()
    msg=FIEL(i)
    REPL &msg. WITH rep[i]
   NEXT
   ALERTA(4)                                       // beep 4 vezes
   msg="Registro acabou de ser|inclu¡do por outro usu rio!"
   DBOX(msg,,,,,"ATEN€ŽO!")                        // avisa
   SELE ORDPGRC
   UNLOCK                                          // libera o registro
   LOOP                                            // e recebe chave novamente
  ENDI
 #endi

 IF aprov_reg_                                     // se vai aproveitar reg excluido

  #ifdef COM_REDE
   BLOREG(0,.5)
  #endi

  RECA                                             // excluido, vamos recupera-lo
 ELSE                                              // caso contrario
  APPEND BLANK                                     // inclui reg em branco no dbf
 ENDI
 FOR i=1 TO FCOU()                                 // para cada campo,
  msg=FIEL(i)                                      // salva o conteudo
  rep[i]=M->&msg.                                  // para repetir
  REPL &msg. WITH rep[i]                           // enche o campo do arquivo
 NEXT

 #ifdef COM_REDE
  UNLOCK                                           // libera o registro e
  COMMIT                                           // forca gravacao
 #else
  IF RECC()-INT(RECC()/20)*20=0                    // a cada 20 registros
   COMMIT                                          // digitados forca gravacao
  ENDI
 #endi

 ult_reg=RECN()                                    // ultimo registro digitado
 IF reg_cop!=NIL                                   // estava na consulta e quis rep o campo
  sq_atual_=NIL
  EXIT                                             // cai fora...
 ENDI
ENDD

#ifdef COM_REDE
 ORD_ANT_SEQ()                                     // restaura sequencial anterior
 SELE ORDPGRC
#endi

GO ult_reg                                         // para o ultimo reg digitado
SETKEY(K_F3,t_f3_)                                 // restaura teclas de funcoes
SETKEY(K_F4,t_f4_)
SET(_SET_DELETED,dele_atu)                            // ecluidos visiveis/invisiveis
SETKEY(K_CTRL_W,ctl_w)
SETKEY(K_CTRL_C,ctl_c)
SETKEY(K_CTRL_R,ctl_r)
RETU



#ifdef COM_REDE
 PROC ORD_ANT_SEQ(est_seq)     // restaura sequencial anterior
 SELE ORD_SEQ     // seleciona arquivo de controle de sequencial
 BLOARQ(0,.5)     // esta estacao foi a ultima a incluir?
 IF sq_atual_ == numop
  REPL numop WITH sq_numop
  REPL intlan WITH sq_intlan
 ENDI
 UNLOCK           // libera DBF para outros usuarios
 COMMIT           // atualiza cps sequenciais no disco
 RETU
#endi


PROC ORD_CRIA_SEQ   // cria dbf de controle de campos sequenciais
LOCAL dbfseq_:=sistema[op_sis,O_ARQUI,O_DIR_DBF]+"ORD_seq" // arq temporario
SELE 0                          // seleciona area vazia
IF !FILE(dbfseq_+".dbf")        // se o dbf nao existe
 DBCREATE(dbfseq_,{;            // vamos criar a sua estrutura
                    {"numop"     ,"C",  6, 0},;
                    {"intlan"    ,"C",  8, 0};
                  };
 )
ENDI
USEARQ(dbfseq_,.f.,,,.f.)       // abre arquivo de cps sequencial
IF RECC()=0                     // se o dbf foi criado agora
 BLOARQ(0,.5)                   // inclui um registro que tera
 APPEND BLANK                   // os ultomos cps sequenciais
 SELE ORDPGRC
 IF RECC()>0                    // se o DBF nao estiver
  SET ORDER TO 0                // vazio, entao enche DBF seq
  GO BOTT                       // com o ultimo reg digitado
  REPL ORD_SEQ->numop WITH numop
  REPL ORD_SEQ->intlan WITH intlan
  DBSETORDER(1)                 // retorna ao indice principal
 ENDI
 SELE ORD_SEQ                   // seleciona arq de sequencias
 UNLOCK                         // libera DBF para outros usuarios
 COMMIT                         // atualiza cps sequenciais no disco
ENDI
RETURN

PROC ORD_GERA_SEQ()

#ifdef COM_REDE
 LOCAL ar_:=SELEC()
#else
 LOCAL reg_:=RECNO(),ord_ind:=INDEXORD()
#endi


#ifdef COM_REDE
 SELE ORD_SEQ
 BLOARQ(0,.5)
 sq_numop=ORD_SEQ->numop
 sq_intlan=ORD_SEQ->intlan
#else
 DBSETORDER(0)
 GO BOTT
#endi

M->numop=LPAD(STR(VAL(numop)+1),06,[0])
M->intlan=LPAD(STR(VAL(intlan)+1),08,[0])

#ifdef COM_REDE
 ORD_GRAVA_SEQ()
 IF PROCNAME(1)!="FAZ_LANC"
  sq_atual_=ORD_SEQ->numop
  UNLOCK                                           // libera o registro
  COMMIT
 ENDI
 SELE (ar_)
#else
 DBSETORDER(ord_ind)
 GO reg_
#endi

RETU

PROC ORD_GRAVA_SEQ
REPL numop WITH M->numop
REPL intlan WITH M->intlan
RETU

PROC ORD_tela     // tela do arquivo ORDPGRC
tem_borda=.t.
l_s=Sistema[op_sis,O_TELA,O_LS]           // coordenadas da tela
c_s=Sistema[op_sis,O_TELA,O_CS]
l_i=Sistema[op_sis,O_TELA,O_LI]
c_i=Sistema[op_sis,O_TELA,O_CI]
SETCOLOR(drvtittel)
vr_memo=NOVAPOSI(@l_s,@c_s,@l_i,@c_i)     // pega posicao atual da tela
CAIXA(mold,l_s,c_s,l_i,c_i)               // monta caixa da tela
i=LEN(sistema[op_sis,O_MENS])/2
@ l_s,c_s-1+(c_i-c_s+1)/2-i SAY " "+MAIUSC(sistema[op_sis,O_MENS])+" "
SETCOLOR(drvcortel)
@ l_s+01,c_s+1 SAY " N£mero de O.P. :"
@ l_s+02,c_s+1 SAY " Origem:        Lan‡ado em           por"
@ l_s+03,c_s+1 SAY "ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ"
@ l_s+04,c_s+1 SAY " Conta:"
@ l_s+05,c_s+1 SAY " Hist¢rico:"
@ l_s+06,c_s+1 SAY " Tipo.....:     Valor:              Vencto:"
@ l_s+07,c_s+1 SAY " Documento..:                    N§ Doctos:"
@ l_s+08,c_s+1 SAY " Complemento:"
@ l_s+09,c_s+1 SAY "ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ"
@ l_s+10,c_s+1 SAY " Fechamento.:"
@ l_s+11,c_s+1 SAY " Transferido:"
RETU

PROC ORD_gets     // mostra variaveis do arquivo ORDPGRC
LOCAL getlist := {}, ord_, chv_, ar_get1:=ALIAS(), op_ant := op_menu
ORD_TELA()
SETCOLOR(drvcortel+","+drvcorget+",,,"+corcampo)
PTAB(HISTORICO,'HISTORIC',1)
@ l_s+01 ,c_s+19 GET  numop;
                 PICT sistema[op_sis,O_CAMPO,01,O_MASC]

@ l_s+02 ,c_s+10 GET  origem;
                 PICT sistema[op_sis,O_CAMPO,02,O_MASC]

@ l_s+02 ,c_s+28 GET  lancto_;
                 PICT sistema[op_sis,O_CAMPO,03,O_MASC]

@ l_s+02 ,c_s+42 GET  por

@ l_s+04 ,c_s+09 GET  numconta;
                 PICT sistema[op_sis,O_CAMPO,05,O_MASC]

@ l_s+05 ,c_s+13 GET  historico;
                 PICT sistema[op_sis,O_CAMPO,06,O_MASC]
                 CRIT(sistema[op_sis,O_CAMPO,06,O_CRIT],,"1")

@ l_s+06 ,c_s+13 GET  debcred;
                 PICT sistema[op_sis,O_CAMPO,07,O_MASC]

@ l_s+06 ,c_s+24 GET  valortotal;
                 PICT sistema[op_sis,O_CAMPO,08,O_MASC]

@ l_s+06 ,c_s+45 GET  vencto_;
                 PICT sistema[op_sis,O_CAMPO,09,O_MASC]

@ l_s+07 ,c_s+15 GET  documento;
                 PICT sistema[op_sis,O_CAMPO,10,O_MASC]

@ l_s+07 ,c_s+45 GET  nrdoctos;
                 PICT sistema[op_sis,O_CAMPO,11,O_MASC]

@ l_s+08 ,c_s+15 GET  complement;
                 PICT sistema[op_sis,O_CAMPO,12,O_MASC]

@ l_s+10 ,c_s+15 GET  fechto_;
                 PICT sistema[op_sis,O_CAMPO,13,O_MASC]

@ l_s+10 ,c_s+26 GET  fechpor

@ l_s+11 ,c_s+15 GET  autoriz_;
		 PICT sistema[op_sis,O_CAMPO,15,O_MASC]

@ l_s+11 ,c_s+26 GET  autorpor

@ l_s+11 ,c_s+35 GET  numos;
                 PICT sistema[op_sis,O_CAMPO,17,O_MASC]

CLEAR GETS
RETU

PROC ORD_get1(tp_mov)     // capta variaveis do arquivo ORDPGRC
LOCAL getlist := {}, ord_, chv_, ar_get1:=ALIAS(), op_ant := op_menu
PRIV  blk_ordpgrc:=.t.

IF tp_mov=INCLUI
 DO WHILE .t.
  rola_t=.f.
  SET KEY K_ALT_F8 TO ROLATELA
  SETCOLOR(drvcortel+","+drvcorget+",,,"+corcampo)
  @ l_s+02 ,c_s+28 GET lancto_;
                   PICT sistema[op_sis,O_CAMPO,03,O_MASC]
  @ l_s+02 ,c_s+42 GET por
  @ l_s+10 ,c_s+15 GET fechto_;
                   PICT sistema[op_sis,O_CAMPO,13,O_MASC]
  @ l_s+10 ,c_s+24 GET fechpor
  @ l_s+11 ,c_s+15 GET autoriz_;
                   PICT sistema[op_sis,O_CAMPO,15,O_MASC]
  @ l_s+11 ,c_s+24 GET autorpor
  @ l_s+11 ,c_s+35 GET numos;
                   PICT sistema[op_sis,O_CAMPO,17,O_MASC]
  CLEA GETS
  @ l_s+02 ,c_s+10 GET  origem;
                   PICT sistema[op_sis,O_CAMPO,02,O_MASC]
                   DEFINICAO 2

  @ l_s+04 ,c_s+09 GET  numconta;
                   PICT sistema[op_sis,O_CAMPO,05,O_MASC]
                   DEFINICAO 5

  @ l_s+05 ,c_s+13 GET  historico;
                   PICT sistema[op_sis,O_CAMPO,06,O_MASC]
                   DEFINICAO 6
                   MOSTRA sistema[op_sis,O_FORMULA,1]

  @ l_s+06 ,c_s+13 GET  debcred;
                   PICT sistema[op_sis,O_CAMPO,07,O_MASC]
                   DEFINICAO 7

  @ l_s+06 ,c_s+24 GET  valortotal;
                   PICT sistema[op_sis,O_CAMPO,08,O_MASC]
                   DEFINICAO 8

  @ l_s+06 ,c_s+45 GET  vencto_;
                   PICT sistema[op_sis,O_CAMPO,09,O_MASC]
                   DEFINICAO 9

  @ l_s+07 ,c_s+15 GET  documento;
                   PICT sistema[op_sis,O_CAMPO,10,O_MASC]
                   DEFINICAO 10

  @ l_s+07 ,c_s+45 GET  nrdoctos;
                   PICT sistema[op_sis,O_CAMPO,11,O_MASC]
                   DEFINICAO 11

  @ l_s+08 ,c_s+15 GET  complement;
                   PICT sistema[op_sis,O_CAMPO,12,O_MASC]
                   DEFINICAO 12

  READ
  SET KEY K_ALT_F8 TO
  IF rola_t
   ROLATELA()
   LOOP
  ENDI
  IF LASTKEY()!=K_ESC .AND. drvincl .AND. op_menu=INCLUSAO
   IF !CONFINCL()
    LOOP
   ENDI
  ENDI
  EXIT
 ENDD
ENDI
PTAB(HISTORICO,'HISTORIC',1)
IF tp_mov=EXCLUI .OR. tp_mov=FORM_INVERSA
 IF !EMPTY(codlan) .AND. tp_mov=EXCLUI
  ALERTA()       // existe registro validado aqui!
  msg="Registro de Lan‡amento"
  DBOX(msg,,,,,"IMPOSS¡VEL EXCLUIR!")
 ELSE
  TIRA_LANC("HISTORIC","ORD-"+intlan,.f.)
  IF !EMPTY(ALIAS())
   DELE
  ENDI
 ENDI
ELSEIF tp_mov=INCLUI .OR. tp_mov=RECUPERA .OR. tp_mov=FORM_DIRETA
 IF (op_menu=INCLUSAO .AND. LASTKEY()!=K_ESC) .OR. op_menu!=INCLUSAO
  IF !EMPTY(codlan) .AND. tp_mov=RECUPERA
   ALERTA()      // existe registro validado aqui!
   msg="Registro de Lan‡amento"
   DBOX(msg,,,,,"IMPOSS¡VEL RECUPERAR!")
  ELSE
   IF 1=3 // For‡a INTLAN
    ord_=LEN(sistema[EVAL(qualsis,"HISTORIC"),O_CHAVE])
    IF TYPE("M->intlan")="C" .AND. EMPTY(intlan)
     chv_="ORD-"+M->intlan+"-001"
    ELSE
     chv_="ORD-"+intlan+"-001"
    ENDI
    PTAB(chv_,"HISTORIC",ord_)
    FAZ_LANC("HISTORIC",chv_,.t.)

    #ifdef COM_REDE
     HISTORIC->(DBUNLOCK())                        // libera o registro
    #endi

   ENDI
   IF op_menu!=INCLUSAO
    RECA
   ENDI
  ENDI
 ENDI
ENDI
RETU

* \\ Final de ORDPGRC.PRG
procedure processa
#include "SIXNSX.CH"
#define RDDNAME "SIXNSX"
#define MEMOEXT ".SMT"
set date brit
set cent on
? [Processando dados do BP-Net]
?
? [Processando Associados.IV]
use gruiv
zap
appe from asssmt
repl codigo with [020]+strzero(VAL(codigo),6), grupo with [IV] all

? [Processando Cobrancas.IV]
use taxiv
zap
appe from receber for str(situacao,1)$[015]
repl codigo with [020]+strzero(VAL(codigo),6), circ with right([000]+circ,3) all

? [Processando Inscritos.IV]
use insiv
zap
appe from inssmt
repl codigo with [020]+strzero(VAL(codigo),6) all

? [Processando Associados.PL]
use grupl
zap
appe from grusmt
repl codigo with [010]+codigo all
? [Processando Cobrancas.PL]
use taxpl
zap
appe from c:\vip4\arquivos\taxas
repl codigo with [010]+codigo, cobranca with codigo+tipo+circ all
? [Processando Inscritos.PL]
use inspl
zap
appe from c:\vip4\arquivos\inscrits
repl codigo with [010]+codigo all


GAS-Pro v3.0
011021015062001003013001014000176001
 Ano.....:
 Numero..:
 Confirme:
[Ÿ]
[Ÿ]
 3 
 0 
Outros Recebimentos
Outros Recebimentos







056







 0 
 0 
-1 
-1 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
rano
C
E
99
 2 
 2 
 1 
 12 
 0 
Ano

!EMPT(rano)
Necess rio informar ANO
IIF(PTAB(UPPER(RIGHT(M->ide_maq,4))+[OBX],[IMPPAR],1),LEFT(IMPPAR->docto,2),[ ])
Ano da emiss„o

 0 
 0 


rnumero
C
E
999999
 6 
 6 
 2 
 12 
 0 
Numero

PTAB(rano+rnumero,'OBXEC',1)
Necess rio informar NUMERO|Tecle F8 para buscar em tabela
IIF(PTAB(UPPER(RIGHT(M->ide_maq,4))+[OBX],[IMPPAR],1),SUBSTR(IMPPAR->docto,3,6),[ ])
N£mero do Recibo a emitir
VDBF(6,4,20,77,'OBXEC',{'ano','numero','codigo','ref','valorpg','emitido_'},1,'numero',[])
 0 
 0 


confirme
C
E
!
 1 
 1 
 3 
 12 
 0 
Confirme

confirme='S'.AND.V02301F9()
CONFIRME n„o aceit vel|Digite S para confirmar|ou|Tecle ESC para cancelar

Digite S para confirmar|ou|tecle ESC para cancelar

 0 
 0 


 0 
 0 
 0 
 0 
 0 
€	 DCI01F9À–Ý  DCI01F9CODEDCI02F9CODEC_ETEXTENDCODE	_SYMSTARTSYMSTARTSYMBOLSSYMBOLS_SYMENDSYMENDNULLBEGDATA_DATADATA_SYMPBDATA_SYMPDATA_SYMPEDATA_CONSTCONST_MSGMSG_BEGBSSBEGBSS_BSSBSS_ENDBSSENDBSSDGROUP›˜ @k¬˜ @r¤˜ H  ˜ h  	ç˜ `p
z˜ h  ß˜ h  Û˜ H  ÷˜ H  ó˜ H ç˜ H  ë˜ H  ç˜ (  procedure tax_01f9
/*
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
 \ Empresa.: PresServ Inform tica-Limeira (019)452.6623
 \ Programa: TAX_01F9.PRG
 \ Data....: 22-11-96
 \ Sistema.: Administradora - RECEP€„O
 \ Funcao..: F¢rmula (Status) a mostrar na tela de TAXAS
 \ Analista: Ademilson Pedro Bom
 \ Criacao.: Programado manualmente pelo analista 
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/
#include "adrbig.ch"    // inicializa constantes manifestas

/*
   -------------------------------------------------------------------
   Se abrir outros arquivos salve situacao anterior e restaure ao sair
   como no exemplo abaixo:
     LOCAL reg_dbf:=POINTER_DBF()
     ...        ...        ...        ...
     POINTER_DBF(reg_dbf)
     RETU
   -------------------------------------------------------------------
*/
RETU       // <- deve retornar um valor qualquer

* \\ Final de TAX_01F9.PRG
GAS-Pro v3.0

[Ÿ]
 0 
CLASSES
Processar



001









-1 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 1 
IMPPAR
docto
M->docto

PTAB(PADR(SUBSTR(M->ide_maq,2),4)+M->tipdoc,[IMPPAR],1)


 0 
 1 
IMPPAR
1
 3 
!PTAB(PADR(SUBSTR(M->ide_maq,2),4)+M->tipdoc,[IMPPAR],1)

 0 



idmaq
C
PADR(SUBSTR(M->ide_maq,2),4)


base
C
M->tipdoc


docto
C
M->docto


 0 
procedure about
/*
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
 \ Empresa.: PresServ Inform tica-Limeira (019)452.6623
 \ Programa: ABOUT.PRG
 \ Data....: 09-09-96
 \ Sistema.: Controle de Convˆnios
 \ Funcao..: Rotina avulsa (Sobre...)
 \ Analista: Ademilson Pedro Bom
 \ Criacao.: Programado manualmente pelo analistad
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/

#include "adrbig.ch"    // inicializa constantes manifestas

/*
   Nivelop = Nivel de acesso do usuario (1=operacao, 2=manutencao e
   3=gerencia)
*/
IF nivelop < 1          // se usuario nao tem
 ALERTA()               // permissao, avisa
 DBOX(msg_auto,,,3)     // e retorna
 RETU
ENDI
PARA  lin_menu, col_menu
PRIV  tem_borda:=.f., op_menu:=VAR_COMPL, l_s:=3, c_s:=14, l_i:=21, c_i:=60, tela_fundo:=SAVESCREEN(0,0,MAXROW(),79)
nucop=1
SETCOLOR(drvtittel)
vr_memo=NOVAPOSI(@l_s,@c_s,@l_i,@c_i)     // pega posicao atual da tela
CAIXA(SPAC(8),l_s+1,c_s+1,l_i,c_i-1)      // limpa area da tela/sombra
SETCOLOR(drvcortel)
@ l_s+02,c_s+1 SAY "         Sistema Funer rio - Thumba"
@ l_s+03,c_s+1 SAY "ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ"
@ l_s+04,c_s+1 SAY "    Gerenciador de Administradora RECEP€AO"
@ l_s+05,c_s+1 SAY "    ADRBIG.EXE - Vers„o VIP 5.1 - Fev/2004"
@ l_s+07,c_s+1 SAY "        Um sistema de propriedade de,"
@ l_s+08,c_s+1 SAY "         desenvolvido e mantido por:"
@ l_s+10,c_s+1 SAY "            PresServ Inform tica"
@ l_s+12,c_s+1 SAY "       (0xx19) 3452.6623 - Limeira, S.P."
@ l_s+14,c_s+1 SAY "ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ"
@ l_s+18,c_s+1 SAY "Operador: " + M->usuario
INKEY(25)
RETU

* \\ Final de ABOUT.PRG
<?
$local = "localhost";
$login = "root";
$senha = "Arroto";
$dbtype = "mysql";
?>
GAS-Pro v4.0
018004024078001003008001021001176001
 Inscr:                                            (                   )
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 Nome:                                     Nasc.:
 Est.Civil.:     Sexo.....:          T.Carˆncia.:
 Vivo/Falec:     Falecto..:            Tipo:      N§ Processo:
[Ÿ]
Inclus„o~~26006
Manuten‡„o~~27007
Consulta~~28008
[Ÿ]
 16 
 2 
Codigo

 1 
 2 
[Ÿ]
Nome

 5 
[Ÿ]
Inscritos
Inscritos







005




































 0 
 0 
-1 
-1 
 0 
-1 
-1 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
codigo
C
I
@!
 9 
 9 
 0 
 0 
 0 
Codigo






-1 
 0 


grau
C
E
9
 1 
 1 
 1 
 9 
 0 
Inscr.
MTAB(M->TBTIPGRAU,[INSCR.])
grau $ [12345678]
INSCR. n„o aceit vel
IIF(M->pgrau<[7],SUBSTR([234567],VAL(M->pgrau),1),M->pgrau)
Informe o grau de liga‡„o deste com o|titular do contrato|ou|tecle F8 para consulta em tabela
MTAB(M->TBTIPGRAU,[INSCR.])
 0 
 0 


seq
N
E
99
 2 
 2 
 1 
 10 
 0 
Seq
grau>[6]
seq>0
SEQ n„o aceit vel
INS_01F9()


 0 
 0 


ehtitular
C
I
!
 1 
 1 
 0 
 0 
 0 
Titular?






 0 
 0 


nome
C
E
@!
 35 
 35 
 3 
 8 
 0 
Nome

!EMPT(nome)
Necess rio informar NOME
IIF(ehtitular=[S],GRUPOS->nome,[ ])


 0 
 0 


nascto_
D
E
@D
 8 
 10 
 3 
 51 
 0 
Nascto

INS_02F9()
NASCTO n„o aceit vel
IIF(ehtitular=[S],GRUPOS->nascto_,ctod('  /  /  '))
Informe a Data de Nascimento deste Inscrito

 0 
 0 


estcivil
C
E
 
 2 
 2 
 4 
 14 
 0 
Est Civil
MTAB(tbestciv,[EST CIVIL])
(ESTCIVIL$tbestciv)
Necess rio informar ESTADO CIVIL|ou tecle F8
IIF(grau<[7],[CA],[SO])
Digite o Estado Civil do Falecido
MTAB(tbestciv,[EST CIVIL])
 0 
 0 


interdito
C
I
!
 1 
 1 
 0 
 0 
 0 
Interdito






 0 
 0 


sexo
C
E
!
 1 
 1 
 4 
 33 
 0 
Sexo

 

IIF(grau$[124],[M],IIF(grau$[356],[F],[ ]))
Digite M ou F |(Masculino ou Feminino)

 0 
 0 


tcarencia
D
E
@D
 8 
 10 
 4 
 51 
 0 
T.Carˆncia

 

IIF(GRUPOS->tcarencia>DATE(),GRUPOS->tcarencia,CTOD('  /  /  '))


 0 
 0 


lancto_
D
I
@D
 8 
 10 
 0 
 0 
 0 
Lan‡to.






 0 
 0 


vivofalec
C
E
!
 1 
 1 
 5 
 14 
 0 
V/F

vivofalec$[VF]
Necess rio informar VIVOFALEC
[V]
Vivo ou Falecido
MTAB([Vivo|Falecido],[V/F])
 0 
 0 


falecto_
D
E
@D
 8 
 10 
 5 
 29 
 0 
Falecto.
vivofalec==[F]
 


Entre com a data de falecimento

 0 
 0 


tipo
C
E
!!!
 3 
 3 
 5 
 46 
 0 
Tipo
vivofalec==[F]
EMPTY(tipo).OR.UPPER(tipo) $ [FUN|AUX]
Necess rio informar TIPO

Com Direitos (Funeral) ou com Auxilio.
MTAB([Funeral|Auxilio],[TIPO])
 0 
 0 


procnr
C
E
@R 99999/99
 7 
 8 
 5 
 64 
 0 
N§Processo
vivofalec==[F]
 


Informe o n£mero do processo

 0 
 0 


por
C
I
 
 10 
 10 
 0 
 0 
 0 
Por






 0 
 0 


 4 
graupart
SUBSTR([TitPaiMaeSgoSgaEspFilDep],(VAL(grau)-1)*3+1,3)

 1 
 13 
 3 

Lan‡to.
lancto_
@D
 1 
 53 
 8 

Por
por

 1 
 62 
 10 

Idade
IIF(!EMPT(nascto_),LEFT(DLAPSO(DATE(),nascto_),12),[            ])

 3 
 62 
 12 

 5 
INSCRITS
lancto_
date()
date()



GRUPOS
titular
grau+STRZERO(seq,2)
[   ]
ehtitular=[S]


GRUPOS
particv
GRUPOS->particv + 1
GRUPOS->particv - 1
vivofalec=[V]


GRUPOS
particf
GRUPOS->particf + 1
GRUPOS->particf - 1
vivofalec=[F]


GRUPOS
nrdepend
GRUPOS->nrdepend + 1
GRUPOS->nrdepend - 1
grau=[8]


 0 
 0 
 0 
BLINKER INCREMENTAL OFF
BLINKER OVERLAY UMB ON
BLINKER OVERLAY PAGEFRAME ON
BLINKER CACHE EMS 50%
BLINKER CACHE XMS 50%
BLINKER OVE OPS 60
BLINKER EXECUTABLE CLIPPER F200
BLINKER MESSAGE NOBLINK


MAP S,A
OUTPUT adr_adap
STACK 10240


FI ADr_adap
fi sixuk
fi sixnsx
fi sixtools
LIB GASPRO52

FI ADR_ATRI
FI ADR_ATR1
FI ADR_ATR2
FI ADR_ESTR

@CL520MID.LNK
@SIX3.LNK

/*
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
 \ Empresa.: Ind£stria de Urnas Bignotto Ltda
 \ Programa: CON_R001.PRG
 \ Data....: 15-05-97
 \ Sistema.: Controle de Convˆnios
 \ Funcao..: Emiss„o Guias 1¦ Parte
 \ Analista: Ademilson Pedro Bom
 \ Criacao.: GAS-Pro v3.0
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/

#include "adrbig.ch"    // inicializa constantes manifestas

LOCAL dele_atu, getlist:={}, so_um_reg, sit_dbf:=POINTER_DBF()
PARA  lin_menu, col_menu, imp_reg
PRIV  tem_borda:=.t., op_menu:=VAR_COMPL, l_s:=11, c_s:=20, l_i:=14, c_i:=61, tela_fundo:=SAVESCREEN(0,0,MAXROW(),79)
nucop=1
so_um_reg=(PCOU()>2)
IF !so_um_reg                             // vai receber a variaveis?
 SETCOLOR(drvtittel)
 vr_memo=NOVAPOSI(@l_s,@c_s,@l_i,@c_i)    // pega posicao atual da tela
 CAIXA(mold,l_s,c_s,l_i,c_i)              // monta caixa da tela
 @ l_s,c_s+12 SAY " EMISSŽO DE GUIAS "
 SETCOLOR(drvcortel)
 @ l_s+01,c_s+1 SAY " N£mero:"
ENDI
gnumero=SPAC(8)                                    // N£mero
DO WHILE .t.
 rola_t=.f.
 cod_sos=56
 IF !so_um_reg
  SET KEY K_ALT_F8 TO ROLATELA
  SETCOLOR(drvcortel+","+drvcorget+",,,"+corcampo)
  @ l_s+01 ,c_s+10 GET  gnumero;
		   PICT "@R 99-999999";
		   VALI CRIT("PTAB(gnumero,'GUIAS',1).AND.V00101F9()~N£MERO n„o existe na tabela")
		   DEFAULT "IIF(PTAB(PADR(SUBSTR(M->ide_maq,2),4)+[GUI],[IMPPAR],1),ALLTRIM(IMPPAR->docto),[])"
		   AJUDA "Emitir a guia de n£mero?"
		   CMDF8 "VDBF(6,8,20,77,'GUIAS',{'numero','contrato','nome'},1,'numero')"
		   MOSTRA {"LEFT(TRAN(GUIAS->nome,[@!]),35)", 2 , 5 }

  READ
  SET KEY K_ALT_F8 TO
  IF rola_t
   ROLATELA(.f.)
   LOOP
  ENDI
  IF LASTKEY()=K_ESC                               // se quer cancelar
   RETU                                            // retorna
  ENDI
 ENDI

 #ifdef COM_REDE
  IF !USEARQ("GUIAS",.f.,10,1)                     // se falhou a abertura do arq
   RETU                                            // volta ao menu anterior
  ENDI
 #else
  USEARQ("GUIAS")                                  // abre o dbf e seus indices
 #endi

 PTAB(medico,"MEDICOS",1,.t.)                      // abre arquivo p/ o relacionamento
 PTAB(contrato,"GRUPOS",1,.t.)                      // abre arquivo p/ o relacionamento
 PTAB(GRUPOS->tipcont,"CLASSES",1,.t.)                      // abre arquivo p/ o relacionamento
 SET RELA TO medico INTO MEDICOS                 // relacionamento dos arquivos

 titrel:=criterio:=cpord := ""                     // inicializa variaveis
 titrel:=chv_rela:=chv_1:=chv_2 := ""
 tps:=op_x:=ccop := 1
 arq_=drvporta                                     // porta de saida configurada
 IF !so_um_reg
  IF !opcoes_rel(lin_menu,col_menu,7,11)           // nao quis configurar...
   CLOS ALL                                        // fecha arquivos e
   LOOP                                            // volta ao menu
  ENDI

 #ifdef COM_REDE

  ELSE

   tps=lin_menu

 #endi

 ENDI
 IF tps=2                                          // se vai para arquivo/video
  arq_=ARQGER()                                    // entao pega nome do arquivo
  IF EMPTY(arq_)                                   // se cancelou ou nao informou
   LOOP                                            // retorna
  ENDI
 ELSE
  arq_=drvporta                                    // porta de saida configurada
 ENDI
 SET PRINTER TO (arq_)                             // redireciona saida
 EXIT
ENDD
IF !EMPTY(drvtapg)                                 // existe configuracao de tam pag?
 op_=AT("NNN",drvtapg)                             // se o codigo que altera
 IF op_=0                                          // o tamanho da pagina
  msg="Configura‡„o do tamanho da p gina!"         // foi informado errado
  DBOX(msg,,,,,"ERRO!")                            // avisa
  CLOSE ALL                                        // fecha todos arquivos abertos
  RETU                                             // e cai fora...
 ENDI                                              // codigo para setar/resetar tam pag
 lpp_024=LEFT(drvtapg,op_-1)+"033"+SUBS(drvtapg,op_+3)
 lpp_066=LEFT(drvtapg,op_-1)+"066"+SUBS(drvtapg,op_+3)
ELSE
 lpp_024:=lpp_066 :=""                             // nao ira mudara o tamanho da pag
ENDI
DBOX("[ESC] Interrompe",15,,,NAO_APAGA)
dele_atu:=SET(_SET_DELETED,.t.)                    // os excluidos nao servem...
SET DEVI TO PRIN                                   // inicia a impressao
maxli=17                                           // maximo de linhas no relatorio
IMPCTL(lpp_024)                                    // seta pagina com 24 linhas
SET MARG TO 1                                      // ajusta a margem esquerda
IF tps=2
 IMPCTL("' '+CHR(8)")
ENDI
BEGIN SEQUENCE
 DO WHIL ccop<=nucop				// imprime qde copias pedida
  pg_=1; cl=999
  IF so_um_reg
   GO imp_reg
  ELSE
   INI_ARQ()                                       // acha 1o. reg valido do arquivo
   IF PTAB(PADR(SUBSTR(M->ide_maq,2),4)+[GUI],[IMPPAR],1)
    SEEK ALLTRIM(IMPPAR->docto)
   ENDI
  ENDI
  ccop++                                           // incrementa contador de copias
  ult_imp=0                                        // ultimo reg impresso
  DO WHIL !EOF().AND.(!so_um_reg.OR.imp_reg=RECN())
   #ifdef COM_TUTOR
    IF IN_KEY()=K_ESC                              // se quer cancelar
   #else
    IF INKEY()=K_ESC                               // se quer cancelar
   #endi
    IF canc()                                      // pede confirmacao
     BREAK                                         // confirmou...
    ENDI
   ENDI
   IF (PTAB(PADR(SUBSTR(M->ide_maq,2),4)+[GUI],[IMPPAR],1).AND.numero=LEFT(IMPPAR->docto,7)) .OR. so_um_reg// se atender a condicao...
    PTAB(contrato,"GRUPOS",1,.t.)                      // abre arquivo p/ o relacionamento
    PTAB(GRUPOS->tipcont,"CLASSES",1,.t.)                      // abre arquivo p/ o relacionamento

    REL_CAB(1,.t.)                                 // soma cl/imprime cabecalho
    @ cl,000 SAY "GUIA DE IDENTIFICACAO  N§:"
    @ cl,027 SAY numero   // N£mero
//    @ cl,043 SAY IIF(guiapara='C',[Consulta],IIF(guiapara='E',[Exame],IIF(guiapara='I',[Interna‡„o],[     ])))// Guia Para
    IF M->combarra=[S]
     CODBARRAS({{numero+GDV1(numero),4,10,64}},10,6)
    ENDI
    ult_imp=RECNO()                                // ultimo reg impresso
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY "Para:"
    @ cl,008 SAY TRAN(MEDICOS->oldespec,"@!")    // Especialidade
    IF M->combarra=[S]
     CODBARRAS({{numero+GDV1(numero),4,10,64}},10,6)
    ENDI
    REL_CAB(2)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY "Credenciado ...........:"
    @ cl,025 SAY ALLTRIM(MEDICOS->nome)+[ (]+ALLTRIM(medico)+[) ]+;// M‚dico
		 [ tel: ]+ ALLTRIM(MEDICOS->fonesdiv)
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    IMPAC("Endere‡o...............:",cl,000)
    @ cl,025 SAY MEDICOS->endereco// Endere‡o
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY "Data...................:"
    @ cl,025 SAY TRAN(data,"@D")               // Emiss„o
    IMPAC("(V lido at‚ 30 dias)",cl,036)
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    IMPAC("Benefici rio principal.:",cl,000)
    @ cl,025 SAY TRAN([ (]+ALLTRIM(GRUPOS->nome)+[ / ]+ALLTRIM(contrato)+[)],"@!")+;// Titular
	 [ ] +&drvpcom+ALLTRIM(CLASSES->descricao)+&drvtcom
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY "Benefici rio..........:"
    IMPCTL(drvpenf)
    @ cl,025 SAY TRAN(nome,"@!")                   // Nome
    IMPCTL(drvtenf)
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY REPL("-",60)
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    SKIP                                           // pega proximo registro
    cl=999                                         // forca salto de pagina
   ELSE                                            // se nao atende condicao
    SKIP                                           // pega proximo registro
   ENDI
   exit
  ENDD
  REL_RDP(.t.)                                     // imprime rodape' do relatorio
 ENDD ccop
 EJEC                                              // salta pagina
END SEQUENCE
SET MARG TO                                        // coloca margem esquerda = 0
IMPCTL(lpp_066)                                    // seta pagina com 66 linhas
SET PRINTER TO (drvporta)                          // fecha arquivo gerado (se houver)
SET DEVI TO SCRE                                   // direciona saida p/ video
IF tps=2                                           // se vai para arquivo/video
 BROWSE_REL(arq_,2,3,MAXROW()-2,78)
ENDI                                               // mostra o arquivo gravado
GRELA(7)                                           // grava variacao do relatorio
SELE GUIAS                                         // salta pagina
SET RELA TO                                        // retira os relacionamentos
SET(_SET_DELETED,dele_atu)                         // os excluidos serao vistos
IF so_um_reg
 POINTER_DBF(sit_dbf)
ENDI
RETU

STATIC PROC REL_RDP(volta_reg)                     // rodape'
LOCAL reg_atual:=RECNO()
IF volta_reg
 GO ult_imp                                        // ajusta reg p/ imp de campos no rodape'
ENDI
@ 16,000 SAY "" //chr(15)                               // comprime
IMPCTL(drvpcom)
@ 16,002 SAY [IMPORTANTE:- Esta guia tem a finalidade principal de identificar ]// Mensagem 1
@ 17,002 SAY [o benefici rio em dia, ou seja, sem pendencias.]// Mensagem 2
@ 18,002 SAY [ - Esta guia s¢ ter  validade com o carimbo e assinatura do respons vel pela emiss„o.]// Mensagem 4
@ 19,002 SAY [ ] //A BOM PASTOR n„o se responsabiliza por procedimentos medicos e outros, visto ser de]
@ 20,002 SAY [ ] //  livre escolha do associado.]
@ 21,000 SAY "" //chr(18)                               // normal
IMPCTL(drvtcom)
@ 22,060 SAY [FR-OPE-0017]
@ 23,001 SAY replicate('- ',36)                    // traco
IF volta_reg
 GO reg_atual                                      // retorna reg a posicao original
ENDI
RETU

STATIC PROC REL_CAB(qt, volta_reg)                 // cabecalho do relatorio
volta_reg=IF(volta_reg=NIL,.f.,volta_reg)
IF qt>0                                            // se parametro maior que 0
 cl=cl+qt                                          // soma no contador de linhas
ENDI
IF cl>maxli .OR. qt=0                              // quebra de pagina
 IF pg_>1
  REL_RDP(volta_reg)                               // imprime rodape' do relatorio
 ENDI
 IMPCTL(drvpenf)
 IMPEXP(0,000,LEFT(M->setup1,38),76)               // Setup1
 IMPCTL(drvtenf)
// @ 1,000 SAY M->defconv                            // Defconv
 @ 2,000 SAY M->setup2                             // setup2
 @ 3,000 SAY M->setup3                             // Setup3
 @ 4,000 SAY REPL("-",60)
 cl=qt+4 ; pg_++
ENDI
RETU

* \\ Final de CON_R001.PRG
FUNC R001GF9
RETURN numero
GAS-Pro v4.0
002003024079001045013043005000176001
[Ÿ]
 17 
AFUNER
Capa de Processo


PTAB(PADR(SUBSTR(M->ide_maq,2),4)+[AFU],[IMPPAR],1).and.processo+proc2+filial+categ=ALLTRIM(IMPPAR->docto)
011

























 0 
 1 










 0 
 1 
 0 
 66 
 0 
 6 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
-1 
-1 
-1 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
N£mero Processo
processo+proc2
@R 99999/99
 8 
C
 9 
 61 


          










Declarante
nomedec
@!
 35 
C
 31 
 13 


          










endereco (declarante)
ALLTRIM(ruadec)

 35 
C
 33 
 13 


          










fone declarante
fonedec

 14 
C
 33 
 57 


          










Nome do falecido
falecido
@!
 35 
C
 21 
 12 


          










endereco (falecido)
ALLTRIM(ruares)+[ ]+ALLTRIM(baires)+'-'+ALLTRIM(munres)

 55 
C
 23 
 12 


          










Data falcto.
falecto_
@D
 8 
D
 25 
 20 


          










Hora Falcto.
horafal
99:99
 5 
C
 25 
 57 


          










Rua Falecimento
ALLTRIM(ruafal)
@!
 30 
C
 27 
 20 


          










Motorista respons vel
FNCS->nome

 35 
C
 48 
 17 


          










CONTRATO
contrato
999999
 6 
C
 48 
 55 


          










GRUPO
IIF(CLASSES->prior=[S],M->mgrupvip,GRUPOS->grupo)

 2 
C
 48 
 67 


          










Cemit‚rio Sepultamento
cemitsep
@!
 30 
C
 61 
 16 


          










hora sepultamento
horasepult

 5 
C
 63 
 22 


          










data sepultamento
DTOC(sepult_)

 8 
C
 63 
 59 
!EMPT(sepult_)

          










tipo de plano
CLASSES->descricao

 35 
C
 44 
 13 


          










Categoria
IIF(categ=[PD],[Plano c/Difer. ],IIF(categ=[PL],[Atend.Plano],[Auxilio Funeral  ]))

 18 
C
 45 
 26 


          










 9 
Nome da empresa
nemp

 0 
 0 
 32 

T¡tulo aplica‡„o
nsis

 0 
 0 
 25 

Data do sistema
DTOC(DATE())

 0 
 0 
 8 

Nome do mˆs
NMES(DATE())

 0 
 0 
 8 

Dia da semana
NSEM(DATE())

 0 
 0 
 7 

N£mero da p gina
TRAN(pg_,'9999')

 0 
 0 
 4 

C¢digo relat¢rio
"ADM_R026"

 0 
 0 
 8 

T¡tulo a definir
titrel

 0 
 0 
 30 

Hora da emiss„o
hora_rel_

 0 
 0 
 5 

 0 
 0 
 0 
 3 
GRUPOS
 1 
contrato



FNCS
 1 
funcresp



CLASSES
 1 
GRUPOS->tipcont



€
 CIRCULAR–A CIRCULARCODECIR_INCLCODECIR_TELACODECIR_GETSCODECIR_GET1CODECPR_INCLCODECPR_TELACODECPR_GETSCODECPR_GET1CODEC_ETEXTENDCODE	_SYMSTARTSYMSTARTSYMBOLSSYMBOLS_SYMENDSYMENDNULLBEGDATA_DATADATA_SYMPBDATA_SYMPDATA_SYMPEDATA_CONSTCONST_MSGMSG_BEGBSSBEGBSS_BSSBSS_ENDBSSENDBSSDGROUP˜ @ö#˜ @r˜ @ªg˜ @‘	{˜ @â
%˜ @ 
Ý˜ @–k˜ @w†˜ @_˜˜ H  ï˜ h  Ë˜ `°˜ h  /*
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
 \ Empresa.: Ind£stria de Urnas Bignotto Ltda
 \ Programa: ADM_R018.PRG
 \ Data....: 21-10-96
 \ Sistema.: Administradora - RECEP€„O
 \ Funcao..: Recibos c/Falecidos
 \ Analista: Ademilson Pedro Bom
 \ Criacao.: GAS-Pro v3.0 
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/

#include "adrbig.ch"    // inicializa constantes manifestas

LOCAL dele_atu, so_um_reg, sit_dbf
PARA  lin_menu, col_menu, imp_reg
so_um_reg=(PCOU()>2)
IF so_um_reg
 sit_dbf=POINTER_DBF()
ENDI
nucop=1

#ifdef COM_REDE
 IF !USEARQ("BXREC",.f.,10,1)                      // se falhou a abertura do arq
  RETU                                             // volta ao menu anterior
 ENDI
#else
 USEARQ("BXREC")                                   // abre o dbf e seus indices
#endi

PTAB(codigo,"GRUPOS",3,.t.)                        // abre arquivo p/ o relacionamento
PTAB(codigo+circ,"TAXAS",1,.t.)
PTAB(GRUPOS->grupo,"ARQGRUP",1,.t.)
PTAB(GRUPOS->cobrador,"COBRADOR",1,.t.)
PTAB(GRUPOS->grupo+circ,"CIRCULAR",1,.t.)
PTAB(GRUPOS->regiao,"REGIAO",1,.t.)
SET RELA TO codigo INTO GRUPOS,;                   // relacionamento dos arquivos
         TO codigo+circ INTO TAXAS,;
         TO GRUPOS->grupo INTO ARQGRUP,;
         TO GRUPOS->cobrador INTO COBRADOR,;
         TO GRUPOS->grupo+circ INTO CIRCULAR,;
         TO GRUPOS->regiao INTO REGIAO
titrel:=criterio:=cpord := ""                      // inicializa variaveis
titrel:=chv_rela:=chv_1:=chv_2 := ""
tps:=op_x:=ccop := 1
arq_=drvporta                                      // porta de saida configurada
IF !so_um_reg
 IF !opcoes_rel(lin_menu,col_menu,5,11)            // nao quis configurar...
  CLOS ALL                                         // fecha arquivos e
  RETU                                             // volta ao menu
 ENDI

#ifdef COM_REDE

 ELSE

  tps=lin_menu

#endi

ENDI
IF tps=2                                           // se vai para arquivo/video
 arq_=ARQGER()                                     // entao pega nome do arquivo
 IF EMPTY(arq_)                                    // se cancelou ou nao informou
  RETU                                             // retorna
 ENDI
ELSE
 arq_=drvporta                                     // porta de saida configurada
ENDI
SET PRINTER TO (arq_)                              // redireciona saida
criterio_=criterio                                 // salva criterio e ordenacao
cpord_=cpord                                       // definidos se huver
criterio=""

#ifdef COM_REDE
 IF !USEARQ("CPRCIRC",.f.,10,1)                    // se falhou a abertura do arq
  RETU                                             // volta ao menu anterior
 ENDI
#else
 USEARQ("CPRCIRC")                                 // abre o dbf e seus indices
#endi

cpord="grupo+circ+DTOS(dfal)"
INDTMP()
criterio=criterio_                                 // restabelece criterio e
cpord=cpord_                                       // ordenacao definidos
SELE BXREC
IF !EMPTY(drvtapg)                                 // existe configuracao de tam pag?
 op_=AT("NNN",drvtapg)                             // se o codigo que altera
 IF op_=0                                          // o tamanho da pagina
  msg="Configura‡„o do tamanho da p gina!"         // foi informado errado
  DBOX(msg,,,,,"ERRO!")                            // avisa
  CLOSE ALL                                        // fecha todos arquivos abertos
  RETU                                             // e cai fora...
 ENDI                                              // codigo para setar/resetar tam pag
 lpp_048=LEFT(drvtapg,op_-1)+"048"+SUBS(drvtapg,op_+3)
 lpp_066=LEFT(drvtapg,op_-1)+"066"+SUBS(drvtapg,op_+3)
ELSE
 lpp_048:=lpp_066 :=""                             // nao ira mudara o tamanho da pag
ENDI
DBOX("[ESC] Interrompe",15,,,NAO_APAGA)
dele_atu:=SET(_SET_DELETED,.t.)                    // os excluidos nao servem...
SET DEVI TO PRIN                                   // inicia a impressao
maxli=19                                           // maximo de linhas no relatorio
IMPCTL(lpp_048)                                    // seta pagina com 48 linhas
SET MARG TO 1                                      // ajusta a margem esquerda
IF tps=2
 IMPCTL("' '+CHR(8)")
ENDI
BEGIN SEQUENCE
 DO WHIL ccop<=nucop                               // imprime qde copias pedida
  pg_=1; cl=999
  IF so_um_reg
   GO imp_reg
  ELSE
   INI_ARQ()                                       // acha 1o. reg valido do arquivo
  ENDI
  ccop++                                           // incrementa contador de copias
  ult_imp=0                                        // ultimo reg impresso
  DO WHIL !EOF().AND.(!so_um_reg.OR.imp_reg=RECN())
   #ifdef COM_TUTOR
    IF IN_KEY()=K_ESC                              // se quer cancelar
   #else
    IF INKEY()=K_ESC                               // se quer cancelar
   #endi
    IF canc()                                      // pede confirmacao
     BREAK                                         // confirmou...
    ENDI
   ENDI
   IF (ano+numero=M->nrauxrec) .OR. so_um_reg      // se atender a condicao...
    chv016=grupo+circ
    SELE CPRCIRC
    SEEK chv016
    IF FOUND()
     DO WHIL ! EOF() .AND. chv016=LEFT(&(INDEXKEY(0)),LEN(chv016))
      #ifdef COM_TUTOR
       IF IN_KEY()=K_ESC                           // se quer cancelar
      #else
       IF INKEY()=K_ESC                            // se quer cancelar
      #endi
       IF canc()                                   // pede confirmacao
        BREAK                                      // confirmou...
       ENDI
      ENDI
      REL_CAB(1,.t.)                               // soma cl/imprime cabecalho
      IMPCTL(drvpc20)                              // comprime os dados
      @ cl,030 SAY num                             // Contrato
      @ cl,041 SAY processo                        // Processo
      @ cl,054 SAY fal                             // Falecido
      @ cl,091 SAY TRAN(ALLTRIM(ends)+'-'+ALLTRIM(cids),"@!")// Ends
      @ cl,149 SAY TRAN(dfal,"@D")                 // Data
      IMPCTL(drvtc20)                              // retira comprimido
      SKIP                                         // pega proximo registro
     ENDD
    ENDI
    SELE BXREC                                     // volta ao arquivo pai
    ult_imp=RECNO()                                // ultimo reg impresso
    SKIP                                           // pega proximo registro
    cl=999                                         // forca salto de pagina
   ELSE                                            // se nao atende condicao
    SKIP                                           // pega proximo registro
   ENDI
  ENDD
  REL_RDP(.t.)                                     // imprime rodape' do relatorio
 ENDD ccop
 EJEC                                              // salta pagina
END SEQUENCE
SET MARG TO                                        // coloca margem esquerda = 0
IMPCTL(lpp_066)                                    // seta pagina com 66 linhas
SET PRINTER TO (drvporta)                          // fecha arquivo gerado (se houver)
SET DEVI TO SCRE                                   // direciona saida p/ video
IF tps=2                                           // se vai para arquivo/video
 BROWSE_REL(arq_,2,3,MAXROW()-2,78)
ENDI                                               // mostra o arquivo gravado
GRELA(5)                                           // grava variacao do relatorio
SELE BXREC                                         // salta pagina
SET RELA TO                                        // retira os relacionamentos
SET(_SET_DELETED,dele_atu)                         // os excluidos serao vistos
IF so_um_reg
 POINTER_DBF(sit_dbf)
ENDI
RETU

STATIC PROC REL_RDP(volta_reg)                     // rodape'
LOCAL ar_:=ALIAS(), reg_atual
SELE BXREC                                         // volta ao arquivo pai
reg_atual=RECNO()
IF volta_reg
 GO ult_imp                                        // ajusta reg p/ imp de campos no rodape'
ENDI
@ 21,008 SAY CHR(18)+CIRCULAR->menscirc            // Mensagem
@ 25,017 SAY TRAN(valorpg,"@E 999,999.99")         // Valor
@ 25,065 SAY TRAN(valorpg,"@E 999,999.99")         // Valor 2
@ 28,020 SAY TRAN(M->nrauxrec,"########")          // N§ Recibo
@ 28,068 SAY TRAN(M->nrauxrec,"########")          // N§ Recibo 2
@ 31,002 SAY circ+[     ]+DTOC(CIRCULAR->emissao_)+[     ]+STR(GRUPOS->funerais,2)// Circular 1
@ 31,038 SAY circ+[     ]+DTOC(CIRCULAR->emissao_)+[     ]+STR(GRUPOS->funerais,2)// Circular 2
@ 34,002 SAY GRUPOS->grupo +[        ]+codigo+[       ]+GRUPOS->cobrador// Grupo 1
@ 34,038 SAY GRUPOS->grupo +[        ]+codigo+[       ]+GRUPOS->cobrador// Grupo 2
@ 36,000 SAY GRUPOS->nome                          // Nome
@ 36,036 SAY GRUPOS->nome                          // Nome 2
@ 37,000 SAY GRUPOS->endereco                      // Endere‡o
@ 37,036 SAY GRUPOS->endereco                      // Endere‡o 2
@ 38,000 SAY GRUPOS->bairro                        // Bairro
@ 38,036 SAY GRUPOS->bairro                        // Bairro 2
@ 39,000 SAY GRUPOS->cidade+[ ] +GRUPOS->cep       // Cidade
@ 39,036 SAY GRUPOS->cidade+[ ] +GRUPOS->cep       // Cidade 2
@ 40,000 SAY [Inic:]+DTOC(GRUPOS->admissao)+[ Ult:]+GRUPOS->ultcirc+[ QtTx:]+STR(GRUPOS->qtcircs,3)// Inicio
@ 40,036 SAY [Inic:]+DTOC(GRUPOS->admissao)+[ Ult:]+GRUPOS->ultcirc+[ QtTx:]+STR(GRUPOS->qtcircs,3)// Inicio 2
@ 42,000 SAY ""
IF M->combarra='S'
 CODBARRAS({{codigo+tipo+circ,1,13,18}},10,6)
ENDI
@ 43,002 SAY LEFT(DTOC(DATE()),2)+[  ]+SUBSTR(DTOC(DATE()),4,2)+[  ]+RIGHT(DTOC(DATE()),2)// data 1
@ 43,039 SAY LEFT(DTOC(DATE()),2)+[  ]+SUBSTR(DTOC(DATE()),4,2)+[  ]+RIGHT(DTOC(DATE()),2)// data 2
IF M->combarra='S'
 CODBARRAS({{codigo+tipo+circ,1,13,18}},10,6)
ENDI
@ 44,000 SAY ""
IF M->combarra='S'
 CODBARRAS({{codigo+tipo+circ,1,13,18}},10,6)
ENDI
IF volta_reg
 GO reg_atual                                      // retorna reg a posicao original
ENDI
SELE (ar_)
RETU 

STATIC PROC REL_CAB(qt, volta_reg)                 // cabecalho do relatorio
LOCAL ar_:=ALIAS()
volta_reg=IF(volta_reg=NIL,.f.,volta_reg)
IF qt>0                                            // se parametro maior que 0
 cl=cl+qt                                          // soma no contador de linhas
ENDI
IF cl>maxli .OR. qt=0                              // quebra de pagina
 IF pg_>1
  REL_RDP(volta_reg)                               // imprime rodape' do relatorio
 ENDI
 SELE BXREC                                        // volta ao arquivo pai
 @ 1,007 SAY GRUPOS->nome                          // Nome
 @ 1,058 SAY TRAN(codigo,"99999")                  // Codigo
 @ 1,076 SAY grupo                                 // Grupo
 @ 3,032 SAY TRAN(valorpg,"@E 999,999.99")         // Valor
 SELE (ar_)
 cl=qt+7 ; pg_++
ENDI
RETU

* \\ Final de ADM_R018.PRG

-L\instalados\tools\clipper\lib
-lxhb
-lhbwin
-lhbct
-oADRBIG.exe
-inc
-prgflag=/l
-compr=def
-rebuild

ADRBIG.prg
libg2.prg
getsys.prg
smt.prg
bxr_07f9.prg
bxr_06f9.prg
bxr_02f9.prg
bxr_01f9.prg
bxrec.prg
ale_01f9.prg
alender.prg
obx_07f9.prg
obx_01f9.prg
obxec.prg
gru_01f9.prg
gru_02f9.prg
grupos.prg
ctainsc.prg
ctxas.prg
tax_02f9.prg
ins_01f9.prg
ins_02f9.prg
gui_07f9.prg
gui_06f9.prg
gui_08f9.prg
gui_02f9.prg
guias.prg
mfilial.prg
adp_r101.prg
adc_rx76.prg
cad_04f9.prg
kinscf9.prg
afuner.prg
r02001f9.prg
r02002f9.prg
adm_r020.prg
v02001f9.prg
v02002f9.prg
r02901f9.prg
adr_r029.prg
rx2001f9.prg
rx2002f9.prg
adm_rx20.prg
rx2901f9.prg
adr_rx29.prg
adm_r029.prg
adm_r026.prg
adm_r021.prg
dci_p001.prg
dci01f9.prg
dci03f9.prg
dci04f9.prg
adm_rs18.prg
v01801f9.prg
adm_r023.prg
v02301f9.prg
adm_r022.prg
r03001f9.prg
adm_r039.prg
imp_01f9.prg
imppar.prg
medicos.prg
tespec.prg
juros.prg
tfiliais.prg
arqgrup.prg
regiao.prg
cob_01f9.prg
cobrador.prg
classes.prg
circular.prg
prcessos.prg
fncs.prg
historic.prg
cstseg.prg
men_01f9.prg
mensag.prg
ordpgrc.prg
par_adm.prg
adr_estr.prg
adr_atri.prg
adr_atr1.prg
adr_atr2.prg
adr_menu.prg
adr_manu.prg
con_rx01.prg
about.prg
adr_proc.prg
adr_func.prg
adr_fun2.prg
adr_outr.prgprocedure cgr_02f9
/*
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
 \ Empresa.: PresServ Inform tica-Limeira (019)452.6623
 \ Programa: GRU_02F9.PRG
 \ Data....: 22-02-98
 \ Sistema.: Administradora - PLANO
 \ Funcao..: Fun‡„o F8 do campo CODIGO, arquivo GRUPOS
 \ Analista: Ademilson Pedro Bom
 \ Criacao.: Programado manualmente pelo analista
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/

#include "adrbig.ch"    // inicializa constantes manifestas

SELE CGRUPOS
GO BOTT
rcodin:=sTRzero(VAL(numero)+1,6,0)
//POINTER_DBF(reg_dbf)

RETU M->rcodin       // <- deve retornar um valor qualquer

* \\ Final de GRU_02F9.PRG
GAS-Pro v4.0
007009016074001001001001008000176001
 C¢digo..:       Nome..:
 Fun‡„o..:                     Nacionalidade:
 E.Civil.:                     Nascimento...:
 Endere‡o:
 Bairro..:
 Cidade..:
 CPF.....:                     Telefone.....:
 Comiss„o:      %
[Ÿ]
Inclus„o~~26006
Manuten‡„o~~27007
Consulta~~28008
[Ÿ]
 13 
 1 
N£mero

 1 
[Ÿ]
Funcion rios
Funcion rios

nivelop>2
Permitido apenas para usu rio cadastrado|com n¡vel de Gerˆncia
nivelop>1
Permitido apenas para usu rio cadastrado|com n¡vel de Manuten‡„o ou Gerˆncia
nivelop>1
Permitido apenas para usu rio cadastrado|com n¡vel de Manuten‡„o ou Gerˆncia
005


nivelop>2
Permitido apenas para usu rio cadastrado|com n¡vel de Gerˆncia




















 0 











 0 
 1 
-1 
-1 
 0 
-1 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
codigo
C
E
 
 3 
 3 
 1 
 12 
 0 
C¢digo

!EMPT(codigo)
Necess rio informar C¢DIGO

Informe um c¢digo para o funcion rio

 0 
 1 


nome
C
E
@!
 35 
 35 
 1 
 26 
 0 
Nome do funcion rio

!EMPT(nome)
Necess rio informar NOME DO FUNCIONRIO

Entre com o nome do funcion rio autorizado a|assinar a declara‡Æo de ¢bito no|Cart¢rio de Registro C¡vil

 0 
 0 


profiss
C
E
@!
 15 
 15 
 2 
 12 
 0 
Profiss„o

!EMPT(profiss)
sta informa‡„o ‚ necess rio para a Declara‡„o de ¢bito

Entre com a profiss„o do funcion rio.
MTAB([ATENDENTE|COBRADOR|MOTORISTA|VENDEDOR],[PROFISSŽO])
 0 
 0 


nacional
C
E
@!
 15 
 15 
 2 
 47 
 0 
Nacionalidade

!EMPT(nacional)
Necess rio informar NACIONALIDADE
[BRASILEIRO]
Entre com a nacionalidade

 0 
 0 


estciv
C
E
!A
 2 
 2 
 3 
 12 
 0 
Est.Civil

estciv $ tbestciv
EST.CIVIL n„o aceit vel.|Tecle F8 para busca em tabela

Entre com o estado civil ou tecle F8
MTAB(tbestciv,[EST.CIVIL])
 0 
 0 


nascto_
D
E
@D
 8 
 10 
 3 
 47 
 0 
Idade

 


Entre com a data de nascimento

 0 
 0 


endereco
C
E
@!
 30 
 30 
 4 
 12 
 0 
Endere‡o

!EMPT(endereco)
Necess rio informar Endere‡o

Informe o endere‡o do funcion rio

 0 
 0 


bairro
C
E
@!
 25 
 25 
 5 
 12 
 0 
Bairro

 


Entre com o bairro

 0 
 0 


cidade
C
E
@!
 25 
 25 
 6 
 12 
 0 
Cidade

!EMPT(cidade)
Necess rio informar CIDADE

Entre com o nome do munic¡pio

 0 
 0 


cpf
C
E
@R 999.999.999-99
 11 
 14 
 7 
 12 
 0 
CPF

VDV2(cpf) .OR. EMPT(cpf)
CPF n„o aceit vel



 0 
 0 


telefone
C
E
 
 14 
 14 
 7 
 47 
 0 
Telefone

 




 0 
 0 


percent
N
E
999.9
 5 
 5 
 8 
 12 
 1 
Percentual
nivelop=3
!(percent<0).AND.!(percent>100)
PERCENTUAL n„o aceit vel

Informe o percentual de comiss„o|caso o vendedor n„o receba por n£mero de parcelas

 0 
 0 


obs
M
E

 10 
 35 
 0 
 0 
 0 
Observa‡„o

 




 0 
 0 


 1 
estado civil
SUBS(tbestciv,AT(estciv,tbestciv),11)

 3 
 15 
 15 

 0 
 0 
 0 
 0 
/*
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
 \ Empresa.: PresServ Inform tica - Limeira (019)452.6623
 \ Programa: CON_R001.PRG
 \ Data....: 03-05-98
 \ Sistema.: Controle de Convˆnios
 \ Funcao..: Emiss„o Guias Modelo 1
 \ Analista: Ademilson Pedro Bom
 \ Criacao.: GAS-Pro v3.0
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/

#include "ADRbig.ch"    // inicializa constantes manifestas

LOCAL dele_atu, getlist:={}, so_um_reg, sit_dbf:=POINTER_DBF()
PARA  lin_menu, col_menu, imp_reg
PRIV  tem_borda:=.t., op_menu:=VAR_COMPL, l_s:=11, c_s:=20, l_i:=14, c_i:=61, tela_fundo:=SAVESCREEN(0,0,MAXROW(),79)
nucop=1
so_um_reg=(PCOU()>2)
IF !so_um_reg                             // vai receber a variaveis?
 SETCOLOR(drvtittel)
 vr_memo=NOVAPOSI(@l_s,@c_s,@l_i,@c_i)    // pega posicao atual da tela
 CAIXA(mold,l_s,c_s,l_i,c_i)              // monta caixa da tela
 @ l_s,c_s+12 SAY " EMISSŽO DE GUIAS "
 SETCOLOR(drvcortel)
 @ l_s+01,c_s+1 SAY " N£mero:"
ENDI
gnumero=SPAC(7)                                    // N£mero
DO WHILE .t.
 rola_t=.f.
 cod_sos=56
 IF !so_um_reg
  SET KEY K_ALT_F8 TO ROLATELA
  SETCOLOR(drvcortel+","+drvcorget+",,,"+corcampo)
  @ l_s+01 ,c_s+10 GET  gnumero;
                   PICT "@R 99-99999";
                   VALI CRIT("PTAB(gnumero,'GUIAS',1).AND.V00101F9()~N£MERO n„o existe na tabela")
                   DEFAULT "M->pnumero"
                   AJUDA "Emitir a guia de n£mero?"
                   CMDF8 "VDBF(6,8,20,77,'GUIAS',{'numero','grupo','codigo','grau','seq','nome'},1,'numero')"
                   MOSTRA {"LEFT(TRAN(GUIAS->nome,[@!]),35)", 2 , 5 }

  READ
  SET KEY K_ALT_F8 TO
  IF rola_t
   ROLATELA(.f.)
   LOOP
  ENDI
  IF LASTKEY()=K_ESC                               // se quer cancelar
   RETU                                            // retorna
  ENDI
 ENDI

 #ifdef COM_REDE
  IF !USEARQ("GUIAS",.f.,10,1)                     // se falhou a abertura do arq
   RETU                                            // volta ao menu anterior
  ENDI
 #else
  USEARQ("GUIAS")                                  // abre o dbf e seus indices
 #endi

 PTAB(medico,"MEDICOS",1,.t.)                      // abre arquivo p/ o relacionamento
 SET RELA TO medico INTO MEDICOS                   // relacionamento dos arquivos
 titrel:=criterio:=cpord := ""                     // inicializa variaveis
 titrel:=chv_rela:=chv_1:=chv_2 := ""
 tps:=op_x:=ccop := 1
 arq_=drvporta                                     // porta de saida configurada
 IF !so_um_reg
  IF !opcoes_rel(lin_menu,col_menu,5,11)           // nao quis configurar...
   CLOS ALL                                        // fecha arquivos e
   LOOP                                            // volta ao menu
  ENDI

 #ifdef COM_REDE

  ELSE

   tps=lin_menu

 #endi

 ENDI
 IF tps=2                                          // se vai para arquivo/video
  arq_=ARQGER()                                    // entao pega nome do arquivo
  IF EMPTY(arq_)                                   // se cancelou ou nao informou
   LOOP                                            // retorna
  ENDI
 ELSE
  arq_=drvporta                                    // porta de saida configurada
 ENDI
 SET PRINTER TO (arq_)                             // redireciona saida
 EXIT
ENDD
IF !EMPTY(drvtapg)                                 // existe configuracao de tam pag?
 op_=AT("NNN",drvtapg)                             // se o codigo que altera
 IF op_=0                                          // o tamanho da pagina
  msg="Configura‡„o do tamanho da p gina!"         // foi informado errado
  DBOX(msg,,,,,"ERRO!")                            // avisa
  CLOSE ALL                                        // fecha todos arquivos abertos
  RETU                                             // e cai fora...
 ENDI                                              // codigo para setar/resetar tam pag
 lpp_024=LEFT(drvtapg,op_-1)+"024"+SUBS(drvtapg,op_+3)
 lpp_066=LEFT(drvtapg,op_-1)+"066"+SUBS(drvtapg,op_+3)
ELSE
 lpp_024:=lpp_066 :=""                             // nao ira mudara o tamanho da pag
ENDI
DBOX("[ESC] Interrompe",15,,,NAO_APAGA)
dele_atu:=SET(_SET_DELETED,.t.)                    // os excluidos nao servem...
SET DEVI TO PRIN                                   // inicia a impressao
maxli=22                                           // maximo de linhas no relatorio
IMPCTL(lpp_024)                                    // seta pagina com 24 linhas
SET MARG TO 1                                      // ajusta a margem esquerda
IF tps=2
 IMPCTL("' '+CHR(8)")
ENDI
BEGIN SEQUENCE
 DO WHIL ccop<=nucop                               // imprime qde copias pedida
  pg_=1; cl=999
  IF so_um_reg
   GO imp_reg
  ELSE
   INI_ARQ()                                       // acha 1o. reg valido do arquivo
   IF PTAB(PADR(SUBSTR(M->ide_maq,2),4)+[GUI],[IMPPAR],1)
    SEEK ALLTRIM(IMPPAR->docto)
   ENDI
  ENDI
  ccop++                                           // incrementa contador de copias
  DO WHIL !EOF().AND.(!so_um_reg.OR.imp_reg=RECN())
   #ifdef COM_TUTOR
    IF IN_KEY()=K_ESC                              // se quer cancelar
   #else
    IF INKEY()=K_ESC                               // se quer cancelar
   #endi
    IF canc()                                      // pede confirmacao
     BREAK                                         // confirmou...
    ENDI
   ENDI
   IF (PTAB(PADR(SUBSTR(M->ide_maq,2),4)+[GUI],[IMPPAR],1).and.LEFT(IMPPAR->docto,7)=ano+numero) .OR. so_um_reg// se atender a condicao...
    REL_CAB(2)                                     // soma cl/imprime cabecalho
    @ cl,066 SAY TRAN(numero,"99999")              // N£mero
    REL_CAB(3)                                     // soma cl/imprime cabecalho
    IMPCTL(drvpenf)
    @ cl,008 SAY MEDICOS->nome                     // Nome M‚dico
    IMPCTL(drvtenf)
    @ cl,063 SAY TRAN(medico,"@!")                 // M‚dico Codigo
    REL_CAB(3)                                     // soma cl/imprime cabecalho
		@ cl,008 SAY ALLTRIM(MEDICOS->endereco)+[ Tel.:]+MEDICOS->telefone // Endere‡o
		REL_CAB(1)                                     // soma cl/imprime cabecalho
		@ cl,008 SAY TRAN(MEDICOS->cidade,"@!")        // Cidade
		REL_CAB(3)                                     // soma cl/imprime cabecalho
		IF !EMPT(MEDICOS->mensagem)
		 @ cl,008 SAY TRAN(MEDICOS->mensagem,"@!")      // Mensagem
		ELSE
		 IF MEDICOS->valorpart > 0
			@ cl,008 SAY TRAN(MEDICOS->valorpart,"@E 99,999,999.99")// Valor Particular
		 ENDI
		 IF MEDICOS->porcent1 > 0
			@ cl,027 SAY TRAN(MEDICOS->porcent1,"99")      // Porcent1
		 ENDI
		 IF MEDICOS->ultvalor > 0
			@ cl,035 SAY TRAN(MEDICOS->valorpart-MEDICOS->ultvalor,"@E 99,999,999.99")// Valor Particular
			@ cl,058 SAY TRAN(MEDICOS->ultvalor,"@E 99,999,999.99")// Ult.valor
		 ENDI
		ENDI

		REL_CAB(3)                                     // soma cl/imprime cabecalho
		@ cl,008 SAY TRAN(titular,"@!")                // Titular
		@ cl,062 SAY TRAN(contrato,"999999")           // N§ Contrato
		REL_CAB(3)                                     // soma cl/imprime cabecalho
		@ cl,008 SAY TRAN(nome,"@!")                   // Nome
		@ cl,051 SAY TRAN(emissao_,"@D")               // Emiss„o
		@ cl,062 SAY TRAN(emissao_+VAL(MEDICOS->tipcont),"@D")            // validade
    SKIP                                           // pega proximo registro
    cl=999                                         // forca salto de pagina
   ELSE                                            // se nao atende condicao
    SKIP                                           // pega proximo registro
   ENDI
   exit
  ENDD
 ENDD ccop
 EJEC                                              // salta pagina
END SEQUENCE
SET MARG TO                                        // coloca margem esquerda = 0
IMPCTL(lpp_066)                                    // seta pagina com 66 linhas
SET PRINTER TO (drvporta)                          // fecha arquivo gerado (se houver)
SET DEVI TO SCRE                                   // direciona saida p/ video
IF tps=2                                           // se vai para arquivo/video
 BROWSE_REL(arq_,2,3,MAXROW()-2,78)
ENDI                                               // mostra o arquivo gravado
GRELA(5)                                           // grava variacao do relatorio
SELE GUIAS                                         // salta pagina
SET RELA TO                                        // retira os relacionamentos
SET(_SET_DELETED,dele_atu)                         // os excluidos serao vistos
IF so_um_reg
 POINTER_DBF(sit_dbf)
ENDI
RETU

STATIC PROC REL_CAB(qt)                            // cabecalho do relatorio
IF qt>0                                            // se parametro maior que 0
 cl=cl+qt                                          // soma no contador de linhas
ENDI
IF cl>maxli .OR. qt=0                              // quebra de pagina
 cl=qt+2 ; pg_++
ENDI
RETU

* \\ Final de CON_R001.PRG
t   /                     PW_GRUPO   C                   PW_CODIGO  C                   PW_NOME    C                   PW_NIVEL   C                   PW_OBS     C                   PW_PASS    C                   FLAG_EXCL  C                     ¤•¤–¤•¤–ÇºÄªÅÊ®Ç´Å”…”…“§”…”…“”…”…“”…”…“µ©Æ…“” € GRUPOS’–½ GRUPOSCODEGRU_INCLCODEGRU_TELACODEGRU_GETSCODEGRU_GET1CODEGRU_MEMOCODETAX_INCLCODETAX_TELACODETAX_GETSCODETAX_GET1CODEECO_INCLCODEECO_TELACODEECO_GETSCODEECO_GET1CODEINS_INCLCODEINS_TELACODEINS_GETSCODEINS_GET1CODEC_ETEXTENDCODE	_SYMSTARTSYMSTARTSYMBOLSSYMBOLS_SYMENDSYMENDNULLBEGDATA_DATADATA_SYMPBDATA_SYMPDATA_SYMPEDATA_CONSTCONST_MSGMSG_BEGBSSBEGBSS_BSSBSS_ENDBSSENDBSSDGROUP°˜ @^º˜ @J	Ä˜ @~˜ @
	†˜ @ÿ
þ˜ @a ¦˜ @m
Œ˜ @û˜ @”e˜ @<µ˜ @§D˜ @*Ã˜ @›GAS-Pro v3.0
002003024079001048019028023000176001








.
[Ÿ]
 27 
TAXAS
Uma a uma Convencional

codigo
codigo=M->rcodigo
011









 0 
 1 
 0 
 48 
 1 
 8 
 28 
 0 
 0 
 0 
 0 
 0 
 0 
-1 
 0 
-1 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
Grupo
GRUPOS->grupo
!9
 2 
C
 2 
 77 


          










Nome
GRUPOS->nome

 35 
C
 2 
 8 


          










Codigo
codigo
999999
 6 
C
 2 
 59 


          










Mensagem
CHR(18)+CIRCULAR->menscirc

 61 
C
 22 
 9 


          










N§ Recibo
0
########
 8 
C
 29 
 21 


          










N§ Recibo 2
0
########
 8 
C
 29 
 69 


          










Valor
valor
@E 999,999.99
 10 
N
 26 
 18 


          










Valor 2
valor
@E 999,999.99
 10 
N
 26 
 66 


          










Circular 1
TAXAS->circ+[     ]+DTOC(TAXAS->emissao_)+[     ]+STR(GRUPOS->funerais,2)

 30 
C
 32 
 3 


          










Circular 2
TAXAS->circ+[     ]+DTOC(TAXAS->emissao_)+[     ]+STR(GRUPOS->funerais,2)

 30 
C
 32 
 39 


          










Grupo 1
GRUPOS->grupo +[        ]+codigo+[       ]+GRUPOS->cobrador

 30 
C
 35 
 3 


          










Grupo 2
GRUPOS->grupo +[        ]+codigo+[       ]+GRUPOS->cobrador

 30 
C
 35 
 39 


          










Inicio
[Inic:]+DTOC(GRUPOS->admissao)+[ Ult:]+GRUPOS->ultcirc+[ QtTx:]+STR(GRUPOS->qtcircs,3)

 35 
C
 41 
 1 


          










Inicio 2
[Inic:]+DTOC(GRUPOS->admissao)+[ Ult:]+GRUPOS->ultcirc+[ QtTx:]+STR(GRUPOS->qtcircs,3)

 35 
C
 41 
 37 


          










Nome
GRUPOS->nome
 
 35 
C
 37 
 1 


          










Nome 2
GRUPOS->nome

 35 
C
 37 
 37 


          










Endere‡o
GRUPOS->endereco
 
 35 
C
 38 
 1 


          










Endere‡o 2
GRUPOS->endereco

 35 
C
 38 
 37 


          










Bairro
GRUPOS->bairro
 
 25 
C
 39 
 1 


          










Bairro 2
GRUPOS->bairro

 25 
C
 39 
 37 


          










Cidade
GRUPOS->cidade+[ ] +GRUPOS->cep

 35 
C
 40 
 1 


          










Cidade 2
GRUPOS->cidade+[ ] +GRUPOS->cep

 35 
C
 40 
 37 


          










Valor
valor
@E 999,999.99
 10 
N
 4 
 33 


          










data 1
[ ]

 10 
C
 44 
 3 


          










data 2
[ ]

 10 
C
 44 
 40 


          










BarCode 1
codigo+tipo+circ

 13 
4
 43 
 19 


          










BarCode 2
codigo+tipo+circ

 13 
4
 44 
 19 


          










 9 
Nome da empresa
nemp

 0 
 0 
 32 

T¡tulo aplica‡„o
nsis

 0 
 0 
 25 

Data do sistema
DTOC(DATE())

 0 
 0 
 8 

Nome do mˆs
NMES(DATE())

 0 
 0 
 8 

Dia da semana
NSEM(DATE())

 0 
 0 
 7 

N£mero da p gina
TRAN(pg_,'9999')

 0 
 0 
 4 

C¢digo relat¢rio
"ADM_R033"

 0 
 0 
 8 

T¡tulo a definir
titrel

 0 
 0 
 30 

Hora da emiss„o
hora_rel_

 0 
 0 
 5 

 0 
 0 
 0 
 4 
GRUPOS
 1 
codigo



ARQGRUP
 1 
GRUPOS->grupo



REGIAO
 1 
GRUPOS->regiao



CIRCULAR
 1 
GRUPOS->grupo+circ



procedure r02501f9
/*
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
 \ Empresa.: PresServ Inform tica-Limeira (019)452.6623
 \ Programa: R02501F9.PRG
 \ Data....: 24-11-95
 \ Sistema.: Administradora de Funer rias
 \ Funcao..: MOTIVO do relat¢rio ADM_R025
 \ Analista: Ademilson Pedro Bom
 \ Criacao.: Programado manualmente pelo analista
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/

#include "admbig.ch"    // inicializa constantes manifestas
IF !PTAB(codigo+circ,'TAXAS',1)
 RETU [Nao cadastrada]
ELSEIF TAXAS->valorpg>0
 RETU [Taxa baixada  ]
ENDIF

RETU []
* \\ Final de R02501F9.PRG
€
 CON_RX01$–ø  CON_RX01CODEREL_RDPCODEREL_CABCODER001GF9CODEC_ETEXTENDCODE	_SYMSTARTSYMSTARTSYMBOLSSYMBOLS_SYMENDSYMENDNULLBEGDATA_DATADATA_SYMPBDATA_SYMPDATA_SYMPEDATA_CONSTCONST_MSGMSG_BEGBSSBEGBSS_BSSBSS_ENDBSSENDBSSDGROUPq˜ @[´˜ @÷˜ @ø ˜ @$ 	ë˜ H  
˜ h  ß˜ ` ¼˜ h  ×˜ h  Ó˜ H  ï˜ H  ë˜ H ß˜ H  DEL ADM_R018.OBJ  
DEL ADM_R020.OBJ
DEL ADM_RS18.OBJ  
DEL ADM_RX20.OBJ  
DEL ADR_R029.OBJ  
DEL ADR_R067.OBJ  
DEL ADR_RX29.OBJ  
DEL CON_R001.OBJ  
DEL RX2001F9.OBJ  
DEL RX2901F9.OBJ  
DEL R02001F9.OBJ  
DEL R02002F9.OBJ  
DEL RX2002F9.OBJ  
DEL guias.OBJ  
procedure rx2002f9
/*
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
 \ Empresa.: PresServ Inform tica-Limeira (019)452.6623
 \ Programa: R02002F9.PRG
 \ Data....: 22-09-97
 \ Sistema.: Administradora - RECEP€„O
 \ Funcao..: DECLARACAO do relat¢rio ADM_R020
 \ Analista: Ademilson Pedro Bom
 \ Criacao.: Programado manualmente pelo analista
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/

#include "adrbig.ch"    // inicializa constantes manifestas
li_aux:=[]
li_aux+=[     O Contratante (ou representante legal) responsabiliza-se pelas ]
li_aux+=[declara‡”es aqui prestadas e est  CIENTE de que qualquer informa‡„o FALSA ]
li_aux+=[importar  em responsabilidade criminal, nos termos do Artigo 299 do C¢digo ]
li_aux+=[Penal. Outrossim declara que tamb‚m est  ciente de que cada funeral d  o ]
li_aux+=[direito de REQUERER somente uma vez o referido Pagamento/Atendimento Funeral, ]
li_aux+=[e que n„o poder  existir nenhum outro requerimento feito com ]
li_aux+=[rela‡„o a este falecimento, nem por este contratante e nem por ]
li_aux+=[seus familiares, nem neste e nem em outro CONTRATO ]
li_aux+=[desta Organiza‡„o. Por fim, declara ainda que, se constatada a inexatid„o ]
li_aux+=[ou fraude nas informa‡”es aqui prestadas, al‚m de obrigar-se … devolu‡„o ]
li_aux+=[das importƒncias recebidas INDEVIDAMENTE, sujeitar-se-   s penalidades ]
li_aux+=[previstas no artigo 171 do C¢digo Penal.]

RETU M->li_aux      // <- deve retornar um valor qualquer

* \\ Final de R02002F9.PRG
procedure r06601f9
/*
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
 \ Empresa.: PresServ Inform tica-Limeira (019)452.6623
 \ Programa: R06601F9.PRG
 \ Data....: 22-01-97
 \ Sistema.: Administradora - PLANO
 \ Funcao..: Express„o de filtro do relat¢rio ADP_R066.PRG
 \ Analista: Ademilson Pedro Bom
 \ Criacao.: Programado manualmente pelo analista
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/

#include "adrbig.ch"    // inicializa constantes manifestas
PRIVA DONEIMP:=TAXAS->stat<[2] //CLASSES->prior=[S]
M->doneimp:=doneimp .AND.emissao_>=M->rem1_
M->doneimp:=doneimp .AND.emissao_<=M->rem2_
M->doneimp:=doneimp .AND.valorpg=0
M->doneimp:=doneimp .AND.(tipo$'16')
M->doneimp:=doneimp .AND.(M->rcod1='000000'.OR.codigo>=M->rcod1)
M->doneimp:=doneimp .AND.(M->rcod2='000000'.OR.codigo<=M->rcod2)
RETU M->doneimp       // <- deve retornar um valor L¢GICO

* \\ Final de R06601F9.PRG
procedure r00201f9
/*
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
 \ Empresa.: PresServ Inform tica-Limeira (019)452.6623
 \ Programa: R00201F9.PRG
 \ Data....: 24-12-95
 \ Sistema.: Administradora de Funer rias
 \ Funcao..: Pr‚-valida‡„o da variavel RECMENSAG, relaotiro ADM_R002
 \ Analista: Ademilson Pedro Bom
 \ Criacao.: Programado manualmente pelo analista
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/

#include "admbig.ch"    // inicializa constantes manifestas
priva doneaux:=[]
DO CASE
 CASE GRUPOS->situacao!=[1]
  doneaux:=[Cancelado]
 CASE GRUPOS->qtcircs>=(GRUPOS->funerais+1)*ARQGRUP->qtdremir
  doneaux:=[Remido]
 CASE RIGHT(GRUPOS->saitxa,2)+LEFT(GRUPOS->saitxa,2)>RIGHT(CIRCULAR->mesref,2)+LEFT(CIRCULAR->mesref,2)
  doneaux:=[SaiTxa > Emissao]
ENDCASE

RETU doneaux      // <- retorna vazio se contrato em codic”es de emiss„o.

* \\ Final de R00201F9.PRG
procedure gui_03f9
/*
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
 \ Empresa.: PresServ Inform tica - Limeira (019)452.6623
 \ Programa: GUI_03F9.PRG
 \ Data....: 23-05-98
 \ Sistema.: Administradora - RECEP€„O
 \ Funcao..: F¢rmula (circ 1-4) a mostrar na tela de GUIAS
 \ Analista: Ademilson Pedro Bom
 \ Criacao.: Programado manualmente pelo analista 
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/
#include "adrbig.ch"    // inicializa constantes manifestas

/*
   -------------------------------------------------------------------
   Se abrir outros arquivos salve situacao anterior e restaure ao sair
   como no exemplo abaixo:
     LOCAL reg_dbf:=POINTER_DBF()
     ...        ...        ...        ...
     POINTER_DBF(reg_dbf)
     RETU
   -------------------------------------------------------------------
*/
RETU       // <- deve retornar um valor qualquer

* \\ Final de GUI_03F9.PRG
Branch 01/06/2010 - pedro:
-Corrigido o tamanho da tela de mensagens apresentadas para cada contrato,
alterado de 50 para 60 caracteres.
-Alterado o processo do campo GRUPOS->obs no lancamento e manutencao do
arquivo MFILIAL.

Branch 18/05/2010 - pedro:
-Incluida rotina de impressao da ficha de acerto (adm_rx76) com as mensagens
de obs apresentadas pela rotina CAD_04F9.

Branch 13/05/2010 - pedro:
-Incluida rotina de impressao de cartinha (adm_r101)

Branch 28/04/2009 - pedro:
-Incluida a mensagem "Favor verificar endereco e telefone" em cad_04f9.

Branch 19/02/2008 - pedro:
-Refeita a rotina de apresentacao de mensagens em tela (cad_04f9) para
apresentar mais conteudos e aumentar o tamanho da linha
-Refeita a rotina de controle de inclusao/exclusao do arquivo Mfilial
para melhorar o controle dos registros lancados.


Branch 03/01/2008 - pedro:
-Alterada a impressao de todos os documentos de auxilio, incluido o campo
filial na indentificacao do processo. programas adm_r029, adm_r026,
adm_r021, adm_rx20, adr_r029, adr_rx29.

Branch 27/04/2007 - pedro:
-Incluida data de vencimento (TAXAS->emissao_) na impressao do recibo.

Alteracoes manuais:
adrbig
incluir os includes:
#include "SIXNSX.CH"
#define RDDNAME "SIXNSX"
#define MEMOEXT ".SMT"

adr_atri
Refazer as definicoes:

sistema[005]={;
	    "Taxas",;                                       // opcao do menu
	    "Cadastro de Taxas",;                           // titulo do sistema
	    {"codigo","codlan"},;                 // chaves do arquivo
	    {"Contrato","Cod.Lanc"},;                       // titulo dos indices para consulta
	    {"01","15"},;                               // ordem campos chaves
	    {"TAXAS",drvdbf,drvntx},;                       // nome do DBF
	    {"TAXAS1","TAXAS2"},;                           // nomes dos NTX

sistema[007]={;
	    "Inscritos",;                                   // opcao do menu
	    "Inscritos",;                                   // titulo do sistema
	    {"codigo","nome"},;                        // chaves do arquivo
	    {"Codigo","Nome"},;                             // titulo dos indices para consulta
	    {"01","05"},;                                 // ordem campos chaves
	    {"INSCRITS",drvdbf,drvntx},;                    // nome do DBF
	    {"INSCRIT1","INSCRIT2"},;                       // nomes dos NTX

adr_estr
PROC TAX_estr     // estrutura do arquivo TAXAS
DBCREATE(dbf,{;
               {"codigo"    ,"C", 18, 0},; // @S10@!
PROC INS_estr     // estrutura do arquivo INSCRITS
DBCREATE(dbf,{;
               {"codigo"    ,"C", 18, 0},; // @S10@!
PROC ECO_estr     // estrutura do arquivo ECOB
DBCREATE(dbf,{;
	       {"codigo"    ,"C", 18, 0},; // @S10@!

Alterar as definicoes:
adrbig.lnk = adrlnk.ok
adrbig.rmk -> alterar de rtlink para blinker
adr_adap.lnk = adr_lnk.ok
adr_adap.rmk ->alterar de rtlink para blinker

Incluir a linha de busca aos inscritos nos arquivos OBXEC e BXREC
  SET KEY K_F9 TO veoutros                         // habilita consulta em outros arquivos
  SET KEY K_F2 TO veinscrits()                         // habilita consulta em outros arquivos


/*
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
 \ Empresa.: Ind£stria de Urnas Bignotto Ltda
 \ Programa: CON_R001.PRG
 \ Data....: 15-05-97
 \ Sistema.: Controle de Convˆnios
 \ Funcao..: Emiss„o Guias 1¦ Parte
 \ Analista: Ademilson Pedro Bom
 \ Criacao.: GAS-Pro v3.0
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/

#include "adrbig.ch"    // inicializa constantes manifestas

LOCAL dele_atu, getlist:={}, so_um_reg, sit_dbf:=POINTER_DBF()
PARA  lin_menu, col_menu, imp_reg
PRIV  tem_borda:=.t., op_menu:=VAR_COMPL, l_s:=11, c_s:=20, l_i:=14, c_i:=61, tela_fundo:=SAVESCREEN(0,0,MAXROW(),79)
nucop=1
so_um_reg=(PCOU()>2)
IF !so_um_reg                             // vai receber a variaveis?
 SETCOLOR(drvtittel)
 vr_memo=NOVAPOSI(@l_s,@c_s,@l_i,@c_i)    // pega posicao atual da tela
 CAIXA(mold,l_s,c_s,l_i,c_i)              // monta caixa da tela
 @ l_s,c_s+12 SAY " EMISSŽO DE GUIAS "
 SETCOLOR(drvcortel)
 @ l_s+01,c_s+1 SAY " N£mero:"
ENDI
gnumero=SPAC(7)                                    // N£mero
DO WHILE .t.
 rola_t=.f.
 cod_sos=56
 IF !so_um_reg
  SET KEY K_ALT_F8 TO ROLATELA
  SETCOLOR(drvcortel+","+drvcorget+",,,"+corcampo)
  @ l_s+01 ,c_s+10 GET  gnumero;
                   PICT "@R 99-99999";
                   VALI CRIT("PTAB(gnumero,'GUIAS',1).AND.V00101F9()~N£MERO n„o existe na tabela")
                   AJUDA "Emitir a guia de n£mero?"
                   CMDF8 "VDBF(6,8,20,77,'GUIAS',{'numero','contrato','nome'},1,'R001gf9()')"
                   MOSTRA {"LEFT(TRAN(GUIAS->nome,[@!]),35)", 2 , 5 }

  READ
  SET KEY K_ALT_F8 TO
  IF rola_t
   ROLATELA(.f.)
   LOOP
  ENDI
  IF LASTKEY()=K_ESC                               // se quer cancelar
   RETU                                            // retorna
  ENDI
 ENDI

 #ifdef COM_REDE
  IF !USEARQ("GUIAS",.f.,10,1)                     // se falhou a abertura do arq
   RETU                                            // volta ao menu anterior
  ENDI
 #else
  USEARQ("GUIAS")                                  // abre o dbf e seus indices
 #endi

 PTAB(medico,"MEDICOS",1,.t.)                      // abre arquivo p/ o relacionamento
 SET RELA TO medico INTO MEDICOS                 // relacionamento dos arquivos
 titrel:=criterio:=cpord := ""                     // inicializa variaveis
 titrel:=chv_rela:=chv_1:=chv_2 := ""
 tps:=op_x:=ccop := 1
 arq_=drvporta                                     // porta de saida configurada
 IF !so_um_reg
  IF !opcoes_rel(lin_menu,col_menu,7,11)           // nao quis configurar...
   CLOS ALL                                        // fecha arquivos e
   LOOP                                            // volta ao menu
  ENDI

 #ifdef COM_REDE

  ELSE

   tps=lin_menu

 #endi

 ENDI
 IF tps=2                                          // se vai para arquivo/video
  arq_=ARQGER()                                    // entao pega nome do arquivo
  IF EMPTY(arq_)                                   // se cancelou ou nao informou
   LOOP                                            // retorna
  ENDI
 ELSE
  arq_=drvporta                                    // porta de saida configurada
 ENDI
 SET PRINTER TO (arq_)                             // redireciona saida
 EXIT
ENDD
IF !EMPTY(drvtapg)                                 // existe configuracao de tam pag?
 op_=AT("NNN",drvtapg)                             // se o codigo que altera
 IF op_=0                                          // o tamanho da pagina
  msg="Configura‡„o do tamanho da p gina!"         // foi informado errado
  DBOX(msg,,,,,"ERRO!")                            // avisa
  CLOSE ALL                                        // fecha todos arquivos abertos
  RETU                                             // e cai fora...
 ENDI                                              // codigo para setar/resetar tam pag
 lpp_024=LEFT(drvtapg,op_-1)+"024"+SUBS(drvtapg,op_+3)
 lpp_066=LEFT(drvtapg,op_-1)+"066"+SUBS(drvtapg,op_+3)
ELSE
 lpp_024:=lpp_066 :=""                             // nao ira mudara o tamanho da pag
ENDI
DBOX("[ESC] Interrompe",15,,,NAO_APAGA)
dele_atu:=SET(_SET_DELETED,.t.)                    // os excluidos nao servem...
SET DEVI TO PRIN                                   // inicia a impressao
maxli=17                                           // maximo de linhas no relatorio
IMPCTL(lpp_024)                                    // seta pagina com 24 linhas
SET MARG TO 1                                      // ajusta a margem esquerda
IF tps=2
 IMPCTL("' '+CHR(8)")
ENDI
BEGIN SEQUENCE
 DO WHIL ccop<=nucop				// imprime qde copias pedida
  pg_=1; cl=999
  IF so_um_reg
   GO imp_reg
  ELSE
   INI_ARQ()                                       // acha 1o. reg valido do arquivo
   IF PTAB(PADR(SUBSTR(M->ide_maq,2),4)+[GUI],[IMPPAR],1)
    SEEK ALLTRIM(IMPPAR->docto)
   ENDI
  ENDI
  ccop++                                           // incrementa contador de copias
  ult_imp=0                                        // ultimo reg impresso
  DO WHIL !EOF().AND.(!so_um_reg.OR.imp_reg=RECN())
   #ifdef COM_TUTOR
    IF IN_KEY()=K_ESC                              // se quer cancelar
   #else
    IF INKEY()=K_ESC                               // se quer cancelar
   #endi
    IF canc()                                      // pede confirmacao
     BREAK                                         // confirmou...
    ENDI
   ENDI
   IF (PTAB(PADR(SUBSTR(M->ide_maq,2),4)+[GUI],[IMPPAR],1).AND.ano+numero=LEFT(IMPPAR->docto,7)) .OR. so_um_reg// se atender a condicao...
    REL_CAB(1,.t.)                                 // soma cl/imprime cabecalho
    @ cl,000 SAY "GUIA DE ENCAMINHAMENTO  N§:"
    @ cl,027 SAY ano+'-'+numero+GDV1(ano+numero)   // N£mero
    @ cl,043 SAY IIF(guiapara='C',[Consulta],IIF(guiapara='E',[Exame],IIF(guiapara='I',[Interna‡„o],[     ])))// Guia Para
    IF M->combarra=[S]
     CODBARRAS({{ano+numero+GDV1(ano+numero),4,10,64}},10,6)
    ENDI
    ult_imp=RECNO()                                // ultimo reg impresso
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY "Para:"
    @ cl,008 SAY TRAN(MEDICOS->especialid,"@!")    // Especialidade
    IF M->combarra=[S]
     CODBARRAS({{ano+numero+GDV1(ano+numero),4,10,64}},10,6)
    ENDI
    REL_CAB(2)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY "Encaminhado a .........:"
    @ cl,025 SAY ALLTRIM(MEDICOS->nome)+[ (]+ALLTRIM(medico)+[)]// M‚dico
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    IMPAC("Endere‡o...............:",cl,000)
    @ cl,025 SAY MEDICOS->endereco// Endere‡o
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY "Atendimento dia........:"
    @ cl,025 SAY TRAN(emissao_,"@D")               // Emiss„o
    IMPAC("(V lido at‚ "+MEDICOS->tipcont+" dias)",cl,036)
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY "Pessoa a ser atendida..:"
    IMPCTL(drvpenf)
    @ cl,025 SAY TRAN(nome,"@!")                   // Nome
    IMPCTL(drvtenf)
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    IMPAC("Benefici rio principal.:",cl,000)
    @ cl,025 SAY TRAN([ (]+ALLTRIM(titular)+[ / ]+contrato+[)],"@!")// Titular
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY REPL("-",60)
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    IF !EMPT(MEDICOS->mensagem)
     @ cl,008 SAY TRAN(MEDICOS->mensagem,"@!")      // Mensagem
     REL_CAB(2)                                     // soma cl/imprime cabecalho
    ELSE
     @ cl,000 SAY "Valor Particular:"
     @ cl,018 SAY tran(MEDICOS->valorpart,"@E 99,999,999.99")// Valor Particular
     @ cl,033 SAY "desconto de:"
     IF (MEDICOS->valorpart - valorcon)>0// pode imprimir?
      @ cl,046 SAY TRAN(MEDICOS->valorpart - valorcon,"@E 99,999,999.99")// Valor desconto
     ENDI
     REL_CAB(1)                                     // soma cl/imprime cabecalho
     @ cl,000 SAY "Valor Total.....:"
     @ cl,018 SAY TRAN(valorcon+ valorexa,"@E 99,999,999.99")// Valor total
     @ cl,032 SAY LEFT([(]+LEFT(EXT(valorcon+valorexa),AT('/',EXT(valorcon+valorexa))-1)+[)],40)// Total p/Extenso
     REL_CAB(1)                                     // soma cl/imprime cabecalho
     @ cl,016 SAY SUBSTR([(]+LEFT(EXT(valorcon+valorexa),AT('/',EXT(valorcon+valorexa))-1)+[)],41,54)// Extenso (cont..)
    ENDI
    SKIP                                           // pega proximo registro
    cl=999                                         // forca salto de pagina
   ELSE                                            // se nao atende condicao
    SKIP                                           // pega proximo registro
   ENDI
   exit
  ENDD
  REL_RDP(.t.)                                     // imprime rodape' do relatorio
 ENDD ccop
 EJEC                                              // salta pagina
END SEQUENCE
SET MARG TO                                        // coloca margem esquerda = 0
IMPCTL(lpp_066)                                    // seta pagina com 66 linhas
SET PRINTER TO (drvporta)                          // fecha arquivo gerado (se houver)
SET DEVI TO SCRE                                   // direciona saida p/ video
IF tps=2                                           // se vai para arquivo/video
 BROWSE_REL(arq_,2,3,MAXROW()-2,78)
ENDI                                               // mostra o arquivo gravado
GRELA(7)                                           // grava variacao do relatorio
SELE GUIAS                                         // salta pagina
SET RELA TO                                        // retira os relacionamentos
SET(_SET_DELETED,dele_atu)                         // os excluidos serao vistos
IF so_um_reg
 POINTER_DBF(sit_dbf)
ENDI
RETU

STATIC PROC REL_RDP(volta_reg)                     // rodape'
LOCAL reg_atual:=RECNO()
IF volta_reg
 GO ult_imp                                        // ajusta reg p/ imp de campos no rodape'
ENDI
@ 18,000 SAY "" //chr(15)                               // comprime
IMPCTL(drvpcom)
IF FILE([MENGUIA.MEM])
 REST FROM MENGUIA.MEM ADDITIVE
 @ 18,002 SAY M->rmens1
 @ 19,002 SAY M->rmens2
 cl:=19
 IF !EMPT(M->rmens3)
  cl++
  @ cl,002 SAY M->rmens3
 ENDI
 IF !EMPT(M->rmens4)
  cl++
  @ cl,002 SAY M->rmens4
 ENDI
 IF !EMPT(M->rmens5)
  cl++
  @ cl,000 SAY M->rmens5
 ENDI
ELSE
 @ 18,002 SAY [IMPORTANTE:- Esta guia tem a finalidade principal de encaminhamento em consultas e exames,]// Mensagem 1
 @ 19,002 SAY [N„o dando direito a cirurgias, interna‡”es, medicamentos entre outros.]// Mensagem 2
 @ 20,002 SAY [ - Esta guia tem validade de 30 dias ap¢s a emiss„o]// Mensagem 3
 @ 21,002 SAY [ - Esta guia s¢ ter  validade com o carimbo e assinatura do respons vel pela emiss„o.]// Mensagem 4
 @ 22,000 SAY "" //chr(18)                               // normal
ENDI
IMPCTL(drvtcom)

@ 23,001 SAY replicate('- ',36)                    // traco
IF volta_reg
 GO reg_atual                                      // retorna reg a posicao original
ENDI
RETU

STATIC PROC REL_CAB(qt, volta_reg)                 // cabecalho do relatorio
volta_reg=IF(volta_reg=NIL,.f.,volta_reg)
IF qt>0                                            // se parametro maior que 0
 cl=cl+qt                                          // soma no contador de linhas
ENDI
IF cl>maxli .OR. qt=0                              // quebra de pagina
 IF pg_>1
  REL_RDP(volta_reg)                               // imprime rodape' do relatorio
 ENDI
 IMPCTL(drvpenf)
 IMPEXP(0,000,LEFT(M->setup1,38),76)               // Setup1
 IMPCTL(drvtenf)
// @ 1,000 SAY M->defconv                            // Defconv
 @ 2,000 SAY M->setup2                             // setup2
 @ 3,000 SAY M->setup3                             // Setup3
 @ 4,000 SAY REPL("-",60)
 cl=qt+4 ; pg_++
ENDI
RETU

* \\ Final de CON_R001.PRG
FUNC R001GF9
RETURN ano+numero€
 ADR_ATR2–Ñ  ADR_ATR2CODEC_ETEXTENDCODE	_SYMSTARTSYMSTARTSYMBOLSSYMBOLS_SYMENDSYMENDNULLBEGDATA_DATADATA_SYMPBDATA_SYMPDATA_SYMPEDATA_CONSTCONST_MSGMSG_BEGBSSBEGBSS_BSSBSS_ENDBSSENDBSSDGROUPÞ˜ @>OŽ˜ H  ˜ h  ë˜ `p 	˜ h  
ã˜ h  ß˜ H  û˜ H  ÷˜ H ë˜ H  ï˜ H  ë˜ (  ˜ H        SIxMemo                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 procedure adm_r021
/*
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
 \ Empresa.: PresServ Inform tica - Limeira (019)452.6623
 \ Programa: ADM_R021.PRG
 \ Data....: 04-11-03
 \ Sistema.: Administradora - RECEP€„O
 \ Funcao..: Processar Pgto em
 \ Analista: Ademilson Pedro Bom
 \ Criacao.: GAS-Pro v4.0n
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/

#include "adrbig.ch"    // inicializa constantes manifestas

PRIV dele_atu, cur_atual, getlist:={}
PARA lin_menu, col_menu
PRIV  tem_borda:=.t., op_menu:=VAR_COMPL, l_s:=10, c_s:=20, l_i:=13, c_i:=61, tela_fundo:=SAVESCREEN(0,0,MAXROW(),79)
nucop=1
SETCOLOR(drvtittel)
vr_memo=NOVAPOSI(@l_s,@c_s,@l_i,@c_i)     // pega posicao atual da tela
CAIXA(mold,l_s,c_s,l_i,c_i)               // monta caixa da tela
@ l_s,c_s+12 SAY " PROCESSAR PGTO EM "
SETCOLOR(drvcortel)
@ l_s+01,c_s+1 SAY " Data Inicial:"
@ l_s+02,c_s+1 SAY " Data Final..:"
PRIV data1_:=CTOD('')                              // Data Inicial
PRIV data2_:=CTOD('')                              // Data Final
DO WHILE .t.
 rola_t=.f.
 cod_sos=56
 SET KEY K_ALT_F8 TO ROLATELA
 SETCOLOR(drvcortel+","+drvcorget+",,,"+corcampo)
 @ l_s+01 ,c_s+16 GET  data1_;
                  PICT "@D";
                  VALI CRIT("!EMPT(data1_)~Necess rio informar DATA INICIAL")
                  AJUDA "Considerar a partir de..."

 @ l_s+02 ,c_s+16 GET  data2_;
                  PICT "@D";
                  VALI CRIT("!EMPT(data2_)~Necess rio informar DATA FINAL")
                  AJUDA "At‚ a data ..."

 READ
 SET KEY K_ALT_F8 TO
 IF rola_t
  ROLATELA(.f.)
  LOOP
 ENDI
 IF LASTKEY()=K_ESC                                // se quer cancelar
  RETU                                             // retorna
 ENDI

 #ifdef COM_REDE
  IF !USEARQ("AFUNER",.f.,10,1)                    // se falhou a abertura do arq
   RETU                                            // volta ao menu anterior
  ENDI
 #else
  USEARQ("AFUNER")                                 // abre o dbf e seus indices
 #endi

 titrel:=criterio := ""                            // inicializa variaveis
 cpord="DTOS(procpagto_)"
 chv_rela:=chv_1:=chv_2 := ""
 tps:=op_x:=ccop := 1
 fil_ini=""
 IF !opcoes_rel(lin_menu,col_menu,7,11,fil_ini)    // nao quis configurar...
  CLOS ALL                                         // fecha arquivos e
  LOOP                                             // volta ao menu
 ENDI
 IF tps=2                                          // se vai para arquivo/video
  arq_=ARQGER()                                    // entao pega nome do arquivo
  IF EMPTY(arq_)                                   // se cancelou ou nao informou
   LOOP                                            // retorna
  ENDI
 ELSE
  arq_=drvporta                                    // porta de saida configurada
 ENDI
 IF "4WIN"$UPPER(drvmarca) // nome da configuracao/marca impressora
    arq_:=drvdbf+"WIN"+ide_maq
    tps:=3                                          // se vai para arquivo/video
 ENDIF
 SET PRINTER TO (arq_)                             // redireciona saida
 EXIT
ENDD
cur_atual=SETCURSOR(0)
dele_atu:=SET(_SET_DELETED,.t.)                    // os excluidos nao servem...
POE_GAUGE("[ESC] Interrompe","AGUARDE...","Emitidos:")
SET DEVI TO PRIN                                   // inicia a impressao
maxli=62                                           // maximo de linhas no relatorio
hora_rel_=LEFT(TIME(),5)                           // hora de emissao do relatorio
BEGIN SEQUENCE
 DO WHIL ccop<=nucop                               // imprime qde copias pedida
  pg_=1; cl=50000
  INI_ARQ()                                        // acha 1o. reg valido do arquivo
  IF EOF()
   EXIT
  ENDI
  ccop++                                           // incrementa contador de copias
  qqu018=0                                         // contador de registros
  DO WHIL !EOF().AND.POE_GAUGE()
   IF IN_KEY()=K_ESC                               // se quer cancelar
    IF canc()                                      // pede confirmacao
     BREAK                                         // confirmou...
    ENDI
   ENDI
   IF procpagto_>=M->data1_.AND.procpagto_<=M->data2_// se atender a condicao...
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY TRAN(processo+proc2+filial,"@R 99999/99/!!")   // Processo
    @ cl,012 SAY TRAN(procpagto_,"@D")             // Proc.Pgto em
    @ cl,023 SAY TRAN(vlauxilio,"9999999.99")  // Valor Auxilio
    @ cl,038 SAY TRAN(falecido,"@!")               // Nome do falecido
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,011 SAY TRAN(nomedec,"@!")                // Nome
    @ cl,053 SAY TRAN(contrato,"@R 999.999999")           // Contrato
    @ cl,065 SAY TRAN(pagtoem_,"@D")               // Pago em
    qqu018++                                       // soma contadores de registros
    SKIP                                           // pega proximo registro
   ELSE                                            // se nao atende condicao
    SKIP                                           // pega proximo registro
   ENDI
  ENDD
  REL_CAB(2)                                       // soma cl/imprime cabecalho
  @ cl,000 SAY "*** Quantidade total "+TRAN(qqu018,"@E 999,999")
 ENDD ccop
 EJEC                                              // salta pagina
END SEQUENCE
SETCURSOR(cur_atual)
SET PRINTER TO (drvporta)                          // fecha arquivo gerado (se houver)
SET DEVI TO SCRE                                   // direciona saida p/ video
IF tps=2                                           // se vai para arquivo/video
 BROWSE_REL(arq_,2,3,MAXROW()-2,78)
ENDI          // mostra o arquivo gravado
GRELA(7)                                           // grava variacao do relatorio
SET(_SET_DELETED,dele_atu)                         // os excluidos serao vistos
RETU

STATIC PROC REL_CAB(qt)                            // cabecalho do relatorio
IF qt>0                                            // se parametro maior que 0
 cl=cl+qt                                          // soma no contador de linhas
ENDI
IF cl>maxli .OR. qt=0                              // quebra de pagina
 IMPAC(nemp,0,000)                                 // nome da empresa
 @ 0,065 SAY "PAG"
 @ 0,069 SAY TRAN(pg_,'9999')                      // n£mero da p gina
 IMPAC(nsis,1,000)                                 // t¡tulo aplica‡„o
 @ 1,065 SAY "ADM_R021"                            // c¢digo relat¢rio
 @ 2,000 SAY titrel                                // t¡tulo a definir
 @ 2,058 SAY DTOC(DATE())                          // data do sistema
 @ 2,068 SAY hora_rel_                             // hora da emiss„o
 @ 3,000 SAY "Processo Proc.Pgto em  Valor Auxilio  Nome do falecido"
 @ 4,011 SAY "Nome do Declarante                       Contrato   Pago em"
 @ 5,000 SAY REPL("-",73)
 cl=qt+5 ; pg_++
ENDI
RETU

* \\ Final de ADM_R021.PRG
procedure bxrec
/*
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
 \ Empresa.: PresServ Inform tica - Limeira (019)452.6623
 \ Programa: BXREC.PRG
 \ Data....: 04-11-03
 \ Sistema.: Administradora - RECEP€„O
 \ Funcao..: Gerenciador do subsistema de recebimentos
 \ Analista: Ademilson Pedro Bom
 \ Criacao.: GAS-Pro v4.0n
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/

#include "adrbig.ch"    // inicializa constantes manifestas

PARA lin_menu,col_menu
PRIV op_sis, tela_fundo:=SAVESCREEN(0,0,MAXROW(),79), l_s, c_s, l_i, c_i, l_a

op_sis=EVAL(qualsis,"BXREC")
IF nivelop<sistema[op_sis,O_OUTROS,O_NIVEL]        // se usuario nao tem permissao,
 ALERTA()                                          // entao, beep, beep, beep
 DBOX(msg_auto,,,3)                                // lamentamos e
 RETU                                              // retornamos ao menu
ENDI
cn:=fgrep :=.f.

#ifdef COM_LOCK
 IF LEN(pr_ok)>0                                   // se a protecao acusou
  ? pr_ok                                          // erro, avisa e
  QUIT                                             // encerra a aplicacao
 ENDI
#endi

t_fundo=SAVESCREEN(0,0,MAXROW(),79)                // salva tela do fundo
op_cad=1
DO WHIL op_cad!=0
 criterio=""
 RESTSCREEN(0,0,MAXROW(),79,t_fundo)               // restaura tela do fundo
 cod_sos=5 ; cn=.f.
 CLEA TYPEAHEAD                                    // limpa o buffer do teclado
 fgrep=.f.
 SET KEY K_F3 TO                                   // retira das teclas F3 e F4 as
 SET KEY K_F4 TO                                   // funcoes de repeticao e confirmacao
 if nivelop>2
  msg="Inclus„o~1|"+;
     "Manuten‡„o~2|"+;
     "Consulta~3"
  op_cad=DBOX(msg,lin_menu,col_menu,E_MENU,NAO_APAGA,MAIUSC(sistema[op_sis,O_MENU]),,,op_cad)
 else
  op_cad=1
 endif
 IF op_cad!=0                                      // se escolheu uma opcao
  Tela_fundo=SAVESCREEN(0,0,MAXROW(),79)           // salva a tela para ROLATELA()
  PARAMETROS(dbfparam)
  SELE A                                           // e abre o arquivo e seus indices

  #ifdef COM_REDE
   IF !USEARQ(sistema[op_sis,O_ARQUI,O_NOME],.f.,20,1)
						   // se falhou a abertura do
    RETU                                           // arquivo volta ao menu anterior
   ENDI
  #else
   USEARQ(sistema[op_sis,O_ARQUI,O_NOME])
  #endi

  SET KEY K_F9 TO veoutros                         // habilita consulta em outros arquivos
  Vinscr:=[]
  SET KEY K_F2 TO veinscrits()                         // habilita consulta em outros arquivos
 ENDI
 DO CASE
  CASE op_cad=01                                   // inclus„o
   op_menu=INCLUSAO
   IF AT("D",exrot[op_sis])=0                      // se usuario pode fazer inclusao
    BXR_INCL()                                     // neste arquivo chama prg de inclusao
   ELSE                                            // caso contrario vamos avisar que
    ALERTA()                                       // ele nao tem permissao para isto
    DBOX(msg_auto,,,3)
   ENDI

  CASE op_cad=02                                   // manuten‡„o
   op_menu=ALTERACAO
   cod_sos=7
   EDIT()

  CASE op_cad=03                                   // consulta
   op_menu=PROJECOES
   cod_sos=8
   EDITA(03,03,MAXROW()-2,77)

 ENDC
 SET KEY K_F9 TO                                   // F9 nao mais consultara outros arquivos
 set key K_F2 TO
 CLOS ALL                                          // fecha todos arquivos abertos
 exit
ENDD
RETU

PROC BXR_incl(reg_cop)  // inclusao no arquivo BXREC
LOCAL getlist:={},cabem:=1,rep:=ARRAY(FCOU()),ult_reg:=RECN(),cond_incl_,dbfseq_,;
      ctl_r, ctl_c, ctl_w, t_f3_, t_f4_, dele_atu:=SET(_SET_DELETED,.f.)
PRIV op_menu:=INCLUSAO, sq_atual_, tem_borda, criterio:="", cpord:=""
cond_incl_={||nivelop>1}                           // condicao de inclusao de registros
IF !EVAL(cond_incl_)                               // se nao pode incluir
 ALERTA(2)                                         // avisa o motivo
 DBOX("Permitido apenas a usu rios cadastrados|com n¡vel de Manuten‡„o ou Maior",,,4,,"ATEN€ŽO, "+usuario)
 RETU                                              // e retorna
ENDI
FOR i=1 TO FCOU()                                  // cria/declara privadas as
 msg=FIEL(i)                                       // variaveis de memoria com
 PRIV &msg.                                        // o mesmo nome dos campos
NEXT                                               // do arquivo
IF reg_cop!=NIL                                    // quer repetir todo o reg atual
 FOR i=1 TO FCOU()                                 // para cada campo,
  msg=FIEL(i)                                      // salva o conteudo
  rep[i]=&msg.                                     // para repetir
 NEXT
ELSE
 AFILL(rep,"")                                     // eche com valor vazio
ENDI
t_f3_=SETKEY(K_F3,{||rep()})                       // repeticao reg anterior
t_f4_=SETKEY(K_F4,{||conf()})                      // confirma campos com ENTER
ctl_w=SETKEY(K_CTRL_W,{||nadafaz()})               // enganando o CA-Clipper...
ctl_c=SETKEY(K_CTRL_C,{||nadafaz()})
ctl_r=SETKEY(K_CTRL_R,{||nadafaz()})

#ifdef COM_REDE
 BXR_CRIA_SEQ()                                    // cria dbf de controle de cp sequenciais
 FOR i=1 TO FCOU()                                 // cria/declara privadas as
  msg="sq_"+FIEL(i)                                // variaveis de memoria com
  PRIV &msg.                                       // o mesmo nome dos campos
 NEXT                                              // do arquivo com extensao _seq
#endi

DO WHIL cabem>0
 cod_sos=6
 rola_t=.f.                                        // flag se quer rolar a tela
 SELE BXREC
 GO BOTT                                           // forca o
 SKIP                                              // final do arquivo
 
 /*
    cria variaveis de memoria identicas as de arquivo, para inclusao
    de registros
 */
 FOR i=1 TO FCOU()
  msg=FIEL(i)
  M->&msg.=IF((fgrep .OR. reg_cop!=NIL).AND.!EMPT(rep[1]),rep[i],&msg.)
 NEXT
 DISPBEGIN()                                       // apresenta a tela de uma vez so
 BXR_TELA()
 INFOSIS(.t.)                                      // exibe informacao no rodape' da tela
 DISPEND()
 BXR_GERA_SEQ()
 IF !EVAL(cond_incl_)
  EXIT
 ENDI
 cabem=DISKSPACE(;
          IF(;
             LEN(sistema[op_sis,O_ARQUI,O_DIR_DBF])<2.OR.sistema[op_sis,O_ARQUI,O_DIR_DBF]="\",;
             0,;
             ASC(sistema[op_sis,O_ARQUI,O_DIR_DBF])-64;
          );
       )
 cabem=INT((cabem-2048)/BXREC->(RECSIZE()))
 IF cabem<1                                        // mais nenhum!!!
  ALERTA()
  msg="Verifique ESPA€O EM DISCO, "+usuario
  DBOX(msg,,,,,"INCLUSŽO INTERROMPIDA!")           // vamos parar por aqui!
  EXIT
 ENDI
 SELE 0                                            // torna visiveis variaveis de memoria
 BXR_GET1(INCLUI)                                  // recebe campos
 SELE BXREC
 IF LASTKEY()=K_ESC                                // se cancelou
  cabem=0                                          // prepara saida da inclusao
  LOOP
 ENDI

 #ifdef COM_REDE
  GO BOTT                                          // vamos bloquear o final do
  SKIP                                             // arq para que nehum outro
  BLOREG(0,.5)                                     // usuario possa incluir
 #endi

 APPEND BLANK                                      // inclui reg em branco no dbf
 FOR i=1 TO FCOU()                                 // para cada campo,
  msg=FIEL(i)                                      // salva o conteudo
  rep[i]=M->&msg.                                  // para repetir
  REPL &msg. WITH rep[i]                           // enche o campo do arquivo
 NEXT

 #ifdef COM_REDE
  UNLOCK                                           // libera o registro e
  COMMIT                                           // forca gravacao
 #else
  IF RECC()-INT(RECC()/20)*20=0                    // a cada 20 registros
   COMMIT                                          // digitados forca gravacao
  ENDI
 #endi

 ult_reg=RECN()                                    // ultimo registro digitado
 BXR_REL(ult_reg)                               // imprime relat apos inclusao
 IF reg_cop!=NIL                                   // estava na consulta e quis rep o campo
  sq_atual_=NIL
  EXIT                                             // cai fora...
 ENDI
ENDD

#ifdef COM_REDE
 BXR_ANT_SEQ()                                     // restaura sequencial anterior
 SELE BXREC
#endi

GO ult_reg                                         // para o ultimo reg digitado
SETKEY(K_F3,t_f3_)                                 // restaura teclas de funcoes
SETKEY(K_F4,t_f4_)
SET(_SET_DELETED,dele_atu)                            // ecluidos visiveis/invisiveis
SETKEY(K_CTRL_W,ctl_w)
SETKEY(K_CTRL_C,ctl_c)
SETKEY(K_CTRL_R,ctl_r)
RETU


PROC BXR_REL(ult_reg)  // imprime relatorio apos inclusao
LOCAL p_imp:=.t., i_ok:=.f., imp_rel:=.f.
DO WHIL .t.
 SAVE SCREEN                     // salva a tela

 #ifdef COM_REDE
  tps=TP_SAIDA(,,.t.)
  IF LASTKEY()=K_ESC
   EXIT
  ENDI
  i_ok=(tps=2 .OR. PREPIMP("TAXAS (RECEP€ŽO)"))
  IF i_ok
   ADM_RS18(tps,0,ult_reg)
   imp_rel=.t.
  ENDI
 #else
  i_ok=PREPIMP("TAXAS (RECEP€ŽO)")
  IF i_ok
   ADM_RS18(0,0,ult_reg)
   imp_rel=.t.
  ENDI
 #endi

 REST SCREEN                    // restaura tela
 IF imp_rel                     // imprimiu algo?
  msg="Prosseguir|Outra c¢pia"
  op_=1 //DBOX(msg,,,E_MENU,,"FIM DE IMPRESSŽO") // quer emitir outra copia?
  IF op_=2
   LOOP                         // nao quer...
  ENDI
 ENDI
 EXIT
ENDD
RETU


#ifdef COM_REDE
 PROC BXR_ANT_SEQ(est_seq)     // restaura sequencial anterior
 SELE BXR_SEQ     // seleciona arquivo de controle de sequencial
 BLOARQ(0,.5)     // esta estacao foi a ultima a incluir?
 IF sq_atual_ == numero
  REPL numero WITH sq_numero
  REPL intlan WITH sq_intlan
 ENDI
 UNLOCK           // libera DBF para outros usuarios
 COMMIT           // atualiza cps sequenciais no disco
 RETU
#endi


PROC BXR_CRIA_SEQ   // cria dbf de controle de campos sequenciais
LOCAL dbfseq_:=sistema[op_sis,O_ARQUI,O_DIR_DBF]+"BXR_seq" // arq temporario
SELE 0                          // seleciona area vazia
IF !FILE(dbfseq_+".dbf")        // se o dbf nao existe
 DBCREATE(dbfseq_,{;            // vamos criar a sua estrutura
                    {"numero"    ,"C",  8, 0},;
                    {"intlan"    ,"C",  8, 0};
                  };
 )
ENDI
USEARQ(dbfseq_,.f.,,,.f.)       // abre arquivo de cps sequencial
IF RECC()=0                     // se o dbf foi criado agora
 BLOARQ(0,.5)                   // inclui um registro que tera
 APPEND BLANK                   // os ultomos cps sequenciais
 SELE BXREC
 IF RECC()>0                    // se o DBF nao estiver
  SET ORDER TO 0                // vazio, entao enche DBF seq
  GO BOTT                       // com o ultimo reg digitado
  REPL BXR_SEQ->numero WITH numero
  REPL BXR_SEQ->intlan WITH intlan
  DBSETORDER(1)                 // retorna ao indice principal
 ENDI
 SELE BXR_SEQ                   // seleciona arq de sequencias
 UNLOCK                         // libera DBF para outros usuarios
 COMMIT                         // atualiza cps sequenciais no disco
ENDI
RETURN

PROC BXR_GERA_SEQ()

#ifdef COM_REDE
 LOCAL ar_:=SELEC()
#else
 LOCAL reg_:=RECNO(),ord_ind:=INDEXORD()
#endi


#ifdef COM_REDE
 SELE BXR_SEQ
 BLOARQ(0,.5)
 sq_numero=BXR_SEQ->numero
 sq_intlan=BXR_SEQ->intlan
#else
 DBSETORDER(0)
 GO BOTT
#endi

M->numero=LPAD(STR(VAL(numero)+1),08,[0])
IF VAL(M->numero)=1
 M->numero=LPAD(RIGHT(DTOC(DATE()),2)+[000001],08,[0])
ENDI
M->intlan=LPAD(STR(VAL(intlan)+1),08,[0])

#ifdef COM_REDE
 BXR_GRAVA_SEQ()
 sq_atual_=BXR_SEQ->numero
 UNLOCK                                            // libera o registro
 COMMIT
 SELE (ar_)
#else
 DBSETORDER(ord_ind)
 GO reg_
#endi

RETU

PROC BXR_GRAVA_SEQ
REPL numero WITH M->numero
REPL intlan WITH M->intlan
RETU

PROC BXR_tela     // tela do arquivo BXREC
tem_borda=.t.
l_s=Sistema[op_sis,O_TELA,O_LS]           // coordenadas da tela
c_s=Sistema[op_sis,O_TELA,O_CS]
l_i=Sistema[op_sis,O_TELA,O_LI]
c_i=Sistema[op_sis,O_TELA,O_CI]
SETCOLOR(drvtittel)
vr_memo=NOVAPOSI(@l_s,@c_s,@l_i,@c_i)     // pega posicao atual da tela
CAIXA(mold,l_s,c_s,l_i,c_i)               // monta caixa da tela
i=LEN(sistema[op_sis,O_MENS])/2
@ l_s,c_s-1+(c_i-c_s+1)/2-i SAY " "+MAIUSC(sistema[op_sis,O_MENS])+" "
SETCOLOR(drvcortel)
@ l_s+01,c_s+1 SAY " Numero:"
@ l_s+02,c_s+1 SAY " Contrato:"
@ l_s+03,c_s+1 SAY "ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ"
@ l_s+04,c_s+1 SAY "                                      ³Circulares"
@ l_s+05,c_s+1 SAY "                                      ³ Ini"
@ l_s+06,c_s+1 SAY "                            Reg.:     ³  £lt"
@ l_s+07,c_s+1 SAY "                                      ³"
@ l_s+08,c_s+1 SAY " Admiss„o:            Sai Taxa:       ³"
@ l_s+09,c_s+1 SAY " Funerais:     Cobrador: "
@ l_s+10,c_s+1 SAY "ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ"
@ l_s+15,c_s+1 SAY "ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ"
@ l_s+16,c_s+1 SAY " Ref.:                       Vl.Pago:"
@ l_s+17,c_s+1 SAY " Pago com..:             Troco:"
@ l_s+19,c_s+1 SAY "  emitida em             por"
RETU

PROC BXR_gets     // mostra variaveis do arquivo BXREC
LOCAL getlist := {}, ord_, chv_, ar_get1:=ALIAS(), op_ant := op_menu
BXR_TELA()
SETCOLOR(drvcortel+","+drvcorget+",,,"+corcampo)
PTAB(CODIGO,[GRUPOS])
PTAB(IIF(EMPT(M->USUARIO),PADR(M->CONTAREC+IDE_MAQ,10,' '),PADR(M->USUARIO,10,' '))+M->HISTRCFCC+[       ],'ORDPGRC',2)
PTAB(PADR(SUBSTR(M->IDE_MAQ,2),4)+[BXR],[IMPPAR],1)
CRIT("",,"16")
@ l_s+01 ,c_s+12 GET  numero;
		 PICT sistema[op_sis,O_CAMPO,01,O_MASC]

@ l_s+02 ,c_s+12 GET  codigo;
                 PICT sistema[op_sis,O_CAMPO,02,O_MASC]
                 CRIT(sistema[op_sis,O_CAMPO,02,O_CRIT],,"1|2|3|4|5|6|7|8|9|10|11|12|13|14")

@ l_s+16 ,c_s+08 GET  cobranca;
                 PICT sistema[op_sis,O_CAMPO,03,O_MASC]

@ l_s+16 ,c_s+39 GET  valorpg;
                 PICT sistema[op_sis,O_CAMPO,04,O_MASC]

@ l_s+17 ,c_s+14 GET  valoraux;
                 PICT sistema[op_sis,O_CAMPO,05,O_MASC]
                 CRIT(sistema[op_sis,O_CAMPO,05,O_CRIT],,"15")

@ l_s+19 ,c_s+14 GET  emitido_;
                 PICT sistema[op_sis,O_CAMPO,06,O_MASC]

@ l_s+19 ,c_s+30 GET  por

@ l_s+19 ,c_s+44 GET  numop;
                 PICT sistema[op_sis,O_CAMPO,08,O_MASC]

CRIT("",,"1|3|4|5|6|7|8|9|10|11|12|13|14")
CLEAR GETS
RETU

PROC BXR_get1(tp_mov)     // capta variaveis do arquivo BXREC
LOCAL getlist := {}, ord_, chv_, ar_get1:=ALIAS(), op_ant := op_menu
PRIV  blk_bxrec:=.t.

IF tp_mov=INCLUI
 DO WHILE .t.
  rola_t=.f.
  SET KEY K_ALT_F8 TO ROLATELA
  SETCOLOR(drvcortel+","+drvcorget+",,,"+corcampo)
  @ l_s+01 ,c_s+12 GET numero;
                   PICT sistema[op_sis,O_CAMPO,01,O_MASC]
  @ l_s+19 ,c_s+14 GET emitido_;
		   PICT sistema[op_sis,O_CAMPO,06,O_MASC]
  @ l_s+19 ,c_s+30 GET por
  @ l_s+19 ,c_s+44 GET numop;
                   PICT sistema[op_sis,O_CAMPO,08,O_MASC]
  CLEA GETS
  CRIT("",,"16")
  @ l_s+02 ,c_s+12 GET  codigo;
                   PICT sistema[op_sis,O_CAMPO,02,O_MASC]
                   DEFINICAO 2
                   MOSTRA sistema[op_sis,O_FORMULA,1]
                   MOSTRA sistema[op_sis,O_FORMULA,2]
                   MOSTRA sistema[op_sis,O_FORMULA,3]
                   MOSTRA sistema[op_sis,O_FORMULA,4]
                   MOSTRA sistema[op_sis,O_FORMULA,5]
                   MOSTRA sistema[op_sis,O_FORMULA,6]
                   MOSTRA sistema[op_sis,O_FORMULA,7]
                   MOSTRA sistema[op_sis,O_FORMULA,8]
                   MOSTRA sistema[op_sis,O_FORMULA,9]
                   MOSTRA sistema[op_sis,O_FORMULA,10]
                   MOSTRA sistema[op_sis,O_FORMULA,11]
		   MOSTRA sistema[op_sis,O_FORMULA,12]
                   MOSTRA sistema[op_sis,O_FORMULA,13]
                   MOSTRA sistema[op_sis,O_FORMULA,14]

  @ l_s+16 ,c_s+08 GET  cobranca;
                   PICT sistema[op_sis,O_CAMPO,03,O_MASC]
                   DEFINICAO 3

  @ l_s+16 ,c_s+39 GET  valorpg;
                   PICT sistema[op_sis,O_CAMPO,04,O_MASC]
                   DEFINICAO 4

  @ l_s+17 ,c_s+14 GET  valoraux;
                   PICT sistema[op_sis,O_CAMPO,05,O_MASC]
                   DEFINICAO 5
                   MOSTRA sistema[op_sis,O_FORMULA,15]

  READ
  SET KEY K_ALT_F8 TO
  IF rola_t
   ROLATELA()
   LOOP
  ENDI
  IF LASTKEY()!=K_ESC .AND. drvincl .AND. op_menu=INCLUSAO
   IF !CONFINCL()
    LOOP
   ENDI
  ENDI
  EXIT
 ENDD
ENDI
PTAB(CODIGO,[GRUPOS])
PTAB(LEFT(COBRANCA,15),'TAXAS',1)
PTAB(IIF(EMPT(M->USUARIO),PADR(M->CONTAREC+IDE_MAQ,10,' '),PADR(M->USUARIO,10,' '))+M->HISTRCFCC+[       ],'ORDPGRC',2)
PTAB(PADR(SUBSTR(M->IDE_MAQ,2),4)+[BXR],[IMPPAR],1)
IF tp_mov=EXCLUI .OR. tp_mov=FORM_INVERSA

 #ifdef COM_REDE
  IF EMPT(numop)
   IF !EMPTY(ALIAS())
    REPL numop WITH ORDPGRC->numop
   ENDI
  ENDI
  IF PTAB(numop,'ORDPGRC',1)
   REPBLO('ORDPGRC->nrdoctos',{||ORDPGRC->nrdoctos - 1})
  ENDI
  IF !EMPT(valorpg)
   REPBLO('TAXAS->pgto_',{||CTOD('')})
   REPBLO('TAXAS->forma',{||[ ]})
   REPBLO('TAXAS->baixa_',{||CTOD('  /  /  ')})
   REPBLO('TAXAS->stat',{||[ ]})
   REPBLO('TAXAS->valorpg',{||0})
  ENDI
  IF EMPT(numop).AND.PTAB(IIF(EMPT(M->usuario),PADR(M->contarec+ide_maq,10,' '),PADR(M->usuario,10,' '))+M->histrcfcc+[       ],'ORDPGRC',2)
   REPBLO('ORDPGRC->valortotal',{||ORDPGRC->valortotal-valorpg})
  ENDI
  IF !EMPT(numop).AND.PTAB(numop,'ORDPGRC',1)
   REPBLO('ORDPGRC->valortotal',{||ORDPGRC->valortotal -valorpg})
  ENDI
 #else
  IF EMPT(numop)
   IF !EMPTY(ALIAS())
    REPL numop WITH ORDPGRC->numop
   ENDI
  ENDI
  IF PTAB(numop,'ORDPGRC',1)
   REPL ORDPGRC->nrdoctos WITH ORDPGRC->nrdoctos - 1
  ENDI
  IF !EMPT(valorpg)
   REPL TAXAS->pgto_ WITH CTOD('')
   REPL TAXAS->forma WITH [ ]
   REPL TAXAS->baixa_ WITH CTOD('  /  /  ')
   REPL TAXAS->stat WITH [ ]
   REPL TAXAS->valorpg WITH 0
  ENDI
  IF EMPT(numop).AND.PTAB(IIF(EMPT(M->usuario),PADR(M->contarec+ide_maq,10,' '),PADR(M->usuario,10,' '))+M->histrcfcc+[       ],'ORDPGRC',2)
   REPL ORDPGRC->valortotal WITH ORDPGRC->valortotal-valorpg
  ENDI
  IF !EMPT(numop).AND.PTAB(numop,'ORDPGRC',1)
   REPL ORDPGRC->valortotal WITH ORDPGRC->valortotal -valorpg
  ENDI
 #endi

 IF 1=3
  IF !EMPTY(ORDPGRC->codlan)
   TIRA_LANC("ORDPGRC",LEFT(ORDPGRC->codlan,16),.f.)
  ENDI
 ENDI
 IF 1=3
  IF !EMPTY(IMPPAR->codlan)
   TIRA_LANC("IMPPAR",LEFT(IMPPAR->codlan,16))
  ENDI
 ENDI
 IF !EMPTY(ALIAS())
  DELE
 ENDI
ELSEIF tp_mov=INCLUI .OR. tp_mov=RECUPERA .OR. tp_mov=FORM_DIRETA
 IF (op_menu=INCLUSAO .AND. LASTKEY()!=K_ESC) .OR. op_menu!=INCLUSAO
  IF !EMPT(valorpg).AND. !PTAB(IIF(EMPT(M->usuario),PADR(M->contarec+ide_maq,10,' '),PADR(M->usuario,10,' '))+M->histrcfcc+[       ],'ORDPGRC',2)
   ord_=LEN(sistema[EVAL(qualsis,"ORDPGRC"),O_CHAVE])
   IF !EMPTY(ORDPGRC->codlan)
    chv_=LEFT(ORDPGRC->codlan,16)
   ELSE
    IF TYPE("M->intlan")="C" .AND. EMPTY(intlan)
     chv_="BXR-"+M->intlan+"-001"
    ELSE
     chv_="BXR-"+intlan+"-001"
    ENDI
   ENDI
   PTAB(chv_,"ORDPGRC",ord_)
   FAZ_LANC("ORDPGRC",chv_,.t.)
   REPL ORDPGRC->origem WITH [ADM],;
        ORDPGRC->lancto_ WITH DATE(),;
        ORDPGRC->por WITH M->usuario,;
        ORDPGRC->numconta WITH IIF(EMPT(M->usuario),PADR(M->contarec+ide_maq,10,' '),PADR(M->usuario,10,' ')),;
        ORDPGRC->historico WITH M->histrcfcc,;
        ORDPGRC->debcred WITH [C],;
        ORDPGRC->valortotal WITH 0,;
        ORDPGRC->vencto_ WITH DATE(),;
        ORDPGRC->documento WITH [FCC/Taxas],;
	ORDPGRC->complement WITH [FCC/Taxas pagas na Recep‡„o]

   #ifdef COM_REDE
    ORDPGRC->(DBUNLOCK())                          // libera o registro
   #endi

  ENDI
  IF !PTAB(PADR(SUBSTR(M->ide_maq,2),4)+[BXR],[IMPPAR],1)
   ord_=LEN(sistema[EVAL(qualsis,"IMPPAR"),O_CHAVE])
   IF !EMPTY(IMPPAR->codlan)
    chv_=LEFT(IMPPAR->codlan,16)
   ELSE
    IF TYPE("M->intlan")="C" .AND. EMPTY(intlan)
     chv_="BXR-"+M->intlan+"-002"
    ELSE
     chv_="BXR-"+intlan+"-002"
    ENDI
   ENDI
   PTAB(chv_,"IMPPAR",ord_)
   FAZ_LANC("IMPPAR",chv_)
   REPL IMPPAR->idmaq WITH PADR(SUBSTR(M->ide_maq,2),4),;
        IMPPAR->base WITH [BXR]

   #ifdef COM_REDE
    IMPPAR->(DBUNLOCK())                           // libera o registro
   #endi

  ENDI
   IF EMPT(numop)
    IF op_menu=INCLUSAO
     numop=ORDPGRC->numop
    ELSE
     REPL numop WITH ORDPGRC->numop
    ENDI
   ENDI

  #ifdef COM_REDE
   IF PTAB(numop,'ORDPGRC',1)
    REPBLO('ORDPGRC->nrdoctos',{||ORDPGRC->nrdoctos + 1})
   ENDI
   IF !EMPT(valorpg)
    REPBLO('TAXAS->pgto_',{||DATE()})
   ENDI
   IF !EMPT(valorpg)
    REPBLO('TAXAS->forma',{||[P]})
   ENDI
   IF !EMPT(valorpg)
    REPBLO('TAXAS->baixa_',{||DATE()})
   ENDI
   IF !EMPT(valorpg)
    REPBLO('TAXAS->por',{||M->usuario})
   ENDI
   IF !EMPT(valorpg)
    REPBLO('TAXAS->stat',{||[6]})
   ENDI
   IF !EMPT(valorpg)
    REPBLO('TAXAS->valorpg',{||valorpg})
   ENDI
   IF op_menu=INCLUSAO
    emitido_=DATE()
   ELSE
    REPL emitido_ WITH DATE()
   ENDI
   IF op_menu=INCLUSAO
    por=M->usuario
   ELSE
    REPL por WITH M->usuario
   ENDI
   IF op_menu=INCLUSAO
    filial=M->p_filial
   ELSE
    REPL filial WITH M->p_filial
   ENDI
   IF EMPT(numop).AND.PTAB(IIF(EMPT(M->usuario),PADR(M->contarec+ide_maq,10,' '),PADR(M->usuario,10,' '))+M->histrcfcc+[       ],'ORDPGRC',2)
    REPBLO('ORDPGRC->valortotal',{||ORDPGRC->valortotal+valorpg})
   ENDI
   IF !EMPT(numop).AND.PTAB(numop,'ORDPGRC',1)
    REPBLO('ORDPGRC->valortotal',{||ORDPGRC->valortotal +valorpg})
   ENDI
   IF PTAB(PADR(SUBSTR(M->ide_maq,2),4)+[BXR],[IMPPAR],1)
    REPBLO('IMPPAR->docto',{||numero})
   ENDI
  #else
   IF EMPT(numop)
    IF op_menu=INCLUSAO
     numop=ORDPGRC->numop
    ELSE
     REPL numop WITH ORDPGRC->numop
    ENDI
   ENDI
   IF PTAB(numop,'ORDPGRC',1)
    REPL ORDPGRC->nrdoctos WITH ORDPGRC->nrdoctos + 1
   ENDI
   IF !EMPT(valorpg)
    REPL TAXAS->pgto_ WITH DATE()
   ENDI
   IF !EMPT(valorpg)
    REPL TAXAS->forma WITH [P]
   ENDI
   IF !EMPT(valorpg)
    REPL TAXAS->baixa_ WITH DATE()
   ENDI
   IF !EMPT(valorpg)
    REPL TAXAS->por WITH M->usuario
   ENDI
   IF !EMPT(valorpg)
    REPL TAXAS->stat WITH [6]
   ENDI
   IF !EMPT(valorpg)
    REPL TAXAS->valorpg WITH valorpg
   ENDI
   IF op_menu=INCLUSAO
    emitido_=DATE()
   ELSE
    REPL emitido_ WITH DATE()
   ENDI
   IF op_menu=INCLUSAO
    por=M->usuario
   ELSE
    REPL por WITH M->usuario
   ENDI
   IF op_menu=INCLUSAO
    filial=M->p_filial
   ELSE
    REPL filial WITH M->p_filial
   ENDI
   IF EMPT(numop).AND.PTAB(IIF(EMPT(M->usuario),PADR(M->contarec+ide_maq,10,' '),PADR(M->usuario,10,' '))+M->histrcfcc+[       ],'ORDPGRC',2)
    REPL ORDPGRC->valortotal WITH ORDPGRC->valortotal+valorpg
   ENDI
   IF !EMPT(numop).AND.PTAB(numop,'ORDPGRC',1)
    REPL ORDPGRC->valortotal WITH ORDPGRC->valortotal +valorpg
   ENDI
   IF PTAB(PADR(SUBSTR(M->ide_maq,2),4)+[BXR],[IMPPAR],1)
    REPL IMPPAR->docto WITH numero
   ENDI
  #endi

  IF op_menu!=INCLUSAO
   RECA
  ENDI
 ENDI
ENDI
RETU

* \\ Final de BXREC.PRG
procedure dci04f9
/*
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
 \ Empresa.: PresServ Inform tica-Limeira (019)452.6623
 \ Programa: DCI04F9.PRG
 \ Data....: 29-08-97
 \ Sistema.: Administradora - RECEP€„O
 \ Funcao..: F¢rmula (Descr.Documento) a mostrar na tela de DCI_P001
 \ Analista: Ademilson Pedro Bom
 \ Criacao.: Programado manualmente pelo analista
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/

#include "adrbig.ch"    // inicializa constantes manifestas
PARA tipdoc
PRIVA donex:=[]
DO CASE
// ADRBIG - Programa da Recepcao
 CASE tipdoc= [BXR]
 IF PTAB(ALLTRIM(docto),[BXREC],1)
  RETU BXREC->codigo+[ ]+BXREC->tipo+[-]+BXREC->circ+TRAN(BXREC->valorpg,[999999.99])
 ENDIF
 CASE tipdoc= [OBX]
 IF PTAB(ALLTRIM(docto),[OBXEC],1)
  RETU OBXEC->codigo+[ ]+OBXEC->ref+TRAN(OBXEC->valorpg,[999999.99])
 ENDIF
 CASE tipdoc= [AFU]
 IF PTAB(ALLTRIM(docto),[AFUNER],1)
  RETU AFUNER->ocorr_+[ ]+AFUNER->categ+[ ]+AFUNER->contrato+[ ]+AFUNER->falecido
 ENDIF

// ADCBIG - Programa de Credito e Cobran‡a
 CASE tipdoc= [BXF]
  donex:=[Baixa por FCC]

// CONBIG - Programa de Guias de convˆnio
 CASE tipdoc= [GUI]
  donex:=[Guia de Convˆnio]

// FUNBIG - Programa de Funer ria
 CASE tipdoc= [CAD]
  donex:=[Processo de Atendimento]
 CASE tipdoc= [PCO]
  donex:=[Pedido de Coroa]
 CASE tipdoc= [REC]
  donex:=[Recibo de Atendimento]
 CASE tipdoc= [RCO]
  donex:=[Recibo de Coroa]
 CASE tipdoc= [NFI]
  donex:=[Nota Fiscal]
OTHERWISE
 donex:=[N„o cadastrado]
ENDCASE

RETU M->donex     // <- deve retornar um valor qualquer

* \\ Final de DCI04F9.PRG
procedure adm_r029
/*
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
 \ Empresa.: PresServ Inform tica - Limeira (019)452.6623
 \ Programa: ADM_R029.PRG
 \ Data....: 04-11-03
 \ Sistema.: Administradora - RECEP€„O
 \ Funcao..: Relat¢rio de Processo
 \ Analista: Ademilson Pedro Bom
 \ Criacao.: GAS-Pro v4.0n
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/

#include "adrbig.ch"    // inicializa constantes manifestas

PRIV dele_atu, cur_atual, getlist:={}
PARA lin_menu, col_menu
PRIV  tem_borda:=.t., op_menu:=VAR_COMPL, l_s:=10, c_s:=20, l_i:=13, c_i:=61, tela_fundo:=SAVESCREEN(0,0,MAXROW(),79)
nucop=1
SETCOLOR(drvtittel)
vr_memo=NOVAPOSI(@l_s,@c_s,@l_i,@c_i)     // pega posicao atual da tela
CAIXA(mold,l_s,c_s,l_i,c_i)               // monta caixa da tela
@ l_s,c_s+10 SAY " IMPRESSŽO AUX.FUNERAL "
SETCOLOR(drvcortel)
@ l_s+01,c_s+1 SAY " Processo:"
@ l_s+02,c_s+1 SAY " Confirme:"
PRIV rproc:=SPAC(11)                               // Processo
PRIV confirme:=SPAC(1)                             // Confirme
DO WHILE .t.
 rola_t=.f.
 cod_sos=56
 SET KEY K_ALT_F8 TO ROLATELA
 SETCOLOR(drvcortel+","+drvcorget+",,,"+corcampo)
 @ l_s+01 ,c_s+12 GET  rproc;
                  PICT "@R 99999/9999-99";
                  VALI CRIT("!EMPT(RPROC).AND.PTAB(M->rproc,[AFUNER],1)~Campo utilizado para localiza‡„o dos documentos.|Tecle F8 para busca em tabela")
                  DEFAULT "IIF(PTAB(PADR(SUBSTR(M->ide_maq,2),4)+[AFU],[IMPPAR],1),ALLTRIM(IMPPAR->docto),[])"
                  AJUDA "Digite neste campo o n£mero de|identifica‡„o do processo"
                  CMDF8 "VDBF(6,12,20,77,'AFUNER',{'processo','proc2','categ','contrato','falecido'},1,'V02001F9()',[])"

 @ l_s+02 ,c_s+12 GET  confirme;
                  PICT "!";
                  VALI CRIT("confirme='S'.AND.V02002F9()~CONFIRME n„o aceit vel|Digite S para confirmar|ou|Tecle ESC para cancelar")
                  AJUDA "Digite S para confirmar|ou|tecle ESC para cancelar"

 READ
 SET KEY K_ALT_F8 TO
 IF rola_t
  ROLATELA(.f.)
  LOOP
 ENDI
 IF LASTKEY()=K_ESC                                // se quer cancelar
  RETU                                             // retorna
 ENDI

 #ifdef COM_REDE
  IF !USEARQ("AFUNER",.f.,10,1)                    // se falhou a abertura do arq
   RETU                                            // volta ao menu anterior
  ENDI
 #else
  USEARQ("AFUNER")                                 // abre o dbf e seus indices
 #endi

 PTAB(contrato,"GRUPOS",1,.t.)                     // abre arquivo p/ o relacionamento
 PTAB(contrato,"INSCRITS",1,.t.)
 SET RELA TO contrato INTO GRUPOS,;                // relacionamento dos arquivos
          TO contrato INTO INSCRITS
 titrel:=criterio := ""                            // inicializa variaveis
 cpord=""
 chv_rela:=chv_1:=chv_2 := ""
 tps:=op_x:=ccop := 1
 fil_ini=""
 IF !opcoes_rel(lin_menu,col_menu,5,11,fil_ini)    // nao quis configurar...
  CLOS ALL                                         // fecha arquivos e
  LOOP                                             // volta ao menu
 ENDI
 IF tps=2                                          // se vai para arquivo/video
  arq_=ARQGER()                                    // entao pega nome do arquivo
  IF EMPTY(arq_)                                   // se cancelou ou nao informou
   LOOP                                            // retorna
  ENDI
 ELSE
  arq_=drvporta                                    // porta de saida configurada
 ENDI
 IF "4WIN"$UPPER(drvmarca) // nome da configuracao/marca impressora
    arq_:=drvdbf+"WIN"+ide_maq
    tps:=3                                          // se vai para arquivo/video
 ENDIF
 SET PRINTER TO (arq_)                             // redireciona saida
 EXIT
ENDD
cur_atual=SETCURSOR(0)
dele_atu:=SET(_SET_DELETED,.t.)                    // os excluidos nao servem...
POE_GAUGE("[ESC] Interrompe","AGUARDE...","Emitidos:")
SET DEVI TO PRIN                                   // inicia a impressao
maxli=62                                           // maximo de linhas no relatorio
BEGIN SEQUENCE
 DO WHIL ccop<=nucop                               // imprime qde copias pedida
  pg_=1; cl=50000
  INI_ARQ()                                        // acha 1o. reg valido do arquivo
  IF EOF()
   EXIT
  ENDI
  ccop++                                           // incrementa contador de copias
  DO WHIL !EOF().AND.POE_GAUGE()
   IF IN_KEY()=K_ESC                               // se quer cancelar
    IF canc()                                      // pede confirmacao
     BREAK                                         // confirmou...
    ENDI
   ENDI
   IF PTAB(PADR(SUBSTR(M->ide_maq,2),4)+[AFU],[IMPPAR],1).and.processo+proc2+filial+categ=ALLTRIM(IMPPAR->docto)// se atender a condicao...
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY "Contrato:"
    IMPCTL(drvpenf)
    @ cl,011 SAY GRUPOS->grupo+'-'+GRUPOS->codigo  // Contrato
    IMPCTL(drvtenf)
    @ cl,043 SAY "Processo"
    IMPCTL(drvpenf)
    @ cl,052 SAY TRAN(processo+proc2+filial,"@R 99999/99/!!")// Nr.Processo
    IMPCTL(drvtenf)
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY REPL("-",74)
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,013 SAY "R E L A T O R I O   D E   P R O C E S S O"
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY REPL("-",74)
    REL_CAB(2)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY "Nome do Falecido.:"
    IMPCTL(drvpenf)
    @ cl,020 SAY TRAN(falecido,"@!")               // nome do falecido
    IMPCTL(drvtenf)
    REL_CAB(2)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY "End. do Falecido.:"
    @ cl,020 SAY LEFT(ALLTRIM(ruares)+' ' +baires,59)// Rua Residˆncia
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY "Cidade...........:"
    @ cl,020 SAY munres                            // Munic¡pio de residˆncia
    @ cl,054 SAY "Estado:"
    @ cl,062 SAY TRAN(estres,"!!")                 // UF Residˆncia
    REL_CAB(2)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY "Falecimento......:"
    IMPCTL(drvpenf)
    @ cl,019 SAY TRAN(falecto_,"@D")               // data falecto
    IMPCTL(drvtenf)
    @ cl,029 SAY "Local...:"
    @ cl,039 SAY ruafal                            // Rua Falecimento
    REL_CAB(2)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY "Inscrito Contrato como.:"
    @ cl,026 SAY grauparcon                        // Parentesco
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY REPL("-",74)
    REL_CAB(2)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY "Contratante:"
    IMPCTL(drvpenf)
    @ cl,013 SAY GRUPOS->nome                      // Nome CONTRATANTE
    IMPCTL(drvtenf)
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    IMPAC("Endere‡o...:",cl,000)
    @ cl,013 SAY xDECRIPT(GRUPOS->endereco)                  // Endere‡o
    @ cl,049 SAY xDECRIPT(GRUPOS->cidade)                    // Cidade
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY REPL("-",74)
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY "Valor em Reais....:"
    @ cl,020 SAY vlauxilio                         // Valor
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY "PROCESSAR PAGAMENTO EM :"
    IMPCTL(drvpenf)
    @ cl,025 SAY LEFT(DTOC(procpagto_),2)+' de '+ALLTRIM(NMES(procpagto_))+' de '+STR(YEAR(procpagto_),4)// Proc.pagto em
    IMPCTL(drvtenf)
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY REPL("-",74)
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    IMPMEMO([   ],10,1,cl,000,.f.)                 // AUX (memo)
    qli_m=MLCOUNT([   ],10)-1                      // quantas linhas a imprimir?
    li_m=0
    DO WHIL .t.                                    // imprime linhas do memo
     li_m++
     IF li_m>qli_m                                 // fim do memo
      EXIT
     ENDI
     REL_CAB(1)                                    // soma cl/imprime cabecalho
     IMPMEMO([   ],10,1+li_m,cl,000,.f.)           // imprime...
     IF IN_KEY()=K_ESC                             // se quer cancelar
      IF canc()                                    // pede confirmacao
       BREAK                                       // confirmou...
      ENDI
     ENDI
    ENDD
    SKIP                                           // pega proximo registro
    cl=50000                                       // forca salto de pagina
   ELSE                                            // se nao atende condicao
    SKIP                                           // pega proximo registro
   ENDI
  ENDD
 ENDD ccop
END SEQUENCE
SETCURSOR(cur_atual)
SET PRINTER TO (drvporta)                          // fecha arquivo gerado (se houver)
SET DEVI TO SCRE                                   // direciona saida p/ video
IF tps=2                                           // se vai para arquivo/video
 BROWSE_REL(arq_,2,3,MAXROW()-2,78)
ENDI          // mostra o arquivo gravado
GRELA(5)                                           // grava variacao do relatorio
SELE AFUNER                                        // seleciona arquivo
SET RELA TO                                        // retira os relacionamentos
SET(_SET_DELETED,dele_atu)                         // os excluidos serao vistos
RETU

STATIC PROC REL_CAB(qt)                            // cabecalho do relatorio
IF qt>0                                            // se parametro maior que 0
 cl=cl+qt                                          // soma no contador de linhas
ENDI
IF cl>maxli .OR. qt=0                              // quebra de pagina
 @ 0,000 SAY REPL("-",74)
 IMPAC("BOM PASTOR - Organiza‡„o Administradora de Bens BOM PASTOR Ltda",1,000)
 @ 2,000 SAY "Data:"
 @ 2,006 SAY TRAN(DATE(),"@D")                     // DATA
 @ 2,025 SAY "CAT:"
 @ 2,030 SAY IIF(categ=[PD],[Plano c/Difer. ],IIF(categ=[PL],[Atend.Plano],[Auxilio Funeral  ]))// Categoria
 cl=qt+2 ; pg_++
ENDI
RETU

* \\ Final de ADM_R029.PRG
GAS-Pro v3.0
002003024079001024031007020000176001
[Ÿ]
 27 
BXREC
Recibos c/Falecidos


PTAB(PADR(SUBSTR(M->ide_maq,2),4)+[BXR],[IMPPAR],1).AND.ano+numero=LEFT(IMPPAR->docto,8)
011









 0 
 2 
 0 
 48 
 1 
 8 
 28 
 0 
 0 
 0 
 0 
 0 
 0 
-1 
 0 
-1 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
Grupo
grupo

 2 
C
 2 
 77 


          










Nome
GRUPOS->nome

 35 
C
 2 
 8 


          










Codigo
codigo
99999
 5 
C
 2 
 59 


          










Mensagem
CHR(18)+CIRCULAR->menscirc

 61 
C
 22 
 9 


          










N§ Recibo
M->nrauxrec
########
 8 
C
 29 
 21 


          










N§ Recibo 2
M->nrauxrec
########
 8 
C
 29 
 69 


          










Valor
valorpg
@E 999,999.99
 10 
N
 26 
 18 


          










Valor 2
valorpg
@E 999,999.99
 10 
N
 26 
 66 


          










Circular 1
circ+[     ]+DTOC(CIRCULAR->emissao_)+[     ]+STR(GRUPOS->funerais,2)

 30 
C
 32 
 3 


          










Circular 2
circ+[     ]+DTOC(CIRCULAR->emissao_)+[     ]+STR(GRUPOS->funerais,2)

 30 
C
 32 
 39 


          










Grupo 1
GRUPOS->grupo +[        ]+codigo+[       ]+GRUPOS->cobrador

 30 
C
 35 
 3 


          










Grupo 2
GRUPOS->grupo +[        ]+codigo+[       ]+GRUPOS->cobrador

 30 
C
 35 
 39 


          










Inicio
[Inic:]+DTOC(GRUPOS->admissao)+[ Ult:]+GRUPOS->ultcirc+[ QtTx:]+STR(GRUPOS->qtcircs,3)

 35 
C
 41 
 1 


          










Inicio 2
[Inic:]+DTOC(GRUPOS->admissao)+[ Ult:]+GRUPOS->ultcirc+[ QtTx:]+STR(GRUPOS->qtcircs,3)

 35 
C
 41 
 37 


          










Nome
GRUPOS->nome
 
 35 
C
 37 
 1 


          










Nome 2
GRUPOS->nome

 35 
C
 37 
 37 


          










Endere‡o
GRUPOS->endereco
 
 35 
C
 38 
 1 


          










Endere‡o 2
GRUPOS->endereco

 35 
C
 38 
 37 


          










Bairro
GRUPOS->bairro
 
 25 
C
 39 
 1 


          










Bairro 2
GRUPOS->bairro

 25 
C
 39 
 37 


          










Cidade
GRUPOS->cidade+[ ] +GRUPOS->cep

 35 
C
 40 
 1 


          










Cidade 2
GRUPOS->cidade+[ ] +GRUPOS->cep

 35 
C
 40 
 37 


          










Valor
valorpg
@E 999,999.99
 10 
N
 4 
 33 


          










data 1
LEFT(DTOC(DATE()),2)+[  ]+SUBSTR(DTOC(DATE()),4,2)+[  ]+RIGHT(DTOC(DATE()),2)

 10 
C
 44 
 3 


          










data 2
LEFT(DTOC(DATE()),2)+[  ]+SUBSTR(DTOC(DATE()),4,2)+[  ]+RIGHT(DTOC(DATE()),2)

 10 
C
 44 
 40 


          










codigo barra1
codigo+tipo+circ

 13 
1
 43 
 19 


          










codigo barra2
codigo+tipo+circ

 13 
1
 44 
 19 


          










 9 
Nome da empresa
nemp

 0 
 0 
 32 

T¡tulo aplica‡„o
nsis

 0 
 0 
 25 

Data do sistema
DTOC(DATE())

 0 
 0 
 8 

Nome do mˆs
NMES(DATE())

 0 
 0 
 8 

Dia da semana
NSEM(DATE())

 0 
 0 
 7 

N£mero da p gina
TRAN(pg_,'9999')

 0 
 0 
 4 

C¢digo relat¢rio
"ADM_R018"

 0 
 0 
 8 

T¡tulo a definir
titrel

 0 
 0 
 30 

Hora da emiss„o
hora_rel_

 0 
 0 
 5 

 0 
 0 
 0 
 6 
GRUPOS
 1 
codigo



TAXAS
 1 
codigo+tipo+circ



ARQGRUP
 1 
GRUPOS->grupo



COBRADOR
 1 
GRUPOS->cobrador



CIRCULAR
 1 
GRUPOS->grupo+circ



REGIAO
 1 
GRUPOS->regiao



NET USE J: /D
NET USE J: \\BP1\DADOS BOMPASTOR
del c:\window\temp\*.rem
CD J:\BPNET\ARQUIVOS
D:
cd d:\teste\prepara
copy asschk.db* assoc.* /y
COPY J:ASSO*.* D:\DADOS\BPNET\ARQUIVOS /Y
call DB2DBF D:\DADOS\BPNET\ARQUIVOS\ASSOC D:\TESTE\PREPARA\ASSOC
COPY J:RECEB*.* D:\DADOS\BPNET\ARQUIVOS /Y
copy recchk.db* receber.* /y
@echo off
@echo Aguardando liberacao do associado
:wait
@if exist c:\windows\temp\inmem*.rem goto wait:
@echo on
call DB2DBF D:\DADOS\BPNET\ARQUIVOS\RECEBER D:\TESTE\PREPARA\RECEBER
COPY J:INSCR*.* D:\DADOS\BPNET\ARQUIVOS /Y
copy inschk.d* inscrit.* /y
@echo off
@echo Aguardando liberacao de contas a receber
:wait1
@if exist c:\windows\temp\inmem*.rem goto wait1:
@echo on
call DB2DBF D:\DADOS\BPNET\ARQUIVOS\INSCRIT D:\TESTE\PREPARA\INSCRIT
NET USE J: /D
@echo off
@echo Aguardando liberacao de Inscritos
:wait2
@if exist c:\windows\temp\inmem*.rem goto wait2:
@call poscop.bat

procedure bxr_07f9
/*
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
 \ Empresa.: Ind£stria de Urnas Bignotto Ltda
 \ Programa: BXR_07F9.PRG
 \ Data....: 28-11-95
 \ Sistema.: Administradora de Funer rias
 \ Funcao..: Valor inicial do campo VALORPG, arquivo BXREC
 \ Analista: Ademilson Pedro Bom
 \ Criacao.: Programado manualmente pelo analista
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/

#include "adrbig.ch"    // inicializa constantes manifestas
LOCAL reg_dbf:=POINTER_DBF()
PRIVA respx,nomx:=space(35)
if op_menu#INCLUSAO
 retu PTAB(codigo,[GRUPOS],1)
endi
PTAB([],[GRUPOS],1,.t.)

nome:=space(35)
//DBOX([>]+CODIGO+[<])
IF EMPT(codigo)
 nomx=DBOX("Nome",,,,,"Informe o nome a procurar",nomx,"@!")

 IF PTAB(alltrim(nomx),[GRUPOS],2,.t.)
	codigo:=GRUPOS->codigo
	codigo:=VDBF(6,3,20,77,'GRUPOS',{'nome','codigo','xDECRIPT(endereco)','tcarencia'},5,'codigo')
	nome:=GRUPOS->nome

 ELSE
  msgt="Nome n„o encontrado como titular|Procurar como inscrito?"
  ALERTA()
  op_=DBOX("Prosseguir|Cancelar opera‡„o",,,E_MENU,,msgt)
  IF op_ = 1
   IF !PTAB(alltrim(nomx),[INSCRITS],2,.t.)
    PTAB(ALLTRIM(LEFT(nomx,AT(' ',nomx))),[INSCRITS],2,.t.)
   ENDI
	 codigo:=INSCRITS->codigo+INSCRITS->grau+STR(INSCRITS->seq,2)
   nome:=alltrim(inscrits->nome)
	 codiGO:=VDBF(6,3,20,77,'INSCRITS',{'nome','codigo','grau','seq','tcarencia','vivofalec','tipo'},2,'codigo')
	 nome:=INSCRITS->nome
   codigo:=IIF(codigo=NIL,SPACE(9),left(codigo,9))
  ENDI

 ENDI

 IF LASTKEY()=K_ESC             // se teclou ESC
	codigo=SPACE(9)
	POINTER_DBF(reg_dbf)
	RETU .f.
 ENDI
ELSEIF LEN(ALLTRIM(codigo))<9.AND.!EMPT(CODIGO)
 msg_ins:=cod_msg:=[]
 nopc:=1
 tem10:=ptab('010'+strzero(VAL(codigo),6),[GRUPOS],1)
 IF tem10
  cod_msg+=GRUPOS->codigo
 	msg_ins+=GRUPOS->codigo+' '+GRUPOS->nome//+' '+xDECRIPT(GRUPOS->endereco)+' '//+DTOC(GRUPOS->tcarencia)
 ENDI

 tem20:=ptab('020'+strzero(VAL(codigo),6),[GRUPOS],1)
 IF tem20
  IF tem10
   msg_ins+=[|]
  ENDI
  cod_msg+=GRUPOS->codigo
 	msg_ins+=GRUPOS->codigo+' '+GRUPOS->nome//+' '+GRUPOS->endereco//+' '+DTOC(GRUPOS->tcarencia)
 ENDI
 if len(cod_msg) > 9
  msg_:=[Escolha o contrato|Codigo Nome                           Endereco]
  nopc:=DBOX(msg_ins,,,E_MENU,,msg_,,,nopc)
 endi
 codigo:=SUBSTR(cod_msg,((nopc-1)*9)+1,9)

ENDI
respx:=LEFT(codigo,9)

IF PTAB(respx,[GRUPOS],1)
 titular:=GRUPOS->nome
// dbox(titular+respx)
ENDI

POINTER_DBF(reg_dbf)

retu PTAB(respx,[GRUPOS],1)	 // <- deve retornar um valor qualquer


procedure codbar

set devi to prin
@ 1,1 say []
? codbarras({[0053800],1,13,10},10,6)
@ 2,1 say []
? codbarras({[0053800],1,13,10},10,6)
@ 6,1 say []
? codbarras({[0053800],2,13,10},10,6)
@ 7,1 say []
? codbarras({[0053800],2,13,10},10,6)
@ 11,1 say []
? codbarras({[0053800],3,13,10},10,6)
@ 12,1 say []
? codbarras({[0053800],3,13,10},10,6)
@ 16,1 say []
? codbarras({[0053800],4,13,10},10,6)
@ 17,1 say []
? codbarras({[0053800],4,13,10},10,6)
@ 21,1 say []
? codbarras({[0053800],5,13,10},10,6)
@ 22,1 say []
? codbarras({[0053800],5,13,10},10,6)
set devi to screen€
 ADM_R021X–Þ  ADM_R021CODEREL_CABCODEC_ETEXTENDCODE	_SYMSTARTSYMSTARTSYMBOLSSYMBOLS_SYMENDSYMENDNULLBEGDATA_DATADATA_SYMPBDATA_SYMPDATA_SYMPEDATA_CONSTCONST_MSGMSG_BEGBSSBEGBSS_BSSBSS_ENDBSSENDBSSDGROUPÜ˜ @e¯˜ @°f˜ H  ˜ h  	ç˜ `
V˜ h  ß˜ h  Û˜ H  ÷˜ H  ó˜ H ç˜ H  ë˜ H  ç˜ (  clipper %1
blinker fi %1,sixnsx,sixuk,sixtools @six3
procedure r00601f9
/*
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
 \ Empresa.: PresServ Inform tica-Limeira (019)452.6623
 \ Programa: R00601F9.PRG
 \ Data....: 14-12-95
 \ Sistema.: Administradora de Funer rias
 \ Funcao..: Processo direto no campo particv, arquivo GRUPOS
 \ Analista: Ademilson Pedro Bom
 \ Criacao.: Programado manualmente pelo analista
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/

#include "admbig.ch"    // inicializa constantes manifestas

   #ifdef COM_REDE
    IF PTAB(M->rgrupo+M->rcodigo,'GRUPOS',1)
     REPBLO('GRUPOS->situacao',[1])
     REPBLO('GRUPOS->admissao',admissao)
     REPBLO('GRUPOS->saitxa',saitxa)
     REPBLO('GRUPOS->cobrador',cobrador)
     REPBLO('GRUPOS->funerais',funerais)
     REPBLO('GRUPOS->vlcarne',vlcarne)
     REPBLO('GRUPOS->circinic',circinic)
     REPBLO('GRUPOS->ultcirc',ultcirc)
     REPBLO('GRUPOS->regiao',regiao)
     REPBLO('GRUPOS->qtcircs',qtcircs)
     REPBLO('GRUPOS->titular',titular)
     REPBLO('GRUPOS->nome',nome)
     REPBLO('GRUPOS->endereco',endereco)
     REPBLO('GRUPOS->bairro',bairro)
     REPBLO('GRUPOS->cidade',cidade)
     REPBLO('GRUPOS->cep',cep)
     REPBLO('GRUPOS->particv',0)
     REPBLO('GRUPOS->particf',particf)
    ENDI
   #else
    IF PTAB(M->rgrupo+M->rcodigo,'GRUPOS',1)
     REPL GRUPOS->situacao WITH [1]
     REPL GRUPOS->admissao WITH admissao
     REPL GRUPOS->saitxa WITH saitxa
     REPL GRUPOS->cobrador WITH cobrador
     REPL GRUPOS->funerais WITH funerais
     REPL GRUPOS->vlcarne WITH vlcarne
     REPL GRUPOS->circinic WITH circinic
     REPL GRUPOS->ultcirc WITH ultcirc
     REPL GRUPOS->regiao WITH regiao
     REPL GRUPOS->qtcircs WITH qtcircs
     REPL GRUPOS->titular WITH titular
     REPL GRUPOS->nome WITH nome
     REPL GRUPOS->endereco WITH endereco
     REPL GRUPOS->bairro WITH bairro
     REPL GRUPOS->cidade WITH cidade
     REPL GRUPOS->cep WITH cep
     REPL GRUPOS->particv WITH 0
     REPL GRUPOS->particf WITH particf
    ENDI
   #endi


RETU 0   // <- deve retornar um valor CARACTER

* \\ Final de R00601F9.PRG
procedure adp_p007
/*
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
 \ Empresa.: PresServ Inform tica-Limeira (019)452.6623
 \ Programa: ADP_P007.PRG
 \ Data....: 11-01-98
 \ Sistema.: Administradora - PLANO
 \ Funcao..: Lan‡amento de acertos
 \ Analista: Ademilson Pedro Bom
 \ Criacao.: GAS-Pro v3.0
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/

#include "adrbig.ch"    // inicializa constantes manifestas

LOCAL dele_atu, getlist:={}, sit_dbf2:=POINTER_DBF(), arr:=SETS()
PARA  lin_menu, col_menu
PRIV  tem_borda:=.t., op_menu:=VAR_COMPL, l_s:=7, c_s:=10, l_i:=12, c_i:=51, tela_fundo:=SAVESCREEN(0,0,MAXROW(),79)
set curs on
SET KEY K_F2 TO                                   // retira das teclas F3 e F4 as
nucop=1
SETCOLOR(drvtittel)
vr_memo=NOVAPOSI(@l_s,@c_s,@l_i,@c_i)     // pega posicao atual da tela
CAIXA(mold,l_s,c_s,l_i,c_i)               // monta caixa da tela
@ l_s,c_s+10 SAY " LAN€AMENTO DE ACERTOS "
SETCOLOR(drvcortel)
@ l_s+01,c_s+1 SAY "    Contrato:"
@ l_s+02,c_s+1 SAY "    Gerar    parcelas de"
@ l_s+03,c_s+1 SAY "    com tipo  , n£mero inicial     e"
@ l_s+04,c_s+1 SAY "    vencimento a partir de         ."
rcodigo=codigo //SPAC(6)                                    // Codigo
parcf=0                                            // Parcf
vlparc=0                                           // Vlparc
rtipo=SPAC(1)                                      // Tipo
rcirc=SPAC(3)                                      // Circular
vini_=CTOD('')                                     // Vencimento
DO WHILE .t.
 rola_t=.f.
 cod_sos=56
 SET KEY K_ALT_F8 TO ROLATELA
 SETCOLOR(drvcortel+","+drvcorget+",,,"+corcampo)
 @ l_s+01 ,c_s+15 GET  rcodigo;
		  PICT "999999";
		  VALI CRIT("PTAB(rcodigo,'GRUPOS',1).AND.GRUPOS->situacao=[1]~Contrato cancelado |ou inexistente")
		  AJUDA "Informe o n£mero do contrato"
		  CMDF8 "VDBF(6,26,20,77,'GRUPOS',{'grupo','codigo','nome'},1,'codigo')"

 @ l_s+02 ,c_s+11 GET  parcf;
		  PICT "99";
		  VALI CRIT("parcf>0~PARCF n„o aceit vel")

 @ l_s+02 ,c_s+26 GET  vlparc;
		  PICT "99999999.99";
		  VALI CRIT("vlparc>0~VLPARC n„o aceit vel")

 @ l_s+03 ,c_s+14 GET  rtipo;
		  PICT "!";
		  VALI CRIT("!EMPT(rtipo)~TIPO n„o aceit vel")
		  AJUDA "Qual o tipo de lan‡amento"
		  CMDF8 "MTAB([1=J¢ia |2=Taxa |3=Carnˆ|4=Acerto|6=J¢ia+Seguro|7=Taxa+Seguro|8=Carnˆ+Seguro],[TIPO])"

 @ l_s+03 ,c_s+32 GET  rcirc;
		  PICT "999";
		  VALI CRIT("!EMPT(rcirc)~Necess rio informar n£mero de CIRCULAR v lida")
		  AJUDA "Informe o n£mero da circular inicial a gerar"

 @ l_s+04 ,c_s+28 GET  vini_;
		  PICT "@D";
		  VALI CRIT("vini_>=DATE()~Necess rio informar Data v lida")
		  AJUDA "Data da Vencimento Circular|Mantido pela emissao do recibo"

 READ
 SET KEY K_ALT_F8 TO
 sets(arr)
 IF rola_t
  ROLATELA(.f.)
  LOOP
 ENDI
 IF LASTKEY()=K_ESC                                // se quer cancelar
  SET KEY K_F2 TO adp_p007                                  // retira das teclas F3 e F4 as
  RETU                                             // retorna
 ENDI
 EXIT
ENDD
cod_sos=1
msgt="LAN€AMENTO DE ACERTOS"
ALERTA()
op_=DBOX("Prosseguir|Cancelar opera‡„o",,,E_MENU,,msgt)
IF op_=1
 DBOX("Processando registros",,,,NAO_APAGA,"AGUARDE!")
 dele_atu:=SET(_SET_DELETED,.t.)                   // os excluidos nao servem...

 #ifdef COM_REDE
  CLOSE GRUPOS
  IF !USEARQ("GRUPOS",.f.,10,1)                    // se falhou a abertura do arq
   RETU                                            // volta ao menu anterior
  ENDI
 #else
  USEARQ("GRUPOS")                                 // abre o dbf e seus indices
 #endi

 criterio:=cpord := ""                             // inicializa variaveis
 chv_rela:=chv_1:=chv_2 := ""

#ifdef COM_REDE
 IF !USEARQ("TAXAS",.f.,10,1)                      // se falhou a abertura do arq
  RETU                                             // volta ao menu anterior
 ENDI
#else
 USEARQ("TAXAS")                                   // abre o dbf e seus indices
#endi

 SELE GRUPOS                                       // processamentos apos emissao
 PTAB(M->rcodigo,[GRUPOS],1)
// INI_ARQ()                                         // acha 1o. reg valido do arquivo
 DO WHIL !EOF().and.codigo=M->rcodigo
  FOR nparc=1 TO parcf
   IF !PTAB(codigo+rtipo+RIGHT('00'+ALLTRIM(STR(nparc+VAL(rcirc)-1)),3) ,[TAXAS],1)

   SELE TAXAS                                      // arquivo alvo do lancamento

   #ifdef COM_REDE
    DO WHIL .t.
     APPE BLAN                                     // tenta abri-lo
     IF NETERR()                                   // nao conseguiu
      DBOX(ms_uso,20)                              // avisa e
      LOOP                                         // tenta novamente
     ENDI
     EXIT                                          // ok. registro criado
    ENDD
   #else
    APPE BLAN                                      // cria registro em branco
   #endi

   SELE GRUPOS                                     // inicializa registro em branco
   REPL TAXAS->codigo WITH codigo,;
	TAXAS->tipo WITH rtipo,;
	TAXAS->circ WITH RIGHT('00'+ALLTRIM(STR(nparc+VAL(rcirc)-1)),3),;
	TAXAS->emissao_ WITH P00801F9(),;
	TAXAS->valor WITH M->vlparc,;
	TAXAS->cobrador WITH cobrador
   ELSEIF TAXAS->valorpg>0
	// nada faz
   ELSE
    msgt1:=[Taxa ]+codigo+[-]+rtipo+[-]+;
	   RIGHT('00'+ALLTRIM(STR(nparc+VAL(rcirc)-1)),3)+[ j  existe]
    op_1=DBOX("Substituir|Ignorar esta TAXA",,,E_MENU,,msgt1)
    if op_1=1
     SELE TAXAS
     BLOREG(0,.05)
     REPL TAXAS->emissao_ WITH P00801F9(),;
	TAXAS->valor WITH M->vlparc,;
	TAXAS->cobrador WITH cobrador
     UNLOCK
     SELE GRUPOS
    endi
   ENDI


   #ifdef COM_REDE
    TAXAS->(DBUNLOCK())                            // libera o registro
   #endi

  NEXT
  exit
  //SKIP                                             // pega proximo registro
 ENDD
 SET(_SET_DELETED,dele_atu)                        // os excluidos serao vistos
 ALERTA(2)
// DBOX("Processo terminado com sucesso!",,,,,msgt)
ENDI
POINTER_DBF(sit_dbf2)
imprela()
SET KEY K_F2 TO adp_p007                                  // retira das teclas F3 e F4 as
RESTSCREEN(,0,MAXROW(),79,tela_fundo)                // restaura tela do fundo

//CLOSE ALL                                          // fecha todos os arquivos e
RETU                                               // volta para o menu anterior

* \\ Final de ADP_P007.PRG

/*
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
 \ Empresa.: PresServ Inform tica-Limeira (019)452.6623
 \ Programa: P00801F9.PRG
 \ Data....: 11-01-98
 \ Sistema.: Administradora - PLANO
 \ Funcao..: Lan‡amento em TAXAS->emissao_, gerado por ADP_P008
 \ Analista: Ademilson Pedro Bom
 \ Criacao.: Programado manualmente pelo analista
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/
FUNCT P00801F9
PRIV dataux, diaaux

    diaaux:=LEFT(DTOC(vini_),3)+SUBSTR(DTOC(vini_-DAY(vini_)+1+(31*(nparc-1))),4)
    dataux:=CTOD(M->diaaux)
    DO WHILE EMPT(M->dataux)
     diaaux:=STR(VAL(LEFT(diaaux,2))-1,2)+SUBSTR(diaaux,3)
     dataux:=CTOD(M->diaaux)
    ENDD



RETU M->dataux      // <- deve retornar um valor DATA

* \\ Final de P00801F9.PRG
procedure con_r027
/*
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
 \ Empresa.: PresServ Inform tica - Limeira (019)452.6623
 \ Programa: CON_R027.PRG
 \ Data....: 31-12-98
 \ Sistema.: Controle de Convˆnios
 \ Funcao..: Ranking
 \ Analista: Ademilson Pedro Bom
 \ Criacao.: GAS-Pro v3.0
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/

#include "adrbig.ch"    // inicializa constantes manifestas

LOCAL dele_atu
PARA  lin_menu, col_menu, rde, rate
nucop=1

#ifdef COM_REDE
 IF !USEARQ("MEDICOS",.f.,10,1)                    // se falhou a abertura do arq
  RETU                                             // volta ao menu anterior
 ENDI
#else
 USEARQ("MEDICOS")                                 // abre o dbf e seus indices
#endi

titrel:=criterio := ""                             // inicializa variaveis
cpord="" //"str(999999-VAL(numconta),6)"
titrel:=chv_rela:=chv_1:=chv_2 := ""
tps:=op_x:=ccop := 1
IF !opcoes_rel(lin_menu,col_menu,25,11)            // nao quis configurar...
 CLOS ALL                                          // fecha arquivos e
 RETU                                              // volta ao menu
ENDI
IF tps=2                                           // se vai para arquivo/video
 arq_=ARQGER()                                     // entao pega nome do arquivo
 IF EMPTY(arq_)                                    // se cancelou ou nao informou
  RETU                                             // retorna
 ENDI
ELSE
 arq_=drvporta                                     // porta de saida configurada
ENDI
SET PRINTER TO (arq_)                              // redireciona saida
DBOX("[ESC] Interrompe",15,,,NAO_APAGA)
dele_atu:=SET(_SET_DELETED,.t.)                    // os excluidos nao servem...
SET DEVI TO PRIN                                   // inicia a impressao
maxli=62                                           // maximo de linhas no relatorio
IMPCTL(drvpcom)                                    // comprime os dados
IF tps=2
 IMPCTL("' '+CHR(8)")
ENDI
BEGIN SEQUENCE
 DO WHIL ccop<=nucop                               // imprime qde copias pedida
  pg_=1; cl=999
  ctaux:=ctmed:=0
  INI_ARQ()                                        // acha 1o. reg valido do arquivo
  ccop++                                           // incrementa contador de copias
  DO WHIL !EOF()
   #ifdef COM_TUTOR
    IF IN_KEY()=K_ESC                              // se quer cancelar
   #else
    IF INKEY()=K_ESC                               // se quer cancelar
   #endi
    IF canc()                                      // pede confirmacao
     BREAK                                         // confirmou...
    ENDI
   ENDI
   IF !EMPT(numconta)                              // se atender a condicao...
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY TRAN(crm,"@!")                    // C¢digo
    @ cl,011 SAY nome                              // Nome
    @ cl,052 SAY TRAN(especialid,"@!")             // Especialidade
    @ cl,083 SAY telefone                          // Telefone
    @ cl,098 SAY TRAN(numconta,"@!")               // Conta
    ctaux+=VAL(numconta)
    ctmed++
    SKIP                                           // pega proximo registro
   ELSE                                            // se nao atende condicao
    SKIP                                           // pega proximo registro
   ENDI
  ENDD
  REL_CAB(1)                                     // soma cl/imprime cabecalho
  @ cl,000 SAY REPL("-",108)
  REL_CAB(1)                                     // soma cl/imprime cabecalho
  @ cl,000 SAY [Quantidade: ]+STR(ctmed,5)+[ credenciados emitiram ] +;
    STR(ctaux,6)+[ guias entre ]+DTOC(M->rde)+[ e ]+DTOC(M->rate)+[.]
 ENDD ccop
 EJEC                                              // salta pagina
END SEQUENCE
IMPCTL(drvtcom)                                    // retira comprimido
SET PRINTER TO (drvporta)                          // fecha arquivo gerado (se houver)
SET DEVI TO SCRE                                   // direciona saida p/ video
IF tps=2                                           // se vai para arquivo/video
 BROWSE_REL(arq_,2,3,MAXROW()-2,78)
ENDI                                               // mostra o arquivo gravado
GRELA(25)                                          // grava variacao do relatorio
SET(_SET_DELETED,dele_atu)                         // os excluidos serao vistos
RETU

STATIC PROC REL_CAB(qt)                            // cabecalho do relatorio
IF qt>0                                            // se parametro maior que 0
 cl=cl+qt                                          // soma no contador de linhas
ENDI
IF cl>maxli .OR. qt=0                              // quebra de pagina
 IMPAC(nemp,0,000)                                 // nome da empresa
 @ 0,100 SAY "PAG"
 @ 0,104 SAY TRAN(pg_,'9999')                      // n£mero da p gina
 IMPAC(nsis,1,000)                                 // t¡tulo aplica‡„o
 @ 1,100 SAY "CON_R027"                            // c¢digo relat¢rio
 @ 2,000 SAY "RANKING (De: "+DTOC(M->rde)+[   ate: ]+DTOC(M->rate)+[)]
 @ 2,090 SAY NSEM(DATE())                          // dia da semana
 @ 2,098 SAY DTOC(DATE())                          // data do sistema
 @ 3,000 SAY titrel                                // t¡tulo a definir
 IMPAC("C¢digo     Nome                                     Especialidade                  Telefone       N§ Guias",4,000)
 @ 5,000 SAY REPL("-",108)
 cl=qt+5 ; pg_++
ENDI
RETU

* \\ Final de CON_R027.PRG
€
 GRU_01F9A–Ñ  GRU_01F9CODEC_ETEXTENDCODE	_SYMSTARTSYMSTARTSYMBOLSSYMBOLS_SYMENDSYMENDNULLBEGDATA_DATADATA_SYMPBDATA_SYMPDATA_SYMPEDATA_CONSTCONST_MSGMSG_BEGBSSBEGBSS_BSSBSS_ENDBSSENDBSSDGROUP ˜ @Ç T˜ H  ˜ h  ë˜ `À 	/˜ h  
ã˜ h  ß˜ H  û˜ H  ÷˜ H ë˜ H  ï˜ H  ë˜ (  ˜ H  €
 RX2901F9y–Ñ  RX2901F9CODEC_ETEXTENDCODE	_SYMSTARTSYMSTARTSYMBOLSSYMBOLS_SYMENDSYMENDNULLBEGDATA_DATADATA_SYMPBDATA_SYMPDATA_SYMPEDATA_CONSTCONST_MSGMSG_BEGBSSBEGBSS_BSSBSS_ENDBSSENDBSSDGROUP8˜ @y ˜ H  ˜ h  ë˜ `  	O˜ h  
ã˜ h  ß˜ H  û˜ H  ÷˜ H ë˜ H  ï˜ H  ë˜ (  ˜ H  GAS-Pro v3.0
009005016077001003023001012001176001
 Processo      ³ Num.   ³ Falecido                            Data
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
               ³        ³
               ³        ³
               ³        ³
               ³        ³
[Ÿ]
Inclus„o~~26006
Manuten‡„o~~27007
Consulta~~28008
[Ÿ]
 9 
 3 
Grupo/Circular

 1 
 2 
 3 
[Ÿ]
p/Data

 9 
[Ÿ]
Grupo e Data

 9 
[Ÿ]
Processos da Circular
Processos da Circular







005







 0 
 0 
-1 
-1 
-1 
-1 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
grupo
C
I
!!
 2 
 2 
 0 
 0 
 0 
Grupo






-1 
 0 


circ
C
I
999
 3 
 3 
 0 
 0 
 0 
Circular






-1 
 0 


processo
C
E
@R 99999/99/!!
 9 
 11 
 3 
 1 
 0 
Processo

!EMPT(processo)
Necess rio informar PROCESSO

Informe o n£mero do processo a incluir

 0 
 0 


categ
C
E
!!
 2 
 2 
 3 
 13 
 0 
Categoria

categ $ [PL|PD|AF]
CATEGORIA n„o aceit vel

Preencha com:|PL para Plano,| PD p/Diferen‡a ou |AX para Aux.Funeral
MTAB([PL=Plano|PD=Plano c/Diferen‡a|AF=Auxilio],[CATEGORIA])
 0 
 0 


num
C
E
999999
 6 
 6 
 3 
 18 
 0 
Num

!EMPT(num).AND.PTAB(num,'GRUPOS',1)
NUM n„o existe na tabela



 0 
 0 


fal
C
E
@!
 35 
 35 
 3 
 27 
 0 
Fal

!EMPT(fal)
Necess rio informar FAL



 0 
 0 


ends
C
I
@!
 40 
 40 
 0 
 0 
 0 
Ends






 0 
 0 


cids
C
I
@!
 15 
 15 
 0 
 0 
 0 
Cids






 0 
 0 


dfal
D
E
@D
 8 
 8 
 3 
 63 
 0 
Data

!EMPT(dfal)
Necess rio informar DATA



 0 
 0 


 1 
Nome
INSCRITS->nome

 0 
 0 
 35 

 1 
CIRCULAR
procpend
CIRCULAR->procpend + 1
CIRCULAR->procpend - 1



 0 
 0 
 0 
GAS-Pro v3.0
009017014060001004014001013000176001
 Contrato:


 Circular:  -               Confirma?
[Ÿ]
[Ÿ]
 4 
 0 
Taxas (2¦ Via)
Taxas (2¦ Via)







056







 0 
 0 
-1 
-1 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
rcodigo
C
E
999999
 6 
 6 
 1 
 12 
 0 
Codigo

PTAB(rcodigo,'GRUPOS',1)
Necess rio informar CODIGO

Informe o n£mero do contrato
VDBF(6,3,20,77,'GRUPOS',{'grupo','codigo','nome','cidade'},1,'codigo',[])
 0 
 0 


rtipo
C
E
!
 1 
 1 
 4 
 12 
 0 
Tipo

rtipo $ [123678]
TIPO n„o aceit vel

Qual o tipo de lan‡amento
MTAB([1=J¢ia|2=Taxa|3=Carnˆ|6=J¢ia+Seguro|7=Taxa+Seguro|8=Carnˆ+Seguro],[TIPO])
 0 
 0 


rcirc
C
E
999
 3 
 3 
 4 
 14 
 0 
Circular

PTAB(rcodigo+rtipo+rcirc,'TAXAS',1)
Necess rio informar CIRCULAR v lida

Informe o n£mero da circular a imprimir

 0 
 0 


confirme
C
E
!
 1 
 1 
 4 
 39 
 0 
Confirme?

confirme='S'.AND.V03301F9()
Digite S para confirmar|ou|Tecle ESC para cancelar

Digite S para confirmar|ou|Tecle ESC para cancelar

 0 
 0 


 2 
Nome
GRUPOS->nome
@!
 2 
 5 
 35 

Endere‡o
GRUPOS->endereco

 3 
 5 
 35 

 0 
 0 
 0 
 0 
BLINKER INCREMENTAL OFF
BLINKER OVERLAY UMB ON
BLINKER OVERLAY PAGEFRAME ON
BLINKER CACHE EMS 50%
BLINKER CACHE XMS 50%
BLINKER OVE OPS 60
BLINKER EXECUTABLE CLIPPER F200
BLINKER MESSAGE NOBLINK


MAP S,A
OUTPUT adrbig
STACK 10240


FI ADrBIG
fi sixuk
fi sixnsx
fi sixtools
LIB GASPRO52

beginarea
FI CAD_04F9
FI BXR_02F9
FI BXR_01F9
FI BXREC
FI ALE_01F9
FI ALENDER
FI OBX_02F9
FI OBXEC
FI GRU_01F9
FI GRU_02F9
FI GRUPOS
FI CTAINSC
FI CTXAS
FI TAX_02F9
FI INS_01F9
FI INS_02F9
FI GUI_07F9
FI GUI_06F9
FI GUI_08F9
FI GUI_02F9
FI GUIAS
FI KINSCF9
FI AFUNER
FI R02001F9
FI R02002F9
FI ADM_R020
FI V02001F9
FI V02002F9
FI R02901F9
FI ADR_R029
FI RX2001F9
FI RX2002F9
FI ADM_RX20
FI RX2901F9
FI ADR_RX29
FI ADM_R029
FI ADM_R026
FI ADM_R021
FI DCI_P001
FI DCI01F9
FI DCI03F9
FI DCI04F9
FI ADM_RS18
FI V01801F9
FI ADM_R022
FI ADM_R023
FI V02301F9
FI CON_R001
FI V00101F9
FI R03001F9
FI ADM_R039
FI IMP_01F9
FI IMPPAR
FI MEDICOS
FI TESPEC
FI JUROS
FI TFILIAIS
FI ARQGRUP
FI REGIAO
FI COB_01F9
FI COBRADOR
FI CLASSES
FI CIRCULAR
FI PRCESSOS
FI FNCS
FI HISTORIC
FI CSTSEG
FI MEN_01F9
FI MENSAG
FI ORDPGRC
FI PAR_ADM
FI ADR_ESTR
FI ADR_ATRI
FI ADR_ATR1
FI ADR_ATR2
FI ABOUT
endarea
FI ADR_PROC
FI ADR_FUNC
FI ADR_FUN2
FI ADR_OUTR

@CL520MID.LNK
@SIX3.LNK

procedure gui_02f9
/*
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
 \ Empresa.: PresServ Inform tica-Limeira (019)452.6623.
 \ Programa: GUI_02F9.PRG
 \ Data....: 22-11-95
 \ Sistema.: Controle de Convˆnios
 \ Funcao..: F¢rmula (circ 1-4) a mostrar na tela de GUIAS
 \ Analista: Ademilson Pedro Bom
 \ Criacao.: Programado manualmente pelo analista
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/

#include "ADRbig.ch"    // inicializa constantes manifestas

 LOCAL reg_dbf:=POINTER_DBF()
 LOCAL circax1:=circax2:=circax3:=circax4:=circax5:=circax6:=SPACE(46)
 LOCAL cipend:=ciatrz:=nrd:=vladd:=0, jrok
 IF !op_menu = INCLUSAO
	contrato:=GUIAS->contrato
 ENDIF
 dele_atu:=SET(_SET_DELETED,.t.)             // os excluidos nao servem...


 PTAB(contrato,'GRUPOS',1)
 PTAB(contrato,'TAXAS',1)
 SELE TAXAS

 DO WHILE !EOF() .AND. TAXAS->codigo = GRUPOS->codigo
  IF DELE()
   SKIP
   LOOP
  ENDI
	vladd:=0

	IF EMPT(TAXAS->valorpg)
	 cipend++
	 IF TAXAS->emissao_< DATE()
    ciatrz++
    jrok:=PTAB(tipo,'JUROS',1)
    nrd:=(DATE() - TAXAS->emissao_)
    IF jrok .AND. (nrd > JUROS->mltcaren)
     vladd+=TAXAS->valor*JUROS->multa/100
    ENDI
    IF jrok .AND. (nrd > JUROS->jrscaren)
     vladd+=TAXAS->valor*JUROS->juros/100*nrd
    ENDI
   ENDI
  ENDI
  IF cipend < 4 .AND. TAXAS->emissao_ <= DATE()+30
   circax1:=circax2
   circax2:=circax3
   circax3:=circax4
   circax4:=[ ]+TAXAS->tipo+[ ]+TAXAS->circ+[ ]+DTOC(TAXAS->emissao_)+[ ]+;
      TRANSF(TAXAS->valor+M->vladd,"@E 99,999.99")+[ ]+DTOC(TAXAS->pgto_)+;
      TRANSF(TAXAS->valorpg,"@E 99,999.99") //+[ ]+TAXAS->cobrador
  ENDI
  SKIP
 ENDDO
 @ l_s+06, c_s+1 SAY SPACE(56)
 @ l_s+07, c_s+1 SAY SPACE(56)
 @ l_s+08, c_s+1 SAY SPACE(56)
 @ l_s+09, c_s+1 SAY SPACE(56)
 @ l_s+06, c_s+1 SAY circax1
 @ l_s+07, c_s+1 SAY circax2
 @ l_s+08, c_s+1 SAY circax3
 @ l_s+09, c_s+1 SAY circax4

 POINTER_DBF(reg_dbf)



RETU []         // <- deve retornar um valor qualquer


* \\ Final de GUI_02F9.PRG
€
 GUI_02F9I–Ñ  GUI_02F9CODEC_ETEXTENDCODE	_SYMSTARTSYMSTARTSYMBOLSSYMBOLS_SYMENDSYMENDNULLBEGDATA_DATADATA_SYMPBDATA_SYMPDATA_SYMPEDATA_CONSTCONST_MSGMSG_BEGBSSBEGBSS_BSSBSS_ENDBSSENDBSSDGROUP˜ @JÎ˜ H  ˜ h  ë˜ `0	½˜ h  
ã˜ h  ß˜ H  û˜ H  ÷˜ H ë˜ H  ï˜ H  ë˜ (  ˜ H  €
 HISTORIC	–I HISTORICCODEHIS_INCLCODE
HIS_ANT_SECODE
HIS_CRIA_SCODE
HIS_GERA_SCODE
HIS_GRAVA_CODEHIS_TELACODEHIS_GETSCODEHIS_GET1CODEC_ETEXTENDCODE	_SYMSTARTSYMSTARTSYMBOLSSYMBOLS_SYMENDSYMENDNULLBEGDATA_DATADATA_SYMPBDATA_SYMPDATA_SYMPEDATA_CONSTCONST_MSGMSG_BEGBSSBEGBSS_BSSBSS_ENDBSSENDBSSDGROUP˜ @ö#˜ @4
Ù˜ @| —˜ @M	Á˜ @ê 
!˜ @2 Õ˜ @H¶˜ @¦W˜ @\›˜ H  ï˜ h  Ë˜ `pX˜ h  € REGIAO»–G REGIAOCODEREG_INCLCODE
REG_ANT_SECODE
REG_CRIA_SCODE
REG_GERA_SCODE
REG_GRAVA_CODEREG_TELACODEREG_GETSCODEREG_GET1CODEC_ETEXTENDCODE	_SYMSTARTSYMSTARTSYMBOLSSYMBOLS_SYMENDSYMENDNULLBEGDATA_DATADATA_SYMPBDATA_SYMPDATA_SYMPEDATA_CONSTCONST_MSGMSG_BEGBSSBEGBSS_BSSBSS_ENDBSSENDBSSDGROUPý˜ @ô%˜ @^³˜ @s  ˜ @(	æ˜ @« 
`˜ @) Þ˜ @¸I˜ @Ô*˜ @­L˜ H  ï˜ h  Ë˜ ` È˜ h  procedure v02201f9
/*
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
 \ Empresa.: PresServ Inform tica-Limeira (019)452.6623
 \ Programa: V02201F9.PRG
 \ Data....: 14-11-95
 \ Sistema.: Administradora de Funer rias
 \ Funcao..: Valida‡„o da variavel CONFIRME, relatorio ADM_R022
 \ Analista: Ademilson Pedro Bom
 \ Criacao.: Programado manualmente pelo analista
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/

#include "admbig.ch"    // inicializa constantes manifestas


PARAMETROS('impnrrec',rnumero)

RETU .T.   // <- deve retornar um valor L¢GICO

* \\ Final de V02201F9.PRG
€
 GUI_06F9E–Ñ  GUI_06F9CODEC_ETEXTENDCODE	_SYMSTARTSYMSTARTSYMBOLSSYMBOLS_SYMENDSYMENDNULLBEGDATA_DATADATA_SYMPBDATA_SYMPDATA_SYMPEDATA_CONSTCONST_MSGMSG_BEGBSSBEGBSS_BSSBSS_ENDBSSENDBSSDGROUP˜ @ÌN˜ H  ˜ h  ë˜ `P	ž˜ h  
ã˜ h  ß˜ H  û˜ H  ÷˜ H ë˜ H  ï˜ H  ë˜ (  ˜ H  GAS-Pro v3.0
011027015057001001028001012000176001
 Usu rio........:
 Lan‡to. inicial:
 Lan‡to. final..:
[Ÿ]
[Ÿ]
 3 
 0 
Endere‡os Alterados
Endere‡os Alterados







056







 0 
 0 
-1 
-1 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
musuario
C
E
@!
 10 
 10 
 1 
 19 
 0 
Usuario

 

M->usuario
Informe o usu rio a listar|ou deixe sem preencher para listar todos.
M->usuario
 0 
 0 


emisini_
D
E
@D
 8 
 8 
 2 
 19 
 0 
Lan‡to. inicial

!EMPT(emisini_).and. emisini_<=DATE()
Necess rio informar Lan‡to. inicial correta
DATE() - DAY(DATE()) + 1
Informe a data inicial

 0 
 0 


emisfim_
D
E
@D
 8 
 8 
 3 
 19 
 0 
Lan‡to. final

!EMPT(emisfim_).and.emisfim_>=emisini_.and.emisfim_<=DATE()
Necess rio informar Lan‡to. final correta
DATE()
Informe a data final

 0 
 0 


 0 
 0 
 0 
 0 
 0 
GAS-Pro v2.0
011022014058001002026001013000176001
[Ÿ]
 8 
TAXAS
Taxas p/2¦Via

cobrador+codigo

052









-1 
 1 
 0 
 2 
 0 
 35 
 1 
 4 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
-1 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
Codig
codigo
99999
 5 
C
 1 
 1 


          










Circ
circ
999
 3 
C
 1 
 7 


          










Emissao
emissao_
@D
 8 
D
 1 
 11 


          










Valor
valor
@E 999,999.99
 10 
N
 1 
 20 


          










Pagto.
pgto_
@D
 8 
D
 2 
 3 


          










Cb
cobrador
!!
 2 
C
 2 
 12 


          










Valor Pg
valorpg
@E 999,999.99
 10 
N
 2 
 15 


          










F
forma

 1 
C
 2 
 26 


          










 0 
 0 
 0 
 0 
 0 
/*
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
 \ Empresa.: PresServ Inform tica - Limeira (019)452.6623
 \ Programa: ADR_ATRI.PRG
 \ Data....: 29-01-04
 \ Sistema.: Administradora - RECEP€„O
 \ Funcao..: Define atributos dos arquivos (sistema[])
 \ Analista: Ademilson Pedro Bom
 \ Criacao.: GAS-Pro v4.0o
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/

#include "adrbig.ch"    // inicializa constantes manifestas


/*
   A adicao das  definicoes dos campos (mascara, titulo, cmd esp, when/defa,
   critica, ajuda) dentro do vetor sistema e' feita atraves da funcao AADD(),
   isto previne erro "memory overbooked" do CA-Clipper, durante a compilacao,
   devido a linha ser muito extensa
*/

sistema[001]={;
            "Recebimentos",;                                // opcao do menu
            "Recebimentos",;                                // titulo do sistema
            {"numero","numop+numero","codigo"},;            // chaves do arquivo
            {"N£mero","Caixa","Contrato"},;                 // titulo dos indices para consulta
            {"01","0801","02"},;                            // ordem campos chaves
            {"BXREC",drvdbf,drvntx},;                       // nome do DBF
            {"BXREC1","BXREC2","BXREC3"},;                  // nomes dos NTX
            {},;                                            // nome dos dbf's relacionados
            {},;                                            // campos de relacionamento
            {1,1,3,11,23,62},;                              // num telas/tela atual/coordenadas
            {1,.t.,.f.},;                                   // nivel acesso/tp chave/pede dir
            {},;                                            // campos do arquivo
            {},;                                            // formula mostradas
            {"nivelop>1","Permitido apenas a usu rios cadastrados|com n¡vel de Manuten‡„o ou Maior"},;// condicao de exclusao de registros
            {"nivelop=3","Para alterar este documento|chame o gerente de sistema"},;// condicao de alteracao de registros
            {"nivelop>1","Permitido apenas a usu rios cadastrados|com n¡vel de Manuten‡„o ou Maior"};// condicao de recupercao de registros
           }

AADD(sistema[001,O_CAMPO],{;            // BXREC
     /* mascara       */    "99999999",;
     /* titulo        */    "Numero",;
     /* cmd especial  */    "",;
     /* default       */    "RIGHT(DTOC(DATE()),2)+[000001]",;
     /* pre-validacao */    "",;
     /* validacao     */    "V",;
     /* help do campo */    "";
                         };
)
AADD(sistema[001,O_CAMPO],{;            // BXREC
     /* mascara       */    "@!",;
     /* titulo        */    "Codigo",;
     /* cmd especial  */    "VDBF(6,3,20,77,'GRUPOS',{'codigo','grupo','nome','endereco'},1,'codigo',[])",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "(BXR_07F9().AND.PTAB(ALLTRIM(codigo),[GRUPOS])).AND.(PTAB(codigo,'TAXAS',1).OR.1=1).AND.CAD_04F9(op_menu)~Contrato inv lido |ou inexistente",;
     /* help do campo */    "Informe o n£mero do contrato";
                         };
)
AADD(sistema[001,O_CAMPO],{;            // BXREC
     /* mascara       */    "@!",;
     /* titulo        */    "Cobranca",;
     /* cmd especial  */    "BXR_06F9()",;
     /* default       */    "",;
     /* pre-validacao */    "BXR_06F9()",;
     /* validacao     */    "PTAB(cobranca,[TAXAS],1).or.!EMPT(cobranca)~Necess rio informar COBRANCA",;
     /* help do campo */    "";
                         };
)
AADD(sistema[001,O_CAMPO],{;            // BXREC
     /* mascara       */    "@E 999,999.99",;
     /* titulo        */    "Valor pago",;
     /* cmd especial  */    "BXR_02F9()",;
     /* default       */    "BXR_02F9()",;
     /* pre-validacao */    "!EMPT(cobranca)",;
     /* validacao     */    "valorpg>0.and.!EMPT(BXR_02F9())~VALOR PAGO n„o aceit vel|Digite o valor recebido",;
     /* help do campo */    "Informe o valor pago ou zeros se for retorno.";
                         };
)
AADD(sistema[001,O_CAMPO],{;            // BXREC
     /* mascara       */    "@E 999,999.99",;
     /* titulo        */    "Pago com...",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "valoraux>=valorpg~VALOR INSUFICIENTE para quitar o d‚bito|A T E N € Ç O",;
     /* help do campo */    "Informe o valor pago";
                         };
)
AADD(sistema[001,O_CAMPO],{;            // BXREC
     /* mascara       */    "@D",;
     /* titulo        */    "Emitido em",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "V",;
     /* help do campo */    "";
                         };
)
AADD(sistema[001,O_CAMPO],{;            // BXREC
     /* mascara       */    "",;
     /* titulo        */    "Por",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "V",;
     /* help do campo */    "";
                         };
)
AADD(sistema[001,O_CAMPO],{;            // BXREC
     /* mascara       */    "999999",;
     /* titulo        */    "N§ O.P.",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "V",;
     /* help do campo */    "";
                         };
)
AADD(sistema[001,O_CAMPO],{;            // BXREC
     /* mascara       */    "!9",;
     /* titulo        */    "Grupo",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[001,O_CAMPO],{;            // BXREC
     /* mascara       */    "@!",;
     /* titulo        */    "Filial",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[001,O_CAMPO],{;            // BXREC
     /* mascara       */    "99999999",;
     /* titulo        */    "Num.Lan‡amento",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[001,O_FORMULA],{;          // BXREC - Nome
     /* form mostrar  */    "LEFT(TRAN((GRUPOS->nome),[]),35)",;
     /* lin da formula*/    4,;
     /* col da formula*/    2;
                         };
)
AADD(sistema[001,O_FORMULA],{;          // BXREC - Circ 1 - 4
     /* form mostrar  */    "LEFT(TRAN(BXR_01F9(),[]),48)",;
     /* lin da formula*/    11,;
     /* col da formula*/    2;
                         };
)
AADD(sistema[001,O_FORMULA],{;          // BXREC - Ult.Circular
     /* form mostrar  */    "LEFT(TRAN(GRUPOS->ultcirc,[999]),03)",;
     /* lin da formula*/    6,;
     /* col da formula*/    47;
                         };
)
AADD(sistema[001,O_FORMULA],{;          // BXREC - Situa‡„o
     /* form mostrar  */    "LEFT(TRAN(IIF(GRUPOS->situacao='2',[CANCELADO],[         ])+IF(codigo<[020],[ - Grupo ]+GRUPOS->grupo,[]),[]),22)",;
     /* lin da formula*/    2,;
     /* col da formula*/    23;
                         };
)
AADD(sistema[001,O_FORMULA],{;          // BXREC - Admiss„o
     /* form mostrar  */    "LEFT(TRAN(GRUPOS->admissao,[@D]),10)",;
     /* lin da formula*/    8,;
     /* col da formula*/    12;
                         };
)
AADD(sistema[001,O_FORMULA],{;          // BXREC - Saitxa
     /* form mostrar  */    "LEFT(TRAN(GRUPOS->saitxa,[@R 99/99]),05)",;
     /* lin da formula*/    8,;
     /* col da formula*/    33;
                         };
)
AADD(sistema[001,O_FORMULA],{;          // BXREC - Cobrador
     /* form mostrar  */    "LEFT(TRAN(GRUPOS->cobrador+IIF(PTAB(LEFT(GRUPOS->cobrador,3),[COBRADOR],1),cobrador->nome,[...]),[@!]),25)",;
     /* lin da formula*/    9,;
     /* col da formula*/    25;
                         };
)
AADD(sistema[001,O_FORMULA],{;          // BXREC - Funerais
     /* form mostrar  */    "LEFT(TRAN(GRUPOS->funerais,[99]),02)",;
     /* lin da formula*/    9,;
     /* col da formula*/    12;
                         };
)
AADD(sistema[001,O_FORMULA],{;          // BXREC - Circ.Inicial
     /* form mostrar  */    "LEFT(TRAN(GRUPOS->circinic,[999]),03)",;
     /* lin da formula*/    5,;
     /* col da formula*/    46;
                         };
)
AADD(sistema[001,O_FORMULA],{;          // BXREC - Endere‡o
     /* form mostrar  */    "LEFT(TRAN(xDECRIPT(GRUPOS->endereco),[]),35)",;
     /* lin da formula*/    5,;
     /* col da formula*/    2;
                         };
)
AADD(sistema[001,O_FORMULA],{;          // BXREC - Bairro
     /* form mostrar  */    "LEFT(TRAN(xDECRIPT(GRUPOS->bairro),[]),25)",;
     /* lin da formula*/    6,;
     /* col da formula*/    2;
                         };
)
AADD(sistema[001,O_FORMULA],{;          // BXREC - Cidade
     /* form mostrar  */    "LEFT(TRAN(xDECRIPT(GRUPOS->cidade),[]),25)",;
     /* lin da formula*/    7,;
     /* col da formula*/    2;
                         };
)
AADD(sistema[001,O_FORMULA],{;          // BXREC - CEP
     /* form mostrar  */    "LEFT(TRAN(xDECRIPT(GRUPOS->cep),[@R 99999-999]),09)",;
     /* lin da formula*/    7,;
     /* col da formula*/    29;
                         };
)
AADD(sistema[001,O_FORMULA],{;          // BXREC - Regi„o
     /* form mostrar  */    "LEFT(TRAN(GRUPOS->regiao,[999]),03)",;
     /* lin da formula*/    6,;
     /* col da formula*/    35;
                         };
)
AADD(sistema[001,O_FORMULA],{;          // BXREC - troco
     /* form mostrar  */    "LEFT(TRAN(valoraux-valorpg,[@E 999,999.99]),11)",;
     /* lin da formula*/    17,;
     /* col da formula*/    33;
                         };
)
AADD(sistema[001,O_FORMULA],{;          // BXREC - Filial
     /* form mostrar  */    "LEFT(TRAN(filial,[@!]),02)",;
     /* lin da formula*/    1,;
     /* col da formula*/    23;
                         };
)

sistema[002]={;
            "Endere‡os",;                                   // opcao do menu
            "Endere‡os",;                                   // titulo do sistema
            {"codigo"},;                                    // chaves do arquivo
            {"Contrato"},;                                  // titulo dos indices para consulta
            {"01"},;                                        // ordem campos chaves
            {"ALENDER",drvdbf,drvntx},;                     // nome do DBF
            {"ALENDER1"},;                                  // nomes dos NTX
            {},;                                            // nome dos dbf's relacionados
            {},;                                            // campos de relacionamento
            {1,1,8,2,17,77},;                               // num telas/tela atual/coordenadas
            {1,.f.,.f.},;                                   // nivel acesso/tp chave/pede dir
            {},;                                            // campos do arquivo
            {},;                                            // formula mostradas
            {"nivelop>1","Permitido apenas a usu rios cadastrados|com n¡vel de Manuten‡„o ou Maior"},;// condicao de exclusao de registros
            {"nivelop>1","Permitido apenas a usu rios cadastrados|com n¡vel de Manuten‡„o ou Maior"},;// condicao de alteracao de registros
            {"nivelop>1","Permitido apenas a usu rios cadastrados|com n¡vel de Manuten‡„o ou Maior"};// condicao de recupercao de registros
           }

AADD(sistema[002,O_CAMPO],{;            // ALENDER
     /* mascara       */    "@!",;
     /* titulo        */    "Codigo",;
     /* cmd especial  */    "VDBF(6,31,20,77,'GRUPOS',{'codigo','nome'},4,'codigo')",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "PTAB(codigo,'GRUPOS',1).AND.ALE_01F9().AND.CAD_04F9(op_menu)~CODIGO n„o aceit vel|Tecle F8 para consulta",;
     /* help do campo */    "Entre com o n£mero do contrato|Tecle F8 para consulta";
                         };
)
AADD(sistema[002,O_CAMPO],{;            // ALENDER
     /* mascara       */    "99999999",;
     /* titulo        */    "Numero",;
     /* cmd especial  */    "",;
     /* default       */    "RIGHT(DTOC(DATE()),2)+[000001]",;
     /* pre-validacao */    "",;
     /* validacao     */    "V",;
     /* help do campo */    "";
                         };
)
AADD(sistema[002,O_CAMPO],{;            // ALENDER
     /* mascara       */    "",;
     /* titulo        */    "Endere‡o",;
     /* cmd especial  */    "",;
     /* default       */    "xDECRIPT(GRUPOS->endereco)",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(endereco)~Necess rio informar ENDERE€O do Titular",;
     /* help do campo */    "Informe o Endere‡o para correspondˆncias.|Rua,n£mero,apto, blocl, etc...";
                         };
)
AADD(sistema[002,O_CAMPO],{;            // ALENDER
     /* mascara       */    "",;
     /* titulo        */    "Bairro",;
     /* cmd especial  */    "",;
     /* default       */    "xDECRIPT(GRUPOS->bairro)",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(bairro)~Necess rio informar BAIRRO do Titular",;
     /* help do campo */    "";
                         };
)
AADD(sistema[002,O_CAMPO],{;            // ALENDER
     /* mascara       */    "",;
     /* titulo        */    "Cidade",;
     /* cmd especial  */    "",;
     /* default       */    "xDECRIPT(GRUPOS->cidade)",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(cidade)~Necess rio informar MUNICIPIO para cobran‡a do Titular.",;
     /* help do campo */    "";
                         };
)
AADD(sistema[002,O_CAMPO],{;            // ALENDER
     /* mascara       */    "!!",;
     /* titulo        */    "UF",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "VUF(uf).OR.EMPT(UF)~UNIDADE DA FEDERA€ŽO inv lida",;
     /* help do campo */    "Qual ‚ o estado da federa‡„o";
                         };
)
AADD(sistema[002,O_CAMPO],{;            // ALENDER
     /* mascara       */    "@R 99999-999",;
     /* titulo        */    "CEP",;
     /* cmd especial  */    "",;
     /* default       */    "xDECRIPT(GRUPOS->cep)",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(cep)~Necess rio informar CEP do Titular |com 08 digitos",;
     /* help do campo */    "";
                         };
)
AADD(sistema[002,O_CAMPO],{;            // ALENDER
     /* mascara       */    "@!",;
     /* titulo        */    "Telefone",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    "Informe o n£mero de telefone para|Contato com o contratante";
                         };
)
AADD(sistema[002,O_CAMPO],{;            // ALENDER
     /* mascara       */    "!!!",;
     /* titulo        */    "Cobrador",;
     /* cmd especial  */    "VDBF(6,39,20,77,'REGIAO',{'regiao','cobrador'},2,'cobrador',[!EMPT(cobrador)])",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "PTAB(cobrador,'COBRADOR',1).OR.EMPT(cobrador)~COBRADOR n„o existe na tabela",;
     /* help do campo */    "Digite o c¢digo do COBRADOR que|receber  as Taxas deste contrato,|Tecle F8 para consultar os cobradores.";
                         };
)
AADD(sistema[002,O_CAMPO],{;            // ALENDER
     /* mascara       */    "@D",;
     /* titulo        */    "Data_",;
     /* cmd especial  */    "",;
     /* default       */    "DATE()",;
     /* pre-validacao */    "",;
     /* validacao     */    "V",;
     /* help do campo */    "";
                         };
)
AADD(sistema[002,O_CAMPO],{;            // ALENDER
     /* mascara       */    "",;
     /* titulo        */    "Por",;
     /* cmd especial  */    "",;
     /* default       */    "M->usuario",;
     /* pre-validacao */    "",;
     /* validacao     */    "V",;
     /* help do campo */    "";
                         };
)
AADD(sistema[002,O_CAMPO],{;            // ALENDER
     /* mascara       */    "",;
     /* titulo        */    "Endere‡o",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "V",;
     /* help do campo */    "";
                         };
)
AADD(sistema[002,O_CAMPO],{;            // ALENDER
     /* mascara       */    "",;
     /* titulo        */    "Bairro",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "V",;
     /* help do campo */    "";
                         };
)
AADD(sistema[002,O_CAMPO],{;            // ALENDER
     /* mascara       */    "",;
     /* titulo        */    "Cidade",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "V",;
     /* help do campo */    "";
                         };
)
AADD(sistema[002,O_CAMPO],{;            // ALENDER
     /* mascara       */    "!!",;
     /* titulo        */    "UF",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "V",;
     /* help do campo */    "";
                         };
)
AADD(sistema[002,O_CAMPO],{;            // ALENDER
     /* mascara       */    "@R 99999-999",;
     /* titulo        */    "CEP",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "V",;
     /* help do campo */    "";
                         };
)
AADD(sistema[002,O_CAMPO],{;            // ALENDER
     /* mascara       */    "@!",;
     /* titulo        */    "Telefone",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "V",;
     /* help do campo */    "";
                         };
)
AADD(sistema[002,O_CAMPO],{;            // ALENDER
     /* mascara       */    "!!!",;
     /* titulo        */    "Cobrador",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "V",;
     /* help do campo */    "";
                         };
)
AADD(sistema[002,O_CAMPO],{;            // ALENDER
     /* mascara       */    "",;
     /* titulo        */    "Dgrupo",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "V",;
     /* help do campo */    "";
                         };
)
AADD(sistema[002,O_CAMPO],{;            // ALENDER
     /* mascara       */    "@D",;
     /* titulo        */    "Emitido",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "nivelop=3",;
     /* validacao     */    "",;
     /* help do campo */    "Data da emiss„o de solicita‡„o do endere‡o";
                         };
)
AADD(sistema[002,O_CAMPO],{;            // ALENDER
     /* mascara       */    "@!",;
     /* titulo        */    "Filial",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[002,O_FORMULA],{;          // ALENDER - Nome
     /* form mostrar  */    "LEFT(TRAN(GRUPOS->nome,[]),35)",;
     /* lin da formula*/    1,;
     /* col da formula*/    28;
                         };
)
AADD(sistema[002,O_FORMULA],{;          // ALENDER - Filial
     /* form mostrar  */    "LEFT(TRAN(filial,[@!]),02)",;
     /* lin da formula*/    1,;
     /* col da formula*/    24;
                         };
)


sistema[003]={;
            "Outros Recebimentos",;                         // opcao do menu
            "Outros Recebimentos",;                         // titulo do sistema
            {"numero","numop+numero","codigo"},;            // chaves do arquivo
            {"N£mero","Caixa","Contrato"},;                 // titulo dos indices para consulta
            {"01","0801","02"},;                            // ordem campos chaves
            {"OBXEC",drvdbf,drvntx},;                       // nome do DBF
            {"OBXEC1","OBXEC2","OBXEC3"},;                  // nomes dos NTX
            {},;                                            // nome dos dbf's relacionados
            {},;                                            // campos de relacionamento
            {1,1,3,11,23,62},;                              // num telas/tela atual/coordenadas
            {1,.t.,.f.},;                                   // nivel acesso/tp chave/pede dir
            {},;                                            // campos do arquivo
            {},;                                            // formula mostradas
            {"nivelop>1","Permitido apenas a usu rios cadastrados|com n¡vel de Manuten‡„o ou Maior"},;// condicao de exclusao de registros
            {"nivelop=3","Para alterar este documento|chame o gerente de sistema"},;// condicao de alteracao de registros
            {"nivelop>1","Permitido apenas a usu rios cadastrados|com n¡vel de Manuten‡„o ou Maior"};// condicao de recupercao de registros
           }

AADD(sistema[003,O_CAMPO],{;            // OBXEC
     /* mascara       */    "99999999",;
     /* titulo        */    "Numero",;
     /* cmd especial  */    "",;
     /* default       */    "RIGHT(DTOC(DATE()),2)+[000001]",;
     /* pre-validacao */    "",;
     /* validacao     */    "V",;
     /* help do campo */    "";
                         };
)
AADD(sistema[003,O_CAMPO],{;            // OBXEC
     /* mascara       */    "@!",;
     /* titulo        */    "Codigo",;
     /* cmd especial  */    "VDBF(6,3,20,77,'GRUPOS',{'codigo','grupo','nome','endereco'},1,'codigo',[])",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "(PTAB(ALLTRIM(codigo),[GRUPOS]).AND.OBX_07F9()).AND.(PTAB(codigo,'TAXAS',1).OR.1=1).AND.CAD_04F9(op_menu)~Contrato inv lido |ou inexistente",;
     /* help do campo */    "Informe o n£mero do contrato";
                         };
)
AADD(sistema[003,O_CAMPO],{;            // OBXEC
     /* mascara       */    "@!S20",;
     /* titulo        */    "Cobranca",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(cobranca)~Necess rio informar COBRANCA",;
     /* help do campo */    "";
                         };
)
AADD(sistema[003,O_CAMPO],{;            // OBXEC
     /* mascara       */    "@E 999,999.99",;
     /* titulo        */    "Valor pago",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "!EMPT(cobranca)",;
     /* validacao     */    "valorpg>0~VALOR PAGO n„o aceit vel|Digite o valor recebido",;
     /* help do campo */    "Informe o valor pago ou zeros se for retorno.";
                         };
)
AADD(sistema[003,O_CAMPO],{;            // OBXEC
     /* mascara       */    "@E 999,999.99",;
     /* titulo        */    "Pago com...",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "valoraux>=valorpg~VALOR INSUFICIENTE para quitar o d‚bito|A T E N € Ç O",;
     /* help do campo */    "Informe o valor pago";
                         };
)
AADD(sistema[003,O_CAMPO],{;            // OBXEC
     /* mascara       */    "@D",;
     /* titulo        */    "Emitido em",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "V",;
     /* help do campo */    "";
                         };
)
AADD(sistema[003,O_CAMPO],{;            // OBXEC
     /* mascara       */    "",;
     /* titulo        */    "Por",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "V",;
     /* help do campo */    "";
                         };
)
AADD(sistema[003,O_CAMPO],{;            // OBXEC
     /* mascara       */    "999999",;
     /* titulo        */    "N§ O.P.",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "V",;
     /* help do campo */    "";
                         };
)
AADD(sistema[003,O_CAMPO],{;            // OBXEC
     /* mascara       */    "!9",;
     /* titulo        */    "Grupo",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[003,O_CAMPO],{;            // OBXEC
     /* mascara       */    "@!",;
     /* titulo        */    "Filial",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[003,O_CAMPO],{;            // OBXEC
     /* mascara       */    "99999999",;
     /* titulo        */    "Num.Lan‡amento",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[003,O_FORMULA],{;          // OBXEC - Nome
     /* form mostrar  */    "LEFT(TRAN(GRUPOS->nome,[]),35)",;
     /* lin da formula*/    4,;
     /* col da formula*/    2;
                         };
)
AADD(sistema[003,O_FORMULA],{;          // OBXEC - Circ 1 - 4
     /* form mostrar  */    "LEFT(TRAN(OBX_01F9(),[]),48)",;
     /* lin da formula*/    11,;
     /* col da formula*/    2;
                         };
)
AADD(sistema[003,O_FORMULA],{;          // OBXEC - Ult.Circular
     /* form mostrar  */    "LEFT(TRAN(GRUPOS->ultcirc,[999]),03)",;
     /* lin da formula*/    6,;
     /* col da formula*/    47;
                         };
)
AADD(sistema[003,O_FORMULA],{;          // OBXEC - Situa‡„o
     /* form mostrar  */    "LEFT(TRAN(IIF(GRUPOS->situacao='2',[CANCELADO],[         ])+[ - Grupo ]+GRUPOS->grupo,[]),22)",;
     /* lin da formula*/    2,;
     /* col da formula*/    23;
                         };
)
AADD(sistema[003,O_FORMULA],{;          // OBXEC - Admiss„o
     /* form mostrar  */    "LEFT(TRAN(GRUPOS->admissao,[@D]),10)",;
     /* lin da formula*/    8,;
     /* col da formula*/    12;
                         };
)
AADD(sistema[003,O_FORMULA],{;          // OBXEC - Saitxa
     /* form mostrar  */    "LEFT(TRAN(GRUPOS->saitxa,[@R 99/99]),05)",;
     /* lin da formula*/    8,;
     /* col da formula*/    33;
                         };
)
AADD(sistema[003,O_FORMULA],{;          // OBXEC - Cobrador
     /* form mostrar  */    "LEFT(TRAN(GRUPOS->cobrador,[!!]),02)",;
     /* lin da formula*/    9,;
     /* col da formula*/    33;
                         };
)
AADD(sistema[003,O_FORMULA],{;          // OBXEC - Funerais
     /* form mostrar  */    "LEFT(TRAN(GRUPOS->funerais,[99]),02)",;
     /* lin da formula*/    9,;
     /* col da formula*/    12;
                         };
)
AADD(sistema[003,O_FORMULA],{;          // OBXEC - Circ.Inicial
     /* form mostrar  */    "LEFT(TRAN(GRUPOS->circinic,[999]),03)",;
     /* lin da formula*/    5,;
     /* col da formula*/    46;
                         };
)
AADD(sistema[003,O_FORMULA],{;          // OBXEC - Endere‡o
     /* form mostrar  */    "LEFT(TRAN(xDECRIPT(GRUPOS->endereco),[]),35)",;
     /* lin da formula*/    5,;
     /* col da formula*/    2;
                         };
)
AADD(sistema[003,O_FORMULA],{;          // OBXEC - Bairro
     /* form mostrar  */    "LEFT(TRAN(xDECRIPT(GRUPOS->bairro),[]),25)",;
     /* lin da formula*/    6,;
     /* col da formula*/    2;
                         };
)
AADD(sistema[003,O_FORMULA],{;          // OBXEC - Cidade
     /* form mostrar  */    "LEFT(TRAN(xDECRIPT(GRUPOS->cidade),[]),25)",;
     /* lin da formula*/    7,;
     /* col da formula*/    2;
                         };
)
AADD(sistema[003,O_FORMULA],{;          // OBXEC - CEP
     /* form mostrar  */    "LEFT(TRAN(xDECRIPT(GRUPOS->cep),[@R 99999-999]),09)",;
     /* lin da formula*/    7,;
     /* col da formula*/    29;
                         };
)
AADD(sistema[003,O_FORMULA],{;          // OBXEC - Regi„o
     /* form mostrar  */    "LEFT(TRAN(GRUPOS->regiao,[999]),03)",;
     /* lin da formula*/    6,;
     /* col da formula*/    35;
                         };
)
AADD(sistema[003,O_FORMULA],{;          // OBXEC - troco
     /* form mostrar  */    "LEFT(TRAN(valoraux-valorpg,[@E 999,999.99]),11)",;
     /* lin da formula*/    17,;
     /* col da formula*/    33;
                         };
)
AADD(sistema[003,O_FORMULA],{;          // OBXEC - Filial
     /* form mostrar  */    "LEFT(TRAN(filial,[@!]),02)",;
     /* lin da formula*/    1,;
     /* col da formula*/    23;
                         };
)


sistema[004]={;
            "Consulta Contratos",;                          // opcao do menu
            "Consulta contratos",;                          // titulo do sistema
            {"codigo","nome"},;                             // chaves do arquivo
            {"Contrato","p/Nome"},;                         // titulo dos indices para consulta
            {"01","04"},;                                   // ordem campos chaves
            {"GRUPOS",drvdbf,drvntx},;                      // nome do DBF
            {"GRUPOS1","GRUPOS2"},;                         // nomes dos NTX
            {"TAXAS","ECOB","INSCRITS"},;                   // nome dos dbf's relacionados
            {},;                                            // campos de relacionamento
            {1,1,1,3,22,77},;                               // num telas/tela atual/coordenadas
            {1,.t.,.f.},;                                   // nivel acesso/tp chave/pede dir
            {},;                                            // campos do arquivo
            {},;                                            // formula mostradas
            {"1=3","Mantido pelo sistema de Plano"},;       // condicao de exclusao de registros
            {"1=3","Mantido pelo sistema de Plano"},;       // condicao de alteracao de registros
            {"1=3","Mantido pelo sistema de Plano"};        // condicao de recupercao de registros
           }

AADD(sistema[004,O_CAMPO],{;            // GRUPOS
     /* mascara       */    "@!",;
     /* titulo        */    "Codigo",;
     /* cmd especial  */    "GRU_02F9()",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "PTAB('',[ARQGRUP],1).AND.GRU_01F9()~CODIGO n„o aceit vel|N„o cadastrado na tabela de grupos",;
     /* help do campo */    "Entre com o n£mero do contrato";
                         };
)
AADD(sistema[004,O_CAMPO],{;            // GRUPOS
     /* mascara       */    "!!",;
     /* titulo        */    "Grupo",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[004,O_CAMPO],{;            // GRUPOS
     /* mascara       */    "9",;
     /* titulo        */    "Situa‡„o",;
     /* cmd especial  */    "MTAB([1=Ativo|2=Cancelado],[SITUA€ŽO])",;
     /* default       */    "[1]",;
     /* pre-validacao */    "",;
     /* validacao     */    "situacao $ [12]~SITUA€ŽO n„o aceit vel",;
     /* help do campo */    "Digite 1 para ativo ou 2 para cancelado";
                         };
)
AADD(sistema[004,O_CAMPO],{;            // GRUPOS
     /* mascara       */    "@!",;
     /* titulo        */    "Nome",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(nome)~Necess rio informar NOME",;
     /* help do campo */    "";
                         };
)
AADD(sistema[004,O_CAMPO],{;            // GRUPOS
     /* mascara       */    "@D",;
     /* titulo        */    "Nascto",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    "Informe a data de nascimento do titular";
                         };
)
AADD(sistema[004,O_CAMPO],{;            // GRUPOS
     /* mascara       */    "!!",;
     /* titulo        */    "Est Civil",;
     /* cmd especial  */    "MTAB(tbestciv,[EST CIVIL])",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "(estcivil$tbestciv)~Informe Estado Civil|ou|Tecle F8 para consulta em tabela",;
     /* help do campo */    "Digite o Estado Civil do Titular|ou|Tecle F8 para consulta em tabela";
                         };
)
AADD(sistema[004,O_CAMPO],{;            // GRUPOS
     /* mascara       */    "@R 999.999.999-99",;
     /* titulo        */    "CPF",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "VDV2(cpf).OR.EMPT(cpf)~CPF nÆo aceit vel",;
     /* help do campo */    "Informe o CIC (CPF) do titular";
                         };
)
AADD(sistema[004,O_CAMPO],{;            // GRUPOS
     /* mascara       */    "@!",;
     /* titulo        */    "R.G.",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    "Informe o n£mero do documento do titular";
                         };
)
AADD(sistema[004,O_CAMPO],{;            // GRUPOS
     /* mascara       */    "@!",;
     /* titulo        */    "Endere‡o",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(endereco)~Este endere‡o ser  utilizado na emissÆo das Taxas|para cobran‡a e em todas as telas de consulta.",;
     /* help do campo */    "Informe o Endere‡o para correspondˆncias.|Rua,n£mero,apto, blocl, etc...";
                         };
)
AADD(sistema[004,O_CAMPO],{;            // GRUPOS
     /* mascara       */    "@!",;
     /* titulo        */    "Bairro",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(bairro)~Necess rio informar BAIRRO do Titular",;
     /* help do campo */    "Informe o bairro ou regi„o do titular do contrato";
                         };
)
AADD(sistema[004,O_CAMPO],{;            // GRUPOS
     /* mascara       */    "@!",;
     /* titulo        */    "Cidade",;
     /* cmd especial  */    "",;
     /* default       */    "M->p_cidade",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(cidade)~Necess rio informar MUNICIPIO para cobran‡a do Titular.",;
     /* help do campo */    "Digite a Cidade para correspondˆncia.";
                         };
)
AADD(sistema[004,O_CAMPO],{;            // GRUPOS
     /* mascara       */    "!!",;
     /* titulo        */    "UF",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "VUF(uf).OR.EMPT(UF)~UNIDADE DA FEDERA€ŽO inv lida",;
     /* help do campo */    "Qual ‚ o estado da federa‡„o";
                         };
)
AADD(sistema[004,O_CAMPO],{;            // GRUPOS
     /* mascara       */    "@R 99999-999",;
     /* titulo        */    "CEP",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(cep)~Necess rio informar CEP do Titular |com 08 digitos",;
     /* help do campo */    "Informe o CEP (8 digitos)|para facilitar a correspondˆncia";
                         };
)
AADD(sistema[004,O_CAMPO],{;            // GRUPOS
     /* mascara       */    "@K!",;
     /* titulo        */    "Naturalidade",;
     /* cmd especial  */    "",;
     /* default       */    "M->p_cidade",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    "Informe a naturalidade do titular";
                         };
)
AADD(sistema[004,O_CAMPO],{;            // GRUPOS
     /* mascara       */    "@!",;
     /* titulo        */    "Relig",;
     /* cmd especial  */    "__KEYBOARD([CATOLICO])",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    "Informe a religi„o do titular";
                         };
)
AADD(sistema[004,O_CAMPO],{;            // GRUPOS
     /* mascara       */    "@!",;
     /* titulo        */    "Contato",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    "Digite o nome da pessoa para contato|";
                         };
)
AADD(sistema[004,O_CAMPO],{;            // GRUPOS
     /* mascara       */    "@!",;
     /* titulo        */    "Telefone",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    "Informe o n£mero de telefone para|Contato com o contratante";
                         };
)
AADD(sistema[004,O_CAMPO],{;            // GRUPOS
     /* mascara       */    "99",;
     /* titulo        */    "TipCont",;
     /* cmd especial  */    "VDBF(6,20,20,77,'CLASSES',{'classcod','descricao','vljoia'},1,'classcod',[])",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "PTAB(tipcont,'CLASSES',1)~Informe a Classe deste contrato",;
     /* help do campo */    "Qual a categoria do Contrato?|Tecle F8 para consulta em tabela";
                         };
)
AADD(sistema[004,O_CAMPO],{;            // GRUPOS
     /* mascara       */    "",;
     /* titulo        */    "Vlcarne",;
     /* cmd especial  */    "VDBF(6,52,20,77,'TCARNES',{'tip','pari','vali','parf'},1,'tip',[])",;
     /* default       */    "",;
     /* pre-validacao */    "!(CLASSES->prior=[S])",;
     /* validacao     */    "",;
     /* help do campo */    "Qual o c¢digo de classifica‡Æo do valor do contrato?|Tecle F8 para consultar tabela|Obs.|Ser  preenchido quando for lan‡ada a|venda do contrato.";
                         };
)
AADD(sistema[004,O_CAMPO],{;            // GRUPOS
     /* mascara       */    "99",;
     /* titulo        */    "FormaPgto",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "CLASSES->prior=[S]",;
     /* validacao     */    "",;
     /* help do campo */    "Informe a forma de pagamento desejada|A Taxa de manuten‡Æo ser  emitida cada NN meses.";
                         };
)
AADD(sistema[004,O_CAMPO],{;            // GRUPOS
     /* mascara       */    "",;
     /* titulo        */    "Seguro",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[004,O_CAMPO],{;            // GRUPOS
     /* mascara       */    "@D",;
     /* titulo        */    "Admiss„o",;
     /* cmd especial  */    "DATE()",;
     /* default       */    "DATE()",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(admissao)~Necess rio informar DATA DE ADMISSŽO",;
     /* help do campo */    "Informe a data da Admiss„o neste contrato";
                         };
)
AADD(sistema[004,O_CAMPO],{;            // GRUPOS
     /* mascara       */    "@D",;
     /* titulo        */    "T.Carˆncia",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    "Informe a data de t‚rmino da Carˆncia";
                         };
)
AADD(sistema[004,O_CAMPO],{;            // GRUPOS
     /* mascara       */    "@R 99/99",;
     /* titulo        */    "Saitxa",;
     /* cmd especial  */    "",;
     /* default       */    "SUBSTR(DTOC(admissao+(CLASSES->nrparc*30)),4,2)+RIGHT(DTOC(admissao+(CLASSES->nrparc*30)),2)",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(saitxa).AND.MMAA(saitxa) .or.nivelop==3~Necess rio informar SAITXA (MM/AA)",;
     /* help do campo */    "Informe o Mˆs a sair a 1¦ Taxa.";
                         };
)
AADD(sistema[004,O_CAMPO],{;            // GRUPOS
     /* mascara       */    "99",;
     /* titulo        */    "Dia Pgto.",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "diapgto<[31]~DIA PGTO. n„o aceit vel|Digite um dia entre 01 e 30|ou|deixe com 00 para data igual ao grupo",;
     /* help do campo */    "Informe o melhor dia para pagamento";
                         };
)
AADD(sistema[004,O_CAMPO],{;            // GRUPOS
     /* mascara       */    "!!!",;
     /* titulo        */    "Vendedor",;
     /* cmd especial  */    "VDBF(6,7,20,77,'COBRADOR',{'cobrador','funcao','nome','cidade'},1,'cobrador')",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "PTAB(vendedor,'COBRADOR',1).OR.EMPT(vendedor)~VENDEDOR n„o existe na tabela",;
     /* help do campo */    "Informe o c¢digo do Vendedor|ou|Tecle F8 para consulta em arquivo";
                         };
)
AADD(sistema[004,O_CAMPO],{;            // GRUPOS
     /* mascara       */    "999",;
     /* titulo        */    "Regi„o",;
     /* cmd especial  */    "VDBF(6,38,20,77,'REGIAO',{'codigo','regiao'},1,'codigo')",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "PTAB(regiao,'REGIAO',1).OR.EMPT(VAL(regiao))~REGIŽO n„o existe na tabela",;
     /* help do campo */    "Informe a regi„o ou tecle F8 para busca em tabela";
                         };
)
AADD(sistema[004,O_CAMPO],{;            // GRUPOS
     /* mascara       */    "!!!",;
     /* titulo        */    "Cobrador",;
     /* cmd especial  */    "VDBF(6,39,20,77,'REGIAO',{'regiao','cobrador'},2,'cobrador',[!EMPT(cobrador)])",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "PTAB(cobrador,'COBRADOR',1)~COBRADOR n„o existe na tabela",;
     /* help do campo */    "Digite o c¢digo do COBRADOR que|receber  as Taxas deste contrato,|Tecle F8 para consultar os cobradores.";
                         };
)
AADD(sistema[004,O_CAMPO],{;            // GRUPOS
     /* mascara       */    "@S35",;
     /* titulo        */    "Obs",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    "";
                         };
)
AADD(sistema[004,O_CAMPO],{;            // GRUPOS
     /* mascara       */    "@D",;
     /* titulo        */    "Renovar",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    "Data final para renova‡Æo";
                         };
)
AADD(sistema[004,O_CAMPO],{;            // GRUPOS
     /* mascara       */    "99",;
     /* titulo        */    "Funerais",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "!(funerais<0)~FUNERAIS n„o aceit vel",;
     /* help do campo */    "N£mero de Funerais efetuados|para este processo";
                         };
)
AADD(sistema[004,O_CAMPO],{;            // GRUPOS
     /* mascara       */    "999",;
     /* titulo        */    "Circ.Inicial",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    "Informe o n£mero da 1¦ Circular|que saiu para este contrato.";
                         };
)
AADD(sistema[004,O_CAMPO],{;            // GRUPOS
     /* mascara       */    "999",;
     /* titulo        */    "Ult.Circular",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "PTAB(IIF(CLASSES->prior=[S],M->mgrupvip,grupo)+ultcirc,'CIRCULAR',1).OR.ultcirc=[000].or.nivelop==3~Necess rio informar ULT.CIRCULAR",;
     /* help do campo */    "Entre com o £ltimo n£mero de circular|deste contrato.";
                         };
)
AADD(sistema[004,O_CAMPO],{;            // GRUPOS
     /* mascara       */    "999",;
     /* titulo        */    "Qt.Circulares",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "!(qtcircs<0)~QT.CIRCULARES n„o aceit vel",;
     /* help do campo */    "";
                         };
)
AADD(sistema[004,O_CAMPO],{;            // GRUPOS
     /* mascara       */    "999",;
     /* titulo        */    "Circ.Pagas",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    "Informe a quantidade de Circulares|pagas/retornadas deste contrato";
                         };
)
AADD(sistema[004,O_CAMPO],{;            // GRUPOS
     /* mascara       */    "",;
     /* titulo        */    "Titular",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[004,O_CAMPO],{;            // GRUPOS
     /* mascara       */    "99",;
     /* titulo        */    "Part.Vivos",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[004,O_CAMPO],{;            // GRUPOS
     /* mascara       */    "99",;
     /* titulo        */    "Part.Falecidos",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[004,O_CAMPO],{;            // GRUPOS
     /* mascara       */    "99",;
     /* titulo        */    "N§ Depend.",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[004,O_CAMPO],{;            // GRUPOS
     /* mascara       */    "@D",;
     /* titulo        */    "Ult.Impress.",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[004,O_CAMPO],{;            // GRUPOS
     /* mascara       */    "@D",;
     /* titulo        */    "élt.alter.endere‡o",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[004,O_CAMPO],{;            // GRUPOS
     /* mascara       */    "",;
     /* titulo        */    "UltEnd",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[004,O_CAMPO],{;            // GRUPOS
     /* mascara       */    "@D",;
     /* titulo        */    "Em",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[004,O_CAMPO],{;            // GRUPOS
     /* mascara       */    "",;
     /* titulo        */    "Por",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[004,O_CAMPO],{;            // GRUPOS
     /* mascara       */    "@!",;
     /* titulo        */    "Atendimento:",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    "Informe a quem pertence o atendimento";
                         };
)
AADD(sistema[004,O_CAMPO],{;            // GRUPOS
     /* mascara       */    "@!",;
     /* titulo        */    "Atendimento:",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    "Segunda opcao";
                         };
)
AADD(sistema[04,O_CAMPO],{;            // GRUPOS
     /* mascara       */    "",;
     /* titulo        */    "Ult.Emitida",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[04,O_CAMPO],{;            // GRUPOS
     /* mascara       */    "@D",;
     /* titulo        */    "Ult.Data",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[04,O_CAMPO],{;            // GRUPOS
     /* mascara       */    "@R 999,999.99",;
     /* titulo        */    "Ult.Valor",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[04,O_CAMPO],{;            // GRUPOS
     /* mascara       */    "",;
     /* titulo        */    "eMail",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    "Entre com o endereco de email.";
                         };
)
AADD(sistema[04,O_CAMPO],{;            // GRUPOS
     /* mascara       */    "",;
     /* titulo        */    "SeguroData",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    "Entre com a data da admissao do seguro.";
                         };
)
AADD(sistema[04,O_CAMPO],{;            // GRUPOS
     /* mascara       */    "",;
     /* titulo        */    "SeguroCod",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    "Entre com o Cod.Seguro.";
                         };
)
AADD(sistema[04,O_CAMPO],{;            // GRUPOS
     /* mascara       */    "",;
     /* titulo        */    "SeguroServ",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    "Entre com o Serv.Seguro.";
                         };
)
AADD(sistema[004,O_FORMULA],{;          // GRUPOS - Situacao
     /* form mostrar  */    "LEFT(TRAN(IIF(situacao=[2],[CANCELADO],[         ]),[]),09)",;
     /* lin da formula*/    1,;
     /* col da formula*/    62;
                         };
)
AADD(sistema[004,O_FORMULA],{;          // GRUPOS - Part.Vivos
     /* form mostrar  */    "LEFT(TRAN(particv,[99]),02)",;
     /* lin da formula*/    16,;
     /* col da formula*/    24;
                         };
)
AADD(sistema[004,O_FORMULA],{;          // GRUPOS - Part.Falecidos
     /* form mostrar  */    "LEFT(TRAN(particf,[99]),02)",;
     /* lin da formula*/    16,;
     /* col da formula*/    38;
                         };
)
AADD(sistema[004,O_FORMULA],{;          // GRUPOS - Nome do Cobrado
     /* form mostrar  */    "LEFT(TRAN(IIF(PTAB(cobrador,'COBRADOR',1),COBRADOR->nome,[ ]),[]),30)",;
     /* lin da formula*/    13,;
     /* col da formula*/    16;
                         };
)
AADD(sistema[004,O_FORMULA],{;          // GRUPOS - Nome do Vendedr
     /* form mostrar  */    "LEFT(TRAN(IIF(PTAB(vendedor,'COBRADOR',1),COBRADOR->nome,[ ]),[]),30)",;
     /* lin da formula*/    11,;
     /* col da formula*/    16;
                         };
)
AADD(sistema[004,O_FORMULA],{;          // GRUPOS - grupo
     /* form mostrar  */    "LEFT(TRAN(IIF(!EMPT(grupo),grupo,[  ]),[]),02)",;
     /* lin da formula*/    1,;
     /* col da formula*/    22;
                         };
)
AADD(sistema[004,O_FORMULA],{;          // GRUPOS - Descri‡„o Reg
     /* form mostrar  */    "LEFT(TRAN(REGIAO->regiao,[]),30)",;
     /* lin da formula*/    12,;
     /* col da formula*/    16;
                         };
)
AADD(sistema[004,O_FORMULA],{;          // GRUPOS - Est.Civil
     /* form mostrar  */    "LEFT(TRAN(IIF(!EMPT(estcivil),SUBS(tbestciv,AT(estcivil,tbestciv),11),[]),[]),11)",;
     /* lin da formula*/    4,;
     /* col da formula*/    13;
                         };
)
AADD(sistema[004,O_FORMULA],{;          // GRUPOS - N§ Depend.
     /* form mostrar  */    "LEFT(TRAN(nrdepend,[99]),02)",;
     /* lin da formula*/    16,;
     /* col da formula*/    54;
                         };
)
AADD(sistema[004,O_FORMULA],{;          // GRUPOS - Ult.Impress.
     /* form mostrar  */    "LEFT(TRAN(ultimp_,[@D]),10)",;
     /* lin da formula*/    16,;
     /* col da formula*/    54;
                         };
)
AADD(sistema[004,O_FORMULA],{;          // GRUPOS - élt.alter.ender
     /* form mostrar  */    "LEFT(TRAN(ender_,[@D]),10)",;
     /* lin da formula*/    18,;
     /* col da formula*/    17;
                         };
)
AADD(sistema[004,O_FORMULA],{;          // GRUPOS - UltEnd
     /* form mostrar  */    "LEFT(TRAN(ultend,[]),10)",;
     /* lin da formula*/    18,;
     /* col da formula*/    28;
                         };
)
AADD(sistema[004,O_FORMULA],{;          // GRUPOS - Seguro
     /* form mostrar  */    "LEFT(TRAN(IIF(seguro>0,'SEGURO ('+str(seguro,2)+')',[   ]),[]),12)",;
     /* lin da formula*/    1,;
     /* col da formula*/    28;
                         };
)
AADD(sistema[004,O_FORMULA],{;          // GRUPOS - Qt.Circulares
     /* form mostrar  */    "LEFT(TRAN(qtcircs,[999]),03)",;
     /* lin da formula*/    0,;
     /* col da formula*/    0;
                         };
)
AADD(sistema[004,O_FORMULA],{;          // GRUPOS - periodicidade
     /* form mostrar  */    "LEFT(TRAN(IIF(PTAB(tipcont,'CLASSES',1),ALLTRIM(CLASSES->descricao),[])+[ ]+IIF(formapgto$'01020304',SUBSTR(tbfpgto,(VAL(formapgto)-1)*13+1,13),[]),[]),35)",;
     /* lin da formula*/    9,;
     /* col da formula*/    39;
                         };
)
AADD(sistema[004,O_FORMULA],{;          // GRUPOS - Idade
     /* form mostrar  */    "LEFT(TRAN(IIF(!EMPT(nascto_),LEFT(DLAPSO(DATE(),nascto_),10),[          ]),[]),10)",;
     /* lin da formula*/    3,;
     /* col da formula*/    64;
                         };
)


sistema[005]={;
            "Taxas",;                                       // opcao do menu
            "Cadastro de Taxas",;                           // titulo do sistema
	    {"codigo","codlan"},;       // chaves do arquivo
	    {"Contrato","Cod.Lanc"},;            // titulo dos indices para consulta
	    {"01","16"},;                            // ordem campos chaves
	    {"TAXAS",drvdbf,drvntx},;                       // nome do DBF
	    {"TAXAS1","TAXAS3"},;                  // nomes dos NTX
            {},;                                            // nome dos dbf's relacionados
            {"GRUPOS->codigo"},;                            // campos de relacionamento
            {1,1,13,0,23,79,3,7},;                          // num telas/tela atual/coordenadas/inicio scroll/qtde scroll
            {1,.t.,.f.},;                                   // nivel acesso/tp chave/pede dir
            {},;                                            // campos do arquivo
            {},;                                            // formula mostradas
            {"",""},;                                       // condicao de exclusao de registros
            {"",""},;                                       // condicao de alteracao de registros
            {"",""};                                        // condicao de recupercao de registros
           }

AADD(sistema[005,O_CAMPO],{;            // TAXAS
     /* mascara       */    "@!",;
     /* titulo        */    "Codigo",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
			 };
)
AADD(sistema[005,O_CAMPO],{;            // TAXAS
     /* mascara       */    "@!",;
     /* titulo        */    "Cobranca",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    "";
                         };
)
AADD(sistema[005,O_CAMPO],{;            // TAXAS
     /* mascara       */    "!",;
     /* titulo        */    "Tipo",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
			 };
)
AADD(sistema[005,O_CAMPO],{;            // TAXAS
     /* mascara       */    "999",;
     /* titulo        */    "Circular",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[005,O_CAMPO],{;            // TAXAS
     /* mascara       */    "@D",;
     /* titulo        */    "Emissao",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(emissao_)~Necess rio informar EMISSAO v lida",;
     /* help do campo */    "Data da Emiss„o da Circular|Mantido pela emissao do recibo";
			 };
)
AADD(sistema[005,O_CAMPO],{;            // TAXAS
     /* mascara       */    "@E 999,999.99",;
     /* titulo        */    "Valor",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "valor>0~VALOR n„o aceit vel",;
     /* help do campo */    "";
                         };
)
AADD(sistema[005,O_CAMPO],{;            // TAXAS
     /* mascara       */    "@D",;
     /* titulo        */    "Pagamento",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "nivelop=3",;
     /* validacao     */    "",;
     /* help do campo */    "Informe a data de pagamento/Baixa";
			 };
)
AADD(sistema[005,O_CAMPO],{;            // TAXAS
     /* mascara       */    "@E 999,999.99",;
     /* titulo        */    "Valor pago",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "nivelop=3",;
     /* validacao     */    "!(valorpg<0)~VALOR PAGO n„o aceit vel",;
     /* help do campo */    "Informe o valor pago/baixado";
                         };
)
AADD(sistema[005,O_CAMPO],{;            // TAXAS
     /* mascara       */    "!!!",;
     /* titulo        */    "Cobrador",;
     /* cmd especial  */    "VDBF(6,3,20,77,'COBRADOR',{'cobrador','funcao','nome','cidade','telefone'},1,'cobrador',[])",;
     /* default       */    "GRUPOS->cobrador",;
     /* pre-validacao */    "",;
     /* validacao     */    "PTAB(cobrador,'COBRADOR',1).AND.(PTAB(cobrador+M->mmesref,'FCCOB',1).OR.1=1)~Problemas encontrados no arquivo Cobrador ou |Circular do grupo n„o cadastrada para|este cobrador.",;
     /* help do campo */    "Informe o Cobrador que recebeu este.";
			 };
)
AADD(sistema[005,O_CAMPO],{;            // TAXAS
     /* mascara       */    "!",;
     /* titulo        */    "Forma",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "forma$[PR ]~FORMA n„o aceit vel",;
     /* help do campo */    "Esta lan‡amento foi Pago ou Cancelado|Deixe sem preencher se ainda em aberto";
                         };
)
AADD(sistema[005,O_CAMPO],{;            // TAXAS
     /* mascara       */    "@D",;
     /* titulo        */    "Baixa_",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
			 };
)
AADD(sistema[005,O_CAMPO],{;            // TAXAS
     /* mascara       */    "",;
     /* titulo        */    "Por",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[005,O_CAMPO],{;            // TAXAS
     /* mascara       */    "9",;
     /* titulo        */    "Status",;
     /* cmd especial  */    "MTAB([1=Gerada|2=Impressa|6=Pg Recep‡„o|7=Bx.p/FCC|9=Bx.Plano],[STATUS])",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "stat $ [12679]~STATUS n„o aceit vel",;
     /* help do campo */    "Informe a situa‡„o deste recibo|Tecle F8 para busca em tabela";
			 };
)
AADD(sistema[005,O_CAMPO],{;            // TAXAS
     /* mascara       */    "@!",;
     /* titulo        */    "Filial",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[005,O_CAMPO],{;            // TAXAS
     /* mascara       */    "!",;
     /* titulo        */    "Flag",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
			 };
)
AADD(sistema[005,O_CAMPO],{;            // TAXAS
     /* mascara       */    "!!!-99999999-999-999",;
     /* titulo        */    "Cod.Lan‡amento",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[005,O_FORMULA],{;          // TAXAS - Status
     /* form mostrar  */    "LEFT(TRAN(LEFT(TAX_02F9(),3),[]),03)",;
     /* lin da formula*/    {||l_a},;
     /* col da formula*/    75;
                         };
)
AADD(sistema[005,O_FORMULA],{;          // TAXAS - numero
     /* form mostrar  */    "LEFT(TRAN(substr(codigo,11),[]),08)",;
     /* lin da formula*/    {||l_a},;
     /* col da formula*/    1;
                         };
)


sistema[006]={;
            "Outros Endere‡os",;                            // opcao do menu
            "Outros Endere‡os",;                            // titulo do sistema
            {"codigo+tipo"},;                               // chaves do arquivo
            {"Contrato"},;                                  // titulo dos indices para consulta
            {"0102"},;                                      // ordem campos chaves
            {"ECOB",drvdbf,drvntx},;                        // nome do DBF
            {"ECOB1"},;                                     // nomes dos NTX
            {},;                                            // nome dos dbf's relacionados
            {"GRUPOS->codigo"},;                            // campos de relacionamento
            {1,1,8,17,16,65},;                              // num telas/tela atual/coordenadas
            {1,.t.,.f.},;                                   // nivel acesso/tp chave/pede dir
            {},;                                            // campos do arquivo
            {},;                                            // formula mostradas
	    {"",""},;                                       // condicao de exclusao de registros
            {"",""},;                                       // condicao de alteracao de registros
            {"",""};                                        // condicao de recupercao de registros
           }

AADD(sistema[006,O_CAMPO],{;            // ECOB
     /* mascara       */    "@!",;
     /* titulo        */    "Codigo",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[006,O_CAMPO],{;            // ECOB
     /* mascara       */    "!",;
     /* titulo        */    "Tipo",;
     /* cmd especial  */    "MTAB([Residˆncia|Trabalho|Outro],[TIPO])",;
     /* default       */    "[R]",;
     /* pre-validacao */    "MTAB([Residˆncia|Trabalho|Outro],[TIPO])",;
     /* validacao     */    "tipo $ [RTO]~TIPO n„o aceit vel|Apenas endere‡os de Residˆncia e Trabalho.",;
     /* help do campo */    "Informe que tipo de Endere‡o ‚ este.|R=Residˆncia, T=Trabalho";
                         };
)
AADD(sistema[006,O_CAMPO],{;            // ECOB
     /* mascara       */    "@!",;
     /* titulo        */    "Endere‡o",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(endereco)~Informe a localiza‡„o ou tecle ESC para cancelar",;
     /* help do campo */    "Informe o Endere‡o|Rua,n£mero,apto, blocl, etc...";
                         };
)
AADD(sistema[006,O_CAMPO],{;            // ECOB
     /* mascara       */    "@!",;
     /* titulo        */    "Bairro",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    "Digite o Bairro|ou complemento| do endere‡o";
                         };
)
AADD(sistema[006,O_CAMPO],{;            // ECOB
     /* mascara       */    "@R 99999-999",;
     /* titulo        */    "CEP",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    "Informe o CEP para facilitar a localiza‡„o";
                         };
)
AADD(sistema[006,O_CAMPO],{;            // ECOB
     /* mascara       */    "@!",;
     /* titulo        */    "Cidade",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    "Informe a Cidade/Municipio";
                         };
)
AADD(sistema[006,O_CAMPO],{;            // ECOB
     /* mascara       */    "!!",;
     /* titulo        */    "UF",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "VUF(uf).OR. EMPT(uf)~UNIDADE DA FEDERA€ŽO inv lida",;
     /* help do campo */    "Informe o Estado.|Ex.: SP,RJ,GO,AM,...";
                         };
)
AADD(sistema[006,O_CAMPO],{;            // ECOB
     /* mascara       */    "@!",;
     /* titulo        */    "Telefone",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    "Informe o n£mero do telefone para contato";
                         };
)
AADD(sistema[006,O_CAMPO],{;            // ECOB
     /* mascara       */    "",;
     /* titulo        */    "Obs",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    "";
                         };
)
AADD(sistema[006,O_CAMPO],{;            // ECOB
     /* mascara       */    "@D",;
     /* titulo        */    "Data",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[006,O_CAMPO],{;            // ECOB
     /* mascara       */    "!",;
     /* titulo        */    "Flag",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[006,O_FORMULA],{;          // ECOB - Tipo
     /* form mostrar  */    "LEFT(TRAN(IIF(tipo=[R],[Residˆncia],IIF(tipo=[T],[Trabalho],[Outro])),[]),12)",;
     /* lin da formula*/    1,;
     /* col da formula*/    15;
                         };
)
AADD(sistema[006,O_FORMULA],{;          // ECOB - Data
     /* form mostrar  */    "LEFT(TRAN(data_,[@D]),08)",;
     /* lin da formula*/    7,;
     /* col da formula*/    39;
                         };
)


sistema[007]={;
	    "Inscritos",;                                   // opcao do menu
	    "Inscritos",;                                   // titulo do sistema
	    {"codigo","nome"},;                        // chaves do arquivo
	    {"Codigo","Nome"},;                             // titulo dos indices para consulta
	    {"01","05"},;                                 // ordem campos chaves
	    {"INSCRITS",drvdbf,drvntx},;                    // nome do DBF
	    {"INSCRIT1","INSCRIT2"},;                       // nomes dos NTX
	    {},;                                            // nome dos dbf's relacionados
	    {"GRUPOS->codigo"},;                            // campos de relacionamento
	    {1,1,17,3,23,77},;                              // num telas/tela atual/coordenadas
	    {1,.t.,.f.},;                                   // nivel acesso/tp chave/pede dir
            {},;                                            // campos do arquivo
            {},;                                            // formula mostradas
            {"",""},;                                       // condicao de exclusao de registros
            {"",""},;                                       // condicao de alteracao de registros
            {"",""};                                        // condicao de recupercao de registros
           }

AADD(sistema[007,O_CAMPO],{;            // INSCRITS
     /* mascara       */    "@!",;
     /* titulo        */    "Codigo",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[007,O_CAMPO],{;            // INSCRITS
     /* mascara       */    "9",;
     /* titulo        */    "Inscr.",;
     /* cmd especial  */    "MTAB(M->TBTIPGRAU,[INSCR.])",;
     /* default       */    "IIF(M->pgrau<[7],SUBSTR([234567],VAL(M->pgrau),1),M->pgrau)",;
     /* pre-validacao */    "MTAB(M->TBTIPGRAU,[INSCR.])",;
     /* validacao     */    "grau $ [12345678]~INSCR. n„o aceit vel",;
     /* help do campo */    "Informe o grau de liga‡„o deste com o|titular do contrato|ou|tecle F8 para consulta em tabela";
                         };
)
AADD(sistema[007,O_CAMPO],{;            // INSCRITS
     /* mascara       */    "99",;
     /* titulo        */    "Seq",;
     /* cmd especial  */    "",;
     /* default       */    "INS_01F9()",;
     /* pre-validacao */    "grau>[6]",;
     /* validacao     */    "seq>0~SEQ n„o aceit vel",;
     /* help do campo */    "";
                         };
)
AADD(sistema[007,O_CAMPO],{;            // INSCRITS
     /* mascara       */    "!",;
     /* titulo        */    "Titular?",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[007,O_CAMPO],{;            // INSCRITS
     /* mascara       */    "@!",;
     /* titulo        */    "Nome",;
     /* cmd especial  */    "",;
     /* default       */    "IIF(ehtitular=[S],GRUPOS->nome,[ ])",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(nome)~Necess rio informar NOME",;
     /* help do campo */    "";
                         };
)
AADD(sistema[007,O_CAMPO],{;            // INSCRITS
     /* mascara       */    "@D",;
     /* titulo        */    "Nascto",;
     /* cmd especial  */    "",;
     /* default       */    "IIF(ehtitular=[S],GRUPOS->nascto_,ctod('  /  /  '))",;
     /* pre-validacao */    "",;
     /* validacao     */    "INS_02F9()~NASCTO n„o aceit vel",;
     /* help do campo */    "Informe a Data de Nascimento deste Inscrito";
                         };
)
AADD(sistema[007,O_CAMPO],{;            // INSCRITS
     /* mascara       */    "",;
     /* titulo        */    "Est Civil",;
     /* cmd especial  */    "MTAB(tbestciv,[EST CIVIL])",;
     /* default       */    "IIF(grau<[7],[CA],[SO])",;
     /* pre-validacao */    "MTAB(tbestciv,[EST CIVIL])",;
     /* validacao     */    "(ESTCIVIL$tbestciv)~Necess rio informar ESTADO CIVIL|ou tecle F8",;
     /* help do campo */    "Digite o Estado Civil do Falecido";
                         };
)
AADD(sistema[007,O_CAMPO],{;            // INSCRITS
     /* mascara       */    "!",;
     /* titulo        */    "Interdito",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[007,O_CAMPO],{;            // INSCRITS
     /* mascara       */    "!",;
     /* titulo        */    "Sexo",;
     /* cmd especial  */    "",;
     /* default       */    "IIF(grau$[124],[M],IIF(grau$[356],[F],[ ]))",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    "Digite M ou F |(Masculino ou Feminino)";
                         };
)
AADD(sistema[007,O_CAMPO],{;            // INSCRITS
     /* mascara       */    "@D",;
     /* titulo        */    "T.Carˆncia",;
     /* cmd especial  */    "",;
     /* default       */    "IIF(GRUPOS->tcarencia>DATE(),GRUPOS->tcarencia,CTOD('  /  /  '))",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    "";
                         };
)
AADD(sistema[007,O_CAMPO],{;            // INSCRITS
     /* mascara       */    "@D",;
     /* titulo        */    "Lan‡to.",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[007,O_CAMPO],{;            // INSCRITS
     /* mascara       */    "!",;
     /* titulo        */    "V/F",;
     /* cmd especial  */    "MTAB([Vivo|Falecido],[V/F])",;
     /* default       */    "[V]",;
     /* pre-validacao */    "",;
     /* validacao     */    "vivofalec$[VF]~Necess rio informar VIVOFALEC",;
     /* help do campo */    "Vivo ou Falecido";
                         };
)
AADD(sistema[007,O_CAMPO],{;            // INSCRITS
     /* mascara       */    "@D",;
     /* titulo        */    "Falecto.",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "vivofalec==[F]",;
     /* validacao     */    "",;
     /* help do campo */    "Entre com a data de falecimento";
                         };
)
AADD(sistema[007,O_CAMPO],{;            // INSCRITS
     /* mascara       */    "!!!",;
     /* titulo        */    "Tipo",;
     /* cmd especial  */    "MTAB([Funeral|Auxilio],[TIPO])",;
     /* default       */    "",;
     /* pre-validacao */    "vivofalec==[F]",;
     /* validacao     */    "EMPTY(tipo).OR.UPPER(tipo) $ [FUN|AUX]~Necess rio informar TIPO",;
     /* help do campo */    "Com Direitos (Funeral) ou com Auxilio.";
                         };
)
AADD(sistema[007,O_CAMPO],{;            // INSCRITS
     /* mascara       */    "@R 99999/99",;
     /* titulo        */    "N§Processo",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "vivofalec==[F]",;
     /* validacao     */    "",;
     /* help do campo */    "Informe o n£mero do processo";
                         };
)
AADD(sistema[007,O_CAMPO],{;            // INSCRITS
     /* mascara       */    "",;
     /* titulo        */    "Por",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[007,O_CAMPO],{;            // INSCRITS
     /* mascara       */    "!",;
     /* titulo        */    "Flag",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[07,O_CAMPO],{;            // INSCRITS
     /* mascara       */    "@R 999.999.999-99",;
     /* titulo        */    "CPF",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "VDV2(cpf).OR.EMPT(cpf)~CPF nÆo aceit vel",;
     /* help do campo */    "Informe o CIC (CPF) do titular";
                         };
)
AADD(sistema[07,O_CAMPO],{;            // INSCRITS
     /* mascara       */    "",;
     /* titulo        */    "SeguroData",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    "Entre com a data da admissao do seguro.";
                         };
)
AADD(sistema[07,O_CAMPO],{;            // INSCRITS
     /* mascara       */    "",;
     /* titulo        */    "Seg.Porcentagem",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    "Entre com o Cod.Seguro.";
                         };
)
AADD(sistema[07,O_CAMPO],{;            // INSCRITS
     /* mascara       */    "",;
     /* titulo        */    "SeguroCod",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    "Entre com o Cod.Seguro.";
                         };
)
AADD(sistema[07,O_CAMPO],{;            // INSCRITS
     /* mascara       */    "",;
     /* titulo        */    "SeguroServ",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    "Entre com o Serv.Seguro.";
                         };
)
AADD(sistema[007,O_FORMULA],{;          // INSCRITS - graupart
     /* form mostrar  */    "LEFT(TRAN(SUBSTR([TitPaiMaeSgoSgaEspFilDep],(VAL(grau)-1)*3+1,3),[]),03)",;
     /* lin da formula*/    1,;
     /* col da formula*/    13;
                         };
)
AADD(sistema[007,O_FORMULA],{;          // INSCRITS - Lan‡to.
     /* form mostrar  */    "LEFT(TRAN(lancto_,[@D]),08)",;
     /* lin da formula*/    1,;
     /* col da formula*/    53;
                         };
)
AADD(sistema[007,O_FORMULA],{;          // INSCRITS - Por
     /* form mostrar  */    "LEFT(TRAN(por,[]),10)",;
     /* lin da formula*/    1,;
     /* col da formula*/    62;
                         };
)
AADD(sistema[007,O_FORMULA],{;          // INSCRITS - Idade
     /* form mostrar  */    "LEFT(TRAN(IIF(!EMPT(nascto_),LEFT(DLAPSO(DATE(),nascto_),12),[            ]),[]),12)",;
     /* lin da formula*/    3,;
     /* col da formula*/    62;
                         };
)


sistema[008]={;
            "Emiss„o de Guias",;                            // opcao do menu
            "Emiss„o de Guias",;                            // titulo do sistema
            {"numero","numero"},;                           // chaves do arquivo
            {"p/N£mero","p/N§Transf."},;                    // titulo dos indices para consulta
            {"01","01"},;                                   // ordem campos chaves
            {"GUIAS",drvdbf,drvntx},;                       // nome do DBF
            {"GUIAS1","GUIAS2"},;                           // nomes dos NTX
            {},;                                            // nome dos dbf's relacionados
            {},;                                            // campos de relacionamento
            {1,1,1,10,23,75},;                              // num telas/tela atual/coordenadas
            {1,.t.,.f.},;                                   // nivel acesso/tp chave/pede dir
            {},;                                            // campos do arquivo
            {},;                                            // formula mostradas
            {"",""},;                                       // condicao de exclusao de registros
            {"",""},;                                       // condicao de alteracao de registros
            {"",""};                                        // condicao de recupercao de registros
           }

AADD(sistema[008,O_CAMPO],{;            // GUIAS
     /* mascara       */    "99999999",;
     /* titulo        */    "N£mero",;
     /* cmd especial  */    "",;
     /* default       */    "RIGHT(DTOC(DATE()),2)+[000001]",;
     /* pre-validacao */    "",;
     /* validacao     */    "V",;
     /* help do campo */    "";
                         };
)
AADD(sistema[008,O_CAMPO],{;            // GUIAS
     /* mascara       */    "@D",;
     /* titulo        */    "Emiss„o",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[008,O_CAMPO],{;            // GUIAS
     /* mascara       */    "99:99",;
     /* titulo        */    "Hora",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[008,O_CAMPO],{;            // GUIAS
     /* mascara       */    "",;
     /* titulo        */    "Filial",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[008,O_CAMPO],{;            // GUIAS
     /* mascara       */    "",;
     /* titulo        */    "Login",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[008,O_CAMPO],{;            // GUIAS
     /* mascara       */    "@!",;
     /* titulo        */    "N§ Contrato",;
     /* cmd especial  */    "VDBF(6,3,20,77,'GRUPOS',{'grupo','codigo','nome','endereco'},1,'codigo')",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "GUI_07F9(contrato).AND.CAD_04F9(op_menu).AND.((PTAB(contrato,'INSCRITS',1).and.PTAB(contrato,'TAXAS',1)).OR.1=1)~N£mero do contrato inv lido,|ou |Titular n„o cadastrado|Tecle F8 para consulta.",;
     /* help do campo */    "Entre com o c¢digo do contrato";
                         };
)
AADD(sistema[008,O_CAMPO],{;            // GUIAS
     /* mascara       */    "@!",;
     /* titulo        */    "Nome",;
     /* cmd especial  */    "GUI_06F9()",;
     /* default       */    "GRUPOS->nome",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(nome).AND.(PTAB([],'MEDICOS',1).OR.1=1)~Informar NOME",;
     /* help do campo */    "Informe o nome do benefici rio.";
                         };
)
AADD(sistema[008,O_CAMPO],{;            // GUIAS
     /* mascara       */    "@!",;
     /* titulo        */    "Inscrito",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[008,O_CAMPO],{;            // GUIAS
     /* mascara       */    "@!",;
     /* titulo        */    "M‚dico",;
     /* cmd especial  */    "VDBF(6,3,20,77,'MEDICOS',{'LEFT(oldespec,20)','nome','endereco','cidade','codbenefic','fonesdiv','fonecom1'},3,'codbenefic',[])",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "PTAB(medico,'MEDICOS',1).OR.GUI_08F9()~MDICO n„o existe na tabela",;
     /* help do campo */    "Informe o m‚dico";
                         };
)
AADD(sistema[008,O_CAMPO],{;            // GUIAS
     /* mascara       */    "",;
     /* titulo        */    "Por",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[008,O_CAMPO],{;            // GUIAS
     /* mascara       */    "99999999",;
     /* titulo        */    "Num.Lan‡amento",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[008,O_FORMULA],{;          // GUIAS - circ 1-4
     /* form mostrar  */    "LEFT(TRAN(GUI_02F9(),[]),45)",;
     /* lin da formula*/    6,;
     /* col da formula*/    15;
                         };
)
AADD(sistema[008,O_FORMULA],{;          // GUIAS - Nome do titular
     /* form mostrar  */    "LEFT(TRAN(GRUPOS->nome,[]),35)",;
     /* lin da formula*/    3,;
     /* col da formula*/    26;
                         };
)
AADD(sistema[008,O_FORMULA],{;          // GUIAS - Admiss„o
     /* form mostrar  */    "LEFT(TRAN(GRUPOS->admissao,[@D]),10)",;
     /* lin da formula*/    4,;
     /* col da formula*/    15;
                         };
)
AADD(sistema[008,O_FORMULA],{;          // GUIAS - Saitxa
     /* form mostrar  */    "LEFT(TRAN(GRUPOS->saitxa,[@R 99/99]),05)",;
     /* lin da formula*/    5,;
     /* col da formula*/    15;
                         };
)
AADD(sistema[008,O_FORMULA],{;          // GUIAS - Cobrador
     /* form mostrar  */    "LEFT(TRAN(GRUPOS->cobrador,[!!]),02)",;
     /* lin da formula*/    5,;
     /* col da formula*/    59;
                         };
)
AADD(sistema[008,O_FORMULA],{;          // GUIAS - Endere‡o contr
     /* form mostrar  */    "LEFT(TRAN(xDECRIPT(GRUPOS->endereco),[]),35)",;
     /* lin da formula*/    4,;
     /* col da formula*/    26;
                         };
)
AADD(sistema[008,O_FORMULA],{;          // GUIAS - Bairro contr
     /* form mostrar  */    "LEFT(TRAN(xDECRIPT(GRUPOS->bairro),[]),25)",;
     /* lin da formula*/    5,;
     /* col da formula*/    26;
                         };
)
AADD(sistema[008,O_FORMULA],{;          // GUIAS - Endere‡o
     /* form mostrar  */    "LEFT(TRAN(IIF(!EMPT(medico).AND.PTAB(medico,'MEDICOS',1),MEDICOS->endereco,SPACE(40)),[]),40)",;
     /* lin da formula*/    15,;
     /* col da formula*/    24;
                         };
)
AADD(sistema[008,O_FORMULA],{;          // GUIAS - Munic¡pio
     /* form mostrar  */    "LEFT(TRAN(IIF(PTAB(medico,'MEDICOS',1),MEDICOS->cidade,[]),[]),30)",;
     /* lin da formula*/    16,;
     /* col da formula*/    32;
                         };
)
AADD(sistema[008,O_FORMULA],{;          // GUIAS - Fone
     /* form mostrar  */    "LEFT(TRAN(IIF(!EMPT(medico),MEDICOS->fonecom1,SPACE(14)),[]),14)",;
     /* lin da formula*/    15,;
     /* col da formula*/    9;
                         };
)
AADD(sistema[008,O_FORMULA],{;          // GUIAS - Nome m‚dico
     /* form mostrar  */    "LEFT(TRAN(IIF(!EMPT(medico),MEDICOS->nome,SPACE(40)),[]),40)",;
     /* lin da formula*/    14,;
     /* col da formula*/    24;
                         };
)
AADD(sistema[008,O_FORMULA],{;          // GUIAS - Especialidade
     /* form mostrar  */    "LEFT(TRAN(IIF(!EMPT(medico),MEDICOS->oldespec,SPACE(30)),[]),30)",;
     /* lin da formula*/    16,;
     /* col da formula*/    2;
                         };
)
AADD(sistema[008,O_FORMULA],{;          // GUIAS - Emiss„o
     /* form mostrar  */    "LEFT(TRAN(IIF(EMPT(data),DATE(),data),[@D]),10)",;
     /* lin da formula*/    1,;
     /* col da formula*/    43;
                         };
)
AADD(sistema[008,O_FORMULA],{;          // GUIAS - Por
     /* form mostrar  */    "LEFT(TRAN(IIF(EMPT(por),M->usuario,por),[]),10)",;
     /* lin da formula*/    1,;
     /* col da formula*/    54;
                         };
)

* \\ Final de ADR_ATRI.PRG
/*
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
 \ Empresa.: PresServ Inform tica-Limeira (019)452.6623
 \ Programa: ADM_R020.PRG
 \ Data....: 22-09-97
 \ Sistema.: Administradora - RECEP€„O
 \ Funcao..: Impress„o Aux.Funeral 1
 \ Analista: Ademilson Pedro Bom
 \ Criacao.: GAS-Pro v3.0 
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/

#include "adrbig.ch"    // inicializa constantes manifestas

LOCAL dele_atu, getlist:={}, so_um_reg, sit_dbf:=POINTER_DBF()
PARA  lin_menu, col_menu, imp_reg
PRIV  tem_borda:=.t., op_menu:=VAR_COMPL, l_s:=10, c_s:=20, l_i:=13, c_i:=61, tela_fundo:=SAVESCREEN(0,0,MAXROW(),79)
nucop=1
so_um_reg=(PCOU()>2)
IF !so_um_reg                             // vai receber a variaveis?
 SETCOLOR(drvtittel)
 vr_memo=NOVAPOSI(@l_s,@c_s,@l_i,@c_i)    // pega posicao atual da tela
 CAIXA(mold,l_s,c_s,l_i,c_i)              // monta caixa da tela
 @ l_s,c_s+10 SAY " IMPRESSŽO AUX.FUNERAL "
 SETCOLOR(drvcortel)
 @ l_s+01,c_s+1 SAY " Processo:"
 @ l_s+02,c_s+1 SAY " Confirme:"
ENDI
rproc=SPAC(11)                                     // Processo
confirme=SPAC(1)                                   // Confirme
DO WHILE .t.
 rola_t=.f.
 cod_sos=56
 IF !so_um_reg
  SET KEY K_ALT_F8 TO ROLATELA
  SETCOLOR(drvcortel+","+drvcorget+",,,"+corcampo)
  @ l_s+01 ,c_s+12 GET  rproc;
                   PICT "@R 99999/9999-99";
                   VALI CRIT("!EMPT(RPROC).AND.PTAB(rproc,[AFUNER],1)~Campo utilizado para localiza‡„o dos documentos.|Tecle F8 para busca em tabela")
                   DEFAULT "IIF(PTAB(PADR(SUBSTR(M->ide_maq,2),4)+[AFU],[IMPPAR],1),ALLTRIM(IMPPAR->docto),[])"
                   AJUDA "Digite neste campo o n£mero de|identifica‡„o do processo"
                   CMDF8 "VDBF(6,12,20,77,'AFUNER',{'processo','proc2','categ','contrato','falecido'},1,'V02001F9()',[])"

  @ l_s+02 ,c_s+12 GET  confirme;
                   PICT "!";
                   VALI CRIT("confirme='S'.AND.V02002F9()~CONFIRME n„o aceit vel|Digite S para confirmar|ou|Tecle ESC para cancelar")
                   AJUDA "Digite S para confirmar|ou|tecle ESC para cancelar"

  READ
  SET KEY K_ALT_F8 TO
  IF rola_t
   ROLATELA(.f.)
   LOOP
  ENDI
  IF LASTKEY()=K_ESC                               // se quer cancelar
   RETU                                            // retorna
  ENDI
 ENDI

 #ifdef COM_REDE
  IF !USEARQ("AFUNER",.f.,10,1)                    // se falhou a abertura do arq
   RETU                                            // volta ao menu anterior
  ENDI
 #else
  USEARQ("AFUNER")                                 // abre o dbf e seus indices
 #endi

 PTAB(contrato,"GRUPOS",1,.t.)                     // abre arquivo p/ o relacionamento
 PTAB(contrato,"INSCRITS",1,.t.)
 SET RELA TO contrato INTO GRUPOS,;                // relacionamento dos arquivos
          TO contrato INTO INSCRITS
 titrel:=criterio:=cpord := ""                     // inicializa variaveis
 titrel:=chv_rela:=chv_1:=chv_2 := ""
 tps:=op_x:=ccop := 1
 arq_=drvporta                                     // porta de saida configurada
 IF !so_um_reg
  IF !opcoes_rel(lin_menu,col_menu,1,11)           // nao quis configurar...
   CLOS ALL                                        // fecha arquivos e
   LOOP                                            // volta ao menu
  ENDI

 #ifdef COM_REDE

  ELSE

   tps=lin_menu

 #endi

 ENDI
 IF tps=2                                          // se vai para arquivo/video
  arq_=ARQGER()                                    // entao pega nome do arquivo
  IF EMPTY(arq_)                                   // se cancelou ou nao informou
   LOOP                                            // retorna
  ENDI
 ELSE
  arq_=drvporta                                    // porta de saida configurada
 ENDI
 SET PRINTER TO (arq_)                             // redireciona saida
 EXIT
ENDD
DBOX("[ESC] Interrompe",15,,,NAO_APAGA)
dele_atu:=SET(_SET_DELETED,.t.)                    // os excluidos nao servem...
SET DEVI TO PRIN                                   // inicia a impressao
maxli=62                                           // maximo de linhas no relatorio
BEGIN SEQUENCE
 DO WHIL ccop<=nucop                               // imprime qde copias pedida
  pg_=1; cl=999
  IF so_um_reg
   GO imp_reg
  ELSE
   INI_ARQ()                                       // acha 1o. reg valido do arquivo
  ENDI
  ccop++                                           // incrementa contador de copias
  DO WHIL !EOF().AND.(!so_um_reg.OR.imp_reg=RECN())
   #ifdef COM_TUTOR
    IF IN_KEY()=K_ESC                              // se quer cancelar
   #else
    IF INKEY()=K_ESC                               // se quer cancelar
   #endi
    IF canc()                                      // pede confirmacao
     BREAK                                         // confirmou...
    ENDI
   ENDI
   IF (PTAB(PADR(SUBSTR(M->ide_maq,2),4)+[AFU],[IMPPAR],1).and.processo+proc2+filial+categ=ALLTRIM(IMPPAR->docto)) .OR. so_um_reg// se atender a condicao...
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,054 SAY "Processo"
    IMPCTL(drvpenf)
    @ cl,063 SAY TRAN(processo+proc2,"@R 99999/99")// Nr.Processo
    IMPCTL(drvtenf)
    REL_CAB(2)                                     // soma cl/imprime cabecalho
    @ cl,003 SAY "Nome do Contratante:"
    IMPCTL(drvpenf)
    @ cl,024 SAY TRAN(IIF(PTAB(contrato+GRUPOS->titular,'INSCRITS',1),INSCRITS->nome,GRUPOS->nome),"@!")// Nome do contratante
    IMPCTL(drvtenf)
    REL_CAB(2)                                     // soma cl/imprime cabecalho
    IMPAC("Endere‡o:",cl,003)
    IMPCTL(drvpenf)
    @ cl,013 SAY TRAN(GRUPOS->endereco,"@!")       // Endereco contratante
    IMPCTL(drvtenf)
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,005 SAY "Cidade               Estado  Documento de Identidade Estado Civil"
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    IMPCTL(drvpenf)
    @ cl,005 SAY TRAN(GRUPOS->cidade,"@!")         // cidade contratante
    IMPCTL(drvtenf)
    @ cl,028 SAY TRAN([  ],"!!")                   // Estado Contratante
    IMPCTL(drvpenf)
    @ cl,037 SAY GRUPOS->rg                        // Doc
    IMPCTL(drvtenf)
    IMPCTL(drvpenf)
    @ cl,059 SAY TRAN(subst(tbestciv,AT(GRUPOS->estcivil,tbestciv),10),"@!")// Est.Civil contratante
    IMPCTL(drvtenf)
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    IMPAC("Contrato    Grupo            Admiss„o                 Processo",cl,005)
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    IMPCTL(drvpenf)
    @ cl,006 SAY contrato                          // contrato numero
    IMPCTL(drvtenf)
    IMPCTL(drvpenf)
    @ cl,018 SAY GRUPOS->grupo                     // grupo
    IMPCTL(drvtenf)
    IMPCTL(drvpenf)
    @ cl,034 SAY GRUPOS->admissao                  // data admissao
    IMPCTL(drvtenf)
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    IMPMEMO(R02001F9(),70,1,cl,001,.t.)            // pedido (memo)
    qli_m=MLCOUNT(R02001F9(),70)-1                 // quantas linhas a imprimir?
    li_m=0
    DO WHIL .t.                                    // imprime linhas do memo
     li_m++
     IF li_m>qli_m                                 // fim do memo
      EXIT
     ENDI
     REL_CAB(1)                                    // soma cl/imprime cabecalho
     IMPMEMO(R02001F9(),70,1+li_m,cl,001,(li_m<qli_m))      // imprime...
     #ifdef COM_TUTOR
      IF IN_KEY()=K_ESC                            // se quer cancelar
     #else
      IF INKEY()=K_ESC                             // se quer cancelar
     #endi
      IF canc()                                    // pede confirmacao
       BREAK                                       // confirmou...
      ENDI
     ENDI
    ENDD
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,004 SAY "Nome do falecido....:"
    IMPCTL(drvpenf)
    @ cl,026 SAY TRAN(falecido,"@!")               // nome do falecido
    IMPCTL(drvtenf)
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    IMPAC("Endere‡o do falecido:",cl,004)
    IMPCTL(drvpenf)
    @ cl,026 SAY TRAN(ALLTRIM(ruares)+[, ]+ALLTRIM(baires),"@!")// Endereco falecido
    IMPCTL(drvtenf)
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,004 SAY "Inscrito neste contrato na qualidade de"
    IMPCTL(drvpenf)
    @ cl,044 SAY grauparcon                        // Inscrito na qualidade de
    IMPCTL(drvtenf)
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,004 SAY "Data do Falecimento.:"
    @ cl,026 SAY TRAN(falecto_,"@D")               // Data falcto.
    IMPAC("Hor rio do Falecimento:",cl,036)
    @ cl,060 SAY TRAN(horafal,"99:99")             // Hora Falcto.
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,004 SAY "Cidade do Falecimento Estado   Local do falecimento"
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    IMPCTL(drvpenf)
    @ cl,004 SAY municfal                          // Cidade Falecimento
    @ cl,028 SAY TRAN(estfal,"!!")                 // UF falecimento
    @ cl,035 SAY ALLTRIM(ruafal)                   // local falecimento
    IMPCTL(drvtenf)
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    IMPAC("Cemit‚rio onde foi sepultado        Hora do sepultamento",cl,004)
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    IMPCTL(drvpenf)
    @ cl,004 SAY cemitsep                          // Cemit‚rio sepultamento
    @ cl,046 SAY TRAN(horasepult,"99:99")          // Hora sepultamento
    IMPCTL(drvtenf)
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    IMPCTL(drvpenf)
    IMPAC("DECLARA€ŽO",cl,031)
    IMPCTL(drvtenf)
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    IMPMEMO(R02002F9(),70,1,cl,002,.t.)            // DECLARACAO (memo)
    qli_m=MLCOUNT(R02002F9(),70)-1                 // quantas linhas a imprimir?
    li_m=0
    DO WHIL .t.                                    // imprime linhas do memo
     li_m++
     IF li_m>qli_m                                 // fim do memo
      EXIT
     ENDI
     REL_CAB(1)                                    // soma cl/imprime cabecalho
     IMPMEMO(R02002F9(),70,1+li_m,cl,002,(li_m<qli_m))      // imprime...
     #ifdef COM_TUTOR
      IF IN_KEY()=K_ESC                            // se quer cancelar
     #else
      IF INKEY()=K_ESC                             // se quer cancelar
     #endi
      IF canc()                                    // pede confirmacao
       BREAK                                       // confirmou...
      ENDI
     ENDI
    ENDD
    REL_CAB(2)                                     // soma cl/imprime cabecalho
    @ cl,025 SAY IMPAC(RTRIM(M->p_cidade)+[, ]+LEFT(DTOC(DATE()),2)+[ de ]+NMES(MONTH(DATE()))+ [ de ]+LEFT(DTOS(DATE()),4))// DATA
    REL_CAB(2)                                     // soma cl/imprime cabecalho
    @ cl,001 SAY "PROCESSAR"
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY "PAGAMENTO EM"
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    IMPCTL(drvpenf)
    @ cl,002 SAY TRAN(procpagto_,"@D")             // Proc.pagto em
    IMPCTL(drvtenf)
    REL_CAB(3)                                     // soma cl/imprime cabecalho
    @ cl,021 SAY REPL("-",42)
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,021 SAY "Ass.:"
    IMPCTL(drvpenf)
    @ cl,027 SAY GRUPOS->nome                      // Nome
    IMPCTL(drvtenf)
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,027 SAY "RG:"
    @ cl,031 SAY TRAN(GRUPOS->rg,"@!")             // R.G.
    SKIP                                           // pega proximo registro
    cl=999                                         // forca salto de pagina
   ELSE                                            // se nao atende condicao
    SKIP                                           // pega proximo registro
   ENDI
  ENDD
 ENDD ccop
END SEQUENCE
SET PRINTER TO (drvporta)                          // fecha arquivo gerado (se houver)
SET DEVI TO SCRE                                   // direciona saida p/ video
IF tps=2                                           // se vai para arquivo/video
 BROWSE_REL(arq_,2,3,MAXROW()-2,78)
ENDI                                               // mostra o arquivo gravado
GRELA(1)                                           // grava variacao do relatorio
SELE AFUNER                                        // salta pagina
SET RELA TO                                        // retira os relacionamentos
SET(_SET_DELETED,dele_atu)                         // os excluidos serao vistos
IF so_um_reg
 POINTER_DBF(sit_dbf)
ENDI
RETU

STATIC PROC REL_CAB(qt)                            // cabecalho do relatorio
IF qt>0                                            // se parametro maior que 0
 cl=cl+qt                                          // soma no contador de linhas
ENDI
IF cl>maxli .OR. qt=0                              // quebra de pagina
 @ 0,001 SAY IIF(categ=[PD],[Plano c/Difer. ],IIF(categ=[PL],[Atend.Plano],[Rest.Desp.Funerais]))// Categoria
 @ 5,021 SAY M->setup1                             // Ident1
    IMPCTL(drvpenf)
 IMPAC("REQUERIMENTO DE RESTITUI€ŽO DE DESPESAS",6,021)
 @ 7,022 SAY "FUNERAIS E TERMO DE RESPONSABILIDADE"
    IMPCTL(drvtenf)
 cl=qt+8 ; pg_++
ENDI
RETU

* \\ Final de ADM_R020.PRG
ÿØÿà JFIF      ÿÛ „ 
(GAS-Pro v4.0
009018017066001001012001010000176001
 Tipo....:
 Endere‡o:
 Bairro..:
 CEP.....:
 Cidade..:                            Est.:
 Telefone:
 Obs.....:
[Ÿ]
Inclus„o~~26006
Manuten‡„o~~27007
Consulta~~28008
[Ÿ]
 10 
 1 
Contrato

 1 
 2 
[Ÿ]
Outros Endere‡os
Outros Endere‡os







005




































-1 
 0 
-1 
-1 
 0 
-1 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
codigo
C
I
@!
 9 
 9 
 0 
 0 
 0 
Codigo






-1 
 0 


tipo
C
E
!
 1 
 1 
 1 
 12 
 0 
Tipo
MTAB([Residˆncia|Trabalho|Outro],[TIPO])
tipo $ [RTO]
TIPO n„o aceit vel|Apenas endere‡os de Residˆncia e Trabalho.
[R]
Informe que tipo de Endere‡o ‚ este.|R=Residˆncia, T=Trabalho
MTAB([Residˆncia|Trabalho|Outro],[TIPO])
 0 
 0 


endereco
C
E
@!
 35 
 35 
 2 
 12 
 0 
Endere‡o

!EMPT(endereco)
Informe a localiza‡„o ou tecle ESC para cancelar

Informe o Endere‡o|Rua,n£mero,apto, blocl, etc...

 0 
 0 


bairro
C
E
@!
 20 
 20 
 3 
 12 
 0 
Bairro

 


Digite o Bairro|ou complemento| do endere‡o

 0 
 0 


cep
C
E
@R 99999-999
 8 
 9 
 4 
 12 
 0 
CEP

 


Informe o CEP para facilitar a localiza‡„o

 0 
 0 


cidade
C
E
@!
 25 
 25 
 5 
 12 
 0 
Cidade

 


Informe a Cidade/Municipio

 0 
 0 


uf
C
E
!!
 2 
 2 
 5 
 45 
 0 
UF

VUF(uf).OR. EMPT(uf)
UNIDADE DA FEDERA€ŽO inv lida

Informe o Estado.|Ex.: SP,RJ,GO,AM,...

 0 
 0 


telefone
C
E
@!
 14 
 14 
 6 
 12 
 0 
Telefone

 


Informe o n£mero do telefone para contato

 0 
 0 


obs
C
E
 
 20 
 20 
 7 
 12 
 0 
Obs

 




 0 
 0 


data_
D
I
@D
 8 
 10 
 0 
 0 
 0 
Data






 0 
 0 


 2 
Tipo
IIF(tipo=[R],[Residˆncia],IIF(tipo=[T],[Trabalho],[Outro]))

 1 
 15 
 12 

Data
data_
@D
 7 
 39 
 8 

 1 
ECOB
data_
DATE()




 0 
 0 
 0 
€
 ADR_PROC–] ADR_PROCCODECBC1CODEAJMOUSECODE
BROWSE_RELCODE	MONTA_LINCODE	MONTA_IMPCODEDOSCOMCODE
PARAMETROSCODEFILTRACODE	FILTROINICODEVEOUTROSCODE	VE_CAMPOSCODEINDTMPCODEREPCODECONFCODECLASSCODE
CAPTURAARQCODE
CAPTURADIRCODE
ESCOLHIDOUCODE	LSTARQDIRCODEPOSICODEIMPRELACODEREIMPTELCODEEDITCODE	REGINICIOCODEINI_ARQCODEFIM_ARQCODEPOSIPAICODEIMP_FORMCODEPEGACHV2CODEGLOBALCODESUBNIVELCODEINTREFCODEVE_RELCODEHELPCODEMHELPCODENADAFAZCODEINFOSISCODE	TIRA_LANCCODEFAZ_LANCCODEMASENHACODEPWG_INCLCODEPWG_TELACODEPWG_GETSCODEPWG_GET1CODEPWT_INCLCODEPWT_TELACODEPWT_GETSCODEPWT_GET1CODEERRORSYSCODEC_ETEXTENDCODE	_SYMSTARTSYMSTARTSYMBOLSSYMBOLS_SYMENDSYMENDNULLBEGDATA_DATADATA_SYMPBDATA_SYMPDATA_SYMPEDATA_CONSTCONST_MSGMSG_BEGBSSBEGBSS_BSSBSS_ENDBSSENDBSSDGROUPÉ˜ @procedure adm_r~2p
/*
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
 \ Empresa.: PresServ Inform tica-Limeira (019)452.6623
 \ Programa: ADM_RS18.PRG
 \ Data....: 27-06-97
 \ Sistema.: Administradora - RECEP€„O
 \ Funcao..: Recibos Sem Falecidos
 \ Analista: Ademilson Pedro Bom
 \ Criacao.: GAS-Pro v3.0 
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/

#include "adrbig.ch"    // inicializa constantes manifestas

LOCAL dele_atu, getlist:={}, so_um_reg, sit_dbf:=POINTER_DBF()
PARA  lin_menu, col_menu, imp_reg
PRIV  tem_borda:=.t., op_menu:=VAR_COMPL, l_s:=10, c_s:=20, l_i:=14, c_i:=61, tela_fundo:=SAVESCREEN(0,0,MAXROW(),79)
nucop=1
so_um_reg=(PCOU()>2)
IF !so_um_reg                             // vai receber a variaveis?
 IF nivelop < 2                                    // se usuario nao tem
  DBOX("Emiss„o negada, "+usuario,20)              // permissao, avisa
  RETU                                             // e retorna
 ENDI
 SETCOLOR(drvtittel)
 vr_memo=NOVAPOSI(@l_s,@c_s,@l_i,@c_i)    // pega posicao atual da tela
 CAIXA(mold,l_s,c_s,l_i,c_i)              // monta caixa da tela
 @ l_s,c_s+10 SAY " RECIBO SEM FALECIDOS "
 SETCOLOR(drvcortel)
 @ l_s+01,c_s+1 SAY " Ano.....:"
 @ l_s+02,c_s+1 SAY " Numero..:"
 @ l_s+03,c_s+1 SAY " Confirme:"
ENDI
rano=SPAC(2)                                       // Ano
rnumero=SPAC(6)                                    // Numero
confirme=SPAC(1)                                   // Confirme
DO WHILE .t.
 rola_t=.f.
 cod_sos=56
 IF !so_um_reg
  SET KEY K_ALT_F8 TO ROLATELA
  SETCOLOR(drvcortel+","+drvcorget+",,,"+corcampo)
  @ l_s+01 ,c_s+12 GET  rano;
                   PICT "99";
                   VALI CRIT("!EMPT(rano)~Necess rio informar ANO")
		   DEFAULT "IIF(PTAB(PADR(SUBSTR(M->ide_maq,2),4)+[BXR],[IMPPAR],1),LEFT(IMPPAR->docto,2),[ ])"
		   AJUDA "Ano da emiss„o"

  @ l_s+02 ,c_s+12 GET  rnumero;
		   PICT "999999";
		   VALI CRIT("PTAB(rano+rnumero,'BXREC',1)~Necess rio informar NUMERO|Tecle F8 para buscar em tabela")
		   DEFAULT "IIF(PTAB(PADR(SUBSTR(M->ide_maq,2),4)+[BXR],[IMPPAR],1),SUBSTR(IMPPAR->docto,3,6),[ ])"
                   AJUDA "N£mero do Recibo a emitir"
                   CMDF8 "VDBF(6,11,20,77,'BXREC',{'ano','numero','codigo','tipo','circ','valorpg','emitido_','numop'},1,'numero',[])"

  @ l_s+03 ,c_s+12 GET  confirme;
                   PICT "!";
                   VALI CRIT("confirme='S'.AND.V01801F9()~CONFIRME n„o aceit vel|Digite S para confirmar|ou|Tecle ESC para cancelar")
                   AJUDA "Digite S para confirmar|ou|tecle ESC para cancelar"

  READ
  SET KEY K_ALT_F8 TO
  IF rola_t
   ROLATELA(.f.)
   LOOP
  ENDI
  IF LASTKEY()=K_ESC                               // se quer cancelar
   RETU                                            // retorna
  ENDI
 ENDI

 #ifdef COM_REDE
  IF !USEARQ("BXREC",.f.,10,1)                     // se falhou a abertura do arq
   RETU                                            // volta ao menu anterior
  ENDI
 #else
  USEARQ("BXREC")                                  // abre o dbf e seus indices
 #endi

 PTAB(codigo,"GRUPOS",1,.t.)                       // abre arquivo p/ o relacionamento
 PTAB([],"ORDPGRC",1,.t.)                       // abre arquivo p/ o relacionamento
 PTAB(codigo+tipo+circ,"TAXAS",1,.t.)
 PTAB(GRUPOS->grupo,"ARQGRUP",1,.t.)
 PTAB(TAXAS->cobrador,"COBRADOR",1,.t.)
 PTAB(GRUPOS->grupo+circ,"CIRCULAR",1,.t.)
 PTAB(GRUPOS->regiao,"REGIAO",1,.t.)
 PTAB(GRUPOS->tipcont,"CLASSES",1,.t.)
 SET RELA TO codigo INTO GRUPOS,;                  // relacionamento dos arquivos
          TO codigo+tipo+circ INTO TAXAS,;
          TO GRUPOS->grupo INTO ARQGRUP,;
	  TO TAXAS->cobrador INTO COBRADOR,;
          TO GRUPOS->grupo+circ INTO CIRCULAR,;
          TO GRUPOS->regiao INTO REGIAO,;
          TO GRUPOS->tipcont INTO CLASSES
 titrel:=criterio:=cpord := ""                     // inicializa variaveis
 titrel:=chv_rela:=chv_1:=chv_2 := ""
 tps:=op_x:=ccop := 1
 arq_=drvporta                                     // porta de saida configurada
 IF !so_um_reg
  IF !opcoes_rel(lin_menu,col_menu,7,11)           // nao quis configurar...
   CLOS ALL                                        // fecha arquivos e
   LOOP                                            // volta ao menu
  ENDI

 #ifdef COM_REDE

  ELSE

   tps=lin_menu

 #endi

 ENDI
 IF tps=2                                          // se vai para arquivo/video
  arq_=ARQGER()                                    // entao pega nome do arquivo
  IF EMPTY(arq_)                                   // se cancelou ou nao informou
   LOOP                                            // retorna
  ENDI
 ELSE
  arq_=drvporta                                    // porta de saida configurada
 ENDI
 SET PRINTER TO (arq_)                             // redireciona saida
 EXIT
ENDD
IF !EMPTY(drvtapg)                                 // existe configuracao de tam pag?
 op_=AT("NNN",drvtapg)                             // se o codigo que altera
 IF op_=0                                          // o tamanho da pagina
  msg="Configura‡„o do tamanho da p gina!"         // foi informado errado
  DBOX(msg,,,,,"ERRO!")                            // avisa
  CLOSE ALL                                        // fecha todos arquivos abertos
  RETU                                             // e cai fora...
 ENDI                                              // codigo para setar/resetar tam pag
 lpp_033=LEFT(drvtapg,op_-1)+"033"+SUBS(drvtapg,op_+3)
 lpp_066=LEFT(drvtapg,op_-1)+"066"+SUBS(drvtapg,op_+3)
ELSE
 lpp_033:=lpp_066 :=""                             // nao ira mudara o tamanho da pag
ENDI
DBOX("[ESC] Interrompe",15,,,NAO_APAGA)
dele_atu:=SET(_SET_DELETED,.t.)                    // os excluidos nao servem...
SET DEVI TO PRIN                                   // inicia a impressao
maxli=32                                           // maximo de linhas no relatorio
IMPCTL(lpp_033)                                    // seta pagina com 33 linhas
SET MARG TO 1                                      // ajusta a margem esquerda
IF tps=2
 IMPCTL("' '+CHR(8)")
ENDI
BEGIN SEQUENCE
 DO WHIL ccop<=nucop                               // imprime qde copias pedida
  pg_=1; cl=999
  IF so_um_reg
   GO imp_reg
  ELSE
   INI_ARQ()                                       // acha 1o. reg valido do arquivo
   IF PTAB(PADR(SUBSTR(M->ide_maq,2),4)+[BXR],[IMPPAR],1)
    PTAB(LEFT(IMPPAR->docto,8),'BXREC',1)
   ENDI
  ENDI
  ccop++                                           // incrementa contador de copias
  DO WHIL !EOF().AND.(!so_um_reg.OR.imp_reg=RECN())
   #ifdef COM_TUTOR
    IF IN_KEY()=K_ESC                              // se quer cancelar
   #else
    IF INKEY()=K_ESC                               // se quer cancelar
   #endi
    IF canc()                                      // pede confirmacao
     BREAK                                         // confirmou...
    ENDI
   ENDI
   IF (PTAB(PADR(SUBSTR(M->ide_maq,2),4)+[BXR],[IMPPAR],1).AND.ano+numero=LEFT(IMPPAR->docto,8)) .OR. so_um_reg// se atender a condicao...
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    IMPCTL(drvpenf)
    @ cl,014 SAY TRAN(ano+numero,"@R 99-999999")  // N§ Recibo
    IMPCTL(drvtenf)
    IMPCTL(drvpexp)
    @ cl,000 SAY [RECIBO]
    IMPCTL(drvtexp)

    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY "Circular:"
    IMPCTL(drvpenf)
    @ cl,010 SAY tipo+'-'+circ                     // Circular
    @ cl,015 SAY [-]+LEFT(DTOC(TAXAS->EMISSAO_),6)+RIGHT(DTOC(TAXAS->EMISSAO_),2)
    IMPCTL(drvtenf)
    @ cl,027 SAY "Valor:"
    IMPCTL(drvpenf)
    @ cl,033 SAY TRAN(valorpg,"@E 999,999.99")     // Valor
    IMPCTL(drvtenf)

    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY [Cx]TRAN(numop,"999999")  // N§ Recibo
    IF so_um_reg                             // vai receber a variaveis?
     @ cl,008 SAY [/]+PADL(TRAN(ORDPGRC->nrdoctos,"9999"))               // Emitido em
    ENDI
    @ cl,013 SAY TRAN(CLASSES->descricao,"@!")     // Descri‡„o 1
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY "Contrato..:"
    IMPCTL(drvpenf)
    @ cl,012 SAY GRUPOS->grupo +[  ]+codigo        // Grupo 1
    IMPCTL(drvtenf)
    @ cl,052 SAY "Data.:"
    @ cl,058 SAY TRAN(emitido_,"@D")               // data 1
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY "Nome......:"
    IMPCTL(drvpenf)
    @ cl,012 SAY GRUPOS->nome                      // Nome
    IMPCTL(drvtenf)
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    IMPAC("Endere‡o..:",cl,000)
    @ cl,012 SAY GRUPOS->endereco                  // Endere‡o
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY "Bairro....:"
    @ cl,012 SAY GRUPOS->bairro                    // Bairro
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY "Cid./Cobr.:"
    @ cl,012 SAY GRUPOS->cidade+[ ] +GRUPOS->cobrador// Cidade

    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,032 SAY REPL("Ä",19)
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,032 SAY "Op:"
    @ cl,036 SAY LEFT(por,1)+LOWER(SUBSTR(por,2))  // operador
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY "Valor:"
    IMPCTL(drvpcom)
    @ cl,007 SAY '('+SUBSTR(EXT(valorpg),1,AT('/',EXT(valorpg))-1)+')'// Valor Ext
    IMPCTL(drvtcom)
    REL_CAB(2)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY REPL("Ä",71)
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    IMPEXP(cl,000,LEFT(M->setup1,35),70)           // 2 Ident1
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY M->setup2                         // 2 Ident 2
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY REPL("-",71)
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    IMPCTL(drvpenf)
    @ cl,014 SAY TRAN(ano+numero,"@R 99-999999")  // N§ Recibo
    IMPCTL(drvtenf)
    @ cl,025 SAY "Circular:"
    IMPCTL(drvpenf)
    @ cl,035 SAY tipo+'-'+circ                     // Circular
    @ cl,040 SAY [-]+LEFT(DTOC(TAXAS->EMISSAO_),6)+RIGHT(DTOC(TAXAS->EMISSAO_),2)
    IMPCTL(drvtenf)
    @ cl,052 SAY "Valor:"
    IMPCTL(drvpenf)
    @ cl,058 SAY TRAN(valorpg,"@E 999,999.99")     // Valor pago
    IMPCTL(drvpexp)
    @ cl,000 SAY [RECIBO]
    IMPCTL(drvtexp)
    IMPCTL(drvtenf)
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY TRAN(numop,"999999")  // N§ Recibo
    IF so_um_reg                             // vai receber a variaveis?
     @ cl,008 SAY TRAN(ORDPGRC->nrdoctos,"9999")               // Emitido em
    endi
    @ cl,012 SAY TRAN(CLASSES->descricao,"@!")     // Descri‡„o 2
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY "Contrato..:"
    IMPCTL(drvpenf)
    @ cl,012 SAY GRUPOS->grupo +[  ]+codigo        // Grupo
    IMPCTL(drvtenf)
    @ cl,052 SAY "Data.:"
    @ cl,058 SAY TRAN(emitido_,"@D")               // Emitido em
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY "Nome......:"
    IMPCTL(drvpenf)
    @ cl,012 SAY GRUPOS->nome                      // Nome
    IMPCTL(drvtenf)
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    IMPAC("Endere‡o..:",cl,000)
    @ cl,012 SAY GRUPOS->endereco                  // Endere‡o
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY "Bairro....:"
    @ cl,012 SAY GRUPOS->bairro                    // Bairro
    @ cl,052 SAY REPL("Ä",19)
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY "Cid./Cobr.:"
    @ cl,012 SAY GRUPOS->cidade+[ ] +GRUPOS->cobrador// Cidade
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,032 SAY "Op:"
    @ cl,036 SAY LEFT(por,1)+LOWER(SUBSTR(por,2))  // Operador
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY "Valor:"
    IMPCTL(drvpcom)
    @ cl,007 SAY '('+SUBSTR(EXT(valorpg),1,AT('/',EXT(valorpg))-1)+')'// Valor Ext
    IMPCTL(drvtcom)
    REL_CAB(2)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY ""
    IF M->combarra=[S]
     CODBARRAS({{codigo+tipo+circ,4,13,9}},10,6)
    ENDI
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY ""
    IF M->combarra=[S]
     CODBARRAS({{codigo+tipo+circ,4,13,9}},10,6)
    ENDI
    SKIP                                           // pega proximo registro
    cl=999                                         // forca salto de pagina
   ELSE                                            // se nao atende condicao
    SKIP                                           // pega proximo registro
   ENDI
   exit
  ENDD
 ENDD ccop
 EJEC                                              // salta pagina
END SEQUENCE
SET MARG TO                                        // coloca margem esquerda = 0
impctl(drvtcom)
IMPCTL(lpp_066)                                    // seta pagina com 66 linhas
SET PRINTER TO (drvporta)                          // fecha arquivo gerado (se houver)
SET DEVI TO SCRE                                   // direciona saida p/ video
IF tps=2                                           // se vai para arquivo/video
 BROWSE_REL(arq_,2,3,MAXROW()-2,78)
ENDI                                               // mostra o arquivo gravado
GRELA(7)                                           // grava variacao do relatorio
SELE BXREC                                         // salta pagina
SET RELA TO                                        // retira os relacionamentos
SET(_SET_DELETED,dele_atu)                         // os excluidos serao vistos
IF so_um_reg
 POINTER_DBF(sit_dbf)
ENDI
RETU

STATIC PROC REL_CAB(qt)                            // cabecalho do relatorio
IF qt>0                                            // se parametro maior que 0
 cl=cl+qt                                          // soma no contador de linhas
ENDI
IF cl>maxli .OR. qt=0                              // quebra de pagina
 IMPCTL(drvpcom)
 @ 0,000 SAY LEFT(M->setup1,55)               // Ident1
 @ 1,000 SAY M->setup2                             // Ident2
 @ 2,000 SAY REPL("-",50)
 cl=qt+2 ; pg_++
ENDI
RETU

* \\ Final de ADM_RS18.PRG
€
 ADM_R029P–Þ  ADM_R029CODEREL_CABCODEC_ETEXTENDCODE	_SYMSTARTSYMSTARTSYMBOLSSYMBOLS_SYMENDSYMENDNULLBEGDATA_DATADATA_SYMPBDATA_SYMPDATA_SYMPEDATA_CONSTCONST_MSGMSG_BEGBSSBEGBSS_BSSBSS_ENDBSSENDBSSDGROUPÔ˜ @…ˆ˜ @p¦˜ H  ˜ h  	ç˜ ` 
ä˜ h  ß˜ h  Û˜ H  ÷˜ H  ó˜ H ç˜ H  ë˜ H  ç˜ (  procedure medicos
/*
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
 \ Empresa.: PresServ Inform tica - Limeira (019)452.6623
 \ Programa: MEDICOS.PRG
 \ Data....: 04-11-03
 \ Sistema.: Administradora - RECEP€„O
 \ Funcao..: Gerenciador do subsistema de credenciados
 \ Analista: Ademilson Pedro Bom
 \ Criacao.: GAS-Pro v4.0n
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/
#include "adrbig.ch"    // inicializa constantes manifestas

PARA lin_menu,col_menu
PRIV op_sis, tela_fundo:=SAVESCREEN(0,0,MAXROW(),79), l_s, c_s, l_i, c_i, l_a

op_sis=EVAL(qualsis,"MEDICOS")
IF nivelop<sistema[op_sis,O_OUTROS,O_NIVEL]        // se usuario nao tem permissao,
 ALERTA()                                          // entao, beep, beep, beep
 DBOX(msg_auto,,,3)                                // lamentamos e
 RETU                                              // retornamos ao menu
ENDI
cn:=fgrep :=.f.

#ifdef COM_LOCK
 IF LEN(pr_ok)>0                                   // se a protecao acusou
  ? pr_ok                                          // erro, avisa e
  QUIT                                             // encerra a aplicacao
 ENDI
#endi

t_fundo=SAVESCREEN(0,0,MAXROW(),79)                // salva tela do fundo
op_cad=1
DO WHIL op_cad!=0
 criterio=""
 RESTSCREEN(0,0,MAXROW(),79,t_fundo)               // restaura tela do fundo
 cod_sos=5 ; cn=.f.
 CLEA TYPEAHEAD                                    // limpa o buffer do teclado
 fgrep=.f.
 SET KEY K_F3 TO                                   // retira das teclas F3 e F4 as
 SET KEY K_F4 TO                                   // funcoes de repeticao e confirmacao
 msg="Inclus„o~1|"+;
     "Manuten‡„o~2|"+;
     "Consulta~3"
 op_cad=DBOX(msg,lin_menu,col_menu,E_MENU,NAO_APAGA,MAIUSC(sistema[op_sis,O_MENU]),,,op_cad)
 IF op_cad!=0                                      // se escolheu uma opcao
  Tela_fundo=SAVESCREEN(0,0,MAXROW(),79)           // salva a tela para ROLATELA()
  PARAMETROS(dbfparam)
  SELE A                                           // e abre o arquivo e seus indices

  #ifdef COM_REDE
   IF !USEARQ(sistema[op_sis,O_ARQUI,O_NOME],.f.,20,1)
                                                   // se falhou a abertura do
    RETU                                           // arquivo volta ao menu anterior
   ENDI
  #else
   USEARQ(sistema[op_sis,O_ARQUI,O_NOME])
  #endi

  SET KEY K_F9 TO veoutros                         // habilita consulta em outros arquivos
 ENDI
 DO CASE
  CASE op_cad=01                                   // inclus„o
   op_menu=INCLUSAO
   IF AT("D",exrot[op_sis])=0                      // se usuario pode fazer inclusao
    MED_INCL()                                     // neste arquivo chama prg de inclusao
   ELSE                                            // caso contrario vamos avisar que
    ALERTA()                                       // ele nao tem permissao para isto
    DBOX(msg_auto,,,3)
   ENDI

  CASE op_cad=02                                   // manuten‡„o
   op_menu=ALTERACAO
   cod_sos=7
   EDIT()

  CASE op_cad=03                                   // consulta
   op_menu=PROJECOES
   cod_sos=8
   EDITA(03,03,MAXROW()-2,77)

 ENDC
 SET KEY K_F9 TO                                   // F9 nao mais consultara outros arquivos
 CLOS ALL                                          // fecha todos arquivos abertos
ENDD
RETU

PROC MED_incl(reg_cop)  // inclusao no arquivo MEDICOS
LOCAL getlist:={},cabem:=1,rep:=ARRAY(FCOU()),ult_reg:=RECN(),dbfseq_,;
      ctl_r, ctl_c, ctl_w, t_f3_, t_f4_, dele_atu:=SET(_SET_DELETED,.f.)
PRIV op_menu:=INCLUSAO, sq_atual_, tem_borda, criterio:="", cpord:=""
FOR i=1 TO FCOU()                                  // cria/declara privadas as
 msg=FIEL(i)                                       // variaveis de memoria com
 PRIV &msg.                                        // o mesmo nome dos campos
NEXT                                               // do arquivo
IF reg_cop!=NIL                                    // quer repetir todo o reg atual
 FOR i=1 TO FCOU()                                 // para cada campo,
  msg=FIEL(i)                                      // salva o conteudo
  rep[i]=&msg.                                     // para repetir
 NEXT
ELSE
 AFILL(rep,"")                                     // eche com valor vazio
ENDI
t_f3_=SETKEY(K_F3,{||rep()})                       // repeticao reg anterior
t_f4_=SETKEY(K_F4,{||conf()})                      // confirma campos com ENTER
ctl_w=SETKEY(K_CTRL_W,{||nadafaz()})               // enganando o CA-Clipper...
ctl_c=SETKEY(K_CTRL_C,{||nadafaz()})
ctl_r=SETKEY(K_CTRL_R,{||nadafaz()})

#ifdef COM_REDE
 MED_CRIA_SEQ()                                    // cria dbf de controle de cp sequenciais
 FOR i=1 TO FCOU()                                 // cria/declara privadas as
  msg="sq_"+FIEL(i)                                // variaveis de memoria com
  PRIV &msg.                                       // o mesmo nome dos campos
 NEXT                                              // do arquivo com extensao _seq
#endi

DO WHIL cabem>0
 cod_sos=6
 rola_t=.f.                                        // flag se quer rolar a tela
 SELE MEDICOS
 GO BOTT                                           // forca o
 SKIP                                              // final do arquivo
 
 /*
    cria variaveis de memoria identicas as de arquivo, para inclusao
    de registros
 */
 FOR i=1 TO FCOU()
  msg=FIEL(i)
  M->&msg.=IF((fgrep .OR. reg_cop!=NIL).AND.!EMPT(rep[1]),rep[i],&msg.)
 NEXT
 DISPBEGIN()                                       // apresenta a tela de uma vez so
 MED_TELA()
 INFOSIS(.t.)                                      // exibe informacao no rodape' da tela
 DISPEND()
 MED_GERA_SEQ()
 cabem=DISKSPACE(;
          IF(;
             LEN(sistema[op_sis,O_ARQUI,O_DIR_DBF])<2.OR.sistema[op_sis,O_ARQUI,O_DIR_DBF]="\",;
             0,;
             ASC(sistema[op_sis,O_ARQUI,O_DIR_DBF])-64;
          );
       )
 cabem=INT((cabem-2048)/MEDICOS->(RECSIZE()))
 IF cabem<1                                        // mais nenhum!!!
  ALERTA()
  msg="Verifique ESPA€O EM DISCO, "+usuario
  DBOX(msg,,,,,"INCLUSŽO INTERROMPIDA!")           // vamos parar por aqui!
  EXIT
 ENDI
 SELE 0                                            // torna visiveis variaveis de memoria
 SETCOLOR(drvcortel+","+drvcorget+",,,"+corcampo)
 SET KEY K_ALT_F8 TO ROLATELA
 
 /*
    recebe chaves do arquivo de indice basico
 */
 @ l_s+07 ,c_s+14 GET  nome
                  DEFINICAO 12

 READ
 SET KEY K_ALT_F8 TO
 IF rola_t
  ROLATELA()

  #ifdef COM_REDE
   MED_ANT_SEQ()                                   // decrementa sequencial
  #endi

  LOOP
 ENDI
 SELE MEDICOS
 IF LASTKEY()=K_ESC                                // cancelou ou chave em branco
  cabem=0                                          // prepara saida da inclusao
  LOOP                                             // volta p/ menu de cadastramento
 ENDI
 SEEK M->nome
 aprov_reg_=(FOUND().AND.DELE().AND.!drvvisivel)   // vai aproveitar o registro?
 IF FOUND() .AND. !aprov_reg_                      // pesquisou e achou!
  op_menu=ALTERACAO                                // seta flag de ateracao

  #ifdef COM_REDE
   MED_ANT_SEQ()                                   // decrementa sequencial
   SELE MEDICOS
  #endi

  DISPBEGIN()
  MED_GETS()                                       // mostra conteudo do registro
  INFOSIS(.f.)                                     // exibe informacao no rodape' da tela
  DISPEND()
  ALERTA()
  msg="Consultar/alterar|Retornar … inclus„o"      // pergunta se deseja
  op_=DBOX(msg,,,E_MENU,,"REGISTRO J EXISTE")     // alterar o registro
  IF op_ =1                                        // caso afirmativo
   EDIT()                                          // deixa alterar
  ENDI
  op_menu=INCLUSAO
  LOOP                                             // volta para inclusao
 ENDI
 SELE 0
 MED_GET1(INCLUI)                                  // recebe campos
 SELE MEDICOS
 IF LASTKEY()=K_ESC                                // se cancelou

  #ifdef COM_REDE
   MED_ANT_SEQ()                                   // decrementa sequencial
  #endi

  ALERTA()                                         // avisa que o registro
  DBOX("Registro n„o inclu¡do!",18,,1)             // nao foi incluido, e volta
  LOOP
 ENDI

 #ifdef COM_REDE
  GO BOTT                                          // vamos bloquear o final do
  SKIP                                             // arq para que nehum outro
  BLOREG(0,.5)                                     // usuario possa incluir
  SEEK M->nome                                     // se registro foi incluido
  aprov_reg_=(FOUND().AND.DELE().AND.!drvvisivel)  // vai aproveitar o registro?
  IF FOUND() .AND. !aprov_reg_                     // por outro usuario, entao
   BLOREG(0,.5)
   FOR i=1 TO FCOU()
    msg=FIEL(i)
    rep[i]=&msg.
    REPL &msg. WITH M->&msg.
   NEXT
   MED_GET1(FORM_INVERSA)                          // executa formula inversa
   RECA
   FOR i=1 TO FCOU()
    msg=FIEL(i)
    REPL &msg. WITH rep[i]
   NEXT
   ALERTA(4)                                       // beep 4 vezes
   msg="Registro acabou de ser|inclu¡do por outro usu rio!"
   DBOX(msg,,,,,"ATEN€ŽO!")                        // avisa
   SELE MEDICOS
   UNLOCK                                          // libera o registro
   LOOP                                            // e recebe chave novamente
  ENDI
 #endi

 IF aprov_reg_                                     // se vai aproveitar reg excluido

  #ifdef COM_REDE
   BLOREG(0,.5)
  #endi

  RECA                                             // excluido, vamos recupera-lo
 ELSE                                              // caso contrario
  APPEND BLANK                                     // inclui reg em branco no dbf
 ENDI
 FOR i=1 TO FCOU()                                 // para cada campo,
  msg=FIEL(i)                                      // salva o conteudo
  rep[i]=M->&msg.                                  // para repetir
  REPL &msg. WITH rep[i]                           // enche o campo do arquivo
 NEXT

 #ifdef COM_REDE
  UNLOCK                                           // libera o registro e
  COMMIT                                           // forca gravacao
 #else
  IF RECC()-INT(RECC()/20)*20=0                    // a cada 20 registros
   COMMIT                                          // digitados forca gravacao
  ENDI
 #endi

 ult_reg=RECN()                                    // ultimo registro digitado
 IF reg_cop!=NIL                                   // estava na consulta e quis rep o campo
  sq_atual_=NIL
  EXIT                                             // cai fora...
 ENDI
ENDD

#ifdef COM_REDE
 MED_ANT_SEQ()                                     // restaura sequencial anterior
 SELE MEDICOS
#endi

GO ult_reg                                         // para o ultimo reg digitado
SETKEY(K_F3,t_f3_)                                 // restaura teclas de funcoes
SETKEY(K_F4,t_f4_)
SET(_SET_DELETED,dele_atu)                            // ecluidos visiveis/invisiveis
SETKEY(K_CTRL_W,ctl_w)
SETKEY(K_CTRL_C,ctl_c)
SETKEY(K_CTRL_R,ctl_r)
RETU



#ifdef COM_REDE
 PROC MED_ANT_SEQ(est_seq)     // restaura sequencial anterior
 SELE MED_SEQ     // seleciona arquivo de controle de sequencial
 BLOARQ(0,.5)     // esta estacao foi a ultima a incluir?
 IF sq_atual_ == ai
  REPL ai WITH sq_ai
  REPL intlan WITH sq_intlan
 ENDI
 UNLOCK           // libera DBF para outros usuarios
 COMMIT           // atualiza cps sequenciais no disco
 RETU
#endi


PROC MED_CRIA_SEQ   // cria dbf de controle de campos sequenciais
LOCAL dbfseq_:=sistema[op_sis,O_ARQUI,O_DIR_DBF]+"MED_seq" // arq temporario
SELE 0                          // seleciona area vazia
IF !FILE(dbfseq_+".dbf")        // se o dbf nao existe
 DBCREATE(dbfseq_,{;            // vamos criar a sua estrutura
                    {"ai"        ,"C",  5, 0},;
                    {"intlan"    ,"C",  8, 0};
                  };
 )
ENDI
USEARQ(dbfseq_,.f.,,,.f.)       // abre arquivo de cps sequencial
IF RECC()=0                     // se o dbf foi criado agora
 BLOARQ(0,.5)                   // inclui um registro que tera
 APPEND BLANK                   // os ultomos cps sequenciais
 SELE MEDICOS
 IF RECC()>0                    // se o DBF nao estiver
  SET ORDER TO 0                // vazio, entao enche DBF seq
  GO BOTT                       // com o ultimo reg digitado
  REPL MED_SEQ->ai WITH ai
  REPL MED_SEQ->intlan WITH intlan
  DBSETORDER(1)                 // retorna ao indice principal
 ENDI
 SELE MED_SEQ                   // seleciona arq de sequencias
 UNLOCK                         // libera DBF para outros usuarios
 COMMIT                         // atualiza cps sequenciais no disco
ENDI
RETURN

PROC MED_GERA_SEQ()

#ifdef COM_REDE
 LOCAL ar_:=SELEC()
#else
 LOCAL reg_:=RECNO(),ord_ind:=INDEXORD()
#endi


#ifdef COM_REDE
 SELE MED_SEQ
 BLOARQ(0,.5)
 sq_ai=MED_SEQ->ai
 sq_intlan=MED_SEQ->intlan
#else
 DBSETORDER(0)
 GO BOTT
#endi

M->ai=PADR(ALLTRIM(STR(VAL(ai)+1)),5)
M->intlan=LPAD(STR(VAL(intlan)+1),08,[0])

#ifdef COM_REDE
 MED_GRAVA_SEQ()
 sq_atual_=MED_SEQ->ai
 UNLOCK                                            // libera o registro
 COMMIT
 SELE (ar_)
#else
 DBSETORDER(ord_ind)
 GO reg_
#endi

RETU

PROC MED_GRAVA_SEQ
REPL ai WITH M->ai
REPL intlan WITH M->intlan
RETU

PROC MED_tela     // tela do arquivo MEDICOS
tem_borda=.t.
l_s=Sistema[op_sis,O_TELA,O_LS]           // coordenadas da tela
c_s=Sistema[op_sis,O_TELA,O_CS]
l_i=Sistema[op_sis,O_TELA,O_LI]
c_i=Sistema[op_sis,O_TELA,O_CI]
SETCOLOR(drvtittel)
vr_memo=NOVAPOSI(@l_s,@c_s,@l_i,@c_i)     // pega posicao atual da tela
CAIXA(mold,l_s,c_s,l_i,c_i)               // monta caixa da tela
i=LEN(sistema[op_sis,O_MENS])/2
@ l_s,c_s-1+(c_i-c_s+1)/2-i SAY " "+MAIUSC(sistema[op_sis,O_MENS])+" "
SETCOLOR(drvcortel)
@ l_s+01,c_s+1 SAY "        CodBenefic:"
@ l_s+02,c_s+1 SAY " Oldescrito:                Oldclasse.:"
@ l_s+03,c_s+1 SAY " Prioridade:                Situa‡„o..:"
@ l_s+04,c_s+1 SAY " Oldespec..:"
@ l_s+05,c_s+1 SAY " Detalhes..:                Vantagens.:"
@ l_s+06,c_s+1 SAY " Condicoes.:                Informutil:"
@ l_s+07,c_s+1 SAY " Nome......:"
@ l_s+08,c_s+1 SAY " Endere‡o..:"
@ l_s+09,c_s+1 SAY " Bairro....:"
@ l_s+10,c_s+1 SAY " Cidade....:                                    CEP:"
@ l_s+11,c_s+1 SAY " Contato...:"
@ l_s+12,c_s+1 SAY " FoneCom1..:                 FoneCom2.:"
@ l_s+13,c_s+1 SAY " Fonecel...:                 Foneres1.:"
@ l_s+14,c_s+1 SAY " Email.....:"
@ l_s+15,c_s+1 SAY " Fax.......:                 Bip......:"
@ l_s+16,c_s+1 SAY " Fonesdiv..:"
@ l_s+17,c_s+1 SAY " DataInc...:                 DataAlt..:"
@ l_s+18,c_s+1 SAY " Codcidade.:                 Contrato.:"
@ l_s+19,c_s+1 SAY " Flagetq...:                 Codclasse:"
RETU

PROC MED_gets     // mostra variaveis do arquivo MEDICOS
LOCAL getlist := {}, ord_, chv_, t_f7_
MED_TELA()
SETCOLOR(drvcortel+","+drvcorget+",,,"+corcampo)
@ l_s+01 ,c_s+02 GET  ai

@ l_s+01 ,c_s+21 GET  codbenefic

@ l_s+02 ,c_s+14 GET  oldescrito

@ l_s+02 ,c_s+41 GET  oldclasse

@ l_s+03 ,c_s+14 GET  prioridade

@ l_s+03 ,c_s+41 GET  status;
                 PICT sistema[op_sis,O_CAMPO,06,O_MASC]

@ l_s+04 ,c_s+14 GET  oldespec;
                 PICT sistema[op_sis,O_CAMPO,07,O_MASC]

@ l_s+05 ,c_s+14 SAY "{M} "

@ l_s+05 ,c_s+41 SAY "{M} "

@ l_s+06 ,c_s+14 SAY "{M} "

@ l_s+06 ,c_s+41 SAY "{M} "

@ l_s+07 ,c_s+14 GET  nome

@ l_s+08 ,c_s+14 GET  endereco

@ l_s+09 ,c_s+14 GET  bairro;
                 PICT sistema[op_sis,O_CAMPO,14,O_MASC]

@ l_s+10 ,c_s+14 GET  cidade;
                 PICT sistema[op_sis,O_CAMPO,15,O_MASC]

@ l_s+10 ,c_s+45 GET  uf;
                 PICT sistema[op_sis,O_CAMPO,16,O_MASC]

@ l_s+10 ,c_s+54 GET  cep;
                 PICT sistema[op_sis,O_CAMPO,17,O_MASC]

@ l_s+11 ,c_s+14 GET  contato;
                 PICT sistema[op_sis,O_CAMPO,18,O_MASC]

@ l_s+12 ,c_s+14 GET  fonecom1

@ l_s+12 ,c_s+41 GET  fonecom2;
                 PICT sistema[op_sis,O_CAMPO,20,O_MASC]

@ l_s+13 ,c_s+14 GET  fonecel;
                 PICT sistema[op_sis,O_CAMPO,21,O_MASC]

@ l_s+13 ,c_s+41 GET  foneres1;
                 PICT sistema[op_sis,O_CAMPO,22,O_MASC]

@ l_s+14 ,c_s+14 GET  email;
                 PICT sistema[op_sis,O_CAMPO,23,O_MASC]

@ l_s+15 ,c_s+14 GET  fax;
                 PICT sistema[op_sis,O_CAMPO,24,O_MASC]

@ l_s+15 ,c_s+41 GET  bip;
                 PICT sistema[op_sis,O_CAMPO,25,O_MASC]

@ l_s+16 ,c_s+14 GET  fonesdiv;
                 PICT sistema[op_sis,O_CAMPO,26,O_MASC]

@ l_s+17 ,c_s+14 GET  datainc;
                 PICT sistema[op_sis,O_CAMPO,27,O_MASC]

@ l_s+17 ,c_s+41 GET  dataalt;
                 PICT sistema[op_sis,O_CAMPO,28,O_MASC]

@ l_s+18 ,c_s+14 GET  codcidade

@ l_s+18 ,c_s+41 GET  contrato

@ l_s+19 ,c_s+14 GET  flagetq

@ l_s+19 ,c_s+41 GET  codclasse

CLEAR GETS
RETU

PROC MED_get1(tp_mov)     // capta variaveis do arquivo MEDICOS
LOCAL getlist := {}, ord_, chv_, t_f7_
PRIV  blk_medicos:=.t.

IF tp_mov=INCLUI
 DO WHILE .t.
  rola_t=.f.
  memo08:=memo09:=memo10:=memo11:="{F7}"
  t_f7_=SETKEY(K_F7,{||MED_memo()})
  SET KEY K_ALT_F8 TO ROLATELA
  SETCOLOR(drvcortel+","+drvcorget+",,,"+corcampo)
  @ l_s+01 ,c_s+02 GET  ai
                   DEFINICAO 1

  @ l_s+01 ,c_s+21 GET  codbenefic
                   DEFINICAO 2

  @ l_s+02 ,c_s+14 GET  oldescrito
                   DEFINICAO 3

  @ l_s+02 ,c_s+41 GET  oldclasse
                   DEFINICAO 4

  @ l_s+03 ,c_s+14 GET  prioridade
                   DEFINICAO 5

  @ l_s+03 ,c_s+41 GET  status;
                   PICT sistema[op_sis,O_CAMPO,06,O_MASC]
                   DEFINICAO 6

  @ l_s+04 ,c_s+14 GET  oldespec;
                   PICT sistema[op_sis,O_CAMPO,07,O_MASC]
                   DEFINICAO 7

  @ l_s+05 ,c_s+14 GET  memo08;
                   PICT "@!"
                   DEFINICAO 8

  @ l_s+05 ,c_s+41 GET  memo09;
                   PICT "@!"
                   DEFINICAO 9

  @ l_s+06 ,c_s+14 GET  memo10;
                   PICT "@!"
                   DEFINICAO 10

  @ l_s+06 ,c_s+41 GET  memo11;
                   PICT "@!"
                   DEFINICAO 11

  @ l_s+08 ,c_s+14 GET  endereco
                   DEFINICAO 13

  @ l_s+09 ,c_s+14 GET  bairro;
                   PICT sistema[op_sis,O_CAMPO,14,O_MASC]
                   DEFINICAO 14

  @ l_s+10 ,c_s+14 GET  cidade;
                   PICT sistema[op_sis,O_CAMPO,15,O_MASC]
                   DEFINICAO 15

  @ l_s+10 ,c_s+45 GET  uf;
                   PICT sistema[op_sis,O_CAMPO,16,O_MASC]
                   DEFINICAO 16

  @ l_s+10 ,c_s+54 GET  cep;
                   PICT sistema[op_sis,O_CAMPO,17,O_MASC]
                   DEFINICAO 17

  @ l_s+11 ,c_s+14 GET  contato;
                   PICT sistema[op_sis,O_CAMPO,18,O_MASC]
                   DEFINICAO 18

  @ l_s+12 ,c_s+14 GET  fonecom1
                   DEFINICAO 19

  @ l_s+12 ,c_s+41 GET  fonecom2;
                   PICT sistema[op_sis,O_CAMPO,20,O_MASC]
                   DEFINICAO 20

  @ l_s+13 ,c_s+14 GET  fonecel;
                   PICT sistema[op_sis,O_CAMPO,21,O_MASC]
                   DEFINICAO 21

  @ l_s+13 ,c_s+41 GET  foneres1;
                   PICT sistema[op_sis,O_CAMPO,22,O_MASC]
                   DEFINICAO 22

  @ l_s+14 ,c_s+14 GET  email;
                   PICT sistema[op_sis,O_CAMPO,23,O_MASC]
                   DEFINICAO 23

  @ l_s+15 ,c_s+14 GET  fax;
                   PICT sistema[op_sis,O_CAMPO,24,O_MASC]
                   DEFINICAO 24

  @ l_s+15 ,c_s+41 GET  bip;
                   PICT sistema[op_sis,O_CAMPO,25,O_MASC]
                   DEFINICAO 25

  @ l_s+16 ,c_s+14 GET  fonesdiv;
                   PICT sistema[op_sis,O_CAMPO,26,O_MASC]
                   DEFINICAO 26

  @ l_s+17 ,c_s+14 GET  datainc;
                   PICT sistema[op_sis,O_CAMPO,27,O_MASC]
                   DEFINICAO 27

  @ l_s+17 ,c_s+41 GET  dataalt;
                   PICT sistema[op_sis,O_CAMPO,28,O_MASC]
                   DEFINICAO 28

  @ l_s+18 ,c_s+14 GET  codcidade
                   DEFINICAO 29

  @ l_s+18 ,c_s+41 GET  contrato
                   DEFINICAO 30

  @ l_s+19 ,c_s+14 GET  flagetq
                   DEFINICAO 31

  @ l_s+19 ,c_s+41 GET  codclasse
                   DEFINICAO 32

  READ
  SETKEY(K_F7,t_f7_)
  SET KEY K_ALT_F8 TO
  IF rola_t
   ROLATELA()
   LOOP
  ENDI
  IF LASTKEY()!=K_ESC .AND. drvincl .AND. op_menu=INCLUSAO
   IF !CONFINCL()
    LOOP
   ENDI
  ENDI
  EXIT
 ENDD
ENDI
IF tp_mov=EXCLUI .OR. tp_mov=FORM_INVERSA
 IF 1=3
  TIRA_LANC("TESPEC","MED-"+intlan)
 ENDI
 IF !EMPTY(ALIAS())
  DELE
 ENDI
ELSEIF tp_mov=INCLUI .OR. tp_mov=RECUPERA .OR. tp_mov=FORM_DIRETA
 IF (op_menu=INCLUSAO .AND. LASTKEY()!=K_ESC) .OR. op_menu!=INCLUSAO
  IF !PTAB(especialid,'TESPEC',1)
   ord_=LEN(sistema[EVAL(qualsis,"TESPEC"),O_CHAVE])
   IF TYPE("M->intlan")="C" .AND. EMPTY(intlan)
    chv_="MED-"+M->intlan+"-001"
   ELSE
    chv_="MED-"+intlan+"-001"
   ENDI
   PTAB(chv_,"TESPEC",ord_)
   FAZ_LANC("TESPEC",chv_)
   REPL TESPEC->especialid WITH especialid

   #ifdef COM_REDE
    TESPEC->(DBUNLOCK())                           // libera o registro
   #endi

  ENDI
  IF op_menu!=INCLUSAO
   RECA
  ENDI
 ENDI
ENDI
RETU

PROC MED_MEMO
IF READVAR()="MEMO08"
 EDIMEMO("detalhes",sistema[op_sis,O_CAMPO,08,O_TITU],14,2,23,38)
ELSEIF READVAR()="MEMO09"
 EDIMEMO("vantagens",sistema[op_sis,O_CAMPO,09,O_TITU],14,2,23,38)
ELSEIF READVAR()="MEMO10"
 EDIMEMO("condicoes",sistema[op_sis,O_CAMPO,10,O_TITU],14,2,23,38)
ELSEIF READVAR()="MEMO11"
 EDIMEMO("informutil",sistema[op_sis,O_CAMPO,11,O_TITU],14,2,23,38)
ENDI
RETU

* \\ Final de MEDICOS.PRG
/*
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
 \ Empresa.: Ind£stria de Urnas Bignotto Ltda
 \ Programa: CAD_04F9.PRG
 \ Data....: 22-04-97
 \ Sistema.: Controle de Processos da Funer ria
 \ Funcao..: Valida‡„o do campo CONTRATO, arquivo CADPROC
 \ Analista: Ademilson Pedro Bom
 \ Criacao.: Programado manualmente pelo analista
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/

#include "adrbig.ch"    // inicializa constantes manifestas
para op_menu
LOCAL reg_dbf1:=POINTER_DBF() , contraux:=GRUPOS->codigo
LOCAL cipend:=vlpend:=0
IF !(op_menu=INCLUSAO)
 retu .t.
ENDI

IF !(contraux=ultcodmsg)
 msg:=[  --->   A T E N C A O  <---|| FAVOR CONFIRMAR|| CPF e Data de Nascimento||]
 KEY2seek:=[ABCDEFGHIJKLMNOPQRSTUVYXWZ]
 KEY2seek+=key2seek
 KEY2seek+=key2seek
 key2press:=[]
 do while EMPT(key2press)
  key2press:=right(str(seconds()),2)
  if (key2press=[00])
   key2press:=[]
  endi
 endd
 key2press:=substr(key2seek,val(key2press),1)

// msg+=[     Tecle <]+key2press+[> para sair|]
 msg+=[     Tecle algo para sair|]
 pressedkey:=[ ]
 do while !(pressedkey=key2press)
  pressedkey:=DBOX(msg,,,,,"ATEN€ŽO! "+usuario," ","!",,)        // avisa ao usuario
  pressedkey:=UPPER(pressedkey)
  EXIT
 endd
 ultcodmsg:=contraux
endi
msg_obs_aux:=msg:=[]
IF PTAB(contraux,[MFILIAL],2,.t.)
 SELE MFILIAL
 DO WHILE !EOF().AND.codigo=contraux
  IF DELE()
   SKIP
   LOOP
  ENDI
  msg_obs_aux+=[**> ATENCAO   ATENCAO   ATENCAO <**]+[|]
  msg_obs_fim:=[***--(]+ALLTRIM(idxd)+[)--***]+[|]
  IF !EMPT(tcarenc_)
   msg_obs_aux+=[ Contrato em Carencia por negociacao ate ]+dtoc(TCARENc_)+[|]
  ENDI
  msg_obs_aux+=ALLTRIM(obs1)+[|]+;
                         ALLTRIM(obs2)+[|]+;
                         ALLTRIM(obs3)+[|]+;
                         msg_obs_fim
  SKIP
  msg_obs_fim:=[]
 ENDD
 msg:=msg_obs_aux
ENDI
ctlmax:=IIF(GRUPOS->codigo=[020],60,10)
for ctmsg=1 to ctlmax
 IF ctlmax=10
  msgaux:=MEMOLINE(GRUPOS->obs,60,ctmsg)
 ELSE
  msgaux:=MEMOLINE(GRUPOS->obs,60,ctmsg)
 ENDI
 IF !EMPT(msgaux)
  msg+=msgaux+[|]
 ENDI
next
PTAB(LEFT(GRUPOS->codigo,09),'TAXAS',1)
SELE TAXAS
 pressedkey:=DBOX(msg,,,,,"ATEN€ŽO! antes do loop "+usuario," ","!",,)        // avisa ao usuario
DO WHILE !EOF() .AND.codigo=LEFT(GRUPOS->codigo,09)
 pressedkey:=DBOX(msg,,,,,"ATEN€ŽO! no loop"+usuario," ","!",,)        // avisa ao usuario
 IF valorpg=0.AND.emissao_<=DATE()
  msg+=[Contrato com 1 ou + d‚bitos pendentes.|]
  exit
 ENDI
 SKIP
ENDD
IF !EMPT(msg)
// op_=DBOX(msg,,,E_MENU,,"SITUACAO DO CONTRATO!") //
 op_=DBOX(msg,,,E_MENU,,"SITUACAO DO CONTRATO!") //
 msg:=[]
ENDI
PTAB([],[MENSAG])
SELE MENSAG
DO WHILE ! EOF()
 SELE GRUPOS
 cond=LEFT(MENSAG->filtro,AT("~",MENSAG->filtro)-1)               // condicao de validacao
 OP_=0
 msg:=[...]
 MSGAUX:=[MENSAGEM]
 alerta()
 IF (&cond.)                                 // se condicao nao satisfeita,
  nrlin:=mlcount(MENSAG->mens1,60)
  FOR OP_ = 1 TO nrlin
   msgAUX:=MEMOLINE(MENSAG->mens1,60,OP_)
   msg+=[|]+msgAUX
  NEXT
  msg+=[|...]
  ALERTA()                                   // beep, beep, beep
  DBOX(msg,,,E_MENU,,"ATEN€ŽO! "+usuario)        // avisa ao usuario
 ENDI
 SELE MENSAG
 SKIP
ENDD


 POINTER_DBF(reg_dbf1)

RETU .t.  // <- deve retornar um valor L¢GICO

* \\ Final de CAD_04F9.PRG
€
 R07701F9ž–Ñ  R07701F9CODEC_ETEXTENDCODE	_SYMSTARTSYMSTARTSYMBOLSSYMBOLS_SYMENDSYMENDNULLBEGDATA_DATADATA_SYMPBDATA_SYMPDATA_SYMPEDATA_CONSTCONST_MSGMSG_BEGBSSBEGBSS_BSSBSS_ENDBSSENDBSSDGROUP]˜ @y ¢˜ H  ˜ h  ë˜ ` 	_˜ h  
ã˜ h  ß˜ H  û˜ H  ÷˜ H ë˜ H  ï˜ H  ë˜ (  ˜ H  /*
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
 \ Empresa.: Ind£stria de Urnas Bignotto Ltda
 \ Programa: CON_R001.PRG
 \ Data....: 15-05-97
 \ Sistema.: Controle de Convˆnios
 \ Funcao..: Emiss„o Guias 1¦ Parte
 \ Analista: Ademilson Pedro Bom
 \ Criacao.: GAS-Pro v3.0
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/

#include "adrbig.ch"    // inicializa constantes manifestas

LOCAL dele_atu, getlist:={}, so_um_reg, sit_dbf:=POINTER_DBF()
PARA  lin_menu, col_menu, imp_reg
PRIV  tem_borda:=.t., op_menu:=VAR_COMPL, l_s:=11, c_s:=20, l_i:=14, c_i:=61, tela_fundo:=SAVESCREEN(0,0,MAXROW(),79)
nucop=1
so_um_reg=(PCOU()>2)
IF !so_um_reg                             // vai receber a variaveis?
 SETCOLOR(drvtittel)
 vr_memo=NOVAPOSI(@l_s,@c_s,@l_i,@c_i)    // pega posicao atual da tela
 CAIXA(mold,l_s,c_s,l_i,c_i)              // monta caixa da tela
 @ l_s,c_s+12 SAY " EMISSŽO DE GUIAS "
 SETCOLOR(drvcortel)
 @ l_s+01,c_s+1 SAY " N£mero:"
ENDI
gnumero=SPAC(7)                                    // N£mero
DO WHILE .t.
 rola_t=.f.
 cod_sos=56
 IF !so_um_reg
  SET KEY K_ALT_F8 TO ROLATELA
  SETCOLOR(drvcortel+","+drvcorget+",,,"+corcampo)
  @ l_s+01 ,c_s+10 GET  gnumero;
                   PICT "@R 99-99999";
                   VALI CRIT("PTAB(gnumero,'GUIAS',1).AND.V00101F9()~N£MERO n„o existe na tabela")
                   AJUDA "Emitir a guia de n£mero?"
                   CMDF8 "VDBF(6,8,20,77,'GUIAS',{'numero','contrato','nome'},1,'R001gf9()')"
                   MOSTRA {"LEFT(TRAN(GUIAS->nome,[@!]),35)", 2 , 5 }

  READ
  SET KEY K_ALT_F8 TO
  IF rola_t
   ROLATELA(.f.)
   LOOP
  ENDI
  IF LASTKEY()=K_ESC                               // se quer cancelar
   RETU                                            // retorna
  ENDI
 ENDI

 #ifdef COM_REDE
  IF !USEARQ("GUIAS",.f.,10,1)                     // se falhou a abertura do arq
   RETU                                            // volta ao menu anterior
  ENDI
 #else
  USEARQ("GUIAS")                                  // abre o dbf e seus indices
 #endi

 PTAB(medico,"MEDICOS",1,.t.)                      // abre arquivo p/ o relacionamento
 SET RELA TO medico INTO MEDICOS                 // relacionamento dos arquivos
 titrel:=criterio:=cpord := ""                     // inicializa variaveis
 titrel:=chv_rela:=chv_1:=chv_2 := ""
 tps:=op_x:=ccop := 1
 arq_=drvporta                                     // porta de saida configurada
 IF !so_um_reg
  IF !opcoes_rel(lin_menu,col_menu,7,11)           // nao quis configurar...
   CLOS ALL                                        // fecha arquivos e
   LOOP                                            // volta ao menu
  ENDI

 #ifdef COM_REDE

  ELSE

   tps=lin_menu

 #endi

 ENDI
 IF tps=2                                          // se vai para arquivo/video
  arq_=ARQGER()                                    // entao pega nome do arquivo
  IF EMPTY(arq_)                                   // se cancelou ou nao informou
   LOOP                                            // retorna
  ENDI
 ELSE
  arq_=drvporta                                    // porta de saida configurada
 ENDI
 SET PRINTER TO (arq_)                             // redireciona saida
 EXIT
ENDD
IF !EMPTY(drvtapg)                                 // existe configuracao de tam pag?
 op_=AT("NNN",drvtapg)                             // se o codigo que altera
 IF op_=0                                          // o tamanho da pagina
  msg="Configura‡„o do tamanho da p gina!"         // foi informado errado
  DBOX(msg,,,,,"ERRO!")                            // avisa
  CLOSE ALL                                        // fecha todos arquivos abertos
  RETU                                             // e cai fora...
 ENDI                                              // codigo para setar/resetar tam pag
 lpp_024=LEFT(drvtapg,op_-1)+"024"+SUBS(drvtapg,op_+3)
 lpp_066=LEFT(drvtapg,op_-1)+"066"+SUBS(drvtapg,op_+3)
ELSE
 lpp_024:=lpp_066 :=""                             // nao ira mudara o tamanho da pag
ENDI
DBOX("[ESC] Interrompe",15,,,NAO_APAGA)
dele_atu:=SET(_SET_DELETED,.t.)                    // os excluidos nao servem...
SET DEVI TO PRIN                                   // inicia a impressao
maxli=17                                           // maximo de linhas no relatorio
IMPCTL(lpp_024)                                    // seta pagina com 24 linhas
SET MARG TO 1                                      // ajusta a margem esquerda
IF tps=2
 IMPCTL("' '+CHR(8)")
ENDI
BEGIN SEQUENCE
 DO WHIL ccop<=nucop				// imprime qde copias pedida
  pg_=1; cl=999
  IF so_um_reg
   GO imp_reg
  ELSE
   INI_ARQ()                                       // acha 1o. reg valido do arquivo
   IF PTAB(PADR(SUBSTR(M->ide_maq,2),4)+[GUI],[IMPPAR],1)
    SEEK ALLTRIM(IMPPAR->docto)
   ENDI
  ENDI
  ccop++                                           // incrementa contador de copias
  ult_imp=0                                        // ultimo reg impresso
  DO WHIL !EOF().AND.(!so_um_reg.OR.imp_reg=RECN())
   #ifdef COM_TUTOR
    IF IN_KEY()=K_ESC                              // se quer cancelar
   #else
    IF INKEY()=K_ESC                               // se quer cancelar
   #endi
    IF canc()                                      // pede confirmacao
     BREAK                                         // confirmou...
    ENDI
   ENDI
   IF (PTAB(PADR(SUBSTR(M->ide_maq,2),4)+[GUI],[IMPPAR],1).AND.ano+numero=LEFT(IMPPAR->docto,7)) .OR. so_um_reg// se atender a condicao...
    REL_CAB(1,.t.)                                 // soma cl/imprime cabecalho
    @ cl,000 SAY "GUIA DE ENCAMINHAMENTO  N§:"
    @ cl,027 SAY ano+'-'+numero+GDV1(ano+numero)   // N£mero
    @ cl,043 SAY IIF(guiapara='C',[Consulta],IIF(guiapara='E',[Exame],IIF(guiapara='I',[Interna‡„o],[     ])))// Guia Para
/*
    IF M->combarra=[S]
     CODBARRAS({{ano+numero+GDV1(ano+numero),4,10,34}},10,6)
    ENDI
*/
    ult_imp=RECNO()                                // ultimo reg impresso
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY "Para:"
    @ cl,008 SAY TRAN(MEDICOS->especialid,"@!")    // Especialidade
    REL_CAB(2)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY "Encaminhado a ....:"
    @ cl,020 SAY ALLTRIM(MEDICOS->nome)+[ (]+ALLTRIM(medico)+[)]// M‚dico
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    IMPAC("Endere‡o..........:",cl,000)
    @ cl,020 SAY MEDICOS->endereco// Endere‡o
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY "Atendimento dia...:"
    @ cl,020 SAY TRAN(emissao_,"@D")               // Emiss„o
    IMPAC("(V lido at‚ 30 dias)",cl,036)
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY "Pessoa a ser atendida:"
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    IMPCTL(drvpenf)
    @ cl,000 SAY TRAN(nome,"@!")                   // Nome
    IMPCTL(drvtenf)
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    IMPAC("Titular.:",cl,000)
    @ cl,015 SAY TRAN([ (]+ALLTRIM(titular)+[ / ]+contrato+[)],"@!")// Titular
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY REPL("-",60)
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    IF !EMPT(MEDICOS->mensagem)
     @ cl,008 SAY TRAN(MEDICOS->mensagem,"@!")      // Mensagem
     REL_CAB(2)                                     // soma cl/imprime cabecalho
    ELSE
     @ cl,000 SAY "Valor Particular:"
     @ cl,018 SAY tran(MEDICOS->valorpart,"@E 99,999,999.99")// Valor Particular
     @ cl,033 SAY "desconto de:"
     IF (MEDICOS->valorpart - valorcon)>0// pode imprimir?
      @ cl,046 SAY TRAN(MEDICOS->valorpart - valorcon,"@E 99,999,999.99")// Valor desconto
     ENDI
     REL_CAB(1)                                     // soma cl/imprime cabecalho
     @ cl,000 SAY "Valor Total.....:"
     @ cl,018 SAY TRAN(valorcon+ valorexa,"@E 99,999,999.99")// Valor total
     @ cl,032 SAY LEFT([(]+LEFT(EXT(valorcon+valorexa),AT('/',EXT(valorcon+valorexa))-1)+[)],40)// Total p/Extenso
     REL_CAB(1)                                     // soma cl/imprime cabecalho
     @ cl,016 SAY SUBSTR([(]+LEFT(EXT(valorcon+valorexa),AT('/',EXT(valorcon+valorexa))-1)+[)],41,54)// Extenso (cont..)
    ENDI
    SKIP                                           // pega proximo registro
    cl=999                                         // forca salto de pagina
   ELSE                                            // se nao atende condicao
    SKIP                                           // pega proximo registro
   ENDI
   exit
  ENDD
  REL_RDP(.t.)                                     // imprime rodape' do relatorio
 ENDD ccop
 EJEC                                              // salta pagina
END SEQUENCE
SET MARG TO                                        // coloca margem esquerda = 0
IMPCTL(lpp_066)                                    // seta pagina com 66 linhas
SET PRINTER TO (drvporta)                          // fecha arquivo gerado (se houver)
SET DEVI TO SCRE                                   // direciona saida p/ video
IF tps=2                                           // se vai para arquivo/video
 BROWSE_REL(arq_,2,3,MAXROW()-2,78)
ENDI                                               // mostra o arquivo gravado
GRELA(7)                                           // grava variacao do relatorio
SELE GUIAS                                         // salta pagina
SET RELA TO                                        // retira os relacionamentos
SET(_SET_DELETED,dele_atu)                         // os excluidos serao vistos
IF so_um_reg
 POINTER_DBF(sit_dbf)
ENDI
RETU

STATIC PROC REL_RDP(volta_reg)                     // rodape'
LOCAL reg_atual:=RECNO()
IF volta_reg
 GO ult_imp                                        // ajusta reg p/ imp de campos no rodape'
ENDI
@ 18,000 SAY "" //chr(15)                               // comprime
IMPCTL(drvpcom)
/*
@ 18,002 SAY [IMPORTANTE:- Esta guia tem a finalidade principal de encaminhamento em consultas e exames,]// Mensagem 1
@ 19,002 SAY [N„o dando direito a cirurgias, interna‡”es, medicamentos entre outros.]// Mensagem 2
@ 20,002 SAY [ - Esta guia tem validade de 30 dias ap¢s a emiss„o]// Mensagem 3
@ 21,002 SAY [ - Esta guia s¢ ter  validade com o carimbo e assinatura do respons vel pela emiss„o.]// Mensagem 4
@ 22,000 SAY "" //chr(18)                               // normal
*/


@ 19,001 SAY replicate('- ',30)                    // traco
IMPCTL(drvtcom)
IF volta_reg
 GO reg_atual                                      // retorna reg a posicao original
ENDI
RETU

STATIC PROC REL_CAB(qt, volta_reg)                 // cabecalho do relatorio
volta_reg=IF(volta_reg=NIL,.f.,volta_reg)
IF qt>0                                            // se parametro maior que 0
 cl=cl+qt                                          // soma no contador de linhas
ENDI
IF cl>maxli .OR. qt=0                              // quebra de pagina
 IF pg_>1
  REL_RDP(volta_reg)                               // imprime rodape' do relatorio
 ENDI
 IMPCTL(drvpcom)

 IMPCTL(drvpenf)
 @ 0,000 SAY LEFT(M->setup1,38)               // Setup1
 IMPCTL(drvtenf)
// @ 1,000 SAY M->defconv                            // Defconv
 @ 2,000 SAY M->setup2                             // setup2
 @ 3,000 SAY M->setup3                             // Setup3
 @ 4,000 SAY REPL("-",60)
 cl=qt+4 ; pg_++
ENDI
RETU

* \\ Final de CON_R001.PRG
FUNC R001GF9
RETURN ano+numeroprocedure v02001f9
/*
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
 \ Empresa.: PresServ Inform tica-Limeira (019)452.6623
 \ Programa: V02001F9.PRG
 \ Data....: 26-05-97
 \ Sistema.: Administradora - RECEP€„O
 \ Funcao..: Pr‚-valida‡„o da variavel RPROC, relaotiro ADM_R020
 \ Analista: Ademilson Pedro Bom
 \ Criacao.: Programado manualmente pelo analista
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/

#include "adrbig.ch"    // inicializa constantes manifestas

RETU (AFUNER->processo+AFUNER->proc2+AFUNER->filial+AFUNER->categ)// <- deve retornar um valor L¢GICO

* \\ Final de V02001F9.PRG
€	 PAR_ADM\–ú  PAR_ADMCODEPAR_TELACODEPAR_GETSCODEPAR_GET1CODEC_ETEXTENDCODE	_SYMSTARTSYMSTARTSYMBOLSSYMBOLS_SYMENDSYMENDNULLBEGDATA_DATADATA_SYMPBDATA_SYMPDATA_SYMPEDATA_CONSTCONST_MSGMSG_BEGBSSBEGBSS_BSSBSS_ENDBSSENDBSSDGROUPL˜ @AØ˜ @hª˜ @žn˜ @;	Ì˜ H  
˜ h  ß˜ `ðð˜ h  ×˜ h  Ó˜ H  ï˜ H  ë˜ H ß˜ H  €
 GUI_07F9D–Ñ  GUI_07F9CODEC_ETEXTENDCODE	_SYMSTARTSYMSTARTSYMBOLSSYMBOLS_SYMENDSYMENDNULLBEGDATA_DATADATA_SYMPBDATA_SYMPDATA_SYMPEDATA_CONSTCONST_MSGMSG_BEGBSSBEGBSS_BSSBSS_ENDBSSENDBSSDGROUP˜ @a¶˜ H  ˜ h  ë˜ `	^˜ h  
ã˜ h  ß˜ H  û˜ H  ÷˜ H ë˜ H  ï˜ H  ë˜ (  ˜ H  GAS-Pro v4.0
003035012078001001001001004000176001
[Ÿ]
[Ÿ]
 39 
 0 









003




































-1 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
pgrupo
C
V
!!
 2 
 2 
 0 
 0 
 0 
Grupo






 0 
 0 


p_filial
C
E
@!
 2 
 2 
 0 
 0 
 0 
C¢digo






 0 
 0 


pcontrato
C
V
999999
 6 
 6 
 0 
 0 
 0 
Codigo






 0 
 0 


pgrau
C
V
9
 1 
 1 
 0 
 0 
 0 
Inscr.






 0 
 0 


pseq
N
V
99
 2 
 2 
 0 
 0 
 0 
Seq






 0 
 0 


pverpag
C
I
!
 1 
 1 
 0 
 0 
 0 
Verificar Pagas?






 0 
 0 


preplanc
C
I
!
 1 
 1 
 0 
 0 
 0 
Repetir lan‡amento?






 0 
 0 


lastcodigo
C
I
999999
 6 
 6 
 0 
 0 
 0 
Maior Contrato






 0 
 0 


nrcanc
N
V
999999
 6 
 6 
 0 
 0 
 0 
N£mero






 0 
 0 


nrreint
N
V
999999
 6 
 6 
 0 
 0 
 0 
Nrreint






 0 
 0 


contarec
C
E
@!
 5 
 5 
 0 
 0 
 0 
Conta Recepcao






 0 
 0 


contapag
C
E
@!
 5 
 5 
 0 
 0 
 0 
Conta Pagamento






 0 
 0 


histrccar
C
E
999
 3 
 3 
 0 
 0 
 0 
Hist¢rico






 0 
 0 


histrcfcc
C
E
999
 3 
 3 
 0 
 0 
 0 
Hist¢rico






 0 
 0 


histrcrec
C
E
999
 3 
 3 
 0 
 0 
 0 
Hist¢rico






 0 
 0 


histpg
C
E
999
 3 
 3 
 0 
 0 
 0 
Hist¢rico






 0 
 0 


nrauxrec
C
E
@R 99-999999
 8 
 9 
 0 
 0 
 0 
N§ Recibo






 0 
 0 


mcodigo
C
E
999999
 6 
 6 
 0 
 0 
 0 
Codigo






 0 
 0 


mtipo
C
E
!
 1 
 1 
 0 
 0 
 0 
Tipo






 0 
 0 


mcirc
C
E
999
 3 
 3 
 0 
 0 
 0 
Circular






 0 
 0 


mgrupvip
C
E
!!
 2 
 2 
 0 
 0 
 0 
Grup






 0 
 0 


combarra
C
E
!
 1 
 1 
 0 
 0 
 0 
Combarra






 0 
 0 


cinscr
C
E
!
 1 
 1 
 0 
 0 
 0 
Com Inscritos






 0 
 0 


comfalec
C
E
!
 1 
 1 
 0 
 0 
 0 
Com Falecido






 0 
 0 


mproc1
C
I
99999
 5 
 5 
 0 
 0 
 0 
Processo






 0 
 0 


mproc2
C
I
99
 2 
 2 
 0 
 0 
 0 
Ano






 0 
 0 


mproc3
C
I
!!
 2 
 2 
 0 
 0 
 0 
Mproc3






 0 
 0 


impnrrec
C
I
99999
 5 
 5 
 0 
 0 
 0 
N£mero






 0 
 0 


procimp
C
I
@R 99999/99/!!
 9 
 11 
 0 
 0 
 0 
Procimp






 0 
 0 


pvalor
N
I
@E 999,999.99
 9 
 10 
 0 
 0 
 2 
Valor






 0 
 0 


pcob
C
I
!!!
 3 
 3 
 0 
 0 
 0 
Cobrador






 0 
 0 


mmesref
C
I
@R 99/99
 4 
 5 
 0 
 0 
 0 
Mˆs Ref.






 0 
 0 


pnumfcc
C
I
 
 8 
 8 
 0 
 0 
 0 
Pnumfcc






 0 
 0 


p_cidade
C
E
@!
 25 
 25 
 0 
 0 
 0 
Munic¡pio






 0 
 0 


p_recp
C
E
!
 1 
 1 
 0 
 0 
 0 
Recibo Padr„o






 0 
 0 


setup1
C
E
 
 40 
 40 
 0 
 0 
 0 
Ident1






 0 
 0 


cgcsetup
C
E
@R 99.999.999/9999-99
 14 
 18 
 0 
 0 
 0 
CGC






 0 
 0 


setup2
C
E
 
 50 
 50 
 0 
 0 
 0 
Ident2






 0 
 0 


setup3
C
E
 
 50 
 50 
 0 
 0 
 0 
Setup3






 0 
 0 


 10 
Nome da empresa
nemp

 0 
 0 
 44 

T¡tulo aplica‡„o
nsis

 0 
 0 
 25 

Data do sistema
DATE()

 0 
 0 
 10 

Nome do mˆs
NMES(DATE())

 0 
 0 
 8 

Dia da semana
NSEM(DATE())

 0 
 0 
 7 

Diret¢rio atual
LEFT(drvdbf,23)

 0 
 0 
 23 

Nome do usu rio
PADR(usuario,15)

 0 
 0 
 15 

Obs do usu rio
PADR(obs_usuario,15)

 0 
 0 
 15 

Rel¢gio hh:mm
LEFT(TIME(),5)

 0 
 0 
 5 

Rel¢gio hh:mm:ss
LEFT(TIME(),8)

 0 
 0 
 8 

 0 
 0 
 0 
 0 
procedure adr_func
/*
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
 \ Empresa.: PresServ Inform tica - Limeira (019)452.6623
 \ Programa: ADR_FUNC.PRG
 \ Data....: 29-01-04
 \ Sistema.: Administradora - RECEP€„O
 \ Funcao..: Fun‡”es auxiliares
 \ Analista: Ademilson Pedro Bom
 \ Criacao.: GAS-Pro v4.0o
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/

#include "adrbig.ch"    // inicializa constantes manifestas

/*
   Sintaxe: PTAB( <ExpC1>, <ExpC2> [,ExpN] [,ExpL] )
   Funcao.: Executa pesquisa em tabelas
              ExpC1 = chave de pesquisa
              ExpC2 = arquivo alvo
              ExpN  = numero do indice associado a ExpC2
              ExpL  = se .t. deixa na ordem do indice do parametro
  
   Retorna: .t. se o registro existe
*/
FUNC PTAB(ch_,db_,or_dem,fix_ind_)
LOCAL ar_:=SELECT(), in_, sem_dbf:=ALIAS(), achou, del_a:=SET(_SET_DELETED,.f.), reg_
or_dem=IF(or_dem=NIL,1,or_dem)
fix_ind_=IF(fix_ind_=NIL,.f.,fix_ind_)
IF !USEARQ(db_)            // tenta abrir DBF e seus indices
 RETU (.f.)                // retorna .f. se nao conseguiu
ENDI
in_=INDEXORD()             // salva ordem atual
DBSETORDER(or_dem)         // seta nova ordem dos indices
SEEK ch_                   // procura o registro
achou=.F.                  // flag se achou
IF FOUND()                 // achou... Verif todos da mesma chave
 reg_=RECNO()              // salva registro atual
 DO WHILE !EOF() .AND. &(INDEXKEY(0))=ch_
  IF !DELE()               // este nao esta excluido..
   EXIT                    // cai fora
  ENDI
  SKIP                     // verifica o proximo
 END
 achou=(&(INDEXKEY(0))=ch_) // se for mesma chave entao achou
 IF !achou                 // se nao achou
  GO reg_                  // volta para o reg excluido
 ENDI
ELSE
 IF !EOF()                 // se nao for final do arquivo
  GO BOTT                  // vamos forcar
  SKIP
 ENDI
ENDI
IF !fix_ind_               // se nao quer deixar na ordem da pesquisa
 DBSETORDER(in_)        // retorna ordem original
ENDI
IF EMPTY(sem_dbf)          // se area anterior estiver vaga
 SELE 0                    //  seleciona proxima area vaga
ELSE                       // senao
 SELE (ar_)                //  seleciona area anterior
ENDI
SET(_SET_DELETED,del_a)    // retorna a visibilidade dos excluidos
RETU achou

/*
   Sintaxe: USEARQ( <ExpC> [,ExpL1] [,ExpN1], [,ExpN2] [,ExpL2] )
   Funcao.: Abre arquivo de dados e seus ¡ndices associados
              ExpC  = nome do arquivo
              ExpL1 = .t. abre modo exclusivo
              ExpN1 = num de vezes que sera tentada a abertura
              ExpN2 = tempo em segundos entre as tentativas de abertura
              ExpL2 = .t. abre associando os ntx
   Retorna: .t. se abriu o arquivo
*/
FUNC USEARQ(db_,use_ex,n_tent,t_tent,com_ntx)
LOCAL op_sis, qt_ind, p_, drv_dbf, p_sempre, v_r, msg,;
      ind01, ind02, ind03, ind04
n_tent=IF(n_tent=NIL,0,n_tent)
t_tent=IF(t_tent=NIL,1,t_tent)
com_ntx=IF(com_ntx=NIL,.t.,com_ntx)
use_ex=IF(use_ex=NIL,.f.,use_ex)
p_sempre=(n_tent=0)
n_ant=n_tent
v_r=.f.
op_sis=EVAL(qualsis,db_)                   // obtem subscricao do DBF no vetor Sistema
IF op_sis>0                                // tem drives
 drv_dbf=sistema[op_sis,O_ARQUI,O_DIR_DBF] // drive de dados
 drv_ntx=sistema[op_sis,O_ARQUI,O_DIR_NTX] // drive dos indices
ELSE                                       // nao tem drives, pega default
 drv_dbf=drvdbf                            // drive de dados
 drv_ntx=drvntx                            // drive dos indices
ENDI
IF "\" $ db_                               // verifica se passou diretorio + arquivo
 p_=RAT("\",db_)
 drv_dbf=LEFT(db_,p_)                      // pega diretorio passado e
 db_=SUBS(db_,p_+1)                        // o nome do arquivo
ENDI
IF EMPTY(SELECT(db_))                      // o arquivo nao esta' em uso, vamos abri-lo...
 db_f=drv_dbf + db_
 SELE 0                                    // seleciona proxima area livre

 #ifdef COM_REDE
  msgt="OUTRO USURIO ACESSANDO|O ARQUIVO"
  DO WHIL n_tent>=0 .OR. p_sempre          // tenta abrir o aruivo n vezes ou p/ sempre
   IF use_ex                               // tenta abrir com exclusividade
    USE (db_f) EXCLUSIVE
   ELSE                                    // tenta abrir compartilhado
    USE (db_f) SHARED
   ENDI
   IF ! NETERR()                           // abriu sem problemas
    v_r=.t.
    EXIT
   ENDI
   DBOX("Tentando abrir|"+;                // avisa usuario, espera n_tent
        IF(p_sempre,"(NŽO","(ESC")+;       // segundos para tentar novamente
        " cancela)",15,,t_tent,,msgt)
   n_tent-=t_tent
   IF !p_sempre .AND. LASTKEY()=K_ESC      // se nao for para sempre e quer
    EXIT                                   // cancelar, nao tenta abrir mais
   ENDI
  ENDD
  CLEA TYPEAHEAD                           // limpa o buffer do teclado
  IF ! v_r                                 // se nao conseguiu abrir o arquivo
   RETU (.f.)                              // retorna falso
  ENDI
 #else
  USE (db_f)                               // abre o arquivo
 #endi

 IF com_ntx                                // abre arquivo com os indices
  IF op_sis=0                              // se o arquivo e' externo ao sistema...
   v_r=AT(".",db_)                         //  tira extensao do arquivo
   n_t_x=IF(v_r>0,LEFT(db_,v_r-1),db_)     //  caso exista
   nt_x=drv_dbf+LEFT(n_t_x,7)+"1"          //  verifica se existe arquivo
   IF FILE(nt_x+EXTENSAO())                //  se existir indice com nome xxx1.ntx,
    SET INDE TO (nt_x)                     //   vamos usa-lo
    DBSETORDER(1)
   ELSE                                    //  se nao procura
    nt_x=drv_dbf+LEFT(n_t_x,7)             //  indice com
    IF FILE(nt_x+EXTENSAO())               //  nome xxx.ntx, usa
     SET INDE TO (nt_x)
     DBSETORDER(1)
    ENDI
   ENDI
  ELSEIF LEN(sistema[op_sis,O_INDIC])>0    // senao, abre indices segundo vetor sistema
   qt_ind=LEN(sistema[op_sis,O_INDIC])
   ind01=sistema[op_sis,O_ARQUI,O_DIR_NTX]+sistema[op_sis,O_INDIC,1]
   IF qt_ind=1
    SET INDE TO (ind01)
   ELSE
    ind02=sistema[op_sis,O_ARQUI,O_DIR_NTX]+sistema[op_sis,O_INDIC,2]
    IF qt_ind=2
     SET INDE TO (ind01), (ind02)
    ELSE
     ind03=sistema[op_sis,O_ARQUI,O_DIR_NTX]+sistema[op_sis,O_INDIC,3]
     IF qt_ind=3
      SET INDE TO (ind01), (ind02), (ind03)
     ELSE
      ind04=sistema[op_sis,O_ARQUI,O_DIR_NTX]+sistema[op_sis,O_INDIC,4]
      IF qt_ind=4
       SET INDE TO (ind01), (ind02), (ind03), (ind04)
      ENDI
     ENDI
    ENDI
   ENDI
   DBSETORDER(1)
  ENDI
 ENDI
ELSE
 SELE SELECT(db_)                          // arquivo ja' estava aberto
ENDI
RETU .t.                                   // deu tudo certo...

/*
   Sintaxe: CRIT( <ExpC1> <,ExpN> [,ExpC2] )
   Funcao.: Executa validacao de campos/ mostra formulas na tela
              ExpC1 = expressao de validacao e a mensagem a ser mostrada
                      separados separadas pelo caracter "~".
              ExpN  = linha onde sera mostrada a mensagem
              ExpC2 = formulas a serem mostradas na tela. ("nn|nn|nn|...",
                      "nn"=num das f¢rmulas especificadas no vetor "sistema"
   Retorna: .t. se critica ok
*/
FUNC CRIT(msgc,li,form_)
LOCAL cond, msg, flag:=.t., no_gets, i_
PRIV  l, c
no_gets=(RIGHT(PROCNAME(1),5)="_GETS")        // flg se nao esta consultando
IF !EMPT(msgc) .AND. !("V"==msgc) .AND. !("I"==msgc)
 li=IF(li=NIL.OR.li>MAXROW()-5,MAXROW()-5,li) // ajusta linha da mensagem
 msg =SUBS(msgc,AT("~",msgc)+1)               // mensagem a mostrar
 cond=LEFT(msgc,AT("~",msgc)-1)               // condicao de validacao
 IF !(&cond.)                                 // se condicao nao satisfeita,
  IF !no_gets                                 // se tem msg para mostrar
   IF LEN(TRIM(msg))>0                        // se tem msg para mostrar
    ALERTA()                                  // beep, beep, beep
    DBOX(msg,li,,,,"ATEN€ŽO! "+usuario)       // avisa ao usuario
   ENDI
   flag=.f.                                   //  retornando falso
  ENDI
 ENDI
ENDI
IF flag .AND. form_!=NIL                      // validacao ok e tem formulas
 DO WHIL LEN(form_)>0                         // mostraremos todas ...
  i_=VAL(PARSE(@form_,"|"))                   // pega subscricao da formula
  IMP_FORM(sistema[op_sis,O_FORMULA,i_])      // imprime a formula
 ENDD
ENDI
RETU flag                                     // retorna ok se validacao ok

/*
   Sintaxe: EDITA( <N1> <,N2> <,N3> <,N4> <,ExpL|ExpC1> <,Arr1> <,Arr2> <,ExpC2> <,ExpC3> <,ExpC4> <,ExpL1> )
   Funcao.: Apresenta a tela de consulta no objeto "TBrowse" com diversos recursos.
              N1,N2,N3,N4 = coordenadas da janela de consulta
               ExpL|ExpC1 = rotinas nao acessadas
                     Arr1 = arranjo de campos a apresentar na janela
                     Arr2 = titulos dos campos de Arr1
                    ExpC2 = filtro inicial
                    ExpC3 = ordem inicial
                    ExpC4 = condicao para marcar o registros
                    ExpL1 = .t.=letras pesq - .f.=letras fazem acao
   Retorna: NIL
*/
FUNC EDITA(li_supp,co_supp,li_infp,co_infp,mo_difp,coluna_cp,coluna_tit,cr_,ord_,cdmr_)
LOCAL op_sy_:=op_sis, cor_orig, i_, t_f8, dele_atu:=SET(_SET_DELETED)
PRIV cp_:="", cond_p:="", tit_cons:={"",""}, db_1rela:="", cpord, qual_prg,;
     db_2rela:="", cpord:="", criterio:="", ind_ord:=1, ind_rela:=1, chvpesq:="",;
     grava_db:=.f., op_db:=1, volta_db, ch_tecl:="05042419", op_menu:=PROJECOES,;
     di_tecl:="24262527", br_reg_ori, br_reg_out, brw_tempo, brw_ant:=brw,;
     col_cp:=coluna_cp,col_tit:=coluna_tit, li_sup:=li_supp, vr_edita, cr_ini:=cr_,;
     li_inf:=li_infp, co_sup:=co_supp, co_inf:=co_infp, posi_cur, cmr_:=cdmr_,;
     mo_dif:=mo_difp, hlp_cod:=cod_sos, dir_cur:=3, chv_rela:=""
IF ! USED()                          // se nao existir arquivo
 RETU .f.                            // aberto, cai fora
ENDI
aux:=[]
qual_prg=PROCNAME(1)                 // nome do prg que chamou a funcao
cr_ini=IF(cr_ini=NIL,"",cr_ini)      // filtro inicial nao informado
cmr_=IF(cmr_=NIL,"1=2",cmr_)         // tem condicao de marcar registros?
cpord=IF(ord_=NIL,"",ord_)           // tem ordem inicial?
FOR i_=1 TO FCOU()                   // declara privados todos os
 msg=FIELD(i_)                       // campos do arquivo da consulta
 PRIV &msg.
NEXT

#ifdef COM_MOUSE
 IF drvmouse
  DO WHIL MOUSEGET(0,0)!=0           // se qualquer botao do mouse
  ENDD                               // estiver pressionado espera
 ENDI                                // liberacao
#endi

brw=.t.                              // pega posicao atual da tela
vr_edita=NOVAPOSI(@li_sup,@co_sup,@li_inf,@co_inf)
mo_dif=IF(mo_dif=NIL,.t.,mo_dif)     // trata as rotinas
IF TYPE("mo_dif")="L"                // que nao poderao
 IF !mo_dif                          // ser acessadas
  mo_dif="DERMG"                     // durante a consulta
 ELSE
  mo_dif=""
 ENDI
ENDI
cor_orig=SETCOLOR()                  // salva cor original
brw_reg=RECN()                       // registro atual
volta_db=.t.
IF LEN(cr_ini)>0                     // tem filtro inicial?
 i_=SELECT()                         // salva area atual
 estr_dbf:=DBSTRUCT()                // pega estrutura do dbf aberto
 i=INDEXORD()                        // indice atual
 IF i>LEN(sistema[EVAL(qualsis,ALIAS()),O_ORDEM]) // se esta usando ind tmp
  i=1                                // pega o primeiro
 ENDI
 x_=sistema[EVAL(qualsis,ALIAS()),O_ORDEM,i] // campos do indice
 SELE 0                              // vai para primeira area vazia
 p=1                                 // separa filtro inicial para
 DO WHILE .t.                        // verificar se tem congruencia com o indice
  i=AT("=",SUBS(cr_ini,p))           // campo do filtro
  IF i=0                             // epa! condicao invalida
   chv_rela=""                       // cai fora
   EXIT
  ENDI                               // campo do filtro verifica se ele e' um
  cp_=ALLTRIM(SUBS(cr_ini,p,i-1))    // nome valido e se o indice e formado por ele
  IF AT("+",cp_)>0 .OR. AT("(",cp_)>0 .OR. AT(")",cp_)>0 .OR.;
     AT(".",cp_)>0 .OR. AT(",",cp_)>0 .OR. AT(" ",cp_)>0 .OR.;
     LEN(x_)=0 .OR. !(UPPER(cp_)==UPPER(estr_dbf[VAL(LEFT(x_,2)),1]))
   chv_rela=""                       // campo ilegal
   EXIT                              // cai fora
  ENDI
  x_=SUBS(x_,3)                      // proximo campo do indice
  p+=i
  i=AT(".AND.",SUBS(UPPER(cr_ini),p))// pode ter mais de um campo filtrando
  IF i=0                             // nao tem
   i=LEN(cr_ini)-p+2                 // pega todo o tamanho do filtro
  ENDI
  cond_p=ALLTRIM(SUBS(cr_ini,p,i-1)) // segundo opereando e' valido...
  IF AT("+",cond_p)>0 .OR. AT("(",cond_p)>0 .OR. AT(")",cond_p)>0 .OR.;
     AT(".",cond_p)>0 .OR. AT(",",cond_p)>0 .OR. AT(" ",cond_p)>0
   chv_rela=""
   EXIT                              // se nao cai fora
  ENDI
  p+=i+4                             // ajusta proximo campo
  &cp_.=&cond_p.                     // faz variavel=segundo operando
  IF LEN(chv_rela)>0                 // se ja tem relacionamento
   chv_rela=chv_rela+"+"             // concatenda com um "+"
  ENDI
  chv_rela+="M->"+cp_                // finge que e dbf relacionado
  IF p>=LEN(cr_ini)                  // se nao tem mais filtro
   EXIT                              // cai fora...
  ENDI
 ENDD
 SELE (i_)
 cp_:=cond_p := ""                   // inicializa variaveis
ENDI
IF LEN(cr_ini)>0 .AND. LEN(chv_rela)=0 // se tem filtro e nao consegui relacionar
 criterio=cr_ini                       // vamos preparar para indexar
ENDI

#ifdef COM_REDE
 brw_tempo=drvtempo                  // tempo de "refresh"
#endi

t_f8=SETKEY(K_ALT_F8,NIL)            // salva/reseta tecla ALT-F8
BRWFUNC(PROCNAME(1)!="VDBF")         // funcoes auxiliares
SETKEY(K_ALT_F8,t_f8)                // seta tecla ALT-F8

#ifdef COM_REDE
 IF brw_tempo!=drvtempo              // se alterou o tempo de "refresh"
  SAVE TO (arqconf) ALL LIKE drv*    // salva em disco
 ENDI
#endi

SETCOLOR(cor_orig)                   // restaura cor original
op_sis = op_sy_
SET KEY K_TAB TO                     // resta TAB
brw=brw_ant
SET(_SET_DELETED,dele_atu)           // SET DELE=anterior
RETU .t.

/*
   Sintaxe: MOV_PTR( <ExpN> )
   Funcao.: Move o ponteiro em arquivo relacionado e ou filtrado
              ExpN  = numero de registros para mover o ponteiro
   Retorna: Num de registros pulados
*/
FUNC MOV_PTR(a_pular)
LOCAL ja_pulado := 0, chv_
IF a_pular = 0                             // nao vai pular registros
 SKIP 0
ELSE                                       // vai pular registros...
 chv_=&("{||"+INDEXKEY(0)+"=["+;           // so servem os registro que
      IF(EMPT(criterio),"","T")+chv_1+"]}")// atendao ao filtro/relacao
 DO WHILE !EOF() .AND. !BOF() .AND.;       // pula qtos reg's forao pedidos
    a_pular != ja_pulado .AND. EVAL(chv_)  // ate eof ou fora filtro/relacao
  IF a_pular > 0                           // pulando para frente
   SKIP
   ja_pulado++                             // conta quando foroa pulados
  ELSE                                     // pulando para traz
   SKIP -1
   ja_pulado--                             // menos um pulado
  ENDI
 ENDD
 IF !EVAL(chv_) .OR. EOF() .OR. BOF()      // reg nao atende filtro/relacao
  IF a_pular > 0                           // esta pulando para frente
   FIM_ARQ()                               // acha o fim do arquivo
   ja_pulado--                             // decrementa um na qde de reg pulados
  ELSE                                     // pulando para traz
   INI_ARQ()                               // acha o inicio do arquivo
   ja_pulado++                             // incrementa um na qde de reg pulados
  ENDI
 ENDI
ENDI
RETU ja_pulado                             // retorna a qde exata de reg pulados

/*
   Sintaxe: CABBRW()
   Funcao.: Monta cabecalho da consulta
   Retorna: NIL
*/
STATIC FUNC CABBRW
br_w:headsep:=chr(205)+chr(209)+chr(205)  // separador do cabecalho (ÍÑÍ)
br_w:colsep:=" "+chr(179)+" "             // separador das colunas  ( ³ )
op_sis=EVAL(qualsis,ALIAS())              // subscricao do arquivo atual
br_w:cargo:={"","","",INDEXORD()}         // salva alguns parametros da consulta
RETU NIL

/*
   Sintaxe: MONTABRW()
   Funcao.: Monta janela de visualiza‡„o da consulta
   Retorna: NIL
*/
STATIC FUNC MONTABRW()
LOCAL id_carg:={}
op_sis   = EVAL(qualsis,ALIAS())       // subscricao do arquivo atual
arq_cor  = LEFT(ALIAS(),3)             // prefixo do arquivo
id_carg  = br_w:cargo                  // variaveis da consulta
criterio = id_carg[1]                  // filtro
cpord    = id_carg[2]                  // ordenacao
chv_rela = id_carg[3]                  // relacao
ind_ord  = id_carg[4]                  // indice atual
cmr_     = id_carg[5]                  // marcacao de registros
DBSETORDER(ind_ord)                    // escolhe o indice atual
PEGACHV2()                             // pega final do relaciomento
SETCOLOR(drvcorbox)                    // cor da janela selecionada

#ifdef COM_MOUSE
 IF drvmouse                           // define area de atuacao do mouse
  MOUSEBOX(br_w:ntop-1,br_w:nleft-1,br_w:nbottom+1,br_w:nright+1)
 ENDI
#endi


/*
   Monta janela de consulta e mensagens de status e teclas disponiveis
   nas suas bordas
*/
CAIXA(mold+CHR(0),br_w:ntop-2, br_w:nleft-1, br_w:nbottom+1, br_w:nright+1)
@ br_w:ntop-2,br_w:nleft SAY IF(EMPTY(criterio),"{Qde="+LTRIM(STR(RECC(),10))+"}",REPL(SUBS(mold,2,1),11))
msg="TAB [ ],F10"+IF(SETKEY(K_F8)=NIL,"",",F8")+IF((M->v_out.AND.tem_t).OR.!M->v_out,",F9","")

#ifdef COM_MOUSE
 IF drvmouse                           // botoes do mouse
  msg+=" "+CHR(174)+" "+CHR(175)+" "+CHR(30)+" "+CHR(31)+" "+CHR(24)+" "+CHR(26)+" "+CHR(25)+" "+CHR(27)+" "+CHR(18)
 ENDI
#endi

msg=LEFT(msg,br_w:nright-br_w:nleft)
posi_cur=INT((br_w:nright-br_w:nleft-LEN(msg))/2)
@ br_w:nbottom+1,br_w:nleft+posi_cur SAY msg
@ br_w:nbottom+1,br_w:nleft+posi_cur+5 SAY CHR(VAL(SUBS(di_tecl,dir_cur*2-1,2)))
x=br_w:nright-br_w:nleft+1
@ br_w:ntop-1,br_w:nleft SAY PADC(MAIUSC(tit_cons[IF(br_w == br_origem,1,2)]),x,' ')
RETU NIL

/*
   Sintaxe: FORCABRW( <ExpL> )
   Funcao.: Reimprime dados da funcao EDITA()
              ExpL = se .t. reimprime inclusive a moldura.
   Retorna: NIL
*/
STATIC FUNC FORCABRW(imp_cx)
LOCAL id_carg:={}
PRIV op_sis, chv_1, chv_2, criterio, cpord, chv_rela, cmr_, chv_1, chv_2
COMMIT
IF br_outro != NIL               // se a 2a. janela estiver aberta
 TROCA_BRW()                     // troca janela do browse

 #ifdef COM_REDE
  COMMIT                         // forca atualizacao em disco
 #endi

 id_carg = br_w:cargo            // retira da variavel de instancia
 criterio=id_carg[1]             // o filtro que tinha
 cpord=id_carg[2]                // a ordenacao
 chv_rela=id_carg[3]             // a relacao
 ind_ord=id_carg[4]              // indice utilizado
 cmr_=id_carg[5]                 // e a marcacao de registros
 DBSETORDER(ind_ord)
 op_sis=EVAL(qualsis,ALIAS())    // obtem subscricao do DBF no vetor Sistema
 PEGACHV2()                      // pega final do relaciomento
 IF imp_cx                       // reimprime moldura da janela
  SETCOLOR(drvcortna)
  br_w:colorspec := drvcortna+","+INVCOR(drvcortna)+","+drvcorenf+","+drvcorget+","+drvcorhlp
  CAIXA(mold+CHR(0),br_w:ntop-2, br_w:nleft-1, br_w:nbottom+1, br_w:nright+1)
  x=br_w:nright-br_w:nleft+1
  @ br_w:ntop-1,br_w:nleft SAY PADC(MAIUSC(tit_cons[IF(br_w == br_origem,1,2)]),x,' ')
 ENDI
 IF DELE().AND.SET(_SET_DELETED) // registro esta apagado e nao visivel
  MOV_PTR(-1)                    // acha o 1o. reg nao apagado
 ENDI
 br_w:refreshall()               // forca atualizacao da tela nao selecionada
 br_w:forcestable()              // apresenta os dados
 br_w:dehilite()                 // liga barra cursora
 TROCA_BRW()                     // troca janela do browse
ENDI
RETU NIL

/*
   Sintaxe: ABREOUTRO( <ExpN> )
   Funcao.: Abre segunda janela de consulta
              ExpN = subscricao do arquivo dentro vetor "sistema"
   Retorna: .t. se teve sucesso
*/
STATIC FUNC ABREOUTRO(op_s)
LOCAL ar_, c_1, c_2
ar_=UPPER(sistema[op_s,O_ARQUI,O_NOME]) // nome do arquivo da consuta

#ifdef COM_REDE
 IF !USEARQ(ar_,.f.,20,1)               // se nao conseguiu abrir o arquivo
  DBOX(ms_uso,20)                       // avisa
  SELE (m_origem)                       // retorna para o DBF original
  RETU .f.                              // e retorna
 ENDI
#else
 USEARQ(ar_)                            // abre DBF da consulta
#endi

outro_db=ALLTRIM(STR(SELEC(ar_)))       // salva area do arquivo aberto
SELE (m_origem)
M->tp=li_sup+INT((li_inf-li_sup-1)/2)+1 // linha de divisao das janelas
br_reg_ori=RECNO()                      // salva registro do DBF original
br_w:dehilite()                         // apaga barra cursora
br_w:nbottom := M->tp - 2               // final da janela do DBF original
br_w:configure()                        // seta remontagem da janela
c_1=br_w:nleft                          // salva coordenadas da direita
c_2=br_w:nright                         // e da esquerda para a nova janela
SELE (outro_db)                         // novo arquivo
GO TOP                                  // monta browse da nova consulta
br_outro=TBROWSENEW(M->tp+1,c_1,li_inf,c_2)
br_outro:colorspec := drvcorbox+","+INVCOR(drvcorbox)+","+drvcorenf+","+drvcorget+","+drvcorhlp
br_w=br_outro                           // browse atual
CABBRW()                                // monta janela do novo browse
RETU .t.                                // e retorna

/*
   Sintaxe: MOSTRA_RELA()
   Funcao.: Verifica se a janela de baixa esta relacionada e
            se e' necessario mostra os seus registros
   Retorna: .t. se preciso remonta-la
*/
STATIC FUNC MOSTRA_RELA()
LOCAL ok:=.f.
PRIV chv_rela, criterio, cpord, cmr_, chv_1, chv_2, op_sis
IF TYPE("br_outro")="O"                       // tem outra janela aberta?
 id_carg = br_outro:cargo
 IF !EMPT(id_carg[3])                         // a janela esta relacionada?
  criterio = id_carg[1]                       // restabelece o filtro
  cpord    = id_carg[2]                       // ordem e a
  chv_rela = id_carg[3]                       // relacao entre as janelas
  cmr_     = id_carg[5]                       // marcacao de registros
  SELE (outro_db)                             // seleciona dbf da janela
  op_sis=EVAL(qualsis,ALIAS())                // sua subscricao no vetor sistema
  PEGACHV2()                                  // acha o inicio/fim da relacao
  IF chv_1 != &chv_rela .OR. !br_outro:stable // precisa remonta-la?
   INI_ARQ()                                  // acha o inicio da relacao
   br_reg_out = RECNO()                       // salva reg atual
   br_outro:rowpos := 1                       // cursor na 1a. lin do browse
   ok:=.t.                                    // tem que remontar a janela
  ENDI
  SELE (m_origem)                             // seleciona janela superior
 ENDI
ENDI
RETU ok

/*
   Sintaxe: BRWFUNC( [ExpL] )
   Funcao.: Diversas funcoes auxiliares da EDITA()
              ExpL = .t./omitida le consultas gravadas
   Retorna: NIL
*/
STATIC FUNC BRWFUNC(nao_vdbf)
LOCAL br_w1, brw_tela, cri_ant, brw_reg, cp_exp:={}, estr_dbf:={}, tps,;
      tecl_p, l_sup, l_inf, m_od, arqexp, dli_exp, id_carg:={}, q_tela,;
      just_memo, Li:=1, Co:=1, ppp:=0, pp:=0, t, i, l_m, Tp_Sai,t_f8,;
      tit_rel, brw_fundo:=SAVESCREEN(0,0,MAXROW(),79), dele_atu, x_, y_,;
      cmr_ant, getlist:={}, cont_mod, cur_atual, nao_pesq:=.f., ind_ok
PRIV cp_, cp_titu, cp_masc, cp_crit, cp_when, cp_help, cp_cmd, tp_cp, br_w,;
     fg_loc:=.f., volta_db:=.t., arq_cor:=LEFT(ALIAS(),3), br_origem,;
     br_outro:=NIL, m_origem, outro_db:=NIL, chv_1:="", chv_2:="", l_s,;
     c_s, l_i, c_i, db_zoom:=.f., br_arq:="", br_tit:="", _pesq:=drvpesq,;
     st_pesq:="", blk_, blk_a
m_origem = ALLTRIM(STR(SELEC()))
br_origem = TBROWSENEW(li_sup,co_sup,li_inf,co_inf)
br_origem:colorspec := drvcorbox+","+INVCOR(drvcorbox)+","+drvcorenf+","+drvcorget+","+drvcorhlp
br_w = br_origem
CABBRW()                                      // monta cabecalho da consulta
tit_cons[1]=sistema[op_sis,O_MENS]            // titulo da janela
nao_vdbf=IF(nao_vdbf=NIL,.t.,nao_vdbf)        // trata parametro
IF !nao_vdbf                                  // veio do VDBF()
 _pesq=drvpvdbf                               // coloca pesquisa como default
ENDI
IF !LDBEDIT(nao_vdbf)                         // menu de consultas gravadas
 RETU NIL
ENDI
col_cp:=col_tit := NIL
tb = {{K_DOWN,      {||br_w:down()}},;        // vetor contendo as teclas
      {K_UP,        {||br_w:up()}},;          // e suas acoes
      {K_PGDN,      {||br_w:pagedown()}},;
      {K_PGUP,      {||br_w:pageup()}},;
      {K_CTRL_PGUP, {||br_w:gotop()}},;
      {K_CTRL_PGDN, {||br_w:gobottom()}},;
      {K_RIGHT,     {||br_w:right()}},;
      {K_LEFT,      {||br_w:left()}},;
      {K_HOME,      {||br_w:home()}},;
      {K_END,       {||br_w:end()}},;
      {K_CTRL_LEFT, {||br_w:panleft()}},;
      {K_CTRL_RIGHT,{||br_w:panright()}},;
      {K_CTRL_HOME, {||br_w:panhome()}},;
      {K_CTRL_END,  {||br_w:panend()}};
     }
volta_db=.t.
MONTABRW()                                    // inicializa tbrowse
DO WHILE volta_db
 SETCOLOR(drvcorbox)
 SET CURSO OFF                                // apaga cursor da tela
 DO WHILE !br_w:stabilize() .AND. NEXTKEY()=0 // apresenta dados na tela
 ENDD
 x_ = COL() ; y_ = ROW()                      // salva posicao atual do cursor
 READINSERT(.f.)                              // retira o "insert"
 t = SUBS(mold,2,1)
 msg=IF(_pesq,"{*Procura*}",IF(EMPTY(criterio),"{Qde="+LTRIM(STR(RECC(),10))+"}",""))
 @ br_w:ntop-2,br_w:nleft SAY LEFT(msg+REPL(SUBS(mold,2,1),11),11)
 IF br_w:nleft+22<br_w:nright                 // msg no canto superior esquerdo
  @ br_w:ntop-2,br_w:nleft+12 SAY IF(DELE(),"{Exclu¡do}",REPL(t,10))
 ENDI
 IF br_w:nleft+31<br_w:nright                 // msg inicio/fim de arq no centro
  msg=IF(br_w:hittop,"{In¡cio}",IF(br_w:hitbottom,"{Final}"+t,REPL(t,8)))
  @ br_w:ntop-2,br_w:nleft+23 SAY msg
 ENDI
 IF br_w == br_origem .AND. br_w:stable       // esta na janela superior
  IF MOSTRA_RELA()                            // e' preciso refazer janela de baixo
   FORCABRW(.f.)                              // entao vamos la...
  ENDI
 ENDI
 IF LEN(st_pesq)>0                            // se esta pesquisando
  SEPARA(br_w:getcolumn(br_w:colpos):cargo)   // separa nome do campo
  IF LEN(st_pesq) <= br_w:getcolumn(br_w:colpos):width // da p/ imprimir...
   i_=SETCOLOR(drvcorenf)                     // coloca cor enfatizada
   t=1
   l_m=TRAN(&cp_.,cp_masc)                    // conteudo da coluna
   FOR j=1 TO LEN(l_m)                        // ajustando com a mascara
    IF SUBS(st_pesq,t,1)=SUBS(l_m,j,1)        // vamos ver quantos
     t++                                      // caracteres vamos colorir...
     IF t>LEN(st_pesq)                        // chegamos ao fim da pesquisa
      @ y_,x_ SAY LEFT(l_m,j)                 // imprime colorido
      EXIT
     ENDI
    ENDI
   NEXT
   SETCOLOR(i_)                               // volta para cor normal
  ENDI
 ENDI
 cod_sos=hlp_cod

 #ifdef COM_MOUSE
  tecl_p=MOUSETECLA(br_w:ntop-1,br_w:nleft-1,; // aguarda com controle de mouse
                    br_w:nbottom+1,br_w:nright+1,.f.;
         )
  MOUSEGET(@li,@co)                            // salva posicao atual do mouse
  IF tecl_p=CLICK                              // se botao esquerdo foi pressionado
   t=br_w:rowpos; colpos_=br_w:colpos          // salva linha/coluna atual
   br_w:dehilite(); tecl_p=0                   // desliga cursor do browse
   br_w:rowpos:=t+li-y_                        // linha do clique
   FOR i=br_w:rightvisible TO br_w:leftvisible STEP -1
    br_w:dehilite()                            // deliga/liga cursor da coluna para
    br_w:colpos:=i                             // pegar as nova coordenadas do cursor
    br_w:hilite()
    IF COL()-1<=co                             // a coluna do clique e' esta?
     tecl_p=1                                  // flag fim da procura
     EXIT                                      // e sai do FOR...
    ENDI
   NEXT
   IF tecl_p=0 .AND. Br_w:freeze>0             // se ainda nao achou a coluna
    FOR i=br_w:freeze TO 1 STEP -1             // verifica se esta' nas colunas
     br_w:dehilite()                           // congeladas
     br_w:colpos:=i
     br_w:hilite()
     IF COL()-1<=Co                            // achamos a coluna do clique
      EXIT
     ENDI
    NEXT
   ENDI
   IF t=br_w:rowpos .AND. colpos_=br_w:colpos  // clicou duas vezes na mesma
    KEYB CHR(77)                               // coluna entao forca modificacao
   ENDI
   tecl_p=0                                    // nao faz nada
  ENDI
 #else

  #ifdef COM_REDE
   tecl_p=IN_KEY(drvtempo)                    // espera tecla ser digitada
  #else
   tecl_p=IN_KEY(0)                           // espera tecla ser digitada
  #endi

 #endi

 #ifdef COM_REDE
  IF tecl_p=0                                  // nao teclou nada, sai pelo
   br_w:refreshall()                           // tempo de "refresh" entao
   FORCABRW(.f.)                               // forca reimpressao dos dados
   LOOP                                        // na tela e volta
  ENDI
 #endi

 IF SETKEY(tecl_p)!=NIL .AND. tecl_p!=K_F3     // executa funcao associada a
  EVAL(SETKEY(tecl_p))                         // tecla digitada se existir
  tecl_p=0                                     // nao faz mais nada
 ENDI
 SET CURSO ON                                  // acende o cursor
 nm = ASCAN(tb,{|ve_a| tecl_p = ve_a[1]})      // verifica se tecla esta
 IF nm != 0                                    // no vetor de teclas progamadas
  st_pesq := ""                                // limpa pesq por palavra
  IF tb[nm,2]!=NIL                             // em caso afirmativo,
   EVAL(tb[nm,2])                              // executa a funcao definida para
  ENDI                                         // a tecla
 ELSE
  br_w:dehilite()                              // apaga barra cursora
  nao_pesq=.f.                                 // flag - tudo normal
  IF tecl_p=K_F10
   st_pesq := ""                               // limpa pesq por palavra
   SET CURS OFF                                // desliga cursor
   tbmenu="PFDMERVNAIOQL"+IF(fg_loc,"S","")+;
          "GCTJXZB"

   #ifdef COM_REDE
    tbmenu+="+-"                               // teclas de "refresh"
   #endi

   l_m=exrot[op_sis]                           // senhas nao tem rotinas
   l_m=RTRIM(mo_dif+l_m)                       // para serem retiradas
   FOR i=1 TO LEN(l_m)                         // retira rotina que o usuario
    tbmenu=STRTRAN(tbmenu,SUBS(l_m,i,1),"")    // nao pode acessar e monta menu
    tbmenu=STRTRAN(tbmenu,SUBS(l_m,i,1),"")    // nao pode acessar e monta menu
   NEXT                                        // com as rotinas disponiveis
   msg =IF(AT("P",tbmenu)>0,"P. Procura determinado registro  ÿ|","")
   msg+=IF(AT("F",tbmenu)>0,"F. Filtragem (seleciona/ordena)  ÿ|","")
   msg+=IF(AT("D",tbmenu)>0,"D. Digita‡„o - inclui registros  ÿ|","")
   msg+=IF(AT("M",tbmenu)>0,"M. Modifica conte£do do campo    ÿ|","")
   msg+=IF(AT("E",tbmenu)>0,"E. Exclui (marca apagamento)     ÿ|","")
   msg+=IF(AT("R",tbmenu)>0,"R. Recupera (desmarca apagamento)ÿ|","")
   msg+=IF(AT("V",tbmenu)>0,"V. Vˆ todo o registro na tela    ÿ|","")
   msg+=IF(AT("N",tbmenu)>0,"N. Nova coluna                    |","")
   msg+=IF(AT("A",tbmenu)>0,"A. Apaga coluna do cursor        ÿ|","")
   msg+=IF(AT("I",tbmenu)>0,"I. Imprime a consulta            ÿ|","")
   msg+=IF(AT("O",tbmenu)>0,"O. Ordena os registros           ÿ|","")
   msg+=IF(AT("Q",tbmenu)>0,"Q. Quantifica registros          ÿ|","")
   msg+=IF(AT("L",tbmenu)>0,"L. Localiza um registro          ÿ|","")
   msg+=IF(AT("S",tbmenu)>0,"S. Seguinte - localiza seguinte  ÿ|","")
   msg+=IF(AT("G",tbmenu)>0,"G. Global - processa os registrosÿ|","")
   msg+=IF(AT("C",tbmenu)>0,"C. Congela/descongela colunas    ÿ|","")
   msg+=IF(AT("T",tbmenu)>0,"T. Tamanho - muda tamanho coluna ÿ|","")
   msg+=IF(AT("J",tbmenu)>0,"J. "+IF(outro_db=NIL,"Janela - abre uma nova janela ÿ|","Janela - troca de janelas     ÿ|"),"")
   msg+=IF(AT("X",tbmenu)>0,"X. eXporta dados (TXT, SDF, DBF) ÿ|","")
   msg+=IF(AT("Z",tbmenu)>0,"Z. totaliZa coluna (se num‚rica) ÿ|","")
   msg+=IF(AT("B",tbmenu)>0,"B. estaBelece condi‡„o para marcar|","")

   #ifdef COM_REDE
    msg+=IF(AT("+",tbmenu)>0,"+. +5 seg na remontagem da tela  ÿ|","")
    msg+=IF(AT("-",tbmenu)>0,"-. -5 seg na remontagem da tela  ÿ|","")
   #endi

   msg=LEFT(msg,LEN(msg)-1)                     // tira pipe do final da msg
   msgt="OP€™ES   -   F3=Pesquisa|ALT-F10=excluidos, ALT-Z=zoom, ALT-G=grava"
   op_db=DBOX(msg,,,E_MENU,,msgt,,,op_db)       // escolhe a rotina
   IF op_db = 0                                 // cancelou...
    LOOP
   ENDI
   tecl_p = ASC(SUBS(tbmenu,op_db,1))           // pega o ASC
   IF SUBS(tbmenu,op_db,1)="L"                  // se escolheu "localiza", entao ajusta
    op_db++                                     // default para o continua
   ENDI
   SET CURSO ON                                 // acende o cursor
   nao_pesq=.t.                                 // assume acao da opcao escolhida
  ELSEIF tecl_p = K_F9                          // ve outros arquivos
   st_pesq := ""                                // limpa pesq por palavra
   IF !M->v_out                                 // se tem permissao
    l_sup=li_sup; l_inf=li_inf                  // salva coordenadas da janela
    c_sup=co_sup; c_inf=co_inf
    m_od=mo_dif                                 // salva rotinas acessadas e
    br_w1 := br_w                               // o objeto browse atual
    VEOUTROS()                                  // escolhe arquivo a consultar
    br_w := br_w1                               // restaura o browse
    br_w:configure()                            // remonta titulo da colunas
    volta_db=.t.
    li_sup=l_sup; li_inf=l_inf                  // restaura as coordenadas da
    co_sup=c_sup; co_inf=c_inf                  // janela e
    mo_dif=m_od                                 // rotinas acessadas
    br_w:refreshall()                           // refaz os dados na tela
    FORCABRW(.f.)                               // forca browse do 2a. janela (se existir)
    MONTABRW()                                  // remonta as bordas da janela
   ELSEIF tem_t                                 // transfere o campo para o get pendente
    IF nao_vdbf                                 // se nao veio do VDBF()
     SEPARA(br_w:getcolumn(br_w:colpos):cargo)  // separa atrib coluna e transf p/ caracter
     IF tp_cp="D"
      msg=STRTRAN(DTOC(&cp_.),"/")
     ELSE
      msg=TRANSCAMPO(.t.,cp_)
     ENDI
     KEYB ALLTRIM(msg)                          // coloca campo no buffer do teclado
    ENDI
    volta_db=.f.
   ENDI
  ELSEIF tecl_p = K_ALT_F10                     // ALT-F10 esconde e mostra os
   st_pesq := ""                                // limpa pesq por palavra
   SET(_SET_DELETED,!SET(_SET_DELETED))         // registros excluidos na consulta
   IF DELE() .AND. SET(_SET_DELETED)            // registro esta apagado
    MOV_PTR(1)                                  // acha o 1o. reg nao apagado
   ENDI
   br_w:refreshall()                            // remonta os dados do browse
   br_w:forcestable()                           // apresenta os dados
   br_w:refreshcurrent()                        // refaz so' a linha do browse
   FORCABRW(.f.)

  ELSEIF tecl_p = K_F3                          // liga/desliga pesquisa
   _pesq=(!_pesq)                               // troca flag
   cond_p:=st_pesq := ""                        // inicializa var de pesq
   tecl_p=0                                     // nao faz mais nada
   IF nao_vdbf                                  // se nao veio do VDBF()
    drvpesq=_pesq
   ELSE
    drvpvdbf=_pesq
   ENDI
   SAVE TO (arqconf) ALL LIKE drv*              // salva configuracao

  ELSEIF tecl_p = K_ALT_G                       // grava a consulta em arquivo
   st_pesq := ""                                // limpa pesq por palavra
   t=ALIAS()                                    // salva arquivo corrente
   br_w1 := br_w                                // e browse atual
   SELE (m_origem)                              // selecion dbf da janela de cima
   cod_sos=22                                   // novo codigo de help
   db_aqcom=PADR(br_tit,58)                     // default para o titulo a gravar
   ALERTA(2)                                    // solicita o titulo para a consulta
   db_aqcom=DBOX("Identifique-a para grava‡„o. ESC cancela",,,,,"GRAVA CONSULTA",db_aqcom)
   db_aqcom=ALLTRIM(db_aqcom)                   // tira brancos do nome
   IF LASTKEY()!=K_ESC.AND.!EMPT(db_aqcom)      // se nao cancelou...
    pas = "1"                                   // grava paramenetros das duas janelas
    br_w = br_origem                            // vai para janela de cima
    db_outro=IF(outro_db=NIL,"",ALIAS(VAL(outro_db)))
    db_indrela=ind_rela                         // indice utilizado para relacionar
    db_qprg=qual_prg                            // prg chamador
    DO WHILE .t.
     db_&pas.qtdc=br_w:colcount                 // numero de colunas
     FOR i=1 TO db_&pas.qtdc                    // para cada coluna
      tt=RIGHT(STR(100+i,3),2)
      db_&pas.carg&tt.= br_w:getcolumn(i):cargo // (conteudo,mascara,titulo,pre-val,valida,tipo)
      db_&pas.tam&tt. = br_w:getcolumn(i):width // tamanho da coluna
     NEXT
     id_carg = br_w:cargo                       // situacao do browse
     db_&pas.expo=id_carg[2]                    // ordem
     db_&pas.arqf=id_carg[1]                    // filtro
     db_&pas.chvr=id_carg[3]                    // relacionamento, outra janela
     db_&pas.ind_ord=id_carg[4]                 // indice atual
     db_&pas.cmr=id_carg[5]                     // marcacao de registros
     db_&pas.freeze=br_w:freeze                 // coluna congelada
     IF pas = "1" .AND. br_outro != NIL         // tem outra janela aberta?
      pas="2"                                   // salva o mesmo
      SELE (outro_db)                           // para a outra janela
      br_w = br_outro
     ELSE
      EXIT                                      // tudo feito...
     ENDI
    ENDD
    IF br_tit==db_aqcom                         // se for a mesma consulta lida
     aqdbe=br_arq                               // grava no arquivo de mesmo nome
    ELSE                                        // se nao,
     DO WHIL .t.                                // procura um nome para gravar
      hms=TIME()                                // a consulta
      resaq=LEFT(hms,2)+SUBS(hms,4,2)+RIGHT(hms,2)+"."+LEFT(ALIAS(VAL(m_origem)),3)
      aqdbe=drvdbf+"DB"+resaq
      IF ! FILE("&aqdbe.")                      // se achou um
       EXIT                                     // cai fora...
      ENDI
     ENDD
    ENDI
    SAVE ALL LIKE db_* TO (aqdbe)               // salva em disco a consulta
   ENDI
   SELE (t)                                     // volta para a area anterior
   br_w := br_w1                                // e browse atual

  ELSEIF tecl_p = K_ALT_F8                      // ALT-F8 rola a janela
   st_pesq := ""                                // limpa pesq por palavra
   li_sup-=2; co_sup--                          // ajusta coordenadas e
   li_inf++; co_inf++                           // executa a rolagem da janela
   MUDA_PJ(@li_sup,@co_sup,@li_inf,@co_inf,brw_fundo,.t.)
   li_sup+=2; co_sup++                          // reajusta as coordenadas
   li_inf--; co_inf--
   PUBL &vr_edita.:=STR(li_sup,2)+STR(co_sup,2) // publica variaves que contem
   SAVE TO (arqconf) ALL LIKE drv*              // as coordenadas da janela e
   REST FROM (arqconf) ADDI                     // grava em disco
   br_origem:ntop   := li_sup                   // ajusta browse com
   br_origem:nleft  := co_sup                   // as novas coordenadas
   br_origem:nbottom:= li_inf
   br_origem:nright := co_inf
   IF br_outro != NIL                           // se existe outra janela aberta
    M->tp=li_sup+INT((li_inf-li_sup-1)/2)+1     // ajusta as coordenadas dela
    br_origem:nbottom:=M->tp-2                  // tambem
    br_outro:ntop   := M->tp+1
    br_outro:nleft  := co_sup
    br_outro:nbottom:= li_inf
    br_outro:nright := co_inf
    FORCABRW(.f.)                               // reimprime dados na tela
   ENDI
  ENDI
  carac_ = UPPER(CHR(tecl_p))                   // escolheu uma rotina...
  l_m=exrot[op_sis]                             // arq de senhas nao tem restricoes
  IF _pesq .AND. !nao_pesq .AND. tecl_p>31      // que pesquisar....
   IF AT("L",mo_dif+l_m)>0                      // se usuario nao tem permissao
    LOOP                                        // nao deixa executar
   ENDI
   SEPARA(br_w:getcolumn(br_w:colpos):cargo)    // separa atributos da coluna
   brw_tela = SAVESCREEN(0,0,MAXROW(),79)       // salva tela atual
   st_pesq+=carac_                              // contatena letra dig com que ja existe
   IF tp_cp=="C"                                // carater concatena com aspas
    cond_p="LTRIM("+cp_+")='"+st_pesq+"'"
   ELSEIF tp_cp=="N"                            // numerico
    cond_p="LTRIM(STR("+cp_+"))='"+st_pesq+"'"  // tira os brancos da frente
    i=AT(".",cp_masc)
    IF i=0
     i=LEN(cp_masc)+1
     j=0
    ELSE
     j=LEN(cp_masc)-i
    ENDI
    cp_="STR("+cp_+","+LPAD(i-1,2,"0")+","+LPAD(j,2,"0")+")"
   ELSEIF tp_cp=="D"                            // campo data
    cond_p="STRTRAN(DTOC("+cp_+"),'/')='"+st_pesq+"'"  // tranforma para char antes de testar
   ELSE                                         // tipo sem pesquisa...
    cond_p:=st_pesq := ""
   ENDI
   IF LEN(cond_p)>2                             // tem condicao para pesquisa
    ind_ok=0                                    // verifica se tem um indice pela coluna
    IF tp_cp=="N" .OR. tp_cp=="C" .OR. tp_cp=="D"               // no seek vamos aceitar so data ou caracter
     FOR t=1 TO LEN(sistema[op_sis,O_INDIC])    // corre todos os indices do dbf
      IF UPPE(INDEXKEY(t))=UPPE(cp_)            // indice = a coluna
       ind_ok=t                                 // vamos usa'-lo
       EXIT
      ENDI
     NEXT
    ENDI
    x_=IF(EMPT(criterio),"","T")                // tem filtro?
    IF LEN(chv_rela)>0                          // se tem relacao pesq somente nela
     x_=x_+chv_1                                // chave de relacionamento
    ENDI
    brw_reg=RECN()                              // registro atual
    IF ind_ok=0
     IF LEN(st_pesq)=1                          // 1a. vez
      INI_ARQ()                                 // move ponteiro para o inicio do arquivo
      br_w:rowpos=1                             // posicao da barra seletora
      br_w:refreshall()                         // forca atualizacao da tela
      br_w:forcestable()                        // apresenta os dados
     ENDI
     cur_atual=SETCURSOR(0)                     // salva/apaga cursor
     POE_GAUGE("Pesquisando...|ESC interrompe","AGUARDE...","Processados:")
     IF LEN(x_)>0                               // se tem relacao pesq somente nela
      LOCA FOR &cond_p. WHIL IN_KEY()!=K_ESC .AND. POE_GAUGE() .AND. &(INDEXKEY(0))=x_ // tenta localizar registro desejado
     ELSE
      LOCA FOR &cond_p. WHIL IN_KEY()!=K_ESC .AND. POE_GAUGE() // tenta localizar registro desejado
     ENDI
     ind_ok=(FOUND() .AND. IF(LEN(x_)>0,&(INDEXKEY(0))=x_,.t.)) // achou?
    ELSE
     i=ind_ok                                    // salva indice atual
     ind_ok=PTAB(st_pesq,ALIAS(),ind_ok)         // tenta achar...
     IF ind_ok                                   // achou?
      IF IF(LEN(x_)>0,&(INDEXKEY(0))=x_,.t.)=.f. // esta dentro do filtro
       p=INDEXORD()                              // ordem atual
       DBSETORDER(i)                             // seta ordem do indice
       DO WHILE !EOF()                           // verifica se o proximo
        IF &cond_p.                              // esta dentro da condicao
         IF IF(LEN(x_)>0,&(INDEXKEY(p))=x_,.t.)  // e filtro
          ind_ok=.t.                             // tudo ok
          EXIT
         ENDI
        ELSE                                     // nao encontrou
         ind_ok=.f.                              // cai fora
         EXIT
        ENDI
        SKIP
       END
       DBSETORDER(p)         // volta ordem do indice
      ENDI
     ENDI
    ENDI
    IF !ind_ok .AND. LEN(st_pesq)>0             // nao achou?
     ALERTA(1)                                  // aviso sonoro
     st_pesq=LEFT(st_pesq,LEN(st_pesq)-1)       // descarta caracter digitado
     ind_ok=.t.
     GO brw_reg                                 // volta para o registro que estava
    ENDI
    SETCURSOR(cur_atual)                        // retorna o cursor ao normal
    IF !ind_ok.OR.LASTKEY()=K_ESC               // nao achou ou cancelou
     cond_p:=st_pesq := ""                      // limpa variavies
    ENDI
    IF !ind_ok                                  // nao achou...
     br_w:gobottom()                            // acha o ultimo reg do arq
     KEYB CHR(K_PGDN)
    ELSE
     br_w:rowpos = 1
    ENDI
    br_w:configure()                               // forca atualizacao da tela
    RESTSCREEN(0,0,MAXROW(),79,brw_tela)        // restaura tela anterior
   ENDI
   carac_=""
   tecl_p=0
  ELSE
   IF AT(carac_,"ERMG")>0 .AND. (RECC()=0 .OR.; // nao permite alterar um
      IF(EMPTY(criterio),.f.,!&criterio.))      // arquivo vazio ou
    LOOP                                        // fora do filtro
   ENDI
   IF AT(carac_,mo_dif+l_m)>0                   // se usuario nao tem permissao
    LOOP                                        // nao deixa executar
   ENDI
   IF AT(carac_,"DERMGV")>0 .AND.;              // se vai alterar um registro
      LEN(sistema[op_sis,O_CPRELA])>0           // e se e' um filho
    i=.t.                                       // flag - vai relacionar com o pai
    IF br_outro!=NIL .AND. EOF()                // se for janela de baixo e nao tem registros
     IF br_w==br_outro                          // e esta na janela de baixo
      x_=AT("->",sistema[op_sis,O_CPRELA,1])-1  // separador de arquivo->campo
      x_=LEFT(sistema[op_sis,O_CPRELA,1],x_)    // pega o nome do pai
      IF ALIAS(VAL(m_origem))!=x_               // se janela de cima nao for o pai
      ALERTA(2)                                 // nao pode incluir!
        DBOX("Inclus„o n„o permitida!",,,3)     // mensagem ao usuario
       LOOP                                     // e retorna ao browse
      ELSE
       i=.f.                                    // flag - nao vai relacionar com o pai
      ENDI
     ENDI
   ENDI
    IF i                                        // vai relacionar?
     POSIPAI()                                  // abre/posiciona seus pais
    ENDI
   ENDI
  ENDI
  DO CASE

   #ifdef COM_REDE
    CASE (tecl_p=43 .OR. tecl_p=45)             // teclou + ou - para mudar o "refresh"
     DO WHILE .T.
      msg=LTRIM(STR(drvtempo))
      msg=IF(drvtempo=0,"N„o",msg+" seg")       // tempo=0 nao tem "refresh"
      ALERTA(1)
      DBOX(msg,,,25,,"'REFRESH`|(+/-)")         // mostra msg do tempo atual
      IF LASTKEY()=43                           // teclou +, entao
       drvtempo=IF(drvtempo>57,60,drvtempo+5)   // aumenta o tempo em 5 seg
      ELSEIF LASTKEY()=45                       // teclou -, entao
       drvtempo=IF(drvtempo<1,0,drvtempo-5)     // diminui o tempo em 5 seg
      ELSE                                      // teclou algo diferente de + e -
       EXIT                                     // entao aceita refresh atual
      ENDI
     ENDD
   #endi


   CASE tecl_p = K_ENTER                        // teclou o ENTER
    IF nao_vdbf                                 // nao veio do VDBF() o ENTER movimentara'
     KEYB CHR(VAL(SUBS(ch_tecl,dir_cur*2-1,2))) // para onde a SETA (TAB) esta apontando
    ELSE                                        // caso contrario,
     volta_db=.f.                               // retorna falso
    ENDI

   CASE tecl_p = K_TAB                          // teclou o TAB
    dir_cur()                                   // muda direcao do cursor

   CASE tecl_p = K_ALT_Z .AND. !db_zoom         // aumenta o tamanho da janela
    li_sup=3; li_inf=22; co_sup=3; co_inf=77    // coordenadas da janela expandida
    br_origem:nTop   := li_sup                  // passa as novas coordenadas
    br_origem:nbottom:= li_inf                  // para o browse de cima
    br_origem:nleft  := co_sup
    br_origem:nright := co_inf
    IF br_outro != NIL                          // existe a janela de baixo
     M->tp=li_sup+INT((li_inf-li_sup-1)/2)+1    // linha de divisao das janelas
     br_origem:nbottom := M->tp - 2             // final da janela de cima
     br_outro:nTop   := M->tp+1                 // topo da jenela de baixo
     br_outro:nbottom:= li_inf                  // ajusta o resto das
     br_outro:nleft  := co_sup                  // coordenadas
     br_outro:nright := co_inf
    ENDI
    db_zoom:=.t.                                // flag dizendo do zoom
    FORCABRW(.t.)                               // reimprime janela nao ativa
    MONTABRW()                                  // remonta janela

   CASE tecl_p = K_F1                           // teclou F1
    help()                                      // mostra ajuda correspondente

   CASE tecl_p = K_ESC                          // teclou ESC
    volta_db=.f.                                // abandona a consulta

   CASE carac_="A" .AND. br_w:colcount > 1      // apaga consulta se mais de 1 coluna
    ALERTA(2)                                   // pede confirmacao
    msg="Apagar a coluna|Cancelar a opera‡„o"
    cod_sos=1
    op_=DBOX(msg,,,E_MENU,,"COLUNA "+MAIUSC(br_w:getcolumn(br_w:colpos):heading))
    IF op_=1                                    // confirmou...
     br_w:delColumn(br_w:colpos)                // retira a coluna do browse
     grava_db = .t.                             // seta flag de consulta alterada
     br_w:configure()                           // remonta todo browse
    ENDI

   CASE carac_="B"                              // estabelece condicao de marcacao de reg
    cri_ant = criterio                          // salva filtro atual
    cmr_ant = cmr_                              // salva cond de marcacao atual
    FILTRA(.f.)                                 // monta expressao de pesquisa
    cmr_=criterio                               // condicao de marcacao
    criterio = cri_ant                          // retorna filtro atual
    IF EMPTY(cmr_)                              // tirou marcacao
     cmr_="1=2"                                 // nemhum sera marcado
    ENDI
    IF cmr_!=cmr_ant                            // mudou condicao de marcacao
     br_w:cargo := {criterio,cpord,chv_rela,INDEXORD(),cmr_}
     FOR i=1 TO br_w:colcount                   // atualiza as cores das colunas
      br_w:getcolumn(i):colorblock=&("{||IF(DELE(),{3,2},IF("+cmr_+",{5,2},{1,2}))}")
     NEXT
     br_w:refreshall()                          // reapresenta os dados na tela
    ENDI

   CASE carac_="C" .AND.;                       // congela/descongela coluna se
        br_w:colpos-1 != br_w:freeze            // a coluna ja' congelada
    IF br_w:freeze != 0                         // se outra coluna ja' congelada
     br_w:getcolumn(br_w:freeze+1):colsep:=NIL  // retira o marcador da coluna congelada
    ENDI
    br_w:freeze := br_w:colpos - 1              // congela coluna requerida
    IF br_w:freeze != 0                         // se nao descongelou todas colunas
     br_w:getcolumn(br_w:colpos):colsep:=" Û "  // coloca marcador de colunas congeladas
    ENDI
    br_w:configure()                            // remonta todo browse
    grava_db = .t.                              // seta flag de consulta alterada

   CASE carac_="D"                              // inclusao de registros
    dele_atu=SET(_SET_DELETED,!drvvisivel)      // salva DELE() atual,
    br_w1 := br_w                               // browse atual,
    brw_tela = SAVESCREEN(0,0,MAXROW(),79)      // tela atual e o
    in_=INDEXORD()                              // salva indice atual para incluirmos
    DBSETORDER(1)                               // seta 1 indice para incluirmos
    brw=.f.
    Tela_fundo=SAVESCREEN(0,0,MAXROW(),79)      // salva pano de fundo para ALT-F8
    t_f8=SETKEY(K_F8,NIL)                       // salva/reseta tecla F8
    cp_exp:={}                                  // enche vetor com relacoes atuais
    i_=1                                        // pega todas relacoes que existir
    DO WHILE LEN(DBRELATION(i_))>0
     AADD(cp_exp,{DBRELATION(i_),ALIAS(DBRSELECT(i_))}) // adiciona ao vetor temporario
     i_++
    ENDD
    SET RELA TO                                 // retira todas as relacoes
    &arq_cor._incl()                            // inclusao de novos registros de dados
    FOR i_=1 TO LEN(cp_exp)                     // coloca todos as relacoes anteriores
     dli_exp=cp_exp[i_,1]                       // expresao de ligacao
     arqexp=cp_exp[i_,2]                        // dbf de ligacao
     SET RELA ADDI TO &dli_exp. INTO &arqexp.   // recoloca a relacao
    NEXT
    SETKEY(K_F8,t_f8)                           // seta tecla F8
    op_menu=PROJECOES; brw=.t.                  // volta para consulta
    DBSETORDER(in_)                             // retorna ao indice da consulta
    REGINICIO()                                 // verifica se reg esta' no filtro
    RESTSCREEN(0,0,MAXROW(),79,brw_tela)        // restaura a tela,
    SET(_SET_DELETED,dele_atu)                  // DELE() e o
    br_w := br_w1                               // browse anteriores
    br_w:refreshall()                           // reapresenta os dados na tela
    FORCABRW(.f.)                               // forca remontagem da janela relacionada
    MONTABRW()

   CASE carac_="E"                              // exclui registro

    #ifdef COM_REDE
     IF !BLOREG(10,.5)                          // tenta bloquear o arquivo
      LOOP                                      // nao conseguiu...
     ENDI
    #endi

    IF ! DELE()                                 // ja esta excluido?
     IF CONFEXCL()                              // pede confirmacao
      &arq_cor._get1(EXCLUI)                    // exclui registro/processo inverso
      br_w:refreshall()                         // remonta os reg da tela
      FORCABRW(.f.)                             // remonta janela relacionada
     ENDI
    ENDI

    #ifdef COM_REDE
     UNLOCK                                     // libera o registro
    #endi

    IF DELE() .AND.SET(_SET_DELETED)            // se nao que ver excluidos
     MOV_PTR(1)                                 // procura o proximo que
    ENDI                                        // nao esteje excluido

   CASE carac_="F" .OR. carac_="Q"              // filtra/quantifica
    cri_ant = criterio
    IF carac_="F"                               // filtra
     FILTRA(.t.,.t.)                            // escolhe o filtro
     br_w:cargo := {criterio,cpord,chv_rela,INDEXORD(),cmr_}
     br_w:refreshall()                          // refaz toda a tela
     IF cri_ant!=criterio.AND.!EMPTY(criterio)  // se alterou o filtro
      grava_db=.t.                              // seta flag de consulta alterada
     ENDI
    ELSE                                        // quantifica
     FILTRA(.f.)                                // so' monta a expressao
     condq=criterio                             // retorna filtro anterior
     criterio = cri_ant
    ENDI
    brw_reg=RECN()                              // salva registro atual
    IF carac_="Q" .AND. LEN(condq)>2            // continuacao da quantificacao
     brw_tela = SAVESCREEN(0,0,MAXROW(),79)     // da mensagem que esta contando...
     DBOX("Condi‡„o:|"+LEFT(condq,78)+"|| AGUARDE...  Contando. ESC cancela",,,,NAO_APAGA)
     INI_ARQ()                                  // move ponteiro para o inicio do arquivo

     COUN FOR &condq WHIL IN_KEY()!=K_ESC TO qu// conta....

     IF LASTKEY()!=K_ESC                        // nao cancelou entao mostra
      ALERTA(2)                                 // quantos reg foram contados
      DBOX("Existe(m) "+LTRIM(TRAN(qu,"@E 9,999,999"))+" registro(s)|na condi‡„o|"+LEFT(condq,78)+"|*",8)
     ENDI
     RESTSCREEN(0,0,MAXROW(),79,brw_tela)       // restaura a tela anterior e
     GO brw_reg                                 // o registro
    ENDI
    MONTABRW()                                  // remonta janela de visualizacao

   CASE carac_="G"                              // processo glogal
    brw_tela = SAVESCREEN(0,0,MAXROW(),79)      // salva situacao atual
    brw_reg = RECNO()
    GLOBAL()                                    // executa processo
    GO brw_reg                                  // restabelece situacao anterior
    REGINICIO()                                 // verifica se reg esta' no filtro
    br_w:cargo := {criterio,cpord,chv_rela,INDEXORD(),cmr_}
    br_w:refreshall()                           // remonta dados da tela
    RESTSCREEN(0,0,MAXROW(),79,brw_tela)        // restaura tela
    MONTABRW()                                  // remonta janela do browse

   CASE carac_="I"                              // imprime consulta
    IMP_BRW()

   CASE carac_="J" .AND. br_outro != NIL        // troca janela de consulta
    TROCA_BRW()                                 // troca arquivo do browse
    br_w:colorspec := drvcorbox+","+INVCOR(drvcorbox)+","+drvcorenf+","+drvcorget+","+drvcorhlp
    FORCABRW(.t.)                               // troca as cores da janela
    MONTABRW()                                  // remonta dados e a
    br_w:hilite()                               // janela com a nova cor

   CASE carac_="J"                              // abre uma nova janela
    msg=""; op_a=0; db=""
    pp=SETKEY(K_F9,NIL)                         // desliga F9 (consulta outro DBF)
    FOR i=1 TO nss                              // monta menu de DBF disponiveis
     IF sistema[i,O_OUTROS,O_NIVEL]<=nivelop .AND.;
        LEN(sistema[i,O_INDIC])>0
      msg+="|"+sistema[i,O_MENU]
      db+=RIGHT(STR(1000+i),3)
     ENDI
    NEXT
    cod_sos=30
    IF LEN(msg)>1                               // escolhe o DBF da nova janela
     op_a=DBOX(SUBS(msg,2),,,E_MENU,,"BASES DE DADOS")
    ENDI
    IF op_a>0                                   // escolheu...
     op_a=VAL(SUBS(db,op_a*3-2,3))              // acha a sua subscricao
     op_sis_x=op_sis                            // salva subscricao atual
     SETCOLOR(drvcortna)
     IF abreoutro(op_a)                         // e abre a outra janela
      grava_db = .t.                            // flag de consulta alterada
      tit_cons[2]=sistema[op_sis,O_MENS]        // titulo da segunda janela
      IF op_sis_x != op_sis
       op_ind=1                                 // indice 'default`
       qt_ind=LEN(sistema[op_sis,O_INDIC])      // qde de indices do arquivo
       chv=ATAIL(sistema[op_sis,O_CHAVE])       // pega ultimo elemento das chaves
       IF chv=="codlan"                         // se e' ntx de relacionamento nao pode
        qt_ind--
       ENDI
       IF qt_ind>1                              // escolheum conjunto de indice
        msg=""
        FOR t=1 to qt_ind
         msg+="|"+sistema[op_sis,O_CONSU,t]
        NEXT
        op_ind=DBOX(SUBS(msg,2),,,E_MENU,,"SELECIONE O INDICE")
        IF op_ind>1
         ind_rela=ALLTRIM(STR(op_ind))
         DBSETORDER(VAL(ind_rela))
        ENDI
       ENDI
       SELE (m_origem)
       x_=ASCAN(sistema[op_sis_x,O_DBRELA],{|db_|sistema[op_sis,O_ARQUI,O_NOME]=db_})
       i_=LEN(sistema[op_sis,O_CPRELA])         // se DBF escolhido e relacionado,
       IF x_>0.AND.i_>0                         // monta a expressao de relacionamento
        chv_rela=""
        FOR i=1 TO LEN(sistema[op_sis,O_CPRELA])
         chv_rela+="+"+TRANSCAMPO(.f.,sistema[op_sis,O_CPRELA,i],i)
        NEXT
       ELSE                                     // se usuario montar expressao
        PEGARELA(.t.)
       ENDI
       chv_rela=IF(LEN(chv_rela)>2,SUBS(chv_rela,2),"")
       br_outro:cargo := {"","",chv_rela,op_ind}// inicializa variavel de usuario
      ENDI
      criterio:=cpord := ""                     // inicializa filtro/ordenacao
      cmr_="1=2"                                // cond marcacao de registros
      SELE (outro_db)                           // muda para a janela de baixo
      PEGACHV2()                                // pega final do relaciomento
      INI_ARQ()                                 // procura 1o. reg da relacao
      LDBEDIT(.f.)                              // monta as novas colunas
      FORCABRW(.t.)                             // imprime dados da janela de cima
      MONTABRW()                                // monta nova janela de visualizacao
     ELSE
      op_sis = op_sis_x                         // nao conseguiu abrir nova janela
     ENDI
    ENDI
    SETKEY(K_F9,pp)                             // habilita F9 (consulta outros DBFs)

   CASE carac_="L"                              // localiza registro
    SEPARA(br_w:getcolumn(br_w:colpos):cargo)   // separa atributos da coluna
    cod_sos=36
    ecara=(tp_cp=="C".OR.tp_cp=="M")            // tipo do campo
    brw_tela = SAVESCREEN(0,0,MAXROW(),79)      // salva tela atual
    chvpesq=IF(ecara,SPAC(30),IF(tp_cp="D",CTOD(''),IF(tp_cp="L",.t.,0)))
    msg="Argumento - Localiza argumento no campo "+cp_titu+;
        "|Condi‡„o - Localiza registro sob uma condi‡„o"+;
        "|Cancelar a opera‡„o"                  // escolhe o tipo de localizacao
    x=DBOX(msg,,,E_MENU,,SEPLETRA("LOCALIZA€ŽO",1))
    IF x!=0 .AND. x!=3                          // nao cancelou
     cond_p=""
     IF x=1                                     // localiza por argumento
      msg="LOCALIZAR ARGUMENTO "+IF(ecara,"CONTIDO ","")+" EM "+MAIUSC(cp_titu)
      chvpesq=DBOX("Informe o argumento",,,,,msg,chvpesq,cp_masc)
      IF cp_crit=="V" .OR. CRIT(cp_crit,18)     // argumento de pesquisa ok?
       IF (!EMPT(chvpesq) .OR. tp_cp="L").AND.LASTKEY()!=K_ESC
        IF ecara                                // se for caracter
         chvpesq=ALLTRIM(chvpesq)               // deixa localizar so as letras digitadas
         igc=1                                  // se tem minusculo no campo
         IF cp_masc!="@!"                       // pergunta se quer ignorar a caixa
          igc=DBOX("Sim|N„o|Cancelar a opera‡„o",,,E_MENU,,"IGNORAR CAIXA|(A=a)?")
         ENDI
         IF igc=1.OR.igc=2                      // prepara expressao de pesquisa
          cond_p=IF(igc=2,"'"+chvpesq+"' $ "+cp_,"MAIUSC('"+chvpesq+"') $ UPPER("+cp_+")")
         ENDI
        ELSE
         cond_p=cp_+"=chvpesq"                  // prepara expressao de pesquisa
        ENDI
       ENDI
      ENDI
     ELSE                                       // localiza por condicao
      cri_ant = criterio                        // salva filtro atual
      FILTRA(.f.)                               // monta expressao de pesquisa
      cond_p=criterio
      criterio = cri_ant                        // retorna filtro atual
     ENDI
     RESTSCREEN(0,0,MAXROW(),79,brw_tela)       // restaura tela anterior
     IF LEN(cond_p)>2                           // continua a localizar...
      cur_atual=SETCURSOR(0)                    // salva/apaga cursor
      POE_GAUGE("Loczalizando "+LTRIM(TRAN(chvpesq,""))+".|ESC interrompe","AGUARDE...","Processados:")
      brw_reg=RECN()
      INI_ARQ()                                 // move ponteiro para o inicio do arquivo
      IF LEN(chv_rela)>0                        // se tem relacao pesq somente nela
       x_=IF(EMPT(criterio),"","T")+chv_1       // chave de relacionamento
       LOCA FOR &cond_p. WHIL IN_KEY()!=K_ESC .AND. POE_GAUGE() .AND. &(INDEXKEY(0))=x_ // tenta localizar registro desejado
      ELSE
       LOCA FOR &cond_p. WHIL IN_KEY()!=K_ESC .AND. POE_GAUGE() // tenta localizar registro desejado
      ENDI
      SETCURSOR(cur_atual)                      // retorna o cursor ao normal
      IF ! FOUND().AND.LASTKEY()!=K_ESC         // nao achou ou cancelou
       ALERTA(4)
       DBOX("N„o encontrado!|*",13,40)          // mensagem ao usuario
       GO brw_reg
      ELSE
       ALERTA(1)                                // achou...
       fg_loc=.t.                               // sinal sonoro
      ENDI
     ENDI
     br_w:refreshall()                          // remonta os dados da consulta
    ENDI
    RESTSCREEN(0,0,MAXROW(),79,brw_tela)        // restaura tela anterior

   CASE carac_="M"                              // modifica registro
    IF !br_w:stable                             // forca a apresentacao de
     br_w:forcestable()                         // todos os registros na tela
     x_=COL(); y_=ROW()                         // salva coordenadas atuais do cursor
    ENDI
    brw_reg = RECNO()                           // salva registro atual
    SKIP                                        // tenta pegar o proximo reg
    IF EOF() .OR. &(INDEXKEY(0))!=IF(EMPT(criterio),"","T")+chv_1 // esta fora do filtro/relacao
     regseg = -1                                // esta no ultimo reg
    ELSE
     regseg = RECNO()
    ENDI
    GO brw_reg                                  // tenta pegar o reg anterior
    SKIP -1
    IF BOF() .OR. &(INDEXKEY(0))!=IF(EMPT(criterio),"","T")+chv_1 // esta fora do filtro/relacao
     regant = -1                                // esta no 1o. reg
    ELSE
     regant = RECNO()
    ENDI
    GO brw_reg                                  // volta para o reg que estava
    cont_mod=.f.                                // flag - continua modificando?

    #ifdef COM_REDE
     IF !BLOREG(10,.5)                          // tenta bloquear o registro
      LOOP                                      // nao conseguiu...
     ENDI
     blk_="blk_"+ALIAS()
     IF TYPE(blk_)="L"
      blk_a=&blk_.
     ELSE
      blk_a=.f.
     ENDI
     PRIV &blk_.:=.t.
    #endi

    IF !CONFALT()                               // verifica se o registro
     LOOP                                       // pode ser modificado
    ENDI
    SEPARA(br_w:getcolumn(br_w:colpos):cargo)   // separa atributos da coluna
    evirt=(cp_crit=="V")                        // pode modificar?
    IF (AT(UPPER(cp_),UPPER(INDEXKEY(1)))>0.AND.sistema[op_sis,O_OUTROS,O_TPCHV]).OR.;
       evirt.OR.DELE()
     ALERTA()
     DBOX(IF(DELE(),"REGISTRO EXCLU¡DO","CAMPO NŽO EDITVEL"),12,,1)
    ELSE
     &arq_cor._get1(FORM_INVERSA)               // executa processo inverso se existir
     pp=.f.                                     // flag "refresh" na outra janela?
     IF IF(!EMPTY(cp_when).AND.;                // tem pre-validacao. pode modificar?
        !("MTAB(" $ cp_when).AND.!("VDBF(" $ cp_when),EVAL(&("{||"+cp_when+"}")),.t.)
      SETCOLOR(drvcorbox)                       // coloca mensagem no topo da janela
      IF br_w:nleft+22<br_w:nright              // avisando que estamos modificando
       @ br_w:ntop-2,br_w:nleft+12 SAY "{Modifica}"
      ENDI
      ALERTA(1)                                 // Beep!
      IF tp_cp=="M"                             // campo memo...
       EDIMEMO(cp_,cp_titu,15,2,MAXROW()-1,3+VAL(SUBS(cp_masc,3)),cp_crit)
      ELSE
       i = br_w:getcolumn(br_w:colpos):width    // o tamanho atual da coluna
       IF i != LEN(TRAN(&cp_.,cp_masc)) .AND.;  // esta' diferente to tamanho
          tp_cp="C"                             // real do campo estao vamos
        cp_masc="@S"+ALLTRIM(STR(i,3))+IIF(LEFT(cp_masc,1)<>"@"," ","")+cp_masc  // forcar a rolagem do campo
       ENDI
       @ y_,x_ GET &cp_. PICT cp_masc;
                         VALI CRIT(cp_crit);
                         WHEN cp_when
                         AJUDA cp_help
                         CMDF8 cp_cmd
       READ
      ENDI
      IF br_w:nleft+22<br_w:nright              // retira mensagem de alteracao
       @ br_w:ntop-2,br_w:nleft+12 SAY REPL(SUBS(mold,2,1),10)
      ENDI
      IF tp_cp!="M".AND.LASTKEY()!=K_ESC.AND.;  // se o campo nao for memo, nao deu ESC,
         RECNO()=brw_reg                        // nao esta fora do filtro/relacao e
       cont_mod=.t.                             // segue modificando...
      ENDI
     ELSE                                       // nao pode ser modificado
      ALERTA()                                  // mostra por que
      DBOX("Modifica quando "+UPPER(cp_when),,,3,,"PR-CR¡TICA NŽO ATENDIDA!")
     ENDI
     &arq_cor._get1(FORM_DIRETA)                // executa processos/lancamentos
     IF pp                                      // se for preciso, forca
      REGINICIO()                               // verifica se reg esta' no filtro
      FORCABRW(.f.)                             // browse da outra janela
     ENDI
    ENDI

    #ifdef COM_REDE
     UNLOCK                                     // atualiza o disco
     &blk_.:=blk_a
    #endif

    br_w:refreshcurrent()                       // refaz so' a linha do browse
    IF cont_mod                                 // continua modicar?
     i_=VAL(SUBS(ch_tecl,dir_cur*2-1,2))        // proxima posicao do cursor
     IF &(INDEXKEY(0))!=IF(EMPT(criterio),"","T")+chv_1 // esta fora do filtro/relacao
      IF i_=5                                   // vai para o reg de cima
       IF regant>=0                             // exitem um...
        GO regant                               // posiciona nela e forca
        KEYB CHR(i_)+"M"                        // "M" para cont modificando
       ELSE                                     // esta no 1o. reg
        br_w:gotop()                            // acha o top do arq atual
       ENDI
      ELSE                                      // vai para reg seg ou para os lados
       IF regseg>=0                             // tem reg seguinte?
        GO regseg                               // posiciona nele
        KEYB "M"                                // forca "M" no buffer do teclado
       ELSE                                     // ja esta no ultimo
        br_w:gobottom()                         // acha o novo ultimo reg do arq
       ENDI
      ENDI
      br_w:hilite()                             // tira barra cursora da tela
      br_w:refreshall()                         // forca atualizacao da tela
      br_w:forcestable()                        // apresenta os dados
      br_w:dehilite()                           // liga barra cursora
      FORCABRW(.f.)                             // atualiza browse da outra janela
     ELSE                                       // nao esta fora do filtro...
      IF AT(UPPER(cp_),UPPER(INDEXKEY(0))) > 0  // se esta modificando campo do indice
       br_w:hilite()                             // tira barra cursora da tela
       br_w:refreshall()                         // forca atualizacao da tela
       br_w:forcestable()                        // apresenta os dados
       br_w:dehilite()                           // liga barra cursora
       FORCABRW(.f.)                             // atualiza browse da outra janela
      ENDI
      KEYB CHR(i_)+"M"                          // vai para onde o TAB esta indicando
     ENDI
    ENDI

   CASE carac_="N"                              // cria nova coluna
    cod_sos=28
    cp_ =SPAC(250) ; cp_titu=SPAC(30)           // inicializa variveis
    cp_masc=SPAC(30)
    msg="T¡tulo da nova coluna:"
    f10=.f.                                     // recebe titulo da nova coluna
    SET KEY K_F10 TO colnova                    // F10 campo de outro arquivo
    cp_titu=DBOX(msg,,,,,"NOVA COLUNA|*|F10=CAMPO DE OUTRO ARQUIVO",cp_titu)
    SET KEY K_F10 TO                            // desativa F10
    IF LASTKEY()!=K_ESC                         // se nao abandonou e nao teclou
     IF !f10                                    // F10, recebe conteudo da nova coluna
      msg+=" "+ALLTRIM(cp_titu)+"|Express„o conte£do:"
      DO WHILE .t.
       SET KEY K_F10 TO ve_campos               // F10 ve campos da estrutura
       cp_=DBOX(msg,,,,,"NOVA COLUNA|*|F10=CAMPOS DO ARQUIVO",cp_,"@S52@!")
       SET KEY K_F10 TO                         // desativa F10
       IF LASTKEY()!=27 .AND. !EMPTY(cp_)       // verifica se o conteudo e valido
        IF !CRIT("[U]!=TYPE(cp_) .OR. ([|] $ cp_ .AND. [->] $ cp_)~EXPRESSŽO ILEGAL",15)
         LOOP
        ENDI
       ENDI
       EXIT
      ENDD
     ENDI
     IF !EMPT(cp_) .AND. LASTKEY()!=K_ESC      // nao cancelou...
      IF !f10                                  // recebe mascara da nova coluna
       msg+=" "+LEFT(ALLTRIM(cp_),30)+"|Com a m scara:"
       cp_masc=DBOX(msg,,,,,"NOVA COLUNA",cp_masc,"@!")
      ENDI
      IF LASTKEY()!=K_ESC                      // se nao cancelou
       IF SETARELA(cp_)                        // coloca set relation
        IF br_w == br_origem                   // e prepara variavel para
         db_1rela=db_1rela+TRIM(cp_)+"³"       // a gravacao da consulta
        ELSE
         db_2rela=db_2rela+TRIM(cp_)+"³"
        ENDI
        cp_=SUBS(cp_,AT("|",cp_)+1)
       ENDI                                    // cria nova coluna com o que
       ncol = br_w:colpos                      // foi informado
       cp_titu=ALLTRIM(cp_titu) ; cp_=ALLTRIM(cp_) ; cp_masc=ALLTRIM(cp_masc)
       br_w:inscolumn(ncol,tbcolumnnew(cp_titu,&("{||TRAN("+cp_+",["+cp_masc+"])}")))
       br_w:getcolumn(ncol):cargo := cp_+"³"+cp_masc+"³"+cp_titu+"³³V"
       br_w:getcolumn(ncol):width := LEN(TRAN(&cp_.,cp_masc))
       br_w:getcolumn(ncol):colorblock=&("{||IF(DELE(),{3,2},IF("+cmr_+",{5,2},{1,2}))}")
       grava_db = .t.                          // modificou a consulta (flag)
       br_w:refreshall()                       // remonta toda a tela
      ENDI
     ENDI
    ENDI
    SET KEY K_F10 TO                           // desativa F10

   CASE carac_="O"                             // ordenacao da consulta
    cpord=""
    br_wx = br_w                               // salva browse atual
    CLASS(.t.)                                 // recebe expressao de ordenacao
    IF !EMPT(cpord)                            // montou ordenacao?
     br_w:refreshall()                         // refaz toda a tela
     IF INDEXORD()>LEN(sistema[op_sis,O_CHAVE])// se criou indice extra
      grava_db = .t.                           // seta flag de gravacao e
     ENDI                                      // grava a nova ordenacao
     br_w:cargo:={criterio,cpord,chv_rela,INDEXORD(),cmr_}
    ENDI
    MONTABRW()                                 // refaz todo o browse

   CASE carac_="P" .AND. ! EMPT(INDEXKEY(1))   // pesquisa indexada de registro
    brw_reg = RECNO()                          // registro atual
    POSI()                                     // recebe/procura registro
    IF brw_reg != RECNO()                      // se o reg nao e o mesmo,
     br_w:rowpos = 1                           // coloca reg atual na primeira
    ENDI                                       // linha da tela
    br_w:configure()                           // refaz a configuracao do browse

   CASE carac_="R"                             // recupera registro

    #ifdef COM_REDE
     IF !BLOREG(10,.5)                         // se nao bloqueou o registro,
      LOOP                                     // retorna ao browse
     ENDI
    #endi

    IF DELE()                                  // se o registro esta' excluido
     IF !EMPT(sistema[op_sis,O_CONDREC,1])     // se tem condicao de
      IF !&(sistema[op_sis,O_CONDREC,1])       // recuperacao e se esse
       ALERTA(2)                               // reg nao pode ser
       msg=sistema[op_sis,O_CONDREC,2]         // avisa o motivo
       DBOX(msg,,,,,"ATEN€ŽO!|IMPOSS¡VEL RECUPERAR")
       LOOP                                    // e retorna
      ENDI
     ENDI
     &arq_cor._get1(RECUPERA)                  // recupera reg/processo direto
     ALERTA(1)                                 // aviso sonoro
     br_w:refreshcurrent()                     // refaz so' a linha do browse
     FORCABRW(.f.)                             // remonta a outra janela (se houver)
    ENDI

    #ifdef COM_REDE
     UNLOCK                                    // libera registro
    #endi


   CASE carac_="S".AND.fg_loc                  // seguinte (proximo do localiza)
    brw_tela = SAVESCREEN(0,0,MAXROW(),79)     // salva tela/avisa que esta localizando
    cur_atual=SETCURSOR(0)                     // salva/apaga cursor
    POE_GAUGE("Loczalizando "+LTRIM(TRAN(chvpesq,""))+".|ESC interrompe","AGUARDE...","Processados:")
    brw_reg=RECN()                             // salva registro atual
    SKIP IF(EOF(),0,1)                         // pula para o proximo, se nao for fim de arq
    IF LEN(chv_rela)>0                         // se tem relacao pesq somente nela
     x_=IF(EMPT(criterio),"","T")+chv_1        // chave de relacionamento
     LOCA FOR &cond_p. WHIL IN_KEY()!=K_ESC .AND. POE_GAUGE() .AND. &(INDEXKEY(0))=x_ // continua a procura...
    ELSE
     LOCA FOR &cond_p. WHIL IN_KEY()!=K_ESC .AND. POE_GAUGE() // continua a procura...
    ENDI
    SETCURSOR(cur_atual)                       // retorna o cursor ao normal
    IF ! FOUND().AND.LASTKEY()!=K_ESC          // se nao achou,
     ALERTA(4)                                 // avisa
     DBOX("Registro n„o encontrado!",13,40)
     GO brw_reg
    ELSE                                       // achou...
     ALERTA(1)                                 // avisa com beep e
     br_w:refreshall()                         // prepara p/ remontar toda a tela
    ENDI
    RESTSCREEN(0,0,MAXROW(),79,brw_tela)       // retira msg de "localizando"

   CASE carac_="T"                             // muda tamanho da coluna
    SEPARA(br_w:getcolumn(br_w:colpos):cargo)  // pega tamanho atual
    x=IF(TYPE(cp_)=="M",60,LEN(TRAN(&cp_.,cp_masc)))
    msg="Informe o novo tamanho da coluna "+;
        MAIUSC(br_w:getcolumn(br_w:colpos):heading)
    cod_sos=1
    x=DBOX(msg,,,,,"TAMANHO DA COLUNA",x,"99") // recebe o novo tamanho
    IF CRIT(STR(x)+"<=77.AND."+STR(x)+;        // se o tamanho e valido
       ">0~TAMANHO ILEGAL",12)
     br_w:getcolumn(br_w:colpos):width = x     // atualiza tamanho da coluna
     grava_db = .t.                            // no browse e
     br_w:configure()                          // reconfigura tudo
    ENDI

   CASE carac_="V"                             // ve todo o registro na tela
    tela_fundo=SAVESCREEN(0,0,MAXROW(),79)     // salva tela
    t_tab:=SETKEY(K_TAB,NIL)                   // desativa o TAB

    #ifdef COM_MOUSE
     IF drvmouse                               // se mouse esta' ativo,
      MOUSEGET(@x_,@y_)                        // salva sua posicao atual
     ENDI
    #endi

    i_=SETCOLOR()                              // salva a cor atual
    DO WHILE .t.
     DISPBEGIN()                               // comeca a montagem da tela
     IMPRELA()                                 // imprime telas relacionadas
     &arq_cor._gets()                          // apresenta o conteudo do registro
     INFOSIS(.f.)                              // imprime o rodape' da tela
     DISPEND()                                 // mostra tela pronta
     ALERTA(1)
     cod_sos=35

     #ifdef COM_MOUSE
      tecl_p=MOUSETECLA(l_s,c_s,l_i,c_i,.f.)   // espera clique ou alguma tecla
     #else


      #ifdef COM_REDE
       tecl_p=IN_KEY(drvtempo)                 // espera tecla ou sai para refresh
      #else
       tecl_p=IN_KEY(0)                        // espera uma tecla ser digitada
      #endi

     #endi

     DO CASE
      CASE tecl_p=K_ALT_F8                     // teclou F8 (rolagem da janela)
       rola_t=.t.                              // liga flag e
       ROLATELA()                              // executa a rolagem
      CASE tecl_p=K_ESC.OR.tecl_p=K_ENTER.OR.tecl_p=32
       EXIT                                    // abandona
     ENDC
    ENDD
    SETCOLOR(i_)                               // restaura cor anterior

    #ifdef COM_MOUSE
     IF drvmouse                               // define janela do mouse
      MOUSEBOX(br_w:ntop-1,br_w:nleft-1,br_w:nbottom+1,br_w:nright+1)
      DO WHIL MOUSEGET(0,0)!=0                 // so' sai se os botoes do
      ENDD                                     // mouse estiverem liberados
      MOUSESET(x_,y_)                          // restaura a posicao do mouse
     ENDI
    #endi

    RESTSCREEN(0,0,MAXROW(),79,tela_fundo)     // restaura tela
    SETKEY(K_TAB,t_tab)                        // TAB volta a funcionar

   CASE carac_="X"                           // exporta dados
    cod_sos=32                               // escolhe o formato da exportacao
    msg="Texto - delimitados, para editores de texto|"+;
        "SDF - 'standard Data Format` para outros sistemas|"+;
        "DBF - formato padr„o dBASE"
    op_exp=DBOX(msg,,,E_MENU,,"TIPO DE ARQUIVO DE SAIDA")
    IF op_exp!=0
     IF op_exp=1                             // escolheu o delimitado, entao
      dli_exp=","                            // escolhe o delimitador
      dli_exp=DBOX("Informe o delimitador",,,,,"SEPARA€ŽO DOS CAMPOS",dli_exp)
     ENDI
     IF LASTKEY()!=K_ESC
      brw_tela = SAVESCREEN(0,0,MAXROW(),79) // salva a tela
      arq_=ARQGER()                          // recebe o nome do arquivo a gerar
      IF !EMPTY(arq_)                        // quer continuar...
       cod_sos=1
       arqexp=arq_+".TXT"                    // se o arq informado existir
       IF FILE(arqexp)                       // verifica se pode gravar por cima
        op_=DBOX("Gravar por cima|Cancelar a opera‡„o",,,E_MENU,,"ARQUIVO "+UPPER(arqexp)+" JA EXISTE!")
        cn=(op_!=1)
        IF !cn                               // pode sobrepor,
         ERASE (arqexp)                      // entao mata arq
        ENDI
       ENDI
       IF op_exp=3                           // se exporta para outro DBF
        IF FILE(arq_+".DBF")                 // verifica se o DBF ja existe
         op_=DBOX("Gravar por cima|Cancelar a opera‡„o",,,E_MENU,,"ARQUIVO "+UPPER(arq_)+".DBF JA EXISTE!")
         cn=(op_!=1)
        ENDI
       ENDI
      ENDI
      IF !cn                                 // avisa que esta' trabalhando...
       DBOX("Gerando o arquivo "+arqexp,15,,,NAO_APAGA)
       ASIZE(estr_dbf,0); ASIZE(cp_exp,0)    // vetores auxiliares
       FOR i=1 TO br_w:colcount              // exporta todas as colunas
        SEPARA(br_w:getcolumn(i):cargo)      // separa atributo da coluna
        IF tp_cp!="M"                        // campo memo nao e' exportado
         IF op_exp=3                         // exporta para DBF
          cp_x=cp_
          casadec=0                          // se a coluna for numerica, verifica
          IF tp_cp="N"                       // a qde de casas decimais
           casadec=IF("." $ cp_masc,LEN(cp_masc)-RAT(".",cp_masc),0)
           tamanho=0                         // acha o tamanho
           FOR t=1 TO LEN(cp_masc)           // do campo
            IF !(SUBS(cp_masc,t,1) $ "@BCDEKXZR, ()")
             tamanho++
            ENDI
           NEXT
          ELSEIF tp_cp="D"                   // a coluna e' uma data
           tamanho=8                         // o tamanho e' sempre 8
          ELSEIF tp_cp="L"                   // a coluna e' tipo logico
           tamanho=1                         // o tamanho e' sempre 1
          ELSE                               // coluna tipo caracter
           tamanho=br_w:getcolumn(i):width
           cp_="LEFT("+cp_+"+["+SPAC(tamanho)+"],"+STR(tamanho,3)+")"
          ENDI
          IF "->" $ cp_x                     // coluna de outro arquivo
           cp_x=SUBS(cp_x,AT("->",cp_x)+2)   // retira o nome do DBF
          ENDI
          FOR tt=1 TO 12                     // retira caracteres ilegais
           i_=SUBS(" ()*/+-^%$@&",tt,1)      // do conteudo da coluna
           IF i_ $ cp_x                      // nome do campo do DBF a exportar
            cp_x=STRTRAN(cp_titu,i_,"")
           ENDI
          NEXT                               // monta vetor da nova estrutura
          AADD(estr_dbf,{cp_x,tp_cp,tamanho,casadec})
         ELSE                                // exportacao TXT/SDF
          IF AT(tp_cp,"CN")>0                // caracter/numerico trunca pelo tam da coluna
           cp_="LEFT(TRAN("+cp_+",["+cp_masc+"])+["+SPAC(br_w:getcolumn(i):width)+"],"+STR(br_w:getcolumn(i):width,3)+")"
          END IF
         ENDI
         AADD(cp_exp,cp_)                    // vetor com conteudos a exportar
        ENDI
       NEXT
       brw_reg = RECNO()                     // volta para registro anterior
       dele_atu:=SET(_SET_DELETED,.t.)       // os excluidos nao serao exportados
       INI_ARQ()                             // move ponteiro para o inicio do arquivo
       SET ALTE TO (arq_)                    // abre o arquivo para gravacao
       SET ALTE ON                           // liga gravacao
       SET CONS OFF                          // nao iremos exibir na tela
       q=CHR(34)                             // "aspas"
       DO WHIL !EOF()                        // para todos os registros
        FOR t=1 TO LEN(cp_exp)               // e para todas as colunas
         c_p=EVAL(&("{||"+cp_exp[t]+"}"))    // "code block" com o conteudo da coluna
         IF op_exp!=1                        // se nao for delimitado
          c_p=IF(VALTYPE(c_p)="D",DTOS(c_p),c_p)
          ?? c_p                             // grava no arquivo
         ELSE                                // se delimitado grava entre aspas
          c_p=IF(VALTYPE(c_p)="D",DTOC(c_p),c_p)
          ?? q+ALLTRIM(c_p)+q+IF(t=LEN(cp_exp),"",dli_exp)
         ENDI
        NEXT
        ?                                    // pula para proxima linha
        SKIP                                 // pega proximo registro
       ENDD
       SET ALTE OFF                          // desliga a gravacao
       SET ALTE TO                           // fecha arquivo
       SET CONS ON                           // reabilita o video
       SET(_SET_DELETED,dele_atu)            // restaura situacao do DELE()
       GO brw_reg                            // volta para registro anterior
       IF op_exp=3                           // exportacao para DBF
        DBOX("Gerando o arquivo "+arq_+".DBF",15,,,NAO_APAGA)
        i_=LEN(estr_dbf)                     // verifica/assegura que os nomes
        FOR t=1 TO i_                        // dos campos nao estao repetidos
         FOR i=t+1 TO i_
          IF estr_dbf[t,1]=estr_dbf[i,1]
           estr_dbf[i,1]=LEFT(estr_dbf[i,1],8)+STRZERO(i,2)
          ENDI
         NEXT
        NEXT
        are_a:=SELECT()                      // area atual
        SELE 0
        DBCREATE(arq_,estr_dbf)              // cria o novo DBF
        USE (arq_)                           // abre
        APPEND FROM (arqexp) SDF             // e anexa os registros
        USE                                  // fecha
        ERASE (arqexp)                       // elimina arq .txt temporario
        SELE (are_a)                         // retorna para area DBF origem
       ENDI
       AFILL(cp_exp,"")
       RESTSCREEN(0,0,MAXROW(),79,brw_tela)  // restaura a tela e
       ALERTA()                              // beep
      ENDI
     ENDI
    ENDI

   CASE carac_="Z"                             // totaliza coluna
    SEPARA(br_w:getcolumn(br_w:colpos):cargo)  // separa atributos da coluna
    IF !(tp_cp $ "NC")                         // se o campo nao for numerico
     ALERTA()                                  // nao da para somar
     DBOX("Coluna n„o pode ser totalizada",,,2)
    ELSE
     brw_tela = SAVESCREEN(0,0,MAXROW(),79)    // salva tela, registro e avisa
     brw_reg=RECN()                            // que esta somando
     DBOX("Totalizando "+MAIUSC(cp_titu)+"|ESC interrompe",,,,NAO_APAGA,"AGUARDE!")
     INI_ARQ()                                 // vai para o topo do arquivo
     x=INDEXKEY(0)                             // e comeca a somar
     IF tp_cp="N"
      SUM &cp_. TO tot_ FOR !DELE() WHIL IN_KEY()!=K_ESC .AND. &x.=IF(EMPTY(criterio),"","T")+chv_1
     ELSE
      SUM VALBR(cp_) TO tot_ FOR !DELE() WHIL IN_KEY()!=K_ESC .AND. &x.=IF(EMPTY(criterio),"","T")+chv_1
     ENDI
     GO brw_reg
     IF LASTKEY()!=K_ESC                       // nao cancelou
      ms="999,999,999,999,999,999"             // mostra quanto foi o somatorio
      dec=AT(".",cp_masc)
      ms+=IF(dec>0,SUBS(cp_masc,dec),".99")
      ALERTA(4)
      DBOX("O somat¢rio de "+MAIUSC(cp_titu)+" ‚|"+TRAN(tot_,ms),,,,,"TOTALIZA€ŽO")
     ENDI
     RESTSCREEN(0,0,MAXROW(),79,brw_tela)      // restaura a tela
    ENDI

  ENDC
 ENDI
ENDD

#ifdef COM_MOUSE
 IF drvmouse
  DO WHIL MOUSEGET(@Li,@Co)!=0                 // se qualquer botao do mouse
  ENDD                                         // estiver pressionado, espera
  MOUSEBOX(0,0,MAXROW(),79)                    // a sua liberacao
 ENDI
#endi

RETU NIL

/*
   Sintaxe: VALBR(cp)
   Funcao.: Transforma caracter em numerico despresando a mascara
   Retorna: valor numerico de cp
*/
STATIC FUNC VALBR(cp_)
LOCAL val_br
val_br=&cp_.                       // campo a ser transformado
IF AT("@E", UPPER(cp_))>0          // tem @E na mascara, entao
 val_br=STRTRAN(val_br, ".", "")   // vamos trocar o ponto por nada
 val_br=STRTRAN(val_br, ",", ".")  // e a virgula pelo ponto
ELSE                               // nao tem @E na mascara, entao
 val_br=STRTRAN(val_br, ",", "")   // so vamos trocar a virgula por nada
ENDI
RETU VAL(val_br)                   // retorna o valor numerico

/*
   Sintaxe: IMP_BRW()
   Funcao.: Imprime a consulta da funcao EDITA()
   Retorna: NIL
*/
STATIC FUNC IMP_BRW()
LOCAL dele_atu, qb_:={}, qba_:={}, x_, or_i, tot_num:=.f., tot_snum:=.f.,;
      tot_sint:=.f., lin_qb:={}
ALERTA(1)
x_=PADR(tit_cons[IF(br_w == br_origem,1,2)],40)         // recebe um titulo do relatorio
cod_sos=38                                              // sugerindo o titulo da consulta
tit_rel=DBOX("Informe um t¡tulo",,,,,"IMPRESSŽO DE CONSULTA",x_)
IF LASTKEY()!=K_ESC
 cod_sos=1
 ALERTA(1)                                              // a onde vai imprimir?
 tps=TP_SAIDA(,0,.T.)                                   // escolhe a saida...
 IF tps>0 .AND. LASTKEY()!=K_ESC
  cn=.f.
  ALERTA(1)
  IF "4WIN"$UPPER(drvmarca) // nome da configuracao/marca impressora
    arq_:=drvdbf+"WIN"+ide_maq
    tps:=3                                          // se vai para arquivo/video
    cn:=.F.
  ELSEIF tps=2                                              // saida para arquivo
   arq_=ARQGER()                                        // solicita um nome
   cn=EMPTY(arq_)
  ELSE                                                  // vai para a impressora
   cn=!PREPIMP()                                        // pede para prepara-la
   arq_=drvporta                                        // porta de saida configurada
  ENDI
  IF !cn
   brw_reg=RECN()                                       // salva registro atual
   dele_atu=SET(_SET_DELETED,.t.)                       // salva/seta visao dos reg apagados
   brw_tela = SAVESCREEN(0,0,MAXROW(),79)               // salva tela
   qb_=QUEBRA_BRW()                                     // pega quebra da impressao
   ltot := ltot_o := 0                                  // inicializa variaveis
   lin4win:=iif("4WIN"$UPPER(drvmarca),20,0)
   brw_cb1 = ""; brw_imp:=just_memo:=tot_num:=tot_snum:=tot_sint := .f.
   IF LEN(qb_)>1                                        // se tem quebra
    brw_cb1 = SPACE((3*(LEN(qb_)-1)))                   // coloca cabecalho mais a direita
    ltot = (3*(LEN(qb_)-1))                             // tamanho do cabecalho
   ENDI
   IF br_w == br_origem .AND. VALTYPE(outro_db) = "C"   // se esta imprimindo da janela de cima
    id_carg = br_outro:cargo                            // vamos verificar se a janela
    brw_imp = !EMPTY(id_carg[3])                        // de baixo esta relacionada
   ENDI
   FOR t = 1 TO br_w:colcount                           // para cada coluna,
    SEPARA_IMP(br_w:getcolumn(t):cargo)                 // separa os atributos
    le_=br_w:getcolumn(t):width                         // tamanho da coluna
    brw_cb1 +=" "+PADR(ALLTRIM(cp_titu),le_)            // monta linha de cabecalho
    ltot += le_ + 1                                     // tamanho do relatorio
    IF tp_cp=="N"                                       // coluna e' numerica?
     var="to"+SUBS(STR(t+100,3),2)                      // inicializa variavel
     &var.=0; tot_num=.t.                               // para totalizar a coluna
     IF LEN(qb_)>0                                      // se tem quebra
      FOR ii=1 TO LEN(qb_)                              // inicializa variaves de sub totalizacao
       var="Q"+SUBS(STR(ii+100,3),2)+"to"+SUBS(STR(t+100,3),2)  // inicializa variavel
       &var.=0; tot_snum=.t.                            // para totalizar a coluna
      NEXT
     ENDI
    ENDI
    IF tp_cp="M"                                        // coluna e' memo?
     just_memo=.t.                                      // liga flag da pergunta
    ENDI                                                // para justificar memo
   NEXT
   brw_cb1 = SUBS(brw_cb1,2)                            // tira 1o. espaco do titulo e
   ltot--                                               // ajusta tamanho do relatorio
   IF brw_imp                                           // existe janela relacionada?
    SELE (outro_db)                                     // seleciona o DBF da janela de
    IF LEN(qb_)>1                                       // se tem quebra
     brw_cb2 = SPACE(ltot_o)                            // defasa cabecalho do arq relacionado
     ltot_o = (3*(LEN(qb_)-1))                          // aumenta tamanho da cabecalho do arq rela
    ELSE                                                // nao tem quebra
     ltot_o = 0                                         // inicializa variaveis do cabecalho
     brw_cb2 = ""
    ENDI
    FOR t = 1 TO br_outro:colcount                      // para cada coluna
     SEPARA_IMP(br_outro:getcolumn(t):cargo)            // separa os atributos
     le_=br_outro:getcolumn(t):width                    // tamanho da coluna
     brw_cb2 +=" "+PADR(ALLTRIM(cp_titu),le_)           // monta titulo das colunas
     ltot_o += le_ + 1                                  // e o tamanho do relatorio
     IF tp_cp=="N"                                      // coluna e' numerica?
      var="too"+SUBS(STR(t+100,3),2)                    // inicializa variavel
      &var.=0; tot_num=.t.                              // para totalizar a coluna
     END IF
     IF tp_cp="M"                                       // coluna e' memo?
      just_memo=.t.                                     // liga flag de pergunta
     ENDI                                               // para justificar memo
    NEXT
    brw_cb2 = SUBS(brw_cb2,2)                           // tira 1o. espaco do titulo e
    ltot_o--                                            // ajusta tamanho do relatorio
    SELE (m_origem)                                     // seleciona DBF da janela de cima
   ENDI
   IF tot_num                                           // tem alguma coluna numerica?
    ALERTA(1)                                           // pergunta se quer totalizar
    cod_sos=1                                           // o relatorio
    i=DBOX("Sim|N„o",,,E_MENU,,"TOTALIZAR AS|COLUNAS NUMRICAS")
    IF i=0
     RETU                                               // cancelou...
    ENDI                                                // flag se quer totalizar
    tot_num=(i=1)
    IF !tot_num                                         // se nao vai totalizar
     tot_snum=.f.                                       // tambem nao sub-totaliza
    ENDI
    IF tot_snum                                         // se tem?
     ALERTA(1)                                          // pergunta se quer sub totalizar
     cod_sos=1                                          // a quebra
     i=DBOX("Sim|N„o",,,E_MENU,,"SUBTOTALIZAR AS QUEBRAS")
     IF i=0
      RETU                                               // cancelou...
     ENDI                                                // flag se quer sub totalizar
     tot_snum=(i=1)
    ENDI
    IF tot_snum .AND. !brw_imp                           // vai subtotalizar e nao tem arq relacionado
     ALERTA(1)                                           // pergunta se quer sintetizar a impressao
     cod_sos=1
     i=DBOX("Sim|N„o",,,E_MENU,,"SINTETIZAR O RELATORIO")
     IF i=0
      RETU                                               // cancelou...
     ENDI
     tot_sint=(i=1)                                      // flag se quer sub totalizar
    ENDI
   ENDI
   IF just_memo                                         // tem algum campo memo?
    ALERTA(1)                                           // pergunta se quer justificar
    cod_sos=50                                          // os campos memos no relatorio
    i=DBOX("Sim|N„o",,,E_MENU,,"JUSTIFICAR OS|CAMPOS MEMO")
    IF i=0
     RETU                                               // cancelou...
    ENDI
    just_memo=(i=1)                                     // flag se quer justificar memos
   ENDI
   or_i=cpord                                           // salva ordenacao atual
   IF LEN(qb_)>0                                        // tem quebra
    x_=""                                               // junta a expressao
    FOR t=1 TO LEN(qb_)                                 // de ordenacao de todas
     x_+=IF(LEN(x_)>1,"+","")+qb_[t,2]                  // as quebras
    NEXT
    IF LEFT(cpord,LEN(x_))!=x_                          // se ainda nao esta ordenado
     cpord=x_+IF(LEN(cpord)>1,"+"+cpord,"")             // por esta expressao
     INDTMP()                                           // vamos ordernar agora...
     br_w:refreshall()                                  // forca atualizacao da tela
    ENDI
   ENDI
   DBOX("Aguarde o final de impress„o||ESC para interromper",17,,,NAO_APAGA)
   INI_ARQ()                                            // vai para o inicio do arquivo
   cl:=pg:=creg := 0                                    // inicializar variaveis
   SET PRINTER TO (arq_)                                // abre arq escolhido ou redireciona saida
   SET DEVI TO PRIN                                     // se tamanho > 80, comprime
   @ PROW(),PCOL() SAY IF(MAX(ltot,ltot_o)>80,&drvpcom.,"")
   cl=CABCONS(brw_cb1,tit_rel)                          // imprime cabecalho da janela superior
   brw_cn = .f.
   x_ = INDEXKEY(0)
   IF LEN(qb_)>0                                        // tem quebra definida
    qba_:=AFILL(ARRAY(LEN(qb_)),"")                     // cria vetor do conteudo de cada quebra
   ENDI
   DO WHIL ! EOF() .AND. ! brw_cn .AND.;                // imprime ate o fim do arquivo
      IF(EMPTY(chv_rela).OR.br_w==br_origem,.t.,&x_.=IF(EMPTY(criterio),"","T")+chv_1)
    IF cl>IF(brw_imp,54,57)                             // atingiu o final da folha
     EJEC                                               // pula para proxima pagina
     cl=CABCONS(brw_cb1,tit_rel)                        // e reimprime o cabecalho
    ENDI

    IF IN_KEY()=K_ESC .OR. MOUSEGET(0,0)=2              // quer cancelar a impressao?
     brw_cn = CANC(1)                                   // pede confimacao do cancelamento
     LOOP
    ENDI
    IF LEN(qb_)>0                                       // tem quebra
     FOR t=1 TO LEN(qb_)                                // vamos correr todas
      IF qba_[t]<>&(qb_[t,1])                           // quebrou...
       x_ = .f.
       IF tot_snum .AND. LEN(qba_[t])>0                 // quer totalizar e nao e a 1a. vez
        FOR ii= LEN(qb_) TO t STEP -1                   // coloca os totais das sub-quebras menores
         IF cl+1>IF(brw_imp,52,55)                  // precisa quebrar pagina
          EJEC
          cl=CABCONS(brw_cb1,tit_rel)
         ENDI
         IF ii=LEN(qb_) .AND. tot_sint              // vai sintetizar e e' ultima quebra
          FOR tt=1 TO LEN(lin_qb)                   // corre as linhas salvas
           IF cl+1>IF(brw_imp,54,57)                // precisa quebrar pagina...
            EJEC                                    // forca quebra de folha
            cl=CABCONS(brw_cb1,tit_rel)
           ENDI
           @ cl++,0 SAY lin_qb[tt]                  // imprime linha sintetizada
          NEXT
         ELSE
          lin = SPACE((3*(ii-1)))                   // esp branco ate a quebra
          @ cl++,0 SAY lin+REPL("-", ltot-LEN(lin)) // traco antes da quebra
          lin = SPACE((3*(len(qb_)-1)))             // esp branco ate os dados
         ENDI
         FOR tt=1 TO br_w:colcount                  // monta linha dos sub-totais
          SEPARA_IMP(br_w:getcolumn(tt):cargo)      // separa dados da coluna
          i = br_w:getcolumn(tt):width              // tananho da coluna
          IF tp_cp=="N"                             // coluna numerica, pega sub-total
           var="Q"+SUBS(STR(ii+100,3),2)+"to"+SUBS(STR(tt+100,3),2)
           lin += LEFT(TRAN(&var.,cp_masc)+SPAC(i),i)+" "
           &var.=0
          ELSE
           lin += SPAC(i+1)                         // coluna nao numerica coloca brancos
          ENDI
         NEXT
         IF ii<LEN(qb_) .OR. !tot_sint              // nao e' a ultima quebra
          @ cl++,0 SAY lin                          // imprime sub-totais
          x_ = .t.
         ENDI
         qba_[ii]=""                                // limpa conteudo da quebra
        NEXT
       ENDI
       qba_[t]=&(qb_[t,1])                          // novo conteudo da quebra
       IF LEN(qb_[t,3])>0                                // imprime o titulo
        cl++
        @ cl++,0 SAY SPACE((3*(t-1)))+;                  // somente se foi informado
                     qb_[t,3]+" "+qba_[t]                // imprime titulo da quebra e seu conteudo
       ELSEIF x_
        cl++
       ENDI
      ENDI
     NEXT
     lin = SPACE((3*(LEN(qb_)-1)))                       // onde comeca os dados
    ELSE
     lin = ""                                            // sem quebra, dados comeca na coluna um
    ENDI
    tem_memo=.f.; qli_m=0
    FOR t=1 TO br_w:colcount                            // monta linha a imprimir
     SEPARA_IMP(br_w:getcolumn(t):cargo)                // separa os atributos da coluna
     i = br_w:getcolumn(t):width                        // tamanho da coluna
     IF tp_cp="M"                                       // coluna e' memo?
      IF qli_m<MLCOUNT(&cp_.,i)                         // mumero maximo de linhas
       qli_m=MLCOUNT(&cp_.,i)                           // a imprimir de todos campos memo
      ENDI                                              // monta linha de impressao
      lin += IMPAC(LEFT(MEMOLINE(&cp_.,i,1)+SPACE(i),i),just_memo)+" "
      tem_memo=.t.                                      // flag tem memo?
     ELSE
      IF tp_cp=="N" .AND. tot_num                       // coluna e' numerica?
       var="to"+SUBS(STR(t+100,3),2)                    // soma coluna para
       &var. += &cp_.                                   // totalizacao
       IF LEN(qb_)>0 .AND. tot_snum                     // tem quebra e quer sub-total
        FOR ii=1 TO LEN(qb_)                            // soma de cada quebra
         var="Q"+SUBS(STR(ii+100,3),2)+"to"+SUBS(STR(t+100,3),2)  // inicializa variavel
         &var. += &cp_.
         IF ii=LEN(qb_) .AND. tot_sint                  // sitetiza a ultima quebra
          cp_=var
         ENDI
        NEXT
       ENDI
      ENDI
      lin+=LEFT(TRAN(&cp_.,cp_masc)+SPAC(i),i)+" "      // monta linha de impressao
     ENDI
    NEXT
    IF tot_sint                                            // esta sintetizando
     lin_qb:={}                                            // salva linhas para
     AADD(lin_qb,lin)                                      // imprimir quando quebrar
    ELSE
     @ cl++,0 SAY lin                                      // joga linha na impressora
    ENDI
    IF tem_memo .AND. qli_m>1                           // imprime resto do memo
     li_m=1
     DO WHIL .t.
      li_m++                                            // proxima linha do memo
      IF li_m>qli_m                                     // se ja' imprimiu todos
       EXIT                                             // cai fora...
      ENDI
      IF LEN(qb_)>1                                     // se tem quebra calcula
       lin = SPACE((3*(LEN(qb_)-1)))                    // posicao de inicio dos dados
      ELSE
       lin = ""                                         // sem quebra inicio=1a. coluna
      ENDI
      FOR t=1 TO br_w:colcount                          // procura todos os memo
       SEPARA_IMP(br_w:getcolumn(t):cargo)              // e monta uma linha so'
       i = br_w:getcolumn(t):width
       IF tp_cp="M"
        lin += IMPAC(LEFT(MEMOLINE(&cp_.,i,li_m)+SPACE(i),i),just_memo)+" "
       ELSE
        lin += SPAC(i+1)
       ENDI
      NEXT
      IF cl+1>(IF(brw_imp,54,57)+lin4win)
       IF !("4WIN"$UPPER(drvmarca))
        EJEC                                             // quebra de folha
       ENDI
       cl=CABCONS(brw_cb1,tit_rel)
      ENDI
      IF tot_sint                                       // esta sintetizando
       AADD(lin_qb,lin)                                 // salva linha
      ELSE
       @ cl++,0 SAY lin                                 // joga linha na impressora
      ENDI
      IF IN_KEY()=K_ESC .OR. MOUSEGET(0,0)=2            // quer cancelar a impressao?
       brw_cn = CANC(1)
       LOOP
      ENDI
     ENDD
    ENDI
    IF tem_memo .AND. !tot_sint                         // se imprimiu algum campo
     cl++                                               // memo, forca espacejamento duplo
    ENDI
    creg++                                              // contador de registros impressos
    IF brw_imp                                          // tem outra janela relacionada?
     cl++                                               // forca salto de linha
     id_carg=br_outro:cargo                             // prepara para a impressao
     c_antes=IF(EMPTY(id_carg[1]),"","T")+&(id_carg[3]) // da janela relacionada
     SELE (outro_db)
     SEEK c_antes                                       // acha o 1o. registro da relacao
     ind_outro = INDEXKEY(0)                            // ordem atual do arquivo
     imp_brw_out=.f.
     IF !EOF().AND.!brw_cn.AND.&ind_outro.=c_antes      // se tem registro a imprimir
      cl=CABCONS_O(cl,brw_cb2)                          // imprime cabecalho
      cl++
     ENDI
     DO WHIL !EOF().AND.!brw_cn.AND.&ind_outro.=c_antes // imprime so quem atende a relacao
      cl--
      IF cl>57                                          // final da folha
       IF !("4WIN"$UPPER(drvmarca))
        EJEC                                             // salta para proxima
       ENDI
       cl=CABCONS(brw_cb1,tit_rel)                      // imprime cabecalho do "pai"
      ENDI
      IF IN_KEY()=K_ESC .OR. MOUSEGET(0,0)=2            // quer cancelar?
       brw_cn = CANC(1)                                 // pede confirmacao
       LOOP
      ENDI
      tem_memo=.f.; qli_m=0
      IF LEN(qb_)>1                                     // se tem quebra
       lin_o = SPACE((3*(LEN(qb_)-1)))                  // inicio dos dados
      ELSE
       lin_o = ""                                       // nao tem quebra posicao 0
      ENDI
      FOR t=1 TO br_outro:colcount                      // monta linha a imprimir
       SEPARA_IMP(br_outro:getcolumn(t):cargo)          // separa os atributos da coluna
       IF tp_cp="M"                                     // tamanho da coluna
        IF qli_m<MLCOUNT(&cp_.,i)                       // coluna e' memo?
         qli_m=MLCOUNT(&cp_.,i)                         // mumero maximo de linhas
        ENDI                                            // a imprimir de todos campos memo
        lin_o+=" "+IMPAC(LEFT(MEMOLINE(&cp_.,i,1)+;
             SPACE(i),i),just_memo)                     // monta linha de impressao
        tem_memo=.t.                                    // flag se tem memo
       ELSE
        IF tp_cp=="N" .AND. tot_num                     // coluna e' numerica?
         var="too"+SUBS(STR(t+100,3),2)                 // soma coluna para
         &var. += &cp_.                                 // totalizacao
        ENDI
        i = br_outro:getcolumn(t):width                 // tamanho da coluna
        lin_o+=" "+LEFT(TRAN(&cp_.,cp_masc)+SPAC(i),i)  // monta linha de impressao
       ENDI
      NEXT
      imp_brw_out=.t.
      @ cl,0 SAY PADL(SUBS(lin_o,2),MAX(ltot,ltot_o))   // joga linha na impressora
      IF tem_memo .AND. qli_m>1                         // imprime resto do memo
       li_m=1
       DO WHIL .t.
        li_m++                                          // proxima linha do memo
        IF li_m>qli_m                                   // se ja imprimiu todos
         EXIT                                           // cai fora...
        ENDI
        IF LEN(qb_)>1                                   // se tem quebra
         lin = SPACE((3*(LEN(qb_)-1)))                  // inicio dos dados
        ELSE
         lin = ""                                       // posicao 0 sem quebra
        ENDI
        FOR t=1 TO br_w:colcount                        // procura todos os memo
         SEPARA_IMP(br_w:getcolumn(t):cargo)            // e monta uma linha so'
         i = br_w:getcolumn(t):width
         IF tp_cp="M"
          lin += IMPAC(LEFT(MEMOLINE(&cp_.,i,li_m)+SPACE(i),i),just_memo)+" "
         ELSE
          lin += SPAC(i+1)
         ENDI
        NEXT
        IF cl+1>57                                      // chegou no final da folha?
         IF !("4WIN"$UPPER(drvmarca))
          EJEC                                           // salta para proxima pagina
         ENDI
         cl=CABCONS(brw_cb1,tit_rel)                    // reimprime cabecalho do "pai"
        ENDI
        @ ++cl,0 SAY PADL(lin,MAX(ltot,ltot_o))         // imprime linhas dos memo
        IF IN_KEY()=K_ESC .OR. MOUSEGET(0,0)=2          // quer cancelar?
         brw_cn = CANC(1)
         LOOP
        ENDI
       ENDD
      ENDI
      cl += 2
      SKIP                                              // de imprimir o proximo "pai"
     ENDD
     IF imp_brw_out                                     // se imprimiu algum registro...
      @ cl-1,0 SAY PADL(REPL("-",ltot_o),MAX(ltot,ltot_o))
     ENDI
     cl++
     IF tot_num                                      // pediu para totalizar
      lin_o=""
      FOR t=1 TO br_outro:colcount                   // monta linha dos totais
       SEPARA_IMP(br_outro:getcolumn(t):cargo)
       i=br_outro:getcolumn(t):width
       IF tp_cp=="N"
        var="too"+SUBS(STR(t+100,3),2)                    // variavel com a mascara
        lin_o+=" "+LEFT(TRAN(&var.,cp_masc)+SPAC(i),i)    // da propria coluna
        &var.=0
       ELSE
        lin_o += SPAC(i+1)
       ENDI
      NEXT
      IF LEN(ALLTRIM(lin_o))>0                          // se tem totais, imprime
       @ cl-1,0 SAY PADL(SUBS(lin_o,2),MAX(ltot,ltot_o))
       cl++
      ENDI
     ENDI
     SELE (m_origem)                                    // retorna ao "pai"
    ENDI
    SKIP
   ENDD
   IF tot_snum                                          // quer sub-totalizar?
    IF LEN(qba_[1])>0                                   // teve alguma quebra impressa?
     FOR ii= LEN(qb_) TO 1 STEP -1                      // corre todas para imprimir sub-total
      IF cl+1>IF(brw_imp,52,55)                         // precisa pular pagina
       IF !("4WIN"$UPPER(drvmarca))
        EJEC
       ENDI
       cl=CABCONS(brw_cb1,tit_rel)                      // se pulou reimprime cabecalho
      ENDI
      IF ii=LEN(qb_) .AND. tot_sint                     // ultima quebra vai sintetizar...
       FOR tt=1 TO LEN(lin_qb)                          // imprime linhas salvas
        IF cl+1>(IF(brw_imp,54,57)+lin4win)             // precisa quebrar a pagina
         IF !("4WIN"$UPPER(drvmarca))
          EJEC                                           // entao forca
         ENDI
         cl=CABCONS(brw_cb1,tit_rel)
        ENDI
        @ cl++,0 SAY lin_qb[tt]                         // linha com total da ultima quebra
       NEXT
      ELSE
       lin = SPACE((3*(ii-1)))                          // inicio da quebra
       @ cl++,0 SAY lin+REPL("-", ltot-LEN(lin))        // traco da quebra
       lin = SPACE((3*(len(qb_)-1)))                    // inicio dos dados
      ENDI
      FOR tt=1 TO br_w:colcount                         // monta linha dos sub-totais
       SEPARA_IMP(br_w:getcolumn(tt):cargo)             // separa a coluna
       i = br_w:getcolumn(tt):width                     // tamanho da coluna
       IF tp_cp=="N"                                    // numerico pega sub-total
        var="Q"+SUBS(STR(ii+100,3),2)+"to"+SUBS(STR(tt+100,3),2)
        lin += LEFT(TRAN(&var.,cp_masc)+SPAC(i),i)+" "
        &var.=0                                         // zera sub-total
       ELSE
        lin += SPAC(i+1)                                // col nao numerica poe espacos
       ENDI
      NEXT
      IF ii<LEN(qb_) .OR. !tot_sint                     // nao esta sintetizando...
       @ cl++,0 SAY lin                                 // imprime sub-total
      ENDI
      qba_[ii]=""                                       // inicializa quebra
     NEXT
    ENDI
   ENDI
   @ PROW()+1,0 SAY REPL("=", MAX(ltot,ltot_o))         // traco do fim do relatorio
   IF LEN(qb_)>0                                        // se tem quebra
    lin = SPACE((3*(LEN(qb_)-1)))                       // dados na posicao da ultima quebra
   ELSE
    lin = ""
   ENDI
   IF tot_num                                           // quer totalizar
    FOR t=1 TO br_w:colcount                            // monta linha dos totais
     SEPARA_IMP(br_w:getcolumn(t):cargo)
     i = br_w:getcolumn(t):width
     IF tp_cp=="N"
      var="to"+SUBS(STR(t+100,3),2)                     // variavel com a mascara
      lin += LEFT(TRAN(&var.,cp_masc)+SPAC(i),i)+" "    // da propria coluna
     ELSE
      lin += SPAC(i+1)
     ENDI
    NEXT
    @ PROW()+1,0 SAY lin
   ENDI                                                 // se tem totais, imprime
   @ PROW()+1,0 SAY IIF(tot_sint,"Processados: ","Listados: ")+; // imprime qde de registros
                    ALLTRIM(TRAN(creg,"@E 999,999"))+;           // listados
                    " registros"+;
                    IF(MAX(ltot,ltot_o)>80,&drvtcom.,"")
   IF !("4WIN"$UPPER(drvmarca))
    EJEC
   ENDI
   cpord=or_i                                           // restaura ordenacao
   SET PRINTER TO (drvporta)                            // finaliza o relatorio
   SET DEVI TO SCRE
   SET(_SET_DELETED,dele_atu)                           // restaura visao dos reg apagados
   GO brw_reg                                           // reposiciona o ponteiro
   IF tps=2                                             // se vai para arquivo/video
    BROWSE_REL(arq_,2,3,MAXROW()-2,78,.f.)              // mostra o arquivo gravado
   ENDI
   RESTSCREEN(0,0,MAXROW(),79,brw_tela)                 // restaura a tela e
  ENDI                                                  // do arquivo
 ENDI
ENDI
RETU NIL

/*
   Sintaxe: QUEBRA_BRW()
   Funcao.: pega campos/tituos para quebra da impressao da consulta
   Retorna: arranjo com as quebras
*/
STATIC FUNC QUEBRA_BRW()
LOCAL menucp:="", clivre:=.f., msg, qb_:={}, cpqb_, cpod_, cpti_, ;
      op_qb:=0, tela_qb:=SAVESCREEN(0,0,MAXROW(),79), x_, i_
PRIV cod_sos:=14
IF nivelop>=NIV_CRI_LIVRE         // verifica se usuario autorizado a fazer
 menucp="|* * Quebra livre * *"   // quebra livre
ENDI
x_=ALIAS()                         // monta menu de campos com
DO WHIL LEN(x_)>0                  // todas os arquivos relacionadas
 k_=PARSE(@x_,"|")                 // arquivo atual
 nc=EVAL(&("{||"+k_+"->(FCOU())}"))// numero de campos do arquivo
 FOR i=1 TO nc                     // monta menu de campos, exceto invisivel
  IF !("I"==sistema[EVAL(qualsis,k_),O_CAMPO,i,O_CRIT])
   menucp+="|"+sistema[EVAL(qualsis,k_),O_CAMPO,i,O_TITU]
  ENDI
 NEXT
 i_=1                                  // pega nome dos arq relacionados
 DO WHIL LEN(&k_.->(DBRELATION(i_)))>0 // ao arq principal
  IF LEN(x_)>0
   x_+="|"
  ENDI
  x_+=&k_.->(ALIAS(DBRSELECT(i_)))     // nome do arq relacionado
  i_++                                 // proximo relacionamento
 ENDD
ENDD
DO WHILE .t.                      // vamos montar varias quebras...
 msg:=cpqb_:=cpod_:=cpti_ := ""   // inicializa variaves da quebra
 DO WHIL op_qb=0                  // escolhes os campos de cada quebra
  IF LEN(msg)>0                   // mostra campos escolhidos
   op_0=DBOX(SUBS(msg,2),,50,,NAO_APAGA,"QUEBRA")
  ENDI
  op_0=DBOX(SUBS(menucp,2),,6,E_MENU,,"CAMPOS PARA QUEBRA")
  IF op_0!=0                      // escolheu um campo
   op_1=op_0
   IF nivelop>=NIV_CRI_LIVRE      // se tem autorizacao para quebra
    IF op_1=1                     // livre, entao faz...
     clivre=.t.
     EXIT
    ENDI
    op_1--                        // faz op_1 a subscricao da coluna
   ENDI
   ii=0
   cp_=""                                         // inicializa campo esolhido
   x_=ALIAS()                                     // arquivo principal
   DO WHIL LEN(x_)>0                              // corre todas os arquivos
    k_=PARSE(@x_,"|")                             // para pegar campo escolhido
    nc=EVAL(&("{||"+k_+"->(FCOU())}"))            // numero de campos do arquivo
    FOR i=1 TO nc                                 // desprezando campo invisieis
     IF !("I"==sistema[EVAL(qualsis,k_),O_CAMPO,i,O_CRIT])
      ii++
     ENDI
     IF ii=op_1                                   // campo escolhido?
      IF k_==ALIAS()                              // se for o arq principal nao coloca alias()
       cp_=FIEL(i)
      ELSE                                        // arq relacionado coloca o alias()
       cp_=k_+"->"+&k_.->(FIEL(i))
      ENDI
      ms_=sistema[EVAL(qualsis,k_),O_CAMPO,i,O_MASC] // mascara do cp escolhido
      ti_=sistema[EVAL(qualsis,k_),O_CAMPO,i,O_TITU] // mascara do cp escolhido
      EXIT
     ENDI
    NEXT
    IF LEN(cp_)>0                                 // se ja achou o cp
     EXIT                                         // cai fora...
    ENDI
    i_=1
    DO WHIL LEN(&k_.->(DBRELATION(i_)))>0         // pega todas as relacoes
     IF LEN(x_)>0                                 // deste arquivo
      x_+="|"
     ENDI
     x_+=&k_.->(ALIAS(DBRSELECT(i_)))             // nome do arq relacionado
     i_++                                         // nome da relacao
    ENDD
   ENDD
   IF TYPE(cp_) $ "MU"                // se tipo MEMO ou INDEFINIDO...
    ALERTA(3)                         // ... nao da' para usar
    DBOX("Campo "+MAIUSC(ti_)+" n„o|pode ser usado para quebra",,,,,"ATEN€ŽO!")
    LOOP
   ENDI
   cpod_+=IF(LEN(cpod_)>1,"+","")+;
          TRANSCAMPO(.f.,cp_)          // concatena campos escolhidos para ordenacao
   cp_=TRANSCAMPO(.f.,cp_,,.f.)        // transforma para caracter
   msg +="|"+ti_
   cpqb_+=IF(LEN(cpqb_)>1,"+"+CHR(34)+" - "+CHR(34)+"+","")+cp_  // concatena campos escolhidos
   cpti_+=IF(LEN(cpti_)>1,", ","")+ti_ // titulo default da quebra
  ELSE
   EXIT                                // termino da escolha de cps da quebra
  ENDI
 ENDD
 IF clivre                             // vai fazer quebra livre
  cpqb_=SPAC(210)
  msg="A EXPRESSŽO ABAIXO DEVER ESTAR DE ACORDO COM|"+;
      "A SINTAXE DA LINGUAGEM PARA EVITAR ERRO DE PROCESSAMENTO|*|"+;
      "F10=CAMPOS DO ARQUIVO|*|INFORME A EXPRESSŽO PARA QUEBRA"
  DO WHILE .T.
   SET KEY K_F10 TO ve_campos          // habilita F10 para ver campos DBF
   cpqb_=DBOX(msg,,,,,SEPLETRA("* QUEBRA  LIVRE *",1),cpqb_,"@S50")
   SET KEY K_F10 TO                    // desabilita F10
   IF LASTKEY()=K_ESC
    cpqb_:=cpod_ := ""                 // cancelou...
    EXIT
   ENDI
   cpod_=cpqb_                         // exp de ordenacao = exp da quebra
   tp_crit=TYPE(cpqb_)
   IF tp_crit="UI"                     // se expressao=indeterminado
    tp_crit=VALTYPE(&cpqb_.)           // existe funcao fora da clipper.lib
   ENDI                                // entao avalia o conteudo da expressao
   IF tp_crit $ "CND"                  // so ordena tipos caracter/numerico/data
    IF tp_crit="N"                     // transf p/ caracter ordem tp numerica
     cpqb_="STR("+ALLTRIM(cpqb_)+")"
     cpod_="STR("+ALLTRIM(cpod_)+")"
    ELSEIF tp_crit="D"                 // transf p/ caracter ordem tp data
     cpqb_="DTOC("+ALLTRIM(cpqb_)+")"
     cpod_="DTOS("+ALLTRIM(cpqb_)+")"
    ENDI
    EXIT                               // vamos retornar, ordenacao ajustada
   ENDI
   ALERTA(3)                           // ordenacao livre invalida
   DBOX("EXPRESSŽO ILEGAL!",15)        // vamos avisar...
  ENDD
  cpqb_=ALLTRIM(cpqb_)                 // tira brancos da expressao
  cpod_=ALLTRIM(cpod_)
 ENDI
 RESTSCREEN(0,0,MAXROW(),79,tela_qb)   // restaura tela original
 IF !EMPTY(cpqb_)                      // escolheu uma quebra
  IF LEN(cpti_)>0                      // coloca : no default do titulo
   cpti_+=":"
  ENDI
  cpti_ = LEFT(cpti_+SPAC(80),80)      // pede o titulo para a quebra
  msg="Informe um t¡tulo para ser impresso ao lado|esquerdo do campo da quebra"
  cpti_=DBOX(msg,,,,,"TITULO DA QUEBRA",cpti_,"@S50")
  IF LASTKEY()=K_ESC
   cpqb_:=cpod_ := ""                  // cancelou...
   EXIT
  ENDI
  AADD(qb_,{cpqb_,cpod_,RTRIM(cpti_)}) // imcrementa vetor de quebras
  ALERTA(1)                            // beep! e
  msg="Sim|N„o"                        // ve se usuario quer outra quebra
  msgt="CRIAR QUEBRA "+ALLTRIM(STR(LEN(qb_)+1))
  cod_sos=1
  ii=DBOX(msg,,,E_MENU,,msgt)
  IF ii!=1                             // se desistiu,
   EXIT                                // prossegue impressao
  ENDI
 ELSE
  EXIT                                 // nenhuma quebra feita...
 ENDI
ENDD
RETU qb_                               // retorna vetor de quebras

/*
   Sintaxe: CABCONS(<ExpC1> <,ExpC2> )
   Funcao.: Imprime cabecalho da consulta na impressora (pai)
              ExpC1 = titulo da consulta
              ExpC2 = titulo extra
   Retorna: Linha de impressao do proximo registro
*/
STATIC FUNC CABCONS(cb_1,tit_rel)
pg++
@ 1,ltot-18 SAY DATE()                   // data do sistema
@ 1,ltot-7  SAY TRAN(pg,"Pag 999")       // numero da pagina
//@ 2,0 SAY IMPAC(PADC(TRIM(nemp),ltot))   // nome da empresa
@ 3,0 SAY PADC(TRIM(tit_rel),ltot)       // titulo informado
@ 4,0 SAY IMPAC(cb_1)                    // titulo das colunas
@ 5,0 SAY REPL("=",MAX(ltot,ltot_o))
RETU 6

/*
   Sintaxe: CABCONS_O()
   Funcao.: Imprime cabecalho da consulta na impressora (filho)
              ExpC1 = titulo da consulta
              ExpC2 = titulo extra
   Retorna: Linha de impressao do proximo registro
*/
STATIC FUNC CABCONS_O(cl,cb_1)
@ cl++,0 SAY IMPAC(PADL(cb_1,MAX(ltot,ltot_o)))              // titulo das colunas
@ cl++,0 SAY IMPAC(PADL(REPL("-",ltot_o),MAX(ltot,ltot_o)))  // justificado a direita
RETU cl

/*
   Sintaxe: SEPARA_IMP( <ExpC> )
     Funcao.: Separa atributos de campos da coluna para impressao
              verifica a possibilidade da formula ser um campo numerico
              ExpC = atributos (nome do campo/mascara/titulo/validacao)
     Retorna: NIL
*/
STATIC FUNC SEPARA_IMP(cp_atr)
LOCAL x
SEPARA(cp_atr)                        // separa atributos da coluna
x=AT("@E",UPPER(cp_))                 // posicao do @E dentro da formula
IF tp_cp="C" .AND.;                   // se a formula for caracter,
   UPPER(cp_masc)="@X" .AND.;         // sua mascara for @X, ter @E
   x>0 .AND. LEFT(cp_,5)="TRAN("      // dentro da formula e comecar com TRAN(
 tp_cp="N"                            // entao e' um formula numerica
 cp_masc=SUBS(cp_,x)                  // pega mascara desta formula
 cp_masc=LEFT(cp_masc,LEN(cp_masc)-2)
 cp_=SUBS(cp_,6,x-8)                  // pega somente a formula
ENDI
RETU NIL

/*
   Sintaxe: TROCA_BRW()
   Funcao.: Troca os arquivos do browse
   Retorna: NIL
*/
STATIC FUNC TROCA_BRW()
IF br_w == br_outro    // se for a janela de baixo
 br_reg_out = RECNO()  // salva situacao e
 SELE (m_origem)       // passa para a janela de cima
 br_w = br_origem
 GO br_reg_ori
ELSE                   // esta' na janela de cima
 br_reg_ori = RECNO()  // salva situacao e
 SELE (outro_db)       // passa para a janela de baixo
 br_w = br_outro
 GO br_reg_out
ENDI
RETU NIL

/*
   Sintaxe: LDBEDIT( <ExpL> )
   Funcao.: Carrega parametros de consulta
            se .t. le consulta dos discos e apresenta menu
   Retorna: .t. se teve sucesso.
*/
STATIC FUNC LDBEDIT(lecons)
LOCAL aqdbe, naq, qarq, cor_, ret_:=.t., sos_cod:=cod_sos, leat_,;
      tela_brw:=SAVESCREEN(0,0,MAXROW(),79), i_, l_mp, c_mp, x_, k_
IF ! USED()                                          // nao existe DBF aberto
 RETU .f.
ENDI
cod_sos=27
leat_=.t.
IF lecons                                            // se quer ler consultas gravadas
 DBOX("AGUARDE!",,,,NAO_APAGA)
 aqdbe=drvdbf+"DB*."+LEFT(ALIAS(),3)                 // mascara dos arquivos
 qarq=ADIR(aqdbe)                                    // capta arquivo do disco
 IF qarq>0                                           // existe alguma consulta gravada?
  PRIV l_arq[qarq+1], v_arq[qarq+1]
  ADIR(aqdbe,l_arq)                                  // monta vetor com os titulos
  i_=0
  FOR i=qarq TO 1 STEP -1                            // de cada consulta
   naq=drvdbf+l_arq[i]
   REST FROM (naq) ADDI
   IF TYPE("db_qprg")="U" .OR. qual_prg==db_qprg
    i_++
    v_arq[i_+1]=db_aqcom+"³"+l_arq[i]
   ENDI
   RELE ALL LIKE db_*                                 // libera variaveis com "DB"
  NEXT
  If i_>0
   v_arq[1]="* Definir nova consulta *"               // primeira opcao do menu
   volta_ac=.t.
   RESTSCREEN(0,0,MAXROW(),79,tela_brw)
   DO WHIL volta_ac
    volta_ac=.f.
    msg=""                                            // tira os espacos dos titulos
    AEVAL(v_arq,{|ms|;                                // da consulta
                  IF(ms!=NIL,msg+="|"+ALLTRIM(PARSE(ms,"³")),"");
                };
    )
    l_mp=IF(TYPE("lin_menu")="N",lin_menu+2,NIL)      // coordenadas do menu
    c_mp=IF(TYPE("col_menu")="N",col_menu+8,NIL)      // apresenta menu
    op_co=DBOX(SUBS(msg,2),l_mp,c_mp,E_MENU,,"CONSULTAS DEFINIDAS|(DEL=APAGA)")
    IF volta_ac                                       // quer apagar a consulta
     pos_=RAT("³",v_arq[op_co])
     IF pos_>3                                        // evita matar opcao sem aquivo
      naq=drvdbf+SUBS(v_arq[op_co],pos_+1)
      i_=ALLTRIM(UPPE(LEFT(v_arq[op_co],pos_-1)))
      ALERTA()                                        // pede confirmacao
      msg="Cancelar a opera‡„o|Efetivar exclus„o"
      op_=DBOX(msg,8,,E_MENU,,"EXCLUINDO|¯ "+i_+" ®")
      IF op_=2                                        // se confirmou exclusao elimina
       ERAS &naq.                                     // arquivo de atributos da consulta
       ADEL(v_arq,op_co)                              // exclui consulta do menu
      ENDI
     ENDI
    ENDI
   ENDD
   RELE ALL LIKE db_*                                 // libera variaveis com "DB"
   db_1rela:=db_2rela := ""
   db_zoom=.f.
   IF op_co=0                                         // nao quis ler consulta
    ret_=.f.
   ELSEIF op_co>1
    op_=v_arq[op_co]                                  // consulta escolhida
    br_tit=ALLTRIM(PARSE(@op_,"³"))                   // extrai o nome do arquivo
    br_arq=drvdbf+op_
    REST FROM (br_arq) ADDI                            // le variaveis do disco
    pas = "1"
    tit_cons[1]=ALLTRIM(br_tit)                       // titulo da consulta
    IF db_zoom                                        // se janela tem zoom
     li_sup=3; li_inf=22; co_sup=3; co_inf=77         // ajusta as coordanadas
     br_w:nTop   := li_sup                            // da janela e do browse
     br_w:nbottom:= li_inf
     br_w:nleft  := co_sup
     br_w:nright := co_inf
    END IF
    ind_rela=db_indrela                               // indice utilizado para relacionar
    DO WHILE .t.
     xdb_rela=LEFT(db_&pas.rela,LEN(db_&pas.rela)-1)
     DO WHIL LEN(xdb_rela)>0                          // restabelece relations
      n_cp=ALLTRIM(PARSE(@xdb_rela,"³"))
      SETARELA(n_cp)
     ENDD
     cmr_=db_&pas.cmr                                 // marcacao de reg
     FOR t=1 TO db_&pas.qtdc                          // remonta todas colunas
      tt=RIGHT(STR(100+t,3),2)
      cargox=db_&pas.carg&tt.
      cp_ =PARSE(@cargox,"³")                         // conteudo
      cp_masc=PARSE(@cargox,"³")                      // mascara
      cp_titu=PARSE(@cargox,"³")                      // titulo
      cp_when=PARSE(@cargox,"³")                      // pre-validacao
      cp_crit=PARSE(@cargox,"³")                      // validacao
      br_w:addcolumn(tbcolumnnew(cp_titu,&("{||"+IF(TYPE(cp_)=="M","MEMOLINE("+cp_+")","TRAN("+cp_+",["+cp_masc+"])")+"}")))
      br_w:getcolumn(t):cargo = db_&pas.carg&tt.
      br_w:getcolumn(t):width = db_&pas.tam&tt.       // tamanho da coluna
      br_w:getcolumn(t):colorblock = &("{||IF(DELE(),{3,2},IF("+cmr_+",{5,2},{1,2}))}")
     NEXT
     br_w:freeze = db_&pas.freeze                     // coluna congelada
     IF br_w:freeze != 0
      br_w:getcolumn(br_w:freeze+1):colsep := " Û "
      br_w:configure()
     ENDI
     criterio=db_&pas.arqf                            // filtro
     cpord=db_&pas.expo                               // ordem
     chv_rela=db_&pas.chvr                            // ligacao entre janelas
     ind_ord=db_&pas.ind_ord                          // indice atual
     br_w:cargo         := {criterio,cpord,chv_rela,ind_ord,cmr_}
     br_w:gobottomblock := {||FIM_ARQ()}
     br_w:gotopblock    := {||INI_ARQ()}
     br_w:skipblock     := {|n|MOV_PTR(n)}
     PEGACHV2()
     INDTMP()
     IF pas = "1"
      br_reg_ori = IF(FOUND(),RECNO(),1)
      IF TYPE("db_outro")=="C".AND.!EMPTY(db_outro)   // tem duas janelas?
       opi = EVAL(qualsis,db_outro)                   // obtem subscricao do DBF no vetor Sistema
       IF !abreoutro(opi)                             // abre o segundo browse
        EXIT
       ENDI
       SETCOLOR(drvcortna)                            // monta janela
       CAIXA(mold,br_outro:ntop-2, br_outro:nleft-1, br_outro:nbottom+1, br_outro:nright+1)
      ELSE
       EXIT
      ENDI
      pas = "2"
      tit_cons[2]=sistema[opi,O_MENS]                 // titulo da segunda janela
      DBSETORDER(ind_rela)                            // vai para utilizado da relacao
     ELSE
      br_reg_out = IF(FOUND(),RECNO(),1)              // segunda janela
      SELE (m_origem)
      br_w = br_origem
      GO br_reg_ori
      br_outro:colorspec := drvcortna+","+INVCOR(drvcortna)+","+drvcorenf+","+drvcorget+","+drvcorhlp
      FORCABRW(.f.)                                   // imprime dados na tela
      EXIT
     ENDI
    ENDD
    leat_=.f.
   ENDI
  ELSE
   RESTSCREEN(0,0,MAXROW(),79,tela_brw)              // restaura tela
  ENDI
 ELSE
  RESTSCREEN(0,0,MAXROW(),79,tela_brw)               // restaura tela
 ENDI
ENDI
IF leat_
 IF col_cp!=NIL                                      // passou arranjo das colunas
  estr_dbf=DBSTRUCT()                                // campos dos arquivo
  ct_cp=0
  FOR i=1 TO LEN(col_cp)
   t=ASCAN(estr_dbf,{|db_|UPPER(col_cp[i])==db_[1]}) // ve se a coluna e cp do arquivo
   IF t>0
    MONTA_COL()                                      // e' um campo do arquivo
   ELSE
    ct_cp++                                          // nao e' campo do arquivo
    br_w:addcolumn(tbcolumnnew(col_cp[i],&("{||"+col_cp[i]+"}")))
    i_=IF(TYPE("col_tit[i]")!="UE".AND.!EMPTY(col_tit[i]),col_tit[i],"")
    x_=LEN(&(col_cp[i]))                             // tamanho da coluna
    br_w:getcolumn(ct_cp):width := x_
    br_w:getcolumn(ct_cp):colorblock := &("{||IF(DELE(),{3,2},IF("+cmr_+",{5,2},{1,2}))}")
    x_="@X"                                          // mascara default
    IF LEFT(col_cp[i],5)="TRAN("                     // vamos tentar pegar um mascara p/ o cp
     t=RAT("[",col_cp[i])                            // separa os limitadores da mascara
     k=RAT("]",col_cp[i])
     IF t>0 .AND. t<k                                // achamos vamos pega-la..
      x_=SUBS(col_cp[i],t+1,k-t-1)
      t=RAT(",[",col_cp[i])                          // separa somente o campo
      IF t>0
       col_cp[i]=SUBST(col_cp[i],6,t-6)
      ENDI
     ENDI
    ENDI
    br_w:getcolumn(ct_cp):cargo := col_cp[i]+"³"+x_+"³"+i_+"³³V³"+VALTYPE(col_cp[i])
   ENDI
   IF TYPE("col_tit[i]")!="UE" .AND. !EMPTY(col_tit[i])
    br_w:getcolumn(ct_cp):heading := col_tit[i]
   ENDI
  NEXT
 ELSE                                                // monta consulta com todos
  estr_dbf=DBSTRUCT()                                // os campos do arquivo
  ct_cp=0
  FOR t=1 TO LEN(estr_dbf)
   IF !("I"==sistema[op_sis,O_CAMPO,t,O_CRIT])       // exceto os invisiveis...
    MONTA_COL()
   END IF
  NEXT
 ENDI
 IF LEN(chv_rela)>0                                  // tem relacionamento
  PEGACHV2()                                         // pega faixa
  INI_ARQ()                                          // vai para o inicio do arquivo
 ENDI
 br_w:gobottomblock := {||FIM_ARQ()}
 br_w:gotopblock    := {||INI_ARQ()}
 br_w:skipblock     := {|n|MOV_PTR(n)}
 IF !EMPTY(criterio) .OR. !EMPTY(cpord)              // tem filtro ou ordem inicial
  INDTMP()                                           // cria indice temporario
  INI_ARQ()                                          // vai para o inicio do arquivo
 ENDI
 br_w:cargo := {criterio,cpord,chv_rela,INDEXORD(),cmr_} // grada nova configuracao
ENDI
RELE ALL LIKE db_*                                   // libera variaveis
cod_sos=sos_cod
RETU ret_                                            // .t. montou consulta com sucesso

/*
   Sintaxe: MONTA_COL()
   Funcao.: Enche uma coluna da edita com atributos de campo
   Retorna: NIL
*/
STATIC FUNC MONTA_COL
M->ms:=sistema[op_sis,O_CAMPO,t,O_MASC]     // mascara
M->tm:=LEN(TRAN(&(FIELD(t)),M->ms))         // conteudo
M->tm:=IF(M->tm=0,34,M->tm)                 // tamanho da coluna
IF LEFT(M->ms,2)="@S"                       // mascara truncada
 M->tm:=VAL(SUBS(M->ms,3))                  // ajusta tamanho e mascara
 IF estr_dbf[t,2]!="M"
  M->ms:=ALLTRIM(SUBS(M->ms,AT(ALLTRIM(STR(M->tm)),M->ms)+LEN(ALLTRIM(STR(M->tm)))))
 END IF
END IF
ct_cp++
br_w:addcolumn(;                            // inicializa coluna
       tbcolumnnew(sistema[op_sis,O_CAMPO,t,O_TITU],;
                      &("{||"+;
                        IF(estr_dbf[t,2]=="M",;
                           "MEMOLINE("+estr_dbf[t,1]+")",;
                           "TRAN("+estr_dbf[t,1]+",["+M->ms+"])";
                        )+"}";
                       );
       );
     )
br_w:getcolumn(ct_cp):cargo := estr_dbf[t,1]+"³"+M->ms+"³"+sistema[op_sis,O_CAMPO,t,O_TITU]+"³"+;
                               sistema[op_sis,O_CAMPO,t,O_WHEN]+"³"+sistema[op_sis,O_CAMPO,t,O_CRIT]+"³"+;
                               sistema[op_sis,O_CAMPO,t,O_HELP]+"³"+sistema[op_sis,O_CAMPO,t,O_CMD]
br_w:getcolumn(ct_cp):width := M->tm
br_w:getcolumn(ct_cp):colorblock := &("{||IF(DELE(),{3,2},IF("+cmr_+",{5,2},{1,2}))}")
RETU

/*
   Sintaxe: SEPARA( <ExpC> )
   Funcao.: Separa atributos de campos da coluna da consulta
              ExpC = atributos (nome do campo/mascara/titulo/validacao)
   Retorna: NIL
*/
STATIC FUNC SEPARA(cp_atr)
cp_ =PARSE(@cp_atr,"³")     // conteudo
cp_masc=PARSE(@cp_atr,"³")  // mascara
cp_titu=PARSE(@cp_atr,"³")  // titulo
cp_when=PARSE(@cp_atr,"³")  // pre-validacao
cp_crit=PARSE(@cp_atr,"³")  // validacao (critica)
cp_help=PARSE(@cp_atr,"³")  // help do campo
cp_cmd =PARSE(@cp_atr,"³")  // comando especial
tp_cp= TYPE(cp_)            // tipo da coluna
IF tp_cp="UI"               // se tipo indefinido
 tp_cp = VALTYPE(cp_)       // tenta pegar o conteudo do campo
 IF tp_cp = "UI"            // se ainda continua indefinido
  tp_cp="C"                 // forca caracter
 ENDI
ENDI
RETU NIL

/*
   Sintaxe: DIR_CUR()
   Funcao.: Muda direcionamento do cursor dentro da funcao EDITA() quando
            o TAB e' acionado
   Retorna: NIL
*/
STATIC FUNC DIR_CUR
dir_cur=IF(dir_cur=4,1,dir_cur+1)
@ br_w:nbottom+1,br_w:nleft+posi_cur+5 SAY CHR(VAL(SUBS(di_tecl,dir_cur*2-1,2)))
RETU NIL

/*
   Sintaxe: COLNOVA()
   Funcao.: Cria uma nova coluna na consulta
   Retorna: NIL
*/
STATIC FUNC COLNOVA
LOCAL brw_tela, ar_, i, ii, db:="", msg:="", qt_ind, op_ind
PRIV cod_sos:=1
brw_tela = SAVESCREEN(0,0,MAXROW(),79)                 // salva tela e monta
FOR i=1 TO nss                                         // menu dos arquivos possiveis
 IF sistema[i,O_ARQUI,O_NOME]!=ALIAS(VAL(m_origem)) .AND. ;
    IF(EMPTY(outro_db),.t.,sistema[i,O_ARQUI,O_NOME]!=ALIAS(VAL(outro_db))) .AND.;
    sistema[i,O_OUTROS,O_NIVEL]<=nivelop .AND.;
    LEN(sistema[i,O_INDIC])>0
  msg+="|"+sistema[i,O_MENU]
  db+=RIGHT(STR(1000+i),3)
 ENDI
NEXT
IF LEN(msg) <= 0                                       // nao existe arq a escolher
 ALERTA()
 DBOX("N„o h  mais arquivos dispon¡veis",15,,3,,"ATEN€ŽO!, "+usuario)
 KEYB CHR(K_ESC)
ELSE
 tit="SELECIONE O ARQUIVO|DO QUAL SER MOSTRADO O CAMPO"
 op_a=DBOX(SUBS(msg,2),,,E_MENU,,tit)                  // escolhe um arquivo
 ar_:=SELECT()
 IF op_a>0                                             // escolheu...
  op_a=VAL(SUBS(db,op_a*3-2,3))                        // subscricao de "sistema"
  db=sistema[op_a,O_ARQUI,O_NOME]                      // nome do arquivo (sem dir)
  IF USEARQ(db)                                        // abre o arquivo
   op_ind=1                                            // indice 'default`
   qt_ind=LEN(sistema[op_a,O_INDIC])                   // qde de indices do arquivo
   IF ATAIL(sistema[op_a,O_CHAVE])="codlan"         // o ntx de relacionamento nao pode...
    qt_ind--
   ENDI
   IF qt_ind>1                                         // escolhe um conjunto de indice
    msg=""
    FOR i=1 to qt_ind
     msg+="|"+sistema[op_a,O_CONSU,i]
    NEXT
    op_ind=DBOX(SUBS(msg,2),,,E_MENU,,"SELECIONE O INDICE")
    IF op_ind>1
     DBSETORDER(op_ind)
    ENDI
   ENDI
   SELE (ar_)
   IF PEGARELA(.f.)                                    // pega campos de relacionamentos
    msg=""
    SELE (db)
    FOR i=1 TO FCOU()                                  // menu de campos
     IF !("I"==sistema[op_a,O_CAMPO,i,O_CRIT])         // exceto os invisiveis...
      msg+="|"+sistema[op_a,O_CAMPO,i,O_TITU]
     ENDI
    NEXT
    op_0=DBOX(SUBS(msg,2),,,E_MENU,,"CAMPO A MOSTRAR NA NOVA COLUNA")
    IF LASTKEY()!=K_ESC .AND. op_0 > 0                 // escolheu um campo
     ii=0
     FOR i=1 TO FCOU()                                 // acha campo escolhido
      IF !("I"==sistema[op_a,O_CAMPO,i,O_CRIT])
       ii++
      ENDI
      IF ii=op_0
       op_0=i
       EXIT
      ENDI
     NEXT
     v_ar=READVAR()                                   // titulo da coluna
     &v_ar.:=sistema[op_a,O_CAMPO,op_0,O_TITU]        // contera' o titulo do campo
     cp_masc:=sistema[op_a,O_CAMPO,op_0,O_MASC]       // mascara
     cp_ =ALLTRIM(STR(op_ind))+"}"+cp_+"|"+;       // expressao para relacionar
          db+"->"+FIEL(op_0)
    ELSE
     cp_=" "
    ENDI
   ELSE
    cp_=" "
   ENDI
  ENDI
 ENDI
 SELE (ar_)                                           // seleciona arquivo original
 f10=.t.
 KEYB CHR(K_CTRL_W)                                   // forca saida do get pendente
ENDI
RETU NIL

/*
   Sintaxe: PEGARELA( <ExpL> )
   Funcao.: Monta menu com arquivos e campos para relacionamento
              ExpL = .t. relacao entre duas janelas
                     .f. relacao entre colunas
   Retorna: .t. se teve sucesso.
*/
STATIC FUNC PEGARELA(fl)
LOCAL tit_chv:="", msg:="", op_0:=0, cp_rela:="", ii
PRIV cod_sos:=31
op_x = EVAL(qualsis,ALIAS())                // subscricao do arquivo atual
FOR i=1 TO FCOU()                           // monta menu com os campos do
 IF !("I"==sistema[op_x,O_CAMPO,i,O_CRIT])  // arquivo, exceto os invisiveis
  msg+="|"+sistema[op_x,O_CAMPO,i,O_TITU]
 ENDI
NEXT                                        // titulo da DBOX()
tit="RELACIONAMENTO|*|ESCOLHA O CAMPO PARA|SINCRONIZAR OS ARQUIVOS|ESC=FIM|*"
IF fl
 chv_rela=""                                // vai sincronizar duas janelas
ENDI
temrela=.f.
DO WHIL .t.                                 // escolhe um campo
 op_0=DBOX(SUBS(msg,2),,,E_MENU,,tit+tit_chv,,,op_0)
 IF LASTKEY()=K_ESC .OR. op_0<=0
  EXIT                                      // cancelou ou ja terminou
 ENDI
 ii=0                                       // procura campo escolhido
 FOR i=1 TO FCOU()
  IF !("I"==sistema[op_x,O_CAMPO,i,O_CRIT]) // despreza os invisiveis
   ii++
  ENDI
  IF ii=op_0
   op_0=i
   EXIT
  ENDI
 NEXT
 cp_ = FIEL(op_0)                           // campo escolhido
 IF TYPE(cp_)="M"
  DBOX("Campo ilegal",,,3,,"ATEN€ŽO!")      // campo memo nao pode...
  LOOP
 ELSE
  temrela=.t.                               // atualiza o titulo da DBOX()
  tit_chv+="|"+MAIUSC(sistema[op_x,O_CAMPO,op_0,O_TITU])+","
  cp_=TRANSCAMPO(.f.,cp_,op_0)              // transforma campo em caracter
  IF fl
   chv_rela+="+"+ALIAS()+"->("+cp_+")"      // chave de relacionamento entre janelas
  ENDI
  cp_rela+="+"+cp_                          // mais um campo de sincronismo?
  op_0=DBOX("Prosseguir|Informar outro campo",,,E_MENU,,"RELACIONAMENTO POR"+tit_chv)
  IF op_0!=2
   cp_=SUBS(cp_rela,2)                      // sincronismo terminado
   EXIT
  ENDI
 ENDI
ENDD
RETU temrela

/*
   Sintaxe: SETARELA( <ExpC> )
   Funcao.: Estabelece relacionamento de arquivos na consulta
              ExpC = parametros de relacionamento
   Retorna: .t. se relacionou
*/
STATIC FUNC SETARELA(p_cp)
op_ind=1                           // indice 'default`
IF VAL(p_cp)>0                     // existe um indice?
 op_ind=VAL(p_cp)                  // vamos utiliza-lo
 p_cp=SUBS(p_cp,AT("}",p_cp)+1)    // arruma expressao de relacionamento
ENDI
p_m=RAT("->",p_cp)
p_b=AT("|",p_cp)
IF p_m>0 .AND. p_b>0               // existe campo e arq para o relacionamento
 c_rel=LEFT(p_cp,p_b-1)            // campo ou expressao para a relacao
 a_u=SUBS(p_cp,p_b+1,(p_m-1)-p_b)  // nome do arquivo que sera' relacionado
 a_r_=SELEC()
 IF USEARQ(a_u)                    // abre arquivo e seus indices
  DBSETORDER(op_ind)         // indice escolhido...
  SELE (a_r_)
  ja=.f.
  FOR t=1 TO 99                    // verifica se a relacao ja' foi feita
   x=DBRSELECT(t)
   IF x>0
    IF UPPER(a_u) == ALIAS(x)
     ja=.t.                        // existe o relacionamento
     EXIT
    ENDI
   ENDI
  NEXT
  IF !ja                           // relaciona se nao tem o relacionamento
   SET RELA ADDI TO &c_rel. INTO &a_u.
  ENDI
 ELSE
  CLOSE ALL                        // ocorreu erro de abertura de arquivo
  BREAK                            // cancela toda a operacao
 ENDI
ENDI
RETU (p_m>0 .AND. p_b>0)           // retorna .t. se relacionou

* \\ Final de ADR_FUNC.PRG
GAS-Pro v4.0

[Ÿ]
 0 

Documento … Imprimir



001

























 0 
 1 










 0 
 1 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
€	 CLASSESb–H CLASSESCODECLA_INCLCODE
CLA_ANT_SECODE
CLA_CRIA_SCODE
CLA_GERA_SCODE
CLA_GRAVA_CODECLA_TELACODECLA_GETSCODECLA_GET1CODEC_ETEXTENDCODE	_SYMSTARTSYMSTARTSYMBOLSSYMBOLS_SYMENDSYMENDNULLBEGDATA_DATADATA_SYMPBDATA_SYMPDATA_SYMPEDATA_CONSTCONST_MSGMSG_BEGBSSBEGBSS_BSSBSS_ENDBSSENDBSSDGROUP˜ @õ$˜ @†‰˜ @s  ˜ @+	ã˜ @« 
`˜ @) Þ˜ @ï˜ @Ù#˜ @}y˜ H  ï˜ h  Ë˜ `¸˜ h  GAS-Pro v1.1
003008019074001001031001004000176001
 Grupo.....:      Codigo....:
 Nome:
 CPF:                  RG:
 Endereco:                                 Numero:
 Bairro:
 Cidade:                           CEP:            UF:
 Fone..:                Profissao:
 Nascido em:                           UF:     Data:
 Est. civil:         em:
       Casado na cidade:                            UF:
 Local Trabalho:
 Setor:                               Fone:
 Rua:                                 N£m.:
 Bairro:
 Cidade:                           CEP:            UF:
[Ÿ]
Consulta~~28
Manuten‡„o~~27            
[Ÿ]
 5 
 1 
Por codigo

 1 
 2 
[Ÿ]
Contratos
Contratos



-1 
 1 
-1 
-1 
 0 
-1 
 0 
 0 
 0 
 0 
grupo
C
E
!9
 2 
 2 
 1 
 14 
 0 
Grupo

PTAB(grupo,'ARQGRUP',1)
GRUPO n„o existe na tabela

Entre com o grupo ou |tecle F8 para consulta em tabela
VDBF(6,56,20,77,'ARQGRUP',{'grup','inicio','final'},1,'grup')
 0 
 0 


codigo
C
E
99999
 5 
 5 
 1 
 31 
 0 
Codigo

codigo >=ARQGRUP->inicio .and. codigo <=ARQGRUP->final
CODIGO n„o aceit vel

Entre com o n£mero do contrato

 0 
 0 


situacao
C
E
9
 1 
 1 
 0 
 0 
 0 
Situa‡Æo

situacao $ [12]
SITUA€ÆO n„o aceit vel
[1]
Este campo identifica a situa‡Æo atual do contrato|
MTAB([1=Ativo|2=Cancelado],[SITUA€ÆO])
 0 
 0 


abertura_
D
E
@D
 8 
 8 
 0 
 0 
 0 
Dat.Abertura

 

DATE()
Entre com a data da Abertura do contrato
DATE()
 0 
 0 


circular
C
E
999
 3 
 3 
 0 
 0 
 0 
Circular

 


N£mero da £ltima circular para este contrato

 0 
 0 


 0 
 0 
 0 
GAS-Pro v3.0
011003022079001002023001013000176001
  Numero  Codigo Circ. Valor pago
========= ====== ===== ==========
  -
[Ÿ]
 5 
BXREC
Taxas p/Transferir
numop
numop+ano+numero

011









 0 
 0 
-1 
 66 
 0 
 2 
 3 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
Ano
ano
99
 2 
C
 3 
 1 


          










Numero
numero
999999
 6 
C
 3 
 4 


          










Codigo
codigo
999999
 6 
C
 3 
 11 


          










Circular
tipo+'-'+circ

 5 
C
 3 
 18 


          










Valor pago
valorpg
@E 999,999.99
 10 
N
 3 
 24 


          










 9 
Nome da empresa
nemp

 0 
 0 
 32 

T¡tulo aplica‡„o
nsis

 0 
 0 
 25 

Data do sistema
DTOC(DATE())

 0 
 0 
 8 

Nome do mˆs
NMES(DATE())

 0 
 0 
 8 

Dia da semana
NSEM(DATE())

 0 
 0 
 7 

N£mero da p gina
TRAN(pg_,'9999')

 0 
 0 
 4 

C¢digo relat¢rio
"ADM_R040"

 0 
 0 
 8 

T¡tulo a definir
titrel

 0 
 0 
 30 

Hora da emiss„o
hora_rel_

 0 
 0 
 5 

 0 
 0 
 0 
 0 
procedure guias
/*
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
 \ Empresa.: PresServ Inform tica - Limeira (019)452.6623
 \ Programa: GUIAS.PRG
 \ Data....: 04-11-03
 \ Sistema.: Administradora - RECEP€„O
 \ Funcao..: Gerenciador do subsistema de emiss„o de guias
 \ Analista: Ademilson Pedro Bom
 \ Criacao.: GAS-Pro v4.0n
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/

#include "adrbig.ch"    // inicializa constantes manifestas

PARA lin_menu,col_menu
PRIV op_sis, tela_fundo:=SAVESCREEN(0,0,MAXROW(),79), l_s, c_s, l_i, c_i, l_a

op_sis=EVAL(qualsis,"GUIAS")
IF nivelop<sistema[op_sis,O_OUTROS,O_NIVEL]        // se usuario nao tem permissao,
 ALERTA()                                          // entao, beep, beep, beep
 DBOX(msg_auto,,,3)                                // lamentamos e
 RETU                                              // retornamos ao menu
ENDI
cn:=fgrep :=.f.

#ifdef COM_LOCK
 IF LEN(pr_ok)>0                                   // se a protecao acusou
  ? pr_ok                                          // erro, avisa e
  QUIT                                             // encerra a aplicacao
 ENDI
#endi

t_fundo=SAVESCREEN(0,0,MAXROW(),79)                // salva tela do fundo
op_cad=1
DO WHIL op_cad!=0
 criterio=""
 RESTSCREEN(0,0,MAXROW(),79,t_fundo)               // restaura tela do fundo
 cod_sos=5 ; cn=.f.
 CLEA TYPEAHEAD                                    // limpa o buffer do teclado
 fgrep=.f.
 SET KEY K_F3 TO                                   // retira das teclas F3 e F4 as
 SET KEY K_F4 TO                                   // funcoes de repeticao e confirmacao
 msg="Inclus„o~1|"+;
     "Manuten‡„o~2|"+;
     "Consulta~3"
 op_cad=DBOX(msg,lin_menu,col_menu,E_MENU,NAO_APAGA,MAIUSC(sistema[op_sis,O_MENU]),,,op_cad)
 IF op_cad!=0                                      // se escolheu uma opcao
  Tela_fundo=SAVESCREEN(0,0,MAXROW(),79)           // salva a tela para ROLATELA()
  PARAMETROS(dbfparam)
  SELE A                                           // e abre o arquivo e seus indices

  #ifdef COM_REDE
   IF !USEARQ(sistema[op_sis,O_ARQUI,O_NOME],.f.,20,1)
                                                   // se falhou a abertura do
    RETU                                           // arquivo volta ao menu anterior
   ENDI
  #else
   USEARQ(sistema[op_sis,O_ARQUI,O_NOME])
  #endi

  SET KEY K_F9 TO veoutros                         // habilita consulta em outros arquivos
 ENDI
 DO CASE
  CASE op_cad=01                                   // inclus„o
   op_menu=INCLUSAO
   IF AT("D",exrot[op_sis])=0                      // se usuario pode fazer inclusao
    GUI_INCL()                                     // neste arquivo chama prg de inclusao
   ELSE                                            // caso contrario vamos avisar que
    ALERTA()                                       // ele nao tem permissao para isto
    DBOX(msg_auto,,,3)
   ENDI

  CASE op_cad=02                                   // manuten‡„o
   op_menu=ALTERACAO
   cod_sos=7
   EDIT()

  CASE op_cad=03                                   // consulta
   op_menu=PROJECOES
   cod_sos=8
   EDITA(05,02,MAXROW()-4,77)

 ENDC
 SET KEY K_F9 TO                                   // F9 nao mais consultara outros arquivos
 CLOS ALL                                          // fecha todos arquivos abertos
ENDD
RETU

PROC GUI_incl(reg_cop)  // inclusao no arquivo GUIAS
LOCAL getlist:={},cabem:=1,rep:=ARRAY(FCOU()),ult_reg:=RECN(),dbfseq_,;
      ctl_r, ctl_c, ctl_w, t_f3_, t_f4_, dele_atu:=SET(_SET_DELETED,.f.)
PRIV op_menu:=INCLUSAO, sq_atual_, tem_borda, criterio:="", cpord:=""
FOR i=1 TO FCOU()                                  // cria/declara privadas as
 msg=FIEL(i)                                       // variaveis de memoria com
 PRIV &msg.                                        // o mesmo nome dos campos
NEXT                                               // do arquivo
IF reg_cop!=NIL                                    // quer repetir todo o reg atual
 FOR i=1 TO FCOU()                                 // para cada campo,
  msg=FIEL(i)                                      // salva o conteudo
  rep[i]=&msg.                                     // para repetir
 NEXT
ELSE
 AFILL(rep,"")                                     // eche com valor vazio
ENDI
t_f3_=SETKEY(K_F3,{||rep()})                       // repeticao reg anterior
t_f4_=SETKEY(K_F4,{||conf()})                      // confirma campos com ENTER
ctl_w=SETKEY(K_CTRL_W,{||nadafaz()})               // enganando o CA-Clipper...
ctl_c=SETKEY(K_CTRL_C,{||nadafaz()})
ctl_r=SETKEY(K_CTRL_R,{||nadafaz()})

#ifdef COM_REDE
 GUI_CRIA_SEQ()                                    // cria dbf de controle de cp sequenciais
 FOR i=1 TO FCOU()                                 // cria/declara privadas as
  msg="sq_"+FIEL(i)                                // variaveis de memoria com
  PRIV &msg.                                       // o mesmo nome dos campos
 NEXT                                              // do arquivo com extensao _seq
#endi

DO WHIL cabem>0
 cod_sos=6
 rola_t=.f.                                        // flag se quer rolar a tela
 SELE GUIAS
 GO BOTT                                           // forca o
 SKIP                                              // final do arquivo
 
 /*
    cria variaveis de memoria identicas as de arquivo, para inclusao
    de registros
 */
 FOR i=1 TO FCOU()
  msg=FIEL(i)
  M->&msg.=IF((fgrep .OR. reg_cop!=NIL).AND.!EMPT(rep[1]),rep[i],&msg.)
 NEXT
 DISPBEGIN()                                       // apresenta a tela de uma vez so
 GUI_TELA()
 INFOSIS(.t.)                                      // exibe informacao no rodape' da tela
 DISPEND()
 GUI_GERA_SEQ()
 cabem=DISKSPACE(;
          IF(;
             LEN(sistema[op_sis,O_ARQUI,O_DIR_DBF])<2.OR.sistema[op_sis,O_ARQUI,O_DIR_DBF]="\",;
             0,;
             ASC(sistema[op_sis,O_ARQUI,O_DIR_DBF])-64;
          );
       )
 cabem=INT((cabem-2048)/GUIAS->(RECSIZE()))
 IF cabem<1                                        // mais nenhum!!!
  ALERTA()
  msg="Verifique ESPA€O EM DISCO, "+usuario
  DBOX(msg,,,,,"INCLUSŽO INTERROMPIDA!")           // vamos parar por aqui!
  EXIT
 ENDI
 SELE 0                                            // torna visiveis variaveis de memoria
 GUI_GET1(INCLUI)                                  // recebe campos
 SELE GUIAS
 IF LASTKEY()=K_ESC                                // se cancelou
  cabem=0                                          // prepara saida da inclusao
  LOOP
 ENDI

 #ifdef COM_REDE
  GO BOTT                                          // vamos bloquear o final do
  SKIP                                             // arq para que nehum outro
  BLOREG(0,.5)                                     // usuario possa incluir
 #endi

 APPEND BLANK                                      // inclui reg em branco no dbf
 FOR i=1 TO FCOU()                                 // para cada campo,
  msg=FIEL(i)                                      // salva o conteudo
  rep[i]=M->&msg.                                  // para repetir
  REPL &msg. WITH rep[i]                           // enche o campo do arquivo
 NEXT

 #ifdef COM_REDE
  UNLOCK                                           // libera o registro e
  COMMIT                                           // forca gravacao
 #else
  IF RECC()-INT(RECC()/20)*20=0                    // a cada 20 registros
   COMMIT                                          // digitados forca gravacao
  ENDI
 #endi

 ult_reg=RECN()                                    // ultimo registro digitado
 GUI_REL(ult_reg)                               // imprime relat apos inclusao
 IF reg_cop!=NIL                                   // estava na consulta e quis rep o campo
  sq_atual_=NIL
  EXIT                                             // cai fora...
 ENDI
ENDD

#ifdef COM_REDE
 GUI_ANT_SEQ()                                     // restaura sequencial anterior
 SELE GUIAS
#endi

GO ult_reg                                         // para o ultimo reg digitado
SETKEY(K_F3,t_f3_)                                 // restaura teclas de funcoes
SETKEY(K_F4,t_f4_)
SET(_SET_DELETED,dele_atu)                            // ecluidos visiveis/invisiveis
SETKEY(K_CTRL_W,ctl_w)
SETKEY(K_CTRL_C,ctl_c)
SETKEY(K_CTRL_R,ctl_r)
RETU

PROC GUI_REL(ult_reg)  // imprime relatorio apos inclusao
DO WHIL .t.
 msg_t="EMISSŽO DE GUIAS"
 SAVE SCREEN                     // salva a tela

 #ifdef COM_REDE
  tps=TP_SAIDA(,,.t.)            // escolhe a impressora
  IF LASTKEY()=K_ESC             // se teclou ESC
   EXIT                          // cai fora...
  ENDI
  IF tps=2 .OR. PREPIMP(msg_t)   // se nao vai para video conf impressora pronta
   CON_RX01(tps,0,ult_reg)
 #else
  IF PREPIMP(msg_t)              // confima preparacao da impressora
   CON_RX01(0,0,ult_reg)
 #endi

  REST SCREEN                    // restaura tela
  msg="Prosseguir|Outra c¢pia"
	op_=1 //DBOX(msg,,,E_MENU,,msg_t)  // quer emitir outra copia?
  IF op_=2
   LOOP                          // nao quer...
  ENDI
 ENDI
 EXIT
ENDD
RETU


#ifdef COM_REDE
 PROC GUI_ANT_SEQ(est_seq)     // restaura sequencial anterior
 SELE GUI_SEQ     // seleciona arquivo de controle de sequencial
 BLOARQ(0,.5)     // esta estacao foi a ultima a incluir?
 IF sq_atual_ == numero
  REPL numero WITH sq_numero
  REPL intlan WITH sq_intlan
 ENDI
 UNLOCK           // libera DBF para outros usuarios
 COMMIT           // atualiza cps sequenciais no disco
 RETU
#endi


PROC GUI_CRIA_SEQ   // cria dbf de controle de campos sequenciais
LOCAL dbfseq_:=sistema[op_sis,O_ARQUI,O_DIR_DBF]+"GUI_seq" // arq temporario
SELE 0                          // seleciona area vazia
IF !FILE(dbfseq_+".dbf")        // se o dbf nao existe
 DBCREATE(dbfseq_,{;            // vamos criar a sua estrutura
		    {"numero"    ,"C",  8, 0},;
                    {"intlan"    ,"C",  8, 0};
                  };
 )
ENDI
USEARQ(dbfseq_,.f.,,,.f.)       // abre arquivo de cps sequencial
IF RECC()=0                     // se o dbf foi criado agora
 BLOARQ(0,.5)                   // inclui um registro que tera
 APPEND BLANK                   // os ultomos cps sequenciais
 SELE GUIAS
 IF RECC()>0                    // se o DBF nao estiver
  SET ORDER TO 0                // vazio, entao enche DBF seq
  GO BOTT                       // com o ultimo reg digitado
  REPL GUI_SEQ->numero WITH numero
  REPL GUI_SEQ->intlan WITH intlan
  DBSETORDER(1)                 // retorna ao indice principal
 ENDI
 SELE GUI_SEQ                   // seleciona arq de sequencias
 UNLOCK                         // libera DBF para outros usuarios
 COMMIT                         // atualiza cps sequenciais no disco
ENDI
RETURN

PROC GUI_GERA_SEQ()

#ifdef COM_REDE
 LOCAL ar_:=SELEC()
#else
 LOCAL reg_:=RECNO(),ord_ind:=INDEXORD()
#endi


#ifdef COM_REDE
 SELE GUI_SEQ
 BLOARQ(0,.5)
 sq_numero=GUI_SEQ->numero
 sq_intlan=GUI_SEQ->intlan
#else
 DBSETORDER(0)
 GO BOTT
#endi

M->numero=LPAD(STR(VAL(numero)+1),08,[0])
IF VAL(M->numero)=1
 M->numero=LPAD(RIGHT(DTOC(DATE()),2)+[000001],08,[0])
ENDI
M->intlan=LPAD(STR(VAL(intlan)+1),08,[0])

#ifdef COM_REDE
 GUI_GRAVA_SEQ()
 sq_atual_=GUI_SEQ->numero
 UNLOCK                                            // libera o registro
 COMMIT
 SELE (ar_)
#else
 DBSETORDER(ord_ind)
 GO reg_
#endi

RETU

PROC GUI_GRAVA_SEQ
REPL numero WITH M->numero
REPL intlan WITH M->intlan
RETU

PROC GUI_tela     // tela do arquivo GUIAS
tem_borda=.t.
l_s=Sistema[op_sis,O_TELA,O_LS]           // coordenadas da tela
c_s=Sistema[op_sis,O_TELA,O_CS]
l_i=Sistema[op_sis,O_TELA,O_LI]
c_i=Sistema[op_sis,O_TELA,O_CI]
SETCOLOR(drvtittel)
vr_memo=NOVAPOSI(@l_s,@c_s,@l_i,@c_i)     // pega posicao atual da tela
CAIXA(mold,l_s,c_s,l_i,c_i)               // monta caixa da tela
i=LEN(sistema[op_sis,O_MENS])/2
@ l_s,c_s-1+(c_i-c_s+1)/2-i SAY " "+MAIUSC(sistema[op_sis,O_MENS])+" "
SETCOLOR(drvcortel)
@ l_s+01,c_s+1 SAY " N£mero:            Emiss„o:"
@ l_s+02,c_s+1 SAY "ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ"
@ l_s+03,c_s+1 SAY " N§ Contrato:"
@ l_s+04,c_s+1 SAY " Admiss„o...:"
@ l_s+05,c_s+1 SAY " Sai Taxas..:                                       Cobr:"
@ l_s+11,c_s+1 SAY "ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ"
@ l_s+12,c_s+1 SAY " Pessoa a Atend:"
@ l_s+14,c_s+1 SAY " M‚dico...:"
RETU

PROC GUI_gets     // mostra variaveis do arquivo GUIAS
LOCAL getlist := {}, ord_, chv_
GUI_TELA()
SETCOLOR(drvcortel+","+drvcorget+",,,"+corcampo)
PTAB([],'MEDICOS',1)
PTAB(PADR(SUBSTR(M->IDE_MAQ,2),4)+[GUI],[IMPPAR],1)
CRIT("",,"14")
@ l_s+01 ,c_s+10 GET  numero;
                 PICT sistema[op_sis,O_CAMPO,01,O_MASC]

@ l_s+03 ,c_s+15 GET  contrato;
                 PICT sistema[op_sis,O_CAMPO,06,O_MASC]
		 CRIT(sistema[op_sis,O_CAMPO,06,O_CRIT],,"1|2|3|4|5|6|7")

@ l_s+12 ,c_s+18 GET  nome;
		 PICT sistema[op_sis,O_CAMPO,07,O_MASC]

@ l_s+14 ,c_s+13 GET  medico;
		 PICT sistema[op_sis,O_CAMPO,09,O_MASC]
		 CRIT(sistema[op_sis,O_CAMPO,09,O_CRIT],,"8|9|10|11|12")

CRIT("",,"2|3|4|5|6|7")
CLEAR GETS
RETU

PROC GUI_get1(tp_mov)     // capta variaveis do arquivo GUIAS
LOCAL getlist := {}, ord_, chv_
PRIV  blk_guias:=.t.

IF tp_mov=INCLUI
 DO WHILE .t.
  rola_t=.f.
  SET KEY K_ALT_F8 TO ROLATELA
  SETCOLOR(drvcortel+","+drvcorget+",,,"+corcampo)
  @ l_s+01 ,c_s+10 GET numero;
		   PICT sistema[op_sis,O_CAMPO,01,O_MASC]
  CLEA GETS
  CRIT("",,"14")
  @ l_s+03 ,c_s+15 GET  contrato;
		   PICT sistema[op_sis,O_CAMPO,06,O_MASC]
		   DEFINICAO 6
		   MOSTRA sistema[op_sis,O_FORMULA,1]
		   MOSTRA sistema[op_sis,O_FORMULA,2]
		   MOSTRA sistema[op_sis,O_FORMULA,3]
		   MOSTRA sistema[op_sis,O_FORMULA,4]
		   MOSTRA sistema[op_sis,O_FORMULA,5]
		   MOSTRA sistema[op_sis,O_FORMULA,6]
		   MOSTRA sistema[op_sis,O_FORMULA,7]

  @ l_s+12 ,c_s+18 GET  nome;
		   PICT sistema[op_sis,O_CAMPO,07,O_MASC]
		   DEFINICAO 7

  @ l_s+14 ,c_s+13 GET  medico;
		   PICT sistema[op_sis,O_CAMPO,09,O_MASC]
		   DEFINICAO 9
		   MOSTRA sistema[op_sis,O_FORMULA,8]
		   MOSTRA sistema[op_sis,O_FORMULA,9]
		   MOSTRA sistema[op_sis,O_FORMULA,10]
		   MOSTRA sistema[op_sis,O_FORMULA,11]
		   MOSTRA sistema[op_sis,O_FORMULA,12]

  READ
  SET KEY K_ALT_F8 TO
  IF rola_t
   ROLATELA()
   LOOP
  ENDI
  IF LASTKEY()!=K_ESC .AND. drvincl .AND. op_menu=INCLUSAO
   IF !CONFINCL()
    LOOP
   ENDI
  ENDI
  EXIT
 ENDD
ENDI
PTAB(CONTRATO,'INSCRITS',1)
PTAB(CONTRATO,'TAXAS',1)
PTAB([],'MEDICOS',1)
PTAB(MEDICO,'MEDICOS',1)
PTAB(PADR(SUBSTR(M->IDE_MAQ,2),4)+[GUI],[IMPPAR],1)
data:=date()
IF tp_mov=EXCLUI .OR. tp_mov=FORM_INVERSA
 IF 1=3
  IF !EMPTY(IMPPAR->codlan)
   TIRA_LANC("IMPPAR",LEFT(IMPPAR->codlan,16))
  ENDI
 ENDI
 IF !EMPTY(ALIAS())
  DELE
 ENDI
ELSEIF tp_mov=INCLUI .OR. tp_mov=RECUPERA .OR. tp_mov=FORM_DIRETA
 IF (op_menu=INCLUSAO .AND. LASTKEY()!=K_ESC) .OR. op_menu!=INCLUSAO
  IF !PTAB(PADR(SUBSTR(M->ide_maq,2),4)+[GUI],[IMPPAR],1)
   ord_=LEN(sistema[EVAL(qualsis,"IMPPAR"),O_CHAVE])
   IF !EMPTY(IMPPAR->codlan)
    chv_=LEFT(IMPPAR->codlan,16)
   ELSE
    IF TYPE("M->intlan")="C" .AND. EMPTY(intlan)
     chv_="GUI-"+M->intlan+"-001"
    ELSE
     chv_="GUI-"+intlan+"-001"
    ENDI
   ENDI
   IF op_menu=INCLUSAO
    data=DATE()
   ELSE
    REPL GUIAS->data WITH DATE()
   ENDI
   PTAB(chv_,"IMPPAR",ord_)
   FAZ_LANC("IMPPAR",chv_)
   REPL IMPPAR->idmaq WITH PADR(SUBSTR(M->ide_maq,2),4),;
        IMPPAR->base WITH [GUI]

   #ifdef COM_REDE
    IMPPAR->(DBUNLOCK())                           // libera o registro
   #endi

  ENDI

  #ifdef COM_REDE
   IF PTAB(PADR(SUBSTR(M->ide_maq,2),4)+[GUI],[IMPPAR],1)
    REPBLO('IMPPAR->docto',{||numero})
   ENDI
  #else
   IF PTAB(PADR(SUBSTR(M->ide_maq,2),4)+[GUI],[IMPPAR],1)
    REPL IMPPAR->docto WITH numero
   ENDI
  #endi

  IF op_menu!=INCLUSAO
   RECA
  ENDI
 ENDI
ENDI
RETU

* \\ Final de GUIAS.PRG
procedure txa_01f9
/*
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
 \ Empresa.: PresServ Inform tica-Limeira (019)452.6623
 \ Programa: TXA_01F9.PRG
 \ Data....: 16-01-97
 \ Sistema.: Administradora - RECEP€„O
 \ Funcao..: F¢rmula (TipCont) a mostrar na tela de TXACONTR
 \ Analista: Ademilson Pedro Bom
 \ Criacao.: Programado manualmente pelo analista
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/

#include "adrbig.ch"    // inicializa constantes manifestas

PRIVA doneresp:=[]

doneresp:= GRUPOS->tipcont+[ Carnˆ:]+GRUPOS->vlcarne+[ F.Pgto.:]+GRUPOS->formapgto+[ ]
doneresp+= IIF(PTAB(GRUPOS->tipcont,'CLASSES',1),ALLTRIM(CLASSES->descricao),[])+[ ]

IF GRUPOS->formapgto<[01]
 RETU LEFT(doneresp,61)
ENDI

IF GRUPOS->formapgto<[05]
 doneresp+=SUBSTR(tbfpgto,(VAL(GRUPOS->formapgto)-1)*13+1,13)
ELSE
 doneresp+=GRUPOS->formapgto
ENDI

RETU LEFT(doneresp,61)  // <- deve retornar um valor qualquer

* \\ Final de TXA_01F9.PRG
GAS-Pro v4.0
005013022069001010045001015001176001
 C¢digo......:
 Descri‡„o...:
 N§ Contratos:
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 A cobran‡a ‚ por per¡odo?:
 (Digite N se a cobran‡a sair por n§ de atendimentos)
 (Digite S se a cobran‡a sair a cada n meses.)
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 Valor J¢ia..:             (      )
               N§Parcelas:     (1¦ a gerar:   )
 Valor Mensal:             (      )
 p/Dependente:             (      )
 Validade do contrato (em meses)....:
 Renova‡„o autom tica no vencimento.:
                      na utiliza‡„o.:
 Valor total dos servi‡os oferecidos:
[Ÿ]
Inclus„o~~26006
Manuten‡„o~~27007
Consulta~~28008
[Ÿ]
 13 
 1 
Classe

 1 
[Ÿ]
Categoria dos Planos
Categoria dos Planos







005
























 0 











 0 
 1 
-1 
-1 
 0 
-1 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
classcod
C
E
99
 2 
 2 
 1 
 16 
 0 
C¢digo

!EMPT(classcod)
Necess rio informar C¢DIGO

Informe um c¢digo para esta categoria

 0 
 1 


descricao
C
E
@!
 35 
 35 
 2 
 16 
 0 
Descri‡„o

!EMPT(descricao)
Informe uma descri‡„o deste tipo de contrato.

Informe o nome desta categoria. Ex.: POPULAR, ESPECIAL,...

 0 
 0 


contrat
N
E
999999
 6 
 6 
 3 
 16 
 0 
Contratos

 


Informe o n£mero de contratos desta categoria|Para categoria VIP, desconsidere esta informa‡„o

 0 
 0 


prior
C
E
!
 1 
 1 
 5 
 29 
 0 
Prior

prior$' SN'
Necess rio informar PRIORIDADE

Os contratos enquadrados nesta categoria|ter„o cobran‡as emitidas periodicamente,|independente de n§ de falecimentos do grupo?

 0 
 0 


vljoia
N
E
99999999.99
 11 
 11 
 9 
 16 
 2 
Valor da J¢ia

!(VLjoia<0.00)
Valor da j¢ia deve ser positivo

Informe o valor da J¢ia do contrato

 0 
 0 


nrparc
N
E
99
 2 
 2 
 10 
 28 
 0 
N§Parcelas
vljoia>0
!(nrparc<0)
NR.Parcelas n„o aceit vel

A j¢ia pode ser parcelada em quantas vezes?

 0 
 0 


parcger
N
E
99
 2 
 2 
 10 
 45 
 0 
N§Parcelas
vljoia>0
!(parcger<1 .OR. parcger>nrparc)
NR.Parcelas a gerar n„o aceit vel|
1
Gerar a partir da parcela de J¢ia de n§...

 0 
 0 


vlmensal
N
E
99999999.99
 11 
 11 
 11 
 16 
 2 
Valor Mensal

!(VLmensal<0.00)
Valor da mensal deve ser positivo

Informe o valor mensal do contrato

 0 
 0 


vldepend
N
E
99999999.99
 11 
 11 
 12 
 16 
 2 
V.p/Dependente

!(VLdepend<0.00)
Valor mensal cobrado a mais por|dependente deve ser maior ou igual a zeros

Informe o valor a ser acrescido por dependente

 0 
 0 


nrmesval
N
E
99
 2 
 2 
 13 
 39 
 0 
V lidade

!(nrmesval<0)
Validade n„o aceit vel

Contratos v lidos por quantos meses?

 0 
 0 


renvenc
C
E
!
 1 
 1 
 14 
 39 
 0 
RenVencto

renvenc$[ SN]
RENVENCTO n„o aceit vel

Os contratos terÆo|renova‡Æo automatica no vencimento?

 0 
 0 


renuso
C
E
!
 1 
 1 
 15 
 39 
 0 
RenUso

renuso$[ SN]
RENUSO n„o aceit vel

Os contratos terÆo|renova‡Æo automatica quando|utilizarem os servi‡os de atendimento/Auxilio?

 0 
 0 


vltotal
N
I
@E 99,999,999.99
 11 
 13 
 0 
 0 
 2 
Valor






 0 
 0 


 4 
Valor
vltotal
@E 99,999,999.99
 16 
 39 
 13 

Valor da J¢ia
(vljoia/vltotal)*100
999.99
 9 
 29 
 6 

Valor Mensal
(vlmensal/vltotal)*100
999.99
 11 
 29 
 6 

V.p/Dependente
(vldepend/vltotal)*100
999.99
 12 
 29 
 6 

 0 
 0 
 0 
 0 
GAS-Pro v4.0
005016023063001010037001015001176001
 Grupo.....:
 Classe....:
 N§.Inicial:             N§.Final:
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 Emitir recibos com no m¡nimo      e no
                    m ximo      processos.
 Comparar admiss„o & atendimento ?
 Intervalo minimo de     dias.
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 Os contratos estar„o remidos ap¢s     taxas
 (por atendimento?  )
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 Ultima circular:      Emiss„o:
        contratos ativos,        participantes
 vivos e     processos pendentes.
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 Emitir circular n§
[Ÿ]
Inclus„o~~26006
Manuten‡„o~~27007
Consulta~~28008
[Ÿ]
 16 
 1 
Grupo

 1 
[Ÿ]
Grupos
Grupos







005
























 0 











 0 
 1 
-1 
-1 
 0 
-1 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
grup
C
E
!!
 2 
 2 
 1 
 14 
 0 
Grupo

!EMPT(grup)
Necess rio informar GRUPO

Entre com o c¢digo do Grupo

 0 
 0 


classe
C
E
99
 2 
 2 
 2 
 14 
 0 
Classe

PTAB(classe,'CLASSES',1)
CLASSE n„o existe na tabela

Informe a categoria dos planos deste grupo.|Para grupo VIP, digite 00
VDBF(6,38,20,77,'CLASSES',{'classcod','descricao','contrat'},1,'classcod',[])
 0 
 0 


inicio
C
E
999999
 6 
 6 
 3 
 14 
 0 
Nr.Inicial

 

IF(classe=[00],[000001],STRZERO(VAL(M->lastcodigo)+1,6))


 0 
 0 


final
C
E
999999
 6 
 6 
 3 
 36 
 0 
Nr.Final

VAL(final)>VAL(inicio)
NR.FINAL n„o aceit vel
IIF(classe=[00],[999999],STRZERO(VAL(inicio)+CLASSES->contrat-1,6))


 0 
 0 


acumproc
N
E
99
 2 
 2 
 5 
 32 
 0 
N§.Processos
!(CLASSES->prior=[S])
!(acumproc<0)
N§.PROCESSOS n„o aceit vel
INT((1+VAL(final)-VAL(inicio))/50)
Informe quantos processos s„o nescess rios|para se emitir recibos.

 0 
 0 


maxproc
N
E
99
 2 
 2 
 6 
 29 
 0 
N§.Processos
!(CLASSES->prior=[S])
maxproc>=acumproc
N§.PROCESSOS n„o aceit vel|Informe o n£mero m ximo de processos |a se incluir na circular
acumproc
Informe o n£mero m ximo de processos|para se emitir na cobran‡a.

 0 
 0 


cpadmiss
C
E
!
 1 
 1 
 7 
 36 
 0 
Comp.AdmissXAtend.
acumproc<maxproc
cpadmiss$[SN]
Digite S ou N|S, n„o ser„o incluidos atendimentos|efetuados antes da admiss„o do contrato.
[S]
Se digitar S, n„o ser„o incluidos atendimentos|efetuados antes da admiss„o do contrato|quando da 1¦Cobran‡a.

 0 
 0 


periodic
N
E
999
 3 
 3 
 8 
 22 
 0 
Periodicidade

!(periodic<0)
PERIODICIDADE n„o aceit vel
IIF(CLASSES->prior=[S],30,INT((VAL(final)-VAL(inicio)+1)*90/500))
Informe o intervalo m¡nimo em dias entre circulares.

 0 
 0 


qtdremir
N
E
999
 3 
 3 
 10 
 36 
 0 
Remido

!(qtdremir<0)
REMIDO n„o aceit vel
acumproc*5
Entre com o n§ de taxas nescess rias para que|o processo fique remido.

 0 
 0 


poratend
C
E
!
 1 
 1 
 11 
 20 
 0 
P/Atend.

poratend$[SN]
Digite|S para deixar de ser remido na utiliza‡„o|ou|N para continuar remido.
[S]
Digite S para considerar uma quantidade|a ser paga por atendimento efetuado|ou N para considerar quantidade total.

 0 
 0 


ultcirc
C
I
999
 3 
 3 
 0 
 0 
 0 
Ultcirc






 0 
 0 


emissao_
D
I
@D
 8 
 10 
 0 
 0 
 0 
Emissao






 0 
 0 


procpend
N
I
999
 3 
 3 
 0 
 0 
 0 
Processos






 0 
 0 


contrat
N
I
999999
 6 
 6 
 0 
 0 
 0 
Contratos






 0 
 0 


partic
N
I
999999
 6 
 6 
 0 
 0 
 0 
Partic.






 0 
 0 


proxcirc
C
E
999
 3 
 3 
 17 
 21 
 0 
N§Proxima Circ.
nivelop=3
proxcirc>=ultcirc.OR.proxcirc=[000]
A Pr¢xima circular deve ser maior|ou igual a| £ltima emitida ou zeros p/ n„o emitir.

Entre com o n£mero da pr¢xima circular ou|zeros se n„o for emitir.

 0 
 0 


 6 
Classe/Categor.
CLASSES->descricao

 2 
 17 
 25 

Ultcirc
ultcirc
999
 13 
 19 
 3 

Emissao
emissao_
@D
 13 
 33 
 8 

Processos
procpend
999
 15 
 10 
 3 

Contratos
contrat
999999
 14 
 2 
 6 

Partic.
partic
999999
 14 
 27 
 6 

 0 
 0 
 0 
 0 
procedure adr_atri
/*
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
 \ Empresa.: PresServ Inform tica - Limeira (019)452.6623
 \ Programa: ADR_ATRI.PRG
 \ Data....: 29-01-04
 \ Sistema.: Administradora - RECEP€„O
 \ Funcao..: Define atributos dos arquivos (sistema[])
 \ Analista: Ademilson Pedro Bom
 \ Criacao.: GAS-Pro v4.0o
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/

#include "adrbig.ch"    // inicializa constantes manifestas


/*
   A adicao das  definicoes dos campos (mascara, titulo, cmd esp, when/defa,
   critica, ajuda) dentro do vetor sistema e' feita atraves da funcao AADD(),
   isto previne erro "memory overbooked" do CA-Clipper, durante a compilacao,
   devido a linha ser muito extensa
*/

sistema[001]={;
            "Recebimentos",;                                // opcao do menu
            "Recebimentos",;                                // titulo do sistema
            {"numero","numop+numero","codigo"},;            // chaves do arquivo
            {"N£mero","Caixa","Contrato"},;                 // titulo dos indices para consulta
            {"01","0801","02"},;                            // ordem campos chaves
            {"BXREC",drvdbf,drvntx},;                       // nome do DBF
            {"BXREC1","BXREC2","BXREC3"},;                  // nomes dos NTX
            {},;                                            // nome dos dbf's relacionados
            {},;                                            // campos de relacionamento
            {1,1,3,11,23,62},;                              // num telas/tela atual/coordenadas
            {1,.t.,.f.},;                                   // nivel acesso/tp chave/pede dir
            {},;                                            // campos do arquivo
            {},;                                            // formula mostradas
            {"nivelop>1","Permitido apenas a usu rios cadastrados|com n¡vel de Manuten‡„o ou Maior"},;// condicao de exclusao de registros
            {"nivelop=3","Para alterar este documento|chame o gerente de sistema"},;// condicao de alteracao de registros
            {"nivelop>1","Permitido apenas a usu rios cadastrados|com n¡vel de Manuten‡„o ou Maior"};// condicao de recupercao de registros
           }

AADD(sistema[001,O_CAMPO],{;            // BXREC
     /* mascara       */    "99999999",;
     /* titulo        */    "Numero",;
     /* cmd especial  */    "",;
     /* default       */    "RIGHT(DTOC(DATE()),2)+[000001]",;
     /* pre-validacao */    "",;
     /* validacao     */    "V",;
     /* help do campo */    "";
                         };
)
AADD(sistema[001,O_CAMPO],{;            // BXREC
     /* mascara       */    "@!",;
     /* titulo        */    "Codigo",;
     /* cmd especial  */    "VDBF(6,3,20,77,'GRUPOS',{'codigo','grupo','nome','endereco'},1,'codigo',[])",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "(BXR_07F9().AND.PTAB(ALLTRIM(codigo),[GRUPOS])).AND.(PTAB(codigo,'TAXAS',1).OR.(1=1)).AND.CAD_04F9(op_menu)~Contrato inv lido |ou inexistente",;
     /* help do campo */    "Informe o n£mero do contrato";
                         };
)
AADD(sistema[001,O_CAMPO],{;            // BXREC
     /* mascara       */    "@!",;
     /* titulo        */    "Cobranca",;
     /* cmd especial  */    "BXR_06F9()",;
     /* default       */    "",;
     /* pre-validacao */    "BXR_06F9()",;
     /* validacao     */    "PTAB(cobranca,[TAXAS],1).or.!EMPT(cobranca)~Necess rio informar COBRANCA",;
     /* help do campo */    "";
                         };
)
AADD(sistema[001,O_CAMPO],{;            // BXREC
     /* mascara       */    "@E 999,999.99",;
     /* titulo        */    "Valor pago",;
     /* cmd especial  */    "BXR_02F9()",;
     /* default       */    "BXR_02F9()",;
     /* pre-validacao */    "!EMPT(cobranca)",;
     /* validacao     */    "valorpg>0.and.!EMPT(BXR_02F9())~VALOR PAGO n„o aceit vel|Digite o valor recebido",;
     /* help do campo */    "Informe o valor pago ou zeros se for retorno.";
                         };
)
AADD(sistema[001,O_CAMPO],{;            // BXREC
     /* mascara       */    "@E 999,999.99",;
     /* titulo        */    "Pago com...",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "valoraux>=valorpg~VALOR INSUFICIENTE para quitar o d‚bito|A T E N € Ç O",;
     /* help do campo */    "Informe o valor pago";
                         };
)
AADD(sistema[001,O_CAMPO],{;            // BXREC
     /* mascara       */    "@D",;
     /* titulo        */    "Emitido em",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "V",;
     /* help do campo */    "";
                         };
)
AADD(sistema[001,O_CAMPO],{;            // BXREC
     /* mascara       */    "",;
     /* titulo        */    "Por",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "V",;
     /* help do campo */    "";
                         };
)
AADD(sistema[001,O_CAMPO],{;            // BXREC
     /* mascara       */    "999999",;
     /* titulo        */    "N§ O.P.",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "V",;
     /* help do campo */    "";
                         };
)
AADD(sistema[001,O_CAMPO],{;            // BXREC
     /* mascara       */    "!9",;
     /* titulo        */    "Grupo",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[001,O_CAMPO],{;            // BXREC
     /* mascara       */    "@!",;
     /* titulo        */    "Filial",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[001,O_CAMPO],{;            // BXREC
     /* mascara       */    "99999999",;
     /* titulo        */    "Num.Lan‡amento",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[001,O_FORMULA],{;          // BXREC - Nome
     /* form mostrar  */    "LEFT(TRAN((GRUPOS->nome),[]),35)",;
     /* lin da formula*/    4,;
     /* col da formula*/    2;
                         };
)
AADD(sistema[001,O_FORMULA],{;          // BXREC - Circ 1 - 4
     /* form mostrar  */    "LEFT(TRAN(BXR_01F9(),[]),48)",;
     /* lin da formula*/    11,;
     /* col da formula*/    2;
                         };
)
AADD(sistema[001,O_FORMULA],{;          // BXREC - Ult.Circular
     /* form mostrar  */    "LEFT(TRAN(GRUPOS->ultcirc,[999]),03)",;
     /* lin da formula*/    6,;
     /* col da formula*/    47;
                         };
)
AADD(sistema[001,O_FORMULA],{;          // BXREC - Situa‡„o
     /* form mostrar  */    "LEFT(TRAN(IIF(GRUPOS->situacao='2',[CANCELADO],[         ])+IF(codigo<[020],[ - Grupo ]+GRUPOS->grupo,[]),[]),22)",;
     /* lin da formula*/    2,;
     /* col da formula*/    23;
                         };
)
AADD(sistema[001,O_FORMULA],{;          // BXREC - Admiss„o
     /* form mostrar  */    "LEFT(TRAN(GRUPOS->admissao,[@D]),10)",;
     /* lin da formula*/    8,;
     /* col da formula*/    12;
                         };
)
AADD(sistema[001,O_FORMULA],{;          // BXREC - Saitxa
     /* form mostrar  */    "LEFT(TRAN(GRUPOS->saitxa,[@R 99/99]),05)",;
     /* lin da formula*/    8,;
     /* col da formula*/    33;
                         };
)
AADD(sistema[001,O_FORMULA],{;          // BXREC - Cobrador
     /* form mostrar  */    "LEFT(TRAN(GRUPOS->cobrador+IIF(PTAB(LEFT(GRUPOS->cobrador,3),[COBRADOR],1),cobrador->nome,[...]),[@!]),25)",;
     /* lin da formula*/    9,;
     /* col da formula*/    25;
                         };
)
AADD(sistema[001,O_FORMULA],{;          // BXREC - Funerais
     /* form mostrar  */    "LEFT(TRAN(GRUPOS->funerais,[99]),02)",;
     /* lin da formula*/    9,;
     /* col da formula*/    12;
                         };
)
AADD(sistema[001,O_FORMULA],{;          // BXREC - Circ.Inicial
     /* form mostrar  */    "LEFT(TRAN(GRUPOS->circinic,[999]),03)",;
     /* lin da formula*/    5,;
     /* col da formula*/    46;
                         };
)
AADD(sistema[001,O_FORMULA],{;          // BXREC - Endere‡o
     /* form mostrar  */    "LEFT(TRAN(xDECRIPT(GRUPOS->endereco),[]),35)",;
     /* lin da formula*/    5,;
     /* col da formula*/    2;
                         };
)
AADD(sistema[001,O_FORMULA],{;          // BXREC - Bairro
     /* form mostrar  */    "LEFT(TRAN(xDECRIPT(GRUPOS->bairro),[]),25)",;
     /* lin da formula*/    6,;
     /* col da formula*/    2;
                         };
)
AADD(sistema[001,O_FORMULA],{;          // BXREC - Cidade
     /* form mostrar  */    "LEFT(TRAN(xDECRIPT(GRUPOS->cidade),[]),25)",;
     /* lin da formula*/    7,;
     /* col da formula*/    2;
                         };
)
AADD(sistema[001,O_FORMULA],{;          // BXREC - CEP
     /* form mostrar  */    "LEFT(TRAN(xDECRIPT(GRUPOS->cep),[@R 99999-999]),09)",;
     /* lin da formula*/    7,;
     /* col da formula*/    29;
                         };
)
AADD(sistema[001,O_FORMULA],{;          // BXREC - Regi„o
     /* form mostrar  */    "LEFT(TRAN(GRUPOS->regiao,[999]),03)",;
     /* lin da formula*/    6,;
     /* col da formula*/    35;
                         };
)
AADD(sistema[001,O_FORMULA],{;          // BXREC - troco
     /* form mostrar  */    "LEFT(TRAN(valoraux-valorpg,[@E 999,999.99]),11)",;
     /* lin da formula*/    17,;
     /* col da formula*/    33;
                         };
)
AADD(sistema[001,O_FORMULA],{;          // BXREC - Filial
     /* form mostrar  */    "LEFT(TRAN(filial,[@!]),02)",;
     /* lin da formula*/    1,;
     /* col da formula*/    23;
                         };
)

sistema[002]={;
            "Endere‡os",;                                   // opcao do menu
            "Endere‡os",;                                   // titulo do sistema
            {"codigo"},;                                    // chaves do arquivo
            {"Contrato"},;                                  // titulo dos indices para consulta
            {"01"},;                                        // ordem campos chaves
            {"ALENDER",drvdbf,drvntx},;                     // nome do DBF
            {"ALENDER1"},;                                  // nomes dos NTX
            {},;                                            // nome dos dbf's relacionados
            {},;                                            // campos de relacionamento
            {1,1,8,2,17,77},;                               // num telas/tela atual/coordenadas
            {1,.f.,.f.},;                                   // nivel acesso/tp chave/pede dir
            {},;                                            // campos do arquivo
            {},;                                            // formula mostradas
            {"nivelop>1","Permitido apenas a usu rios cadastrados|com n¡vel de Manuten‡„o ou Maior"},;// condicao de exclusao de registros
            {"nivelop>1","Permitido apenas a usu rios cadastrados|com n¡vel de Manuten‡„o ou Maior"},;// condicao de alteracao de registros
            {"nivelop>1","Permitido apenas a usu rios cadastrados|com n¡vel de Manuten‡„o ou Maior"};// condicao de recupercao de registros
           }

AADD(sistema[002,O_CAMPO],{;            // ALENDER
     /* mascara       */    "@!",;
     /* titulo        */    "Codigo",;
     /* cmd especial  */    "VDBF(6,31,20,77,'GRUPOS',{'codigo','nome'},4,'codigo')",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "PTAB(codigo,'GRUPOS',1).AND.ALE_01F9().AND.CAD_04F9(op_menu)~CODIGO n„o aceit vel|Tecle F8 para consulta",;
     /* help do campo */    "Entre com o n£mero do contrato|Tecle F8 para consulta";
                         };
)
AADD(sistema[002,O_CAMPO],{;            // ALENDER
     /* mascara       */    "99999999",;
     /* titulo        */    "Numero",;
     /* cmd especial  */    "",;
     /* default       */    "RIGHT(DTOC(DATE()),2)+[000001]",;
     /* pre-validacao */    "",;
     /* validacao     */    "V",;
     /* help do campo */    "";
                         };
)
AADD(sistema[002,O_CAMPO],{;            // ALENDER
     /* mascara       */    "",;
     /* titulo        */    "Endere‡o",;
     /* cmd especial  */    "",;
     /* default       */    "xDECRIPT(GRUPOS->endereco)",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(endereco)~Necess rio informar ENDERE€O do Titular",;
     /* help do campo */    "Informe o Endere‡o para correspondˆncias.|Rua,n£mero,apto, blocl, etc...";
                         };
)
AADD(sistema[002,O_CAMPO],{;            // ALENDER
     /* mascara       */    "",;
     /* titulo        */    "Bairro",;
     /* cmd especial  */    "",;
     /* default       */    "xDECRIPT(GRUPOS->bairro)",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(bairro)~Necess rio informar BAIRRO do Titular",;
     /* help do campo */    "";
                         };
)
AADD(sistema[002,O_CAMPO],{;            // ALENDER
     /* mascara       */    "",;
     /* titulo        */    "Cidade",;
     /* cmd especial  */    "",;
     /* default       */    "xDECRIPT(GRUPOS->cidade)",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(cidade)~Necess rio informar MUNICIPIO para cobran‡a do Titular.",;
     /* help do campo */    "";
                         };
)
AADD(sistema[002,O_CAMPO],{;            // ALENDER
     /* mascara       */    "!!",;
     /* titulo        */    "UF",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "VUF(uf).OR.EMPT(UF)~UNIDADE DA FEDERA€ŽO inv lida",;
     /* help do campo */    "Qual ‚ o estado da federa‡„o";
                         };
)
AADD(sistema[002,O_CAMPO],{;            // ALENDER
     /* mascara       */    "@R 99999-999",;
     /* titulo        */    "CEP",;
     /* cmd especial  */    "",;
     /* default       */    "xDECRIPT(GRUPOS->cep)",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(cep)~Necess rio informar CEP do Titular |com 08 digitos",;
     /* help do campo */    "";
                         };
)
AADD(sistema[002,O_CAMPO],{;            // ALENDER
     /* mascara       */    "@!",;
     /* titulo        */    "Telefone",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    "Informe o n£mero de telefone para|Contato com o contratante";
                         };
)
AADD(sistema[002,O_CAMPO],{;            // ALENDER
     /* mascara       */    "!!!",;
     /* titulo        */    "Cobrador",;
     /* cmd especial  */    "VDBF(6,39,20,77,'REGIAO',{'regiao','cobrador'},2,'cobrador',[!EMPT(cobrador)])",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "PTAB(cobrador,'COBRADOR',1).OR.EMPT(cobrador)~COBRADOR n„o existe na tabela",;
     /* help do campo */    "Digite o c¢digo do COBRADOR que|receber  as Taxas deste contrato,|Tecle F8 para consultar os cobradores.";
                         };
)
AADD(sistema[002,O_CAMPO],{;            // ALENDER
     /* mascara       */    "@D",;
     /* titulo        */    "Data_",;
     /* cmd especial  */    "",;
     /* default       */    "DATE()",;
     /* pre-validacao */    "",;
     /* validacao     */    "V",;
     /* help do campo */    "";
                         };
)
AADD(sistema[002,O_CAMPO],{;            // ALENDER
     /* mascara       */    "",;
     /* titulo        */    "Por",;
     /* cmd especial  */    "",;
     /* default       */    "M->usuario",;
     /* pre-validacao */    "",;
     /* validacao     */    "V",;
     /* help do campo */    "";
                         };
)
AADD(sistema[002,O_CAMPO],{;            // ALENDER
     /* mascara       */    "",;
     /* titulo        */    "Endere‡o",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "V",;
     /* help do campo */    "";
                         };
)
AADD(sistema[002,O_CAMPO],{;            // ALENDER
     /* mascara       */    "",;
     /* titulo        */    "Bairro",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "V",;
     /* help do campo */    "";
                         };
)
AADD(sistema[002,O_CAMPO],{;            // ALENDER
     /* mascara       */    "",;
     /* titulo        */    "Cidade",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "V",;
     /* help do campo */    "";
                         };
)
AADD(sistema[002,O_CAMPO],{;            // ALENDER
     /* mascara       */    "!!",;
     /* titulo        */    "UF",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "V",;
     /* help do campo */    "";
                         };
)
AADD(sistema[002,O_CAMPO],{;            // ALENDER
     /* mascara       */    "@R 99999-999",;
     /* titulo        */    "CEP",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "V",;
     /* help do campo */    "";
                         };
)
AADD(sistema[002,O_CAMPO],{;            // ALENDER
     /* mascara       */    "@!",;
     /* titulo        */    "Telefone",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "V",;
     /* help do campo */    "";
                         };
)
AADD(sistema[002,O_CAMPO],{;            // ALENDER
     /* mascara       */    "!!!",;
     /* titulo        */    "Cobrador",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "V",;
     /* help do campo */    "";
                         };
)
AADD(sistema[002,O_CAMPO],{;            // ALENDER
     /* mascara       */    "",;
     /* titulo        */    "Dgrupo",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "V",;
     /* help do campo */    "";
                         };
)
AADD(sistema[002,O_CAMPO],{;            // ALENDER
     /* mascara       */    "@D",;
     /* titulo        */    "Emitido",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "nivelop=3",;
     /* validacao     */    "",;
     /* help do campo */    "Data da emiss„o de solicita‡„o do endere‡o";
                         };
)
AADD(sistema[002,O_CAMPO],{;            // ALENDER
     /* mascara       */    "@!",;
     /* titulo        */    "Filial",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[002,O_FORMULA],{;          // ALENDER - Nome
     /* form mostrar  */    "LEFT(TRAN(GRUPOS->nome,[]),35)",;
     /* lin da formula*/    1,;
     /* col da formula*/    28;
                         };
)
AADD(sistema[002,O_FORMULA],{;          // ALENDER - Filial
     /* form mostrar  */    "LEFT(TRAN(filial,[@!]),02)",;
     /* lin da formula*/    1,;
     /* col da formula*/    24;
                         };
)


sistema[003]={;
            "Outros Recebimentos",;                         // opcao do menu
            "Outros Recebimentos",;                         // titulo do sistema
            {"numero","numop+numero","codigo"},;            // chaves do arquivo
            {"N£mero","Caixa","Contrato"},;                 // titulo dos indices para consulta
            {"01","0801","02"},;                            // ordem campos chaves
            {"OBXEC",drvdbf,drvntx},;                       // nome do DBF
            {"OBXEC1","OBXEC2","OBXEC3"},;                  // nomes dos NTX
            {},;                                            // nome dos dbf's relacionados
            {},;                                            // campos de relacionamento
            {1,1,3,11,23,62},;                              // num telas/tela atual/coordenadas
            {1,.t.,.f.},;                                   // nivel acesso/tp chave/pede dir
            {},;                                            // campos do arquivo
            {},;                                            // formula mostradas
            {"nivelop>1","Permitido apenas a usu rios cadastrados|com n¡vel de Manuten‡„o ou Maior"},;// condicao de exclusao de registros
            {"nivelop=3","Para alterar este documento|chame o gerente de sistema"},;// condicao de alteracao de registros
            {"nivelop>1","Permitido apenas a usu rios cadastrados|com n¡vel de Manuten‡„o ou Maior"};// condicao de recupercao de registros
           }

AADD(sistema[003,O_CAMPO],{;            // OBXEC
     /* mascara       */    "99999999",;
     /* titulo        */    "Numero",;
     /* cmd especial  */    "",;
     /* default       */    "RIGHT(DTOC(DATE()),2)+[000001]",;
     /* pre-validacao */    "",;
     /* validacao     */    "V",;
     /* help do campo */    "";
                         };
)
AADD(sistema[003,O_CAMPO],{;            // OBXEC
     /* mascara       */    "@!",;
     /* titulo        */    "Codigo",;
     /* cmd especial  */    "VDBF(6,3,20,77,'GRUPOS',{'codigo','grupo','nome','endereco'},1,'codigo',[])",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "(PTAB(ALLTRIM(codigo),[GRUPOS]).AND.OBX_07F9()).AND.(PTAB(codigo,'TAXAS',1).OR.1=1).AND.CAD_04F9(op_menu)~Contrato inv lido |ou inexistente",;
     /* help do campo */    "Informe o n£mero do contrato";
                         };
)
AADD(sistema[003,O_CAMPO],{;            // OBXEC
     /* mascara       */    "@!S20",;
     /* titulo        */    "Cobranca",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(cobranca)~Necess rio informar COBRANCA",;
     /* help do campo */    "";
                         };
)
AADD(sistema[003,O_CAMPO],{;            // OBXEC
     /* mascara       */    "@E 999,999.99",;
     /* titulo        */    "Valor pago",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "!EMPT(cobranca)",;
     /* validacao     */    "valorpg>0~VALOR PAGO n„o aceit vel|Digite o valor recebido",;
     /* help do campo */    "Informe o valor pago ou zeros se for retorno.";
                         };
)
AADD(sistema[003,O_CAMPO],{;            // OBXEC
     /* mascara       */    "@E 999,999.99",;
     /* titulo        */    "Pago com...",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "valoraux>=valorpg~VALOR INSUFICIENTE para quitar o d‚bito|A T E N € Ç O",;
     /* help do campo */    "Informe o valor pago";
                         };
)
AADD(sistema[003,O_CAMPO],{;            // OBXEC
     /* mascara       */    "@D",;
     /* titulo        */    "Emitido em",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "V",;
     /* help do campo */    "";
                         };
)
AADD(sistema[003,O_CAMPO],{;            // OBXEC
     /* mascara       */    "",;
     /* titulo        */    "Por",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "V",;
     /* help do campo */    "";
                         };
)
AADD(sistema[003,O_CAMPO],{;            // OBXEC
     /* mascara       */    "999999",;
     /* titulo        */    "N§ O.P.",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "V",;
     /* help do campo */    "";
                         };
)
AADD(sistema[003,O_CAMPO],{;            // OBXEC
     /* mascara       */    "!9",;
     /* titulo        */    "Grupo",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[003,O_CAMPO],{;            // OBXEC
     /* mascara       */    "@!",;
     /* titulo        */    "Filial",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[003,O_CAMPO],{;            // OBXEC
     /* mascara       */    "99999999",;
     /* titulo        */    "Num.Lan‡amento",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[003,O_FORMULA],{;          // OBXEC - Nome
     /* form mostrar  */    "LEFT(TRAN(GRUPOS->nome,[]),35)",;
     /* lin da formula*/    4,;
     /* col da formula*/    2;
                         };
)
AADD(sistema[003,O_FORMULA],{;          // OBXEC - Circ 1 - 4
     /* form mostrar  */    "LEFT(TRAN(OBX_01F9(),[]),48)",;
     /* lin da formula*/    11,;
     /* col da formula*/    2;
                         };
)
AADD(sistema[003,O_FORMULA],{;          // OBXEC - Ult.Circular
     /* form mostrar  */    "LEFT(TRAN(GRUPOS->ultcirc,[999]),03)",;
     /* lin da formula*/    6,;
     /* col da formula*/    47;
                         };
)
AADD(sistema[003,O_FORMULA],{;          // OBXEC - Situa‡„o
     /* form mostrar  */    "LEFT(TRAN(IIF(GRUPOS->situacao='2',[CANCELADO],[         ])+[ - Grupo ]+GRUPOS->grupo,[]),22)",;
     /* lin da formula*/    2,;
     /* col da formula*/    23;
                         };
)
AADD(sistema[003,O_FORMULA],{;          // OBXEC - Admiss„o
     /* form mostrar  */    "LEFT(TRAN(GRUPOS->admissao,[@D]),10)",;
     /* lin da formula*/    8,;
     /* col da formula*/    12;
                         };
)
AADD(sistema[003,O_FORMULA],{;          // OBXEC - Saitxa
     /* form mostrar  */    "LEFT(TRAN(GRUPOS->saitxa,[@R 99/99]),05)",;
     /* lin da formula*/    8,;
     /* col da formula*/    33;
                         };
)
AADD(sistema[003,O_FORMULA],{;          // OBXEC - Cobrador
     /* form mostrar  */    "LEFT(TRAN(GRUPOS->cobrador,[!!]),02)",;
     /* lin da formula*/    9,;
     /* col da formula*/    33;
                         };
)
AADD(sistema[003,O_FORMULA],{;          // OBXEC - Funerais
     /* form mostrar  */    "LEFT(TRAN(GRUPOS->funerais,[99]),02)",;
     /* lin da formula*/    9,;
     /* col da formula*/    12;
                         };
)
AADD(sistema[003,O_FORMULA],{;          // OBXEC - Circ.Inicial
     /* form mostrar  */    "LEFT(TRAN(GRUPOS->circinic,[999]),03)",;
     /* lin da formula*/    5,;
     /* col da formula*/    46;
                         };
)
AADD(sistema[003,O_FORMULA],{;          // OBXEC - Endere‡o
     /* form mostrar  */    "LEFT(TRAN(xDECRIPT(GRUPOS->endereco),[]),35)",;
     /* lin da formula*/    5,;
     /* col da formula*/    2;
                         };
)
AADD(sistema[003,O_FORMULA],{;          // OBXEC - Bairro
     /* form mostrar  */    "LEFT(TRAN(xDECRIPT(GRUPOS->bairro),[]),25)",;
     /* lin da formula*/    6,;
     /* col da formula*/    2;
                         };
)
AADD(sistema[003,O_FORMULA],{;          // OBXEC - Cidade
     /* form mostrar  */    "LEFT(TRAN(xDECRIPT(GRUPOS->cidade),[]),25)",;
     /* lin da formula*/    7,;
     /* col da formula*/    2;
                         };
)
AADD(sistema[003,O_FORMULA],{;          // OBXEC - CEP
     /* form mostrar  */    "LEFT(TRAN(xDECRIPT(GRUPOS->cep),[@R 99999-999]),09)",;
     /* lin da formula*/    7,;
     /* col da formula*/    29;
                         };
)
AADD(sistema[003,O_FORMULA],{;          // OBXEC - Regi„o
     /* form mostrar  */    "LEFT(TRAN(GRUPOS->regiao,[999]),03)",;
     /* lin da formula*/    6,;
     /* col da formula*/    35;
                         };
)
AADD(sistema[003,O_FORMULA],{;          // OBXEC - troco
     /* form mostrar  */    "LEFT(TRAN(valoraux-valorpg,[@E 999,999.99]),11)",;
     /* lin da formula*/    17,;
     /* col da formula*/    33;
                         };
)
AADD(sistema[003,O_FORMULA],{;          // OBXEC - Filial
     /* form mostrar  */    "LEFT(TRAN(filial,[@!]),02)",;
     /* lin da formula*/    1,;
     /* col da formula*/    23;
                         };
)


sistema[004]={;
            "Consulta Contratos",;                          // opcao do menu
            "Consulta contratos",;                          // titulo do sistema
            {"codigo","nome"},;                             // chaves do arquivo
            {"Contrato","p/Nome"},;                         // titulo dos indices para consulta
            {"01","04"},;                                   // ordem campos chaves
            {"GRUPOS",drvdbf,drvntx},;                      // nome do DBF
            {"GRUPOS1","GRUPOS2"},;                         // nomes dos NTX
            {"TAXAS","ECOB","INSCRITS"},;                   // nome dos dbf's relacionados
            {},;                                            // campos de relacionamento
            {1,1,1,3,22,77},;                               // num telas/tela atual/coordenadas
            {1,.t.,.f.},;                                   // nivel acesso/tp chave/pede dir
            {},;                                            // campos do arquivo
            {},;                                            // formula mostradas
            {"1=3","Mantido pelo sistema de Plano"},;       // condicao de exclusao de registros
            {"1=3","Mantido pelo sistema de Plano"},;       // condicao de alteracao de registros
            {"1=3","Mantido pelo sistema de Plano"};        // condicao de recupercao de registros
           }

AADD(sistema[004,O_CAMPO],{;            // GRUPOS
     /* mascara       */    "@!",;
     /* titulo        */    "Codigo",;
     /* cmd especial  */    "GRU_02F9()",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "PTAB('',[ARQGRUP],1).AND.GRU_01F9()~CODIGO n„o aceit vel|N„o cadastrado na tabela de grupos",;
     /* help do campo */    "Entre com o n£mero do contrato";
                         };
)
AADD(sistema[004,O_CAMPO],{;            // GRUPOS
     /* mascara       */    "!!",;
     /* titulo        */    "Grupo",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[004,O_CAMPO],{;            // GRUPOS
     /* mascara       */    "9",;
     /* titulo        */    "Situa‡„o",;
     /* cmd especial  */    "MTAB([1=Ativo|2=Cancelado],[SITUA€ŽO])",;
     /* default       */    "[1]",;
     /* pre-validacao */    "",;
     /* validacao     */    "situacao $ [12]~SITUA€ŽO n„o aceit vel",;
     /* help do campo */    "Digite 1 para ativo ou 2 para cancelado";
                         };
)
AADD(sistema[004,O_CAMPO],{;            // GRUPOS
     /* mascara       */    "@!",;
     /* titulo        */    "Nome",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(nome)~Necess rio informar NOME",;
     /* help do campo */    "";
                         };
)
AADD(sistema[004,O_CAMPO],{;            // GRUPOS
     /* mascara       */    "@D",;
     /* titulo        */    "Nascto",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    "Informe a data de nascimento do titular";
                         };
)
AADD(sistema[004,O_CAMPO],{;            // GRUPOS
     /* mascara       */    "!!",;
     /* titulo        */    "Est Civil",;
     /* cmd especial  */    "MTAB(tbestciv,[EST CIVIL])",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "(estcivil$tbestciv)~Informe Estado Civil|ou|Tecle F8 para consulta em tabela",;
     /* help do campo */    "Digite o Estado Civil do Titular|ou|Tecle F8 para consulta em tabela";
                         };
)
AADD(sistema[004,O_CAMPO],{;            // GRUPOS
     /* mascara       */    "@R 999.999.999-99",;
     /* titulo        */    "CPF",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "VDV2(cpf).OR.EMPT(cpf)~CPF nÆo aceit vel",;
     /* help do campo */    "Informe o CIC (CPF) do titular";
                         };
)
AADD(sistema[004,O_CAMPO],{;            // GRUPOS
     /* mascara       */    "@!",;
     /* titulo        */    "R.G.",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    "Informe o n£mero do documento do titular";
                         };
)
AADD(sistema[004,O_CAMPO],{;            // GRUPOS
     /* mascara       */    "@!",;
     /* titulo        */    "Endere‡o",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(endereco)~Este endere‡o ser  utilizado na emissÆo das Taxas|para cobran‡a e em todas as telas de consulta.",;
     /* help do campo */    "Informe o Endere‡o para correspondˆncias.|Rua,n£mero,apto, blocl, etc...";
                         };
)
AADD(sistema[004,O_CAMPO],{;            // GRUPOS
     /* mascara       */    "@!",;
     /* titulo        */    "Bairro",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(bairro)~Necess rio informar BAIRRO do Titular",;
     /* help do campo */    "Informe o bairro ou regi„o do titular do contrato";
                         };
)
AADD(sistema[004,O_CAMPO],{;            // GRUPOS
     /* mascara       */    "@!",;
     /* titulo        */    "Cidade",;
     /* cmd especial  */    "",;
     /* default       */    "M->p_cidade",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(cidade)~Necess rio informar MUNICIPIO para cobran‡a do Titular.",;
     /* help do campo */    "Digite a Cidade para correspondˆncia.";
                         };
)
AADD(sistema[004,O_CAMPO],{;            // GRUPOS
     /* mascara       */    "!!",;
     /* titulo        */    "UF",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "VUF(uf).OR.EMPT(UF)~UNIDADE DA FEDERA€ŽO inv lida",;
     /* help do campo */    "Qual ‚ o estado da federa‡„o";
                         };
)
AADD(sistema[004,O_CAMPO],{;            // GRUPOS
     /* mascara       */    "@R 99999-999",;
     /* titulo        */    "CEP",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(cep)~Necess rio informar CEP do Titular |com 08 digitos",;
     /* help do campo */    "Informe o CEP (8 digitos)|para facilitar a correspondˆncia";
                         };
)
AADD(sistema[004,O_CAMPO],{;            // GRUPOS
     /* mascara       */    "@K!",;
     /* titulo        */    "Naturalidade",;
     /* cmd especial  */    "",;
     /* default       */    "M->p_cidade",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    "Informe a naturalidade do titular";
                         };
)
AADD(sistema[004,O_CAMPO],{;            // GRUPOS
     /* mascara       */    "@!",;
     /* titulo        */    "Relig",;
     /* cmd especial  */    "__KEYBOARD([CATOLICO])",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    "Informe a religi„o do titular";
                         };
)
AADD(sistema[004,O_CAMPO],{;            // GRUPOS
     /* mascara       */    "@!",;
     /* titulo        */    "Contato",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    "Digite o nome da pessoa para contato|";
                         };
)
AADD(sistema[004,O_CAMPO],{;            // GRUPOS
     /* mascara       */    "@!",;
     /* titulo        */    "Telefone",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    "Informe o n£mero de telefone para|Contato com o contratante";
                         };
)
AADD(sistema[004,O_CAMPO],{;            // GRUPOS
     /* mascara       */    "99",;
     /* titulo        */    "TipCont",;
     /* cmd especial  */    "VDBF(6,20,20,77,'CLASSES',{'classcod','descricao','vljoia'},1,'classcod',[])",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "PTAB(tipcont,'CLASSES',1)~Informe a Classe deste contrato",;
     /* help do campo */    "Qual a categoria do Contrato?|Tecle F8 para consulta em tabela";
                         };
)
AADD(sistema[004,O_CAMPO],{;            // GRUPOS
     /* mascara       */    "",;
     /* titulo        */    "Vlcarne",;
     /* cmd especial  */    "VDBF(6,52,20,77,'TCARNES',{'tip','pari','vali','parf'},1,'tip',[])",;
     /* default       */    "",;
     /* pre-validacao */    "!(CLASSES->prior=[S])",;
     /* validacao     */    "",;
     /* help do campo */    "Qual o c¢digo de classifica‡Æo do valor do contrato?|Tecle F8 para consultar tabela|Obs.|Ser  preenchido quando for lan‡ada a|venda do contrato.";
                         };
)
AADD(sistema[004,O_CAMPO],{;            // GRUPOS
     /* mascara       */    "99",;
     /* titulo        */    "FormaPgto",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "CLASSES->prior=[S]",;
     /* validacao     */    "",;
     /* help do campo */    "Informe a forma de pagamento desejada|A Taxa de manuten‡Æo ser  emitida cada NN meses.";
                         };
)
AADD(sistema[004,O_CAMPO],{;            // GRUPOS
     /* mascara       */    "",;
     /* titulo        */    "Seguro",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[004,O_CAMPO],{;            // GRUPOS
     /* mascara       */    "@D",;
     /* titulo        */    "Admiss„o",;
     /* cmd especial  */    "DATE()",;
     /* default       */    "DATE()",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(admissao)~Necess rio informar DATA DE ADMISSŽO",;
     /* help do campo */    "Informe a data da Admiss„o neste contrato";
                         };
)
AADD(sistema[004,O_CAMPO],{;            // GRUPOS
     /* mascara       */    "@D",;
     /* titulo        */    "T.Carˆncia",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    "Informe a data de t‚rmino da Carˆncia";
                         };
)
AADD(sistema[004,O_CAMPO],{;            // GRUPOS
     /* mascara       */    "@R 99/99",;
     /* titulo        */    "Saitxa",;
     /* cmd especial  */    "",;
     /* default       */    "SUBSTR(DTOC(admissao+(CLASSES->nrparc*30)),4,2)+RIGHT(DTOC(admissao+(CLASSES->nrparc*30)),2)",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(saitxa).AND.MMAA(saitxa) .or.nivelop==3~Necess rio informar SAITXA (MM/AA)",;
     /* help do campo */    "Informe o Mˆs a sair a 1¦ Taxa.";
                         };
)
AADD(sistema[004,O_CAMPO],{;            // GRUPOS
     /* mascara       */    "99",;
     /* titulo        */    "Dia Pgto.",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "diapgto<[31]~DIA PGTO. n„o aceit vel|Digite um dia entre 01 e 30|ou|deixe com 00 para data igual ao grupo",;
     /* help do campo */    "Informe o melhor dia para pagamento";
                         };
)
AADD(sistema[004,O_CAMPO],{;            // GRUPOS
     /* mascara       */    "!!!",;
     /* titulo        */    "Vendedor",;
     /* cmd especial  */    "VDBF(6,7,20,77,'COBRADOR',{'cobrador','funcao','nome','cidade'},1,'cobrador')",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "PTAB(vendedor,'COBRADOR',1).OR.EMPT(vendedor)~VENDEDOR n„o existe na tabela",;
     /* help do campo */    "Informe o c¢digo do Vendedor|ou|Tecle F8 para consulta em arquivo";
                         };
)
AADD(sistema[004,O_CAMPO],{;            // GRUPOS
     /* mascara       */    "999",;
     /* titulo        */    "Regi„o",;
     /* cmd especial  */    "VDBF(6,38,20,77,'REGIAO',{'codigo','regiao'},1,'codigo')",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "PTAB(regiao,'REGIAO',1).OR.EMPT(VAL(regiao))~REGIŽO n„o existe na tabela",;
     /* help do campo */    "Informe a regi„o ou tecle F8 para busca em tabela";
                         };
)
AADD(sistema[004,O_CAMPO],{;            // GRUPOS
     /* mascara       */    "!!!",;
     /* titulo        */    "Cobrador",;
     /* cmd especial  */    "VDBF(6,39,20,77,'REGIAO',{'regiao','cobrador'},2,'cobrador',[!EMPT(cobrador)])",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "PTAB(cobrador,'COBRADOR',1)~COBRADOR n„o existe na tabela",;
     /* help do campo */    "Digite o c¢digo do COBRADOR que|receber  as Taxas deste contrato,|Tecle F8 para consultar os cobradores.";
                         };
)
AADD(sistema[004,O_CAMPO],{;            // GRUPOS
     /* mascara       */    "@S35",;
     /* titulo        */    "Obs",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    "";
                         };
)
AADD(sistema[004,O_CAMPO],{;            // GRUPOS
     /* mascara       */    "@D",;
     /* titulo        */    "Renovar",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    "Data final para renova‡Æo";
                         };
)
AADD(sistema[004,O_CAMPO],{;            // GRUPOS
     /* mascara       */    "99",;
     /* titulo        */    "Funerais",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "!(funerais<0)~FUNERAIS n„o aceit vel",;
     /* help do campo */    "N£mero de Funerais efetuados|para este processo";
                         };
)
AADD(sistema[004,O_CAMPO],{;            // GRUPOS
     /* mascara       */    "999",;
     /* titulo        */    "Circ.Inicial",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    "Informe o n£mero da 1¦ Circular|que saiu para este contrato.";
                         };
)
AADD(sistema[004,O_CAMPO],{;            // GRUPOS
     /* mascara       */    "999",;
     /* titulo        */    "Ult.Circular",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "PTAB(IIF(CLASSES->prior=[S],M->mgrupvip,grupo)+ultcirc,'CIRCULAR',1).OR.ultcirc=[000].or.nivelop==3~Necess rio informar ULT.CIRCULAR",;
     /* help do campo */    "Entre com o £ltimo n£mero de circular|deste contrato.";
                         };
)
AADD(sistema[004,O_CAMPO],{;            // GRUPOS
     /* mascara       */    "999",;
     /* titulo        */    "Qt.Circulares",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "!(qtcircs<0)~QT.CIRCULARES n„o aceit vel",;
     /* help do campo */    "";
                         };
)
AADD(sistema[004,O_CAMPO],{;            // GRUPOS
     /* mascara       */    "999",;
     /* titulo        */    "Circ.Pagas",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    "Informe a quantidade de Circulares|pagas/retornadas deste contrato";
                         };
)
AADD(sistema[004,O_CAMPO],{;            // GRUPOS
     /* mascara       */    "",;
     /* titulo        */    "Titular",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[004,O_CAMPO],{;            // GRUPOS
     /* mascara       */    "99",;
     /* titulo        */    "Part.Vivos",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[004,O_CAMPO],{;            // GRUPOS
     /* mascara       */    "99",;
     /* titulo        */    "Part.Falecidos",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[004,O_CAMPO],{;            // GRUPOS
     /* mascara       */    "99",;
     /* titulo        */    "N§ Depend.",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[004,O_CAMPO],{;            // GRUPOS
     /* mascara       */    "@D",;
     /* titulo        */    "Ult.Impress.",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[004,O_CAMPO],{;            // GRUPOS
     /* mascara       */    "@D",;
     /* titulo        */    "élt.alter.endere‡o",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[004,O_CAMPO],{;            // GRUPOS
     /* mascara       */    "",;
     /* titulo        */    "UltEnd",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[004,O_CAMPO],{;            // GRUPOS
     /* mascara       */    "@D",;
     /* titulo        */    "Em",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[004,O_CAMPO],{;            // GRUPOS
     /* mascara       */    "",;
     /* titulo        */    "Por",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[004,O_CAMPO],{;            // GRUPOS
     /* mascara       */    "@!",;
     /* titulo        */    "Atendimento:",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    "Informe a quem pertence o atendimento";
                         };
)
AADD(sistema[004,O_CAMPO],{;            // GRUPOS
     /* mascara       */    "@!",;
     /* titulo        */    "Atendimento:",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    "Segunda opcao";
                         };
)
AADD(sistema[04,O_CAMPO],{;            // GRUPOS
     /* mascara       */    "",;
     /* titulo        */    "Ult.Emitida",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[04,O_CAMPO],{;            // GRUPOS
     /* mascara       */    "@D",;
     /* titulo        */    "Ult.Data",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[04,O_CAMPO],{;            // GRUPOS
     /* mascara       */    "@R 999,999.99",;
     /* titulo        */    "Ult.Valor",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[04,O_CAMPO],{;            // GRUPOS
     /* mascara       */    "",;
     /* titulo        */    "eMail",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    "Entre com o endereco de email.";
                         };
)
AADD(sistema[04,O_CAMPO],{;            // GRUPOS
     /* mascara       */    "",;
     /* titulo        */    "SeguroData",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    "Entre com a data da admissao do seguro.";
                         };
)
AADD(sistema[04,O_CAMPO],{;            // GRUPOS
     /* mascara       */    "",;
     /* titulo        */    "SeguroCod",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    "Entre com o Cod.Seguro.";
                         };
)
AADD(sistema[04,O_CAMPO],{;            // GRUPOS
     /* mascara       */    "",;
     /* titulo        */    "SeguroServ",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    "Entre com o Serv.Seguro.";
                         };
)
AADD(sistema[04,O_CAMPO],{;            // GRUPOS
     /* mascara       */    "",;
     /* titulo        */    "NrSorteio",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    "Entre com o Numero Sorteio.";
                         };
)
AADD(sistema[004,O_FORMULA],{;          // GRUPOS - Situacao
     /* form mostrar  */    "LEFT(TRAN(IIF(situacao=[2],[CANCELADO],[         ]),[]),09)",;
     /* lin da formula*/    1,;
     /* col da formula*/    62;
                         };
)
AADD(sistema[004,O_FORMULA],{;          // GRUPOS - Part.Vivos
     /* form mostrar  */    "LEFT(TRAN(particv,[99]),02)",;
     /* lin da formula*/    16,;
     /* col da formula*/    24;
                         };
)
AADD(sistema[004,O_FORMULA],{;          // GRUPOS - Part.Falecidos
     /* form mostrar  */    "LEFT(TRAN(particf,[99]),02)",;
     /* lin da formula*/    16,;
     /* col da formula*/    38;
                         };
)
AADD(sistema[004,O_FORMULA],{;          // GRUPOS - Nome do Cobrado
     /* form mostrar  */    "LEFT(TRAN(IIF(PTAB(cobrador,'COBRADOR',1),COBRADOR->nome,[ ]),[]),30)",;
     /* lin da formula*/    13,;
     /* col da formula*/    16;
                         };
)
AADD(sistema[004,O_FORMULA],{;          // GRUPOS - Nome do Vendedr
     /* form mostrar  */    "LEFT(TRAN(IIF(PTAB(vendedor,'COBRADOR',1),COBRADOR->nome,[ ]),[]),30)",;
     /* lin da formula*/    11,;
     /* col da formula*/    16;
                         };
)
AADD(sistema[004,O_FORMULA],{;          // GRUPOS - grupo
     /* form mostrar  */    "LEFT(TRAN(IIF(!EMPT(grupo),grupo,[  ]),[]),02)",;
     /* lin da formula*/    1,;
     /* col da formula*/    22;
                         };
)
AADD(sistema[004,O_FORMULA],{;          // GRUPOS - Descri‡„o Reg
     /* form mostrar  */    "LEFT(TRAN(REGIAO->regiao,[]),30)",;
     /* lin da formula*/    12,;
     /* col da formula*/    16;
                         };
)
AADD(sistema[004,O_FORMULA],{;          // GRUPOS - Est.Civil
     /* form mostrar  */    "LEFT(TRAN(IIF(!EMPT(estcivil),SUBS(tbestciv,AT(estcivil,tbestciv),11),[]),[]),11)",;
     /* lin da formula*/    4,;
     /* col da formula*/    13;
                         };
)
AADD(sistema[004,O_FORMULA],{;          // GRUPOS - N§ Depend.
     /* form mostrar  */    "LEFT(TRAN(nrdepend,[99]),02)",;
     /* lin da formula*/    16,;
     /* col da formula*/    54;
                         };
)
AADD(sistema[004,O_FORMULA],{;          // GRUPOS - Ult.Impress.
     /* form mostrar  */    "LEFT(TRAN(ultimp_,[@D]),10)",;
     /* lin da formula*/    16,;
     /* col da formula*/    54;
                         };
)
AADD(sistema[004,O_FORMULA],{;          // GRUPOS - élt.alter.ender
     /* form mostrar  */    "LEFT(TRAN(ender_,[@D]),10)",;
     /* lin da formula*/    18,;
     /* col da formula*/    17;
                         };
)
AADD(sistema[004,O_FORMULA],{;          // GRUPOS - UltEnd
     /* form mostrar  */    "LEFT(TRAN(ultend,[]),10)",;
     /* lin da formula*/    18,;
     /* col da formula*/    28;
                         };
)
AADD(sistema[004,O_FORMULA],{;          // GRUPOS - Seguro
     /* form mostrar  */    "LEFT(TRAN(IIF(seguro>0,'SEGURO ('+str(seguro,2)+')',[   ]),[]),12)",;
     /* lin da formula*/    1,;
     /* col da formula*/    28;
                         };
)
AADD(sistema[004,O_FORMULA],{;          // GRUPOS - Qt.Circulares
     /* form mostrar  */    "LEFT(TRAN(qtcircs,[999]),03)",;
     /* lin da formula*/    0,;
     /* col da formula*/    0;
                         };
)
AADD(sistema[004,O_FORMULA],{;          // GRUPOS - periodicidade
     /* form mostrar  */    "LEFT(TRAN(IIF(PTAB(tipcont,'CLASSES',1),ALLTRIM(CLASSES->descricao),[])+[ ]+IIF(formapgto$'01020304',SUBSTR(tbfpgto,(VAL(formapgto)-1)*13+1,13),[]),[]),35)",;
     /* lin da formula*/    9,;
     /* col da formula*/    39;
                         };
)
AADD(sistema[004,O_FORMULA],{;          // GRUPOS - Idade
     /* form mostrar  */    "LEFT(TRAN(IIF(!EMPT(nascto_),LEFT(DLAPSO(DATE(),nascto_),10),[          ]),[]),10)",;
     /* lin da formula*/    3,;
     /* col da formula*/    64;
                         };
)


sistema[005]={;
            "Taxas",;                                       // opcao do menu
            "Cadastro de Taxas",;                           // titulo do sistema
	    {"codigo","codlan"},;       // chaves do arquivo
	    {"Contrato","Cod.Lanc"},;            // titulo dos indices para consulta
	    {"01","16"},;                            // ordem campos chaves
	    {"TAXAS",drvdbf,drvntx},;                       // nome do DBF
	    {"TAXAS1","TAXAS3"},;                  // nomes dos NTX
            {},;                                            // nome dos dbf's relacionados
            {"GRUPOS->codigo"},;                            // campos de relacionamento
            {1,1,13,0,23,79,3,7},;                          // num telas/tela atual/coordenadas/inicio scroll/qtde scroll
            {1,.t.,.f.},;                                   // nivel acesso/tp chave/pede dir
            {},;                                            // campos do arquivo
            {},;                                            // formula mostradas
            {"",""},;                                       // condicao de exclusao de registros
            {"",""},;                                       // condicao de alteracao de registros
            {"",""};                                        // condicao de recupercao de registros
           }

AADD(sistema[005,O_CAMPO],{;            // TAXAS
     /* mascara       */    "@!",;
     /* titulo        */    "Codigo",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
			 };
)
AADD(sistema[005,O_CAMPO],{;            // TAXAS
     /* mascara       */    "@!",;
     /* titulo        */    "Cobranca",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    "";
                         };
)
AADD(sistema[005,O_CAMPO],{;            // TAXAS
     /* mascara       */    "!",;
     /* titulo        */    "Tipo",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
			 };
)
AADD(sistema[005,O_CAMPO],{;            // TAXAS
     /* mascara       */    "999",;
     /* titulo        */    "Circular",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[005,O_CAMPO],{;            // TAXAS
     /* mascara       */    "@D",;
     /* titulo        */    "Emissao",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(emissao_)~Necess rio informar EMISSAO v lida",;
     /* help do campo */    "Data da Emiss„o da Circular|Mantido pela emissao do recibo";
			 };
)
AADD(sistema[005,O_CAMPO],{;            // TAXAS
     /* mascara       */    "@E 999,999.99",;
     /* titulo        */    "Valor",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "valor>0~VALOR n„o aceit vel",;
     /* help do campo */    "";
                         };
)
AADD(sistema[005,O_CAMPO],{;            // TAXAS
     /* mascara       */    "@D",;
     /* titulo        */    "Pagamento",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "nivelop=3",;
     /* validacao     */    "",;
     /* help do campo */    "Informe a data de pagamento/Baixa";
			 };
)
AADD(sistema[005,O_CAMPO],{;            // TAXAS
     /* mascara       */    "@E 999,999.99",;
     /* titulo        */    "Valor pago",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "nivelop=3",;
     /* validacao     */    "!(valorpg<0)~VALOR PAGO n„o aceit vel",;
     /* help do campo */    "Informe o valor pago/baixado";
                         };
)
AADD(sistema[005,O_CAMPO],{;            // TAXAS
     /* mascara       */    "!!!",;
     /* titulo        */    "Cobrador",;
     /* cmd especial  */    "VDBF(6,3,20,77,'COBRADOR',{'cobrador','funcao','nome','cidade','telefone'},1,'cobrador',[])",;
     /* default       */    "GRUPOS->cobrador",;
     /* pre-validacao */    "",;
     /* validacao     */    "PTAB(cobrador,'COBRADOR',1).AND.(PTAB(cobrador+M->mmesref,'FCCOB',1).OR.1=1)~Problemas encontrados no arquivo Cobrador ou |Circular do grupo n„o cadastrada para|este cobrador.",;
     /* help do campo */    "Informe o Cobrador que recebeu este.";
			 };
)
AADD(sistema[005,O_CAMPO],{;            // TAXAS
     /* mascara       */    "!",;
     /* titulo        */    "Forma",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "forma$[PR ]~FORMA n„o aceit vel",;
     /* help do campo */    "Esta lan‡amento foi Pago ou Cancelado|Deixe sem preencher se ainda em aberto";
                         };
)
AADD(sistema[005,O_CAMPO],{;            // TAXAS
     /* mascara       */    "@D",;
     /* titulo        */    "Baixa_",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
			 };
)
AADD(sistema[005,O_CAMPO],{;            // TAXAS
     /* mascara       */    "",;
     /* titulo        */    "Por",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[005,O_CAMPO],{;            // TAXAS
     /* mascara       */    "9",;
     /* titulo        */    "Status",;
     /* cmd especial  */    "MTAB([1=Gerada|2=Impressa|6=Pg Recep‡„o|7=Bx.p/FCC|9=Bx.Plano],[STATUS])",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "stat $ [12679]~STATUS n„o aceit vel",;
     /* help do campo */    "Informe a situa‡„o deste recibo|Tecle F8 para busca em tabela";
			 };
)
AADD(sistema[005,O_CAMPO],{;            // TAXAS
     /* mascara       */    "@!",;
     /* titulo        */    "Filial",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[005,O_CAMPO],{;            // TAXAS
     /* mascara       */    "!",;
     /* titulo        */    "Flag",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
			 };
)
AADD(sistema[005,O_CAMPO],{;            // TAXAS
     /* mascara       */    "!!!-99999999-999-999",;
     /* titulo        */    "Cod.Lan‡amento",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[005,O_FORMULA],{;          // TAXAS - Status
     /* form mostrar  */    "LEFT(TRAN(LEFT(TAX_02F9(),3),[]),03)",;
     /* lin da formula*/    {||l_a},;
     /* col da formula*/    75;
                         };
)
AADD(sistema[005,O_FORMULA],{;          // TAXAS - numero
     /* form mostrar  */    "LEFT(TRAN(substr(codigo,11),[]),08)",;
     /* lin da formula*/    {||l_a},;
     /* col da formula*/    1;
                         };
)


sistema[006]={;
            "Outros Endere‡os",;                            // opcao do menu
            "Outros Endere‡os",;                            // titulo do sistema
            {"codigo+tipo"},;                               // chaves do arquivo
            {"Contrato"},;                                  // titulo dos indices para consulta
            {"0102"},;                                      // ordem campos chaves
            {"ECOB",drvdbf,drvntx},;                        // nome do DBF
            {"ECOB1"},;                                     // nomes dos NTX
            {},;                                            // nome dos dbf's relacionados
            {"GRUPOS->codigo"},;                            // campos de relacionamento
            {1,1,8,17,16,65},;                              // num telas/tela atual/coordenadas
            {1,.t.,.f.},;                                   // nivel acesso/tp chave/pede dir
            {},;                                            // campos do arquivo
            {},;                                            // formula mostradas
	    {"",""},;                                       // condicao de exclusao de registros
            {"",""},;                                       // condicao de alteracao de registros
            {"",""};                                        // condicao de recupercao de registros
           }

AADD(sistema[006,O_CAMPO],{;            // ECOB
     /* mascara       */    "@!",;
     /* titulo        */    "Codigo",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[006,O_CAMPO],{;            // ECOB
     /* mascara       */    "!",;
     /* titulo        */    "Tipo",;
     /* cmd especial  */    "MTAB([Residˆncia|Trabalho|Outro],[TIPO])",;
     /* default       */    "[R]",;
     /* pre-validacao */    "MTAB([Residˆncia|Trabalho|Outro],[TIPO])",;
     /* validacao     */    "tipo $ [RTO]~TIPO n„o aceit vel|Apenas endere‡os de Residˆncia e Trabalho.",;
     /* help do campo */    "Informe que tipo de Endere‡o ‚ este.|R=Residˆncia, T=Trabalho";
                         };
)
AADD(sistema[006,O_CAMPO],{;            // ECOB
     /* mascara       */    "@!",;
     /* titulo        */    "Endere‡o",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(endereco)~Informe a localiza‡„o ou tecle ESC para cancelar",;
     /* help do campo */    "Informe o Endere‡o|Rua,n£mero,apto, blocl, etc...";
                         };
)
AADD(sistema[006,O_CAMPO],{;            // ECOB
     /* mascara       */    "@!",;
     /* titulo        */    "Bairro",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    "Digite o Bairro|ou complemento| do endere‡o";
                         };
)
AADD(sistema[006,O_CAMPO],{;            // ECOB
     /* mascara       */    "@R 99999-999",;
     /* titulo        */    "CEP",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    "Informe o CEP para facilitar a localiza‡„o";
                         };
)
AADD(sistema[006,O_CAMPO],{;            // ECOB
     /* mascara       */    "@!",;
     /* titulo        */    "Cidade",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    "Informe a Cidade/Municipio";
                         };
)
AADD(sistema[006,O_CAMPO],{;            // ECOB
     /* mascara       */    "!!",;
     /* titulo        */    "UF",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "VUF(uf).OR. EMPT(uf)~UNIDADE DA FEDERA€ŽO inv lida",;
     /* help do campo */    "Informe o Estado.|Ex.: SP,RJ,GO,AM,...";
                         };
)
AADD(sistema[006,O_CAMPO],{;            // ECOB
     /* mascara       */    "@!",;
     /* titulo        */    "Telefone",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    "Informe o n£mero do telefone para contato";
                         };
)
AADD(sistema[006,O_CAMPO],{;            // ECOB
     /* mascara       */    "",;
     /* titulo        */    "Obs",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    "";
                         };
)
AADD(sistema[006,O_CAMPO],{;            // ECOB
     /* mascara       */    "@D",;
     /* titulo        */    "Data",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[006,O_CAMPO],{;            // ECOB
     /* mascara       */    "!",;
     /* titulo        */    "Flag",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[006,O_FORMULA],{;          // ECOB - Tipo
     /* form mostrar  */    "LEFT(TRAN(IIF(tipo=[R],[Residˆncia],IIF(tipo=[T],[Trabalho],[Outro])),[]),12)",;
     /* lin da formula*/    1,;
     /* col da formula*/    15;
                         };
)
AADD(sistema[006,O_FORMULA],{;          // ECOB - Data
     /* form mostrar  */    "LEFT(TRAN(data_,[@D]),08)",;
     /* lin da formula*/    7,;
     /* col da formula*/    39;
                         };
)


sistema[007]={;
	    "Inscritos",;                                   // opcao do menu
	    "Inscritos",;                                   // titulo do sistema
	    {"codigo","nome"},;                        // chaves do arquivo
	    {"Codigo","Nome"},;                             // titulo dos indices para consulta
	    {"01","05"},;                                 // ordem campos chaves
	    {"INSCRITS",drvdbf,drvntx},;                    // nome do DBF
	    {"INSCRIT1","INSCRIT2"},;                       // nomes dos NTX
	    {},;                                            // nome dos dbf's relacionados
	    {"GRUPOS->codigo"},;                            // campos de relacionamento
	    {1,1,17,3,23,77},;                              // num telas/tela atual/coordenadas
	    {1,.t.,.f.},;                                   // nivel acesso/tp chave/pede dir
            {},;                                            // campos do arquivo
            {},;                                            // formula mostradas
            {"",""},;                                       // condicao de exclusao de registros
            {"",""},;                                       // condicao de alteracao de registros
            {"",""};                                        // condicao de recupercao de registros
           }

AADD(sistema[007,O_CAMPO],{;            // INSCRITS
     /* mascara       */    "@!",;
     /* titulo        */    "Codigo",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[007,O_CAMPO],{;            // INSCRITS
     /* mascara       */    "9",;
     /* titulo        */    "Inscr.",;
     /* cmd especial  */    "MTAB(M->TBTIPGRAU,[INSCR.])",;
     /* default       */    "IIF(M->pgrau<[7],SUBSTR([234567],VAL(M->pgrau),1),M->pgrau)",;
     /* pre-validacao */    "MTAB(M->TBTIPGRAU,[INSCR.])",;
     /* validacao     */    "grau $ [12345678]~INSCR. n„o aceit vel",;
     /* help do campo */    "Informe o grau de liga‡„o deste com o|titular do contrato|ou|tecle F8 para consulta em tabela";
                         };
)
AADD(sistema[007,O_CAMPO],{;            // INSCRITS
     /* mascara       */    "99",;
     /* titulo        */    "Seq",;
     /* cmd especial  */    "",;
     /* default       */    "INS_01F9()",;
     /* pre-validacao */    "grau>[6]",;
     /* validacao     */    "seq>0~SEQ n„o aceit vel",;
     /* help do campo */    "";
                         };
)
AADD(sistema[007,O_CAMPO],{;            // INSCRITS
     /* mascara       */    "!",;
     /* titulo        */    "Titular?",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[007,O_CAMPO],{;            // INSCRITS
     /* mascara       */    "@!",;
     /* titulo        */    "Nome",;
     /* cmd especial  */    "",;
     /* default       */    "IIF(ehtitular=[S],GRUPOS->nome,[ ])",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(nome)~Necess rio informar NOME",;
     /* help do campo */    "";
                         };
)
AADD(sistema[007,O_CAMPO],{;            // INSCRITS
     /* mascara       */    "@D",;
     /* titulo        */    "Nascto",;
     /* cmd especial  */    "",;
     /* default       */    "IIF(ehtitular=[S],GRUPOS->nascto_,ctod('  /  /  '))",;
     /* pre-validacao */    "",;
     /* validacao     */    "INS_02F9()~NASCTO n„o aceit vel",;
     /* help do campo */    "Informe a Data de Nascimento deste Inscrito";
                         };
)
AADD(sistema[007,O_CAMPO],{;            // INSCRITS
     /* mascara       */    "",;
     /* titulo        */    "Est Civil",;
     /* cmd especial  */    "MTAB(tbestciv,[EST CIVIL])",;
     /* default       */    "IIF(grau<[7],[CA],[SO])",;
     /* pre-validacao */    "MTAB(tbestciv,[EST CIVIL])",;
     /* validacao     */    "(ESTCIVIL$tbestciv)~Necess rio informar ESTADO CIVIL|ou tecle F8",;
     /* help do campo */    "Digite o Estado Civil do Falecido";
                         };
)
AADD(sistema[007,O_CAMPO],{;            // INSCRITS
     /* mascara       */    "!",;
     /* titulo        */    "Interdito",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[007,O_CAMPO],{;            // INSCRITS
     /* mascara       */    "!",;
     /* titulo        */    "Sexo",;
     /* cmd especial  */    "",;
     /* default       */    "IIF(grau$[124],[M],IIF(grau$[356],[F],[ ]))",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    "Digite M ou F |(Masculino ou Feminino)";
                         };
)
AADD(sistema[007,O_CAMPO],{;            // INSCRITS
     /* mascara       */    "@D",;
     /* titulo        */    "T.Carˆncia",;
     /* cmd especial  */    "",;
     /* default       */    "IIF(GRUPOS->tcarencia>DATE(),GRUPOS->tcarencia,CTOD('  /  /  '))",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    "";
                         };
)
AADD(sistema[007,O_CAMPO],{;            // INSCRITS
     /* mascara       */    "@D",;
     /* titulo        */    "Lan‡to.",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[007,O_CAMPO],{;            // INSCRITS
     /* mascara       */    "!",;
     /* titulo        */    "V/F",;
     /* cmd especial  */    "MTAB([Vivo|Falecido],[V/F])",;
     /* default       */    "[V]",;
     /* pre-validacao */    "",;
     /* validacao     */    "vivofalec$[VF]~Necess rio informar VIVOFALEC",;
     /* help do campo */    "Vivo ou Falecido";
                         };
)
AADD(sistema[007,O_CAMPO],{;            // INSCRITS
     /* mascara       */    "@D",;
     /* titulo        */    "Falecto.",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "vivofalec==[F]",;
     /* validacao     */    "",;
     /* help do campo */    "Entre com a data de falecimento";
                         };
)
AADD(sistema[007,O_CAMPO],{;            // INSCRITS
     /* mascara       */    "!!!",;
     /* titulo        */    "Tipo",;
     /* cmd especial  */    "MTAB([Funeral|Auxilio],[TIPO])",;
     /* default       */    "",;
     /* pre-validacao */    "vivofalec==[F]",;
     /* validacao     */    "EMPTY(tipo).OR.UPPER(tipo) $ [FUN|AUX]~Necess rio informar TIPO",;
     /* help do campo */    "Com Direitos (Funeral) ou com Auxilio.";
                         };
)
AADD(sistema[007,O_CAMPO],{;            // INSCRITS
     /* mascara       */    "@R 99999/99",;
     /* titulo        */    "N§Processo",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "vivofalec==[F]",;
     /* validacao     */    "",;
     /* help do campo */    "Informe o n£mero do processo";
                         };
)
AADD(sistema[007,O_CAMPO],{;            // INSCRITS
     /* mascara       */    "",;
     /* titulo        */    "Por",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[007,O_CAMPO],{;            // INSCRITS
     /* mascara       */    "!",;
     /* titulo        */    "Flag",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[07,O_CAMPO],{;            // INSCRITS
     /* mascara       */    "@R 999.999.999-99",;
     /* titulo        */    "CPF",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "VDV2(cpf).OR.EMPT(cpf)~CPF nÆo aceit vel",;
     /* help do campo */    "Informe o CIC (CPF) do titular";
                         };
)
AADD(sistema[07,O_CAMPO],{;            // INSCRITS
     /* mascara       */    "",;
     /* titulo        */    "SeguroData",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    "Entre com a data da admissao do seguro.";
                         };
)
AADD(sistema[07,O_CAMPO],{;            // INSCRITS
     /* mascara       */    "",;
     /* titulo        */    "Seg.Porcentagem",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    "Entre com o Cod.Seguro.";
                         };
)
AADD(sistema[07,O_CAMPO],{;            // INSCRITS
     /* mascara       */    "",;
     /* titulo        */    "SeguroCod",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    "Entre com o Cod.Seguro.";
                         };
)
AADD(sistema[07,O_CAMPO],{;            // INSCRITS
     /* mascara       */    "",;
     /* titulo        */    "SeguroServ",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    "Entre com o Serv.Seguro.";
                         };
)
AADD(sistema[007,O_FORMULA],{;          // INSCRITS - graupart
     /* form mostrar  */    "LEFT(TRAN(SUBSTR([TitPaiMaeSgoSgaEspFilDep],(VAL(grau)-1)*3+1,3),[]),03)",;
     /* lin da formula*/    1,;
     /* col da formula*/    13;
                         };
)
AADD(sistema[007,O_FORMULA],{;          // INSCRITS - Lan‡to.
     /* form mostrar  */    "LEFT(TRAN(lancto_,[@D]),08)",;
     /* lin da formula*/    1,;
     /* col da formula*/    53;
                         };
)
AADD(sistema[007,O_FORMULA],{;          // INSCRITS - Por
     /* form mostrar  */    "LEFT(TRAN(por,[]),10)",;
     /* lin da formula*/    1,;
     /* col da formula*/    62;
                         };
)
AADD(sistema[007,O_FORMULA],{;          // INSCRITS - Idade
     /* form mostrar  */    "LEFT(TRAN(IIF(!EMPT(nascto_),LEFT(DLAPSO(DATE(),nascto_),12),[            ]),[]),12)",;
     /* lin da formula*/    3,;
     /* col da formula*/    62;
                         };
)


sistema[008]={;
            "Emiss„o de Guias",;                            // opcao do menu
            "Emiss„o de Guias",;                            // titulo do sistema
            {"numero","numero"},;                           // chaves do arquivo
            {"p/N£mero","p/N§Transf."},;                    // titulo dos indices para consulta
            {"01","01"},;                                   // ordem campos chaves
            {"GUIAS",drvdbf,drvntx},;                       // nome do DBF
            {"GUIAS1","GUIAS2"},;                           // nomes dos NTX
            {},;                                            // nome dos dbf's relacionados
            {},;                                            // campos de relacionamento
            {1,1,1,10,23,75},;                              // num telas/tela atual/coordenadas
            {1,.t.,.f.},;                                   // nivel acesso/tp chave/pede dir
            {},;                                            // campos do arquivo
            {},;                                            // formula mostradas
            {"",""},;                                       // condicao de exclusao de registros
            {"",""},;                                       // condicao de alteracao de registros
            {"",""};                                        // condicao de recupercao de registros
           }

AADD(sistema[008,O_CAMPO],{;            // GUIAS
     /* mascara       */    "99999999",;
     /* titulo        */    "N£mero",;
     /* cmd especial  */    "",;
     /* default       */    "RIGHT(DTOC(DATE()),2)+[000001]",;
     /* pre-validacao */    "",;
     /* validacao     */    "V",;
     /* help do campo */    "";
                         };
)
AADD(sistema[008,O_CAMPO],{;            // GUIAS
     /* mascara       */    "@D",;
     /* titulo        */    "Emiss„o",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[008,O_CAMPO],{;            // GUIAS
     /* mascara       */    "99:99",;
     /* titulo        */    "Hora",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[008,O_CAMPO],{;            // GUIAS
     /* mascara       */    "",;
     /* titulo        */    "Filial",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[008,O_CAMPO],{;            // GUIAS
     /* mascara       */    "",;
     /* titulo        */    "Login",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[008,O_CAMPO],{;            // GUIAS
     /* mascara       */    "@!",;
     /* titulo        */    "N§ Contrato",;
     /* cmd especial  */    "VDBF(6,3,20,77,'GRUPOS',{'grupo','codigo','nome','endereco'},1,'codigo')",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "GUI_07F9(contrato).AND.CAD_04F9(op_menu).AND.((PTAB(contrato,'INSCRITS',1).and.PTAB(contrato,'TAXAS',1)).OR.1=1)~N£mero do contrato inv lido,|ou |Titular n„o cadastrado|Tecle F8 para consulta.",;
     /* help do campo */    "Entre com o c¢digo do contrato";
                         };
)
AADD(sistema[008,O_CAMPO],{;            // GUIAS
     /* mascara       */    "@!",;
     /* titulo        */    "Nome",;
     /* cmd especial  */    "GUI_06F9()",;
     /* default       */    "GRUPOS->nome",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(nome).AND.(PTAB([],'MEDICOS',1).OR.1=1)~Informar NOME",;
     /* help do campo */    "Informe o nome do benefici rio.";
                         };
)
AADD(sistema[008,O_CAMPO],{;            // GUIAS
     /* mascara       */    "@!",;
     /* titulo        */    "Inscrito",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[008,O_CAMPO],{;            // GUIAS
     /* mascara       */    "@!",;
     /* titulo        */    "M‚dico",;
     /* cmd especial  */    "VDBF(6,3,20,77,'MEDICOS',{'LEFT(oldespec,20)','nome','endereco','cidade','codbenefic','fonesdiv','fonecom1'},3,'codbenefic',[])",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "PTAB(medico,'MEDICOS',1).OR.GUI_08F9()~MDICO n„o existe na tabela",;
     /* help do campo */    "Informe o m‚dico";
                         };
)
AADD(sistema[008,O_CAMPO],{;            // GUIAS
     /* mascara       */    "",;
     /* titulo        */    "Por",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[008,O_CAMPO],{;            // GUIAS
     /* mascara       */    "99999999",;
     /* titulo        */    "Num.Lan‡amento",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[008,O_FORMULA],{;          // GUIAS - circ 1-4
     /* form mostrar  */    "LEFT(TRAN(GUI_02F9(),[]),45)",;
     /* lin da formula*/    6,;
     /* col da formula*/    15;
                         };
)
AADD(sistema[008,O_FORMULA],{;          // GUIAS - Nome do titular
     /* form mostrar  */    "LEFT(TRAN(GRUPOS->nome,[]),35)",;
     /* lin da formula*/    3,;
     /* col da formula*/    26;
                         };
)
AADD(sistema[008,O_FORMULA],{;          // GUIAS - Admiss„o
     /* form mostrar  */    "LEFT(TRAN(GRUPOS->admissao,[@D]),10)",;
     /* lin da formula*/    4,;
     /* col da formula*/    15;
                         };
)
AADD(sistema[008,O_FORMULA],{;          // GUIAS - Saitxa
     /* form mostrar  */    "LEFT(TRAN(GRUPOS->saitxa,[@R 99/99]),05)",;
     /* lin da formula*/    5,;
     /* col da formula*/    15;
                         };
)
AADD(sistema[008,O_FORMULA],{;          // GUIAS - Cobrador
     /* form mostrar  */    "LEFT(TRAN(GRUPOS->cobrador,[!!]),02)",;
     /* lin da formula*/    5,;
     /* col da formula*/    59;
                         };
)
AADD(sistema[008,O_FORMULA],{;          // GUIAS - Endere‡o contr
     /* form mostrar  */    "LEFT(TRAN(xDECRIPT(GRUPOS->endereco),[]),35)",;
     /* lin da formula*/    4,;
     /* col da formula*/    26;
                         };
)
AADD(sistema[008,O_FORMULA],{;          // GUIAS - Bairro contr
     /* form mostrar  */    "LEFT(TRAN(xDECRIPT(GRUPOS->bairro),[]),25)",;
     /* lin da formula*/    5,;
     /* col da formula*/    26;
                         };
)
AADD(sistema[008,O_FORMULA],{;          // GUIAS - Endere‡o
     /* form mostrar  */    "LEFT(TRAN(IIF(!EMPT(medico).AND.PTAB(medico,'MEDICOS',1),MEDICOS->endereco,SPACE(40)),[]),40)",;
     /* lin da formula*/    15,;
     /* col da formula*/    24;
                         };
)
AADD(sistema[008,O_FORMULA],{;          // GUIAS - Munic¡pio
     /* form mostrar  */    "LEFT(TRAN(IIF(PTAB(medico,'MEDICOS',1),MEDICOS->cidade,[]),[]),30)",;
     /* lin da formula*/    16,;
     /* col da formula*/    32;
                         };
)
AADD(sistema[008,O_FORMULA],{;          // GUIAS - Fone
     /* form mostrar  */    "LEFT(TRAN(IIF(!EMPT(medico),MEDICOS->fonecom1,SPACE(14)),[]),14)",;
     /* lin da formula*/    15,;
     /* col da formula*/    9;
                         };
)
AADD(sistema[008,O_FORMULA],{;          // GUIAS - Nome m‚dico
     /* form mostrar  */    "LEFT(TRAN(IIF(!EMPT(medico),MEDICOS->nome,SPACE(40)),[]),40)",;
     /* lin da formula*/    14,;
     /* col da formula*/    24;
                         };
)
AADD(sistema[008,O_FORMULA],{;          // GUIAS - Especialidade
     /* form mostrar  */    "LEFT(TRAN(IIF(!EMPT(medico),MEDICOS->oldespec,SPACE(30)),[]),30)",;
     /* lin da formula*/    16,;
     /* col da formula*/    2;
                         };
)
AADD(sistema[008,O_FORMULA],{;          // GUIAS - Emiss„o
     /* form mostrar  */    "LEFT(TRAN(IIF(EMPT(data),DATE(),data),[@D]),10)",;
     /* lin da formula*/    1,;
     /* col da formula*/    43;
                         };
)
AADD(sistema[008,O_FORMULA],{;          // GUIAS - Por
     /* form mostrar  */    "LEFT(TRAN(IIF(EMPT(por),M->usuario,por),[]),10)",;
     /* lin da formula*/    1,;
     /* col da formula*/    54;
                         };
)

* \\ Final de ADR_ATRI.PRG
procedure mfilial
/*
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
 \ Empresa.: PresServ Inform tica - Limeira (019)452.6623
 \ Programa: MFILIAL.PRG
 \ Data....: 22-01-08
 \ Sistema.: Administradora - RECEP€„O
 \ Funcao..: Gerenciador do subsistema de avisos / carencias
 \ Analista: Ademilson Pedro Bom
 \ Criacao.: GAS-Pro v4.0o
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/

#include "adrbig.ch"    // inicializa constantes manifestas

PARA lin_menu,col_menu
PRIV op_sis, tela_fundo:=SAVESCREEN(0,0,MAXROW(),79), l_s, c_s, l_i, c_i, l_a

op_sis=EVAL(qualsis,"MFILIAL")
IF .f. //nivelop<sistema[op_sis,O_OUTROS,O_NIVEL]        // se usuario nao tem permissao,
 ALERTA()                                          // entao, beep, beep, beep
 DBOX(msg_auto,,,3)                                // lamentamos e
 RETU                                              // retornamos ao menu
ENDI
cn:=fgrep :=.f.

#ifdef COM_LOCK
 IF LEN(pr_ok)>0                                   // se a protecao acusou
  ? pr_ok                                          // erro, avisa e
  QUIT                                             // encerra a aplicacao
 ENDI
#endi

t_fundo=SAVESCREEN(0,0,MAXROW(),79)                // salva tela do fundo
op_cad=1
DO WHIL op_cad!=0
 criterio=""
 RESTSCREEN(0,0,MAXROW(),79,t_fundo)               // restaura tela do fundo
 cod_sos=5 ; cn=.f.
 CLEA TYPEAHEAD                                    // limpa o buffer do teclado
 fgrep=.f.
 SET KEY K_F3 TO                                   // retira das teclas F3 e F4 as
 SET KEY K_F4 TO                                   // funcoes de repeticao e confirmacao
 msg="Inclus„o~1|"+;
     "Manuten‡„o~2|"+;
     "Consulta~3"
 op_cad=DBOX(msg,lin_menu,col_menu,E_MENU,NAO_APAGA,MAIUSC(sistema[op_sis,O_MENU]),,,op_cad)
 IF op_cad!=0                                      // se escolheu uma opcao
  Tela_fundo=SAVESCREEN(0,0,MAXROW(),79)           // salva a tela para ROLATELA()
  PARAMETROS(dbfparam)
  SELE A                                           // e abre o arquivo e seus indices

  #ifdef COM_REDE
   IF !USEARQ(sistema[op_sis,O_ARQUI,O_NOME],.f.,20,1)
                                                   // se falhou a abertura do
    RETU                                           // arquivo volta ao menu anterior
   ENDI
  #else
   USEARQ(sistema[op_sis,O_ARQUI,O_NOME])
  #endi

  SET KEY K_F9 TO veoutros                         // habilita consulta em outros arquivos
 ENDI
 DO CASE
  CASE op_cad=01                                   // inclus„o
   op_menu=INCLUSAO
   IF AT("D",exrot[op_sis])=0                      // se usuario pode fazer inclusao
    MFI_INCL()                                     // neste arquivo chama prg de inclusao
   ELSE                                            // caso contrario vamos avisar que
    ALERTA()                                       // ele nao tem permissao para isto
    DBOX(msg_auto,,,3)
   ENDI

  CASE op_cad=02                                   // manuten‡„o
   op_menu=ALTERACAO
   cod_sos=7
   EDIT()

  CASE op_cad=03                                   // consulta
   op_menu=PROJECOES
   cod_sos=8
   EDITA(03,03,MAXROW()-2,77)

 ENDC
 SET KEY K_F9 TO                                   // F9 nao mais consultara outros arquivos
 CLOS ALL                                          // fecha todos arquivos abertos
ENDD
RETU

PROC MFI_incl(reg_cop)  // inclusao no arquivo MFILIAL
LOCAL getlist:={},cabem:=1,rep:=ARRAY(FCOU()),ult_reg:=RECN(),dbfseq_,;
      ctl_r, ctl_c, ctl_w, t_f3_, t_f4_, dele_atu:=SET(_SET_DELETED,.f.)
PRIV op_menu:=INCLUSAO, sq_atual_, tem_borda, criterio:="", cpord:=""
FOR i=1 TO FCOU()                                  // cria/declara privadas as
 msg=FIEL(i)                                       // variaveis de memoria com
 PRIV &msg.                                        // o mesmo nome dos campos
NEXT                                               // do arquivo
IF reg_cop!=NIL                                    // quer repetir todo o reg atual
 FOR i=1 TO FCOU()                                 // para cada campo,
  msg=FIEL(i)                                      // salva o conteudo
  rep[i]=&msg.                                     // para repetir
 NEXT
ELSE
 AFILL(rep,"")                                     // eche com valor vazio
ENDI
t_f3_=SETKEY(K_F3,{||rep()})                       // repeticao reg anterior
t_f4_=SETKEY(K_F4,{||conf()})                      // confirma campos com ENTER
ctl_w=SETKEY(K_CTRL_W,{||nadafaz()})               // enganando o CA-Clipper...
ctl_c=SETKEY(K_CTRL_C,{||nadafaz()})
ctl_r=SETKEY(K_CTRL_R,{||nadafaz()})

#ifdef COM_REDE
 MFI_CRIA_SEQ()                                    // cria dbf de controle de cp sequenciais
 FOR i=1 TO FCOU()                                 // cria/declara privadas as
  msg="sq_"+FIEL(i)                                // variaveis de memoria com
  PRIV &msg.                                       // o mesmo nome dos campos
 NEXT                                              // do arquivo com extensao _seq
#endi

DO WHIL cabem>0
 cod_sos=6
 rola_t=.f.                                        // flag se quer rolar a tela
 SELE MFILIAL
 GO BOTT                                           // forca o
 SKIP                                              // final do arquivo
 
 /*
    cria variaveis de memoria identicas as de arquivo, para inclusao
    de registros
 */
 FOR i=1 TO FCOU()
  msg=FIEL(i)
  M->&msg.=IF((fgrep .OR. reg_cop!=NIL).AND.!EMPT(rep[1]),rep[i],&msg.)
 NEXT
 DISPBEGIN()                                       // apresenta a tela de uma vez so
 MFI_TELA()
 INFOSIS(.t.)                                      // exibe informacao no rodape' da tela
 DISPEND()
 MFI_GERA_SEQ()
 cabem=DISKSPACE(;
          IF(;
             LEN(sistema[op_sis,O_ARQUI,O_DIR_DBF])<2.OR.sistema[op_sis,O_ARQUI,O_DIR_DBF]="\",;
             0,;
             ASC(sistema[op_sis,O_ARQUI,O_DIR_DBF])-64;
          );
       )
 cabem=INT((cabem-2048)/MFILIAL->(RECSIZE()))
 IF cabem<1                                        // mais nenhum!!!
  ALERTA()
  msg="Verifique ESPA€O EM DISCO, "+usuario
  DBOX(msg,,,,,"INCLUSŽO INTERROMPIDA!")           // vamos parar por aqui!
  EXIT
 ENDI
 M->data_=DATE()
 M->por=M->usuario
 SELE 0                                            // torna visiveis variaveis de memoria
 MFI_GET1(INCLUI)                                  // recebe campos
 SELE MFILIAL
 IF LASTKEY()=K_ESC                                // se cancelou
  cabem=0                                          // prepara saida da inclusao
  LOOP
 ENDI

 #ifdef COM_REDE
  GO BOTT                                          // vamos bloquear o final do
  SKIP                                             // arq para que nehum outro
  BLOREG(0,.5)                                     // usuario possa incluir
 #endi

 APPEND BLANK                                      // inclui reg em branco no dbf
 FOR i=1 TO FCOU()                                 // para cada campo,
  msg=FIEL(i)                                      // salva o conteudo
  rep[i]=M->&msg.                                  // para repetir
  REPL &msg. WITH rep[i]                           // enche o campo do arquivo
 NEXT

 #ifdef COM_REDE
  UNLOCK                                           // libera o registro e
  COMMIT                                           // forca gravacao
 #else
  IF RECC()-INT(RECC()/20)*20=0                    // a cada 20 registros
   COMMIT                                          // digitados forca gravacao
  ENDI
 #endi

 ult_reg=RECN()                                    // ultimo registro digitado
 IF reg_cop!=NIL                                   // estava na consulta e quis rep o campo
  sq_atual_=NIL
  EXIT                                             // cai fora...
 ENDI
ENDD

#ifdef COM_REDE
 MFI_ANT_SEQ()                                     // restaura sequencial anterior
 SELE MFILIAL
#endi

GO ult_reg                                         // para o ultimo reg digitado
SETKEY(K_F3,t_f3_)                                 // restaura teclas de funcoes
SETKEY(K_F4,t_f4_)
SET(_SET_DELETED,dele_atu)                            // ecluidos visiveis/invisiveis
SETKEY(K_CTRL_W,ctl_w)
SETKEY(K_CTRL_C,ctl_c)
SETKEY(K_CTRL_R,ctl_r)
RETU



#ifdef COM_REDE
 PROC MFI_ANT_SEQ(est_seq)     // restaura sequencial anterior
 SELE MFI_SEQ     // seleciona arquivo de controle de sequencial
 BLOARQ(0,.5)     // esta estacao foi a ultima a incluir?
 IF sq_atual_ == seq0
  REPL seq0 WITH sq_seq0
 ENDI
 UNLOCK           // libera DBF para outros usuarios
 COMMIT           // atualiza cps sequenciais no disco
 RETU
#endi


PROC MFI_CRIA_SEQ   // cria dbf de controle de campos sequenciais
LOCAL dbfseq_:=sistema[op_sis,O_ARQUI,O_DIR_DBF]+"MFI_seq" // arq temporario
SELE 0                          // seleciona area vazia
IF !FILE(dbfseq_+".dbf")        // se o dbf nao existe
 DBCREATE(dbfseq_,{;            // vamos criar a sua estrutura
                    {"seq0"      ,"C",  6, 0};
                  };
 )
ENDI
USEARQ(dbfseq_,.f.,,,.f.)       // abre arquivo de cps sequencial
IF RECC()=0                     // se o dbf foi criado agora
 BLOARQ(0,.5)                   // inclui um registro que tera
 APPEND BLANK                   // os ultomos cps sequenciais
 SELE MFILIAL
 IF RECC()>0                    // se o DBF nao estiver
  SET ORDER TO 0                // vazio, entao enche DBF seq
  GO BOTT                       // com o ultimo reg digitado
  REPL MFI_SEQ->seq0 WITH seq0
  DBSETORDER(1)                 // retorna ao indice principal
 ENDI
 SELE MFI_SEQ                   // seleciona arq de sequencias
 UNLOCK                         // libera DBF para outros usuarios
 COMMIT                         // atualiza cps sequenciais no disco
ENDI
RETURN

PROC MFI_GERA_SEQ()

#ifdef COM_REDE
 LOCAL ar_:=SELEC()
#else
 LOCAL reg_:=RECNO(),ord_ind:=INDEXORD()
#endi


#ifdef COM_REDE
 SELE MFI_SEQ
 BLOARQ(0,.5)
 sq_seq0=MFI_SEQ->seq0
#else
 DBSETORDER(0)
 GO BOTT
#endi

M->seq0=LPAD(STR(VAL(seq0)+1),06,[0])

#ifdef COM_REDE
 MFI_GRAVA_SEQ()
 sq_atual_=MFI_SEQ->seq0
 UNLOCK                                            // libera o registro
 COMMIT
 SELE (ar_)
#else
 DBSETORDER(ord_ind)
 GO reg_
#endi

RETU

PROC MFI_GRAVA_SEQ
REPL seq0 WITH M->seq0
RETU

PROC MFI_tela     // tela do arquivo MFILIAL
tem_borda=.t.
l_s=Sistema[op_sis,O_TELA,O_LS]           // coordenadas da tela
c_s=Sistema[op_sis,O_TELA,O_CS]
l_i=Sistema[op_sis,O_TELA,O_LI]
c_i=Sistema[op_sis,O_TELA,O_CI]
SETCOLOR(drvtittel)
vr_memo=NOVAPOSI(@l_s,@c_s,@l_i,@c_i)     // pega posicao atual da tela
CAIXA(mold,l_s,c_s,l_i,c_i)               // monta caixa da tela
i=LEN(sistema[op_sis,O_MENS])/2
@ l_s,c_s-1+(c_i-c_s+1)/2-i SAY " "+MAIUSC(sistema[op_sis,O_MENS])+" "
SETCOLOR(drvcortel)
@ l_s+02,c_s+1 SAY "ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ"
@ l_s+03,c_s+1 SAY " Codigo..........:"
@ l_s+04,c_s+1 SAY " Termino Carencia:"
@ l_s+05,c_s+1 SAY " Obs1............:"
@ l_s+06,c_s+1 SAY " Obs2............:"
@ l_s+07,c_s+1 SAY " Obs3............:"
RETU

PROC MFI_gets     // mostra variaveis do arquivo MFILIAL
LOCAL getlist := {}
MFI_TELA()
SETCOLOR(drvcortel+","+drvcorget+",,,"+corcampo)
PTAB(ALLTRIM(CODIGO),[GRUPOS])
@ l_s+01 ,c_s+03 GET  seq0;
                 PICT sistema[op_sis,O_CAMPO,02,O_MASC]

@ l_s+01 ,c_s+49 GET  data_;
                 PICT sistema[op_sis,O_CAMPO,03,O_MASC]

@ l_s+01 ,c_s+60 GET  por

@ l_s+03 ,c_s+20 GET  codigo;
                 PICT sistema[op_sis,O_CAMPO,05,O_MASC]

@ l_s+04 ,c_s+20 GET  tcarenc_;
                 PICT sistema[op_sis,O_CAMPO,06,O_MASC]

@ l_s+05 ,c_s+20 GET  obs1;
                 PICT sistema[op_sis,O_CAMPO,07,O_MASC]

@ l_s+06 ,c_s+20 GET  obs2;
                 PICT sistema[op_sis,O_CAMPO,08,O_MASC]

@ l_s+07 ,c_s+20 GET  obs3;
                 PICT sistema[op_sis,O_CAMPO,09,O_MASC]

CRIT("",,"1")
CLEAR GETS
RETU

PROC MFI_get1(tp_mov)     // capta variaveis do arquivo MFILIAL
LOCAL getlist := {}
PRIV  blk_mfilial:=.t.

IF tp_mov=INCLUI
 DO WHILE .t.
  rola_t=.f.
  SET KEY K_ALT_F8 TO ROLATELA
  SETCOLOR(drvcortel+","+drvcorget+",,,"+corcampo)
  @ l_s+01 ,c_s+03 GET seq0;
                   PICT sistema[op_sis,O_CAMPO,02,O_MASC]
  @ l_s+01 ,c_s+49 GET data_;
                   PICT sistema[op_sis,O_CAMPO,03,O_MASC]
  @ l_s+01 ,c_s+60 GET por
  CLEA GETS
  @ l_s+03 ,c_s+20 GET  codigo;
                   PICT sistema[op_sis,O_CAMPO,05,O_MASC]
                   DEFINICAO 5

  @ l_s+04 ,c_s+20 GET  tcarenc_;
                   PICT sistema[op_sis,O_CAMPO,06,O_MASC]
                   DEFINICAO 6

  @ l_s+05 ,c_s+20 GET  obs1;
                   PICT sistema[op_sis,O_CAMPO,07,O_MASC]
                   DEFINICAO 7

  @ l_s+06 ,c_s+20 GET  obs2;
                   PICT sistema[op_sis,O_CAMPO,08,O_MASC]
                   DEFINICAO 8

  @ l_s+07 ,c_s+20 GET  obs3;
                   PICT sistema[op_sis,O_CAMPO,09,O_MASC]
                   DEFINICAO 9

  READ
  SET KEY K_ALT_F8 TO
  IF rola_t
   ROLATELA()
   LOOP
  ENDI
  IF LASTKEY()!=K_ESC .AND. drvincl .AND. op_menu=INCLUSAO
   IF !CONFINCL()
    LOOP
   ENDI
  ENDI
  EXIT
 ENDD
ENDI
PTAB(ALLTRIM(CODIGO),[GRUPOS])
PTAB(CODIGO,'TAXAS',1)
IF tp_mov=EXCLUI .OR. tp_mov=FORM_INVERSA
 msgX:=[]
 msg1find:=[**> ATENCAO   ATENCAO   ATENCAO <**]
 msg2find:=[(]+ALLTRIM(idxd)
 ultmsg1:=ultmsg2:=0
 FOR contmsg=1 TO 20
  msgadd:=MEMOLINE(GRUPOS->obs,60,contmsg)
  IF (msg1find$msgadd)
   ultmsg1:=contmsg
  ENDI
  IF (msg2find$msgadd)
   ultmsg2:=contmsg
  ENDI
 NEXT
 FOR contmsg=1 TO 20
  IF contmsg>=ultmsg1.AND.contmsg<=ultmsg2
  ELSE
   msgadd:=MEMOLINE(GRUPOS->obs,60,contmsg)
   msgX+=msgadd+chr(13)+chr(10)
  ENDI
 NEXT
/*
// Bloqueado em 01/06/2010 para naum interferir nas mensagens depois
// de excluido o lancamento
 #ifdef COM_REDE
  REPBLO('GRUPOS->obs',{||msgX})
 #else
  REPL GRUPOS->obs WITH msgX
 #endi
*/

 IF !EMPTY(ALIAS())
  DELE
 ENDI
ELSEIF tp_mov=INCLUI .OR. tp_mov=RECUPERA .OR. tp_mov=FORM_DIRETA
 IF (op_menu=INCLUSAO .AND. LASTKEY()!=K_ESC) .OR. op_menu!=INCLUSAO
   IF EMPT(idxd)
    IF op_menu=INCLUSAO
     idxd=dtoS(DATE())+time()+M->usuario
    ELSE
     REPL idxd WITH dtoS(DATE())+time()+M->usuario
    ENDI
   ENDI
/*
// Bloqueado em 01/06/2010 para naum interferir nas mensagens depois
// de excluido o lancamento
   msg_obs_aux:=[**> ATENCAO   ATENCAO   ATENCAO <**]+CHR(13)+CHR(10)
   msg_obs_fim:=[***--(]+ALLTRIM(idxd)+[)--***]+CHR(13)+CHR(10)
   IF !EMPT(tcarenc_)
    msg_obs_aux+=[ Contrato em Carencia por negociacao ate ]+dtoc(TCARENc_)+;
                CHR(13)+CHR(10)
   ENDI
   REPBLO('GRUPOS->obs',{||msg_obs_aux+ALLTRIM(obs1)+CHR(13)+CHR(10)+;
                          ALLTRIM(obs2)+CHR(13)+CHR(10)+;
                          ALLTRIM(obs3)+chr(13)+chr(10)+;
                          msg_obs_fim+GRUPOS->obs})
*/
//   [ (]+LEFT(DTOC(DATE()),6)+RIGHT(DTOC(DATE()),2)+[ ]+LEFT(TIME(),5)+[ ]+M->USUARIO+[)]+chr(13)+chr(10)+GRUPOS->obs})
   IF op_menu=INCLUSAO
    idxm=DTOS(DATE())+time()+M->usuario
   ELSE
    REPL idxm WITH DTOS(DATE())+time()+M->usuario
   ENDI
   IF op_menu=INCLUSAO
    filial=M->p_filial
   ELSE
    REPL filial WITH M->p_filial
   ENDI
  IF op_menu!=INCLUSAO
   RECA
  ENDI
 ENDI
ENDI
RETU

* \\ Final de MFILIAL.PRG
MZ       ÿÿ  ¸       @                                   €   º ´	Í!¸LÍ!This program cannot be run in DOS mode.
$       PE  L €ùNX ¤# [-  à  p       Œ$     $   @                      $         @                             $ D                          D‘$                            ð$                                                    UPX0                            €  àUPX1     p     p                @  àUPX2        $     r             @  À3.07 UPX!	é¨ ^qa¼´m$ çk í[( & šßùÿÿU‰åSƒì4¡È¿a …ÀtÇD$ ÿ×v+$ÿÐH@ èWÖºßlP
€‘`ÇEðE‰hÜ=íý¡°9b ô‘ bwß·bâ˜¡ˆ:bÚuJ ‹í¾íÜ‡Xd’˜ƒäð”à3¨‹uŸÛ‘¡}¡‰Ž¿÷»»,‰ÃE°‰t£‡H‹èsK{·TJ‹CQØ¸3&‚ƒ\I0Pé†·Í>Ãz‹Eø=‘&Àw;ðaÃß=rL»1A]p÷QuÀƒø„íGAS-Pro v4.0
007015019069001004014001011000176001
 Processo.:
 Categoria:    (PL=Plano, PD=Plano c/Dif.,AF=Auxilio)
 Saiu.....:
 Contrato.:   /      / /
 Segurado.:
 Endere‡o.:
 Cidade...:
 Falecido.:
 Sepultam.:
 Data Fal.:
[Ÿ]
Consulta Individual~~27007
Consulta Global~~28008
[Ÿ]
 13 
 2 
p/Processo

 1 
 2 
[Ÿ]
Grupo+Data

 4 
 13 
[Ÿ]
Processos
Processos

EMPT(saiu)
J  emitido nas Taxas|Exclusao nao permitida
EMPT(saiu)
J  emitido nas Taxas|Altera‡ao nao permitida


005
























 0 











 0 
 0 
-1 
-1 
 0 
-1 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
processo
C
E
@R 99999/99/!!
 9 
 11 
 1 
 13 
 0 
Processo

!EMPT(processo)
Necess rio informar PROCESSO

Informe o n£mero do processo a incluir

 0 
 0 


categ
C
E
!!
 2 
 2 
 2 
 13 
 0 
Categoria

categ $ [PL|PD|AF]
CATEGORIA n„o aceit vel

Preencha com:|PL para Plano,| PD p/Diferen‡a ou |AX para Aux.Funeral
MTAB([PL=Plano|PD=Plano c/Diferen‡a|AF=Auxilio],[CATEGORIA])
 0 
 0 


saiu
C
E
 
 3 
 3 
 3 
 13 
 0 
Saiu

 


Preencha com o n£mero da circular|ou|deixe em branco se ainda n„o saiu em cobran‡a

 0 
 0 


grup
C
E
!!
 2 
 2 
 4 
 13 
 0 
Grup

!EMPT(grup).AND.PTAB(grup,'ARQGRUP',1)
GRUP n„o existe na tabela

Pertence a qual grupo

 0 
 0 


num
C
E
999999
 6 
 6 
 4 
 16 
 0 
Num

!EMPT(num).AND.PTAB(num,'GRUPOS',1)
NUM n„o existe na tabela

Qual contrato

 0 
 0 


grau
C
E
9
 1 
 1 
 4 
 23 
 0 
Inscr.

grau $ [12345678].and.(PTAB(num,'INSCRITS',1).or.1=1)
INSCR. n„o aceit vel
IIF(M->pgrau<[7],SUBSTR([1234567],VAL(M->pgrau),1),M->pgrau)
Qual o grau de parentesco|Tecle F8 para consulta
MTAB(M->TBTIPGRAU,[INSCR.])
 0 
 0 


seq
N
E
99
 2 
 2 
 4 
 25 
 0 
Seq
grau>'6'
 


Que sequencia

 0 
 0 


seg
C
E
@!
 35 
 35 
 5 
 13 
 0 
Seg

 


Nome do segurado/Contratante

 0 
 0 


ends
C
E
@!
 40 
 40 
 6 
 13 
 0 
Ends

 




 0 
 0 


cids
C
E
@!
 15 
 15 
 7 
 13 
 0 
Cids

 




 0 
 0 


fal
C
E
@!
 35 
 35 
 8 
 13 
 0 
Fal

!EMPT(fal)
Necess rio informar FAL

Nome do falecido

 0 
 0 


sep
C
E
@!
 35 
 35 
 9 
 13 
 0 
Sep

!EMPT(sep)
Necess rio informar SEP

Sepultado em

 0 
 0 


dfal
D
E
@D
 8 
 10 
 10 
 13 
 0 
Data

 


Data do falecimento

 0 
 0 


 1 
T.Carˆncia
IIF(INSCRITS->tcarencia>dfal,[Carˆncia do Inscrito],[])

 4 
 29 
 22 

 9 
ARQGRUP
procpend
ARQGRUP->procpend + 1
ARQGRUP->procpend - 1
saiu<'001'.AND.PTAB(grup,'ARQGRUP',1)


ARQGRUP
partic
ARQGRUP->partic - 1
ARQGRUP->partic + 1
saiu<'001'.AND.PTAB(grup,'ARQGRUP',1)


GRUPOS
funerais
GRUPOS->funerais + 1
GRUPOS->funerais - 1
PTAB(num,'GRUPOS',1)


GRUPOS
particv
GRUPOS->particv - 1
GRUPOS->particv + 1
PTAB(num,'GRUPOS',1)


GRUPOS
particf
GRUPOS->particf + 1
GRUPOS->particf - 1
PTAB(num,'GRUPOS',1)


INSCRITS
vivofalec
[F]
[V]
PTAB(num+grau+STR(seq,02,00),'INSCRITS',1)


INSCRITS
falecto_
dfal
ctod('  /  /  ')
PTAB(num+grau+STR(seq,02,00),'INSCRITS',1)


INSCRITS
tipo
categ
[  ]
PTAB(num+grau+STR(seq,02,00),'INSCRITS',1)


INSCRITS
procnr
processo
[ ]
PTAB(num+grau+STR(seq,02,00),'INSCRITS',1)


 0 
 0 
 0 
      SIxMemo                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 €
 ADR_RX29#–Þ  ADR_RX29CODEREL_CABCODEC_ETEXTENDCODE	_SYMSTARTSYMSTARTSYMBOLSSYMBOLS_SYMENDSYMENDNULLBEGDATA_DATADATA_SYMPBDATA_SYMPDATA_SYMPEDATA_CONSTCONST_MSGMSG_BEGBSSBEGBSS_BSSBSS_ENDBSSENDBSSDGROUP§˜ @-Û˜ @ò %˜ H  ˜ h  	ç˜ `€
d˜ h  ß˜ h  Û˜ H  ÷˜ H  ó˜ H ç˜ H  ë˜ H  ç˜ (  CLIPPER POECEP
BLINKER FI POECEP,SIXCDX,SIXUK,DBT @SIX3
COPY POECEP.EXE \VIP4\ARQUIVOS /Y
CD \VIP4\ARQUIVOS
€
 BXR_02F9B–Ñ  BXR_02F9CODEC_ETEXTENDCODE	_SYMSTARTSYMSTARTSYMBOLSSYMBOLS_SYMENDSYMENDNULLBEGDATA_DATADATA_SYMPBDATA_SYMPDATA_SYMPEDATA_CONSTCONST_MSGMSG_BEGBSSBEGBSS_BSSBSS_ENDBSSENDBSSDGROUP˜ @˜ H  ˜ h  ë˜ `	Þ˜ h  
ã˜ h  ß˜ H  û˜ H  ÷˜ H ë˜ H  ï˜ H  ë˜ (  ˜ H  /*
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
 \ Empresa.: PresServ Inform tica - Limeira (019)452.6623
 \ Programa: GUI_08F9.PRG
 \ Data....: 23-05-98
 \ Sistema.: Administradora - RECEP€„O
 \ Funcao..: Fun‡„o de preenchimento do campo m‚dico, arquivo GUIAS
 \ Analista: Ademilson Pedro Bom
 \ Criacao.: Programado manualmente pelo analista
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/

#include "adrbig.ch"    // inicializa constantes manifestas

//LOCAL reg_dbf:=POINTER_DBF()

PRIVA respx:=SPACE(10),nomx:=space(35)
PTAB([],[MEDICOS],1,.t.)
IF EMPT(medico)
 nomx=DBOX("Nome",,,,,"Informe o nome a procurar",nomx,"@!")
 IF PTAB(alltrim(nomx),[MEDICOS],2)
	medico:=MEDICOS->crm
 ENDI
 medico:=VDBF(6,3,20,77,'MEDICOS',{'especialid','nome','cidade','endereco','telefone','mensagem','valorpart','ultvalor'},3,'crm',[])
 IF LASTKEY()=K_ESC             // se teclou ESC
	medico=space(10)
//	POINTER_DBF(reg_dbf)
	RETU .f.
 ENDI

ENDI
respx:=medico
//dbox([>]+respx+[<])
//POINTER_DBF(reg_dbf)

retu PTAB(respx,[MEDICOS],1)  // <- deve retornar um valor qualquer

* \\ Final de GUI_02F9.PRG
/*
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
 \ Empresa.: Ind£stria de Urnas Bignotto Ltda
 \ Programa: ADM_R027.PRG
 \ Data....: 25-12-95
 \ Sistema.: Administradora de Funer rias
 \ Funcao..: N„o sai Taxas
 \ Analista: Ademilson Pedro Bom
 \ Criacao.: GAS-Pro v2.0
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/

#include "admbig.ch"    // inicializa constantes manifestas

LOCAL dele_atu
PARA  lin_menu, col_menu
nucop=1

#ifdef COM_REDE
 IF !USEARQ("GRUPOS",.f.,10,1)                     // se falhou a abertura do arq
  RETU                                             // volta ao menu anterior
 ENDI
#else
 USEARQ("GRUPOS")                                  // abre o dbf e seus indices
#endi

PTAB(grupo,"ARQGRUP",1,.t.)                        // abre arquivo p/ o relacionamento
PTAB(cobrador,"COBRADOR",1,.t.)
PTAB(grupo+ARQGRUP->proxcirc,"CIRCULAR",1,.t.)
PTAB(regiao,"REGIAO",1,.t.)
SET RELA TO grupo INTO ARQGRUP,;                   // relacionamento dos arquivos
         TO cobrador INTO COBRADOR,;
         TO grupo+ARQGRUP->proxcirc INTO CIRCULAR,;
         TO regiao INTO REGIAO
titrel:=criterio:=cpord := ""                      // inicializa variaveis
titrel:=chv_rela:=chv_1:=chv_2 := ""
tps:=op_x:=ccop := 1
IF !opcoes_rel(lin_menu,col_menu,16,11)            // nao quis configurar...
 CLOS ALL                                          // fecha arquivos e
 RETU                                              // volta ao menu
ENDI
IF tps=2                                           // se vai para arquivo/video
 arq_=ARQGER()                                     // entao pega nome do arquivo
 IF EMPTY(arq_)                                    // se cancelou ou nao informou
  RETU                                             // retorna
 ENDI
ELSE
 arq_=drvporta                                     // porta de saida configurada
ENDI
SET PRINTER TO (arq_)                              // redireciona saida
DBOX("[ESC] Interrompe",15,,,NAO_APAGA)
dele_atu:=SET(_SET_DELETED,.t.)                    // os excluidos nao servem...
SET DEVI TO PRIN                                   // inicia a impressao
maxli=62                                           // maximo de linhas no relatorio
IMPCTL(drvpc20)                                    // comprime os dados
BEGIN SEQUENCE
 DO WHIL ccop<=nucop                               // imprime qde copias pedida
  pg_=1; cl=999
  INI_ARQ()                                        // acha 1o. reg valido do arquivo
  ccop++                                           // incrementa contador de copias
  qqu030=0                                         // contador de registros
  DO WHIL !EOF()
   IF INKEY()=K_ESC                                // se quer cancelar
    IF canc()                                      // pede confirmacao
     BREAK                                         // confirmou...
    ENDI
   ENDI
   // ******************** Programado manualmente
   IF ARQGRUP->proxcirc=[000]                      // se nao imprime o grupo
    SELE ARQGRUP                                   // procura o proximo grupo
    DO WHIL ! EOF() .AND. proxcirc = [000]         // a imprimir
     SKIP
    ENDDO
    chv037x:=IIF(EOF(),'//',grupo)                 // Encontrou ou nao?
    SELE GRUPOS
    IF chv037x=[//]                                // Se nao, encontrou
     GO BOTT                                       // entao tchau!
     LOOP
    ELSE                                           // Se achou o grupo,
     SEEK chv037x                                  // procura o 1§ contrato
    ENDIF
   ENDIF
   // ********************************************


   IF ARQGRUP->proxcirc>[000].AND. !EMPT(R02701F9())// se atender a condicao...
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY REPL("-",102)
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY TRAN(grupo,"!9")                  // Grupo
    @ cl,004 SAY TRAN(codigo,"99999")              // Codigo
    @ cl,011 SAY TRAN(admissao,"@D")               // Admiss„o
    @ cl,020 SAY TRAN(saitxa,"@R 99/99")           // Saitxa
    @ cl,027 SAY TRAN(regiao,"999")                // Regi„o
    @ cl,031 SAY nome                              // Nome
    @ cl,067 SAY endereco                          // Endere‡o
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,005 SAY bairro                            // Bairro
    @ cl,031 SAY cidade+cep                        // Cidade
    @ cl,067 SAY R02701F9()                        // motivo
    @ cl,098 SAY TRAN(cobrador,"!!")               // Cobrador
    qqu030++                                       // soma contadores de registros
    SKIP                                           // pega proximo registro
   ELSE                                            // se nao atende condicao
    SKIP                                           // pega proximo registro
   ENDI
  ENDD
  REL_CAB(1)                                       // soma cl/imprime cabecalho
  @ cl,000 SAY "*** Quantidade total "+TRAN(qqu030,"@E 999,999")
 ENDD ccop
 EJEC                                              // salta pagina
END SEQUENCE
IMPCTL(drvtc20)                                    // retira comprimido
SET PRINTER TO (drvporta)                          // fecha arquivo gerado (se houver)
SET DEVI TO SCRE                                   // direciona saida p/ video
IF tps=2                                           // se vai para arquivo/video
 BROWSE_REL(arq_,2,3,MAXROW()-2,78)                // mostra o arquivo gravado
ENDI
GRELA(16)                                          // grava variacao do relatorio
SELE GRUPOS                                        // salta pagina
SET RELA TO                                        // retira os relacionamentos
SET(_SET_DELETED,dele_atu)                         // os excluidos serao vistos
RETU

STATIC PROC REL_CAB(qt)                            // cabecalho do relatorio
IF qt>0                                            // se parametro maior que 0
 cl=cl+qt                                          // soma no contador de linhas
ENDI
IF cl>maxli .OR. qt=0                              // quebra de pagina
 IMPAC(nemp,0,000)                                 // nome da empresa
 @ 0,089 SAY "PAG"
 @ 0,093 SAY TRAN(pg_,'9999')                      // n£mero da p gina
 IMPAC(nsis,1,000)                                 // t¡tulo aplica‡„o
 @ 1,089 SAY "ADM_R027"                            // c¢digo relat¢rio
 IMPAC("NŽO SAI TAXAS",2,000)
 @ 2,081 SAY NSEM(DATE())                          // dia da semana
 @ 2,089 SAY DTOC(DATE())                          // data do sistema
 @ 3,000 SAY titrel                                // t¡tulo a definir
 IMPAC("Grp/Codigo Admiss„o Saitxa Reg Nome                                Endere‡o",4,000)
 @ 5,005 SAY "Bairro                    Cidade                              motivo                     Cobrador"
 cl=qt+5 ; pg_++
ENDI
RETU

* \\ Final de ADM_R027.PRG
procedure obx_02f9
/*
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
 \ Empresa.: Ind£stria de Urnas Bignotto Ltda
 \ Programa: BXR_02F9.PRG
 \ Data....: 28-11-95
 \ Sistema.: Administradora de Funer rias
 \ Funcao..: Valor inicial do campo VALORPG, arquivo BXREC
 \ Analista: Ademilson Pedro Bom
 \ Criacao.: Programado manualmente pelo analista
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/

#include "adrbig.ch"    // inicializa constantes manifestas

//PARAMETROS('nrauxrec',ano+numero)
IF op_menu = INCLUSAO
 grupo=GRUPOS->grupo
ELSE
 REPL grupo WITH GRUPOS->grupo
ENDIF
RETU 0


* \\ Final de BXR_02F9.PRG

€
 MEN_01F9O–Ñ  MEN_01F9CODEC_ETEXTENDCODE	_SYMSTARTSYMSTARTSYMBOLSSYMBOLS_SYMENDSYMENDNULLBEGDATA_DATADATA_SYMPBDATA_SYMPDATA_SYMPEDATA_CONSTCONST_MSGMSG_BEGBSSBEGBSS_BSSBSS_ENDBSSENDBSSDGROUP˜ @› €˜ H  ˜ h  ë˜ `  	O˜ h  
ã˜ h  ß˜ H  û˜ H  ÷˜ H ë˜ H  ï˜ H  ë˜ (  ˜ H  procedure bx_bxrec
para nrdays
if pcount()<1
 nrdays:=[20]
endi
?
? [Baixando ]+nrdays+[ dias.]
nrdays:=val(nrdays)
crow=row()
ccol=col()
sele b
use taxas
inde on codigo+tipo+circ to taxas EVAL ODOMETER() EVERY 50
sele a
use bxrec
go top

?
? [>>]
do while .not. eof()
// @ crow,ccol say [           ]
// @ crow,ccol say str(recno(),8)
 if BXREC->emitido_ < (DATE() -nrdays)
  skip
  loop
 endi
 ?? [.]
 chave=codigo+tipo+circ
 sele taxas
 seek chave

 IF !EMPT(valorpg).or.codigo<[000001]
  sele bxrec
  skip
  loop
 ENDI
 ?? chr(8)+[;]
 rlock()
 REPL TAXAS->pgto_ WITH BXREC->EMITIDO_,;
	    TAXAS->forma WITH [P]   ,;
	    TAXAS->baixa_ WITH DATE(),;
	    TAXAS->por WITH BXREC->por ,;
	    TAXAS->stat WITH [6]       ,;
	    TAXAS->valorpg WITH BXREC->valorpg
 unlock
 sele bxrec
 skip
enddo

GAS-Pro v1.1

[Ÿ]
[Ÿ]
 0 
 0 
contrato
contrato



 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
€
 TFILIAIS– TFILIAISCODETFI_INCLCODETFI_TELACODETFI_GETSCODETFI_GET1CODETFI_MEMOCODEC_ETEXTENDCODE	_SYMSTARTSYMSTARTSYMBOLSSYMBOLS_SYMENDSYMENDNULLBEGDATA_DATADATA_SYMPBDATA_SYMPDATA_SYMPEDATA_CONSTCONST_MSGMSG_BEGBSSBEGBSS_BSSBSS_ENDBSSENDBSSDGROUPÆ˜ @ö#˜ @šu˜ @˜ @ò	˜ @o
™˜ @a ¦˜ H  û˜ h  ×˜ ``u˜ h  Ï˜ h  Ë˜ H  ç˜ H  GAS-Pro v3.0

[Ÿ]
 0 
TXPROC
Limpa Taxas processadas


TAXAS->stat=[9]
001









-1 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 1 
TXPROC
stat
[9]




 0 
 0 
 1 
TAXAS
 1 
codigo+tipo+circ



/*
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
 \ Empresa.: Ind£stria de Urnas Bignotto Ltda
 \ Programa: CON_R001.PRG
 \ Data....: 15-05-97
 \ Sistema.: Controle de Convˆnios
 \ Funcao..: Emiss„o Guias 1¦ Parte
 \ Analista: Ademilson Pedro Bom
 \ Criacao.: GAS-Pro v3.0
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/

#include "adrbig.ch"    // inicializa constantes manifestas

LOCAL dele_atu, getlist:={}, so_um_reg, sit_dbf:=POINTER_DBF()
PARA  lin_menu, col_menu, imp_reg
PRIV  tem_borda:=.t., op_menu:=VAR_COMPL, l_s:=11, c_s:=20, l_i:=14, c_i:=61, tela_fundo:=SAVESCREEN(0,0,MAXROW(),79)
nucop=1
so_um_reg=(PCOU()>2)
IF !so_um_reg                             // vai receber a variaveis?
 SETCOLOR(drvtittel)
 vr_memo=NOVAPOSI(@l_s,@c_s,@l_i,@c_i)    // pega posicao atual da tela
 CAIXA(mold,l_s,c_s,l_i,c_i)              // monta caixa da tela
 @ l_s,c_s+12 SAY " EMISSŽO DE GUIAS "
 SETCOLOR(drvcortel)
 @ l_s+01,c_s+1 SAY " N£mero:"
ENDI
gnumero=SPAC(7)                                    // N£mero
DO WHILE .t.
 rola_t=.f.
 cod_sos=56
 IF !so_um_reg
  SET KEY K_ALT_F8 TO ROLATELA
  SETCOLOR(drvcortel+","+drvcorget+",,,"+corcampo)
  @ l_s+01 ,c_s+10 GET  gnumero;
                   PICT "@R 99-99999";
                   VALI CRIT("PTAB(gnumero,'GUIAS',1).AND.V00101F9()~N£MERO n„o existe na tabela")
                   DEFAULT "M->pnumero"
                   AJUDA "Emitir a guia de n£mero?"
                   CMDF8 "VDBF(6,8,20,77,'GUIAS',{'numero','grupo','codigo','grau','seq','nome'},1,'numero')"
                   MOSTRA {"LEFT(TRAN(GUIAS->nome,[@!]),35)", 2 , 5 }

  READ
  SET KEY K_ALT_F8 TO
  IF rola_t
   ROLATELA(.f.)
   LOOP
  ENDI
  IF LASTKEY()=K_ESC                               // se quer cancelar
   RETU                                            // retorna
  ENDI
 ENDI

 #ifdef COM_REDE
  IF !USEARQ("GUIAS",.f.,10,1)                     // se falhou a abertura do arq
   RETU                                            // volta ao menu anterior
  ENDI
 #else
  USEARQ("GUIAS")                                  // abre o dbf e seus indices
 #endi

 PTAB(medico,"MEDICOS",1,.t.)                      // abre arquivo p/ o relacionamento
// PTAB(codups,"UPSERV",1,.t.)
 SET RELA TO medico INTO MEDICOS                 // relacionamento dos arquivos
//          TO codups INTO UPSERV
 titrel:=criterio:=cpord := ""                     // inicializa variaveis
 titrel:=chv_rela:=chv_1:=chv_2 := ""
 tps:=op_x:=ccop := 1
 arq_=drvporta                                     // porta de saida configurada
 IF !so_um_reg
  IF !opcoes_rel(lin_menu,col_menu,7,11)           // nao quis configurar...
   CLOS ALL                                        // fecha arquivos e
   LOOP                                            // volta ao menu
  ENDI

 #ifdef COM_REDE

  ELSE

   tps=lin_menu

 #endi

 ENDI
 IF tps=2                                          // se vai para arquivo/video
  arq_=ARQGER()                                    // entao pega nome do arquivo
  IF EMPTY(arq_)                                   // se cancelou ou nao informou
   LOOP                                            // retorna
  ENDI
 ELSE
  arq_=drvporta                                    // porta de saida configurada
 ENDI
 SET PRINTER TO (arq_)                             // redireciona saida
 EXIT
ENDD
IF !EMPTY(drvtapg)                                 // existe configuracao de tam pag?
 op_=AT("NNN",drvtapg)                             // se o codigo que altera
 IF op_=0                                          // o tamanho da pagina
  msg="Configura‡„o do tamanho da p gina!"         // foi informado errado
  DBOX(msg,,,,,"ERRO!")                            // avisa
  CLOSE ALL                                        // fecha todos arquivos abertos
  RETU                                             // e cai fora...
 ENDI                                              // codigo para setar/resetar tam pag
 lpp_024=LEFT(drvtapg,op_-1)+"024"+SUBS(drvtapg,op_+3)
 lpp_066=LEFT(drvtapg,op_-1)+"066"+SUBS(drvtapg,op_+3)
ELSE
 lpp_024:=lpp_066 :=""                             // nao ira mudara o tamanho da pag
ENDI
DBOX("[ESC] Interrompe",15,,,NAO_APAGA)
dele_atu:=SET(_SET_DELETED,.t.)                    // os excluidos nao servem...
SET DEVI TO PRIN                                   // inicia a impressao
maxli=17                                           // maximo de linhas no relatorio
IMPCTL(lpp_024)                                    // seta pagina com 24 linhas
SET MARG TO 1                                      // ajusta a margem esquerda
IF tps=2
 IMPCTL("' '+CHR(8)")
ENDI
BEGIN SEQUENCE
 DO WHIL ccop<=nucop				// imprime qde copias pedida
  pg_=1; cl=999
  IF so_um_reg
   GO imp_reg
  ELSE
   INI_ARQ()                                       // acha 1o. reg valido do arquivo
   IF PTAB(PADR(SUBSTR(M->ide_maq,2),4)+[GUI],[IMPPAR],1)
    SEEK ALLTRIM(IMPPAR->docto)
   ENDI
  ENDI
  ccop++                                           // incrementa contador de copias
  ult_imp=0                                        // ultimo reg impresso
  DO WHIL !EOF().AND.(!so_um_reg.OR.imp_reg=RECN())
   #ifdef COM_TUTOR
    IF IN_KEY()=K_ESC                              // se quer cancelar
   #else
    IF INKEY()=K_ESC                               // se quer cancelar
   #endi
    IF canc()                                      // pede confirmacao
     BREAK                                         // confirmou...
    ENDI
   ENDI
   IF (PTAB(PADR(SUBSTR(M->ide_maq,2),4)+[GUI],[IMPPAR],1).AND.ano+numero=LEFT(IMPPAR->docto,7)) .OR. so_um_reg// se atender a condicao...
    REL_CAB(1,.t.)                                 // soma cl/imprime cabecalho
    @ cl,000 SAY "GUIA DE ENCAMINHAMENTO  N§:"
    @ cl,027 SAY ano+'-'+numero+GDV1(ano+numero)   // N£mero
    @ cl,043 SAY IIF(guiapara='C',[Consulta],IIF(guiapara='E',[Exame],IIF(guiapara='I',[Interna‡„o],[     ])))// Guia Para
    IF M->combarra=[S]
     CODBARRAS({{ano+numero+GDV1(ano+numero),4,10,64}},10,6)
    ENDI
    ult_imp=RECNO()                                // ultimo reg impresso
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY "Para:"
    @ cl,008 SAY TRAN(MEDICOS->especialid,"@!")    // Especialidade
    IF M->combarra=[S]
     CODBARRAS({{ano+numero+GDV1(ano+numero),4,10,64}},10,6)
    ENDI
    REL_CAB(2)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY "Encaminhado a .........:"
    @ cl,025 SAY IIF(!EMPT(medico),ALLTRIM(MEDICOS->nome)+[ (]+ALLTRIM(medico)+[)],[])// M‚dico
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    IMPAC("Endere‡o...............:",cl,000)
    @ cl,025 SAY IIF(!EMPT(medico),MEDICOS->endereco,[])// Endere‡o
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY "Atendimento dia........:"
    @ cl,025 SAY TRAN(emissao_,"@D")               // Emiss„o
    IMPAC("(V lido at‚ 30 dias)",cl,036)
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY "Pessoa a ser atendida..:"
    IMPCTL(drvpenf)
    @ cl,025 SAY TRAN(nome,"@!")                   // Nome
    IMPCTL(drvtenf)
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    IMPAC("Benefici rio principal.:",cl,000)
    @ cl,025 SAY TRAN([ (]+ALLTRIM(titular)+[ / ]+contrato+[)],"@!")// Titular
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY REPL("-",60)
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY "Valor Particular:"
    @ cl,018 SAY TRAN(IIF(!EMPT(medico),MEDICOS->valorpart,0),"@E 99,999,999.99")// Valor Particular
    @ cl,033 SAY "desconto de:"
    IF (IIF(!EMPT(medico),MEDICOS->valorpart,0) - valorcon)>0// pode imprimir?
     @ cl,046 SAY TRAN(IIF(!EMPT(medico),MEDICOS->valorpart,0) - valorcon,"@E 99,999,999.99")// Valor desconto
    ENDI
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY "Valor Total.....:"
    @ cl,018 SAY TRAN(valorcon+ valorexa,"@E 99,999,999.99")// Valor total
    @ cl,032 SAY LEFT([(]+LEFT(EXT(valorcon+valorexa),AT('/',EXT(valorcon+valorexa))-1)+[)],40)// Total p/Extenso
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,016 SAY SUBSTR([(]+LEFT(EXT(valorcon+valorexa),AT('/',EXT(valorcon+valorexa))-1)+[)],41,54)// Extenso (cont..)
    SKIP                                           // pega proximo registro
    cl=999                                         // forca salto de pagina
   ELSE                                            // se nao atende condicao
    SKIP                                           // pega proximo registro
   ENDI
   exit
  ENDD
  REL_RDP(.t.)                                     // imprime rodape' do relatorio
 ENDD ccop
 EJEC                                              // salta pagina
END SEQUENCE
SET MARG TO                                        // coloca margem esquerda = 0
IMPCTL(lpp_066)                                    // seta pagina com 66 linhas
SET PRINTER TO (drvporta)                          // fecha arquivo gerado (se houver)
SET DEVI TO SCRE                                   // direciona saida p/ video
IF tps=2                                           // se vai para arquivo/video
 BROWSE_REL(arq_,2,3,MAXROW()-2,78)
ENDI                                               // mostra o arquivo gravado
GRELA(7)                                           // grava variacao do relatorio
SELE GUIAS                                         // salta pagina
SET RELA TO                                        // retira os relacionamentos
SET(_SET_DELETED,dele_atu)                         // os excluidos serao vistos
IF so_um_reg
 POINTER_DBF(sit_dbf)
ENDI
RETU

STATIC PROC REL_RDP(volta_reg)                     // rodape'
LOCAL reg_atual:=RECNO()
IF volta_reg
 GO ult_imp                                        // ajusta reg p/ imp de campos no rodape'
ENDI
@ 18,000 SAY "" //chr(15)                               // comprime
IMPCTL(drvpcom)
@ 18,002 SAY M->mens_1
@ 19,002 SAY M->mens2
@ 20,002 SAY M->mens3
@ 21,002 SAY M->mens4
@ 22,000 SAY "" //chr(18)                               // normal
IMPCTL(drvtcom)

@ 23,001 SAY replicate('- ',36)                    // traco
IF volta_reg
 GO reg_atual                                      // retorna reg a posicao original
ENDI
RETU 

STATIC PROC REL_CAB(qt, volta_reg)                 // cabecalho do relatorio
volta_reg=IF(volta_reg=NIL,.f.,volta_reg)
IF qt>0                                            // se parametro maior que 0
 cl=cl+qt                                          // soma no contador de linhas
ENDI
IF cl>maxli .OR. qt=0                              // quebra de pagina
 IF pg_>1
  REL_RDP(volta_reg)                               // imprime rodape' do relatorio
 ENDI
 IMPCTL(drvpenf)
 IMPEXP(0,000,LEFT(M->setup1,38),76)               // Setup1
 IMPCTL(drvtenf)
 @ 1,000 SAY M->setup1                            // Defconv
 @ 2,000 SAY M->setup2                             // setup2
 @ 3,000 SAY M->setup3                             // Setup3
 @ 4,000 SAY REPL("-",60)
 cl=qt+4 ; pg_++
ENDI
RETU

* \\ Final de CON_R001.PRG
€
 ADR_R029K–Þ  ADR_R029CODEREL_CABCODEC_ETEXTENDCODE	_SYMSTARTSYMSTARTSYMBOLSSYMBOLS_SYMENDSYMENDNULLBEGDATA_DATADATA_SYMPBDATA_SYMPDATA_SYMPEDATA_CONSTCONST_MSGMSG_BEGBSSBEGBSS_BSSBSS_ENDBSSENDBSSDGROUPÏ˜ @Q¶˜ @7ß˜ H  ˜ h  	ç˜ ` 
ã˜ h  ß˜ h  Û˜ H  ÷˜ H  ó˜ H ç˜ H  ë˜ H  ç˜ (  €
 PRCESSOSü–	 PRCESSOSCODEPRC_INCLCODEPRC_TELACODEPRC_GETSCODEPRC_GET1CODEC_ETEXTENDCODE	_SYMSTARTSYMSTARTSYMBOLSSYMBOLS_SYMENDSYMENDNULLBEGDATA_DATADATA_SYMPBDATA_SYMPDATA_SYMPEDATA_CONSTCONST_MSGMSG_BEGBSSBEGBSS_BSSBSS_ENDBSSENDBSSDGROUPF˜ @«n˜ @;Ô˜ @¶[˜ @°	\˜ @“
m˜ H  ÿ˜ h  Û˜ `Pˆ˜ h  Ó˜ h  Ï˜ H  ë˜ H  ç˜ H GAS-Pro v2.0
001004004078001001001001002000176001
                                                              ,
[Ÿ]
[Ÿ]
 0 
 0 









054







 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 6 
Nome da empresa
nemp

 1 
 2 
 32 

T¡tulo aplica‡„o
nsis

 2 
 2 
 25 

Data do sistema
DATE()

 1 
 65 
 8 

Nome do mˆs
NMES(DATE())

 0 
 0 
 8 

Dia da semana
NSEM(DATE())

 1 
 56 
 7 

Diret¢rio atual
drvdbf

 2 
 50 
 23 

 0 
 0 
 0 
 0 
/*
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
 \ Empresa.: PresServ Inform tica - Limeira (019)452.6623
 \ Programa: ADM_R026.PRG
 \ Data....: 04-11-03
 \ Sistema.: Administradora - RECEP€„O
 \ Funcao..: Capa de Processo
 \ Analista: Ademilson Pedro Bom
 \ Criacao.: GAS-Pro v4.0n
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/

#include "adrbig.ch"    // inicializa constantes manifestas

PRIV dele_atu, cur_atual, getlist:={}
PARA lin_menu, col_menu
PRIV  tem_borda:=.t., op_menu:=VAR_COMPL, l_s:=10, c_s:=20, l_i:=13, c_i:=61, tela_fundo:=SAVESCREEN(0,0,MAXROW(),79)
nucop=1
SETCOLOR(drvtittel)
vr_memo=NOVAPOSI(@l_s,@c_s,@l_i,@c_i)     // pega posicao atual da tela
CAIXA(mold,l_s,c_s,l_i,c_i)               // monta caixa da tela
@ l_s,c_s+10 SAY " IMPRESSŽO AUX.FUNERAL "
SETCOLOR(drvcortel)
@ l_s+01,c_s+1 SAY " Processo:"
@ l_s+02,c_s+1 SAY " Confirme:"
PRIV rproc:=SPAC(11)                               // Processo
PRIV confirme:=SPAC(1)                             // Confirme
DO WHILE .t.
 rola_t=.f.
 cod_sos=56
 SET KEY K_ALT_F8 TO ROLATELA
 SETCOLOR(drvcortel+","+drvcorget+",,,"+corcampo)
 @ l_s+01 ,c_s+12 GET  rproc;
                  PICT "@R 99999/9999-99";
                  VALI CRIT("!EMPT(RPROC).AND.PTAB(M->rproc,[AFUNER],1)~Campo utilizado para localiza‡„o dos documentos.|Tecle F8 para busca em tabela")
                  DEFAULT "IIF(PTAB(PADR(SUBSTR(M->ide_maq,2),4)+[AFU],[IMPPAR],1),ALLTRIM(IMPPAR->docto),[])"
                  AJUDA "Digite neste campo o n£mero de|identifica‡„o do processo"
                  CMDF8 "VDBF(6,12,20,77,'AFUNER',{'processo','proc2','categ','contrato','falecido'},1,'V02001F9()',[])"

 @ l_s+02 ,c_s+12 GET  confirme;
                  PICT "!";
                  VALI CRIT("confirme='S'.AND.V02002F9()~CONFIRME n„o aceit vel|Digite S para confirmar|ou|Tecle ESC para cancelar")
                  AJUDA "Digite S para confirmar|ou|tecle ESC para cancelar"

 READ
 SET KEY K_ALT_F8 TO
 IF rola_t
  ROLATELA(.f.)
  LOOP
 ENDI
 IF LASTKEY()=K_ESC                                // se quer cancelar
  RETU                                             // retorna
 ENDI

 #ifdef COM_REDE
  IF !USEARQ("AFUNER",.f.,10,1)                    // se falhou a abertura do arq
   RETU                                            // volta ao menu anterior
  ENDI
 #else
  USEARQ("AFUNER")                                 // abre o dbf e seus indices
 #endi

 PTAB(contrato,"GRUPOS",1,.t.)                     // abre arquivo p/ o relacionamento
 PTAB(funcresp,"FNCS",1,.t.)
 PTAB(GRUPOS->tipcont,"CLASSES",1,.t.)
 SET RELA TO contrato INTO GRUPOS,;                // relacionamento dos arquivos
          TO funcresp INTO FNCS,;
          TO GRUPOS->tipcont INTO CLASSES
 titrel:=criterio := ""                            // inicializa variaveis
 cpord=""
 chv_rela:=chv_1:=chv_2 := ""
 tps:=op_x:=ccop := 1
 fil_ini=""
 IF !opcoes_rel(lin_menu,col_menu,6,11,fil_ini)    // nao quis configurar...
  CLOS ALL                                         // fecha arquivos e
  LOOP                                             // volta ao menu
 ENDI
 IF tps=2                                          // se vai para arquivo/video
  arq_=ARQGER()                                    // entao pega nome do arquivo
  IF EMPTY(arq_)                                   // se cancelou ou nao informou
   LOOP                                            // retorna
  ENDI
 ELSE
  arq_=drvporta                                    // porta de saida configurada
 ENDI
 SET PRINTER TO (arq_)                             // redireciona saida
 EXIT
ENDD
cur_atual=SETCURSOR(0)
IF !EMPTY(drvtapg)                                 // existe configuracao de tam pag?
 op_=AT("NNN",drvtapg)                             // se o codigo que altera
 IF op_=0                                          // o tamanho da pagina
  msg="Configura‡„o do tamanho da p gina!"         // foi informado errado
  DBOX(msg,,,,,"ERRO!")                            // avisa
  CLOSE ALL                                        // fecha todos arquivos abertos
  RETU                                             // e cai fora...
 ENDI                                              // codigo para setar/resetar tam pag
 lpp_050=LEFT(drvtapg,op_-1)+"050"+SUBS(drvtapg,op_+3)
 lpp_066=LEFT(drvtapg,op_-1)+"066"+SUBS(drvtapg,op_+3)
ELSE
 lpp_050:=lpp_066 :=""                             // nao ira mudara o tamanho da pag
ENDI
dele_atu:=SET(_SET_DELETED,.t.)                    // os excluidos nao servem...
POE_GAUGE("[ESC] Interrompe","AGUARDE...","Emitidos:")
SET DEVI TO PRIN                                   // inicia a impressao
maxli=65                                           // maximo de linhas no relatorio
IMPCTL(lpp_050)                                    // seta pagina com 50 linhas
IMPCTL(drvpde8)                                    // ativa 8 lpp
IF tps=2
 IMPCTL("' '+CHR(8)")
ENDI
BEGIN SEQUENCE
 DO WHIL ccop<=nucop                               // imprime qde copias pedida
  pg_=1; cl=50000
  INI_ARQ()                                        // acha 1o. reg valido do arquivo
  IF EOF()
   EXIT
  ENDI
  ccop++                                           // incrementa contador de copias
  DO WHIL !EOF().AND.POE_GAUGE()
   IF IN_KEY()=K_ESC                               // se quer cancelar
    IF canc()                                      // pede confirmacao
     BREAK                                         // confirmou...
    ENDI
   ENDI
   IF PTAB(PADR(SUBSTR(M->ide_maq,2),4)+[AFU],[IMPPAR],1).and.processo+proc2+filial+categ=ALLTRIM(IMPPAR->docto)// se atender a condicao...
    REL_CAB(3)                                     // soma cl/imprime cabecalho
    @ cl,060 SAY TRAN(processo+proc2+filial,"@R 99999/99/!!")// N£mero Processo
    REL_CAB(12)                                    // soma cl/imprime cabecalho
    @ cl,011 SAY TRAN(falecido,"@!")               // Nome do falecido
    REL_CAB(2)                                     // soma cl/imprime cabecalho
    @ cl,011 SAY ALLTRIM(ruares)+[ ]+ALLTRIM(baires)+'-'+ALLTRIM(munres)// endereco (falecido)
    REL_CAB(2)                                     // soma cl/imprime cabecalho
    @ cl,019 SAY TRAN(falecto_,"@D")               // Data falcto.
    @ cl,056 SAY TRAN(horafal,"99:99")             // Hora Falcto.
    REL_CAB(2)                                     // soma cl/imprime cabecalho
    @ cl,019 SAY TRAN(ALLTRIM(ruafal),"@!")        // Rua Falecimento
    REL_CAB(4)                                     // soma cl/imprime cabecalho
    @ cl,012 SAY TRAN(nomedec,"@!")                // Declarante
    REL_CAB(2)                                     // soma cl/imprime cabecalho
    @ cl,012 SAY ALLTRIM(ruadec)                   // endereco (declarante)
    @ cl,056 SAY fonedec                           // fone declarante
    REL_CAB(11)                                    // soma cl/imprime cabecalho
    @ cl,012 SAY CLASSES->descricao                // tipo de plano
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,025 SAY IIF(categ=[PD],[Plano c/Difer. ],IIF(categ=[PL],[Atend.Plano],[Auxilio Funeral  ]))// Categoria
    REL_CAB(3)                                     // soma cl/imprime cabecalho
    @ cl,012 SAY FNCS->nome                        // Motorista respons vel
    @ cl,050 SAY TRAN(contrato,"@R 999.999999")           // CONTRATO
    @ cl,066 SAY IIF(CLASSES->prior=[S],M->mgrupvip,GRUPOS->grupo)// GRUPO
    REL_CAB(13)                                    // soma cl/imprime cabecalho
    @ cl,015 SAY TRAN(cemitsep,"@!")               // Cemit‚rio Sepultamento
    REL_CAB(2)                                     // soma cl/imprime cabecalho
    @ cl,021 SAY horasepult                        // hora sepultamento
    IF !EMPT(sepult_)                              // pode imprimir?
     @ cl,058 SAY DTOC(sepult_)                    // data sepultamento
    ENDI
    SKIP                                           // pega proximo registro
    cl=50000                                       // forca salto de pagina
   ELSE                                            // se nao atende condicao
    SKIP                                           // pega proximo registro
   ENDI
  ENDD
 ENDD ccop
 EJEC                                              // salta pagina
END SEQUENCE
SETCURSOR(cur_atual)
IMPCTL(drvtde8)                                    // ativa 6 lpp
IMPCTL(lpp_066)                                    // seta pagina com 66 linhas
SET PRINTER TO (drvporta)                          // fecha arquivo gerado (se houver)
SET DEVI TO SCRE                                   // direciona saida p/ video
IF tps=2                                           // se vai para arquivo/video
 BROWSE_REL(arq_,2,3,MAXROW()-2,78)
ENDI          // mostra o arquivo gravado
GRELA(6)                                           // grava variacao do relatorio
SELE AFUNER                                        // seleciona arquivo
SET RELA TO                                        // retira os relacionamentos
SET(_SET_DELETED,dele_atu)                         // os excluidos serao vistos
RETU

STATIC PROC REL_CAB(qt)                            // cabecalho do relatorio
IF qt>0                                            // se parametro maior que 0
 cl=cl+qt                                          // soma no contador de linhas
ENDI
IF cl>maxli .OR. qt=0                              // quebra de pagina
 cl=qt+5 ; pg_++
ENDI
RETU

* \\ Final de ADM_R026.PRG
procedure admbig
/*
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
 \ Empresa.: PresServ Inform tica-Limeira (019)452.6623
 \ Programa: ADMBIG.PRG
 \ Data....: 29-09-96
 \ Sistema.: Administradora - RECEP€„O
 \ Funcao..: Gerenciador geral
 \ Analista: Ademilson Pedro Bom
 \ Criacao.: GAS-Pro v2.0d
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/
#include "admbig.ch"    // inicializa constantes manifestas

/*
   Funcoes chamadas dentro de macros
*/

REQUEST DESCEND, MTAB, VUF, VHORA, EXT, NMES, MMAA, VDV2, LTOC

#include "ADM_PUBL.ch"  // contem variaveis publicas

V0=SAVESCREEN(0,0,MAXROW(),79)
CLEA SCREEN
NAOPISCA()                   // habilita 256 cores (ega/vga)

/*
   rotina utilizando funcoes em assembly  para pegar o nome do programa
   que e  colocado pelo DOS no PSP (Program Segment Prefix) do programa
   que esta  sendo executado. O segmento do ambiente esta  no  endereco
   44/45 do segmento do PSP
*/
VAL_AX("6200")               // funcao 62h retorna segmento do PSP em BX
CALLINT("21")                // executa interrupt 21
x=VAL_BX()                   // pega o segmento do PSP
Sg=PEEK(x,44)+PEEK(x,45)*256 // calcula endereco do segmento de ambiente

/*
   Agora, procura no segmento de ambiente, por dois bytes ZERO seguidos.
   O nome do programa comeca 2 bytes apos os ZEROs
*/
x=0
DO WHIL .t.
 IF PEEK(Sg,x)=0             // este e o primeiro ZERO
  IF PEEK(Sg,x+1)=0          // se o proximo tambem for,
   x+=2                      // entao pula ambos
   EXIT                      // e sai
  ENDI
 ENDI
 x++                         // continua procurando
ENDD
direxe=""
IF PEEK(Sg,x)=1              // se este byte = 1, entao
 x+=2                        // o nome comeca aqui e vai
 DO WHIL PEEK(Sg,x)>0        // at‚ encontrar outro 0
  direxe+=CHR(PEEK(Sg,x))    // pega mais uma letra do nome
  x++
 ENDD
ENDI
direxe=UPPER(LEFT(direxe,RAT("\",direxe)))
arq_sos=direxe+"ADMBIG.SOS"  // nome do arquivo de ajuda
SETCANCEL(.f.)               // desativa ALT-C/BREAK
SET DATE BRIT                // datas no formato 'britasileiro`
SET EXAC OFF                 // comparacoes parciais habilitadas
SET SCOREBOARD OFF           // habilita uso da linha 0
SET WRAP ON                  // habilita rolagem de menus
SET KEY K_ALT_F2  TO doscom  // ALT-F2 ativa DOS-SHELL
SETKEY(K_INS,{||;            // muda tamanho do cursor quando inserindo
              IF(READINSERT(),SETCURSOR(1),SETCURSOR(3)),;
              READINSERT(!READINSERT());
             };
)


/*
   inicializa variaveis publicas
*/
msg:=cpord:=criterio:=chv_rela:=chv_1:=chv_2:=vr_memo := ""
op_sis:=cod_sos:=nucop:=op_posi:=op_menu :=1
nss=21
exrot:=AFILL(ARRAY(nss),""); usuario=""
datac=DATE()
nao_mostra:=l_s:=c_s:=c_i:=l_i := 0
tem_borda:=drvexcl:=drvvisivel := .t.
v_out:=gr_rela:=ve_outros:=cn:=fgrep:=drvmouse :=.f.
tem_t:=fgconf:=drvconf:=brw:=drvincl :=.f.
gcr=CHR(17)+CHR(217); nivelop=3

#ifdef COM_MOUSE
 drvmouse=(MOUSE()>0)                   // verifica e inicializa mouse
 drvratH=8; drvratV=16                  // default da sensibilidade do mouse
 tpo_mouse=0
#endi

drvcara=CHR(250); mold="ÚÄ¿³ÙÄÀ³ÃÄ´"
drvmenucen=.t.; drvfonte=0
drvporta="LPT1"
drvcortna="W/N*"; drvtittna="BG+/N*"
nemp="PresServ Inform tica-Limeira (019)452.6623"
nsis="Administradora - RECEP€„O"
arqgeral="ADM"

#ifdef COM_REDE

 #undef COM_PROTECAO

 drvtempo=25
 ide_maq=RIGHT(ALLTRIM(NETNAME()),4)    // tenta pegar nome da estacao
 IF EMPTY(ide_maq)                      // se netname() retornou nulo,
  ide_maq=LEFT(GETENV("ESTACAO"),4)     // tenta variavel de ambiente ESTACAO
 ENDI
 
 /*
    Se rede, e se NETNAME() do Clipper ou ESTACAO retornam "", pede ao usuario
    a identificacao da estacao para gravar arquivos de configuracoes
    especificos para cada usuario da rede
 */
 IF EMPTY(ide_maq)                 // CA-Clipper nao reconheceu nome da estacao
  cod_sos=49                       // nem existe variavel ambiental,
  msgt="IDENTIFICA€ŽO DA ESTA€ŽO"  // entao, vamos solicitar ao usuario
  SET KEY K_F1 TO                  // desativa help
  ide_maq=DBOX("Nome da esta‡„o",,,,,msgt,SPAC(4),"@!",,"W+/N")
  SET KEY K_F1 TO help             // habilita F1 (help)
  IF LASTKEY()=K_ESC .OR.;         // desistiu...
     EMPTY(ide_maq)                // ou nao informou
   RESTSCREEN(0,0,MAXROW(),79,v0)  // restaura tela
   SETPOS(MAXROW()-1,1)            // cursor na penultima linha, coluna 1
   RETU                            // e volta ao DOS
  ENDI
 ENDI
 ide_maq="_"+ALLTRIM(ide_maq)
 ms_uso="Arquivo sendo acessado|COM EXCLUSIVIDADE"
#else
 ide_maq="_temp"                   // nome do arquivo de configuracoes
#endi

ntxpw=direxe+arqgeral+"PW"
dbfpw=ntxpw+".SYS"                 // nomes dos arquivos de senhas
arqconf=direxe+arqgeral+;          // nome do arquivo de configuracoes
        ide_maq+".sys"
IF FILE(arqconf)
 REST FROM (arqconf) ADDI          // restaura configuracoes gravadas

 #ifdef COM_MOUSE
  IF drvmouse
   drvmouse=(MOUSE()>0)            // verifica e inicializa mouse
   MOUSERAT(drvratH,drvratV)       // ajusta sensibilidade do mouse
  ENDI
 #else
  drvmouse=.f.
 #endi

ELSE
 
 /*
    cria variaveis default de cores, codigos de impressao, etc...
 */
 drvmarca := "Epson"                          // nome da configuracao/marca impressora
 drvprn =1                                    // configuracao atual
 drvtapg="CHR(27)+'C'+CHR(NNN)"               // tamanho da pagina
 drvpcom="CHR(15)"                            // ativa comprimido (17,5 cpp)
 drvtcom="CHR(18)"                            // desativa comprimido (17,5 cpp)
 drvpc20="CHR(27)+'M'+CHR(15)"                // ativa comprimido (20 cpp)
 drvtc20="CHR(27)+'P'"                        // desativa comprimido (20 cpp)
 drvpeli="CHR(27)+'M'"                        // ativa elite
 drvteli="CHR(27)+'P'"                        // desativa elite
 drvpenf="CHR(27)+'E'"                        // ativa enfatizado
 drvtenf="CHR(27)+'F'"                        // desativa enfatizado
 drvpexp="CHR(27)+'W'+CHR(1)"                 // ativa expansao
 drvtexp="CHR(27)+'W'+CHR(0)"                 // desativa expansao
 drvpde8="CHR(27)+'0'"                        // ativa 8 lpp
 drvtde8="CHR(27)+'2'"                        // desativa 8 lpp
 drvland=""                                   // ativa landscape (paisagem)
 drvport=""                                   // ativa portrait (retrato)
 drvsom=.f.                                   // tipo de saida/efeitos sonoro
 drvautohelp=.f.                              // ajuda automatica em campos
 drvdbf:=drvntx:=drverr := PADR(QUALDIR(),23) // diretorio dos dbf's, ntx's e erros.dbf
 drvcorpad="N/BG"   ; drvcorbox="W+/B"        // cores default
 drvcormsg="W+/W"   ; drvcorenf="W+/R"
 drvcorget="GR+/N*" ; drvcortel="W+/B"
 drvcorhlp="BG+/B"  ; drvcortna="W/N*"
 drvtitpad="GR+/BG" ; drvtitbox="GR+/B"       // cores dos titulos default
 drvtitmsg="GR+/W"  ; drvtitenf="GR+/R"
 drvtitget="R+/N*"  ; drvtittel="GR+/B"
 drvtithlp="GR+/B"  ; drvtittna="BG+/N*"
 CBC1()                            // monta cabecalho e pano de fundo
 ALERTA()
 cod_sos=2
 IF !PEGADIR(.t.)                  // se nao informou diretorios de trabalho
  RESTSCREEN(0,0,MAXROW(),79,v0)   // restaura tela
  SETPOS(MAXROW()-1,1)             // cursor na penultima linha, coluna 1
  RETU                             // de volta ao DOS
 ENDI
 
 /*
    cria arquivo de senha e o inicializa com o primeiro usuario
 */
 IF !FILE(dbfpw)                    // nao encontrou arquivo de senhas,
  DBCREATE(dbfpw,{;                 // entao, cria estrutura
                  {"pass","C", 6,0},;
                  {"nome","C",15,0},;
                  {"nace","C", 1,0},;
                  {"ex01","C",20,0},;
                  {"ex02","C",20,0},;
                  {"ex03","C",20,0},;
                  {"ex04","C",20,0},;
                  {"ex05","C",20,0},;
                  {"ex06","C",20,0},;
                  {"ex07","C",20,0},;
                  {"ex08","C",20,0},;
                  {"ex09","C",20,0},;
                  {"ex10","C",20,0},;
                  {"ex11","C",20,0},;
                  {"ex12","C",20,0},;
                  {"ex13","C",20,0},;
                  {"ex14","C",20,0},;
                  {"ex15","C",20,0},;
                  {"ex16","C",20,0},;
                  {"ex17","C",20,0},;
                  {"ex18","C",20,0},;
                  {"ex19","C",20,0},;
                  {"ex20","C",20,0},;
                  {"ex21","C",20,0};
                 };
  )

  #ifdef COM_REDE
   USEARQ(dbfpw,.t.,20,1,.f.)       // tenta abrir senhas, exclusivo
  #else
   USE (dbfpw)                      // abre arquivo de senhas
  #endi

  INDE ON pass TO (ntxpw)           // indexa pela password
  APPE BLAN                         // credencia usuario ficticio (1o. acesso)
  senha=PWORD(arqgeral)             // com senha = tres primeiras letras
  REPL nome WITH ENCRIPT(SPAC(15)),;
       pass WITH senha, nace WITH ENCRIPT("3")
  USE
 ENDI
ENDI
arq_prn=drverr+"PRINTERS.DBF"            // nome dbf de "drivers" da prn
IF !FILE(arq_prn)                        // se o arquivo de "drivers"
 DBCREATE(arq_prn,{;                     // de impressoras nao existir
                   {"marca","C",15,0},;  // entao vamos cria-lo
                   {"porta","C", 4,0},;
                   {"tapg", "C",40,0},;
                   {"pcom", "C",40,0},;
                   {"tcom", "C",40,0},;
                   {"pc20", "C",40,0},;
                   {"tc20", "C",40,0},;
                   {"peli", "C",40,0},;
                   {"teli", "C",40,0},;
                   {"penf", "C",40,0},;
                   {"tenf", "C",40,0},;
                   {"pexp", "C",40,0},;
                   {"texp", "C",40,0},;
                   {"pde8", "C",40,0},;
                   {"tde8", "C",40,0},;
                   {"land", "C",40,0},;
                   {"port", "C",40,0};
                  };
 )

 #ifdef COM_REDE
  USEARQ(arq_prn,.t.,20,1,.f.)      // tenta abrir configuracoes, exclusivo
 #else
  USE (arq_prn)                     // abre arquivo de configuracoes
 #endi

 APPE BLAN                          // inclui uma configuracao
 REPL marca WITH drvmarca,;         // marca da impressora
      porta WITH drvporta,;         // porta de saida
      tapg  WITH drvtapg,;          // tamanho da pagina
      pcom  WITH drvpcom,;          // ativa comprimido (17,5 cpp)
      tcom  WITH drvtcom,;          // desativa comprimido (17,5 cpp)
      pc20  WITH drvpc20,;          // ativa comprimido (20 cpp)
      tc20  WITH drvtc20,;          // desativa comprimido (20 cpp)
      peli  WITH drvpeli,;          // ativa elite
      teli  WITH drvteli,;          // desativa elite
      penf  WITH drvpenf,;          // ativa enfatizado
      tenf  WITH drvtenf,;          // desativa enfatizado
      pexp  WITH drvpexp,;          // ativa expansao
      texp  WITH drvtexp,;          // desativa expansao
      pde8  WITH drvpde8,;          // ativa 8 lpp
      tde8  WITH drvtde8,;          // desativa 8 lpp
      land  WITH drvland,;          // ativa landscape
      port  WITH drvport            // ativa portrait
 USE
ENDI
MUDAFONTE(drvfonte)                 // troca a fonte de caracteres
corcampo=drvtittel                  // cor "unselected"
SETCOLOR(drvcorpad+","+drvcorget+",,,"+corcampo)
SET(_SET_DELETED,!drvvisivel)       // visibilidade dos reg excluidos
CBC1()                              // monta cabecalho e pano de fundo

/*
   se informado drive A para criar arquivo, previne preparo do disquete
*/
IF ASC(drvdbf)=65.OR.ASC(drvntx)=65 // informou drive A
 ALERTA()
 cod_sos=1
 op_a=DBOX("Disco pronto|Cancelar a opera‡„o",,,E_MENU,,"DISCO DE DADOS EM "+LEFT(drvdbf,1))
 IF op_a!=1
  RESTSCREEN(0,0,MAXROW(),79,v0)    // restaura tela
  SETPOS(MAXROW()-1,1)              // cursor na penultima linha, coluna 1
  RETU
 ENDI
ENDI
AFILL(sistema:=ARRAY(nss+1),{})     // enche sistema[] com vetores nulos
ADM_ATRI()                          // enche sistema[] com atributos dos arquivos
ADM_ATR1()
ADM_ATR2()

/*
   verifica qual subscricao do vetor SISTEMA corresponde ao arquivo
   aberto na area selecionada
*/
qualsis={|db_f|db_:=db_f,ASCAN(sistema,{|si|si[O_ARQUI]==db_})}

#ifdef COM_PROTECAO
 
 /*
    protege arquivo de dados contra acesso dBase e muda para "read-only"
    vamos comentar este "code block" ...
 */
 protdbf={|fg|pt:=fg,;                             // torna a flag visivel no proximo "code block"
           tel_p:=SAVESCREEN(0,0,MAXROW(),79),;    // salva a tela
           DBOX("Um momento!",,,,NAO_APAGA),;      // mensagem ao usuario
           AEVAL(sistema,{|sis|;                   // executa o "code block" para cada
                           EDBF(drvdbf+;           // um dos arquivos do vetor sistema
                                sis[O_ARQUI],pt);  // (se pt, desprotege; senao, protege)
                         };
           ),;
           RESTSCREEN(0,0,MAXROW(),79,tel_p);      // restaura a tela
         }
#endi

IF !FILE(dbfpw)                                    // se nao existir arquivo de
 ALERTA()                                          // senhas, avisa
 DBOX("Arquivo de senhas ausente!",,,2)
 RESTSCREEN(0,0,MAXROW(),79,v0)                    // restaura a tela
 SETPOS(MAXROW()-1,1)                              // cursor na penultima linha, coluna 1
 RETU                                              // retorna ao DOS
ENDI

#ifdef COM_REDE
 IF ! USEARQ(dbfpw,.f.,20,1,.f.)                   // falhou abertura modo compartilhado,
  RESTSCREEN(0,0,MAXROW(),79,v0)                   // restaura tela
  SETPOS(MAXROW()-1,1)                             // cursor na penultima linha, coluna 1
  RETU                                             // retorna ao DOS
 ENDI
#else
 EDBF(dbfpw,.t.)                                   // desprotege arquivo de
 USE (dbfpw)                                       // senhas e o utiliza
#endi

IF !FILE(ntxpw+".ntx")                             // se nao ha indice,
 INDE ON pass TO (ntxpw)                           // cria o arquivo indice
ENDI
SET INDE TO (ntxpw)
IF ASC(nace)>48 .AND. ASC(nace)<52                 // previne erro

 #ifdef COM_REDE
  IF !BLOARQ(3,.5)                                 // se nao conseguiu bloquear o arquivo,
   RESTSCREEN(0,0,MAXROW(),79,v0)                  // restaura tela
   SETPOS(MAXROW()-1,1)                            // cursor na penultima linha, coluna 1
   RETU                                            // retorna ao DOS
  ENDI
 #endi

 REPL ALL nace WITH ENCRIPT(nace),;                // manipulacao das senhas
          nome WITH ENCRIPT(nome)                  // criptografando o nivel e nome

 #ifdef COM_REDE
  UNLOCK                                           // libera arquivo
 #endi

ENDI
cod_sos=15
COLORSELECT(COR_GET)
v1=SAVESCREEN(0,0,MAXROW(),79)
CAIXA(mold,10,22,14,58,440)
@ 11,30 SAY "INFORME A SUA SENHA"                  // monta janela para
@ 12,35 SAY "Þ      Ý"                             // solicitar a entrada
@ 13,31 SAY "ESC para recome‡ar"                   // da senha de acesso
cp_=1
DO WHIL .t.
 COLORSELECT(COR_GET)
 senha=PWORD(12,36)                                // recebe a senha do usuario
 COLORSELECT(COR_PADRAO)
 SEEK senha                                        // ve se esta' credenciado
 IF FOUND()                                        // OK!
  usuario=TRIM(DECRIPT(nome))                      // nome do usuario
  senhatu=senha                                    // sua senha
  nivelop=VAL(DECRIPT(nace))                       // seu nivel
  FOR t=1 TO nss                                   // exrot[] contera' as
   msg=RIGHT(STR(100+t),2)                         // rotinas nao acessadas
   exrot[t]=ex&msg.                                // para cada subsistema
  NEXT
  IF nivelop>0.AND.nivelop<4                       // de 1 a 3...
   DBOX("Bom trabalho, "+usuario,13,45,2)          // boas vindas!
   EXIT                                            // use e abuse...
  ENDI
 ELSE
  IF cp_<2                                         // epa! senha invalida
   cp_++                                           // vamos dar outra chance
   ALERTA()                                        // estamos avisando!
   DBOX("Senha inv lida!",,,1)
   COLORSELECT(COR_GET)
   @ 12,36 SAY SPAC(6)
  ELSE                                             // errou duas vezes!
   ALERTA()                                        // este pode ser um E.T.
   DBOX("Usu rio n„o autorizado!",,,2)

   #ifndef COM_REDE
    EDBF(dbfpw,.f.)                                // protege o arquivo de senhas
   #endi

   #ifdef COM_PROTECAO
    EVAL(protdbf,.f.)                              // protege DBF
   #endi

   RESTSCREEN(0,0,MAXROW(),79,v0)                  // restaura tela,
   SETPOS(MAXROW()-1,1)                            // cursor na penultima linha, coluna 1
   MUDAFONTE(0)                                    // retorna com a fonte normal
   RETU                                            // e tchau!
  ENDI
 ENDI
ENDD
RESTSCREEN(0,0,MAXROW(),79,v1)                     // restaura tela
USE                                                // fecha o arquivo de senhas

#ifdef COM_PROTECAO
 EVAL(protdbf,.t.)                                 // desprotege DBFs
#endi

msg_auto="Opera‡„o n„o autorizada, "+usuario
IF !CRIADBF()                                      // se DBF nao criado,

 #ifdef COM_PROTECAO
  EVAL(protdbf,.f.)                                // protege DBF
 #endi

 RESTSCREEN(0,0,MAXROW(),79,v0)                    // restaura tela
 SETPOS(MAXROW()-1,1)                              // cursor na penultima linha, coluna 1
 RETU                                              // volta ao DOS
ENDI
SET CONF (drvconf)                                 // ajusta SET CONFIRM
cod_sos=1
ALERTA(1)
msg="Atualize a data de hoje"
datac=DBOX(msg,,,,,"ATEN€ŽO!",datac,"99/99/99")    // confirma a data
IF UPDATED()                                       // se modificou sugestao,
 DOSDATA(DTOC(datac))                              // vamos atualizar o DOS
ENDI
dbfparam=drvdbf+"PAR_ADM"
SELE A

#ifdef COM_REDE
 USEARQ(dbfparam,.t.,,,.f.)
#else
 USE (dbfparam)
#endi


/*
   cria variaveis de memoria publicas identicas as de arquivo,
   para serem usadas por toda a aplicacao
*/
FOR i=1 TO FCOU()
 msg=FIEL(i)
 M->&msg.=&msg.
NEXT
USE
CBC1()                                             // atualiza parametros do cabecalho
opc_01=1
v01=SAVESCREEN(0,0,MAXROW(),79)
DO WHIL opc_01!=0
 cod_sos=3
 RESTSCREEN(0,0,MAXROW(),79,v01)
 menu01="Lan‡amentos|"+;
        "A.Funeral|"+;
        "Relat¢rios|"+;
        "Tabelas|"+;
        "Apoio"
 msgt="MENU GERAL DO SISTEMA"
 opc_01=DBOX(menu01,5,7,E_MENU,NAO_APAGA,msgt,,,opc_01)
 BEGIN SEQUENCE
  DO CASE
   CASE opc_01=0      // retornar ao DOS
    ALERTA()
    msgt="ENCERRAMENTO"
    msg ="Finalizar opera‡”es|N„o finalizar"
    cod_sos=1
    op_=DBOX(msg,,,E_MENU,,msgt,,,1)
    IF op_=1
     MUDAFONTE(0)
    ELSE
     opc_01=1
    ENDI

   CASE opc_01=1     // lan‡amentos
    opc_02=1
    v02=SAVESCREEN(0,0,MAXROW(),79)
    DO WHIL opc_02!=0
     cod_sos=4
     RESTSCREEN(0,0,MAXROW(),79,v02)
     menu02="Recebimento de Taxas|"+;
            "Consulta Contrato|"+;
            "Endere‡os|"+;
            "Outros Recebimentos"
     msgt="LAN€AMENTOS"
     opc_02=DBOX(menu02,7,15,E_MENU,NAO_APAGA,msgt,,,opc_02)
     DO CASE
      CASE opc_02=1     // recebimento de taxas
       BXREC(9,23)

      CASE opc_02=2     // consulta contrato
       TXACONTR(9,23)

      CASE opc_02=3     // endere‡os
       ALENDER(9,23)

      CASE opc_02=4     // outros recebimentos
       OBXEC(9,23)

     ENDC
     CLEA GETS
     CLOS ALL
    ENDD

   CASE opc_01=2     // a.funeral
    opc_02=1
    v02=SAVESCREEN(0,0,MAXROW(),79)
    DO WHIL opc_02!=0
     cod_sos=4
     RESTSCREEN(0,0,MAXROW(),79,v02)
     menu02="Lan‡amento Aux.Funeral|"+;
            "Impress„o Aux.Funeral|"+;
            "Relat¢rio de Processo|"+;
            "Capa de Processo|"+;
            "Processar Pgto em"
     msgt="A.FUNERAL"
     opc_02=DBOX(menu02,7,15,E_MENU,NAO_APAGA,msgt,,,opc_02)
     DO CASE
      CASE opc_02=1     // lan‡amento aux.funeral
       AFUNER(9,23)

      CASE opc_02=2     // impress„o aux.funeral
       ADM_R020(9,23)

      CASE opc_02=3     // relat¢rio de processo
       ADM_R029(9,23)

      CASE opc_02=4     // capa de processo
       ADM_R026(9,23)

      CASE opc_02=5     // processar pgto em
       ADM_R021(9,23)

     ENDC
     CLEA GETS
     CLOS ALL
    ENDD

   CASE opc_01=3     // relat¢rios
    opc_02=1
    v02=SAVESCREEN(0,0,MAXROW(),79)
    DO WHIL opc_02!=0
     cod_sos=4
     RESTSCREEN(0,0,MAXROW(),79,v02)
     menu02="Recibo COM falecidos|"+;
            "Recibos Sem Falecidos|"+;
            "Endere‡os Alterados|"+;
            "Outros recibos (2¦Via)|"+;
            "Fechamento Caixa|"+;
            "Fechamento 2¦Via"
     msgt="RELAT¢RIOS"
     opc_02=DBOX(menu02,7,15,E_MENU,NAO_APAGA,msgt,,,opc_02)
     DO CASE
      CASE opc_02=1     // recibo com falecidos
       ADM_R018(9,23)

      CASE opc_02=2     // recibos sem falecidos
       ADM_RS18(9,23)

      CASE opc_02=3     // endere‡os alterados
       ADM_R022(9,23)

      CASE opc_02=4     // outros recibos (2¦via)
       ADM_R023(9,23)

      CASE opc_02=5     // fechamento caixa
       ADM_R039(9,23)

      CASE opc_02=6     // fechamento 2¦via
       ADM_R050(9,23)

     ENDC
     CLEA GETS
     CLOS ALL
    ENDD

   CASE opc_01=4     // tabelas
    opc_02=1
    v02=SAVESCREEN(0,0,MAXROW(),79)
    DO WHIL opc_02!=0
     cod_sos=4
     RESTSCREEN(0,0,MAXROW(),79,v02)
     menu02="Grupos|"+;
            "Categoria dos Planos|"+;
            "Regi”es|"+;
            "Circulares|"+;
            "Cobradores/Vendedores|"+;
            "Processos|"+;
            "Contratos|"+;
            "Funcion rios|"+;
            "Hist¢rico Padr„o|"+;
            "Pgtos / Recebtos"
     msgt="TABELAS"
     opc_02=DBOX(menu02,7,15,E_MENU,NAO_APAGA,msgt,,,opc_02)
     DO CASE
      CASE opc_02=1     // grupos
       ARQGRUP(9,23)

      CASE opc_02=2     // categoria dos planos
       CLASSES(9,23)

      CASE opc_02=3     // regi”es
       REGIAO(9,23)

      CASE opc_02=4     // circulares
       CIRCULAR(9,23)

      CASE opc_02=5     // cobradores/vendedores
       COBRADOR(9,23)

      CASE opc_02=6     // processos
       PRCESSOS(9,23)

      CASE opc_02=7     // contratos
       GRUPOS(9,23)

      CASE opc_02=8     // funcion rios
       FNCS(9,23)

      CASE opc_02=9     // hist¢rico padr„o
       HISTORIC(9,23)

      CASE opc_02=10     // pgtos / recebtos
       ORDPGRC(9,23)

     ENDC
     CLEA GETS
     CLOS ALL
    ENDD

   CASE opc_01=5     // apoio
    opc_02=1
    v02=SAVESCREEN(0,0,MAXROW(),79)
    DO WHIL opc_02!=0
     op_menu=PROJECOES
     cod_sos=9
     RESTSCREEN(0,0,MAXROW(),79,v02)
     menu02="Parƒmetros|"+;
            "Vˆ relat¢rio gravado|"+;
            "Backup|"+;
            "Restaura backup|"+;
            "Reconstr¢i ¡ndices|"+;
            "Elimina reg apagados|"+;
            "Configura ambiente|"+;
            "Plano de senhas"
     msgt="APOIO"
     opc_02=DBOX(menu02,7,15,E_MENU,NAO_APAGA,msgt,,,opc_02)
     DO CASE
      CASE opc_02=1     // parƒmetros
       PAR_ADM(9,23)

      CASE opc_02=2     // vˆ relat¢rio gravado
       arq_=ARQGER()                               // pega nome do arquivo
       IF !EMPTY(arq_)                             // se cancelou ou nao informou
        cod_sos=1
        BROWSE_REL(arq_,2,3,MAXROW()-2,78)         // mostra o arquivo gravado
       ENDI

      CASE opc_02=3     // backup
       GBAK()

      CASE opc_02=4     // restaura backup
       RBAK()

      CASE opc_02=5     // reconstr¢i ¡ndices
       cod_sos=39
       RCLA()

      CASE opc_02=6     // elimina reg apagados
       cod_sos=40
       COMPACTA()

      CASE opc_02=7     // configura ambiente
       opc_03=1
       v03=SAVESCREEN(0,0,MAXROW(),79)
       DO WHIL opc_03!=0
        cod_sos=41
        RESTSCREEN(0,0,MAXROW(),79,v03)
        menu03="ÿ Diret¢rio de trabalho|"+;
               "ÿ Marca da impressoraÿÿ|"+;
               "ÿ Pano de fundoÿÿÿÿÿÿÿÿ|"+;
               "ÿ Fontes de caracteresÿ|"+;
               "ÿ Esquemas de coresÿÿÿÿ|"+;
               IF(drvconf,"û ","ÿ ")+"Confirma em camposÿÿÿ|"+;
               IF(drvexcl,"û ","ÿ ")+"Confirma exclus”esÿÿÿ|"+;
               IF(drvincl,"û ","ÿ ")+"Confirma inclus”esÿÿÿ|"+;
               IF(drvvisivel,"û ","ÿ ")+"Excluidos vis¡veisÿÿÿ|"+;
               IF(drvsom,"û ","ÿ ")+"Efeitos sonorosÿÿÿÿÿÿ|"+;
               IF(drvautohelp,"û ","ÿ ")+"Ajuda de campo ativaÿ|"+;
               IF(drvmouse,"û ","ÿ ")+"Liga/desliga mouseÿÿÿ|"+;
               "ÿ Sensibilidade mouseÿÿ"
        msgt="CONFIGURA AMBIENTE"
        opc_03=DBOX(menu03,9,23,E_MENU,NAO_APAGA,msgt,,,opc_03)
        DO CASE
         CASE opc_03=1     // diret¢rio de trabalho
          cod_sos=2
          PEGADIR(.f.)

         CASE opc_03=2     // marca da impressora
          CONFPRN()

         CASE opc_03=3     // pano de fundo
          cod_sos=43; msg=""                       // menu de caracteres para fundo
          FOR t=1 TO 255                           // enche msg com as opcoes
           IF t!=124                               // exceto o '|` que e o
            msg+="|"+STR(t,3)+" - "+CHR(t)         // caracter separador das
           ENDI                                    // opcoes da DBOX(
          NEXT
          t=ASC(drvcara)-IF(ASC(drvcara)>123,1,0)
          op_x=DBOX(SUBS(msg,2),,31,E_MENU,,"FUNDO",,,t)
          IF op_x!=0                               // escolhido um caracter
           op_x+=IF(op_x>123,1,0)                  // desconta o '|`
           IF drvcara!=CHR(op_x)                   // se caracter
            drvcara=CHR(op_x)                      // diferente do atual
            SAVE TO (arqconf) ALL LIKE drv*        // grava configuracoes,
            CBC1()                                 // monta tela principal e
            v01=SAVESCREEN(0,0,MAXROW(),79)        // salva para o break
            BREAK                                  // que foi configurado
           ENDI
          ENDI

         CASE opc_03=4     // fontes de caracteres
          op_x=1; cod_sos=53
          msgf=MUDAFONTE(999)
          DO WHILE op_x!=0 .AND.LEN(msgf)>0
           msgf=STRTRAN(msgf,CHR(251)," ")
           msgf=LEFT(msgf,13*drvfonte)+CHR(251)+SUBS(msgf,13*drvfonte+2)
           op_x=DBOX(msgf,11,31,E_MENU,,"FONTES",,,drvfonte+1)
           IF op_x>0
            drvfonte=op_x-1
            MUDAFONTE(drvfonte)
           ENDI
          ENDD

         CASE opc_03=5     // esquemas de cores
          CONFCORES()

         CASE opc_03=6     // confirma em campos
          drvconf=!drvconf
          SET(_SET_CONFIRM,drvconf)

         CASE opc_03=7     // confirma exclus”es
          drvexcl=!drvexcl

         CASE opc_03=8     // confirma inclus”es
          drvincl=!drvincl

         CASE opc_03=9     // excluidos vis¡veis
          drvvisivel=!drvvisivel
          SET(_SET_DELETED,!drvvisivel)

         CASE opc_03=10     // efeitos sonoros
          drvsom=!drvsom

         CASE opc_03=11     // ajuda de campo ativa
          drvautohelp=!drvautohelp

         CASE opc_03=12     // liga/desliga mouse
          IF MOUSE()>0
           drvmouse=!drvmouse
          ENDI
         CASE opc_03=13     // sensibilidade mouse
          cod_sos=45
          AJMOUSE()
        ENDC
        CLEA GETS
        CLOS ALL
       ENDD
       SAVE TO (arqconf) ALL LIKE drv*             // diferente do atual

      CASE opc_02=8     // plano de senhas
       cod_sos=17
       MASENHA(7,23)
     ENDC
     CLEA GETS
     CLOS ALL
    ENDD

  ENDC
 END
 CLEA GETS
 CLOS ALL
ENDD

#ifndef COM_REDE
 EDBF(dbfpw,.f.)                                   // protege arquivo senhas
#endi

#ifdef COM_PROTECAO
 EVAL(protdbf,.f.)                                 // protege DBF
#endi

RESTSCREEN(0,0,MAXROW(),79,v0)                     // s'imbora
SETPOS(MAXROW()-1,1)                               // e cursor na penultima linha, coluna 1
RETU                                               // volta ao DOS

* \\ Final de ADMBIG.PRG
€
 R03001F9©–Ñ  R03001F9CODEC_ETEXTENDCODE	_SYMSTARTSYMSTARTSYMBOLSSYMBOLS_SYMENDSYMENDNULLBEGDATA_DATADATA_SYMPBDATA_SYMPDATA_SYMPEDATA_CONSTCONST_MSGMSG_BEGBSSBEGBSS_BSSBSS_ENDBSSENDBSSDGROUPh˜ @+ ð˜ H  ˜ h  ë˜ `0 	¿˜ h  
ã˜ h  ß˜ H  û˜ H  ÷˜ H ë˜ H  ï˜ H  ë˜ (  ˜ H  ÿØÿà JFIF      ÿÛ „ 
(Branch 14/09/2010 - pedro:
-Alterado layout da cartinha, eliminado o " grupo ", informacao anexada
ao campo circular.

Branch 01/06/2010 - pedro:
-Corrigido o tamanho da tela de mensagens apresentadas para cada contrato,
alterado de 50 para 60 caracteres.
-Alterado o processo do campo GRUPOS->obs no lancamento e manutencao do
arquivo MFILIAL.

Branch 18/05/2010 - pedro:
-Incluida rotina de impressao da ficha de acerto (adm_rx76) com as mensagens
de obs apresentadas pela rotina CAD_04F9.

Branch 13/05/2010 - pedro:
-Incluida rotina de impressao de cartinha (adm_r101)

Branch 28/04/2009 - pedro:
-Incluida a mensagem "Favor verificar endereco e telefone" em cad_04f9.

Branch 19/02/2008 - pedro:
-Refeita a rotina de apresentacao de mensagens em tela (cad_04f9) para
apresentar mais conteudos e aumentar o tamanho da linha
-Refeita a rotina de controle de inclusao/exclusao do arquivo Mfilial
para melhorar o controle dos registros lancados.


Branch 03/01/2008 - pedro:
-Alterada a impressao de todos os documentos de auxilio, incluido o campo
filial na indentificacao do processo. programas adm_r029, adm_r026,
adm_r021, adm_rx20, adr_r029, adr_rx29.

Branch 27/04/2007 - pedro:
-Incluida data de vencimento (TAXAS->emissao_) na impressao do recibo.

Alteracoes manuais:
adrbig
incluir os includes:
#include "SIXNSX.CH"
#define RDDNAME "SIXNSX"
#define MEMOEXT ".SMT"

adr_atri
Refazer as definicoes:

sistema[005]={;
	    "Taxas",;                                       // opcao do menu
	    "Cadastro de Taxas",;                           // titulo do sistema
	    {"codigo","codlan"},;                 // chaves do arquivo
	    {"Contrato","Cod.Lanc"},;                       // titulo dos indices para consulta
	    {"01","15"},;                               // ordem campos chaves
	    {"TAXAS",drvdbf,drvntx},;                       // nome do DBF
	    {"TAXAS1","TAXAS2"},;                           // nomes dos NTX

sistema[007]={;
	    "Inscritos",;                                   // opcao do menu
	    "Inscritos",;                                   // titulo do sistema
	    {"codigo","nome"},;                        // chaves do arquivo
	    {"Codigo","Nome"},;                             // titulo dos indices para consulta
	    {"01","05"},;                                 // ordem campos chaves
	    {"INSCRITS",drvdbf,drvntx},;                    // nome do DBF
	    {"INSCRIT1","INSCRIT2"},;                       // nomes dos NTX

adr_estr
PROC TAX_estr     // estrutura do arquivo TAXAS
DBCREATE(dbf,{;
               {"codigo"    ,"C", 18, 0},; // @S10@!
PROC INS_estr     // estrutura do arquivo INSCRITS
DBCREATE(dbf,{;
               {"codigo"    ,"C", 18, 0},; // @S10@!
PROC ECO_estr     // estrutura do arquivo ECOB
DBCREATE(dbf,{;
	       {"codigo"    ,"C", 18, 0},; // @S10@!

Alterar as definicoes:
adrbig.lnk = adrlnk.ok
adrbig.rmk -> alterar de rtlink para blinker
adr_adap.lnk = adr_lnk.ok
adr_adap.rmk ->alterar de rtlink para blinker

Incluir a linha de busca aos inscritos nos arquivos OBXEC e BXREC
  SET KEY K_F9 TO veoutros                         // habilita consulta em outros arquivos
  SET KEY K_F2 TO veinscrits()                         // habilita consulta em outros arquivos


GAS-Pro v4.0
009009017075001001015001010000176001
 C¢digo.....:             Abreviatura:
 Nome.......:
 Endereco...:
 Cidade.....:
 Ref........:
 Contato....:
[Ÿ]
Inclus„o~~26006
Manuten‡„o~~27007
Consulta~~28008
[Ÿ]
 7 
 1 
C¢digo

 1 
[Ÿ]
Filiais
Filiais

nivelop>1
Permitido apenas a usu rios cadastrados|com n¡vel de Manuten‡„o ou Maior
nivelop>1
Permitido apenas a usu rios cadastrados|com n¡vel de Manuten‡„o ou Maior
nivelop>1
Permitido apenas a usu rios cadastrados|com n¡vel de Manuten‡„o ou Maior
005


nivelop>1
Permitido apenas a usu rios cadastrados|com n¡vel de Manuten‡„o ou Maior




















 0 











 0 
 1 
-1 
-1 
 0 
-1 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
codigo
C
E
@!
 2 
 2 
 1 
 15 
 0 
C¢digo

!EMPT(codigo)
Necess rio informar C¢DIGO

Informe o c¢digo da filial

 0 
 0 


abrev
C
E
 
 25 
 25 
 1 
 40 
 0 
Abreviatura

!EMPT(abrev)
Necess rio informar ABREVIATURA

Dˆ um nome abreviado para a filial|Ser  utilizada para identifica‡Æo nas telas

 0 
 0 


nome
C
E
@!
 50 
 50 
 2 
 15 
 0 
Nome

!EMPT(nome)
Necess rio informar NOME

Entre com o nome da filial

 0 
 0 


endereco
C
E
@!
 50 
 50 
 3 
 15 
 0 
Endereco

 




 0 
 0 


cidade
C
E
@!
 50 
 50 
 4 
 15 
 0 
Cidade

 




 0 
 0 


ref
M
E

 10 
 35 
 5 
 15 
 0 
Ref

 




 0 
 0 


contato
C
E
@!
 20 
 20 
 6 
 15 
 0 
Contato

!EMPT(contato)
Necess rio informar CONTATO



 0 
 0 


 0 
 0 
 0 
 0 
 0 
/*
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
 \ Empresa.: PresServ Inform tica - Limeira (019)452.6623
 \ Programa: ADR_MANU.PRG
 \ Data....: 22-01-08
 \ Sistema.: Administradora - RECEP€„O
 \ Funcao..: Menu geral de auxilio da aplica‡„o
 \ Analista: Ademilson Pedro Bom
 \ Criacao.: GAS-Pro v4.0o
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/

#include "adrbig.ch"    // inicializa constantes manifestas

opc_01=1
v01=SAVESCREEN(0,0,MAXROW(),79)
arqx_:=M->arq_sos
arq_sos=direxe+"ADRBIG.TXT"  // nome do arquivo de ajud
menu02:=[]
contx:=0
IF FILE(arq_sos)
 txtini:=MEMOREAD(arq_sos) // texto
 nLines:=MLCOUNT(M->txtini,56)
 FOR nCurrLine = 1 TO nLines
  Lineaux:=MEMOLINE(txtini, 56, nCurrLine)
  IF LineAux=[\0]
   LineAux:=SUBSTR(LineAux,6,RAT([ -],LineAux)-3)+[~]+SUBSTR(LineAux,3,2)
   menu02+=LineAux+[|]
  ENDI
 NEXT
 opc_02=1
 v02=SAVESCREEN(0,0,MAXROW(),79)
 DO WHIL opc_02!=0
  RESTSCREEN(0,0,MAXROW(),79,v02)
  msgt="PROCEDIMENTOS"
  ROLAPOP(1)
  opc_02=DBOX(menu02,1,2,E_MENU,NAO_APAGA,msgt,,,opc_02)
  ROLAPOP()
  IF !EMPT(opc_02)
   txt_cut1:=SUBSTR(txtini,AT([\0]+strzero(opc_02,2),txtini)+56)
   txt_cut1:=LEFT(txt_cut1,AT([\0],txt_cut1))

   cod_sos:=opc_02
   HELP_PROC()
  ENDIF
 ENDD
ENDI
M->arq_sos:=arqx_
RETU

PROC HELP_PROC    // Apresenta ajuda on-line
LOCAL tela_, txt, ctr, t, cor_, qdlin_, linf_, estr_db, pg_up, pg_dn,;
      tec_f3, tec_f4, tec_f9, tec_f8
SETKEY(K_F1,NIL)                                     // evita recursividade
pg_up =SETKEY(K_PGUP,NIL)                            // desabilita PgUp,
pg_dn =SETKEY(K_PGDN,NIL)                            // PgDn,
tec_f3=SETKEY(K_F3,NIL)                              // F3,
tec_f4=SETKEY(K_F4,NIL)                              // F4,
tec_f9=SETKEY(K_F9,NIL)                              // F9 e
tec_f8=SETKEY(K_ALT_F8,NIL)                          // ALT-F8
tela_=SAVESCREEN(0,0,MAXROW(),79)                    // salva a tela por baixo e
cor_=SETCOLOR(drvtithlp)                             // o esquema de cor vigente
 txt=txt_cut1
 qdlin_=MLCOUNT(txt,56)                              // qde linhas
 maxlt_ =MAXROW()
 linf_ =IF(qdlin_>maxlt_-7,maxlt_-3,qdlin_+3)        // calcula linha inferior
 CAIXA(mold,2,10,linf_,69,392)                       // monta janela
 ctr=IF(qdlin_>maxlt_-6," "+CHR(K_CTRL_X)+" "+;      // monta teclas de controle
        CHR(K_CTRL_Y)+" PgUp PgDn","")+" ESC "       // disponiveis na janela
 @ linf_,(80-LEN(ctr))/2 SAY ctr                     // mostra teclas de controle
 SETCOLOR(drvcorhlp)

 #ifdef COM_TUTOR
  MEMOEDIT(txt,3,12,linf_-1,68,.f.,"mHelp")          // mostra o bloco de ajuda
 #else
  MEMOEDIT(txt,3,12,linf_-1,68,.f.)                  // mostra o bloco de ajuda
 #endi

SETCOLOR(cor_)
RESTSCREEN(0,0,MAXROW(),79,tela_)
SETKEY(K_PGUP,pg_up)                                 // habilita teclas PgUp,
SETKEY(K_PGDN,pg_dn)                                 // PgDn,
SETKEY(K_F3,tec_f3)                                  // F3,
SETKEY(K_F4,tec_f4)                                  // F4,
SETKEY(K_F9,tec_f9)                                  // F9 e
SETKEY(K_ALT_F8,tec_f8)                              // ALT-F8
SET KEY K_F1 TO help                                 // habilita F1
RETU

func mkinx
para filetxt
 txtini:=MEMOREAD(filetxt) // texto
 nLines:=MLCOUNT(M->txtini,56)
 posinx:=0
 FOR nCurrLine = 1 TO nLines
  Lineaux:=MEMOLINE(txtini, 56, nCurrLine)
  posinx+=LEN(lineaux)
  IF LineAux=[\0]
   LineAux:=SUBSTR(LineAux,6,RAT([ -],LineAux)-3)+[~]+SUBSTR(LineAux,3,2)
   menu02+=strzero(posinx+2,8)
  ENDI
 NEXT
 menu02+=repl([0],1920-len(menu02))
// memowrite([adrbig.inx],menu02)
retu
GAS-Pro v4.0
002003024079001006012001008001176001
                                                                      PAG

                                ALTERA€ŽO DE ENDERE€OS
------------------------------------------------------------------------------
                                          ³
Alterar                     DE:           ³ PARA:        (                   )
Ender..                                   ³
Bairro.                                   ³
Cidade.                                   ³
[Ÿ]
 11 
ALENDER
Endere‡os Alterados


EMPT(emitido_).AND.(EMPT(M->musuario).OR.por=M->musuario).AND.data_>=M->emisini_.AND.data_<=M->emisfim_
011

























 0 
 1 










 0 
 2 
 0 
 66 
 0 
 4 
 2 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
Codigo
dgrupo+'-'+codigo

 9 
C
 6 
 9 


ûû        










Endere‡o
endereco

 35 
C
 7 
 45 


          










Bairro
bairro

 25 
C
 8 
 45 


          










Cidade
cidade

 25 
C
 9 
 45 


          










CEP
cep
@R 99999-999
 9 
C
 9 
 71 


          










Data_
data_
@D
 8 
D
 6 
 70 


          










Por
por
 
 10 
C
 6 
 59 


          










Endere‡o
dendereco

 35 
C
 7 
 8 


          










Bairro
dbairro

 25 
C
 8 
 8 


          










Cidade
dcidade

 25 
C
 9 
 8 


          










CEP
dcep
@R 99999-999
 9 
C
 9 
 34 


          










 9 
Nome da empresa
nemp

 1 
 1 
 32 

T¡tulo aplica‡„o
nsis

 2 
 1 
 25 

Data do sistema
DTOC(DATE())

 3 
 71 
 8 

Nome do mˆs
NMES(DATE())

 0 
 0 
 8 

Dia da semana
NSEM(DATE())

 3 
 63 
 7 

N£mero da p gina
TRAN(pg_,'9999')

 1 
 75 
 4 

C¢digo relat¢rio
"ADM_R022"

 2 
 71 
 8 

T¡tulo a definir
titrel

 3 
 1 
 30 

Hora da emiss„o
hora_rel_

 0 
 0 
 5 

 8 
GRUPOS
endereco
endereco

PTAB(codigo,'GRUPOS',1)


GRUPOS
bairro
bairro




GRUPOS
cidade
cidade




GRUPOS
cep
cep




GRUPOS
cobrador
cobrador




GRUPOS
ender_
DATE()




GRUPOS
ultend
M->usuario




ALENDER
emitido_
DATE()




 0 
 0 
 1 
GRUPOS
 1 
codigo



/*
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
 \ Empresa.: PresServ Inform tica-Limeira (019)452.6623
 \ Programa: ADM_R020.PRG
 \ Data....: 22-09-97
 \ Sistema.: Administradora - RECEP€„O
 \ Funcao..: Impress„o Aux.Funeral 1
 \ Analista: Ademilson Pedro Bom
 \ Criacao.: GAS-Pro v3.0 
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/

#include "adrbig.ch"    // inicializa constantes manifestas

LOCAL dele_atu, getlist:={}, so_um_reg, sit_dbf:=POINTER_DBF()
PARA  lin_menu, col_menu, imp_reg
PRIV  tem_borda:=.t., op_menu:=VAR_COMPL, l_s:=10, c_s:=20, l_i:=13, c_i:=61, tela_fundo:=SAVESCREEN(0,0,MAXROW(),79)
nucop=1
so_um_reg=(PCOU()>2)
IF !so_um_reg                             // vai receber a variaveis?
 SETCOLOR(drvtittel)
 vr_memo=NOVAPOSI(@l_s,@c_s,@l_i,@c_i)    // pega posicao atual da tela
 CAIXA(mold,l_s,c_s,l_i,c_i)              // monta caixa da tela
 @ l_s,c_s+10 SAY " IMPRESSŽO AUX.FUNERAL "
 SETCOLOR(drvcortel)
 @ l_s+01,c_s+1 SAY " Processo:"
 @ l_s+02,c_s+1 SAY " Confirme:"
ENDI
rproc=SPAC(11)                                     // Processo
confirme=SPAC(1)                                   // Confirme
DO WHILE .t.
 rola_t=.f.
 cod_sos=56
 IF !so_um_reg
  SET KEY K_ALT_F8 TO ROLATELA
  SETCOLOR(drvcortel+","+drvcorget+",,,"+corcampo)
  @ l_s+01 ,c_s+12 GET  rproc;
                   PICT "@R 99999/9999-99";
                   VALI CRIT("!EMPT(RPROC).AND.PTAB(rproc,[AFUNER],1)~Campo utilizado para localiza‡„o dos documentos.|Tecle F8 para busca em tabela")
                   DEFAULT "IIF(PTAB(PADR(SUBSTR(M->ide_maq,2),4)+[AFU],[IMPPAR],1),ALLTRIM(IMPPAR->docto),[])"
                   AJUDA "Digite neste campo o n£mero de|identifica‡„o do processo"
                   CMDF8 "VDBF(6,12,20,77,'AFUNER',{'processo','proc2','categ','contrato','falecido'},1,'V02001F9()',[])"

  @ l_s+02 ,c_s+12 GET  confirme;
                   PICT "!";
                   VALI CRIT("confirme='S'.AND.V02002F9()~CONFIRME n„o aceit vel|Digite S para confirmar|ou|Tecle ESC para cancelar")
                   AJUDA "Digite S para confirmar|ou|tecle ESC para cancelar"

  READ
  SET KEY K_ALT_F8 TO
  IF rola_t
   ROLATELA(.f.)
   LOOP
  ENDI
  IF LASTKEY()=K_ESC                               // se quer cancelar
   RETU                                            // retorna
  ENDI
 ENDI

 #ifdef COM_REDE
  IF !USEARQ("AFUNER",.f.,10,1)                    // se falhou a abertura do arq
   RETU                                            // volta ao menu anterior
  ENDI
 #else
  USEARQ("AFUNER")                                 // abre o dbf e seus indices
 #endi

 PTAB(contrato,"GRUPOS",1,.t.)                     // abre arquivo p/ o relacionamento
 PTAB(contrato,"INSCRITS",1,.t.)
 SET RELA TO contrato INTO GRUPOS,;                // relacionamento dos arquivos
          TO contrato INTO INSCRITS
 titrel:=criterio:=cpord := ""                     // inicializa variaveis
 titrel:=chv_rela:=chv_1:=chv_2 := ""
 tps:=op_x:=ccop := 1
 arq_=drvporta                                     // porta de saida configurada
 IF !so_um_reg
  IF !opcoes_rel(lin_menu,col_menu,1,11)           // nao quis configurar...
   CLOS ALL                                        // fecha arquivos e
   LOOP                                            // volta ao menu
  ENDI

 #ifdef COM_REDE

  ELSE

   tps=lin_menu

 #endi

 ENDI
 IF tps=2                                          // se vai para arquivo/video
  arq_=ARQGER()                                    // entao pega nome do arquivo
  IF EMPTY(arq_)                                   // se cancelou ou nao informou
   LOOP                                            // retorna
  ENDI
 ELSE
  arq_=drvporta                                    // porta de saida configurada
 ENDI
 SET PRINTER TO (arq_)                             // redireciona saida
 EXIT
ENDD
DBOX("[ESC] Interrompe",15,,,NAO_APAGA)
dele_atu:=SET(_SET_DELETED,.t.)                    // os excluidos nao servem...
SET DEVI TO PRIN                                   // inicia a impressao
maxli=62                                           // maximo de linhas no relatorio
BEGIN SEQUENCE
 DO WHIL ccop<=nucop                               // imprime qde copias pedida
  pg_=1; cl=999
  IF so_um_reg
   GO imp_reg
  ELSE
   INI_ARQ()                                       // acha 1o. reg valido do arquivo
  ENDI
  ccop++                                           // incrementa contador de copias
  DO WHIL !EOF().AND.(!so_um_reg.OR.imp_reg=RECN())
   #ifdef COM_TUTOR
    IF IN_KEY()=K_ESC                              // se quer cancelar
   #else
    IF INKEY()=K_ESC                               // se quer cancelar
   #endi
    IF canc()                                      // pede confirmacao
     BREAK                                         // confirmou...
    ENDI
   ENDI
   IF (PTAB(PADR(SUBSTR(M->ide_maq,2),4)+[AFU],[IMPPAR],1).and.processo+proc2+filial+categ=ALLTRIM(IMPPAR->docto)) .OR. so_um_reg// se atender a condicao...
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,054 SAY "Processo"
    IMPCTL(drvpenf)
    @ cl,063 SAY TRAN(processo+proc2,"@R 99999/99")// Nr.Processo
    IMPCTL(drvtenf)
    REL_CAB(2)                                     // soma cl/imprime cabecalho
    @ cl,003 SAY "Nome do Contratante:"
    IMPCTL(drvpenf)
    @ cl,024 SAY TRAN(IIF(PTAB(contrato+GRUPOS->titular,'INSCRITS',1),INSCRITS->nome,GRUPOS->nome),"@!")// Nome do contratante
    IMPCTL(drvtenf)
    REL_CAB(2)                                     // soma cl/imprime cabecalho
    IMPAC("Endere‡o:",cl,003)
    IMPCTL(drvpenf)
    @ cl,013 SAY TRAN(GRUPOS->endereco,"@!")       // Endereco contratante
    IMPCTL(drvtenf)
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,005 SAY "Cidade               Estado  Documento de Identidade Estado Civil"
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    IMPCTL(drvpenf)
    @ cl,005 SAY TRAN(GRUPOS->cidade,"@!")         // cidade contratante
    IMPCTL(drvtenf)
    @ cl,028 SAY TRAN([  ],"!!")                   // Estado Contratante
    IMPCTL(drvpenf)
    @ cl,037 SAY GRUPOS->rg                        // Doc
    IMPCTL(drvtenf)
    IMPCTL(drvpenf)
    @ cl,059 SAY TRAN(subst(tbestciv,AT(GRUPOS->estcivil,tbestciv),10),"@!")// Est.Civil contratante
    IMPCTL(drvtenf)
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    IMPAC("Contrato    Grupo            Admiss„o                 Processo",cl,005)
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    IMPCTL(drvpenf)
    @ cl,006 SAY contrato                          // contrato numero
    IMPCTL(drvtenf)
    IMPCTL(drvpenf)
    @ cl,018 SAY GRUPOS->grupo                     // grupo
    IMPCTL(drvtenf)
    IMPCTL(drvpenf)
    @ cl,034 SAY GRUPOS->admissao                  // data admissao
    IMPCTL(drvtenf)
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    IMPMEMO(R02001F9(),70,1,cl,001,.t.)            // pedido (memo)
    qli_m=MLCOUNT(R02001F9(),70)-1                 // quantas linhas a imprimir?
    li_m=0
    DO WHIL .t.                                    // imprime linhas do memo
     li_m++
     IF li_m>qli_m                                 // fim do memo
      EXIT
     ENDI
     REL_CAB(1)                                    // soma cl/imprime cabecalho
     IMPMEMO(R02001F9(),70,1+li_m,cl,001,(li_m<qli_m))      // imprime...
     #ifdef COM_TUTOR
      IF IN_KEY()=K_ESC                            // se quer cancelar
     #else
      IF INKEY()=K_ESC                             // se quer cancelar
     #endi
      IF canc()                                    // pede confirmacao
       BREAK                                       // confirmou...
      ENDI
     ENDI
    ENDD
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,004 SAY "Nome do falecido....:"
    IMPCTL(drvpenf)
    @ cl,026 SAY TRAN(falecido,"@!")               // nome do falecido
    IMPCTL(drvtenf)
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    IMPAC("Endere‡o do falecido:",cl,004)
    IMPCTL(drvpenf)
    @ cl,026 SAY TRAN(ALLTRIM(ruares)+[, ]+ALLTRIM(baires),"@!")// Endereco falecido
    IMPCTL(drvtenf)
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,004 SAY "Inscrito neste contrato na qualidade de"
    IMPCTL(drvpenf)
    @ cl,044 SAY grauparcon                        // Inscrito na qualidade de
    IMPCTL(drvtenf)
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,004 SAY "Data do Falecimento.:"
    @ cl,026 SAY TRAN(falecto_,"@D")               // Data falcto.
    IMPAC("Hor rio do Falecimento:",cl,036)
    @ cl,060 SAY TRAN(horafal,"99:99")             // Hora Falcto.
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,004 SAY "Cidade do Falecimento Estado   Local do falecimento"
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    IMPCTL(drvpenf)
    @ cl,004 SAY municfal                          // Cidade Falecimento
    @ cl,028 SAY TRAN(estfal,"!!")                 // UF falecimento
    @ cl,035 SAY ALLTRIM(ruafal)                   // local falecimento
    IMPCTL(drvtenf)
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    IMPAC("Cemit‚rio onde foi sepultado        Hora do sepultamento",cl,004)
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    IMPCTL(drvpenf)
    @ cl,004 SAY cemitsep                          // Cemit‚rio sepultamento
    @ cl,046 SAY TRAN(horasepult,"99:99")          // Hora sepultamento
    IMPCTL(drvtenf)
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    IMPCTL(drvpenf)
    IMPAC("DECLARA€ŽO",cl,031)
    IMPCTL(drvtenf)
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    IMPMEMO(R02002F9(),70,1,cl,002,.t.)            // DECLARACAO (memo)
    qli_m=MLCOUNT(R02002F9(),70)-1                 // quantas linhas a imprimir?
    li_m=0
    DO WHIL .t.                                    // imprime linhas do memo
     li_m++
     IF li_m>qli_m                                 // fim do memo
      EXIT
     ENDI
     REL_CAB(1)                                    // soma cl/imprime cabecalho
     IMPMEMO(R02002F9(),70,1+li_m,cl,002,(li_m<qli_m))      // imprime...
     #ifdef COM_TUTOR
      IF IN_KEY()=K_ESC                            // se quer cancelar
     #else
      IF INKEY()=K_ESC                             // se quer cancelar
     #endi
      IF canc()                                    // pede confirmacao
       BREAK                                       // confirmou...
      ENDI
     ENDI
    ENDD
    REL_CAB(2)                                     // soma cl/imprime cabecalho
    @ cl,025 SAY IMPAC(RTRIM(M->p_cidade)+[, ]+LEFT(DTOC(DATE()),2)+[ de ]+NMES(MONTH(DATE()))+ [ de ]+LEFT(DTOS(DATE()),4))// DATA
    REL_CAB(2)                                     // soma cl/imprime cabecalho
    @ cl,001 SAY "PROCESSAR"
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY "PAGAMENTO EM"
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    IMPCTL(drvpenf)
    @ cl,002 SAY TRAN(procpagto_,"@D")             // Proc.pagto em
    IMPCTL(drvtenf)
    REL_CAB(3)                                     // soma cl/imprime cabecalho
    @ cl,021 SAY REPL("-",42)
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,021 SAY "Ass.:"
    IMPCTL(drvpenf)
    @ cl,027 SAY GRUPOS->nome                      // Nome
    IMPCTL(drvtenf)
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,027 SAY "RG:"
    @ cl,031 SAY TRAN(GRUPOS->rg,"@!")             // R.G.
    SKIP                                           // pega proximo registro
    cl=999                                         // forca salto de pagina
   ELSE                                            // se nao atende condicao
    SKIP                                           // pega proximo registro
   ENDI
  ENDD
 ENDD ccop
END SEQUENCE
SET PRINTER TO (drvporta)                          // fecha arquivo gerado (se houver)
SET DEVI TO SCRE                                   // direciona saida p/ video
IF tps=2                                           // se vai para arquivo/video
 BROWSE_REL(arq_,2,3,MAXROW()-2,78)
ENDI                                               // mostra o arquivo gravado
GRELA(1)                                           // grava variacao do relatorio
SELE AFUNER                                        // salta pagina
SET RELA TO                                        // retira os relacionamentos
SET(_SET_DELETED,dele_atu)                         // os excluidos serao vistos
IF so_um_reg
 POINTER_DBF(sit_dbf)
ENDI
RETU

STATIC PROC REL_CAB(qt)                            // cabecalho do relatorio
IF qt>0                                            // se parametro maior que 0
 cl=cl+qt                                          // soma no contador de linhas
ENDI
IF cl>maxli .OR. qt=0                              // quebra de pagina
 @ 0,001 SAY IIF(categ=[PD],[Plano c/Difer. ],IIF(categ=[PL],[Atend.Plano],[Rest.Desp.Funerais]))// Categoria
 @ 5,021 SAY M->setup1                             // Ident1
    IMPCTL(drvpenf)
 IMPAC("REQUERIMENTO DE RESTITUI€ŽO DE DESPESAS",6,021)
 @ 7,022 SAY "FUNERAIS E TERMO DE RESPONSABILIDADE"
    IMPCTL(drvtenf)
 cl=qt+8 ; pg_++
ENDI
RETU

* \\ Final de ADM_R020.PRG
procedure v03301f9
/*
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
 \ Empresa.: Grupo Bom Pastor
 \ Programa: V03301F9.PRG
 \ Data....: 07-11-96
 \ Sistema.: Administradora -CRD/COBRAN€A
 \ Funcao..: Valida‡„o da variavel CONFIRME, relatorio ADM_R033
 \ Analista: Ademilson Pedro Bom
 \ Criacao.: Programado manualmente pelo analistad
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/

#include "adrbig.ch"    // inicializa constantes manifestas
PARAMETROS('mcodigo',rcodigo)
PARAMETROS('mcirc',rcirc)
RETU .t.   // <- deve retornar um valor L¢GICO

* \\ Final de V03301F9.PRG
GAS-Pro v4.0
009015016068001001001001010000176001
 C¢digo ³ Descri‡„o                      ³ Cobrador
ÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄ
        ³                                ³
        ³                                ³
        ³                                ³
        ³                                ³
[Ÿ]
Inclus„o~~26006
Manuten‡„o~~27007
Consulta~~28008
[Ÿ]
 3 
 2 
p/C¢digo

 1 
[Ÿ]
Nome

 2 
[Ÿ]
Regi”es
Regi”es

nivelop>1
Permitido apenas a usu rios cadastrados|com n¡vel de Manuten‡„o ou Maior
nivelop>1
Permitido apenas a usu rios cadastrados|com n¡vel de Manuten‡„o ou Maior
nivelop>1
Permitido apenas a usu rios cadastrados|com n¡vel de Manuten‡„o ou Maior
005


nivelop>1
Permitido apenas a usu rios cadastrados|com n¡vel de Manuten‡„o ou Maior




















 0 











 0 
 1 
-1 
-1 
-1 
-1 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
codigo
C
V
999
 3 
 3 
 3 
 2 
 0 
C¢digo






 0 
 1 


regiao
C
E
 
 30 
 30 
 3 
 11 
 0 
Descri‡„o

!EMPT(regiao)
Necess rio informar a REGIAO

Informe o nome do bairro, distrito ou regi„o

 0 
 0 


cobrador
C
E
!!!
 3 
 3 
 3 
 44 
 0 
Cobrador

PTAB(cobrador,'COBRADOR',1).OR.EMPT(cobrador)
Necess rio informar COBRADOR

Informe o c¢digo do cobrador.|F8 consulta em tabela.
VDBF(6,11,20,77,'COBRADOR',{'cobrador','nome','cidade'},1,'cobrador')
 0 
 0 


 0 
 0 
 0 
 0 
 0 
GAS-Pro v4.0
004002023079001017030001021001176001
 Processo..:      /  /    de             Categoria:
 ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ   Dados do Contratante  ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 Contrato...:
 Grau.......:
 Respons vel:                                     (Declarante)
 Endere‡o...:                                      Fone:
 ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ   Dados do Falecido   ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 Inscrito..:
 Rua...:                                 Bairro:
 Cidade:                           UF:     Dt.Nasc.:
 ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ   Dados do Falecimento   ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 Data:            hora:        Endere‡o:
               Cidade:                           UF:
 Seu sepultamento ser  ..:            hora:
                Cemit‚rio:
 Funcion rio respons vel.:

 Proc. Pgto em:              Vl.Auxilio:                Pago em
[Ÿ]
Inclus„o~~26006            
Manuten‡„o~~27007
Consulta~~28008
[Ÿ]
 29 
 3 
Processo

 1 
 2 
[Ÿ]
Nome Falecido

 12 
 1 
[Ÿ]
Data e Local Fal.

 20 
[Ÿ]
Aux¡lio Funeral
Lan‡amento Aux.Funeral

nivelop>1
Permitido apenas a usu rios cadastrados|com n¡vel de Manuten‡„o ou Maior
nivelop>1
Permitido apenas a usu rios cadastrados|com n¡vel de Manuten‡„o ou Maior
nivelop>1
Permitido apenas a usu rios cadastrados|com n¡vel de Manuten‡„o ou Maior
005


nivelop>1
Permitido apenas a usu rios cadastrados|com n¡vel de Manuten‡„o ou Maior
































 0 
 1 
-1 
-1 
 0 
-1 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
processo
C
E
99999
 5 
 5 
 1 
 14 
 0 
Processo

!EMPT(PROCESSO)
Este ‚ um campo obrigat¢rio!|Ele ‚ usado como chave principal|para localiza‡„o dos documentos.

Digite neste campo o n£mero de|identifica‡„o do processo

 0 
 1 


proc2
C
E
99
 2 
 2 
 1 
 20 
 0 
Ano

!EMPT(proc2)
Necess rio informar ANO
RIGHT(DTOC(DATE()),2)
Informe o ano correspondente ao processo.

 0 
 0 


filial
C
I
@!
 2 
 2 
 0 
 0 
 0 
Filial






 0 
 0 


ocorr_
D
E
@D
 8 
 10 
 1 
 30 
 0 
Data ocorrˆncia

!EMPTY(ocorr_)
DATA OCORRENCIA n„o pode estar vazia
DATE()
Entre com a Data de Ocorrˆncia

 0 
 0 


categ
C
E
!!
 2 
 2 
 1 
 53 
 0 
Categoria

categ $ [PL|PD|AF]
CATEGORIA n„o aceit vel
[AF]
Preencha com:|PL para Plano,| PD p/Diferen‡a ou |AX para Aux.Funeral
MTAB([PL=Plano|PD=Plano c/Diferen‡a|AF=Auxilio],[CATEGORIA])
 0 
 0 


contrato
C
E
@!
 9 
 9 
 3 
 15 
 0 
Contrato

PTAB(contrato,'GRUPOS',1).AND.CAD_04F9(op_menu).AND.(PTAB(contrato,'TAXAS',1).OR.PTAB(GRUPOS->grupo,'ARQGRUP',1).OR.1=1)
CONTRATO n„o existe em arquivo de tabela

Informe o n£mero do contrato
VDBF(6,3,20,77,'GRUPOS',{'codigo','grupo','nome','endereco'},1,'codigo',[])
 0 
 0 


grauparcon
C
E
 
 10 
 10 
 4 
 15 
 0 
Parentesco

 


Informe o grau de parentesco deste com o falecido.

 0 
 0 


nomedec
C
E
@!
 35 
 35 
 5 
 15 
 0 
Nome

!EMPT(nomedec)
Necess rio informar NOME
GRUPOS->nome
Entre com o nome do declarante

 0 
 0 


ruadec
C
E
@!
 35 
 35 
 6 
 15 
 0 
Rua Declarante

 


Entre com o endere‡o do respons vel

 0 
 0 


fonedec
C
E
@!
 14 
 14 
 6 
 58 
 0 
Fone

 


Informe o n£mero do Telefone para contato|com o respons vel pela solicita‡„o do A.F.

 0 
 0 


codigofal
C
E
 
 18 
 18 
 8 
 14 
 0 
Falecido

PTAB(codigofal,'INSCRITS',1).OR.EMPT(codigofal)
Necess rio informar C¢digo do FALECIDO ou|Tecle F8 para consulta.
ALLTRIM(contrato)
Entre com o c¢digo do falecido
VDBF(6,3,20,77,'INSCRITS',{'codigo','nome','nascto_'},1,'kinscf9()',[])
 0 
 0 


falecido
C
E
 
 35 
 35 
 8 
 33 
 0 
Nome do falecido

!EMPT(falecido)
Necess rio informar NOME DO FALECIDO
IIF(PTAB(codigofal,'INSCRITS',1),INSCRITS->nome,[])
Entre com o nome do falecido

 0 
 0 


ruares
C
E
 
 30 
 30 
 9 
 10 
 0 
Rua Residˆncia

 


Entre com o endere‡o de residˆncia do Falecido

 0 
 0 


baires
C
E
 
 25 
 25 
 9 
 50 
 0 
Bairro Residˆncia

 


Entre com o bairro de residˆncia

 0 
 0 


munres
C
E
 
 25 
 25 
 10 
 10 
 0 
Munic¡pio de residˆncia

 


Entre com o nome do Munic¡pio de residˆncia

 0 
 0 


estres
C
E
!!
 2 
 2 
 10 
 40 
 0 
UF Residˆncia

EMPTY(ESTRES).OR.VUF(ESTRES)
ESTADO RESIDENCIA N„o aceit vel

Entre com o estado de Residˆncia

 0 
 0 


nascto_
D
E
@D
 8 
 10 
 10 
 54 
 0 
Nascimento

 

IIF(PTAB(codigofal,'INSCRITS',1),INSCRITS->nascto_,CTOD([  /  /  ]))
Informe a data de nascimento do falecido.

 0 
 0 


falecto_
D
E
@D
 8 
 10 
 12 
 8 
 0 
Data falcto.

falecto_<=DATE()
Informe uma data v lida para falecimento|Verifique a data do sistema.

Entre com a data de falecimento

 0 
 0 


horafal
C
E
99:99
 5 
 5 
 12 
 25 
 0 
Hora Falcto.
!EMPTY(falecto_)
VHORA(horafal+':00')
HORA FALCTO. n„o aceit vel|Digite uma hora correta



 0 
 0 


ruafal
C
E
 
 30 
 30 
 12 
 42 
 0 
Rua Falecimento

 


Entre com o endere‡o (Rua) onde|ocorreu o falecimento

 0 
 0 


municfal
C
E
 
 25 
 25 
 13 
 24 
 0 
Munic¡pio de falecimento

 


Entre com o nome do munic¡pio

 0 
 0 


estfal
C
E
!!
 2 
 2 
 13 
 54 
 0 
UF falecto

EMPTY(ESTFAL) .OR.VUF(ESTFAL)
ESTADO FALECIMENTO N„o aceit vel

Entre com o Estado onde ocorreu o falecimento

 0 
 0 


sepult_
D
E
@D
 8 
 10 
 14 
 28 
 0 
Data Sepultamento

 

DATE()
Informe a data do sepultamento

 0 
 0 


horasepult
C
E
99:99
 5 
 5 
 14 
 45 
 0 
Hora sepult.

VHORA(horasepult+':00')
HORA SEPULT. n„o aceit vel|digite uma hora correta

Informe a hora do sepultamento

 0 
 0 


cemitsep
C
E
 
 30 
 30 
 15 
 28 
 0 
Cemit‚rio Sepultamento

 


Entre com o n£mero do cemit‚rio de sepultamento

 0 
 0 


funcresp
C
E
999
 3 
 3 
 16 
 28 
 0 
Func.Respons vel

PTAB(funcresp,'FNCS',1).OR.EMPTY(funcresp)
Funcion rio n„o existe na tabela

Informe o funcion rio far |o registro ou F8 para consulta em tabela
VDBF(6,15,20,77,'FNCS',{'codigo','nome','profiss'},1,'codigo',[])
 0 
 0 


procpagto_
D
E
@D
 8 
 10 
 18 
 17 
 0 
Proc.pagto em

 


Processar pagamento em...

 0 
 0 


vlauxilio
N
E
99999999999.99
 14 
 14 
 18 
 42 
 2 
Valor Auxilio

 


Informe o valor do Auxilio Funeral

 0 
 0 


pagtoem_
D
E
@D
 8 
 10 
 18 
 65 
 0 
Pago em

 




 0 
 0 


 6 
Contratante
IIF(PTAB(contrato,'GRUPOS',1),GRUPOS->nome,[])

 3 
 28 
 30 

Endere‡o Contr.
IIF(PTAB(contrato,'GRUPOS',1),GRUPOS->endereco,[])

 4 
 28 
 35 

Func.Resp.
IIF(PTAB(funcresp,[FNCS]),FNCS->nome,[ ])

 16 
 32 
 30 

Categoria
IIF(categ=[PD],[Plano c/Difer. ],IIF(categ=[PL],[Atend.Plano],[Auxilio Funeral  ]))

 1 
 56 
 18 

Filial
filial
@!
 1 
 23 
 2 

Seguro?
IIF(PTAB(contrato,[GRSEGUR],2),[SEGURO],[])

 3 
 61 
 6 

 7 
PAR_ADM
procimp
processo+proc2+filial
processo+proc2+filial



PRCESSOS
categ
categ

PTAB(processo+proc2+M->p_filial+categ,[PRCESSOS],1).AND.(EMPT(PRCESSOS->saiu).OR.PRCESSOS->saiu=ARQGRUP->ultcirc)


PRCESSOS
ends
ruares

PTAB(processo+proc2+M->p_filial+categ,[PRCESSOS],1).AND.(EMPT(PRCESSOS->saiu).OR.PRCESSOS->saiu=ARQGRUP->ultcirc)


PRCESSOS
cids
munres

PTAB(processo+proc2+M->p_filial+categ,[PRCESSOS],1).AND.(EMPT(PRCESSOS->saiu).OR.PRCESSOS->saiu=ARQGRUP->ultcirc)


PRCESSOS
fal
falecido

PTAB(processo+proc2+M->p_filial+categ,[PRCESSOS],1).AND.(EMPT(PRCESSOS->saiu).OR.PRCESSOS->saiu=ARQGRUP->ultcirc)


PRCESSOS
dfal
falecto_

PTAB(processo+proc2+M->p_filial+categ,[PRCESSOS],1).AND.(EMPT(PRCESSOS->saiu).OR.PRCESSOS->saiu=ARQGRUP->ultcirc)


IMPPAR
docto
processo+proc2+filial+categ

PTAB(PADR(M->ide_maq,4)+[AFU],[IMPPAR],1)


 0 
 2 
PRCESSOS
1
 13 
!PTAB(processo+proc2+M->p_filial+categ,[PRCESSOS],1)
1=3
-1 



processo
C
processo+proc2+M->p_filial


categ
C
categ


saiu
C



grup
C
GRUPOS->grupo


num
C
contrato


grau
C
SUBSTR(codigofal,7,1)


seq
N
VAL(SUBSTR(codigofal,8,2))


seg
C
nomedec


ends
C
ruares


cids
C
munres


fal
C
falecido


sep
C
cemitsep


dfal
D
falecto_


IMPPAR
1
 3 
!PTAB(PADR(SUBSTR(M->ide_maq,2),4)+[AFU],[IMPPAR],1)
1=3
 0 



idmaq
C
PADR(SUBSTR(M->ide_maq,2),4)


base
C
[AFU]


docto
C



 4 
ADM_R020
 0 
Impress„o Aux.Funeral
categ=[AF]


ADR_R029
 0 
Impress„o Aux.Funeral
categ=[AF]


ADM_RX20
 0 
Impress„o Aux.Funeral
!(categ=[AF])


ADR_RX29
 0 
Impress„o Aux.Funeral
!(categ=[AF])


DRVVISIVEL Ì                   DRVTITTNA  Ã                   W/N DRVTITTEL  Ã                   GR+/B DRVTITPAD  Ã                   GR+/RB DRVTITMSG  Ã                   GR+/W DRVTITHLP  Ã                   W+/GR DRVTITGET  Ã                   GR+/BG DRVTITENF  Ã                   GR+/R DRVTITBOX  Ã                   GR+/B DRVTEXP    Ã                   CHR(27)+'W'+CHR(0) DRVTENF    Ã                   CHR(27)+'F' DRVTEMPO   Î    
                     9@DRVTELI    Ã                   CHR(30)+'0' DRVTDE8    Ã                   CHR(27)+'2' DRVTCOM    Ã                   CHR(18) DRVTC20    Ã                   CHR(30)+'0' DRVTAPG    Ã                   CHR(27)+'C'+CHR(NNN) DRVSOM     Ì                    DRVRATV    Î    
                     0@DRVRATH    Î    
                      @DRVPW      Ã    "               X:\HBRANCH\BPASTOR\RECRIP\161212\ DRVPVDBF   Ì                   DRVPRN     Î    
                     ð?DRVPORTA   Ã                   LPT1 DRVPORT    Ã                    DRVPEXP    Ã                   CHR(27)+'W'+CHR(1) DRVPESQ    Ì                    DRVPENF    Ã                   CHR(27)+'E' DRVPELI    Ã                   CHR(30)+'2' DRVPDE8    Ã                   CHR(27)+'0' DRVPCOM    Ã                   CHR(15) DRVPC20    Ã                   CHR(30)+'5' DRVPADRAO  Ã                   1 DRVNTX     Ã                   X:\BPASTOR\INDICES\ DRVMOUSE   Ì                   DRVMENUCEN Ì                    DRVMARCA   Ã                   Padr„o IBM DRVLAND    Ã                    DRVINCL    Ì                    DRVFONTE   Î    
                     ð?DRVEXCL    Ì                   DRVERR     Ã    "               X:\HBRANCH\BPASTOR\RECRIP\161212\ DRVDBF     Ã                   X:\BPASTOR\ARQUIVOS\ DRVCORTNA  Ã                   GR/N DRVCORTEL  Ã                   W+/B DRVCORPAD  Ã                   W+/RB DRVCORMSG  Ã                   W+/W DRVCORHLP  Ã                   GR+/GR DRVCORGET  Ã                   W+/BG DRVCORENF  Ã                   W+/R DRVCORBOX  Ã                   W+/B DRVCONF    Ì                    DRVCARA    Ã                   ² DRVAUTOHEL Ì                    DRVAUTOHEL Ì                    /*
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
 \ Empresa.: PresServ Inform tica-Limeira (019)452.6623
 \ Programa: ADM_R029.PRG
 \ Data....: 30-06-97
 \ Sistema.: Administradora - RECEP€„O
 \ Funcao..: Relat¢rio de Processo
 \ Analista: Ademilson Pedro Bom
 \ Criacao.: GAS-Pro v3.0 
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/

#include "adrbig.ch"    // inicializa constantes manifestas

LOCAL dele_atu, getlist:={}
PARA  lin_menu, col_menu
PRIV  tem_borda:=.t., op_menu:=VAR_COMPL, l_s:=10, c_s:=20, l_i:=13, c_i:=61, tela_fundo:=SAVESCREEN(0,0,MAXROW(),79)
nucop=1
SETCOLOR(drvtittel)
vr_memo=NOVAPOSI(@l_s,@c_s,@l_i,@c_i)     // pega posicao atual da tela
CAIXA(mold,l_s,c_s,l_i,c_i)               // monta caixa da tela
@ l_s,c_s+10 SAY " IMPRESSŽO AUX.FUNERAL "
SETCOLOR(drvcortel)
@ l_s+01,c_s+1 SAY " Processo:"
@ l_s+02,c_s+1 SAY " Confirme:"
rproc=SPAC(11)                                     // Processo
confirme=SPAC(1)                                   // Confirme
DO WHILE .t.
 rola_t=.f.
 cod_sos=56
 SET KEY K_ALT_F8 TO ROLATELA
 SETCOLOR(drvcortel+","+drvcorget+",,,"+corcampo)
 @ l_s+01 ,c_s+12 GET  rproc;
                  PICT "@R 99999/9999-99";
		  VALI CRIT("!EMPT(RPROC).AND.PTAB(M->rproc,[AFUNER],1)~Campo utilizado para localiza‡„o dos documentos.|Tecle F8 para busca em tabela")
                  DEFAULT "IIF(PTAB(PADR(SUBSTR(M->ide_maq,2),4)+[AFU],[IMPPAR],1),ALLTRIM(IMPPAR->docto),[])"
                  AJUDA "Digite neste campo o n£mero de|identifica‡„o do processo"
                  CMDF8 "VDBF(6,12,20,77,'AFUNER',{'processo','proc2','categ','contrato','falecido'},1,'V02001F9()',[])"

 @ l_s+02 ,c_s+12 GET  confirme;
                  PICT "!";
                  VALI CRIT("confirme='S'.AND.V02002F9()~CONFIRME n„o aceit vel|Digite S para confirmar|ou|Tecle ESC para cancelar")
                  AJUDA "Digite S para confirmar|ou|tecle ESC para cancelar"

 READ
 SET KEY K_ALT_F8 TO
 IF rola_t
  ROLATELA(.f.)
  LOOP
 ENDI
 IF LASTKEY()=K_ESC                                // se quer cancelar
  RETU                                             // retorna
 ENDI

 #ifdef COM_REDE
  IF !USEARQ("AFUNER",.f.,10,1)                    // se falhou a abertura do arq
   RETU                                            // volta ao menu anterior
  ENDI
 #else
  USEARQ("AFUNER")                                 // abre o dbf e seus indices
 #endi

 PTAB(contrato,"GRUPOS",1,.t.)                     // abre arquivo p/ o relacionamento
 PTAB(contrato,"INSCRITS",1,.t.)
 SET RELA TO contrato INTO GRUPOS,;                // relacionamento dos arquivos
          TO contrato INTO INSCRITS
 titrel:=criterio:=cpord := ""                     // inicializa variaveis
 titrel:=chv_rela:=chv_1:=chv_2 := ""
 tps:=op_x:=ccop := 1
 IF !opcoes_rel(lin_menu,col_menu,3,11)            // nao quis configurar...
  CLOS ALL                                         // fecha arquivos e
  LOOP                                             // volta ao menu
 ENDI
 IF tps=2                                          // se vai para arquivo/video
  arq_=ARQGER()                                    // entao pega nome do arquivo
  IF EMPTY(arq_)                                   // se cancelou ou nao informou
   LOOP                                            // retorna
  ENDI
 ELSE
  arq_=drvporta                                    // porta de saida configurada
 ENDI
 SET PRINTER TO (arq_)                             // redireciona saida
 EXIT
ENDD
DBOX("[ESC] Interrompe",15,,,NAO_APAGA)
dele_atu:=SET(_SET_DELETED,.t.)                    // os excluidos nao servem...
SET DEVI TO PRIN                                   // inicia a impressao
maxli=62                                           // maximo de linhas no relatorio
BEGIN SEQUENCE
 DO WHIL ccop<=nucop                               // imprime qde copias pedida
  pg_=1; cl=999
  INI_ARQ()                                        // acha 1o. reg valido do arquivo
  ccop++                                           // incrementa contador de copias
  DO WHIL !EOF()
   #ifdef COM_TUTOR
    IF IN_KEY()=K_ESC                              // se quer cancelar
   #else
    IF INKEY()=K_ESC                               // se quer cancelar
   #endi
    IF canc()                                      // pede confirmacao
     BREAK                                         // confirmou...
    ENDI
   ENDI
   IF PTAB(PADR(SUBSTR(M->ide_maq,2),4)+[AFU],[IMPPAR],1).and.processo+proc2+filial+categ=ALLTRIM(IMPPAR->docto)// se atender a condicao...
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY "Contrato:"
    IMPCTL(drvpenf)
    @ cl,011 SAY GRUPOS->grupo+'-'+GRUPOS->codigo  // Contrato
    IMPCTL(drvtenf)
    @ cl,043 SAY "Processo"
    IMPCTL(drvpenf)
    @ cl,052 SAY TRAN(processo+proc2,"@R 99999/99")// Nr.Processo
    IMPCTL(drvtenf)
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY REPL("-",74)
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,013 SAY "R E L A T O R I O   D E   P R O C E S S O"
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY REPL("-",74)
    REL_CAB(2)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY "Nome do Falecido.:"
    IMPCTL(drvpenf)
    @ cl,020 SAY TRAN(falecido,"@!")               // nome do falecido
    IMPCTL(drvtenf)
    REL_CAB(2)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY "End. do Falecido.:"
    @ cl,020 SAY LEFT(ALLTRIM(ruares)+' ' +baires,59)// Rua Residˆncia
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY "Cidade...........:"
    @ cl,020 SAY munres                            // Munic¡pio de residˆncia
    @ cl,054 SAY "Estado:"
    @ cl,062 SAY TRAN(estres,"!!")                 // UF Residˆncia
    REL_CAB(2)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY "Falecimento......:"
    IMPCTL(drvpenf)
    @ cl,019 SAY TRAN(falecto_,"@D")               // data falecto
    IMPCTL(drvtenf)
    @ cl,029 SAY "Local...:"
    @ cl,039 SAY ruafal                            // Rua Falecimento
    REL_CAB(2)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY "Inscrito Contrato como.:"
    @ cl,026 SAY grauparcon                        // Parentesco
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY REPL("-",74)
    REL_CAB(2)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY "Contratante:"
    IMPCTL(drvpenf)
    @ cl,013 SAY GRUPOS->nome                      // Nome CONTRATANTE
    IMPCTL(drvtenf)
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    IMPAC("Endere‡o...:",cl,000)
    @ cl,013 SAY GRUPOS->endereco                  // Endere‡o
    @ cl,049 SAY GRUPOS->cidade                    // Cidade
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY REPL("-",74)
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY "Valor em Reais....:"
    @ cl,020 SAY vlauxilio                         // Valor
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY "PROCESSAR PAGAMENTO EM :"
    IMPCTL(drvpenf)
    @ cl,025 SAY LEFT(DTOC(procpagto_),2)+' de '+ALLTRIM(NMES(procpagto_))+' de '+STR(YEAR(procpagto_),4)// Proc.pagto em
    IMPCTL(drvtenf)
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY REPL("-",74)
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    IMPMEMO([   ],10,1,cl,000,.f.)                 // AUX (memo)
    qli_m=MLCOUNT([   ],10)-1                      // quantas linhas a imprimir?
    li_m=0
    DO WHIL .t.                                    // imprime linhas do memo
     li_m++
     IF li_m>qli_m                                 // fim do memo
      EXIT
     ENDI
     REL_CAB(1)                                    // soma cl/imprime cabecalho
     IMPMEMO([   ],10,1+li_m,cl,000,.f.)           // imprime...
     #ifdef COM_TUTOR
      IF IN_KEY()=K_ESC                            // se quer cancelar
     #else
      IF INKEY()=K_ESC                             // se quer cancelar
     #endi
      IF canc()                                    // pede confirmacao
       BREAK                                       // confirmou...
      ENDI
     ENDI
    ENDD
    SKIP                                           // pega proximo registro
    cl=999                                         // forca salto de pagina
   ELSE                                            // se nao atende condicao
    SKIP                                           // pega proximo registro
   ENDI
  ENDD
 ENDD ccop
END SEQUENCE
SET PRINTER TO (drvporta)                          // fecha arquivo gerado (se houver)
SET DEVI TO SCRE                                   // direciona saida p/ video
IF tps=2                                           // se vai para arquivo/video
 BROWSE_REL(arq_,2,3,MAXROW()-2,78)
ENDI                                               // mostra o arquivo gravado
GRELA(3)                                           // grava variacao do relatorio
SELE AFUNER                                        // salta pagina
SET RELA TO                                        // retira os relacionamentos
SET(_SET_DELETED,dele_atu)                         // os excluidos serao vistos
RETU

STATIC PROC REL_CAB(qt)                            // cabecalho do relatorio
IF qt>0                                            // se parametro maior que 0
 cl=cl+qt                                          // soma no contador de linhas
ENDI
IF cl>maxli .OR. qt=0                              // quebra de pagina
 @ 0,000 SAY REPL("-",74)
 IMPAC(nemp,1,000)
 @ 2,000 SAY "Data:"
 @ 2,006 SAY TRAN(DATE(),"@D")                     // DATA
 @ 2,025 SAY "CAT:"
 @ 2,030 SAY IIF(categ=[PD],[Plano c/Difer. ],IIF(categ=[PL],[Atend.Plano],[Auxilio Funeral  ]))// Categoria
 cl=qt+2 ; pg_++
ENDI
RETU

* \\ Final de ADM_R029.PRG
GAS-Pro v4.0
002003024079001022031022003000176001
--------------------------------------------------------------------------
BOM PASTOR - Organiza‡„o Administradora de Bens BOM PASTOR Ltda
Data:                    CAT:
Contrato:                                  Processo
--------------------------------------------------------------------------
             R E L A T O R I O   D E   P R O C E S S O
--------------------------------------------------------------------------

Nome do Falecido.:

End. do Falecido.:
Cidade...........:                                    Estado:

Falecimento......:           Local...:

Inscrito Contrato como.:
--------------------------------------------------------------------------

Contratante:
Endere‡o...:
--------------------------------------------------------------------------
Valor em Reais....:
PROCESSAR PAGAMENTO EM :
--------------------------------------------------------------------------
[Ÿ]
 17 
AFUNER
Relat¢rio de Processo


PTAB(PADR(SUBSTR(M->ide_maq,2),4)+[AFU],[IMPPAR],1).and.processo+proc2+filial+categ=ALLTRIM(IMPPAR->docto)
011

























 0 
 1 










 0 
 1 
 0 
 66 
 0 
 3 
 3 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
-1 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
Nome CONTRATANTE
GRUPOS->nome

 35 
C
 19 
 14 


û         










Contrato
GRUPOS->grupo+'-'+GRUPOS->codigo

 9 
C
 4 
 12 


û         










Nr.Processo
processo+proc2
@R 99999/99
 8 
C
 4 
 53 


û         










Proc.pagto em
LEFT(DTOC(procpagto_),2)+' de '+ALLTRIM(NMES(procpagto_))+' de '+STR(YEAR(procpagto_),4)

 25 
C
 23 
 26 


û         










Valor
vlauxilio

 14 
N
 22 
 21 


          










nome do falecido
falecido
@!
 35 
C
 9 
 21 


û         










Rua Residˆncia
LEFT(ALLTRIM(ruares)+' ' +baires,59)

 59 
C
 11 
 21 


          










Munic¡pio de residˆncia
munres

 25 
C
 12 
 21 


          










UF Residˆncia
estres
!!
 2 
C
 12 
 63 


          










Rua Falecimento
ruafal

 30 
C
 14 
 40 


          










Parentesco
grauparcon

 10 
C
 16 
 27 


          










data falecto
falecto_
@D
 8 
D
 14 
 20 


û         










Endere‡o
GRUPOS->endereco

 35 
C
 20 
 14 


          










Cidade
GRUPOS->cidade

 25 
C
 20 
 50 


          










DATA
DATE()
@D
 8 
D
 3 
 7 


          










AUX
[   ]

 10 
M
 25 
 1 


          










Categoria
IIF(categ=[PD],[Plano c/Difer. ],IIF(categ=[PL],[Atend.Plano],[Auxilio Funeral  ]))

 18 
C
 3 
 31 


          










 9 
Nome da empresa
nemp

 0 
 0 
 32 

T¡tulo aplica‡„o
nsis

 0 
 0 
 25 

Data do sistema
DTOC(DATE())

 0 
 0 
 8 

Nome do mˆs
NMES(DATE())

 0 
 0 
 8 

Dia da semana
NSEM(DATE())

 0 
 0 
 7 

N£mero da p gina
TRAN(pg_,'9999')

 0 
 0 
 4 

C¢digo relat¢rio
"ADM_R029"

 0 
 0 
 8 

T¡tulo a definir
titrel

 0 
 0 
 30 

Hora da emiss„o
hora_rel_

 0 
 0 
 5 

 0 
 0 
 0 
 2 
GRUPOS
 1 
contrato



INSCRITS
 1 
contrato



/*
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
 \ Empresa.: Ind£stria de Urnas Bignotto Ltda
 \ Programa: CON_R001.PRG
 \ Data....: 26-02-98
 \ Sistema.: Controle de Convˆnios
 \ Funcao..: Emiss„o Guias Modelo 1
 \ Analista: Ademilson Pedro Bom
 \ Criacao.: GAS-Pro v3.0 
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/

#include "adrbig.ch"    // inicializa constantes manifestas

LOCAL dele_atu, getlist:={}, so_um_reg, sit_dbf
PARA  lin_menu, col_menu, imp_reg
PRIV  tem_borda:=.t., op_menu:=VAR_COMPL, l_s:=11, c_s:=20, l_i:=14, c_i:=61, tela_fundo:=SAVESCREEN(0,0,MAXROW(),79)
nucop=1
so_um_reg=(PCOU()>2)
IF !so_um_reg                             // vai receber a variaveis?
 SETCOLOR(drvtittel)
 vr_memo=NOVAPOSI(@l_s,@c_s,@l_i,@c_i)    // pega posicao atual da tela
 CAIXA(mold,l_s,c_s,l_i,c_i)              // monta caixa da tela
 @ l_s,c_s+12 SAY " EMISSŽO DE GUIAS "
 SETCOLOR(drvcortel)
 @ l_s+01,c_s+1 SAY " N£mero:"
ENDI
gnumero=SPAC(7)                                    // N£mero
DO WHILE .t.
 rola_t=.f.
 cod_sos=56
 IF !so_um_reg
  SET KEY K_ALT_F8 TO ROLATELA
  SETCOLOR(drvcortel+","+drvcorget+",,,"+corcampo)
  @ l_s+01 ,c_s+10 GET  gnumero;
                   PICT "@R 99-99999";
                   VALI CRIT("PTAB(gnumero,'GUIAS',1).AND.V00101F9()~N£MERO n„o existe na tabela")
		   AJUDA "Emitir a guia de n£mero?"
									 CMDF8 "VDBF(6,8,20,77,'GUIAS',{'numero','nome'},1,'RETNGUI()')"
                   MOSTRA {"LEFT(TRAN(GUIAS->nome,[@!]),35)", 2 , 5 }

  READ
  SET KEY K_ALT_F8 TO
  IF rola_t
   ROLATELA(.f.)
   LOOP
  ENDI
  IF LASTKEY()=K_ESC                               // se quer cancelar
   RETU                                            // retorna
  ENDI
 ENDI

 #ifdef COM_REDE
  IF !USEARQ("GUIAS",.f.,10,1)                     // se falhou a abertura do arq
   RETU                                            // volta ao menu anterior
  ENDI
 #else
  USEARQ("GUIAS")                                  // abre o dbf e seus indices
 #endi

 PTAB(medico,"MEDICOS",1,.t.)                      // abre arquivo p/ o relacionamento
 SET RELA TO medico INTO MEDICOS                 // relacionamento dos arquivos
 titrel:=criterio:=cpord := ""                     // inicializa variaveis
 titrel:=chv_rela:=chv_1:=chv_2 := ""
 tps:=op_x:=ccop := 1
 arq_=drvporta                                     // porta de saida configurada
 IF !so_um_reg
  IF !opcoes_rel(lin_menu,col_menu,5,11)           // nao quis configurar...
   CLOS ALL                                        // fecha arquivos e
   LOOP                                            // volta ao menu
  ENDI

 #ifdef COM_REDE

  ELSE

   tps=lin_menu

 #endi

 ENDI
 IF tps=2                                          // se vai para arquivo/video
  arq_=ARQGER()                                    // entao pega nome do arquivo
  IF EMPTY(arq_)                                   // se cancelou ou nao informou
   LOOP                                            // retorna
  ENDI
 ELSE
  arq_=drvporta                                    // porta de saida configurada
 ENDI
 SET PRINTER TO (arq_)                             // redireciona saida
 EXIT
ENDD
IF !EMPTY(drvtapg)                                 // existe configuracao de tam pag?
 op_=AT("NNN",drvtapg)                             // se o codigo que altera
 IF op_=0                                          // o tamanho da pagina
  msg="Configura‡„o do tamanho da p gina!"         // foi informado errado
  DBOX(msg,,,,,"ERRO!")                            // avisa
  CLOSE ALL                                        // fecha todos arquivos abertos
  RETU                                             // e cai fora...
 ENDI                                              // codigo para setar/resetar tam pag
 lpp_024=LEFT(drvtapg,op_-1)+"024"+SUBS(drvtapg,op_+3)
 lpp_066=LEFT(drvtapg,op_-1)+"066"+SUBS(drvtapg,op_+3)
ELSE
 lpp_024:=lpp_066 :=""                             // nao ira mudara o tamanho da pag
ENDI
DBOX("[ESC] Interrompe",15,,,NAO_APAGA)
dele_atu:=SET(_SET_DELETED,.t.)                    // os excluidos nao servem...
SET DEVI TO PRIN                                   // inicia a impressao
maxli=22                                           // maximo de linhas no relatorio
IMPCTL(lpp_024)                                    // seta pagina com 24 linhas
SET MARG TO 1                                      // ajusta a margem esquerda
IF tps=2
 IMPCTL("' '+CHR(8)")
ENDI
BEGIN SEQUENCE
 DO WHIL ccop<=nucop                               // imprime qde copias pedida
  pg_=1; cl=999
  IF so_um_reg
   GO imp_reg
  ELSE
   INI_ARQ()                                       // acha 1o. reg valido do arquivo
  ENDI
  ccop++                                           // incrementa contador de copias
  DO WHIL !EOF().AND.(!so_um_reg.OR.imp_reg=RECN())
   #ifdef COM_TUTOR
    IF IN_KEY()=K_ESC                              // se quer cancelar
	 #else
    IF INKEY()=K_ESC                               // se quer cancelar
   #endi
    IF canc()                                      // pede confirmacao
     BREAK                                         // confirmou...
    ENDI
   ENDI
   IF (PTAB(PADR(SUBSTR(M->ide_maq,2),4)+[GUI],[IMPPAR],1).and.LEFT(IMPPAR->docto,7)=ano+numero) .OR. so_um_reg// se atender a condicao...
    IMPCTL(drvtcom)
		REL_CAB(1)                                     // soma cl/imprime cabecalho
//    @ cl,066 SAY TRAN(ano,"99")                    // Ano
//    @ cl,068 SAY "-"
		@ cl,064 SAY TRAN(numero,"99999")              // N£mero
		REL_CAB(3)                                     // soma cl/imprime cabecalho
		IMPCTL(drvpenf)
		@ cl,004 SAY MEDICOS->nome                     // Nome M‚dico
		IMPCTL(drvtenf)
		@ cl,061 SAY TRAN(medico,"@!")                 // M‚dico Codigo
		REL_CAB(3)                                     // soma cl/imprime cabecalho
		@ cl,004 SAY ALLTRIM(MEDICOS->endereco) // Endere‡o
		REL_CAB(1)                                     // soma cl/imprime cabecalho
		@ cl,004 SAY TRAN(MEDICOS->cidade,"@!")+[ Tel.:]+MEDICOS->telefone				// Cidade
		REL_CAB(3)                                     // soma cl/imprime cabecalho
		IF MEDICOS->valorpart > 0
		 @ cl,006 SAY TRAN(MEDICOS->valorpart,"@E 99,999,999.99")// Valor Particular
		ENDI
		IF MEDICOS->ultvalor > 0
		 IF MEDICOS->VALORPART > 0
			@ cl,026 SAY TRAN(100-(MEDICOS->ultvalor/MEDICOS->valorpart*100),"99")      // Porcent1
			@ cl,031 SAY TRAN(MEDICOS->valorpart-MEDICOS->ultvalor,"@E 99,999,999.99")// Valor Particular
		 ENDI
		 @ cl,054 SAY TRAN(MEDICOS->ultvalor,"@E 99,999,999.99")// Ult.valor
		ENDI
		REL_CAB(1)                                     // soma cl/imprime cabecalho
		@ cl,004 SAY MEDICOS->mensagem
		REL_CAB(2)                                     // soma cl/imprime cabecalho
		@ cl,004 SAY TRAN(titular,"@!")                // Titular
		@ cl,062 SAY TRAN(contrato,"999999")           // N§ Contrato
		REL_CAB(3)                                     // soma cl/imprime cabecalho
		@ cl,004 SAY TRAN(nome,"@!")                   // Nome
		@ cl,050 SAY TRAN(emissao_,"@D")               // Emiss„o
		@ cl,061 SAY TRAN(emissao_+VAL(MEDICOS->tipcont),"@D")               // Emiss„o
		SKIP                                           // pega proximo registro
		cl=999                                         // forca salto de pagina
	 ELSE                                            // se nao atende condicao
		SKIP                                           // pega proximo registro
	 ENDI
	ENDD
 ENDD ccop
 EJEC                                              // salta pagina
END SEQUENCE
SET MARG TO                                        // coloca margem esquerda = 0
IMPCTL(lpp_066)                                    // seta pagina com 66 linhas
SET PRINTER TO (drvporta)                          // fecha arquivo gerado (se houver)
SET DEVI TO SCRE                                   // direciona saida p/ video
IF tps=2                                           // se vai para arquivo/video
 BROWSE_REL(arq_,2,3,MAXROW()-2,78)
ENDI                                               // mostra o arquivo gravado
GRELA(5)                                           // grava variacao do relatorio
SELE GUIAS                                         // salta pagina
SET RELA TO                                        // retira os relacionamentos
SET(_SET_DELETED,dele_atu)                         // os excluidos serao vistos
IF so_um_reg
 POINTER_DBF(sit_dbf)
ENDI
RETU

STATIC PROC REL_CAB(qt)                            // cabecalho do relatorio
IF qt>0                                            // se parametro maior que 0
 cl=cl+qt                                          // soma no contador de linhas
ENDI
IF cl>maxli .OR. qt=0                              // quebra de pagina
 cl=qt+2 ; pg_++
ENDI
RETU

* \\ Final de CON_R001.PRG

FUNC RETNGUI()
RETU ANO+NUMERO€ CSTSEG©– CSTSEGCODECST_INCLCODECST_TELACODECST_GETSCODECST_GET1CODEC_ETEXTENDCODE	_SYMSTARTSYMSTARTSYMBOLSSYMBOLS_SYMENDSYMENDNULLBEGDATA_DATADATA_SYMPBDATA_SYMPDATA_SYMPEDATA_CONSTCONST_MSGMSG_BEGBSSBEGBSS_BSSBSS_ENDBSSENDBSSDGROUPß˜ @ô%˜ @_´˜ @MÄ˜ @Ñ	<˜ @%
á˜ H  ÿ˜ h  Û˜ `@™˜ h  Ó˜ h  Ï˜ H  ë˜ H  ç˜ H procedure r00202f9
/*
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
 \ Empresa.: PresServ Inform tica-Limeira (019)452.6623
 \ Programa: R00202F9.PRG
 \ Data....: 02-01-97
 \ Sistema.: Administradora - PLANO
 \ Funcao..: hist 1 do relat¢rio ADM_R002
 \ Analista: Ademilson Pedro Bom
 \ Criacao.: Programado manualmente pelo analista
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/

#include "adRbig.ch"    // inicializa constantes manifestas

 LOCAL reg_dbf1:=POINTER_DBF()
 LOCAL cipend:=0
 PUBLI circax1:=circax2:=circax3:=circax4:=[]
 PUBLI circax5:=circax6:=circax7:=circax8:=[]
 cod:=codigo
// PTAB(codigo,'TAXAS',1)
// PTAB(codigo,'GRUPOS',1)

 SELE TAXAS

 PTAB(codigo,'TAXAS',1,.t.)

 M->recvalor:=0
 DO WHILE !EOF().AND.TAXAS->codigo=cod
  IF TAXAS->valorpg>0         // Somente taxas pendentes
   SKIP
   LOOP
  ENDI
  IF TAXAS->circ=ARQGRUP->proxcirc         // Somente taxas pendentes
   SKIP
   LOOP
  ENDI
  circax1:=circax2
  circax2:=circax3
  circax3:=circax4
  circax4:=circax5
  circax5:=circax6
  circax6:=circax7
  circax7:=circax8
  circax8:=DTOC(TAXAS->emissao_)+TRANSF(TAXAS->valor,"@E 99,999.99")+;
     [ (]+TAXAS->tipo+[-]+TAXAS->circ+[)]
  M->recvalor+=TAXAS->valor
  SKIP
 ENDDO
 FOR cipend= 8 TO 1 STEP -1
  ccaux:="circax"+str(cipend,1)
  IF !EMPT(&ccaux)
   &ccaux=CHR(15)+STR(GRUPOS->qtcircs-(9-cipend),3)+[ ]+&ccaux+CHR(18)
  ENDI
 NEXT
 POINTER_DBF(reg_dbf1)

RETU []         // <- deve retornar um valor qualquer


* \\ Final de R00202F9.PRG
t   ¢ =                     PW_GRUPO   C                   PW_DBF     C    #               PW_PERMIS  C                   FLAG_EXCL  C                     ¤•¤–ÆÊ×ÊÕÝÒÙÓçãØ”…“”…”…“”…”…“”…”…“”…”…“”…”…“”…”…“”…”…“”…”…“  ¤•¤–¹ÓØÊåÙìãØ“”…”…“”…”…“”…”…“”…”…“”…”…“”…”…“”…”…“”…”…“”…”…“  ¤•¤–ÃÚè×âç…ÆÊÖÙÇÝÒØâÙãØ“”…”…“”…”…“”…”…“”…”…“”…”…“”…”…“”…”…“  ¤•¤–·ÔâØèàÙÕ…¶ãÓè×ÔèÔç…“”…”…“”…”…“”…”…“”…”…“”…”…“”…”…“”…”…“  ¤•¤–ÈÆìÆæ”…”…“”…”…“”…”…“”…”…“”…”…“”…”…“”…”…“”…”…“”…”…“”…”…“  ¤•¤–ÃÚè×âç…¹Ó×Ù×Ùìâç…”…“”…”…“”…”…“”…”…“”…”…“”…”…“”…”…“”…”…“  ¤•¤–½ÓçÈåÝÙãØ“”…”…“”…”…“”…”…“”…”…“”…”…“”…”…“”…”…“”…”…“”…”…“  ¤•¤–¹ÒÝØæøÔ”ÉØ”¬éÎÔç…”…“”…”…“”…”…“”…”…“”…”…“”…”…“”…”…“”…”…“  ¤•¤–ÀÆâìÔáÊâÙâ”¦éÝ¡ºÚâÊåÕÑ”…“”…”…“”…”…“”…”…“”…”…“”…”…“”…”…“  ¤•¤–¸Ô×ÚàÙÓèÔ“ù…½ÒãæÎáÎå”…”…“”…”…“”…”…“”…”…“”…”…“”…”…“”…”…“  ¤•¤–·×ÙÉØâÈÝÆ×ãØ”…“”…”…“”…”…“”…”…“”…”…“”…”…“”…”…“”…”…“”…”…“  ¤•¤–¹ØäÊÖÝÆàÎ×ÕÉÙØ“”…”…“”…”…“”…”…“”…”…“”…”…“”…”…“”…”…“”…”…“  ¤•¤–ÄÆæèàÙÙæÔ“ØÊ”¯èæÔç…“”…”…“”…”…“”…”…“”…”…“”…”…“”…”…“”…”…“  ¤•¤–ºÎàÎÔÝØ”…“”…”…“”…”…“”…”…“”…”…“”…”…“”…”…“”…”…“”…”…“”…”…“  ¤•¤–»×éÕâç…”…“”…”…“”…”…“”…”…“”…”…“”…”…“”…”…“”…”…“”…”…“”…”…“  ¤•¤–ÆÊÛÎÙØ”…“”…”…“”…”…“”…”…“”…”…“”…”…“”…”…“”…”…“”…”…“”…”…“  ¤•¤–·ÔÖ×ÔØÔæÊæ£»ÙÓ×ÙÉã×Øç…”…“”…”…“”…”…“”…”…“”…”…“”…”…“”…”…“  ¤•¤–·ÆèÊÚã×ÝÆ“ØÔç…ÃàÆâÔæ”…”…“”…”…“”…”…“”…”…“”…”…“”…”…“”…”…“  ¤•¤–·ÎæÈèàÆæÊæ”…”…“”…”…“”…”…“”…”…“”…”…“”…”…“”…”…“”…”…“”…”…“  ¤•¤–Ä×ãÈØçØãØ“ØÆ”¨ÜæÈéÑÔæ…”…“”…”…“”…”…“”…”…“”…”…“”…”…“”…”…“  ¤•¤–Ä×ãÈØçØãØ“”…”…“”…”…“”…”…“”…”…“”…”…“”…”…“”…”…“”…”…“”…”…“  ¤•¤–ºÚâÈÜãÓ×ÜãØ”…“”…”…“”…”…“”…”…“”…”…“”…”…“”…”…“”…”…“”…”…“  ¤•¤–¼ÎçÙæÎ×Ô“ÄÆØ×÷ã…”…“”…”…“”…”…“”…”…“”…”…“”…”…“”…”…“”…”…“  ¤•¤–·ÚçÙâç…µÉÜ×ÎãÓÔÝØ”…“”…”…“”…”…“”…”…“”…”…“”…”…“”…”…“”…”…“  ¤•¤–ÁÊâØÔÛÊá…ã£¨ãÓçæÆèÔ“”…”…“”…”…“”…”…“”…”…“”…”…“”…”…“”…”…“  ¤•¤–·ÆÝÝÔç…”…“”…”…“”…”…“”…”…“”…”…“”…”…“”…”…“”…”…“”…”…“”…”…“  ¤•¤–ÄÆæèàÙÙæÔæ”…”…“”…”…“”…”…“”…”…“”…”…“”…”…“”…”…“”…”…“”…”…“  ¤•¤–µÛÝØâç…£…¶Õ×ÙÓÖÝÆç…“”…”…“”…”…“”…”…“”…”…“”…”…“”…”…“”…”…“ procedure r08703f9
/*
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
 \ Empresa.: PresServ Inform tica-Limeira (019)452.6623
 \ Programa: R08703F9.PRG
 \ Data....: 21-09-97
 \ Sistema.: Administradora - PLANO
 \ Funcao..: Montagem dos dados dos falecimentos da circular.
 \ Analista: Ademilson Pedro Bom
 \ Criacao.: Programado manualmente pelo analista
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/

#include "adrbig.ch"    // inicializa constantes manifestas

LOCAL reg_dbf:=POINTER_DBF()
IF ultprc = CIRCULAR->grupo+CIRCULAR->circ .OR. !(TAXAS->tipo$'27')
 RETU []
ENDI
AFILL(DETPRC,[])
ultprc:=CIRCULAR->grupo+CIRCULAR->circ
PTAB(ultprc,[CPRCIRC],1)
SELE CPRCIRC
contx:=0
DO WHILE .NOT. EOF() .AND. contx<LEN(detprc).AND.ultprc=grupo+circ
 contx+=1
 detprc[contx]:=CPRCIRC->num+[ ]+DTOC(CPRCIRC->dfal)+[ ]+CPRCIRC->fal
 SKIP
ENDDO

POINTER_DBF(reg_dbf)

RETU []      // <- deve retornar um valor qualquer

* \\ Final de R08703F9.PRG
/*
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
 \ Empresa.: PresServ Inform tica-Limeira (019)452.6623
 \ Programa: ADM_RX20.PRG
 \ Data....: 22-09-97
 \ Sistema.: Administradora - RECEP€„O
 \ Funcao..: Impress„o Aux.Funeral 2
 \ Analista: Ademilson Pedro Bom
 \ Criacao.: GAS-Pro v3.0 
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/

#include "adrbig.ch"    // inicializa constantes manifestas

LOCAL dele_atu, getlist:={}, so_um_reg, sit_dbf:=POINTER_DBF()
PARA  lin_menu, col_menu, imp_reg
PRIV  tem_borda:=.t., op_menu:=VAR_COMPL, l_s:=10, c_s:=20, l_i:=13, c_i:=61, tela_fundo:=SAVESCREEN(0,0,MAXROW(),79)
nucop=1
so_um_reg=(PCOU()>2)
IF !so_um_reg                             // vai receber a variaveis?
 SETCOLOR(drvtittel)
 vr_memo=NOVAPOSI(@l_s,@c_s,@l_i,@c_i)    // pega posicao atual da tela
 CAIXA(mold,l_s,c_s,l_i,c_i)              // monta caixa da tela
 @ l_s,c_s+10 SAY " IMPRESSŽO AUX.FUNERAL "
 SETCOLOR(drvcortel)
 @ l_s+01,c_s+1 SAY " Processo:"
 @ l_s+02,c_s+1 SAY " Confirme:"
ENDI
rproc=SPAC(11)                                     // Processo
confirme=SPAC(1)                                   // Confirme
DO WHILE .t.
 rola_t=.f.
 cod_sos=56
 IF !so_um_reg
  SET KEY K_ALT_F8 TO ROLATELA
  SETCOLOR(drvcortel+","+drvcorget+",,,"+corcampo)
  @ l_s+01 ,c_s+12 GET  rproc;
                   PICT "@R 99999/9999-99";
                   VALI CRIT("!EMPT(RPROC).AND.PTAB(rproc,[AFUNER],1)~Campo utilizado para localiza‡„o dos documentos.|Tecle F8 para busca em tabela")
                   DEFAULT "IIF(PTAB(PADR(SUBSTR(M->ide_maq,2),4)+[AFU],[IMPPAR],1),ALLTRIM(IMPPAR->docto),[])"
                   AJUDA "Digite neste campo o n£mero de|identifica‡„o do processo"
                   CMDF8 "VDBF(6,12,20,77,'AFUNER',{'processo','proc2','categ','contrato','falecido'},1,'V02001F9()',[])"

  @ l_s+02 ,c_s+12 GET  confirme;
                   PICT "!";
                   VALI CRIT("confirme='S'.AND.V02002F9()~CONFIRME n„o aceit vel|Digite S para confirmar|ou|Tecle ESC para cancelar")
                   AJUDA "Digite S para confirmar|ou|tecle ESC para cancelar"

  READ
  SET KEY K_ALT_F8 TO
  IF rola_t
   ROLATELA(.f.)
   LOOP
  ENDI
  IF LASTKEY()=K_ESC                               // se quer cancelar
   RETU                                            // retorna
  ENDI
 ENDI

 #ifdef COM_REDE
  IF !USEARQ("AFUNER",.f.,10,1)                    // se falhou a abertura do arq
   RETU                                            // volta ao menu anterior
  ENDI
 #else
  USEARQ("AFUNER")                                 // abre o dbf e seus indices
 #endi

 PTAB(contrato,"GRUPOS",1,.t.)                     // abre arquivo p/ o relacionamento
 PTAB(contrato,"INSCRITS",1,.t.)
 SET RELA TO contrato INTO GRUPOS,;                // relacionamento dos arquivos
          TO contrato INTO INSCRITS
 titrel:=criterio:=cpord := ""                     // inicializa variaveis
 titrel:=chv_rela:=chv_1:=chv_2 := ""
 tps:=op_x:=ccop := 1
 arq_=drvporta                                     // porta de saida configurada
 IF !so_um_reg
  IF !opcoes_rel(lin_menu,col_menu,3,11)           // nao quis configurar...
   CLOS ALL                                        // fecha arquivos e
   LOOP                                            // volta ao menu
  ENDI

 #ifdef COM_REDE

  ELSE

   tps=lin_menu

 #endi

 ENDI
 IF tps=2                                          // se vai para arquivo/video
  arq_=ARQGER()                                    // entao pega nome do arquivo
  IF EMPTY(arq_)                                   // se cancelou ou nao informou
   LOOP                                            // retorna
  ENDI
 ELSE
  arq_=drvporta                                    // porta de saida configurada
 ENDI
 IF "4WIN"$UPPER(drvmarca) // nome da configuracao/marca impressora
    arq_:=drvdbf+"WIN"+ide_maq
    tps:=3                                          // se vai para arquivo/video
 ENDIF
 SET PRINTER TO (arq_)                             // redireciona saida
 EXIT
ENDD
DBOX("[ESC] Interrompe",15,,,NAO_APAGA)
dele_atu:=SET(_SET_DELETED,.t.)                    // os excluidos nao servem...
SET DEVI TO PRIN                                   // inicia a impressao
maxli=62                                           // maximo de linhas no relatorio
BEGIN SEQUENCE
 DO WHIL ccop<=nucop                               // imprime qde copias pedida
  pg_=1; cl=999
  IF so_um_reg
   GO imp_reg
  ELSE
   INI_ARQ()                                       // acha 1o. reg valido do arquivo
   IF PTAB(PADR(SUBSTR(M->ide_maq,2),4)+[AFU],[IMPPAR],1)
    PTAB(LEFT(IMPPAR->docto,11),'AFUNER',1)
   ENDI
  ENDI
  ccop++                                           // incrementa contador de copias
  DO WHIL !EOF().AND.(!so_um_reg.OR.imp_reg=RECN())
   #ifdef COM_TUTOR
    IF IN_KEY()=K_ESC                              // se quer cancelar
   #else
    IF INKEY()=K_ESC                               // se quer cancelar
   #endi
    IF canc()                                      // pede confirmacao
     BREAK                                         // confirmou...
    ENDI
   ENDI
   IF (PTAB(PADR(SUBSTR(M->ide_maq,2),4)+[AFU],[IMPPAR],1).and.processo+proc2+filial+categ=ALLTRIM(IMPPAR->docto)) .OR. so_um_reg// se atender a condicao...
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,054 SAY "Processo"
    IMPCTL(drvpenf)
    @ cl,063 SAY TRAN(processo+proc2+filial,"@R 99999/99/!!")// Nr.Processo
    IMPCTL(drvtenf)
    REL_CAB(2)                                     // soma cl/imprime cabecalho
    @ cl,003 SAY "Nome do Contratante:"
    IMPCTL(drvpenf)
    @ cl,024 SAY TRAN(IIF(PTAB(contrato+GRUPOS->titular,'INSCRITS',1),INSCRITS->nome,GRUPOS->nome),"@!")// Nome do contratante
    IMPCTL(drvtenf)
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    IMPAC("Endere‡o:",cl,003)
    IMPCTL(drvpenf)
    @ cl,013 SAY TRAN(GRUPOS->endereco,"@!")       // Endereco contratante
    IMPCTL(drvtenf)
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,005 SAY "Cidade               Estado  Documento de Identidade Estado Civil"
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    IMPCTL(drvpenf)
    @ cl,005 SAY TRAN(GRUPOS->cidade,"@!")         // cidade contratante
    IMPCTL(drvtenf)
    @ cl,028 SAY TRAN([  ],"!!")                   // Estado Contratante
    IMPCTL(drvpenf)
    @ cl,037 SAY GRUPOS->rg                        // Doc
    IMPCTL(drvtenf)
    IMPCTL(drvpenf)
    @ cl,059 SAY TRAN(subst(tbestciv,AT(GRUPOS->estcivil,tbestciv),10),"@!")// Est.Civil contratante
    IMPCTL(drvtenf)
    REL_CAB(2)                                     // soma cl/imprime cabecalho
    IMPAC("Contrato    Grupo            Admiss„o                 Processo",cl,005)
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    IMPCTL(drvpenf)
    @ cl,005 SAY contrato                          // contrato numero
    IMPCTL(drvtenf)
    IMPCTL(drvpenf)
    @ cl,018 SAY GRUPOS->grupo                     // grupo
    IMPCTL(drvtenf)
    IMPCTL(drvpenf)
    @ cl,034 SAY GRUPOS->admissao                  // data admissao
    IMPCTL(drvtenf)
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    IMPMEMO(Rx2001F9(),70,1,cl,001,.t.)            // pedido (memo)
    qli_m=MLCOUNT(Rx2001F9(),70)-1                 // quantas linhas a imprimir?
    li_m=0
    DO WHIL .t.                                    // imprime linhas do memo
     li_m++
     IF li_m>qli_m                                 // fim do memo
      EXIT
     ENDI
     REL_CAB(1)                                    // soma cl/imprime cabecalho
     IMPMEMO(Rx2001F9(),70,1+li_m,cl,001,(li_m<qli_m))      // imprime...
     #ifdef COM_TUTOR
      IF IN_KEY()=K_ESC                            // se quer cancelar
     #else
      IF INKEY()=K_ESC                             // se quer cancelar
     #endi
      IF canc()                                    // pede confirmacao
       BREAK                                       // confirmou...
      ENDI
     ENDI
    ENDD
    REL_CAB(2)                                     // soma cl/imprime cabecalho
    @ cl,004 SAY "Nome do falecido....:"
    IMPCTL(drvpenf)
    @ cl,026 SAY TRAN(falecido,"@!")               // nome do falecido
    IMPCTL(drvtenf)
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    IMPAC("Endere‡o do falecido:",cl,004)
    IMPCTL(drvpenf)
    @ cl,026 SAY TRAN(ALLTRIM(ruares)+[, ]+ALLTRIM(baires),"@!")// Endereco falecido
    IMPCTL(drvtenf)
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,004 SAY "Inscrito neste contrato na qualidade de"
    IMPCTL(drvpenf)
    @ cl,044 SAY grauparcon                        // Inscrito na qualidade de
    IMPCTL(drvtenf)
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,004 SAY "Data do Falecimento.:"
    @ cl,026 SAY TRAN(falecto_,"@D")               // Data falcto.
    IMPAC("Hor rio do Falecimento:",cl,036)
    @ cl,060 SAY TRAN(horafal,"99:99")             // Hora Falcto.
    REL_CAB(2)                                     // soma cl/imprime cabecalho
    @ cl,004 SAY "Cidade do Falecimento Estado   Local do falecimento"
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    IMPCTL(drvpenf)
    @ cl,004 SAY municfal                          // Cidade Falecimento
    IMPCTL(drvtenf)
    IMPCTL(drvpenf)
    @ cl,028 SAY TRAN(estfal,"!!")                 // UF falecimento
    IMPCTL(drvtenf)
    IMPCTL(drvpenf)
    @ cl,035 SAY ALLTRIM(ruafal)                   // local falecimento
    IMPCTL(drvtenf)
    REL_CAB(2)                                     // soma cl/imprime cabecalho
    IMPAC("Cemit‚rio onde foi sepultado        Hora do sepultamento",cl,004)
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    IMPCTL(drvpenf)
    @ cl,004 SAY cemitsep                          // Cemit‚rio sepultamento
    IMPCTL(drvtenf)
    IMPCTL(drvpenf)
    @ cl,046 SAY TRAN(horasepult,"99:99")          // Hora sepultamento
    IMPCTL(drvtenf)
    REL_CAB(2)                                     // soma cl/imprime cabecalho
    IMPAC("DECLARA€ŽO",cl,031)
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    IMPMEMO(Rx2002F9(),70,1,cl,002,.t.)            // DECLARACAO (memo)
    qli_m=MLCOUNT(Rx2002F9(),70)-1                 // quantas linhas a imprimir?
    li_m=0
    DO WHIL .t.                                    // imprime linhas do memo
     li_m++
     IF li_m>qli_m                                 // fim do memo
      EXIT
     ENDI
     REL_CAB(1)                                    // soma cl/imprime cabecalho
     IMPMEMO(Rx2002F9(),70,1+li_m,cl,002,(li_m<qli_m))      // imprime...
     #ifdef COM_TUTOR
      IF IN_KEY()=K_ESC                            // se quer cancelar
     #else
      IF INKEY()=K_ESC                             // se quer cancelar
     #endi
      IF canc()                                    // pede confirmacao
       BREAK                                       // confirmou...
      ENDI
     ENDI
    ENDD
    REL_CAB(2)                                     // soma cl/imprime cabecalho
    @ cl,025 SAY IMPAC(RTRIM(M->p_cidade)+[, ]+LEFT(DTOC(DATE()),2)+[ de ]+NMES(MONTH(DATE()))+ [ de ]+LEFT(DTOS(DATE()),4))// DATA
    REL_CAB(2)                                     // soma cl/imprime cabecalho
//    @ cl,001 SAY "PROCESSAR"
    REL_CAB(1)                                     // soma cl/imprime cabecalho
//    @ cl,000 SAY "PAGAMENTO EM"
    REL_CAB(1)                                     // soma cl/imprime cabecalho
//    IMPCTL(drvpenf)
//    @ cl,002 SAY TRAN(procpagto_,"@D")             // Proc.pagto em
//    IMPCTL(drvtenf)
    REL_CAB(3)                                     // soma cl/imprime cabecalho
    @ cl,021 SAY REPL("-",42)
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,021 SAY "Ass.:"
    IMPCTL(drvpenf)
    @ cl,027 SAY GRUPOS->nome                      // Nome
    IMPCTL(drvtenf)
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,027 SAY "RG:"
    @ cl,031 SAY TRAN(GRUPOS->rg,"@!")             // R.G.
    SKIP                                           // pega proximo registro
    cl=999                                         // forca salto de pagina
   ELSE                                            // se nao atende condicao
    SKIP                                           // pega proximo registro
   ENDI
   EXIT
  ENDD
 ENDD ccop
END SEQUENCE
SET PRINTER TO (drvporta)                          // fecha arquivo gerado (se houver)
SET DEVI TO SCRE                                   // direciona saida p/ video
IF tps=2                                           // se vai para arquivo/video
 BROWSE_REL(arq_,2,3,MAXROW()-2,78)
ENDI                                               // mostra o arquivo gravado
GRELA(3)                                           // grava variacao do relatorio
SELE AFUNER                                        // salta pagina
SET RELA TO                                        // retira os relacionamentos
SET(_SET_DELETED,dele_atu)                         // os excluidos serao vistos
IF so_um_reg
 POINTER_DBF(sit_dbf)
ENDI
RETU

STATIC PROC REL_CAB(qt)                            // cabecalho do relatorio
IF qt>0                                            // se parametro maior que 0
 cl=cl+qt                                          // soma no contador de linhas
ENDI
IF cl>maxli .OR. qt=0                              // quebra de pagina
 @ 0,001 SAY IIF(categ=[PD],[Plano c/Difer. ],IIF(categ=[PL],[Atend.Plano],[Rest.Desp.Funerais]))// Categoria
 @ 5,021 SAY M->setup1                             // Ident1
    IMPCTL(drvPenf)
 @ 6,021 SAY "REQUERIMENTO DE PAGAMENTO/ATENDIMENTO"
 @ 7,022 SAY "FUNERAL E TERMO DE RESPONSABILIDADE"
    IMPCTL(drvtenf)
 cl=qt+8 ; pg_++
ENDI
RETU

* \\ Final de ADM_RX20.PRG
€
 R02001F9ª–Ñ  R02001F9CODEC_ETEXTENDCODE	_SYMSTARTSYMSTARTSYMBOLSSYMBOLS_SYMENDSYMENDNULLBEGDATA_DATADATA_SYMPBDATA_SYMPDATA_SYMPEDATA_CONSTCONST_MSGMSG_BEGBSSBEGBSS_BSSBSS_ENDBSSENDBSSDGROUPi˜ @þ˜ H  ˜ h  ë˜ `  	O˜ h  
ã˜ h  ß˜ H  û˜ H  ÷˜ H ë˜ H  ï˜ H  ë˜ (  ˜ H  /*
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
 \ Empresa.: Ind£stria de Urnas Bignotto Ltda
 \ Programa: OBXEC.PRG
 \ Data....: 09-08-96
 \ Sistema.: Administradora de Funer rias
 \ Funcao..: Gerenciador do subsistema de outros recebimentos
 \ Analista: Ademilson Pedro Bom
 \ Criacao.: GAS-Pro v2.0d
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/

#include "admbig.ch"    // inicializa constantes manifestas

PARA lin_menu,col_menu
PRIV op_sis, tela_fundo:=SAVESCREEN(0,0,MAXROW(),79)
op_sis=EVAL(qualsis,"OBXEC")
IF nivelop<sistema[op_sis,O_OUTROS,O_NIVEL]        // se usuario nao tem permissao,
 ALERTA()                                          // entao, beep, beep, beep
 DBOX(msg_auto,,,3)                                // lamentamos e
 RETU                                              // retornamos ao menu
ENDI
cn:=fgrep :=.f.
t_fundo=SAVESCREEN(0,0,MAXROW(),79)                // salva tela do fundo
op_cad=1
DO WHIL op_cad!=0
 criterio=""
 RESTSCREEN(,0,MAXROW(),79,t_fundo)                // restaura tela do fundo
 cod_sos=5 ; cn=.f.
 CLEA TYPEAHEAD                                    // limpa o buffer do teclado
 fgrep=.f.
 SET KEY K_F3 TO                                   // retira das teclas F3 e F4 as
 SET KEY K_F4 TO                                   // funcoes de repeticao e confirmacao
 msg="Inclus„o|"+;
     "Manuten‡„o|"+;
     "Consulta"
 op_cad=DBOX(msg,lin_menu,col_menu,E_MENU,NAO_APAGA,MAIUSC(sistema[op_sis,O_MENU]),,,op_cad)
 IF op_cad!=0                                      // se escolheu uma opcao
  Tela_fundo=SAVESCREEN(0,0,MAXROW(),79)           // salva a tela para ROLATELA()
  SELE A                                           // e abre o arquivo e seus indices

  #ifdef COM_REDE
   IF !USEARQ(sistema[op_sis,O_ARQUI],.f.,20,1)    // se falhou a abertura do
    RETU                                           // arquivo volta ao menu anterior
   ENDI
  #else
   USEARQ(sistema[op_sis,O_ARQUI])
  #endi

  SET KEY K_F9 TO veoutros                         // habilita consulta em outros arquivos
 ENDI
 DO CASE
  CASE op_cad=01                                   // inclus„o
   op_menu=INCLUSAO
   IF AT("D",exrot[op_sis])=0                      // se usuario pode fazer inclusao
    OBX_INCL()                                     // neste arquivo chama prg de inclusao
   ELSE                                            // caso contrario vamos avisar que
    ALERTA()                                       // ele nao tem permissao para isto
    DBOX(msg_auto,,,3)
   ENDI

  CASE op_cad=02                                   // manuten‡„o
   op_menu=ALTERACAO
   cod_sos=7
   EDIT()

  CASE op_cad=03                                   // consulta
   op_menu=PROJECOES
   cod_sos=8
   EDITA(3,3,MAXROW()-2,77)

 ENDC
 SET KEY K_F9 TO                                   // F9 nao mais consultara outros arquivos
 CLOS ALL                                          // fecha todos arquivos abertos
ENDD
RETU

PROC OBX_incl     // inclusao no arquivo OBXEC
LOCAL getlist:={},cabem:=1,rep:=ARRAY(FCOU()),ult_reg:=RECN(),dbfseq_,;
      ctl_r, ctl_c, ctl_w, t_f3_, t_f4_, dele_atu:=SET(_SET_DELETED,.f.)
PRIV op_menu:=INCLUSAO, sq_atual_, tem_borda, criterio:="", cpord:=""
FOR i=1 TO FCOU()                                  // cria/declara privadas as
 msg=FIEL(i)                                       // variaveis de memoria com
 PRIV &msg.                                        // o mesmo nome dos campos
NEXT                                               // do arquivo
AFILL(rep,"")
t_f3_=SETKEY(K_F3,{||rep()})                       // repeticao reg anterior
t_f4_=SETKEY(K_F4,{||conf()})                      // confirma campos com ENTER
ctl_w=SETKEY(K_CTRL_W,{||nadafaz()})               // enganando o CA-Clipper...
ctl_c=SETKEY(K_CTRL_C,{||nadafaz()})
ctl_r=SETKEY(K_CTRL_R,{||nadafaz()})

#ifdef COM_REDE
 OBX_CRIA_SEQ()                                    // cria dbf de controle de cp sequenciais
 FOR i=1 TO FCOU()                                 // cria/declara privadas as
  msg="sq_"+FIEL(i)                                // variaveis de memoria com
  PRIV &msg.                                       // o mesmo nome dos campos
 NEXT                                              // do arquivo com estensao _seq
#endi

DO WHIL cabem>0
 cod_sos=6
 rola_t=.f.                                        // flag se quer rolar a tela
 SELE OBXEC
 GO BOTT                                           // forca o
 SKIP                                              // final do arquivo
 
 /*
    cria variaveis de memoria identicas as de arquivo, para inclusao
    de registros
 */
 FOR i=1 TO FCOU()
  msg=FIEL(i)
  M->&msg.=IF(fgrep.AND.!EMPT(rep[1]),rep[i],&msg.)
 NEXT
 DISPBEGIN()                                       // apresenta a tela de uma vez so
 OBX_TELA()
 INFOSIS()                                         // exibe informacao no rodape' da tela
 DISPEND()
 OBX_GERA_SEQ()
 cabem=DISKSPACE(IF(LEN(drvdbf)<2.OR.drvdbf="\",0,ASC(drvdbf)-64))
 cabem=INT((cabem-2048)/OBXEC->(RECSIZE()))
 IF cabem<1                                        // mais nenhum!!!
  ALERTA()
  msg="Verifique ESPA€O EM DISCO, "+usuario
  DBOX(msg,,,,,"INCLUSŽO INTERROMPIDA!")           // vamos parar por aqui!
  EXIT
 ENDI
 M->ano=LPAD(RIGHT(DTOC(DATE()),2),02,[0])
 SELE 0                                            // torna visiveis variaveis de memoria
 OBX_GET1(INCLUI)                                  // recebe campos
 SELE OBXEC
 IF LASTKEY()=K_ESC                                // se cancelou
  cabem=0
  LOOP
 ENDI

 #ifdef COM_REDE
  BLOARQ(0,.5)                                     // bloquea o arquivo
 #endi

 APPEND BLANK                                      // inclui reg em branco no dbf
 FOR i=1 TO FCOU()                                 // para cada campo,
  msg=FIEL(i)                                      // salva o conteudo
  rep[i]=M->&msg.                                  // para repetir
  REPL &msg. WITH rep[i]                           // enche o campo do arquivo
 NEXT

 #ifdef COM_REDE
  UNLOCK                                           // libera o registro e
  COMMIT                                           // forca gravacao
 #else
  IF RECC()-INT(RECC()/20)*20=0                    // a cada 20 registros
   COMMIT                                          // digitados forca gravacao
  ENDI
 #endi

 ult_reg=RECN()                                    // ultimo registro digitado
 DO WHIL .t.                                       // imprime relat apos inclusao
  msgt="OUTROS RECIBOS"
  IF PREPIMP(msgt)                                 // confima preparacao da impressora
   SAVE SCREEN                                     // salva a tela
   ADM_R033(0,0,RECN())
   REST SCREEN                                     // restaura tela
**********
   exit                                            // sa¡da pela tangente
**********
   msg="Prosseguir|Outra c¢pia"
   op_=DBOX(msg,,,E_MENU,,msgt)                    // quer emitir outra copia?
   IF op_=2
    LOOP                                           // nao quer...
   ENDI
  ENDI
  EXIT
 ENDD
ENDD

#ifdef COM_REDE
 OBX_ANT_SEQ()                                     // restaura sequencial anterior
 SELE OBXEC
#endi

GO ult_reg                                         // para o ultimo reg digitado
SETKEY(K_F3,t_f3_)                                 // restaura teclas de funcoes
SETKEY(K_F4,t_f4_)
SET(_SET_DELETED,dele_atu)                            // ecluidos visiveis/invisiveis
SETKEY(K_CTRL_W,ctl_w)
SETKEY(K_CTRL_C,ctl_c)
SETKEY(K_CTRL_R,ctl_r)
RETU


#ifdef COM_REDE
 PROC OBX_ANT_SEQ(est_seq)     // restaura sequencial anterior
 SELE OBX_SEQ     // seleciona arquivo de controle de sequencial
 BLOARQ(0,.5)     // esta estacao foi a ultima a incluir?
 IF sq_atual_=numero
  REPL numero WITH sq_numero
  REPL intlan WITH sq_intlan
 ENDI
 UNLOCK           // libera DBF para outros usuarios
 COMMIT           // atualiza cps sequenciais no disco
 RETU
#endi


PROC OBX_CRIA_SEQ   // cria dbf de controle de campos sequenciais
LOCAL dbfseq_:=drvdbf+"OBX_seq" // arq temporario
SELE 0                          // seleciona area vazia
IF !FILE(dbfseq_+".dbf")        // se o dbf nao existe
 DBCREATE(dbfseq_,{;            // vamos criar a sua estrutura
		    {"numero"    ,"C",  6, 0},;
                    {"intlan"    ,"C",  8, 0};
                  };
 )
ENDI
USEARQ(dbfseq_,.f.,,,.f.)       // abre arquivo de cps sequencial
IF RECC()=0                     // se o dbf foi criado agora
 BLOARQ(0,.5)                   // inclui um registro que tera
 APPEND BLANK                   // os ultomos cps sequenciais
 SELE OBXEC
 IF RECC()>0                    // se o DBF nao estiver
  SET ORDER TO 0                // vazio, entao enche DBF seq
  GO BOTT                       // com o ultimo reg digitado
  REPL OBX_SEQ->numero WITH numero
  REPL OBX_SEQ->intlan WITH intlan
  SET ORDER TO 1                // retorna ao indice principal
 ENDI
 SELE OBX_SEQ                   // seleciona arq de sequencias
 UNLOCK                         // libera DBF para outros usuarios
 COMMIT                         // atualiza cps sequenciais no disco
ENDI
RETURN

PROC OBX_GERA_SEQ()

#ifdef COM_REDE
 LOCAL ar_:=SELEC()
#else
 LOCAL reg_:=RECNO(),ord_ind:=INDEXORD()
#endi


#ifdef COM_REDE
 SELE OBX_SEQ
 BLOARQ(0,.5)
 sq_numero=OBX_SEQ->numero
 sq_intlan=OBX_SEQ->intlan
#else
 SET ORDER TO 0
 GO BOTT
#endi

M->numero=LPAD(STR(VAL(numero)+1),06,[0])
M->intlan=LPAD(STR(VAL(intlan)+1),08,[0])

#ifdef COM_REDE
 OBX_GRAVA_SEQ()
 sq_atual_=OBX_SEQ->numero
 UNLOCK
 COMMIT
 SELE (ar_)
#else
 DBSETORDER(ord_ind)
 GO reg_
#endi

RETU

PROC OBX_GRAVA_SEQ
REPL numero WITH M->numero
REPL intlan WITH M->intlan
RETU

PROC OBX_tela     // tela do arquivo OBXEC
tem_borda=.t.
l_s=Sistema[op_sis,O_TELA,O_LS]           // coordenadas da tela
c_s=Sistema[op_sis,O_TELA,O_CS]
l_i=Sistema[op_sis,O_TELA,O_LI]
c_i=Sistema[op_sis,O_TELA,O_CI]
SETCOLOR(drvtittel)
vr_memo=NOVAPOSI(@l_s,@c_s,@l_i,@c_i)     // pega posicao atual da tela
CAIXA(mold,l_s,c_s,l_i,c_i)               // monta caixa da tela
i=LEN(sistema[op_sis,O_MENS])/2
@ l_s,c_s-1+(c_i-c_s+1)/2-i SAY " "+MAIUSC(sistema[op_sis,O_MENS])+" "
SETCOLOR(drvcortel)
@ l_s+01,c_s+1 SAY " Numero....:   -"
@ l_s+02,c_s+1 SAY " Contrato..:"
@ l_s+03,c_s+1 SAY "ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄ"
@ l_s+04,c_s+1 SAY "                                     ³ Circulares"
@ l_s+05,c_s+1 SAY "                                     ³  Ini"
@ l_s+06,c_s+1 SAY "                           Reg.:     ³  £lt"
@ l_s+07,c_s+1 SAY "                                     ³  Pend"
@ l_s+08,c_s+1 SAY " Admiss„o:           Sai Taxa:       ³"
@ l_s+09,c_s+1 SAY " Funerais:           Cobrador:       ³"
@ l_s+10,c_s+1 SAY "ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄ"
@ l_s+11,c_s+1 SAY "  Cir Emiss„o     Valor   Pago em     Valor"
@ l_s+16,c_s+1 SAY "ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ"
@ l_s+17,c_s+1 SAY " Ref:                         Vl.Pago:"
@ l_s+18,c_s+1 SAY " Pago com:               Troco:"
@ l_s+19,c_s+1 SAY "  emitida em          por"
RETU

PROC OBX_gets     // mostra variaveis do arquivo OBXEC
LOCAL getlist := {}, ord_, chv_, ar_get1:=ALIAS()
OBX_TELA()
SETCOLOR(drvcortel+","+drvcorget+",,,"+corcampo)
PTAB(CODIGO,'GRUPOS',3)
PTAB(IIF(EMPT(M->USUARIO),PADR(M->CONTAREC+IDE_MAQ,10,' '),PADR(M->USUARIO,10,' '))+M->HISTRCREC+[       ],'ORDPGRC',2)
@ l_s+01 ,c_s+14 GET  ano;
                 PICT sistema[op_sis,O_CAMPO,01,O_MASC]

@ l_s+01 ,c_s+17 GET  numero;
                 PICT sistema[op_sis,O_CAMPO,02,O_MASC]

@ l_s+02 ,c_s+14 GET  codigo;
                 PICT sistema[op_sis,O_CAMPO,03,O_MASC]
                 CRIT(sistema[op_sis,O_CAMPO,03,O_CRIT],,"1|2|3|4|5|6|7|8|9|10|11|12|13|14")

@ l_s+17 ,c_s+07 GET  ref;
                 PICT sistema[op_sis,O_CAMPO,04,O_MASC]

@ l_s+17 ,c_s+40 GET  valorpg;
                 PICT sistema[op_sis,O_CAMPO,05,O_MASC]

@ l_s+18 ,c_s+12 GET  valoraux;
                 PICT sistema[op_sis,O_CAMPO,06,O_MASC]
                 CRIT(sistema[op_sis,O_CAMPO,06,O_CRIT],,"16")

@ l_s+19 ,c_s+14 GET  emitido_;
                 PICT sistema[op_sis,O_CAMPO,07,O_MASC]

@ l_s+19 ,c_s+27 GET  por

@ l_s+19 ,c_s+44 GET  numop;
                 PICT sistema[op_sis,O_CAMPO,09,O_MASC]

CRIT("",,"15")
CLEAR GETS
RETU

PROC OBX_get1     // capta variaveis do arquivo OBXEC
LOCAL getlist := {}, ord_, chv_, ar_get1:=ALIAS()
PRIV  blk_obxec:=.t.
PARA tp_mov
IF tp_mov=INCLUI
 DO WHILE .t.
  rola_t=.f.
  SET KEY K_ALT_F8 TO ROLATELA
  SETCOLOR(drvcortel+","+drvcorget+",,,"+corcampo)
  @ l_s+01 ,c_s+14 GET ano;
                   PICT sistema[op_sis,O_CAMPO,01,O_MASC]
  @ l_s+01 ,c_s+17 GET numero;
                   PICT sistema[op_sis,O_CAMPO,02,O_MASC]
  @ l_s+19 ,c_s+14 GET emitido_;
                   PICT sistema[op_sis,O_CAMPO,07,O_MASC]
  @ l_s+19 ,c_s+27 GET por
  @ l_s+19 ,c_s+44 GET numop;
                   PICT sistema[op_sis,O_CAMPO,09,O_MASC]
  CLEA GETS
  @ l_s+02 ,c_s+14 GET  codigo;
                   PICT sistema[op_sis,O_CAMPO,03,O_MASC]
                   DEFINICAO 3
                   MOSTRA sistema[op_sis,O_FORMULA,1]
                   MOSTRA sistema[op_sis,O_FORMULA,2]
                   MOSTRA sistema[op_sis,O_FORMULA,3]
                   MOSTRA sistema[op_sis,O_FORMULA,4]
                   MOSTRA sistema[op_sis,O_FORMULA,5]
                   MOSTRA sistema[op_sis,O_FORMULA,6]
                   MOSTRA sistema[op_sis,O_FORMULA,7]
                   MOSTRA sistema[op_sis,O_FORMULA,8]
                   MOSTRA sistema[op_sis,O_FORMULA,9]
                   MOSTRA sistema[op_sis,O_FORMULA,10]
                   MOSTRA sistema[op_sis,O_FORMULA,11]
                   MOSTRA sistema[op_sis,O_FORMULA,12]
                   MOSTRA sistema[op_sis,O_FORMULA,13]
                   MOSTRA sistema[op_sis,O_FORMULA,14]

  @ l_s+17 ,c_s+07 GET  ref;
                   PICT sistema[op_sis,O_CAMPO,04,O_MASC]
                   DEFINICAO 4

  @ l_s+17 ,c_s+40 GET  valorpg;
                   PICT sistema[op_sis,O_CAMPO,05,O_MASC]
                   DEFINICAO 5

  @ l_s+18 ,c_s+12 GET  valoraux;
                   PICT sistema[op_sis,O_CAMPO,06,O_MASC]
                   DEFINICAO 6
                   MOSTRA sistema[op_sis,O_FORMULA,16]

  READ
  SET KEY K_ALT_F8 TO
  IF rola_t
   ROLATELA()
   LOOP
  ENDI
  IF LASTKEY()!=K_ESC .AND. drvincl .AND. op_menu=INCLUSAO
   IF !CONFINCL()
    LOOP
   ENDI
  ENDI
  EXIT
 ENDD
ENDI
PTAB(CODIGO,'GRUPOS',3)
PTAB(CODIGO,'TAXAS',1)
PTAB(IIF(EMPT(M->USUARIO),PADR(M->CONTAREC+IDE_MAQ,10,' '),PADR(M->USUARIO,10,' '))+M->HISTRCREC+[       ],'ORDPGRC',2)
IF tp_mov=EXCLUI .OR. tp_mov=FORM_INVERSA

 #ifdef COM_REDE
  IF !EMPT(valorpg).AND.PTAB(IIF(EMPT(M->usuario),PADR(M->contarec+ide_maq,10,' '),PADR(M->usuario,10,' '))+M->histrcrec+[       ],'ORDPGRC',2)
   REPBLO('ORDPGRC->valortotal',ORDPGRC->valortotal -valorpg)
   REPBLO('ORDPGRC->nrdoctos',ORDPGRC->nrdoctos - 1)
  ENDI
 #else
  IF !EMPT(valorpg).AND.PTAB(IIF(EMPT(M->usuario),PADR(M->contarec+ide_maq,10,' '),PADR(M->usuario,10,' '))+M->histrcrec+[       ],'ORDPGRC',2)
   REPL ORDPGRC->valortotal WITH ORDPGRC->valortotal -valorpg
   REPL ORDPGRC->nrdoctos WITH ORDPGRC->nrdoctos - 1
  ENDI
 #endi

 IF EMPT(ORDPGRC->numos)
  IF !EMPTY(ORDPGRC->codlan)
   TIRA_LANC("ORDPGRC",LEFT(ORDPGRC->codlan,16),.f.)
  ENDI
 ENDI
 DELE
ELSEIF tp_mov=INCLUI .OR. tp_mov=RECUPERA .OR. tp_mov=FORM_DIRETA
 IF (op_menu=INCLUSAO .AND. LASTKEY()!=K_ESC) .OR. op_menu!=INCLUSAO
  IF !EMPT(valorpg).AND. !PTAB(IIF(EMPT(M->usuario),PADR(M->contarec+ide_maq,10,' '),PADR(M->usuario,10,' '))+M->histrcrec+[       ],'ORDPGRC',2)
   ord_=LEN(sistema[EVAL(qualsis,"ORDPGRC"),O_CHAVE])
   chv_="OBX-"+intlan+"-001"
   PTAB(chv_,"ORDPGRC",ord_)
   FAZ_LANC("ORDPGRC",chv_,.t.)
   REPL ORDPGRC->origem WITH [ADM],;
        ORDPGRC->lancto_ WITH DATE(),;
        ORDPGRC->por WITH M->usuario,;
        ORDPGRC->numconta WITH IIF(EMPT(M->usuario),PADR(M->contarec+ide_maq,10,' '),PADR(M->usuario,10,' ')),;
        ORDPGRC->historico WITH M->histrcrec,;
        ORDPGRC->debcred WITH [C],;
        ORDPGRC->valortotal WITH 0,;
        ORDPGRC->vencto_ WITH DATE(),;
        ORDPGRC->documento WITH [Recibos],;
        ORDPGRC->complement WITH [Outros Recebimentos ]

   #ifdef COM_REDE
    ORDPGRC->(DBUNLOCK())                          // libera o registro
   #endi

  ENDI

  #ifdef COM_REDE
   IF !EMPT(valorpg).AND.PTAB(IIF(EMPT(M->usuario),PADR(M->contarec+ide_maq,10,' '),PADR(M->usuario,10,' '))+M->histrcrec+[       ],'ORDPGRC',2)
    REPBLO('ORDPGRC->valortotal',ORDPGRC->valortotal +valorpg)
    REPBLO('ORDPGRC->nrdoctos',ORDPGRC->nrdoctos + 1)
   ENDI
   IF op_menu=INCLUSAO
    emitido_=DATE()
   ELSE
    REPL emitido_ WITH DATE()
   ENDI
   IF op_menu=INCLUSAO
    por=M->usuario
   ELSE
    REPL por WITH M->usuario
   ENDI
   IF op_menu=INCLUSAO
    numop=ORDPGRC->numop
   ELSE
    REPL numop WITH ORDPGRC->numop
   ENDI
  #else
   IF !EMPT(valorpg).AND.PTAB(IIF(EMPT(M->usuario),PADR(M->contarec+ide_maq,10,' '),PADR(M->usuario,10,' '))+M->histrcrec+[       ],'ORDPGRC',2)
    REPL ORDPGRC->valortotal WITH ORDPGRC->valortotal +valorpg
    REPL ORDPGRC->nrdoctos WITH ORDPGRC->nrdoctos + 1
   ENDI
   IF op_menu=INCLUSAO
    emitido_=DATE()
   ELSE
    REPL emitido_ WITH DATE()
   ENDI
   IF op_menu=INCLUSAO
    por=M->usuario
   ELSE
    REPL por WITH M->usuario
   ENDI
   IF op_menu=INCLUSAO
    numop=ORDPGRC->numop
   ELSE
    REPL numop WITH ORDPGRC->numop
   ENDI
  #endi

  IF op_menu!=INCLUSAO
   RECA
  ENDI
 ENDI
ENDI
RETU

* \\ Final de OBXEC.PRG
procedure alender
/*
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
 \ Empresa.: PresServ Inform tica - Limeira (019)452.6623
 \ Programa: ALENDER.PRG
 \ Data....: 04-11-03
 \ Sistema.: Administradora - RECEP€„O
 \ Funcao..: Gerenciador do subsistema de endere‡os
 \ Analista: Ademilson Pedro Bom
 \ Criacao.: GAS-Pro v4.0n
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/
#include "adrbig.ch"    // inicializa constantes manifestas

PARA lin_menu,col_menu
PRIV op_sis, tela_fundo:=SAVESCREEN(0,0,MAXROW(),79), l_s, c_s, l_i, c_i, l_a

op_sis=EVAL(qualsis,"ALENDER")
IF nivelop<sistema[op_sis,O_OUTROS,O_NIVEL]        // se usuario nao tem permissao,
 ALERTA()                                          // entao, beep, beep, beep
 DBOX(msg_auto,,,3)                                // lamentamos e
 RETU                                              // retornamos ao menu
ENDI
cn:=fgrep :=.f.

#ifdef COM_LOCK
 IF LEN(pr_ok)>0                                   // se a protecao acusou
  ? pr_ok                                          // erro, avisa e
  QUIT                                             // encerra a aplicacao
 ENDI
#endi

t_fundo=SAVESCREEN(0,0,MAXROW(),79)                // salva tela do fundo
op_cad=1
DO WHIL op_cad!=0
 criterio=""
 RESTSCREEN(0,0,MAXROW(),79,t_fundo)               // restaura tela do fundo
 cod_sos=5 ; cn=.f.
 CLEA TYPEAHEAD                                    // limpa o buffer do teclado
 fgrep=.f.
 SET KEY K_F3 TO                                   // retira das teclas F3 e F4 as
 SET KEY K_F4 TO                                   // funcoes de repeticao e confirmacao
 msg="Inclus„o~1|"+;
     "Manuten‡„o~2|"+;
     "Consulta~3"
 op_cad=DBOX(msg,lin_menu,col_menu,E_MENU,NAO_APAGA,MAIUSC(sistema[op_sis,O_MENU]),,,op_cad)
 IF op_cad!=0                                      // se escolheu uma opcao
  Tela_fundo=SAVESCREEN(0,0,MAXROW(),79)           // salva a tela para ROLATELA()
  PARAMETROS(dbfparam)
  SELE A                                           // e abre o arquivo e seus indices

  #ifdef COM_REDE
   IF !USEARQ(sistema[op_sis,O_ARQUI,O_NOME],.f.,20,1)
                                                   // se falhou a abertura do
    RETU                                           // arquivo volta ao menu anterior
   ENDI
  #else
   USEARQ(sistema[op_sis,O_ARQUI,O_NOME])
  #endi

  SET KEY K_F9 TO veoutros                         // habilita consulta em outros arquivos
 ENDI
 DO CASE
  CASE op_cad=01                                   // inclus„o
   op_menu=INCLUSAO
   IF AT("D",exrot[op_sis])=0                      // se usuario pode fazer inclusao
    ALE_INCL()                                     // neste arquivo chama prg de inclusao
   ELSE                                            // caso contrario vamos avisar que
    ALERTA()                                       // ele nao tem permissao para isto
    DBOX(msg_auto,,,3)
   ENDI

  CASE op_cad=02                                   // manuten‡„o
   op_menu=ALTERACAO
   cod_sos=7
   EDIT()

  CASE op_cad=03                                   // consulta
   op_menu=PROJECOES
   cod_sos=8
   EDITA(03,03,MAXROW()-2,77)

 ENDC
 SET KEY K_F9 TO                                   // F9 nao mais consultara outros arquivos
 CLOS ALL                                          // fecha todos arquivos abertos
ENDD
RETU

PROC ALE_incl(reg_cop)  // inclusao no arquivo ALENDER
LOCAL getlist:={},cabem:=1,rep:=ARRAY(FCOU()),ult_reg:=RECN(),cond_incl_,dbfseq_,;
      ctl_r, ctl_c, ctl_w, t_f3_, t_f4_, dele_atu:=SET(_SET_DELETED,.f.)
PRIV op_menu:=INCLUSAO, sq_atual_, tem_borda, criterio:="", cpord:=""
cond_incl_={||nivelop>1}                           // condicao de inclusao de registros
IF !EVAL(cond_incl_)                               // se nao pode incluir
 ALERTA(2)                                         // avisa o motivo
 DBOX("Permitido apenas a usu rios cadastrados|com n¡vel de Manuten‡„o ou Maior",,,4,,"ATEN€ŽO, "+usuario)
 RETU                                              // e retorna
ENDI
FOR i=1 TO FCOU()                                  // cria/declara privadas as
 msg=FIEL(i)                                       // variaveis de memoria com
 PRIV &msg.                                        // o mesmo nome dos campos
NEXT                                               // do arquivo
IF reg_cop!=NIL                                    // quer repetir todo o reg atual
 FOR i=1 TO FCOU()                                 // para cada campo,
  msg=FIEL(i)                                      // salva o conteudo
  rep[i]=&msg.                                     // para repetir
 NEXT
ELSE
 AFILL(rep,"")                                     // eche com valor vazio
ENDI
t_f3_=SETKEY(K_F3,{||rep()})                       // repeticao reg anterior
t_f4_=SETKEY(K_F4,{||conf()})                      // confirma campos com ENTER
ctl_w=SETKEY(K_CTRL_W,{||nadafaz()})               // enganando o CA-Clipper...
ctl_c=SETKEY(K_CTRL_C,{||nadafaz()})
ctl_r=SETKEY(K_CTRL_R,{||nadafaz()})

#ifdef COM_REDE
 ALE_CRIA_SEQ()                                    // cria dbf de controle de cp sequenciais
 FOR i=1 TO FCOU()                                 // cria/declara privadas as
  msg="sq_"+FIEL(i)                                // variaveis de memoria com
  PRIV &msg.                                       // o mesmo nome dos campos
 NEXT                                              // do arquivo com extensao _seq
#endi

DO WHIL cabem>0
 cod_sos=6
 rola_t=.f.                                        // flag se quer rolar a tela
 SELE ALENDER
 GO BOTT                                           // forca o
 SKIP                                              // final do arquivo
 
 /*
    cria variaveis de memoria identicas as de arquivo, para inclusao
    de registros
 */
 FOR i=1 TO FCOU()
  msg=FIEL(i)
  M->&msg.=IF((fgrep .OR. reg_cop!=NIL).AND.!EMPT(rep[1]),rep[i],&msg.)
 NEXT
 DISPBEGIN()                                       // apresenta a tela de uma vez so
 ALE_TELA()
 INFOSIS(.t.)                                      // exibe informacao no rodape' da tela
 DISPEND()
 ALE_GERA_SEQ()
 IF !EVAL(cond_incl_)
  EXIT
 ENDI
 cabem=DISKSPACE(;
          IF(;
             LEN(sistema[op_sis,O_ARQUI,O_DIR_DBF])<2.OR.sistema[op_sis,O_ARQUI,O_DIR_DBF]="\",;
             0,;
             ASC(sistema[op_sis,O_ARQUI,O_DIR_DBF])-64;
          );
       )
 cabem=INT((cabem-2048)/ALENDER->(RECSIZE()))
 IF cabem<1                                        // mais nenhum!!!
  ALERTA()
  msg="Verifique ESPA€O EM DISCO, "+usuario
  DBOX(msg,,,,,"INCLUSŽO INTERROMPIDA!")           // vamos parar por aqui!
  EXIT
 ENDI
 M->data_=DATE()
 M->por=M->usuario
 SELE 0                                            // torna visiveis variaveis de memoria
 ALE_GET1(INCLUI)                                  // recebe campos
 SELE ALENDER
 IF LASTKEY()=K_ESC                                // se cancelou
  cabem=0                                          // prepara saida da inclusao
  LOOP
 ENDI

 #ifdef COM_REDE
  GO BOTT                                          // vamos bloquear o final do
  SKIP                                             // arq para que nehum outro
  BLOREG(0,.5)                                     // usuario possa incluir
 #endi

 APPEND BLANK                                      // inclui reg em branco no dbf
 FOR i=1 TO FCOU()                                 // para cada campo,
  msg=FIEL(i)                                      // salva o conteudo
  rep[i]=M->&msg.                                  // para repetir
  REPL &msg. WITH rep[i]                           // enche o campo do arquivo
 NEXT

 #ifdef COM_REDE
  UNLOCK                                           // libera o registro e
  COMMIT                                           // forca gravacao
 #else
  IF RECC()-INT(RECC()/20)*20=0                    // a cada 20 registros
   COMMIT                                          // digitados forca gravacao
  ENDI
 #endi

 ult_reg=RECN()                                    // ultimo registro digitado
 IF reg_cop!=NIL                                   // estava na consulta e quis rep o campo
  sq_atual_=NIL
  EXIT                                             // cai fora...
 ENDI
ENDD

#ifdef COM_REDE
 ALE_ANT_SEQ()                                     // restaura sequencial anterior
 SELE ALENDER
#endi

GO ult_reg                                         // para o ultimo reg digitado
SETKEY(K_F3,t_f3_)                                 // restaura teclas de funcoes
SETKEY(K_F4,t_f4_)
SET(_SET_DELETED,dele_atu)                            // ecluidos visiveis/invisiveis
SETKEY(K_CTRL_W,ctl_w)
SETKEY(K_CTRL_C,ctl_c)
SETKEY(K_CTRL_R,ctl_r)
RETU



#ifdef COM_REDE
 PROC ALE_ANT_SEQ(est_seq)     // restaura sequencial anterior
 SELE ALE_SEQ     // seleciona arquivo de controle de sequencial
 BLOARQ(0,.5)     // esta estacao foi a ultima a incluir?
 IF sq_atual_ == numero
  REPL numero WITH sq_numero
 ENDI
 UNLOCK           // libera DBF para outros usuarios
 COMMIT           // atualiza cps sequenciais no disco
 RETU
#endi


PROC ALE_CRIA_SEQ   // cria dbf de controle de campos sequenciais
LOCAL dbfseq_:=sistema[op_sis,O_ARQUI,O_DIR_DBF]+"ALE_seq" // arq temporario
SELE 0                          // seleciona area vazia
IF !FILE(dbfseq_+".dbf")        // se o dbf nao existe
 DBCREATE(dbfseq_,{;            // vamos criar a sua estrutura
                    {"numero"    ,"C",  8, 0};
                  };
 )
ENDI
USEARQ(dbfseq_,.f.,,,.f.)       // abre arquivo de cps sequencial
IF RECC()=0                     // se o dbf foi criado agora
 BLOARQ(0,.5)                   // inclui um registro que tera
 APPEND BLANK                   // os ultomos cps sequenciais
 SELE ALENDER
 IF RECC()>0                    // se o DBF nao estiver
  SET ORDER TO 0                // vazio, entao enche DBF seq
  GO BOTT                       // com o ultimo reg digitado
  REPL ALE_SEQ->numero WITH numero
  DBSETORDER(1)                 // retorna ao indice principal
 ENDI
 SELE ALE_SEQ                   // seleciona arq de sequencias
 UNLOCK                         // libera DBF para outros usuarios
 COMMIT                         // atualiza cps sequenciais no disco
ENDI
RETURN

PROC ALE_GERA_SEQ()

#ifdef COM_REDE
 LOCAL ar_:=SELEC()
#else
 LOCAL reg_:=RECNO(),ord_ind:=INDEXORD()
#endi


#ifdef COM_REDE
 SELE ALE_SEQ
 BLOARQ(0,.5)
 sq_numero=ALE_SEQ->numero
#else
 DBSETORDER(0)
 GO BOTT
#endi

M->numero=LPAD(STR(VAL(numero)+1),08,[0])
IF VAL(M->numero)=1
 M->numero=LPAD(RIGHT(DTOC(DATE()),2)+[000001],08,[0])
ENDI

#ifdef COM_REDE
 ALE_GRAVA_SEQ()
 sq_atual_=ALE_SEQ->numero
 UNLOCK                                            // libera o registro
 COMMIT
 SELE (ar_)
#else
 DBSETORDER(ord_ind)
 GO reg_
#endi

RETU

PROC ALE_GRAVA_SEQ
REPL numero WITH M->numero
RETU

PROC ALE_tela     // tela do arquivo ALENDER
tem_borda=.t.
l_s=Sistema[op_sis,O_TELA,O_LS]           // coordenadas da tela
c_s=Sistema[op_sis,O_TELA,O_CS]
l_i=Sistema[op_sis,O_TELA,O_LI]
c_i=Sistema[op_sis,O_TELA,O_CI]
SETCOLOR(drvtittel)
vr_memo=NOVAPOSI(@l_s,@c_s,@l_i,@c_i)     // pega posicao atual da tela
CAIXA(mold,l_s,c_s,l_i,c_i)               // monta caixa da tela
i=LEN(sistema[op_sis,O_MENS])/2
@ l_s,c_s-1+(c_i-c_s+1)/2-i SAY " "+MAIUSC(sistema[op_sis,O_MENS])+" "
SETCOLOR(drvcortel)
@ l_s+01,c_s+1 SAY " Contrato:"
@ l_s+02,c_s+1 SAY " Alterar de:                          para:"
@ l_s+06,c_s+1 SAY "             Tel:                                Tel:"
@ l_s+07,c_s+1 SAY " Cobrador:                            Cobrador:"
@ l_s+08,c_s+1 SAY "                      p/               Listado em:"
RETU

PROC ALE_gets     // mostra variaveis do arquivo ALENDER
LOCAL getlist := {}
ALE_TELA()
SETCOLOR(drvcortel+","+drvcorget+",,,"+corcampo)
PTAB(CODIGO,'GRUPOS',1)
CRIT("",,"2")
@ l_s+01 ,c_s+12 GET  codigo;
                 PICT sistema[op_sis,O_CAMPO,01,O_MASC]
                 CRIT(sistema[op_sis,O_CAMPO,01,O_CRIT],,"1")

@ l_s+03 ,c_s+39 GET  endereco

@ l_s+04 ,c_s+39 GET  bairro

@ l_s+05 ,c_s+39 GET  cidade

@ l_s+05 ,c_s+67 GET  uf;
                 PICT sistema[op_sis,O_CAMPO,06,O_MASC]

@ l_s+06 ,c_s+39 GET  cep;
                 PICT sistema[op_sis,O_CAMPO,07,O_MASC]

@ l_s+06 ,c_s+55 GET  telefone;
                 PICT sistema[op_sis,O_CAMPO,08,O_MASC]

@ l_s+07 ,c_s+49 GET  cobrador;
                 PICT sistema[op_sis,O_CAMPO,09,O_MASC]

@ l_s+08 ,c_s+10 GET  data_;
                 PICT sistema[op_sis,O_CAMPO,10,O_MASC]

@ l_s+08 ,c_s+26 GET  por

@ l_s+03 ,c_s+02 GET  dendereco

@ l_s+04 ,c_s+02 GET  dbairro

@ l_s+05 ,c_s+02 GET  dcidade

@ l_s+05 ,c_s+30 GET  duf;
                 PICT sistema[op_sis,O_CAMPO,15,O_MASC]

@ l_s+06 ,c_s+02 GET  dcep;
                 PICT sistema[op_sis,O_CAMPO,16,O_MASC]

@ l_s+06 ,c_s+19 GET  dtelefone;
                 PICT sistema[op_sis,O_CAMPO,17,O_MASC]

@ l_s+07 ,c_s+12 GET  dcobrador;
                 PICT sistema[op_sis,O_CAMPO,18,O_MASC]

@ l_s+08 ,c_s+52 GET  emitido_;
                 PICT sistema[op_sis,O_CAMPO,20,O_MASC]

CLEAR GETS
RETU

PROC ALE_get1(tp_mov)     // capta variaveis do arquivo ALENDER
LOCAL getlist := {}
PRIV  blk_alender:=.t.

IF tp_mov=INCLUI
 DO WHILE .t.
  rola_t=.f.
  SET KEY K_ALT_F8 TO ROLATELA
  SETCOLOR(drvcortel+","+drvcorget+",,,"+corcampo)
  @ l_s+08 ,c_s+10 GET data_;
                   PICT sistema[op_sis,O_CAMPO,10,O_MASC]
  @ l_s+08 ,c_s+26 GET por
  @ l_s+03 ,c_s+02 GET dendereco
  @ l_s+04 ,c_s+02 GET dbairro
  @ l_s+05 ,c_s+02 GET dcidade
  @ l_s+05 ,c_s+30 GET duf;
                   PICT sistema[op_sis,O_CAMPO,15,O_MASC]
  @ l_s+06 ,c_s+02 GET dcep;
                   PICT sistema[op_sis,O_CAMPO,16,O_MASC]
  @ l_s+06 ,c_s+19 GET dtelefone;
                   PICT sistema[op_sis,O_CAMPO,17,O_MASC]
  @ l_s+07 ,c_s+12 GET dcobrador;
                   PICT sistema[op_sis,O_CAMPO,18,O_MASC]
  CLEA GETS
  CRIT("",,"2")
  @ l_s+01 ,c_s+12 GET  codigo;
                   PICT sistema[op_sis,O_CAMPO,01,O_MASC]
                   DEFINICAO 1
                   MOSTRA sistema[op_sis,O_FORMULA,1]

  @ l_s+03 ,c_s+39 GET  endereco
                   DEFINICAO 3

  @ l_s+04 ,c_s+39 GET  bairro
                   DEFINICAO 4

  @ l_s+05 ,c_s+39 GET  cidade
                   DEFINICAO 5

  @ l_s+05 ,c_s+67 GET  uf;
                   PICT sistema[op_sis,O_CAMPO,06,O_MASC]
                   DEFINICAO 6

  @ l_s+06 ,c_s+39 GET  cep;
                   PICT sistema[op_sis,O_CAMPO,07,O_MASC]
                   DEFINICAO 7

  @ l_s+06 ,c_s+55 GET  telefone;
                   PICT sistema[op_sis,O_CAMPO,08,O_MASC]
                   DEFINICAO 8

  @ l_s+07 ,c_s+49 GET  cobrador;
                   PICT sistema[op_sis,O_CAMPO,09,O_MASC]
                   DEFINICAO 9

  @ l_s+08 ,c_s+52 GET  emitido_;
                   PICT sistema[op_sis,O_CAMPO,20,O_MASC]
                   DEFINICAO 20

  READ
  SET KEY K_ALT_F8 TO
  IF rola_t
   ROLATELA()
   LOOP
  ENDI
  IF LASTKEY()!=K_ESC .AND. drvincl .AND. op_menu=INCLUSAO
   IF !CONFINCL()
    LOOP
   ENDI
  ENDI
  EXIT
 ENDD
ENDI
PTAB(CODIGO,'GRUPOS',1)
PTAB(COBRADOR,'COBRADOR',1)
IF tp_mov=EXCLUI .OR. tp_mov=FORM_INVERSA
 IF !EMPTY(ALIAS())
  DELE
 ENDI
ELSEIF tp_mov=INCLUI .OR. tp_mov=RECUPERA .OR. tp_mov=FORM_DIRETA
 IF (op_menu=INCLUSAO .AND. LASTKEY()!=K_ESC) .OR. op_menu!=INCLUSAO
   IF EMPT(data_)
    IF op_menu=INCLUSAO
     data_=DATE()
    ELSE
     REPL data_ WITH DATE()
    ENDI
   ENDI
   IF EMPT(por)
    IF op_menu=INCLUSAO
     por=M->usuario
    ELSE
     REPL por WITH M->usuario
    ENDI
   ENDI
   IF op_menu=INCLUSAO
    filial=M->p_filial
   ELSE
    REPL filial WITH M->p_filial
   ENDI

  #ifdef COM_REDE
   REPBLO('GRUPOS->endereco',{||endereco})
   REPBLO('GRUPOS->bairro',{||bairro})
   REPBLO('GRUPOS->cidade',{||cidade})
   REPBLO('GRUPOS->uf',{||uf})
   REPBLO('GRUPOS->telefone',{||telefone})
   REPBLO('GRUPOS->cep',{||cep})
   REPBLO('GRUPOS->cobrador',{||cobrador})
  #else
   IF EMPT(data_)
    IF op_menu=INCLUSAO
     data_=DATE()
    ELSE
     REPL data_ WITH DATE()
    ENDI
   ENDI
   IF EMPT(por)
    IF op_menu=INCLUSAO
     por=M->usuario
    ELSE
     REPL por WITH M->usuario
    ENDI
   ENDI
   IF op_menu=INCLUSAO
    filial=M->p_filial
   ELSE
    REPL filial WITH M->p_filial
   ENDI
   REPL GRUPOS->endereco WITH endereco
   REPL GRUPOS->bairro WITH bairro
   REPL GRUPOS->cidade WITH cidade
   REPL GRUPOS->uf WITH uf
   REPL GRUPOS->telefone WITH telefone
   REPL GRUPOS->cep WITH cep
   REPL GRUPOS->cobrador WITH cobrador
  #endi

  IF op_menu!=INCLUSAO
   RECA
  ENDI
 ENDI
ENDI
RETU

* \\ Final de ALENDER.PRG
procedure obxec
/*
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
 \ Empresa.: PresServ Inform tica - Limeira (019)452.6623
 \ Programa: OBXEC.PRG
 \ Data....: 29-01-04
 \ Sistema.: Administradora - RECEP€„O
 \ Funcao..: Gerenciador do subsistema de outros recebimentos
 \ Analista: Ademilson Pedro Bom
 \ Criacao.: GAS-Pro v4.0o
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/

#include "adrbig.ch"    // inicializa constantes manifestas

PARA lin_menu,col_menu
PRIV op_sis, tela_fundo:=SAVESCREEN(0,0,MAXROW(),79), l_s, c_s, l_i, c_i, l_a
PRIV OBS2PRINT
op_sis=EVAL(qualsis,"OBXEC")
IF nivelop<sistema[op_sis,O_OUTROS,O_NIVEL]        // se usuario nao tem permissao,
 ALERTA()                                          // entao, beep, beep, beep
 DBOX(msg_auto,,,3)                                // lamentamos e
 RETU                                              // retornamos ao menu
ENDI
cn:=fgrep :=.f.

#ifdef COM_LOCK
 IF LEN(pr_ok)>0                                   // se a protecao acusou
  ? pr_ok                                          // erro, avisa e
  QUIT                                             // encerra a aplicacao
 ENDI
#endi

t_fundo=SAVESCREEN(0,0,MAXROW(),79)                // salva tela do fundo
op_cad=1
DO WHIL op_cad!=0
 criterio=""
 RESTSCREEN(0,0,MAXROW(),79,t_fundo)               // restaura tela do fundo
 cod_sos=5 ; cn=.f.
 CLEA TYPEAHEAD                                    // limpa o buffer do teclado
 fgrep=.f.
 SET KEY K_F3 TO                                   // retira das teclas F3 e F4 as
 SET KEY K_F4 TO                                   // funcoes de repeticao e confirmacao
 msg="Inclus„o~1|"+;
     "Manuten‡„o~2|"+;
     "Consulta~3"
 op_cad=DBOX(msg,lin_menu,col_menu,E_MENU,NAO_APAGA,MAIUSC(sistema[op_sis,O_MENU]),,,op_cad)
 IF op_cad!=0                                      // se escolheu uma opcao
  Tela_fundo=SAVESCREEN(0,0,MAXROW(),79)           // salva a tela para ROLATELA()
  PARAMETROS(dbfparam)
  SELE A                                           // e abre o arquivo e seus indices

  #ifdef COM_REDE
   IF !USEARQ(sistema[op_sis,O_ARQUI,O_NOME],.f.,20,1)
                                                   // se falhou a abertura do
    RETU                                           // arquivo volta ao menu anterior
   ENDI
  #else
   USEARQ(sistema[op_sis,O_ARQUI,O_NOME])
  #endi

  SET KEY K_F9 TO veoutros                         // habilita consulta em outros arquivos
  SET KEY K_F2 TO veinscrits()                         // habilita consulta em outros arquivos
 ENDI
 DO CASE
  CASE op_cad=01                                   // inclus„o
   op_menu=INCLUSAO
   IF AT("D",exrot[op_sis])=0                      // se usuario pode fazer inclusao
    OBX_INCL()                                     // neste arquivo chama prg de inclusao
   ELSE                                            // caso contrario vamos avisar que
    ALERTA()                                       // ele nao tem permissao para isto
    DBOX(msg_auto,,,3)
   ENDI

  CASE op_cad=02                                   // manuten‡„o
   op_menu=ALTERACAO
   cod_sos=7
   EDIT()

  CASE op_cad=03                                   // consulta
   op_menu=PROJECOES
   cod_sos=8
   EDITA(03,03,22,77)

 ENDC
 SET KEY K_F9 TO                                   // F9 nao mais consultara outros arquivos
 CLOS ALL                                          // fecha todos arquivos abertos
ENDD
RETU

PROC OBX_incl(reg_cop)  // inclusao no arquivo OBXEC
LOCAL getlist:={},cabem:=1,rep:=ARRAY(FCOU()),ult_reg:=RECN(),cond_incl_,dbfseq_,;
      ctl_r, ctl_c, ctl_w, t_f3_, t_f4_, dele_atu:=SET(_SET_DELETED,.f.)
PRIV op_menu:=INCLUSAO, sq_atual_, tem_borda, criterio:="", cpord:=""
cond_incl_={||nivelop>1}                           // condicao de inclusao de registros
IF !EVAL(cond_incl_)                               // se nao pode incluir
 ALERTA(2)                                         // avisa o motivo
 DBOX("Permitido apenas a usu rios cadastrados|com n¡vel de Manuten‡„o ou Maior",,,4,,"ATEN€ŽO, "+usuario)
 RETU                                              // e retorna
ENDI
FOR i=1 TO FCOU()                                  // cria/declara privadas as
 msg=FIEL(i)                                       // variaveis de memoria com
 PRIV &msg.                                        // o mesmo nome dos campos
NEXT                                               // do arquivo
IF reg_cop!=NIL                                    // quer repetir todo o reg atual
 FOR i=1 TO FCOU()                                 // para cada campo,
  msg=FIEL(i)                                      // salva o conteudo
  rep[i]=&msg.                                     // para repetir
 NEXT
ELSE
 AFILL(rep,"")                                     // eche com valor vazio
ENDI
t_f3_=SETKEY(K_F3,{||rep()})                       // repeticao reg anterior
t_f4_=SETKEY(K_F4,{||conf()})                      // confirma campos com ENTER
ctl_w=SETKEY(K_CTRL_W,{||nadafaz()})               // enganando o CA-Clipper...
ctl_c=SETKEY(K_CTRL_C,{||nadafaz()})
ctl_r=SETKEY(K_CTRL_R,{||nadafaz()})

#ifdef COM_REDE
 OBX_CRIA_SEQ()                                    // cria dbf de controle de cp sequenciais
 FOR i=1 TO FCOU()                                 // cria/declara privadas as
  msg="sq_"+FIEL(i)                                // variaveis de memoria com
  PRIV &msg.                                       // o mesmo nome dos campos
 NEXT                                              // do arquivo com extensao _seq
#endi

DO WHIL cabem>0
 cod_sos=6
 rola_t=.f.                                        // flag se quer rolar a tela
 SELE OBXEC
 GO BOTT                                           // forca o
 SKIP                                              // final do arquivo
 
 /*
    cria variaveis de memoria identicas as de arquivo, para inclusao
    de registros
 */
 FOR i=1 TO FCOU()
  msg=FIEL(i)
  M->&msg.=IF((fgrep .OR. reg_cop!=NIL).AND.!EMPT(rep[1]),rep[i],&msg.)
 NEXT
 DISPBEGIN()                                       // apresenta a tela de uma vez so
 OBX_TELA()
 INFOSIS(.t.)                                      // exibe informacao no rodape' da tela
 DISPEND()
 OBX_GERA_SEQ()
 IF !EVAL(cond_incl_)
  EXIT
 ENDI
 cabem=DISKSPACE(;
          IF(;
             LEN(sistema[op_sis,O_ARQUI,O_DIR_DBF])<2.OR.sistema[op_sis,O_ARQUI,O_DIR_DBF]="\",;
             0,;
             ASC(sistema[op_sis,O_ARQUI,O_DIR_DBF])-64;
          );
       )
 cabem=INT((cabem-2048)/OBXEC->(RECSIZE()))
 IF cabem<1                                        // mais nenhum!!!
  ALERTA()
  msg="Verifique ESPA€O EM DISCO, "+usuario
  DBOX(msg,,,,,"INCLUSŽO INTERROMPIDA!")           // vamos parar por aqui!
  EXIT
 ENDI
 SELE 0                                            // torna visiveis variaveis de memoria
 OBX_GET1(INCLUI)                                  // recebe campos
 SELE OBXEC
 IF LASTKEY()=K_ESC                                // se cancelou
  cabem=0                                          // prepara saida da inclusao
  LOOP
 ENDI

 #ifdef COM_REDE
  GO BOTT                                          // vamos bloquear o final do
  SKIP                                             // arq para que nehum outro
  BLOREG(0,.5)                                     // usuario possa incluir
 #endi

 APPEND BLANK                                      // inclui reg em branco no dbf
 FOR i=1 TO FCOU()                                 // para cada campo,
  msg=FIEL(i)                                      // salva o conteudo
  rep[i]=M->&msg.                                  // para repetir
  REPL &msg. WITH rep[i]                           // enche o campo do arquivo
 NEXT

 #ifdef COM_REDE
  UNLOCK                                           // libera o registro e
  COMMIT                                           // forca gravacao
 #else
  IF RECC()-INT(RECC()/20)*20=0                    // a cada 20 registros
   COMMIT                                          // digitados forca gravacao
  ENDI
 #endi

 ult_reg=RECN()                                    // ultimo registro digitado
 OBX_REL(ult_reg)                               // imprime relat apos inclusao
 IF reg_cop!=NIL                                   // estava na consulta e quis rep o campo
  sq_atual_=NIL
  EXIT                                             // cai fora...
 ENDI
ENDD

#ifdef COM_REDE
 OBX_ANT_SEQ()                                     // restaura sequencial anterior
 SELE OBXEC
#endi

GO ult_reg                                         // para o ultimo reg digitado
SETKEY(K_F3,t_f3_)                                 // restaura teclas de funcoes
SETKEY(K_F4,t_f4_)
SET(_SET_DELETED,dele_atu)                            // ecluidos visiveis/invisiveis
SETKEY(K_CTRL_W,ctl_w)
SETKEY(K_CTRL_C,ctl_c)
SETKEY(K_CTRL_R,ctl_r)
RETU


PROC OBX_REL(ult_reg)  // imprime relatorio apos inclusao
LOCAL p_imp:=.t., i_ok:=.f., imp_rel:=.f.
DO WHIL .t.
 SAVE SCREEN                     // salva a tela

 #ifdef COM_REDE
  tps=TP_SAIDA(,,.t.)
  IF LASTKEY()=K_ESC
   EXIT
  ENDI
  i_ok=(tps=2 .OR. PREPIMP("OUTROS RECIBOS (2¦VIA)"))
  IF i_ok
   ADM_R023(tps,0,ult_reg,OBS2PRINT)
   imp_rel=.t.
  ENDI
 #else
  i_ok=PREPIMP("OUTROS RECIBOS (2¦VIA)")
  IF i_ok
   ADM_R023(0,0,ult_reg,OBS2PRINT)
   imp_rel=.t.
  ENDI
 #endi

 REST SCREEN                    // restaura tela
 IF imp_rel                     // imprimiu algo?
  msg="Prosseguir|Outra c¢pia"
  op_=1 //DBOX(msg,,,E_MENU,,"FIM DE IMPRESSŽO") // quer emitir outra copia?
  IF op_=2
   LOOP                         // nao quer...
  ENDI
 ENDI
 EXIT
ENDD
RETU


#ifdef COM_REDE
 PROC OBX_ANT_SEQ(est_seq)     // restaura sequencial anterior
 SELE OBX_SEQ     // seleciona arquivo de controle de sequencial
 BLOARQ(0,.5)     // esta estacao foi a ultima a incluir?
 IF sq_atual_ == numero
  REPL numero WITH sq_numero
  REPL intlan WITH sq_intlan
 ENDI
 UNLOCK           // libera DBF para outros usuarios
 COMMIT           // atualiza cps sequenciais no disco
 RETU
#endi


PROC OBX_CRIA_SEQ   // cria dbf de controle de campos sequenciais
LOCAL dbfseq_:=sistema[op_sis,O_ARQUI,O_DIR_DBF]+"OBX_seq" // arq temporario
SELE 0                          // seleciona area vazia
IF !FILE(dbfseq_+".dbf")        // se o dbf nao existe
 DBCREATE(dbfseq_,{;            // vamos criar a sua estrutura
                    {"numero"    ,"C",  8, 0},;
                    {"intlan"    ,"C",  8, 0};
                  };
 )
ENDI
USEARQ(dbfseq_,.f.,,,.f.)       // abre arquivo de cps sequencial
IF RECC()=0                     // se o dbf foi criado agora
 BLOARQ(0,.5)                   // inclui um registro que tera
 APPEND BLANK                   // os ultomos cps sequenciais
 SELE OBXEC
 IF RECC()>0                    // se o DBF nao estiver
  SET ORDER TO 0                // vazio, entao enche DBF seq
  GO BOTT                       // com o ultimo reg digitado
  REPL OBX_SEQ->numero WITH numero
  REPL OBX_SEQ->intlan WITH intlan
  DBSETORDER(1)                 // retorna ao indice principal
 ENDI
 SELE OBX_SEQ                   // seleciona arq de sequencias
 UNLOCK                         // libera DBF para outros usuarios
 COMMIT                         // atualiza cps sequenciais no disco
ENDI
RETURN

PROC OBX_GERA_SEQ()

#ifdef COM_REDE
 LOCAL ar_:=SELEC()
#else
 LOCAL reg_:=RECNO(),ord_ind:=INDEXORD()
#endi


#ifdef COM_REDE
 SELE OBX_SEQ
 BLOARQ(0,.5)
 sq_numero=OBX_SEQ->numero
 sq_intlan=OBX_SEQ->intlan
#else
 DBSETORDER(0)
 GO BOTT
#endi

M->numero=LPAD(STR(VAL(numero)+1),08,[0])
IF VAL(M->numero)=1
 M->numero=LPAD(RIGHT(DTOC(DATE()),2)+[000001],08,[0])
ENDI
M->intlan=LPAD(STR(VAL(intlan)+1),08,[0])

#ifdef COM_REDE
 OBX_GRAVA_SEQ()
 sq_atual_=OBX_SEQ->numero
 UNLOCK                                            // libera o registro
 COMMIT
 SELE (ar_)
#else
 DBSETORDER(ord_ind)
 GO reg_
#endi

RETU

PROC OBX_GRAVA_SEQ
REPL numero WITH M->numero
REPL intlan WITH M->intlan
RETU

PROC OBX_tela     // tela do arquivo OBXEC
tem_borda=.t.
l_s=Sistema[op_sis,O_TELA,O_LS]           // coordenadas da tela
c_s=Sistema[op_sis,O_TELA,O_CS]
l_i=Sistema[op_sis,O_TELA,O_LI]
c_i=Sistema[op_sis,O_TELA,O_CI]
OBS2PRINT:=[Observacao apenas para impressao                           ]
SETCOLOR(drvtittel)
vr_memo=NOVAPOSI(@l_s,@c_s,@l_i,@c_i)     // pega posicao atual da tela
CAIXA(mold,l_s,c_s,l_i,c_i)               // monta caixa da tela
i=LEN(sistema[op_sis,O_MENS])/2
@ l_s,c_s-1+(c_i-c_s+1)/2-i SAY " "+MAIUSC(sistema[op_sis,O_MENS])+" "
SETCOLOR(drvcortel)
@ l_s+01,c_s+1 SAY " Numero:"
@ l_s+02,c_s+1 SAY " Contrato:"
@ l_s+03,c_s+1 SAY "ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ"
@ l_s+04,c_s+1 SAY "                                      ³Circulares"
@ l_s+05,c_s+1 SAY "                                      ³ Ini"
@ l_s+06,c_s+1 SAY "                            Reg.:     ³  £lt"
@ l_s+07,c_s+1 SAY "                                      ³"
@ l_s+08,c_s+1 SAY " Admiss„o:            Sai Taxa:       ³"
@ l_s+09,c_s+1 SAY " Funerais:            Cobrador:       ³"
@ l_s+10,c_s+1 SAY "ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ"
@ l_s+15,c_s+1 SAY "ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ"
@ l_s+16,c_s+1 SAY " Ref.:                       Vl.Pago:"
@ l_s+17,c_s+1 SAY " Pago com..:             Troco:"
@ l_s+18,c_s+1 SAY " OBS.:"
@ l_s+19,c_s+1 SAY "  emitida em             por"
RETU

PROC OBX_gets     // mostra variaveis do arquivo OBXEC
LOCAL getlist := {}, ord_, chv_, ar_get1:=ALIAS(), op_ant := op_menu
OBX_TELA()
SETCOLOR(drvcortel+","+drvcorget+",,,"+corcampo)
PTAB(CODIGO,[GRUPOS])
PTAB(IIF(EMPT(M->USUARIO),PADR(M->CONTAREC+IDE_MAQ,10,' '),PADR(M->USUARIO,10,' '))+M->HISTRCREC+[       ],'ORDPGRC',2)
PTAB(PADR(SUBSTR(M->IDE_MAQ,2),4)+[OBX],[IMPPAR],1)
CRIT("",,"16")
@ l_s+01 ,c_s+12 GET  numero;
		 PICT sistema[op_sis,O_CAMPO,01,O_MASC]

@ l_s+02 ,c_s+12 GET  codigo;
		 PICT sistema[op_sis,O_CAMPO,02,O_MASC]
		 CRIT(sistema[op_sis,O_CAMPO,02,O_CRIT],,"1|2|3|4|5|6|7|8|9|10|11|12|13|14")

@ l_s+16 ,c_s+08 GET  cobranca;
                 PICT sistema[op_sis,O_CAMPO,03,O_MASC]

@ l_s+16 ,c_s+39 GET  valorpg;
                 PICT sistema[op_sis,O_CAMPO,04,O_MASC]

@ l_s+17 ,c_s+14 GET  valoraux;
                 PICT sistema[op_sis,O_CAMPO,05,O_MASC]
                 CRIT(sistema[op_sis,O_CAMPO,05,O_CRIT],,"15")

@ l_s+18 ,c_s+08 GET  obs2print;
                 PICT "@!S40"

@ l_s+19 ,c_s+14 GET  emitido_;
                 PICT sistema[op_sis,O_CAMPO,06,O_MASC]

@ l_s+19 ,c_s+30 GET  por

@ l_s+19 ,c_s+44 GET  numop;
                 PICT sistema[op_sis,O_CAMPO,08,O_MASC]

CRIT("",,"1|3|4|5|6|7|8|9|10|11|12|13|14")
CLEAR GETS
RETU

PROC OBX_get1(tp_mov)     // capta variaveis do arquivo OBXEC
LOCAL getlist := {}, ord_, chv_, ar_get1:=ALIAS(), op_ant := op_menu
PRIV  blk_obxec:=.t.

IF tp_mov=INCLUI
 DO WHILE .t.
  rola_t=.f.
  SET KEY K_ALT_F8 TO ROLATELA
  SETCOLOR(drvcortel+","+drvcorget+",,,"+corcampo)
  @ l_s+01 ,c_s+12 GET numero;
                   PICT sistema[op_sis,O_CAMPO,01,O_MASC]
  @ l_s+19 ,c_s+14 GET emitido_;
		   PICT sistema[op_sis,O_CAMPO,06,O_MASC]
  @ l_s+19 ,c_s+30 GET por
  @ l_s+19 ,c_s+44 GET numop;
                   PICT sistema[op_sis,O_CAMPO,08,O_MASC]
  CLEA GETS
  CRIT("",,"16")
  @ l_s+02 ,c_s+12 GET  codigo;
		   PICT sistema[op_sis,O_CAMPO,02,O_MASC]
		   DEFINICAO 2
		   MOSTRA sistema[op_sis,O_FORMULA,1]
                   MOSTRA sistema[op_sis,O_FORMULA,2]
                   MOSTRA sistema[op_sis,O_FORMULA,3]
                   MOSTRA sistema[op_sis,O_FORMULA,4]
                   MOSTRA sistema[op_sis,O_FORMULA,5]
                   MOSTRA sistema[op_sis,O_FORMULA,6]
                   MOSTRA sistema[op_sis,O_FORMULA,7]
                   MOSTRA sistema[op_sis,O_FORMULA,8]
                   MOSTRA sistema[op_sis,O_FORMULA,9]
                   MOSTRA sistema[op_sis,O_FORMULA,10]
                   MOSTRA sistema[op_sis,O_FORMULA,11]
		   MOSTRA sistema[op_sis,O_FORMULA,12]
                   MOSTRA sistema[op_sis,O_FORMULA,13]
                   MOSTRA sistema[op_sis,O_FORMULA,14]

  @ l_s+16 ,c_s+08 GET  cobranca;
                   PICT sistema[op_sis,O_CAMPO,03,O_MASC]
                   DEFINICAO 3

  @ l_s+16 ,c_s+39 GET  valorpg;
		   PICT sistema[op_sis,O_CAMPO,04,O_MASC]
                   DEFINICAO 4

  @ l_s+17 ,c_s+14 GET  valoraux;
                   PICT sistema[op_sis,O_CAMPO,05,O_MASC]
                   DEFINICAO 5
                   MOSTRA sistema[op_sis,O_FORMULA,15]


  @ l_s+18 ,c_s+08 GET  obs2print;
                   PICT "@K!S40"

  READ
  SET KEY K_ALT_F8 TO
  IF rola_t
   ROLATELA()
   LOOP
  ENDI
  IF LASTKEY()!=K_ESC .AND. drvincl .AND. op_menu=INCLUSAO
   IF !CONFINCL()
    LOOP
   ENDI
  ENDI
  EXIT
 ENDD
ENDI
PTAB(CODIGO,[GRUPOS])
PTAB(CODIGO,'TAXAS',1)
PTAB(IIF(EMPT(M->USUARIO),PADR(M->CONTAREC+IDE_MAQ,10,' '),PADR(M->USUARIO,10,' '))+M->HISTRCREC+[       ],'ORDPGRC',2)
PTAB(PADR(SUBSTR(M->IDE_MAQ,2),4)+[OBX],[IMPPAR],1)
IF tp_mov=EXCLUI .OR. tp_mov=FORM_INVERSA

 #ifdef COM_REDE
  IF EMPT(numop)
   IF !EMPTY(ALIAS())
    REPL numop WITH ORDPGRC->numop
   ENDI
  ENDI
  IF PTAB(numop,'ORDPGRC',1)
   REPBLO('ORDPGRC->nrdoctos',{||ORDPGRC->nrdoctos - 1})
  ENDI
  IF EMPT(numop).AND.PTAB(IIF(EMPT(M->usuario),PADR(M->contarec+ide_maq,10,' '),PADR(M->usuario,10,' '))+M->histrcrec+[       ],'ORDPGRC',2)
   REPBLO('ORDPGRC->valortotal',{||ORDPGRC->valortotal-valorpg})
  ENDI
  IF !EMPT(numop).AND.PTAB(numop,'ORDPGRC',1)
   REPBLO('ORDPGRC->valortotal',{||ORDPGRC->valortotal -valorpg})
  ENDI
 #else
  IF EMPT(numop)
   IF !EMPTY(ALIAS())
    REPL numop WITH ORDPGRC->numop
   ENDI
  ENDI
  IF PTAB(numop,'ORDPGRC',1)
   REPL ORDPGRC->nrdoctos WITH ORDPGRC->nrdoctos - 1
  ENDI
  IF EMPT(numop).AND.PTAB(IIF(EMPT(M->usuario),PADR(M->contarec+ide_maq,10,' '),PADR(M->usuario,10,' '))+M->histrcrec+[       ],'ORDPGRC',2)
   REPL ORDPGRC->valortotal WITH ORDPGRC->valortotal-valorpg
  ENDI
  IF !EMPT(numop).AND.PTAB(numop,'ORDPGRC',1)
   REPL ORDPGRC->valortotal WITH ORDPGRC->valortotal -valorpg
  ENDI
 #endi

 IF 1=3
  IF !EMPTY(ORDPGRC->codlan)
   TIRA_LANC("ORDPGRC",LEFT(ORDPGRC->codlan,16),.f.)
  ENDI
 ENDI
 IF 1=3
  IF !EMPTY(IMPPAR->codlan)
   TIRA_LANC("IMPPAR",LEFT(IMPPAR->codlan,16))
  ENDI
 ENDI
 IF !EMPTY(ALIAS())
  DELE
 ENDI
ELSEIF tp_mov=INCLUI .OR. tp_mov=RECUPERA .OR. tp_mov=FORM_DIRETA
 IF (op_menu=INCLUSAO .AND. LASTKEY()!=K_ESC) .OR. op_menu!=INCLUSAO
  IF !EMPT(valorpg).AND. !PTAB(IIF(EMPT(M->usuario),PADR(M->contarec+ide_maq,10,' '),PADR(M->usuario,10,' '))+M->histrcrec+[       ],'ORDPGRC',2)
   ord_=LEN(sistema[EVAL(qualsis,"ORDPGRC"),O_CHAVE])
   IF !EMPTY(ORDPGRC->codlan)
    chv_=LEFT(ORDPGRC->codlan,16)
   ELSE
    IF TYPE("M->intlan")="C" .AND. EMPTY(intlan)
     chv_="OBX-"+M->intlan+"-001"
    ELSE
     chv_="OBX-"+intlan+"-001"
    ENDI
   ENDI
   PTAB(chv_,"ORDPGRC",ord_)
   FAZ_LANC("ORDPGRC",chv_,.t.)
   REPL ORDPGRC->origem WITH [ADM],;
        ORDPGRC->lancto_ WITH DATE(),;
        ORDPGRC->por WITH M->usuario,;
	ORDPGRC->numconta WITH IIF(EMPT(M->usuario),PADR(M->contarec+ide_maq,10,' '),PADR(M->usuario,10,' ')),;
        ORDPGRC->historico WITH M->histrcrec,;
        ORDPGRC->debcred WITH [C],;
        ORDPGRC->valortotal WITH 0,;
        ORDPGRC->vencto_ WITH DATE(),;
        ORDPGRC->documento WITH [FCC/Taxas],;
        ORDPGRC->complement WITH [FCC/Outros recebimentos]

   #ifdef COM_REDE
    ORDPGRC->(DBUNLOCK())                          // libera o registro
   #endi

  ENDI
  IF !PTAB(PADR(SUBSTR(M->ide_maq,2),4)+[OBX],[IMPPAR],1)
   ord_=LEN(sistema[EVAL(qualsis,"IMPPAR"),O_CHAVE])
   IF !EMPTY(IMPPAR->codlan)
    chv_=LEFT(IMPPAR->codlan,16)
   ELSE
    IF TYPE("M->intlan")="C" .AND. EMPTY(intlan)
     chv_="OBX-"+M->intlan+"-002"
    ELSE
     chv_="OBX-"+intlan+"-002"
    ENDI
   ENDI
   PTAB(chv_,"IMPPAR",ord_)
   FAZ_LANC("IMPPAR",chv_)
   REPL IMPPAR->idmaq WITH PADR(SUBSTR(M->ide_maq,2),4),;
        IMPPAR->base WITH [OBX]

   #ifdef COM_REDE
    IMPPAR->(DBUNLOCK())                           // libera o registro
   #endi

  ENDI
   IF EMPT(numop)
    IF op_menu=INCLUSAO
     numop=ORDPGRC->numop
    ELSE
     REPL numop WITH ORDPGRC->numop
    ENDI
   ENDI

  #ifdef COM_REDE
   IF PTAB(numop,'ORDPGRC',1)
    REPBLO('ORDPGRC->nrdoctos',{||ORDPGRC->nrdoctos + 1})
   ENDI
   IF op_menu=INCLUSAO
    emitido_=DATE()
   ELSE
    REPL emitido_ WITH DATE()
   ENDI
   IF op_menu=INCLUSAO
    por=M->usuario
   ELSE
    REPL por WITH M->usuario
   ENDI
   IF op_menu=INCLUSAO
    filial=M->p_filial
   ELSE
    REPL filial WITH M->p_filial
   ENDI
   IF EMPT(numop).AND.PTAB(IIF(EMPT(M->usuario),PADR(M->contarec+ide_maq,10,' '),PADR(M->usuario,10,' '))+M->histrcrec+[       ],'ORDPGRC',2)
    REPBLO('ORDPGRC->valortotal',{||ORDPGRC->valortotal+valorpg})
   ENDI
   IF !EMPT(numop).AND.PTAB(numop,'ORDPGRC',1)
    REPBLO('ORDPGRC->valortotal',{||ORDPGRC->valortotal +valorpg})
   ENDI
   IF PTAB(PADR(SUBSTR(M->ide_maq,2),4)+[OBX],[IMPPAR],1)
    REPBLO('IMPPAR->docto',{||numero})
   ENDI
  #else
   IF EMPT(numop)
    IF op_menu=INCLUSAO
     numop=ORDPGRC->numop
    ELSE
     REPL numop WITH ORDPGRC->numop
    ENDI
   ENDI
   IF PTAB(numop,'ORDPGRC',1)
    REPL ORDPGRC->nrdoctos WITH ORDPGRC->nrdoctos + 1
   ENDI
   IF op_menu=INCLUSAO
    emitido_=DATE()
   ELSE
    REPL emitido_ WITH DATE()
   ENDI
   IF op_menu=INCLUSAO
    por=M->usuario
   ELSE
    REPL por WITH M->usuario
   ENDI
   IF op_menu=INCLUSAO
    filial=M->p_filial
   ELSE
    REPL filial WITH M->p_filial
   ENDI
   IF EMPT(numop).AND.PTAB(IIF(EMPT(M->usuario),PADR(M->contarec+ide_maq,10,' '),PADR(M->usuario,10,' '))+M->histrcrec+[       ],'ORDPGRC',2)
    REPL ORDPGRC->valortotal WITH ORDPGRC->valortotal+valorpg
   ENDI
   IF !EMPT(numop).AND.PTAB(numop,'ORDPGRC',1)
    REPL ORDPGRC->valortotal WITH ORDPGRC->valortotal +valorpg
   ENDI
   IF PTAB(PADR(SUBSTR(M->ide_maq,2),4)+[OBX],[IMPPAR],1)
    REPL IMPPAR->docto WITH numero
   ENDI
  #endi

  IF op_menu!=INCLUSAO
   RECA
  ENDI
 ENDI
ENDI
RETU

* \\ Final de OBXEC.PRG
procedure adc_rx76
/*
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
 \ Empresa.: PresServ Inform tica - Limeira (019)452.6623
 \ Programa: ADC_RX76.PRG
 \ Data....: 14-09-98
 \ Sistema.: Administradora - PLANO
 \ Funcao..: Ficha de Acerto
 \ Analista: Ademilson Pedro Bom
 \ Criacao.: GAS-Pro v3.0
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/

#include "adrbig.ch"    // inicializa constantes manifestas

LOCAL dele_atu, getlist:={}, so_um_reg, sit_dbf:=POINTER_DBF()
PARA  lin_menu, col_menu, imp_reg
PRIV  tem_borda:=.t., op_menu:=VAR_COMPL, l_s:=10, c_s:=15, l_i:=18, c_i:=65, tela_fundo:=SAVESCREEN(0,0,MAXROW(),79)
nucop=1
so_um_reg=(PCOU()>2)
IF !so_um_reg                             // vai receber a variaveis?
 SETCOLOR(drvtittel)
 vr_memo=NOVAPOSI(@l_s,@c_s,@l_i,@c_i)     // pega posicao atual da tela
 CAIXA(mold,l_s,c_s,l_i,c_i)               // monta caixa da tela
 @ l_s,c_s+14 SAY " CONTRATOS & COBRAN€AS "
 SETCOLOR(drvcortel)
 @ l_s+01,c_s+1 SAY " Situacao....:"
 @ l_s+02,c_s+1 SAY " Contratos de:                  at‚:"
 @ l_s+03,c_s+1 SAY " Vencimentos de:                at‚:"
 @ l_s+04,c_s+1 SAY " Imprimir as cobran‡as j  pagas?"
 @ l_s+05,c_s+1 SAY " Imprimir as cobran‡as vencidas?"
 @ l_s+06,c_s+1 SAY " M¡nimo de pendentes a listar..:"
 @ l_s+07,c_s+1 SAY "                     Confirme?"
ENDI
cods=[0123456789]
codi=SPAC(9)                                       // Codigo
codf=SPAC(9)                                       // Codigo
veni_=CTOD('')                                     // Venc.Inicial
venf_=DATE() //CTOD('')                                     // Venc.Final
pag=[S] //SPAC(1)                                        // Pagas?
pend=[S] //SPAC(1)                                       // Pendentes?
rpend=0                                            // Nrpend
confirme=[S] //SPAC(1)                                   // Confirme
DO WHILE .t.
 rola_t=.f.
 cod_sos=56
 IF !so_um_reg
  SET KEY K_ALT_F8 TO ROLATELA
  SETCOLOR(drvcortel+","+drvcorget+",,,"+corcampo)
/*
  @ l_s+01 ,c_s+22 GET  cods;
									PICT "9"
*/
  @ l_s+02 ,c_s+22 GET  codi;
									PICT "999999999";
									VALI CRIT("PTAB(codi,'GRUPOS',1).OR.VAL(codi)=0~Necess rio informar CODIGO existente")
									AJUDA "Informe o n£mero do contrato"
									CMDF8 "VDBF(6,26,20,77,'GRUPOS',{'grupo','codigo','nome'},1,'codigo')"
/*
 @ l_s+02 ,c_s+41 GET  codf;
									PICT "999999";
									VALI CRIT("(PTAB(codf,'GRUPOS',1).AND.codf>=codi).OR.VAL(codf)=0~Necess rio informar CODIGO existente")
									AJUDA "Informe o n£mero do contrato"
									CMDF8 "VDBF(6,26,20,77,'GRUPOS',{'grupo','codigo','nome'},1,'codigo')"

 @ l_s+03 ,c_s+21 GET  veni_;
									PICT "@D"
									AJUDA "Informe o primeiro vencimento a considerar"

 @ l_s+03 ,c_s+40 GET  venf_;
									PICT "@D"
									AJUDA "Informe o £ltimo vencimento a considerar"

 @ l_s+04 ,c_s+34 GET  pag;
									PICT "!";
									VALI CRIT("pag$([SN])~PAGAS? n„o aceit vel|Digite S ou N")
									DEFAULT "[N]"
									AJUDA "Digite S para listar as cobran‡as pagas."

 @ l_s+05 ,c_s+34 GET  pend;
									PICT "!";
									VALI CRIT("pend$([SN])~PENDENTES? n„o aceit vel|Digite S ou N")
									DEFAULT "[S]"
									AJUDA "Digite S para listar as cobran‡as pendentes"

 @ l_s+06 ,c_s+34 GET  rpend;
									PICT "99";
									VALI CRIT("rpend>0~NRPEND n„o aceit vel")
									DEFAULT "3"
									AJUDA "Informe o n£mero m¡nimo de taxas|pendentes para listar"

 @ l_s+07 ,c_s+32 GET  confirme;
                  PICT "!";
                  VALI CRIT("confirme='S'~CONFIRME n„o aceit vel")
                  AJUDA "Digite S para confirmar|ou|tecle ESC para cancelar"
*/
  READ
  SET KEY K_ALT_F8 TO
  IF rola_t
   ROLATELA(.f.)
   LOOP
  ENDI
  IF LASTKEY()=K_ESC                                // se quer cancelar
   RETU                                             // retorna
  ENDI
 ENDI

 #ifdef COM_REDE
  CLOSE GRUPOS
  IF !USEARQ("GRUPOS",.f.,10,1)                    // se falhou a abertura do arq
	 RETU                                            // volta ao menu anterior
	ENDI
 #else
  USEARQ("GRUPOS")                                 // abre o dbf e seus indices
 #endi

 PTAB(codigo,"ECOB",1,.t.)                         // abre arquivo p/ o relacionamento
 SET RELA TO codigo INTO ECOB                      // relacionamento dos arquivos
 titrel:=criterio:=cpord := ""                     // inicializa variaveis
 titrel:=chv_rela:=chv_1:=chv_2 := ""
 tps:=op_x:=ccop := 1
 arq_=drvporta                                     // porta de saida configurada
 IF !so_um_reg
  IF !opcoes_rel(lin_menu,col_menu,52,11)           // nao quis configurar...
   CLOS ALL                                         // fecha arquivos e
   LOOP                                             // volta ao menu
  ENDI

 #ifdef COM_REDE

  ELSE

   tps=lin_menu

 #endi

 ENDI
 IF tps=2                                          // se vai para arquivo/video
  arq_=ARQGER()                                    // entao pega nome do arquivo
  IF EMPTY(arq_)                                   // se cancelou ou nao informou
   LOOP                                            // retorna
  ENDI
 ELSE
  arq_=drvporta                                    // porta de saida configurada
 ENDI
 IF "4WIN"$UPPER(drvmarca) // nome da configuracao/marca impressora
   arq_:=drvdbf+"WIN"+ide_maq
   tps:=3                                         // se vai para arquivo/video
 ENDIF
 SET PRINTER TO (arq_)                             // redireciona saida
 EXIT
ENDD
criterio_=criterio                                 // salva criterio e ordenacao
cpord_=cpord                                       // definidos se huver
criterio=""

#ifdef COM_REDE
 IF !USEARQ("TAXAS",.f.,10,1)                      // se falhou a abertura do arq
  RETU                                             // volta ao menu anterior
 ENDI
#else
 USEARQ("TAXAS")                                   // abre o dbf e seus indices
#endi

cpord="codigo"
INDTMP()
criterio=criterio_                                 // restabelece criterio e
cpord=cpord_                                       // ordenacao definidos
codf:=codi
veni:=CTOD([01/01/1970])
#ifdef COM_REDE
 IF !USEARQ("INSCRITS",.f.,10,1)                   // se falhou a abertura do arq
	RETU                                             // volta ao menu anterior
 ENDI
#else
 USEARQ("INSCRITS")                                // abre o dbf e seus indices
#endi

cpord="codigo"
INDTMP()
criterio=criterio_                                 // restabelece criterio e
cpord=cpord_                                       // ordenacao definidos

SELE GRUPOS
DBOX("[ESC] Interrompe",15,,,NAO_APAGA)
dele_atu:=SET(_SET_DELETED,.t.)                    // os excluidos nao servem...
SET DEVI TO PRIN                                   // inicia a impressao
maxli=62                                           // maximo de linhas no relatorio
BEGIN SEQUENCE
 DO WHIL ccop<=nucop                               // imprime qde copias pedida
	pg_=1; cl=999
	IF so_um_reg
	 GO imp_reg
	ELSE
	 INI_ARQ()                                       // acha 1o. reg valido do arquivo
	ENDI
	ccop++                                           // incrementa contador de copias
	DO WHIL !EOF().AND.(!so_um_reg.OR.imp_reg=RECN())
	 #ifdef COM_TUTOR
		IF IN_KEY()=K_ESC                              // se quer cancelar
	 #else
		IF INKEY()=K_ESC                               // se quer cancelar
	 #endi
		IF canc()                                      // pede confirmacao
		 BREAK                                         // confirmou...
		ENDI
	 ENDI
   IF codigo > M->codi
    GO BOTT
    SKIP
    LOOP
   ENDI
	 IF (codigo>=M->codi.AND.(M->codf=[000000000].OR.codigo<=M->codf));
    .OR. so_um_reg                  // se atender a condicao...
    IF !(so_um_reg.OR.(GRUPOS->situacao$M->cods))
     SKIP
     LOOP
    ENDI
    PTAB(GRUPOS->tipcont,[CLASSES],1)
		REL_CAB(1)                                     // soma cl/imprime cabecalho
		 IMPCTL(drvpenf)
		@ cl,000 SAY TRAN(codigo,"999999999")            // Codigo
		@ cl,006 SAY "-"
		@ cl,007 SAY TRAN(grupo,"!!")                  // Grupo
		@ cl,010 SAY nome                              // Nome
		 IMPCTL(drvTenf)
    IF !EMPT(xDECRIPT(telefone)+contato)
		 @ cl,046 SAY LEFT(ALLTRIM(xDECRIPT(telefone))+[/]+alltrim(contato),33)// Telefone
    ENDI
		REL_CAB(2)                                     // soma cl/imprime cabecalho
		@ cl,010 SAY TRAN(xDECRIPT(endereco),"@!")               // Endere‡o
		REL_CAB(1)                                     // soma cl/imprime cabecalho
		@ cl,010 SAY TRAN(ALLTRIM(xDECRIPT(bairro))+[ ]+ALLTRIM(xDECRIPT(cidade))+[, ]+uf+[ - CEP:]+TRAN(cep,"@R 99999-999"),"@!")// Cidade
		subtt=0                                        // variavel temporaria
		@ cl,067 SAY "Vend/Reg/Cob"
		REL_CAB(1)                                     // soma cl/imprime cabecalho
		IMPAC("Admiss„o:",cl,010)
		@ cl,020 SAY TRAN(admissao,"@D")               // Admiss„o
		@ cl,032 SAY "SaiTxa:"
		@ cl,040 SAY TRAN(saitxa,"@R 99/99")           // Saitxa
		@ cl,047 SAY "Dia Pgto:"
		@ cl,057 SAY TRAN(diapgto,"99")                // Dia Pgto.
		@ cl,068 SAY vendedor+[/]+regiao+[/]+cobrador  // Vend/Cob/Reg
		REL_CAB(1)                                     // soma cl/imprime cabecalho
		@ cl,010 SAY [Cir.Inic.]+circinic+[   Ultima: ]+ultcirc+;
                 [   Quant.: ]+STR(qtcircs,3)+[   Nr.funerais: ]+str(funerais,3)
		REL_CAB(1)                                     // soma cl/imprime cabecalho
		@ cl,010 SAY [Categoria: ]+GRUPOS->tipcont+[ ]+CLASSES->descricao
		IF !ECOB->(EOF())
		 SELE ECOB
		 REL_CAB(1)                                     // soma cl/imprime cabecalho
		 IF ECOB->tipo=[T]
			@ cl,002 SAY [Endereco de trabalho]
		 ELSEIF ECOB->tipo=[R]
			@ cl,002 SAY [Endereco de residencia]
		 ELSE
			@ cl,002 SAY [Outro endereco  ]
		 ENDI
		 REL_CAB(1)                                     // soma cl/imprime cabecalho
		 @ cl,010 SAY TRAN(endereco,"@!")+[ ]+telefone  // Endere‡o
		 REL_CAB(1)                                     // soma cl/imprime cabecalho
		 @ cl,010 SAY TRAN(ALLTRIM(bairro)+[ ]+ALLTRIM(cidade)+[, ]+uf+[ - CEP:]+TRAN(cep,"@R 99999-999"),"@!")// Cidade
		 SELE GRUPOS
		ENDI
	 chv088=codigo
	 SELE INSCRITS
	 SEEK chv088
	 IF FOUND()
		 cl+=1                                         // soma contador de linha
		 @ cl,002 SAY REPL("-",77)
		 cl+=1                                         // soma contador de linha
		 IMPAC("Inscritos no contrato                      Observa‡„o",cl,002)
		 cl+=1                                         // soma contador de linha
//		 @ cl,002 SAY "=====  =================================== ========== ======================="
		DO WHIL ! EOF() .AND. chv088=codigo //LEFT(&(INDEXKEY(0)),LEN(chv088))
		 #ifdef COM_TUTOR
			IF IN_KEY()=K_ESC                            // se quer cancelar
		 #else
			IF INKEY()=K_ESC                             // se quer cancelar
		 #endi
			IF canc()                                    // pede confirmacao
			 BREAK                                       // confirmou...
			ENDI
		 ENDI
		 REL_CAB(1)                                    // soma cl/imprime cabecalho
		 DO CASE
		 CASE grau=[1]
			@ cl,002 SAY [Tit  ]                          // Inscr.
		 CASE grau=[2]
			@ cl,002 SAY [Pai  ]                          // Inscr.
		 CASE grau=[3]
			@ cl,002 SAY [Mae  ]                          // Inscr.
		 CASE grau=[4]
			@ cl,002 SAY [Sogro]                          // Inscr.
		 CASE grau=[5]
			@ cl,002 SAY [Sogra]                          // Inscr.
		 CASE grau=[6]
			@ cl,002 SAY [Espos]                          // Inscr.
		 CASE grau=[7]
			@ cl,002 SAY [Filh ]                          // Inscr.
		 CASE grau=[8]
			@ cl,002 SAY [Depen]                          // Inscr.
		 ENDC
//		 @ cl,002 SAY grau+'-'+STR(seq,2)              // Inscr.
		 @ cl,009 SAY nome                             // Nome
//		 @ cl,045 SAY TRAN(nascto_,"@D")               // Nascto
		 IF !EMPT(falecto_)
			@ cl,045 SAY [Falec. em ]+TRAN(falecto_,"@D")              // Falecto.
		  @ cl,066 SAY TRAN(tipo,"!!!")                 // Tipo
		  @ cl,070 SAY TRAN(procnr,"@R 99999/99")       // N§Processo
		 ENDI
		 SKIP                                          // pega proximo registro
		ENDD
	 ENDI
	 SELE GRUPOS                                     // volta ao arquivo pai

		tot091004 := 0                                 // inicializa variaves de totais
		chv091=codigo
		SELE TAXAS
		SEEK chv091
		vlatras:=vlemdia:=0
		IF FOUND()
		 // Corrigir o valor antes de listar
		 DO WHILE !EOF().AND.TAXAS->codigo==GRUPOS->codigo
			IF EMPT(TAXAS->valorpg)
			 IF TAXAS->emissao_< DATE()
				vlatras+=R07702F9()
			 ELSE
				vlemdia+=TAXAS->valor
			 ENDI
			ENDI

			SKIP
		 ENDD
		 // De volta ao inicio
		 SELE TAXAS
		 SEEK chv091

		 IF cl+3>maxli                                 // se cabecalho do arq filho
			REL_CAB(0)                                   // nao cabe nesta pagina
		 ENDI                                          // salta para a proxima pagina
		 cl+=2                                         // soma contador de linha
		 @ cl,002 SAY REPL("-",77)
		 cl+=1                                         // soma contador de linha
		 IMPAC("Cobran‡as do contrato ",cl,002)
		 cl+=1                                         // soma contador de linha
		 IMPAC("Circular Vencimento    Valor       Observa‡„o",cl,002)
		 IMPCTL(drvpenf)
     IF codigo>=[010600001].AND.codigo<[010800000]
      @ cl,50 SAY [*Valor em atraso: ]+TRAN(vlatras,"@E 9,999.99")   // Valor
     ELSE
      @ cl,50 SAY [*Valor do debito: ]+TRAN(vlatras+vlemdia,"@E 9,999.99")   // Valor
     ENDI
		 IMPCTL(drvtenf)
		 cl+=1                                         // soma contador de linha
//		 @ cl,002 SAY "======== ========== ========== =============================="
		 qqu091=0                                      // contador de registros
     addcl=0
		 DO WHIL ! EOF() .AND. chv091=codigo //LEFT(&(INDEXKEY(0)),LEN(chv091))
			#ifdef COM_TUTOR
			 IF IN_KEY()=K_ESC                           // se quer cancelar
			#else
			 IF INKEY()=K_ESC                            // se quer cancelar
			#endi
			 IF canc()                                   // pede confirmacao
				BREAK                                      // confirmou...
			 ENDI
			ENDI
			IF R07701F9()                                // se atender a condicao...
			 IF addcl=0
        REL_CAB(1)                                  // soma cl/imprime cabecalho
       ENDI

//			 IF R07701F9()                               // pode imprimir?
				IF TYPE("omt091001")!="C" .OR. omt091001!=tipo// imp se dif do anterior
//				 @ cl,003 SAY TRAN(tipo,"!")               // Tipo
				 omt091001=tipo                            // imp se dif do anterior
				ENDI
//			 ENDI
			 @ cl,002+addcl SAY IIF(emissao_<DATE(),[*],[ ])
			 @ cl,003+addcl SAY TRAN(tipo,"!")               // Tipo
			 @ cl,004+addcl SAY "-"
			 @ cl,005+addcl SAY TRAN(circ,"999")               // Circular
			 @ cl,009+addcl SAY TRAN(emissao_,"@D")            // Emissao
			 vlpend=R07702F9()                           // variavel temporaria
			 tot091004+=vlpend
			 @ cl,020+addcl SAY TRAN(vlpend,"@E 9,999.99")   // Valor
			 vlpg=valorpg                                // variavel temporaria
			 subtt=subtt+vlpend-vlpg                     // variavel temporaria
			 IF !EMPT(valorpg)                             // pode imprimir?
				@ cl,029+addcl SAY [Pg.]+LEFT(dtoc(pgto_),6)+;     // Obs.
                     RIGHT(dtoc(pgto_),2)
			 ENDI
       IF addcl=0
        addcl=40
       ELSE
        addcl=0
       ENDI
			 qqu091++                                    // soma contadores de registros
			 SKIP                                        // pega proximo registro
			ELSE                                         // se nao atende condicao
			 SKIP                                        // pega proximo registro
			ENDI
		 ENDD
		 IF cl+3>maxli                                 // se cabecalho do arq filho
			REL_CAB(0)                                   // nao cabe nesta pagina
		 ENDI                                          // salta para a proxima pagina
/*
		 @ ++cl,022 SAY REPL('-',10)
		 @ ++cl,022 SAY TRAN(subtt,"@E 999,999.99")// total Valor
		 @ cl,003 SAY "*** Quantidade "+TRAN(qqu091,"999")
*/
		 cl+=2
		 @ ++cl,002 SAY [OBS.: ]
     @ cl,002 say GET_MSG()
		 cl+=3                                    // soma cl/imprime cabecalho
		 @ cl,02 SAY [Data: ___ / ___ / ___]//
		 cl+=3
		 @ cl,002 SAY [________________________________]
		 @ cl,040 SAY [________________________________]
		 cl++
		 @ cl,002 SAY [Representante]
		 @ cl,040 SAY [Contratante]
		 cl+=2
		 @ ++cl,002 SAY [Valor para continuidade: ]+TRAN(subtt,"@E 999,999.99")// total Valor
		 @ ++cl,002 SAY [Valor para cancelamento: ]
		 @ ++cl,002 SAY [Calculo efetuado por...: ]

     cl+=2                                         // soma contador de linha

    ENDI
    SELE GRUPOS                                    // volta ao arquivo pai
    SKIP                                           // pega proximo registro
    cl=999                                         // forca salto de pagina
   ELSE                                            // se nao atende condicao
    SKIP                                           // pega proximo registro
   ENDI
  ENDD
 ENDD ccop
 EJEC                                              // salta pagina
END SEQUENCE
SET PRINTER TO (drvporta)                          // fecha arquivo gerado (se houver)
SET DEVI TO SCRE                                   // direciona saida p/ video
IF tps=2                                           // se vai para arquivo/video
 BROWSE_REL(arq_,2,3,MAXROW()-2,78)
ENDI                                               // mostra o arquivo gravado
GRELA(52)                                          // grava variacao do relatorio
SELE GRUPOS                                        // salta pagina
SET RELA TO                                        // retira os relacionamentos
SET(_SET_DELETED,dele_atu)                         // os excluidos serao vistos
IF so_um_reg
 POINTER_DBF(sit_dbf)
ENDI
RETU

STATIC PROC REL_CAB(qt)                            // cabecalho do relatorio
IF qt>0                                            // se parametro maior que 0
 cl=cl+qt                                          // soma no contador de linhas
ENDI
IF cl>maxli .OR. qt=0                              // quebra de pagina
 IMPCTL(drvtcom)
 @ 0,000 SAY M->nemp                                // nome da empresa
 @ 0,071 SAY "PAG"
 @ 0,075 SAY TRAN(pg_,'9999')                      // n£mero da p gina
 IMPAC(nsis,1,000)                                 // t¡tulo aplica‡„o
 @ 1,071 SAY "ADC_RX76"                            // c¢digo relat¢rio
 IMPAC("FICHA DE ACERTOS",2,000)
 @ 2,024 SAY titrel                                // t¡tulo a definir
 @ 2,060 SAY NSEM(DATE())                          // dia da semana
 @ 2,069 SAY DTOC(DATE())                          // data do sistema
 @ 3,000 SAY "Contrato  Nome                               "+IIF(!EMPT(telefone+contato)," Telefone/ Contato"," ")
 @ 4,000 SAY REPL("-",79)
 cl=qt+4 ; pg_++
ENDI
RETU

* \\ Final de ADC_RX76.PRG

FUNC get_msg
msg:=[]
ctlmax:=IIF(GRUPOS->codigo=[020],60,10)
for ctmsg=1 to ctlmax
 IF ctlmax=10
  msgaux:=MEMOLINE(GRUPOS->obs,55,ctmsg)
 ELSE
  msgaux:=MEMOLINE(GRUPOS->obs,55,ctmsg)
 ENDI
 IF !EMPT(msgaux)
  msg+=msgaux
 ENDI
next
IF !EMPT(msg)
 msg+=chr(10)+chr(13)+[:============]
ENDI
PTAB([],[MENSAG])
SELE MENSAG
msg2add:=[]
msg2prt:=.f.
DO WHILE ! EOF()
 SELE GRUPOS
 cond=LEFT(MENSAG->filtro,AT("~",MENSAG->filtro)-1)               // condicao de validacao
 OP_=0
 MSGAUX:=[MENSAGEM]
 alerta()
 msg2prt:=.f.
 msg2add:=[]
 IF (&cond.)                                 // se condicao nao satisfeita,
  nrlin:=mlcount(MENSAG->mens1,50)
  FOR OP_ = 1 TO nrlin
   msgAUX:=MEMOLINE(MENSAG->mens1,50,OP_)
   msg2add+=msgAUX
   IF [ATEN]$msgAUX
    msg2prt:=.t.
   ENDIF
  NEXT
 ENDI
 IF msg2prt
  msg+=msg2add+chr(10)+chr(13)+[:============]
 ENDI
 SELE MENSAG
 SKIP
ENDD

RETU msg

FUNC R07701F9
donex:=(M->pag=[S].AND.TAXAS->valorpg>0)
donex:=donex.OR.(M->pend=[S].AND.TAXAS->valorpg=0)
//donex:=donex.AND.(EMPT(M->veni_).OR.TAXAS->emissao_>=M->veni_)
donex:=donex.AND.(EMPT(M->venf_).OR.TAXAS->emissao_<=M->venf_)

RETU M->donex       // <- deve retornar um valor L¢GICO

* \\ Final de R07701F9.PRG

FUNC R07702F9
PRIVA vladd:=0
IF TAXAS->emissao_< DATE()
 jrok:=PTAB(tipo,'JUROS',1)
 nrd:=(DATE() - TAXAS->emissao_)
 IF jrok .AND. (nrd > JUROS->mltcaren)
  vladd+=TAXAS->valor*JUROS->multa/100
 ENDI
 IF jrok .AND. (nrd > JUROS->jrscaren)
  vladd+=TAXAS->valor*JUROS->juros/100*nrd
 ENDI
ENDI

RETU IIF(EMPT(TAXAS->valorpg),TAXAS->valor+M->vladd,TAXAS->valorpg)

* \\ Final de R07702F9.PRG
procedure obx_018
/*
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
 \ Empresa.: Ind£stria de Urnas Bignotto Ltda
 \ Programa: BXR_018.PRG
 \ Data....: 07-12-95
 \ Sistema.: Administradora de Funer rias
 \ Funcao..: Rotina avulsa (Emiss„o do Recibo)
 \ Analista: Ademilson Pedro Bom
 \ Criacao.: Programado manualmente pelo analista
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/

#include "admbig.ch"    // inicializa constantes manifestas

/*
   Nivelop = Nivel de acesso do usuario (1=operacao, 2=manutencao e
   3=gerencia)
*/
IF nivelop < 1          // se usuario nao tem
 ALERTA()               // permissao, avisa
 DBOX(msg_auto,,,3)     // e retorna
 RETU
ENDI
/*
  Emite o recibo
*/
ADM_R033(3,10)
RETU

* \\ Final de BXR_018.PRG
/*
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
 \ Empresa.: Ind£stria de Urnas Bignotto Ltda
 \ Programa: CON_R001.PRG
 \ Data....: 15-05-97
 \ Sistema.: Controle de Convˆnios
 \ Funcao..: Emiss„o Guias 1¦ Parte
 \ Analista: Ademilson Pedro Bom
 \ Criacao.: GAS-Pro v3.0
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/

#include "adrbig.ch"    // inicializa constantes manifestas

LOCAL dele_atu, getlist:={}, so_um_reg, sit_dbf:=POINTER_DBF()
PARA  lin_menu, col_menu, imp_reg
PRIV  tem_borda:=.t., op_menu:=VAR_COMPL, l_s:=11, c_s:=20, l_i:=14, c_i:=61, tela_fundo:=SAVESCREEN(0,0,MAXROW(),79)
nucop=1
so_um_reg=(PCOU()>2)
IF !so_um_reg                             // vai receber a variaveis?
 SETCOLOR(drvtittel)
 vr_memo=NOVAPOSI(@l_s,@c_s,@l_i,@c_i)    // pega posicao atual da tela
 CAIXA(mold,l_s,c_s,l_i,c_i)              // monta caixa da tela
 @ l_s,c_s+12 SAY " EMISSŽO DE GUIAS "
 SETCOLOR(drvcortel)
 @ l_s+01,c_s+1 SAY " N£mero:"
ENDI
gnumero=SPAC(7)                                    // N£mero
DO WHILE .t.
 rola_t=.f.
 cod_sos=56
 IF !so_um_reg
  SET KEY K_ALT_F8 TO ROLATELA
  SETCOLOR(drvcortel+","+drvcorget+",,,"+corcampo)
  @ l_s+01 ,c_s+10 GET  gnumero;
                   PICT "@R 99-99999";
                   VALI CRIT("PTAB(gnumero,'GUIAS',1).AND.V00101F9()~N£MERO n„o existe na tabela")
                   AJUDA "Emitir a guia de n£mero?"
                   CMDF8 "VDBF(6,8,20,77,'GUIAS',{'numero','contrato','nome'},1,'R001gf9()')"
                   MOSTRA {"LEFT(TRAN(GUIAS->nome,[@!]),35)", 2 , 5 }

  READ
  SET KEY K_ALT_F8 TO
  IF rola_t
   ROLATELA(.f.)
   LOOP
  ENDI
  IF LASTKEY()=K_ESC                               // se quer cancelar
   RETU                                            // retorna
  ENDI
 ENDI

 #ifdef COM_REDE
  IF !USEARQ("GUIAS",.f.,10,1)                     // se falhou a abertura do arq
   RETU                                            // volta ao menu anterior
  ENDI
 #else
  USEARQ("GUIAS")                                  // abre o dbf e seus indices
 #endi

 PTAB(medico,"MEDICOS",1,.t.)                      // abre arquivo p/ o relacionamento
 SET RELA TO medico INTO MEDICOS                 // relacionamento dos arquivos
 titrel:=criterio:=cpord := ""                     // inicializa variaveis
 titrel:=chv_rela:=chv_1:=chv_2 := ""
 tps:=op_x:=ccop := 1
 arq_=drvporta                                     // porta de saida configurada
 IF !so_um_reg
  IF !opcoes_rel(lin_menu,col_menu,7,11)           // nao quis configurar...
   CLOS ALL                                        // fecha arquivos e
   LOOP                                            // volta ao menu
  ENDI

 #ifdef COM_REDE

  ELSE

   tps=lin_menu

 #endi

 ENDI
 IF tps=2                                          // se vai para arquivo/video
  arq_=ARQGER()                                    // entao pega nome do arquivo
  IF EMPTY(arq_)                                   // se cancelou ou nao informou
   LOOP                                            // retorna
  ENDI
 ELSE
  arq_=drvporta                                    // porta de saida configurada
 ENDI
 SET PRINTER TO (arq_)                             // redireciona saida
 EXIT
ENDD
IF !EMPTY(drvtapg)                                 // existe configuracao de tam pag?
 op_=AT("NNN",drvtapg)                             // se o codigo que altera
 IF op_=0                                          // o tamanho da pagina
  msg="Configura‡„o do tamanho da p gina!"         // foi informado errado
  DBOX(msg,,,,,"ERRO!")                            // avisa
  CLOSE ALL                                        // fecha todos arquivos abertos
  RETU                                             // e cai fora...
 ENDI                                              // codigo para setar/resetar tam pag
 lpp_024=LEFT(drvtapg,op_-1)+"024"+SUBS(drvtapg,op_+3)
 lpp_066=LEFT(drvtapg,op_-1)+"066"+SUBS(drvtapg,op_+3)
ELSE
 lpp_024:=lpp_066 :=""                             // nao ira mudara o tamanho da pag
ENDI
DBOX("[ESC] Interrompe",15,,,NAO_APAGA)
dele_atu:=SET(_SET_DELETED,.t.)                    // os excluidos nao servem...
SET DEVI TO PRIN                                   // inicia a impressao
maxli=17                                           // maximo de linhas no relatorio
IMPCTL(lpp_024)                                    // seta pagina com 24 linhas
SET MARG TO 1                                      // ajusta a margem esquerda
IF tps=2
 IMPCTL("' '+CHR(8)")
ENDI
BEGIN SEQUENCE
 DO WHIL ccop<=nucop				// imprime qde copias pedida
  pg_=1; cl=999
  IF so_um_reg
   GO imp_reg
  ELSE
   INI_ARQ()                                       // acha 1o. reg valido do arquivo
   IF PTAB(PADR(SUBSTR(M->ide_maq,2),4)+[GUI],[IMPPAR],1)
    SEEK ALLTRIM(IMPPAR->docto)
   ENDI
  ENDI
  ccop++                                           // incrementa contador de copias
  ult_imp=0                                        // ultimo reg impresso
  DO WHIL !EOF().AND.(!so_um_reg.OR.imp_reg=RECN())
   #ifdef COM_TUTOR
    IF IN_KEY()=K_ESC                              // se quer cancelar
   #else
    IF INKEY()=K_ESC                               // se quer cancelar
   #endi
    IF canc()                                      // pede confirmacao
     BREAK                                         // confirmou...
    ENDI
   ENDI
   IF (PTAB(PADR(SUBSTR(M->ide_maq,2),4)+[GUI],[IMPPAR],1).AND.ano+numero=LEFT(IMPPAR->docto,7)) .OR. so_um_reg// se atender a condicao...
    REL_CAB(1,.t.)                                 // soma cl/imprime cabecalho
    @ cl,000 SAY "GUIA DE ENCAMINHAMENTO  N§:"
    @ cl,027 SAY ano+'-'+numero+GDV1(ano+numero)   // N£mero
    @ cl,043 SAY IIF(guiapara='C',[Consulta],IIF(guiapara='E',[Exame],IIF(guiapara='I',[Interna‡„o],[     ])))// Guia Para
    IF M->combarra=[S]
     CODBARRAS({{ano+numero+GDV1(ano+numero),4,10,64}},10,6)
    ENDI
    ult_imp=RECNO()                                // ultimo reg impresso
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY "Para:"
    @ cl,008 SAY TRAN(MEDICOS->especialid,"@!")    // Especialidade
    IF M->combarra=[S]
     CODBARRAS({{ano+numero+GDV1(ano+numero),4,10,64}},10,6)
    ENDI
    REL_CAB(2)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY "Encaminhado a .........:"
    @ cl,025 SAY ALLTRIM(MEDICOS->nome)+[ (]+ALLTRIM(medico)+[)]// M‚dico
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    IMPAC("Endere‡o...............:",cl,000)
    @ cl,025 SAY MEDICOS->endereco// Endere‡o
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY "Atendimento dia........:"
    @ cl,025 SAY TRAN(emissao_,"@D")               // Emiss„o
    IMPAC("(V lido at‚ 30 dias)",cl,036)
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY "Pessoa a ser atendida..:"
    IMPCTL(drvpenf)
    @ cl,025 SAY TRAN(nome,"@!")                   // Nome
    IMPCTL(drvtenf)
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    IMPAC("Benefici rio principal.:",cl,000)
    @ cl,025 SAY TRAN([ (]+ALLTRIM(titular)+[ / ]+contrato+[)],"@!")// Titular
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY REPL("-",60)
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    IF !EMPT(MEDICOS->mensagem)
     @ cl,008 SAY TRAN(MEDICOS->mensagem,"@!")      // Mensagem
     REL_CAB(2)                                     // soma cl/imprime cabecalho
    ELSE
     @ cl,000 SAY "Valor Particular:"
     @ cl,018 SAY tran(MEDICOS->valorpart,"@E 99,999,999.99")// Valor Particular
     @ cl,033 SAY "desconto de:"
     IF (MEDICOS->valorpart - valorcon)>0// pode imprimir?
      @ cl,046 SAY TRAN(MEDICOS->valorpart - valorcon,"@E 99,999,999.99")// Valor desconto
     ENDI
     REL_CAB(1)                                     // soma cl/imprime cabecalho
     @ cl,000 SAY "Valor Total.....:"
     @ cl,018 SAY TRAN(valorcon+ valorexa,"@E 99,999,999.99")// Valor total
     @ cl,032 SAY LEFT([(]+LEFT(EXT(valorcon+valorexa),AT('/',EXT(valorcon+valorexa))-1)+[)],40)// Total p/Extenso
     REL_CAB(1)                                     // soma cl/imprime cabecalho
     @ cl,016 SAY SUBSTR([(]+LEFT(EXT(valorcon+valorexa),AT('/',EXT(valorcon+valorexa))-1)+[)],41,54)// Extenso (cont..)
    ENDI
    SKIP                                           // pega proximo registro
    cl=999                                         // forca salto de pagina
   ELSE                                            // se nao atende condicao
    SKIP                                           // pega proximo registro
   ENDI
   exit
  ENDD
  REL_RDP(.t.)                                     // imprime rodape' do relatorio
 ENDD ccop
 EJEC                                              // salta pagina
END SEQUENCE
SET MARG TO                                        // coloca margem esquerda = 0
IMPCTL(lpp_066)                                    // seta pagina com 66 linhas
SET PRINTER TO (drvporta)                          // fecha arquivo gerado (se houver)
SET DEVI TO SCRE                                   // direciona saida p/ video
IF tps=2                                           // se vai para arquivo/video
 BROWSE_REL(arq_,2,3,MAXROW()-2,78)
ENDI                                               // mostra o arquivo gravado
GRELA(7)                                           // grava variacao do relatorio
SELE GUIAS                                         // salta pagina
SET RELA TO                                        // retira os relacionamentos
SET(_SET_DELETED,dele_atu)                         // os excluidos serao vistos
IF so_um_reg
 POINTER_DBF(sit_dbf)
ENDI
RETU

STATIC PROC REL_RDP(volta_reg)                     // rodape'
LOCAL reg_atual:=RECNO()
IF volta_reg
 GO ult_imp                                        // ajusta reg p/ imp de campos no rodape'
ENDI
@ 18,000 SAY "" //chr(15)                               // comprime
IMPCTL(drvpcom)
IF FILE([MENGUIA.MEM])
 REST FROM MENGUIA.MEM ADDITIVE
 @ 18,002 SAY M->rmens1
 @ 19,002 SAY M->rmens2
 cl:=19
 IF !EMPT(M->rmens3)
  cl++
  @ cl,002 SAY M->rmens3
 ENDI
 IF !EMPT(M->rmens4)
  cl++
  @ cl,002 SAY M->rmens4
 ENDI
 IF !EMPT(M->rmens5)
  cl++
  @ cl,000 SAY M->rmens5
 ENDI
ELSE
 @ 18,002 SAY [IMPORTANTE:- Esta guia tem a finalidade principal de encaminhamento em consultas e exames,]// Mensagem 1
 @ 19,002 SAY [N„o dando direito a cirurgias, interna‡”es, medicamentos entre outros.]// Mensagem 2
 @ 20,002 SAY [ - Esta guia tem validade de 30 dias ap¢s a emiss„o]// Mensagem 3
 @ 21,002 SAY [ - Esta guia s¢ ter  validade com o carimbo e assinatura do respons vel pela emiss„o.]// Mensagem 4
 cl:= 22
ENDI
IMPCTL(drvtcom)

@ cl,001 SAY replicate('- ',36)                    // traco
IF volta_reg
 GO reg_atual                                      // retorna reg a posicao original
ENDI
RETU

STATIC PROC REL_CAB(qt, volta_reg)                 // cabecalho do relatorio
volta_reg=IF(volta_reg=NIL,.f.,volta_reg)
IF qt>0                                            // se parametro maior que 0
 cl=cl+qt                                          // soma no contador de linhas
ENDI
IF cl>maxli .OR. qt=0                              // quebra de pagina
 IF pg_>1
  REL_RDP(volta_reg)                               // imprime rodape' do relatorio
 ENDI
 IMPCTL(drvpenf)
 IMPEXP(0,000,LEFT(M->setup1,38),76)               // Setup1
 IMPCTL(drvtenf)
// @ 1,000 SAY M->defconv                            // Defconv
 @ 2,000 SAY M->setup2                             // setup2
 @ 3,000 SAY M->setup3                             // Setup3
 @ 4,000 SAY REPL("-",60)
 cl=qt+4 ; pg_++
ENDI
RETU

* \\ Final de CON_R001.PRG
FUNC R001GF9
RETURN ano+numero/*
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
 \ Empresa.: PresServ Inform tica - Limeira (019)452.6623
 \ Programa: GUI_07F9.PRG
 \ Data....: 23-05-98
 \ Sistema.: Administradora - RECEP€„O
 \ Funcao..: Fun‡„o de busca do inscrito, arquivo GUIAS
 \ Analista: Ademilson Pedro Bom
 \ Criacao.: Programado manualmente pelo analista
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/

#include "adrbig.ch"    // inicializa constantes manifestas

LOCAL reg_dbf:=POINTER_DBF()
PRIVA respx,nomx:=space(35)
PTAB([],[GRUPOS],1,.t.)

nome:=space(35)
IF contrato=[000000]
 nomx=DBOX("Nome",,,,,"Informe o nome a procurar",nomx,"@!")

 IF PTAB(alltrim(nomx),[GRUPOS],5,.t.)
	contrato:=GRUPOS->codigo
	contrato:=VDBF(6,3,20,77,'GRUPOS',{'nome','codigo'},5,'codigo')
	nome:=GRUPOS->nome

 ELSEIF PTAB(alltrim(nomx),[INSCRITS],2,.t.)
	contrato:=INSCRITS->codigo+INSCRITS->grau+STR(INSCRITS->seq,2)
  nome:=alltrim(inscrits->nome)
	contrato:=VDBF(6,3,20,77,'INSCRITS',{'nome','codigo'},2,'codigo')
	nome:=INSCRITS->nome
  contrato:=IIF(contrato=NIL,[000000],left(contrato,6))

 ENDI

 IF LASTKEY()=K_ESC             // se teclou ESC
	contrato=[000000]
	POINTER_DBF(reg_dbf)
	RETU .f.
 ENDI

ENDI
respx:=contrato

IF PTAB(respx,[GRUPOS],1)
 titular:=GRUPOS->nome
ENDI

POINTER_DBF(reg_dbf)

retu PTAB(respx,[GRUPOS])	 // <- deve retornar um valor qualquer

* \\ Final de GUI_02F9.PRG
/*
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
 \ Empresa.: PresServ Inform tica - Limeira (019)452.6623
 \ Programa: GUI_08F9.PRG
 \ Data....: 23-05-98
 \ Sistema.: Administradora - RECEP€„O
 \ Funcao..: Fun‡„o de preenchimento do campo m‚dico, arquivo GUIAS
 \ Analista: Ademilson Pedro Bom
 \ Criacao.: Programado manualmente pelo analista
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/

#include "adrbig.ch"    // inicializa constantes manifestas

//LOCAL reg_dbf:=POINTER_DBF()

PRIVA respx:=SPACE(10),nomx:=space(35)
PTAB([],[MEDICOS],1,.t.)
IF EMPT(medico).and.op_menu=INCLUSAO
 nomx=DBOX("Nome",,,,,"Informe o nome a procurar",nomx,"@!")
 IF PTAB(alltrim(nomx),[MEDICOS],2)
  medico:=MEDICOS->codbenefic
 ELSEIF PTAB(alltrim(nomx),[MEDICOS],3)
  medico:=MEDICOS->codbenefic
 ENDI
 Codbenefic=MEDICO
 Codbenefic:=VDBF(6,3,20,77,'MEDICOS',{'LEFT(oldespec,20)','nome','endereco','cidade','codbenefic','fonecom1','fonecom2'},3,'codbenefic',[])
 MEDICO=Codbenefic
 IF LASTKEY()=K_ESC             // se teclou ESC
	medico=space(10)
//	POINTER_DBF(reg_dbf)
	RETU .f.
 ENDI
ELSE
 retur .t.
ENDI
respx:=medico
//dbox([>]+respx+[<])
//POINTER_DBF(reg_dbf)

retu PTAB(respx,[MEDICOS],1)  // <- deve retornar um valor qualquer

* \\ Final de GUI_02F9.PRG
procedure ins_01f9
/*
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
 \ Empresa.: Funer ria Bom Pastor
 \ Programa: INS_01F9.PRG
 \ Data....: 21-11-94
 \ Sistema.: Controle da Organiza‡Æo
 \ Funcao..: Valor inicial do campo SEQ, arquivo INSCRITS
 \ Analista: Ademilson Pedro Bom
 \ Criacao.: Programado manualmente pelo analista
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/

#include "adrbig.ch"   // inicializa constantes manifestas

IF (grau==[8] .AND. M->pgrau==[7]) .OR. grau<[7]
   M->pseq:=0
ENDIF
M->pgrau:=grau
M->pseq+=IIF(grau>[6],1,0)
RETU M->pseq

* \\ Final de INS_01F9.PRG
procedure bxr_018
/*
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
 \ Empresa.: Ind£stria de Urnas Bignotto Ltda
 \ Programa: BXR_018.PRG
 \ Data....: 07-12-95
 \ Sistema.: Administradora de Funer rias
 \ Funcao..: Rotina avulsa (Emiss„o do Recibo)
 \ Analista: Ademilson Pedro Bom
 \ Criacao.: Programado manualmente pelo analista
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/

#include "admbig.ch"    // inicializa constantes manifestas

/*
   Nivelop = Nivel de acesso do usuario (1=operacao, 2=manutencao e
   3=gerencia)
*/
IF nivelop < 1          // se usuario nao tem
 ALERTA()               // permissao, avisa
 DBOX(msg_auto,,,3)     // e retorna
 RETU
ENDI
/*
  Emite o recibo
*/
ADM_R018(3,10)
RETU

* \\ Final de BXR_018.PRG
€ ADRBIGÉ–ë  ADRBIGCODE
PEGA_SENHACODEFIM_PWCODEC_ETEXTENDCODE	_SYMSTARTSYMSTARTSYMBOLSSYMBOLS_SYMENDSYMENDNULLBEGDATA_DATADATA_SYMPBDATA_SYMPDATA_SYMPEDATA_CONSTCONST_MSGMSG_BEGBSSBEGBSS_BSSBSS_ENDBSSENDBSSDGROUPQ˜ @!ß˜ @“˜ @J É˜ H  	˜ h  
ã˜ ``w˜ h  Û˜ h  ×˜ H  ó˜ H  ï˜ H ã˜ H  ç˜ H  /*
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
 \ Empresa.: PresServ Inform tica - Limeira (019)452.6623
 \ Programa: ADR_ATR2.PRG
 \ Data....: 29-01-04
 \ Sistema.: Administradora - RECEP€„O
 \ Funcao..: Define atributos dos arquivos (sistema[])
 \ Analista: Ademilson Pedro Bom
 \ Criacao.: GAS-Pro v4.0o
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/

#include "adrbig.ch"    // inicializa constantes manifestas


sistema[020]={;
            "Processos da Circular",;                       // opcao do menu
            "Processos da Circular",;                       // titulo do sistema
            {"grupo+circ+processo","DTOS(dfal)","DTOS(dfal)"},;// chaves do arquivo
            {"Grupo/Circular","p/Data","Grupo e Data"},;    // titulo dos indices para consulta
            {"010203","09","09"},;                          // ordem campos chaves
            {"CPRCIRC",drvdbf,drvntx},;                     // nome do DBF
            {"CPRCIRC1","CPRCIRC2","CPRCIRC3"},;            // nomes dos NTX
            {},;                                            // nome dos dbf's relacionados
            {"CIRCULAR->grupo","CIRCULAR->circ"},;          // campos de relacionamento
            {1,1,8,4,15,76,3,4},;                           // num telas/tela atual/coordenadas/inicio scroll/qtde scroll
            {1,.t.,.f.},;                                   // nivel acesso/tp chave/pede dir
            {},;                                            // campos do arquivo
            {},;                                            // formula mostradas
            {"",""},;                                       // condicao de exclusao de registros
            {"",""},;                                       // condicao de alteracao de registros
            {"",""};                                        // condicao de recupercao de registros
           }

AADD(sistema[020,O_CAMPO],{;            // CPRCIRC
     /* mascara       */    "!!",;
     /* titulo        */    "Grupo",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[020,O_CAMPO],{;            // CPRCIRC
     /* mascara       */    "999",;
     /* titulo        */    "Circular",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[020,O_CAMPO],{;            // CPRCIRC
     /* mascara       */    "@R 99999/99/!!",;
     /* titulo        */    "Processo",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(processo)~Necess rio informar PROCESSO",;
     /* help do campo */    "Informe o n£mero do processo a incluir";
                         };
)
AADD(sistema[020,O_CAMPO],{;            // CPRCIRC
     /* mascara       */    "!!",;
     /* titulo        */    "Categoria",;
     /* cmd especial  */    "MTAB([PL=Plano|PD=Plano c/Diferen‡a|AF=Auxilio],[CATEGORIA])",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "categ $ [PL|PD|AF]~CATEGORIA n„o aceit vel",;
     /* help do campo */    "Preencha com:|PL para Plano,| PD p/Diferen‡a ou |AX para Aux.Funeral";
                         };
)
AADD(sistema[020,O_CAMPO],{;            // CPRCIRC
     /* mascara       */    "999999",;
     /* titulo        */    "Num",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(num).AND.PTAB(num,'GRUPOS',1)~NUM n„o existe na tabela",;
     /* help do campo */    "";
                         };
)
AADD(sistema[020,O_CAMPO],{;            // CPRCIRC
     /* mascara       */    "@!",;
     /* titulo        */    "Fal",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(fal)~Necess rio informar FAL",;
     /* help do campo */    "";
                         };
)
AADD(sistema[020,O_CAMPO],{;            // CPRCIRC
     /* mascara       */    "@!",;
     /* titulo        */    "Ends",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[020,O_CAMPO],{;            // CPRCIRC
     /* mascara       */    "@!",;
     /* titulo        */    "Cids",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[020,O_CAMPO],{;            // CPRCIRC
     /* mascara       */    "@D",;
     /* titulo        */    "Data",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(dfal)~Necess rio informar DATA",;
     /* help do campo */    "";
                         };
)
AADD(sistema[020,O_CAMPO],{;            // CPRCIRC
     /* mascara       */    "!",;
     /* titulo        */    "Flag",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[020,O_FORMULA],{;          // CPRCIRC - Nome
     /* form mostrar  */    "LEFT(TRAN(INSCRITS->nome,[]),35)",;
     /* lin da formula*/    0,;
     /* col da formula*/    0;
                         };
)


sistema[021]={;
            "Processos",;                                   // opcao do menu
            "Processos",;                                   // titulo do sistema
            {"processo+categ","grup+DTOS(dfal)","codlan"},; // chaves do arquivo
            {"p/Processo","Grupo+Data","Cod.Lanc"},;        // titulo dos indices para consulta
            {"0102","0413","14"},;                          // ordem campos chaves
            {"PRCESSOS",drvdbf,drvntx},;                    // nome do DBF
            {"PRCESSO1","PRCESSO2","PRCESSO3"},;            // nomes dos NTX
            {},;                                            // nome dos dbf's relacionados
            {},;                                            // campos de relacionamento
            {1,1,6,14,18,68},;                              // num telas/tela atual/coordenadas
            {0,.t.,.f.},;                                   // nivel acesso/tp chave/pede dir
            {},;                                            // campos do arquivo
            {},;                                            // formula mostradas
            {"EMPT(saiu)","J  emitido nas Taxas|Exclusao nao permitida"},;// condicao de exclusao de registros
            {"EMPT(saiu)","J  emitido nas Taxas|Altera‡ao nao permitida"},;// condicao de alteracao de registros
            {"",""};                                        // condicao de recupercao de registros
           }

AADD(sistema[021,O_CAMPO],{;            // PRCESSOS
     /* mascara       */    "@R 99999/99/!!",;
     /* titulo        */    "Processo",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(processo)~Necess rio informar PROCESSO",;
     /* help do campo */    "Informe o n£mero do processo a incluir";
                         };
)
AADD(sistema[021,O_CAMPO],{;            // PRCESSOS
     /* mascara       */    "!!",;
     /* titulo        */    "Categoria",;
     /* cmd especial  */    "MTAB([PL=Plano|PD=Plano c/Diferen‡a|AF=Auxilio],[CATEGORIA])",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "categ $ [PL|PD|AF]~CATEGORIA n„o aceit vel",;
     /* help do campo */    "Preencha com:|PL para Plano,| PD p/Diferen‡a ou |AX para Aux.Funeral";
                         };
)
AADD(sistema[021,O_CAMPO],{;            // PRCESSOS
     /* mascara       */    "",;
     /* titulo        */    "Saiu",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    "Preencha com o n£mero da circular|ou|deixe em branco se ainda n„o saiu em cobran‡a";
                         };
)
AADD(sistema[021,O_CAMPO],{;            // PRCESSOS
     /* mascara       */    "!!",;
     /* titulo        */    "Grup",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(grup).AND.PTAB(grup,'ARQGRUP',1)~GRUP n„o existe na tabela",;
     /* help do campo */    "Pertence a qual grupo";
                         };
)
AADD(sistema[021,O_CAMPO],{;            // PRCESSOS
     /* mascara       */    "999999",;
     /* titulo        */    "Num",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(num).AND.PTAB(num,'GRUPOS',1)~NUM n„o existe na tabela",;
     /* help do campo */    "Qual contrato";
                         };
)
AADD(sistema[021,O_CAMPO],{;            // PRCESSOS
     /* mascara       */    "9",;
     /* titulo        */    "Inscr.",;
     /* cmd especial  */    "MTAB(M->TBTIPGRAU,[INSCR.])",;
     /* default       */    "IIF(M->pgrau<[7],SUBSTR([1234567],VAL(M->pgrau),1),M->pgrau)",;
     /* pre-validacao */    "",;
     /* validacao     */    "grau $ [12345678].and.(PTAB(num,'INSCRITS',1).or.1=1)~INSCR. n„o aceit vel",;
     /* help do campo */    "Qual o grau de parentesco|Tecle F8 para consulta";
                         };
)
AADD(sistema[021,O_CAMPO],{;            // PRCESSOS
     /* mascara       */    "99",;
     /* titulo        */    "Seq",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "grau>'6'",;
     /* validacao     */    "",;
     /* help do campo */    "Que sequencia";
                         };
)
AADD(sistema[021,O_CAMPO],{;            // PRCESSOS
     /* mascara       */    "@!",;
     /* titulo        */    "Seg",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    "Nome do segurado/Contratante";
                         };
)
AADD(sistema[021,O_CAMPO],{;            // PRCESSOS
     /* mascara       */    "@!",;
     /* titulo        */    "Ends",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    "";
                         };
)
AADD(sistema[021,O_CAMPO],{;            // PRCESSOS
     /* mascara       */    "@!",;
     /* titulo        */    "Cids",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    "";
                         };
)
AADD(sistema[021,O_CAMPO],{;            // PRCESSOS
     /* mascara       */    "@!",;
     /* titulo        */    "Fal",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(fal)~Necess rio informar FAL",;
     /* help do campo */    "Nome do falecido";
                         };
)
AADD(sistema[021,O_CAMPO],{;            // PRCESSOS
     /* mascara       */    "@!",;
     /* titulo        */    "Sep",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(sep)~Necess rio informar SEP",;
     /* help do campo */    "Sepultado em";
                         };
)
AADD(sistema[021,O_CAMPO],{;            // PRCESSOS
     /* mascara       */    "@D",;
     /* titulo        */    "Data",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    "Data do falecimento";
                         };
)
AADD(sistema[021,O_CAMPO],{;            // PRCESSOS
     /* mascara       */    "!!!-99999999-999-999",;
     /* titulo        */    "Cod.Lan‡amento",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[021,O_FORMULA],{;          // PRCESSOS - T.Carˆncia
     /* form mostrar  */    "LEFT(TRAN(IIF(INSCRITS->tcarencia>dfal,[Carˆncia do Inscrito],[]),[]),22)",;
     /* lin da formula*/    4,;
     /* col da formula*/    29;
                         };
)


sistema[022]={;
            "Funcion rios",;                                // opcao do menu
            "Funcion rios",;                                // titulo do sistema
            {"codigo"},;                                    // chaves do arquivo
            {"N£mero"},;                                    // titulo dos indices para consulta
            {"01"},;                                        // ordem campos chaves
            {"FNCS",drvdbf,drvntx},;                        // nome do DBF
            {"FNCS1"},;                                     // nomes dos NTX
            {},;                                            // nome dos dbf's relacionados
            {},;                                            // campos de relacionamento
            {1,1,6,8,15,73},;                               // num telas/tela atual/coordenadas
            {1,.t.,.f.},;                                   // nivel acesso/tp chave/pede dir
            {},;                                            // campos do arquivo
            {},;                                            // formula mostradas
            {"nivelop>2","Permitido apenas para usu rio cadastrado|com n¡vel de Gerˆncia"},;// condicao de exclusao de registros
            {"nivelop>1","Permitido apenas para usu rio cadastrado|com n¡vel de Manuten‡„o ou Gerˆncia"},;// condicao de alteracao de registros
            {"nivelop>2","Permitido apenas para usu rio cadastrado|com n¡vel de Gerˆncia"};// condicao de recupercao de registros
           }

AADD(sistema[022,O_CAMPO],{;            // FNCS
     /* mascara       */    "",;
     /* titulo        */    "C¢digo",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(codigo)~Necess rio informar C¢DIGO",;
     /* help do campo */    "Informe um c¢digo para o funcion rio";
                         };
)
AADD(sistema[022,O_CAMPO],{;            // FNCS
     /* mascara       */    "@!",;
     /* titulo        */    "Nome do funcion rio",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(nome)~Necess rio informar NOME DO FUNCIONRIO",;
     /* help do campo */    "Entre com o nome do funcion rio autorizado a|assinar a declara‡Æo de ¢bito no|Cart¢rio de Registro C¡vil";
                         };
)
AADD(sistema[022,O_CAMPO],{;            // FNCS
     /* mascara       */    "@!",;
     /* titulo        */    "Profiss„o",;
     /* cmd especial  */    "MTAB([ATENDENTE|COBRADOR|MOTORISTA|VENDEDOR],[PROFISSŽO])",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(profiss)~sta informa‡„o ‚ necess rio para a Declara‡„o de ¢bito",;
     /* help do campo */    "Entre com a profiss„o do funcion rio.";
                         };
)
AADD(sistema[022,O_CAMPO],{;            // FNCS
     /* mascara       */    "@!",;
     /* titulo        */    "Nacionalidade",;
     /* cmd especial  */    "",;
     /* default       */    "[BRASILEIRO]",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(nacional)~Necess rio informar NACIONALIDADE",;
     /* help do campo */    "Entre com a nacionalidade";
                         };
)
AADD(sistema[022,O_CAMPO],{;            // FNCS
     /* mascara       */    "!A",;
     /* titulo        */    "Est.Civil",;
     /* cmd especial  */    "MTAB(tbestciv,[EST.CIVIL])",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "estciv $ tbestciv~EST.CIVIL n„o aceit vel.|Tecle F8 para busca em tabela",;
     /* help do campo */    "Entre com o estado civil ou tecle F8";
                         };
)
AADD(sistema[022,O_CAMPO],{;            // FNCS
     /* mascara       */    "@D",;
     /* titulo        */    "Idade",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    "Entre com a data de nascimento";
                         };
)
AADD(sistema[022,O_CAMPO],{;            // FNCS
     /* mascara       */    "@!",;
     /* titulo        */    "Endere‡o",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(endereco)~Necess rio informar Endere‡o",;
     /* help do campo */    "Informe o endere‡o do funcion rio";
                         };
)
AADD(sistema[022,O_CAMPO],{;            // FNCS
     /* mascara       */    "@!",;
     /* titulo        */    "Bairro",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    "Entre com o bairro";
                         };
)
AADD(sistema[022,O_CAMPO],{;            // FNCS
     /* mascara       */    "@!",;
     /* titulo        */    "Cidade",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(cidade)~Necess rio informar CIDADE",;
     /* help do campo */    "Entre com o nome do munic¡pio";
                         };
)
AADD(sistema[022,O_CAMPO],{;            // FNCS
     /* mascara       */    "@R 999.999.999-99",;
     /* titulo        */    "CPF",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "VDV2(cpf) .OR. EMPT(cpf)~CPF n„o aceit vel",;
     /* help do campo */    "";
                         };
)
AADD(sistema[022,O_CAMPO],{;            // FNCS
     /* mascara       */    "",;
     /* titulo        */    "Telefone",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    "";
                         };
)
AADD(sistema[022,O_CAMPO],{;            // FNCS
     /* mascara       */    "999.9",;
     /* titulo        */    "Percentual",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "nivelop=3",;
     /* validacao     */    "!(percent<0).AND.!(percent>100)~PERCENTUAL n„o aceit vel",;
     /* help do campo */    "Informe o percentual de comiss„o|caso o vendedor n„o receba por n£mero de parcelas";
                         };
)
AADD(sistema[022,O_CAMPO],{;            // FNCS
     /* mascara       */    "@S35",;
     /* titulo        */    "Observa‡„o",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    "";
                         };
)
AADD(sistema[022,O_FORMULA],{;          // FNCS - estado civil
     /* form mostrar  */    "LEFT(TRAN(SUBS(tbestciv,AT(estciv,tbestciv),11),[]),15)",;
     /* lin da formula*/    3,;
     /* col da formula*/    15;
                         };
)


sistema[023]={;
            "Hist¢rico Padr„o",;                            // opcao do menu
            "Hist¢rico Padr„o",;                            // titulo do sistema
            {"historico","codigo","codlan"},;               // chaves do arquivo
            {"Por C¢digo","C¢digo Estruturado","Cod.Lanc"},;// titulo dos indices para consulta
            {"01","06","08"},;                              // ordem campos chaves
            {"HISTORIC",drvdbf,drvntx},;                    // nome do DBF
            {"HISTORI1","HISTORI2","HISTORI3"},;            // nomes dos NTX
            {},;                                            // nome dos dbf's relacionados
            {},;                                            // campos de relacionamento
            {1,1,8,4,21,77,3,10},;                          // num telas/tela atual/coordenadas/inicio scroll/qtde scroll
            {1,.t.,.f.},;                                   // nivel acesso/tp chave/pede dir
            {},;                                            // campos do arquivo
            {},;                                            // formula mostradas
            {"origem=[ADM]","Registro utilizado por outro Sistema"},;// condicao de exclusao de registros
            {"orimgem=[ADM]","Registro mantido por outro sistema"},;// condicao de alteracao de registros
            {"",""};                                        // condicao de recupercao de registros
           }

AADD(sistema[023,O_CAMPO],{;            // HISTORIC
     /* mascara       */    "999",;
     /* titulo        */    "Hist",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(HISTORICO)~Este ‚ um campo de preenchimento obrigat¢rio.",;
     /* help do campo */    "Entre com um c¢digo para identificar| este hist¢rico.";
                         };
)
AADD(sistema[023,O_CAMPO],{;            // HISTORIC
     /* mascara       */    "",;
     /* titulo        */    "Descri‡„o de Hist¢rico",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "!EMPTY(historico)",;
     /* validacao     */    "!EMPT(DESCRICAO)~Informe uma DESCRI€ŽO para este c¢digo.",;
     /* help do campo */    "Entre com a identifica‡ao do Hist¢rico.|Ex.:Cheque, Dep¢sito, Pgto de Duplic., etc...";
                         };
)
AADD(sistema[023,O_CAMPO],{;            // HISTORIC
     /* mascara       */    "!",;
     /* titulo        */    "D/C",;
     /* cmd especial  */    "MTAB('D‚bito|Cr‚dito',[TIPO])",;
     /* default       */    "",;
     /* pre-validacao */    "!EMPTY(historico)",;
     /* validacao     */    "EMPTY(TIPO).OR.tipo$[DC]~ necess rio informar se TIPO ‚ D‚bito ou Cr‚dito.|D p/Pagamentos e C para recebimentos.",;
     /* help do campo */    "Este hist¢rico ‚ um D‚bito ou Cr‚dito|Se for D‚b., reduzir  no saldo da conta de|lan‡amento e acrescido na de baixa.";
                         };
)
AADD(sistema[023,O_CAMPO],{;            // HISTORIC
     /* mascara       */    "!!!",;
     /* titulo        */    "C/C",;
     /* cmd especial  */    "MTAB([ADMinistradora|FUNer ria|CONvenio|ESToque|FINanceiro|VIAtura],[ORIGEM])",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    "Informe o prefixo do sistema que|gerou o lan‡amento|O Centro de Custo";
                         };
)
AADD(sistema[023,O_CAMPO],{;            // HISTORIC
     /* mascara       */    "!",;
     /* titulo        */    "R/D",;
     /* cmd especial  */    "MTAB([Receita|Despesa|Transferˆncia],[R/D])",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "recdesp $ [RDT]~Receita/Despesa n„o aceit vel",;
     /* help do campo */    " Receita ou Despesa";
                         };
)
AADD(sistema[023,O_CAMPO],{;            // HISTORIC
     /* mascara       */    "@!",;
     /* titulo        */    "C¢digo",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    "Informe o c¢digo estruturado|para os lan‡amentos com |este hist¢rico.";
                         };
)
AADD(sistema[023,O_CAMPO],{;            // HISTORIC
     /* mascara       */    "99999999",;
     /* titulo        */    "Num.Lan‡amento",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[023,O_CAMPO],{;            // HISTORIC
     /* mascara       */    "!!!-99999999-999-999",;
     /* titulo        */    "Cod.Lan‡amento",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)


sistema[024]={;
            "Custos Adicionais",;                           // opcao do menu
            "Custos Adicionais",;                           // titulo do sistema
            {"DTOS(emissao_)","historic+contrato","contrato+circ","circ+contrato"},;// chaves do arquivo
            {"Ocorrencia","Hist¢rico","Contrato","N§Cobran‡a"},;// titulo dos indices para consulta
            {"01","0405","0510","1005"},;                   // ordem campos chaves
            {"CSTSEG",drvdbf,drvntx},;                      // nome do DBF
            {"CSTSEG1","CSTSEG2","CSTSEG3","CSTSEG4"},;     // nomes dos NTX
            {},;                                            // nome dos dbf's relacionados
            {},;                                            // campos de relacionamento
            {1,1,6,15,13,66},;                              // num telas/tela atual/coordenadas
            {1,.f.,.f.},;                                   // nivel acesso/tp chave/pede dir
            {},;                                            // campos do arquivo
            {},;                                            // formula mostradas
            {"",""},;                                       // condicao de exclusao de registros
            {"",""},;                                       // condicao de alteracao de registros
            {"",""};                                        // condicao de recupercao de registros
           }

AADD(sistema[024,O_CAMPO],{;            // CSTSEG
     /* mascara       */    "@D",;
     /* titulo        */    "Emiss„o",;
     /* cmd especial  */    "DATE()",;
     /* default       */    "date()",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(emissao_)~Necess rio informar DATA DE EMISSAO v lida",;
     /* help do campo */    "Informe a data da gera‡„o desta cobran‡a";
                         };
)
AADD(sistema[024,O_CAMPO],{;            // CSTSEG
     /* mascara       */    "99:99",;
     /* titulo        */    "Hora",;
     /* cmd especial  */    "",;
     /* default       */    "TIME()",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(hora)~Necess rio informar HORA",;
     /* help do campo */    "Informe a hora|Se necess rio";
                         };
)
AADD(sistema[024,O_CAMPO],{;            // CSTSEG
     /* mascara       */    "",;
     /* titulo        */    "Quem",;
     /* cmd especial  */    "",;
     /* default       */    "M->usuario",;
     /* pre-validacao */    "",;
     /* validacao     */    "V",;
     /* help do campo */    "";
                         };
)
AADD(sistema[024,O_CAMPO],{;            // CSTSEG
     /* mascara       */    "999",;
     /* titulo        */    "Hist¢rico",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "PTAB(historic,'HISTORIC',1)~Este ‚ um campo de preenchimento obrigat¢rio.|Tecle F8 para busca em tabela",;
     /* help do campo */    "Entre com um c¢digo para identificar| a cobran‡a";
                         };
)
AADD(sistema[024,O_CAMPO],{;            // CSTSEG
     /* mascara       */    "999999",;
     /* titulo        */    "Contrato",;
     /* cmd especial  */    "VDBF(6,26,20,77,'GRUPOS',{'grupo','codigo','nome'},1,'codigo')",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "PTAB(contrato,'GRUPOS',1)~Contrato inv lido |ou inexistente",;
     /* help do campo */    "Informe o n£mero do contrato";
                         };
)
AADD(sistema[024,O_CAMPO],{;            // CSTSEG
     /* mascara       */    "@!",;
     /* titulo        */    "Complemento",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(complement)~Entre com uma informa‡„o que diferencie este|lan‡amento de outros com mesmo hist¢rico.",;
     /* help do campo */    "Informe algo para identificar esta cobran‡a";
                         };
)
AADD(sistema[024,O_CAMPO],{;            // CSTSEG
     /* mascara       */    "99999",;
     /* titulo        */    "Qtdade",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "!(qtdade<0)~Informe uma quantidade v lida (>=0)",;
     /* help do campo */    "";
                         };
)
AADD(sistema[024,O_CAMPO],{;            // CSTSEG
     /* mascara       */    "999999.99",;
     /* titulo        */    "Valor",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "!(valor=0)~VALOR n„o aceit vel|Deve ser diferente de zeros",;
     /* help do campo */    "Informe o valor do servi‡o";
                         };
)
AADD(sistema[024,O_CAMPO],{;            // CSTSEG
     /* mascara       */    "9",;
     /* titulo        */    "Tipo",;
     /* cmd especial  */    "MTAB([1=J¢ia|2=Taxa|3=Carnˆ],[TIPO])",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    "Qual o tipo de lan‡amento";
                         };
)
AADD(sistema[024,O_CAMPO],{;            // CSTSEG
     /* mascara       */    "999",;
     /* titulo        */    "Circ",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "(PTAB(contrato+tipo+circ,'TAXAS',1).AND.TAXAS->valorpg=0).or.circ<[001]~Taxa n„o cadastrada,|ou,| j  paga.",;
     /* help do campo */    "Informe o n£mero da circular a consultar";
                         };
)


sistema[025]={;
            "Mensagem p/Contrato",;                         // opcao do menu
            "Mensagem p/Contrato",;                         // titulo do sistema
            {"seq"},;                                       // chaves do arquivo
            {"Sequencia"},;                                 // titulo dos indices para consulta
            {"01"},;                                        // ordem campos chaves
            {"MENSAG",drvdbf,drvntx},;                      // nome do DBF
            {"MENSAG1"},;                                   // nomes dos NTX
            {},;                                            // nome dos dbf's relacionados
            {},;                                            // campos de relacionamento
            {1,1,9,9,18,72},;                               // num telas/tela atual/coordenadas
            {1,.t.,.f.},;                                   // nivel acesso/tp chave/pede dir
            {},;                                            // campos do arquivo
            {},;                                            // formula mostradas
            {"",""},;                                       // condicao de exclusao de registros
            {"",""},;                                       // condicao de alteracao de registros
            {"",""};                                        // condicao de recupercao de registros
           }

AADD(sistema[025,O_CAMPO],{;            // MENSAG
     /* mascara       */    "999999",;
     /* titulo        */    "Sequˆncia",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(seq)~Necess rio informar SEQUENCIA",;
     /* help do campo */    "Informe o n£mero sequencial|os menores ser„o apresentados antes";
                         };
)
AADD(sistema[025,O_CAMPO],{;            // MENSAG
     /* mascara       */    "@S50",;
     /* titulo        */    "Crit‚rio",;
     /* cmd especial  */    "MEN_01F9()",;
     /* default       */    "MEN_01F9()",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(filtro)~Informe uma express„o v lida",;
     /* help do campo */    "Informe o crit‚rio de filtragem|para exibi‡„o da mensagem.";
                         };
)
AADD(sistema[025,O_CAMPO],{;            // MENSAG
     /* mascara       */    "@S50",;
     /* titulo        */    "Menssagem",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(mens1)~Informe a mensagem a apresentar,|tecle F7 para entrar e sair do campo",;
     /* help do campo */    "Informe a mensagem que ser  apresentada |na tela quando for satisfeita a condi‡„o informada";
                         };
)
AADD(sistema[025,O_CAMPO],{;            // MENSAG
     /* mascara       */    "@D",;
     /* titulo        */    "Lan‡amento",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[025,O_CAMPO],{;            // MENSAG
     /* mascara       */    "",;
     /* titulo        */    "Por",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[025,O_FORMULA],{;          // MENSAG - Lan‡amento
     /* form mostrar  */    "LEFT(TRAN(lancto_,[@D]),10)",;
     /* lin da formula*/    1,;
     /* col da formula*/    40;
                         };
)
AADD(sistema[025,O_FORMULA],{;          // MENSAG - mensagem1
     /* form mostrar  */    "LEFT(TRAN(MEMOLINE(MENSAG->mens1,50,1),[]),50)",;
     /* lin da formula*/    4,;
     /* col da formula*/    12;
                         };
)
AADD(sistema[025,O_FORMULA],{;          // MENSAG - MENSAGEM 2
     /* form mostrar  */    "LEFT(TRAN(MEMOLINE(MENSAG->mens1,50,2),[]),50)",;
     /* lin da formula*/    5,;
     /* col da formula*/    12;
                         };
)
AADD(sistema[025,O_FORMULA],{;          // MENSAG - MENSAGEM 3
     /* form mostrar  */    "LEFT(TRAN(MEMOLINE(MENSAG->mens1,50,3),[]),50)",;
     /* lin da formula*/    6,;
     /* col da formula*/    12;
                         };
)
AADD(sistema[025,O_FORMULA],{;          // MENSAG - MENSAGEM 4
     /* form mostrar  */    "LEFT(TRAN(MEMOLINE(MENSAG->mens1,50,4),[]),50)",;
     /* lin da formula*/    7,;
     /* col da formula*/    12;
                         };
)
AADD(sistema[025,O_FORMULA],{;          // MENSAG - MENSAGEM 5
     /* form mostrar  */    "LEFT(TRAN(MEMOLINE(MENSAG->mens1,50,5),[]),50)",;
     /* lin da formula*/    8,;
     /* col da formula*/    12;
                         };
)
AADD(sistema[025,O_FORMULA],{;          // MENSAG - Por
     /* form mostrar  */    "LEFT(TRAN(por,[]),10)",;
     /* lin da formula*/    1,;
     /* col da formula*/    51;
                         };
)


sistema[026]={;
            "Caixas",;                                      // opcao do menu
            "Caixas",;                                      // titulo do sistema
            {"numop","numconta+historico+DTOS(fechto_)","codlan"},;// chaves do arquivo
            {"p/N£mero","p/Conta","Cod.Lanc"},;             // titulo dos indices para consulta
            {"01","050613","19"},;                          // ordem campos chaves
            {"ORDPGRC",drvdbf,drvntx},;                     // nome do DBF
            {"ORDPGRC1","ORDPGRC2","ORDPGRC3"},;            // nomes dos NTX
            {},;                                            // nome dos dbf's relacionados
            {},;                                            // campos de relacionamento
            {1,1,7,12,20,71},;                              // num telas/tela atual/coordenadas
            {3,.t.,.f.},;                                   // nivel acesso/tp chave/pede dir
            {},;                                            // campos do arquivo
            {},;                                            // formula mostradas
            {"",""},;                                       // condicao de exclusao de registros
            {"",""},;                                       // condicao de alteracao de registros
            {"",""};                                        // condicao de recupercao de registros
           }

AADD(sistema[026,O_CAMPO],{;            // ORDPGRC
     /* mascara       */    "999999",;
     /* titulo        */    "N§ O.P.",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(numop)~Necess rio informar N§ O.P.",;
     /* help do campo */    "";
                         };
)
AADD(sistema[026,O_CAMPO],{;            // ORDPGRC
     /* mascara       */    "!!!",;
     /* titulo        */    "Origem",;
     /* cmd especial  */    "MTAB([ADMinistradora|FUNer ria|CONvenio|ESToque|FINanceiro|VIAtura],[ORIGEM])",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "origem $ [ADM|FUN|CON|EST|FIN|VIA]~ORIGEM n„o aceit vel",;
     /* help do campo */    "Informe o prefixo do sistema que|gerou o lan‡amento";
                         };
)
AADD(sistema[026,O_CAMPO],{;            // ORDPGRC
     /* mascara       */    "@D",;
     /* titulo        */    "Lancto_",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "V",;
     /* help do campo */    "";
                         };
)
AADD(sistema[026,O_CAMPO],{;            // ORDPGRC
     /* mascara       */    "",;
     /* titulo        */    "Por",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "V",;
     /* help do campo */    "";
                         };
)
AADD(sistema[026,O_CAMPO],{;            // ORDPGRC
     /* mascara       */    "@!",;
     /* titulo        */    "Conta",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(numconta)~Campo obrigat¢rio!|Identifique a Conta/Cadastro com um n£mero | ou nome qualquer.",;
     /* help do campo */    "Informe a conta que receber  este lan‡amento.";
                         };
)
AADD(sistema[026,O_CAMPO],{;            // ORDPGRC
     /* mascara       */    "999",;
     /* titulo        */    "Hist¢rico",;
     /* cmd especial  */    "VDBF(6,24,20,77,'HISTORIC',{'historico','descricao','tipo'},1,'historico',[HISTORIC->origem$']+origem+[   '])",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "EMPT(historico).OR.PTAB(historico,'HISTORIC',1)~HIST¢RICO n„o existe na tabela",;
     /* help do campo */    "Informe o hist¢rico do lan‡amento.";
                         };
)
AADD(sistema[026,O_CAMPO],{;            // ORDPGRC
     /* mascara       */    "!",;
     /* titulo        */    "D‚b/Cr‚d",;
     /* cmd especial  */    "MTAB([D‚bito|Cr‚dito],[DB/CRD])",;
     /* default       */    "HISTORIC->tipo",;
     /* pre-validacao */    "",;
     /* validacao     */    "debcred$[CD]~Necess rio informar DB/CRD",;
     /* help do campo */    "Se for um documento a pagar ser  D, sen„o C";
                         };
)
AADD(sistema[026,O_CAMPO],{;            // ORDPGRC
     /* mascara       */    "99999999.99",;
     /* titulo        */    "Valor Lan‡amento",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "!(VALORtotal<0.00)~VALOR TOTAL DO LAN€AMENTO| deve ser positivo ou zeros",;
     /* help do campo */    "Entre com o valor total do documento,|se valor = zero, ser  apenas agendado.";
                         };
)
AADD(sistema[026,O_CAMPO],{;            // ORDPGRC
     /* mascara       */    "@D",;
     /* titulo        */    "Vencto",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(vencto_)~Necess rio informar VENCTO",;
     /* help do campo */    "Entre com a data do vencimento deste.";
                         };
)
AADD(sistema[026,O_CAMPO],{;            // ORDPGRC
     /* mascara       */    "@!",;
     /* titulo        */    "Documento",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPTY(documento)~Digite algo para identificar o documento",;
     /* help do campo */    "Entre com o n£mero do documento";
                         };
)
AADD(sistema[026,O_CAMPO],{;            // ORDPGRC
     /* mascara       */    "99999",;
     /* titulo        */    "N§Doctos",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "!(nrdoctos<0)~N§DOCTOS n„o aceit vel",;
     /* help do campo */    "";
                         };
)
AADD(sistema[026,O_CAMPO],{;            // ORDPGRC
     /* mascara       */    "@!",;
     /* titulo        */    "Complemento de Hist¢rico",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(complement)~Entre com uma informa‡„o que diferencie este|lan‡amento de outros com mesmo hist¢rico.",;
     /* help do campo */    "";
                         };
)
AADD(sistema[026,O_CAMPO],{;            // ORDPGRC
     /* mascara       */    "@D",;
     /* titulo        */    "Fechto",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "V",;
     /* help do campo */    "";
                         };
)
AADD(sistema[026,O_CAMPO],{;            // ORDPGRC
     /* mascara       */    "",;
     /* titulo        */    "Fechpor",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "V",;
     /* help do campo */    "";
                         };
)
AADD(sistema[026,O_CAMPO],{;            // ORDPGRC
     /* mascara       */    "@D",;
     /* titulo        */    "Autorizado em",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "V",;
     /* help do campo */    "";
                         };
)
AADD(sistema[026,O_CAMPO],{;            // ORDPGRC
     /* mascara       */    "",;
     /* titulo        */    "Autorizado",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "V",;
     /* help do campo */    "";
                         };
)
AADD(sistema[026,O_CAMPO],{;            // ORDPGRC
     /* mascara       */    "9999999",;
     /* titulo        */    "Lan‡amento N§",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "V",;
     /* help do campo */    "";
                         };
)
AADD(sistema[026,O_CAMPO],{;            // ORDPGRC
     /* mascara       */    "99999999",;
     /* titulo        */    "Num.Lan‡amento",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[026,O_CAMPO],{;            // ORDPGRC
     /* mascara       */    "!!!-99999999-999-999",;
     /* titulo        */    "Cod.Lan‡amento",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[026,O_FORMULA],{;          // ORDPGRC - Descri‡„o de Hi
     /* form mostrar  */    "LEFT(TRAN(HISTORIC->descricao,[]),40)",;
     /* lin da formula*/    5,;
     /* col da formula*/    17;
                         };
)


sistema[027]={;
            "Parƒmetros",;                                  // opcao do menu
            "Parƒmetros do sistema",;                       // titulo do sistema
            {},;                                            // chaves do arquivo
            {},;                                            // titulo dos indices para consulta
            {},;                                            // ordem campos chaves
            {"PAR_ADM",drvdbf,drvntx},;                     // nome do DBF
            {},;                                            // nomes dos NTX
            {},;                                            // nome dos dbf's relacionados
            {},;                                            // campos de relacionamento
            {1,1,2,8,23,71},;                               // num telas/tela atual/coordenadas
            {2,.f.,.f.},;                                   // nivel acesso/tp chave/pede dir
            {},;                                            // campos do arquivo
            {},;                                            // formula mostradas
            {"",""},;                                       // condicao de exclusao de registros
            {"",""},;                                       // condicao de alteracao de registros
            {"",""};                                        // condicao de recupercao de registros
           }

AADD(sistema[027,O_CAMPO],{;            // PAR_ADM
     /* mascara       */    "!!",;
     /* titulo        */    "Grupo",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "V",;
     /* help do campo */    "";
                         };
)
AADD(sistema[027,O_CAMPO],{;            // PAR_ADM
     /* mascara       */    "@!",;
     /* titulo        */    "C¢digo",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    "Informe o c¢digo da filial";
                         };
)
AADD(sistema[027,O_CAMPO],{;            // PAR_ADM
     /* mascara       */    "999999",;
     /* titulo        */    "Codigo",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "V",;
     /* help do campo */    "";
                         };
)
AADD(sistema[027,O_CAMPO],{;            // PAR_ADM
     /* mascara       */    "9",;
     /* titulo        */    "Inscr.",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "V",;
     /* help do campo */    "";
                         };
)
AADD(sistema[027,O_CAMPO],{;            // PAR_ADM
     /* mascara       */    "99",;
     /* titulo        */    "Seq",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "V",;
     /* help do campo */    "";
                         };
)
AADD(sistema[027,O_CAMPO],{;            // PAR_ADM
     /* mascara       */    "!",;
     /* titulo        */    "Verificar Pagas?",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[027,O_CAMPO],{;            // PAR_ADM
     /* mascara       */    "!",;
     /* titulo        */    "Repetir lan‡amento?",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[027,O_CAMPO],{;            // PAR_ADM
     /* mascara       */    "999999",;
     /* titulo        */    "Maior Contrato",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[027,O_CAMPO],{;            // PAR_ADM
     /* mascara       */    "999999",;
     /* titulo        */    "N£mero",;
     /* cmd especial  */    "",;
     /* default       */    "000000",;
     /* pre-validacao */    "",;
     /* validacao     */    "V",;
     /* help do campo */    "";
                         };
)
AADD(sistema[027,O_CAMPO],{;            // PAR_ADM
     /* mascara       */    "999999",;
     /* titulo        */    "Nrreint",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "V",;
     /* help do campo */    "";
                         };
)
AADD(sistema[027,O_CAMPO],{;            // PAR_ADM
     /* mascara       */    "@!",;
     /* titulo        */    "Conta Recepcao",;
     /* cmd especial  */    "",;
     /* default       */    "[RECEP]",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(contarec)~Necess rio informar CONTA RECEPCAO p/recebimentos",;
     /* help do campo */    "Informe a Conta que receber |os lan‡amentos da recep‡„o.";
                         };
)
AADD(sistema[027,O_CAMPO],{;            // PAR_ADM
     /* mascara       */    "@!",;
     /* titulo        */    "Conta Pagamento",;
     /* cmd especial  */    "",;
     /* default       */    "[RECEP]",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(contapag)~Necess rio informar CONTA RECEPCAO p/Pagamentos",;
     /* help do campo */    "Informe a Conta que pagar |os lan‡amentos da recep‡„o.";
                         };
)
AADD(sistema[027,O_CAMPO],{;            // PAR_ADM
     /* mascara       */    "999",;
     /* titulo        */    "Hist¢rico",;
     /* cmd especial  */    "VDBF(6,24,20,77,'HISTORIC',{'historico','descricao','tipo'},1,'historico',[HISTORIC->origem$'ADM   '])",;
     /* default       */    "[004]",;
     /* pre-validacao */    "",;
     /* validacao     */    "histrccar=[000].OR. PTAB(histrccar,'HISTORIC',1)~HIST¢RICO n„o existe na tabela",;
     /* help do campo */    "Informe o hist¢rico do lan‡amento|para parcelas recebidas na Recep‡„o.";
                         };
)
AADD(sistema[027,O_CAMPO],{;            // PAR_ADM
     /* mascara       */    "999",;
     /* titulo        */    "Hist¢rico",;
     /* cmd especial  */    "VDBF(6,24,20,77,'HISTORIC',{'historico','descricao','tipo'},1,'historico',[HISTORIC->origem$'ADM   '])",;
     /* default       */    "[001]",;
     /* pre-validacao */    "",;
     /* validacao     */    "histrcfcc=[000].OR. PTAB(histrcfcc,'HISTORIC',1)~HIST¢RICO n„o existe na tabela",;
     /* help do campo */    "Informe o hist¢rico do lan‡amento de|recebimento de FCC.";
                         };
)
AADD(sistema[027,O_CAMPO],{;            // PAR_ADM
     /* mascara       */    "999",;
     /* titulo        */    "Hist¢rico",;
     /* cmd especial  */    "VDBF(6,24,20,77,'HISTORIC',{'historico','descricao','tipo'},1,'historico',[HISTORIC->origem$'ADM   '])",;
     /* default       */    "[002]",;
     /* pre-validacao */    "",;
     /* validacao     */    "histrcrec=[000].OR. PTAB(histrcrec,'HISTORIC',1)~HIST¢RICO n„o existe na tabela",;
     /* help do campo */    "Informe o hist¢rico do lan‡amento|para taxas recebidas na Recep‡„o.";
                         };
)
AADD(sistema[027,O_CAMPO],{;            // PAR_ADM
     /* mascara       */    "999",;
     /* titulo        */    "Hist¢rico",;
     /* cmd especial  */    "VDBF(6,24,20,77,'HISTORIC',{'historico','descricao','tipo'},1,'historico',[HISTORIC->origem$'ADM   '])",;
     /* default       */    "[003]",;
     /* pre-validacao */    "",;
     /* validacao     */    "histpg=[000].OR. PTAB(histpg,'HISTORIC',1)~HIST¢RICO n„o existe na tabela",;
     /* help do campo */    "Informe o hist¢rico|para lan‡amento de pagamentos.";
                         };
)
AADD(sistema[027,O_CAMPO],{;            // PAR_ADM
     /* mascara       */    "@R 99-999999",;
     /* titulo        */    "N§ Recibo",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(nrauxrec)~Necess rio informar N§ RECIBO",;
     /* help do campo */    "Informe o n£mero do recibo a imprimir.|no formato AA-NNNNNN|onde: AA=Ano, N=n£mero";
                         };
)
AADD(sistema[027,O_CAMPO],{;            // PAR_ADM
     /* mascara       */    "999999",;
     /* titulo        */    "Codigo",;
     /* cmd especial  */    "VDBF(6,26,20,77,'GRUPOS',{'grupo','codigo','nome'},1,'codigo',[situacao=1])",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "PTAB(mcodigo,'GRUPOS',1).AND.PTAB(mcodigo,'TAXAS',1).OR.mcodigo=[00000]~C¢digo inv lido ou sem Taxas pendentes",;
     /* help do campo */    "Informe o n£mero do contrato";
                         };
)
AADD(sistema[027,O_CAMPO],{;            // PAR_ADM
     /* mascara       */    "!",;
     /* titulo        */    "Tipo",;
     /* cmd especial  */    "MTAB([1=J¢ia|2=Taxa|3=Carnˆ|6=J¢ia+Seguro|7=Taxa+Seguro|8=Carnˆ+Seguro],[TIPO])",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "mtipo $ [123678]~TIPO n„o aceit vel",;
     /* help do campo */    "Qual o tipo de lan‡amento";
                         };
)
AADD(sistema[027,O_CAMPO],{;            // PAR_ADM
     /* mascara       */    "999",;
     /* titulo        */    "Circular",;
     /* cmd especial  */    "VDBF(6,22,20,77,'TAXAS',{'codigo','circ','emissao_','valor','valorpg','forma'},1,'circ',[])",;
     /* default       */    "",;
     /* pre-validacao */    "!(mcodigo=[00000])",;
     /* validacao     */    "PTAB(mcodigo+mcirc,'TAXAS',1).AND.PTAB(GRUPOS->grupo+mcirc,'CIRCULAR',1)~Necess rio informar CIRCULAR existente",;
     /* help do campo */    "N£mero da Circular|Mantido pela emissao de recibos";
                         };
)
AADD(sistema[027,O_CAMPO],{;            // PAR_ADM
     /* mascara       */    "!!",;
     /* titulo        */    "Grup",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "EMPT(mgrupvip).OR.PTAB(mgrupvip,'ARQGRUP',1)~GRUP n„o existe na tabela",;
     /* help do campo */    "Entre com o c¢digo do Grupo que ser  utilizado|como controle dos contratos VIPs.";
                         };
)
AADD(sistema[027,O_CAMPO],{;            // PAR_ADM
     /* mascara       */    "!",;
     /* titulo        */    "Combarra",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "combarra$'SN '~COMBARRA n„o aceit vel|Digite S ou N",;
     /* help do campo */    "Informe se os recibos devem ser impressos|com o c¢digo de barras";
                         };
)
AADD(sistema[027,O_CAMPO],{;            // PAR_ADM
     /* mascara       */    "!",;
     /* titulo        */    "Com Inscritos",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "cinscr$'SN '~Digite S ou N",;
     /* help do campo */    "Informe se os Inscritos estÆo cadastrados";
                         };
)
AADD(sistema[027,O_CAMPO],{;            // PAR_ADM
     /* mascara       */    "!",;
     /* titulo        */    "Com Falecido",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "comfalec$'SN '~Digite S para imprimir recibos com os|Falecidos da circular.",;
     /* help do campo */    "Informe se os recibos da recep‡Æo|devem ser impressos com os|falecidos (cartinha)";
                         };
)
AADD(sistema[027,O_CAMPO],{;            // PAR_ADM
     /* mascara       */    "99999",;
     /* titulo        */    "Processo",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[027,O_CAMPO],{;            // PAR_ADM
     /* mascara       */    "99",;
     /* titulo        */    "Ano",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[027,O_CAMPO],{;            // PAR_ADM
     /* mascara       */    "!!",;
     /* titulo        */    "Mproc3",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[027,O_CAMPO],{;            // PAR_ADM
     /* mascara       */    "99999",;
     /* titulo        */    "N£mero",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[027,O_CAMPO],{;            // PAR_ADM
     /* mascara       */    "@R 99999/99/!!",;
     /* titulo        */    "Procimp",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[027,O_CAMPO],{;            // PAR_ADM
     /* mascara       */    "@E 999,999.99",;
     /* titulo        */    "Valor",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[027,O_CAMPO],{;            // PAR_ADM
     /* mascara       */    "!!!",;
     /* titulo        */    "Cobrador",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[027,O_CAMPO],{;            // PAR_ADM
     /* mascara       */    "@R 99/99",;
     /* titulo        */    "Mˆs Ref.",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[027,O_CAMPO],{;            // PAR_ADM
     /* mascara       */    "",;
     /* titulo        */    "Pnumfcc",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[027,O_CAMPO],{;            // PAR_ADM
     /* mascara       */    "@!",;
     /* titulo        */    "Munic¡pio",;
     /* cmd especial  */    "",;
     /* default       */    "[LIMEIRA]",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(p_cidade)~Necess rio informar MUNIC¡PIO",;
     /* help do campo */    "Entre com o nome do Munic¡pio";
                         };
)
AADD(sistema[027,O_CAMPO],{;            // PAR_ADM
     /* mascara       */    "!",;
     /* titulo        */    "Recibo Padr„o",;
     /* cmd especial  */    "MTAB([S-Recibos em pap‚l branco|N-Recibos pr‚-impressos],[RECIBO PADRŽO])",;
     /* default       */    "[S]",;
     /* pre-validacao */    "",;
     /* validacao     */    "(p_recp$[SN ])~RECIBO PADRŽO n„o aceit vel|Digite S, N ou deixe sem preencher.",;
     /* help do campo */    "Digite S para utilizar o modelo|Padronizado de recibos (formul rio branco)|ou N para recibos personalizados";
                         };
)
AADD(sistema[027,O_CAMPO],{;            // PAR_ADM
     /* mascara       */    "",;
     /* titulo        */    "Ident1",;
     /* cmd especial  */    "",;
     /* default       */    "[Ind£stria de Urnas Bignotto Ltda]",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(setup1)~Digite o nome da Empresa|Ser  utilizado em relat¢rios",;
     /* help do campo */    "Informe o nome da Empresa";
                         };
)
AADD(sistema[027,O_CAMPO],{;            // PAR_ADM
     /* mascara       */    "@R 99.999.999/9999-99",;
     /* titulo        */    "CGC",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "VCGC(cgcsetup).or.EMPT(cgcsetup)~Necess rio informar CGC",;
     /* help do campo */    "";
                         };
)
AADD(sistema[027,O_CAMPO],{;            // PAR_ADM
     /* mascara       */    "",;
     /* titulo        */    "Ident2",;
     /* cmd especial  */    "Informe o endere‡o da Empresa",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(setup2)~Digite o endere‡o,|ser  a 2¦ linha de cabe‡alho|de alguns relat¢rios",;
     /* help do campo */    "Digite o endere‡o.";
                         };
)
AADD(sistema[027,O_CAMPO],{;            // PAR_ADM
     /* mascara       */    "",;
     /* titulo        */    "Setup3",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    "Informe a 3¦ linha de cabe‡alho.|Ex.: Telefone, Fax, etc...";
                         };
)
AADD(sistema[027,O_FORMULA],{;          // PAR_ADM - Desc.Pgto.
     /* form mostrar  */    "LEFT(TRAN(IIF(PTAB(histpg,'HISTORIC',1),HISTORIC->descricao,SPACE(40)),[]),40)",;
     /* lin da formula*/    5,;
     /* col da formula*/    22;
                         };
)
AADD(sistema[027,O_FORMULA],{;          // PAR_ADM - Desc.Recebto
     /* form mostrar  */    "LEFT(TRAN(IIF(PTAB(histrcrec,'HISTORIC',1),HISTORIC->descricao,SPACE(40)),[]),40)",;
     /* lin da formula*/    3,;
     /* col da formula*/    22;
                         };
)
AADD(sistema[027,O_FORMULA],{;          // PAR_ADM - Desc.Receb.FCC
     /* form mostrar  */    "LEFT(TRAN(IIF(PTAB(histrcfcc,'HISTORIC',1),HISTORIC->descricao,SPACE(40)),[]),40)",;
     /* lin da formula*/    2,;
     /* col da formula*/    22;
                         };
)
AADD(sistema[027,O_FORMULA],{;          // PAR_ADM - Descri‡„o de Hi
     /* form mostrar  */    "LEFT(TRAN(IIF(PTAB(histrccar,'HISTORIC',1),HISTORIC->descricao,SPACE(40)),[]),40)",;
     /* lin da formula*/    4,;
     /* col da formula*/    22;
                         };
)


sistema[nss-2]={;
            "Senhas",;                   // opcao do menu
            "Grupos de usu rios",;       // titulo do sistema
            {"pw_grupo"},;               // chaves do arquivo
            {"Codigo"},;                 // titulo dos indices para consulta
            {"01"},;                     // ordem campos chaves
            {"PWGRUPOS",drvpw,drvpw},;   // nome do DBF
            {"PWGRUPO1"},;               // nomes dos NTX
            {"PWTABELA","PWUSUA"},;      // nome dos dbf's relacionados
            {},;                         // campos de relacionamento
            {1,1,1,12,3,65},;            // num telas/tela atual/coordenadas
            {3,.t.,.f.},;                // nivel acesso/tp chave/pede dir
            {},;                         // campos do arquivo
            {},;// fromula { mascara, titulo, formula, linha, coluna }
            {"",""},;      // condicao de exclusao de registros
            {"",""},;      // condicao de alteracao de registros
            {"",""};       // condicao de recuperacao de registros
           }

AADD(sistema[nss-2,O_CAMPO],{;           // PWGRUPOS
     /* mascara       */    "9999",;
     /* titulo        */    "C¢digo",;
     /* cmd especial  */    "",;
     /* default       */    "1",;
     /* pre-validacao */    "",;
     /* validacao     */    "V",;
     /* help do campo */    "";
                         };
)
AADD(sistema[nss-2,O_CAMPO],{;           // PWGRUPOS
     /* mascara       */    "@!",;
     /* titulo        */    "Grupo",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(_nogrupo)~Necess rio informar GRUPO",;
     /* help do campo */    "";
                         };
)

sistema[nss-1]={;
            "Tabelas",;                  // opcao do menu
            "Tabelas",;                  // titulo do sistema
            {"pw_grupo+pw_dbf"},;        // chaves do arquivo
            {"Por Grupo"},;              // titulo dos indices para consulta
            {"0102"},;                   // ordem campos chaves
            {"PWTABELA",drvpw,drvpw},;   // nome do DBF
            {"PWTABEL1"},;               // nomes dos NTX
            {},;                         // nome dos dbf's relacionados
            {"PWGRUPOS->pw_grupo"},;     // campos de relacionamento
            {1,1,4,12,12,65,3,5},;       // num telas/tela atual/coordenadas/inicio scroll/qtde scroll
            {3,.t.,.f.},;                // nivel acesso/tp chave/pede dir
            {},;                         // campos do arquivo
            {},;// fromula { mascara, titulo, formula, linha, coluna }
            {"",""},;      // condicao de exclusao de registros
            {"",""},;      // condicao de alteracao de registros
            {"",""};       // condicao de recuperacao de registros
           }

AADD(sistema[nss-1,O_CAMPO],{;           // PWTABELA
     /* mascara       */    "9999",;
     /* titulo        */    "C¢digo",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[nss-1,O_CAMPO],{;           // PWTABELA
     /* mascara       */    "@S27",;
     /* titulo        */    "Arquivo",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(_dbf)~Necess rio informar ARQUIVO",;
     /* help do campo */    "";
                         };
)
AADD(sistema[nss-1,O_CAMPO],{;           // PWTABELA
     /* mascara       */    "@!",;
     /* titulo        */    "Permis”es",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    "DIGITE INICIAIS DAS ROTINAS CERCEADAS AO USURIO|"+;
                            "P. Procura    F. Filtragem    D. Digita‡„o     ÿ|"+;
                            "M. Modifica   E. Exclui       R. Recupera      ÿ|"+;
                            "V. Vˆ global  N. Nova coluna  A. Apaga coluna  ÿ|"+;
                            "I. Imprime    O. Ordena       Q. Quantifica    ÿ|"+;
                            "L. Localiza   G. Global       C. Congela Colunas|"+;
                            "T. Tamanho    J. nova Janela ÿX. eXporta       ÿ|"+;
                            "Z. totaliZa   B. marca linha                   ÿ|";
                         };
)
AADD(sistema[nss-1,O_CAMPO],{;           // PWTABELA
     /* mascara       */    "!",;
     /* titulo        */    "Flag",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)

sistema[nss]={;
            "Usu rios",;                               // opcao do menu
            "Usu rios",;                               // titulo do sistema
            {"pw_grupo+pw_codigo","pw_nome+pw_pass"},; // chaves do arquivo
            {"Por Grupo","Nome+pass"},;                // titulo dos indices para consulta
            {"0102","0306"},;                          // ordem campos chaves
            {"PWUSUA",drvpw,drvpw},;                   // nome do DBF
            {"PWUSUA1","PWUSUA2"},;                    // nomes dos NTX
            {},;                                       // nome dos dbf's relacionados
            {"PWGRUPOS->pw_grupo"},;                   // campos de relacionamento
            {1,1,13,12,23,65,3,7},;                    // num telas/tela atual/coordenadas/inicio scroll/qtde scroll
            {3,.f.,.f.},;                              // nivel acesso/tp chave/pede dir
            {},;                                       // campos do arquivo
            {},;// fromula { mascara, titulo, formula, linha, coluna }
            {"",""},;      // condicao de exclusao de registros
            {"",""},;      // condicao de alteracao de registros
            {"",""};       // condicao de recuperacao de registros
           }

AADD(sistema[nss,O_CAMPO],{;            // PWUSUA
     /* mascara       */    "9999",;
     /* titulo        */    "C¢digo",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[nss,O_CAMPO],{;            // PWUSUA
     /* mascara       */    "9999",;
     /* titulo        */    "C¢digo",;
     /* cmd especial  */    "",;
     /* default       */    "1",;
     /* pre-validacao */    "",;
     /* validacao     */    "V",;
     /* help do campo */    "";
                         };
)
AADD(sistema[nss,O_CAMPO],{;            // PWUSUA
     /* mascara       */    "@!",;
     /* titulo        */    "Nome",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(_nome)~Necess rio informar NOME",;
     /* help do campo */    "";
                         };
)
AADD(sistema[nss,O_CAMPO],{;            // PWUSUA
     /* mascara       */    "9",;
     /* titulo        */    "Nivel",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "MTAB([1. Opera‡„o|2. Manuten‡„o|3. Gerˆncia],[N¡VEL DE ACESSO])",;
     /* validacao     */    "VAL(_nivel)>0~NIVEL n„o aceit vel",;
     /* help do campo */    "";
                         };
)
AADD(sistema[nss,O_CAMPO],{;            // PWUSUA
     /* mascara       */    "",;
     /* titulo        */    "Obs",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    "";
                         };
)
AADD(sistema[nss,O_CAMPO],{;            // PWUSUA
     /* mascara       */    "",;
     /* titulo        */    "PW",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[nss,O_CAMPO],{;            // PWUSUA
     /* mascara       */    "!",;
     /* titulo        */    "Flag",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)

* \\ Final de ADR_ATR2.PRG
procedure gui_04f9
/*
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
 \ Empresa.: PresServ Inform tica - Limeira (019)452.6623
 \ Programa: GUI_04F9.PRG
 \ Data....: 23-05-98
 \ Sistema.: Administradora - RECEP€„O
 \ Funcao..: F¢rmula (circ 1-4) a mostrar na tela de GUIAS
 \ Analista: Ademilson Pedro Bom
 \ Criacao.: Programado manualmente pelo analista 
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/
#include "adrbig.ch"    // inicializa constantes manifestas

/*
   -------------------------------------------------------------------
   Se abrir outros arquivos salve situacao anterior e restaure ao sair
   como no exemplo abaixo:
     LOCAL reg_dbf:=POINTER_DBF()
     ...        ...        ...        ...
     POINTER_DBF(reg_dbf)
     RETU
   -------------------------------------------------------------------
*/
RETU       // <- deve retornar um valor qualquer

* \\ Final de GUI_04F9.PRG
/*
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
 \ Empresa.: PresServ Inform tica - Limeira (019)452.6623
 \ Programa: ADR_MENU.PRG
 \ Data....: 22-01-08
 \ Sistema.: Administradora - RECEP€„O
 \ Funcao..: Menu geral da aplica‡„o
 \ Analista: Ademilson Pedro Bom
 \ Criacao.: GAS-Pro v4.0o
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/

#include "adrbig.ch"    // inicializa constantes manifestas

opc_01=1
v01=SAVESCREEN(0,0,MAXROW(),79)
DO WHIL opc_01!=0
 cod_sos=3
 RESTSCREEN(0,0,MAXROW(),79,v01)
 menu01="Lan‡amentos~1|"+;
        "A.Funeral~2|"+;
        "Relat¢rios~3|"+;
        "Tabelas~4|"+;
        "Apoio~5"
 opc_01=DBOX(menu01,0,,E_POPMENU,NAO_APAGA,,,,opc_01)
 BEGIN SEQUENCE
  DO CASE
   CASE opc_01=0      // retornar ao DOS
    ALERTA()
    msgt="ENCERRAMENTO"
    msg ="Finalizar opera‡”es|N„o finalizar"
    cod_sos=1
    op_=DBOX(msg,,,E_MENU,,msgt,,,1)
    IF op_!=1
     opc_01=1
    ENDI

   CASE opc_01=1     // lan‡amentos
    opc_02=1
    v02=SAVESCREEN(0,0,MAXROW(),79)
    DO WHIL opc_02!=0
     cod_sos=4
     RESTSCREEN(0,0,MAXROW(),79,v02)
     menu02="Recebimentos~1|"+;
            "Endere‡os~2|"+;
            "Outros Recebimentos~3|"+;
            "Consulta Contratos~4|"+;
            "Emiss„o de Guias~5|"+;
            "Avisos / Carencias~6|"+;
            "Cartinha/Falecidos~7|"+;
            "Ajuda Procedimentos~8"
     msgt="LAN€AMENTOS"
     ROLAPOP(1)
     opc_02=DBOX(menu02,1,2,E_MENU,NAO_APAGA,msgt,,,opc_02)
     ROLAPOP()
     DO CASE
      CASE opc_02=1     // recebimentos
       BXREC(3,10)

      CASE opc_02=2     // endere‡os
       ALENDER(3,10)

      CASE opc_02=3     // outros recebimentos
       OBXEC(3,10)

      CASE opc_02=4     // consulta contratos
       GRUPOS(3,10)

      CASE opc_02=5     // emiss„o de guias
       GUIAS(3,10)

      CASE opc_02=6     // avisos / carencias
       MFILIAL(3,10)

      CASE opc_02=7     // Cartinha de Falecidos
       ADP_R101(3,10)

      CASE opc_02=8     // Ajuda aos Procedimentos
       ADR_MANU(3,10)

arqx_:=[\_]+alltrim(M->rgrupo)+[.txt]
IF FILE(arqx_)
 txtini:=MEMOREAD(arqx_) // texto inicial do grupo "_A.TXT"
ENDI
     FOR contx:=1 to 6  // maximo de linhas de mensagem inicial
  		REL_CAB(3)                                     // soma cl/imprime cabecalho
      @ cl,002 SAY MEMOLINE(txtini,70,contx)         // Mensagem
     NEXT contx

     ENDC
     CLEA GETS
     CLOS ALL
    ENDD

   CASE opc_01=2     // a.funeral
    opc_02=1
    v02=SAVESCREEN(0,0,MAXROW(),79)
    DO WHIL opc_02!=0
     cod_sos=4
     RESTSCREEN(0,0,MAXROW(),79,v02)
     menu02="Lan‡amento Aux.Funeral~1|"+;
            "Impress„o Modelo 1~2|"+;
            "Recibo Modelo 1~3|"+;
            "Impress„o Modelo 2~4|"+;
            "Recibo Modelo 2~5|"+;
            "Relat¢rio de Processo~6|"+;
            "Capa de Processo~7|"+;
            "Processar Pgto em~8"
     msgt="A.FUNERAL"
     ROLAPOP(1)
     opc_02=DBOX(menu02,1,15,E_MENU,NAO_APAGA,msgt,,,opc_02)
     ROLAPOP()
     DO CASE
      CASE opc_02=1     // lan‡amento aux.funeral
       AFUNER(3,23)

      CASE opc_02=2     // impress„o modelo 1
       ADM_R020(3,23)

      CASE opc_02=3     // recibo modelo 1
       ADR_R029(3,23)

      CASE opc_02=4     // impress„o modelo 2
       ADM_RX20(3,23)

      CASE opc_02=5     // recibo modelo 2
       ADR_RX29(3,23)

      CASE opc_02=6     // relat¢rio de processo
       ADM_R029(3,23)

      CASE opc_02=7     // capa de processo
       ADM_R026(3,23)

      CASE opc_02=8     // processar pgto em
       ADM_R021(3,23)

     ENDC
     CLEA GETS
     CLOS ALL
    ENDD

   CASE opc_01=3     // relat¢rios
    opc_02=1
    v02=SAVESCREEN(0,0,MAXROW(),79)
    DO WHIL opc_02!=0
     cod_sos=4
     RESTSCREEN(0,0,MAXROW(),79,v02)
     menu02="Documento … Imprimir~1|"+;
            "Recibos (2¦via)~2|"+;
            "Outros recibos (2¦Via)~3|"+;
            "Endere‡os Alterados~4|"+;
            "Emissao de guia~5|"+;
            "Fechamento Caixa~6|"+;
            "Ficha de Acerto~7"
     msgt="RELAT¢RIOS"
     ROLAPOP(1)
     opc_02=DBOX(menu02,1,26,E_MENU,NAO_APAGA,msgt,,,opc_02)
     ROLAPOP()
     DO CASE
      CASE opc_02=1     // documento … imprimir
       DCI_P001(3,34)

      CASE opc_02=2     // recibos (2¦via)
       ADM_RS18(3,34)

      CASE opc_02=3     // outros recibos (2¦via)
       ADM_R023(3,34)

      CASE opc_02=4     // endere‡os alterados
       ADM_R022(3,34)

      CASE opc_02=5     // emissao de guia
       cod_sos=1
       CON_RX01(3,34)

      CASE opc_02=6     // fechamento caixa
       ADM_R039(3,34)

      CASE opc_02=7     // ficha de acerto
       ADC_RX76(3,34)

     ENDC
     CLEA GETS
     CLOS ALL
    ENDD

   CASE opc_01=4     // tabelas
    opc_02=1
    v02=SAVESCREEN(0,0,MAXROW(),79)
    DO WHIL opc_02!=0
     cod_sos=4
     RESTSCREEN(0,0,MAXROW(),79,v02)
     menu02="Documento … Imprimir~1|"+;
            "Credenciados~2|"+;
            "Especialidades~3|"+;
            "Parƒmetro de Juros~4|"+;
            "Filiais~5|"+;
            "Grupos~6|"+;
            "Tabelas Secund rias~7|"+;
            "Caixas~8"
     msgt="TABELAS"
     ROLAPOP(1)
     opc_02=DBOX(menu02,1,38,E_MENU,NAO_APAGA,msgt,,,opc_02)
     ROLAPOP()
     DO CASE
      CASE opc_02=1     // documento … imprimir
       IMPPAR(3,46)

      CASE opc_02=2     // credenciados
       MEDICOS(3,46)

      CASE opc_02=3     // especialidades
       TESPEC(3,46)

      CASE opc_02=4     // parƒmetro de juros
       JUROS(3,46)

      CASE opc_02=5     // filiais
       TFILIAIS(3,46)

      CASE opc_02=6     // grupos
       ARQGRUP(3,46)

      CASE opc_02=7     // tabelas secund rias
       opc_03=1
       v03=SAVESCREEN(0,0,MAXROW(),79)
       DO WHIL opc_03!=0
        cod_sos=4
        RESTSCREEN(0,0,MAXROW(),79,v03)
        menu03="Regi”es~1|"+;
               "Cobradores/Vendedores~2|"+;
               "Categoria dos Planos~3|"+;
               "Circulares~4|"+;
               "Processos~5|"+;
               "Funcion rios~6|"+;
               "Hist¢rico Padr„o~7|"+;
               "Custos Adicionais~8|"+;
               "Mensagem p/Contrato~9"
        msgt="TABELAS SECUNDRIAS"
        opc_03=DBOX(menu03,3,46,E_MENU,NAO_APAGA,msgt,,,opc_03)
        DO CASE
         CASE opc_03=1     // regi”es
          REGIAO(5,54)

         CASE opc_03=2     // cobradores/vendedores
          COBRADOR(5,54)

         CASE opc_03=3     // categoria dos planos
          CLASSES(5,54)

         CASE opc_03=4     // circulares
          CIRCULAR(5,54)

         CASE opc_03=5     // processos
          PRCESSOS(5,54)

         CASE opc_03=6     // funcion rios
          FNCS(5,54)

         CASE opc_03=7     // hist¢rico padr„o
          HISTORIC(5,54)

         CASE opc_03=8     // custos adicionais
          CSTSEG(5,54)

         CASE opc_03=9     // mensagem p/contrato
          MENSAG(5,54)

        ENDC
        CLEA GETS
        CLOS ALL
       ENDD

      CASE opc_02=8     // caixas
       ORDPGRC(3,46)

     ENDC
     CLEA GETS
     CLOS ALL
    ENDD

   CASE opc_01=5     // apoio
    opc_02=1
    v02=SAVESCREEN(0,0,MAXROW(),79)
    DO WHIL opc_02!=0
     op_menu=PROJECOES
     cod_sos=9
     RESTSCREEN(0,0,MAXROW(),79,v02)
     menu02="Parƒmetros~1|"+;
            "Vˆ relat¢rio gravado~2|"+;
            "Reconstr¢i ¡ndices~3|"+;
            "Elimina reg apagados~4|"+;
            "Configura ambiente~5|"+;
            "Plano de senhas~6|"+;
            "Sobre...~7"
     msgt="APOIO"
     ROLAPOP(1)
     opc_02=DBOX(menu02,1,47,E_MENU,NAO_APAGA,msgt,,,opc_02)
     ROLAPOP()
     DO CASE
      CASE opc_02=1     // parƒmetros
       PAR_ADM(3,55)

      CASE opc_02=2     // vˆ relat¢rio gravado
       VE_REL()

      CASE opc_02=3     // reconstr¢i ¡ndices
       cod_sos=39
       RCLA()

      CASE opc_02=4     // elimina reg apagados
       cod_sos=40
       COMPACTA()

      CASE opc_02=5     // configura ambiente
       opc_03=1
       v03=SAVESCREEN(0,0,MAXROW(),79)
       DO WHIL opc_03!=0
        cod_sos=41
        RESTSCREEN(0,0,MAXROW(),79,v03)
        menu03="ÿ Diret¢rio de trabalho~1|"+;
               "ÿ Marca da impressoraÿÿ~2|"+;
               "ÿ Pano de fundoÿÿÿÿÿÿÿÿ~3|"+;
               "ÿ Fontes de caracteresÿ~4|"+;
               "ÿ Esquemas de coresÿÿÿÿ~5|"+;
               IF(drvconf,"û ","ÿ ")+"Confirma em camposÿÿÿ~6|"+;
               IF(drvexcl,"û ","ÿ ")+"Confirma exclus”esÿÿÿ~7|"+;
               IF(drvincl,"û ","ÿ ")+"Confirma inclus”esÿÿÿ~8|"+;
               IF(drvvisivel,"û ","ÿ ")+"Excluidos vis¡veisÿÿÿ~9|"+;
               IF(drvautohelp,"û ","ÿ ")+"Ajuda de campo ativaÿ~10|"+;
               IF(drvmouse,"û ","ÿ ")+"Liga/desliga mouseÿÿÿ~11|"+;
               "ÿ Sensibilidade mouseÿÿ~12"
        msgt="CONFIGURA AMBIENTE"
        opc_03=DBOX(menu03,3,55,E_MENU,NAO_APAGA,msgt,,,opc_03)
        DO CASE
         CASE opc_03=1     // diret¢rio de trabalho
          cod_sos=2
          PEGADIR(.f.)

          SAVE TO (arqconf) ALL LIKE drv*          // grava configuracoes,
          CBC1()                                   // monta tela principal e
          v01=SAVESCREEN(0,0,MAXROW(),79)          // salva para o break
          BREAK                                    // que foi configurado
         CASE opc_03=2     // marca da impressora
          CONFPRN()

         CASE opc_03=3     // pano de fundo
          cod_sos=43; msg=""                       // menu de caracteres para fundo
          FOR t=1 TO 255                           // enche msg com as opcoes
           IF t!=124                               // exceto o '|` que e o
            msg+="|"+STR(t,3)+" - "+CHR(t)         // caracter separador das
           ENDI                                    // opcoes da DBOX(
          NEXT
          t=ASC(drvcara)-IF(ASC(drvcara)>123,1,0)
          op_x=DBOX(SUBS(msg,2),,63,E_MENU,,"FUNDO",,,t)
          IF op_x!=0                               // escolhido um caracter
           op_x+=IF(op_x>123,1,0)                  // desconta o '|`
           IF drvcara!=CHR(op_x)                   // se caracter
            drvcara=CHR(op_x)                      // diferente do atual
            SAVE TO (arqconf) ALL LIKE drv*        // grava configuracoes,
            CBC1()                                 // monta tela principal e
            v01=SAVESCREEN(0,0,MAXROW(),79)        // salva para o break
            BREAK                                  // que foi configurado
           ENDI
          ENDI

         CASE opc_03=4     // fontes de caracteres
          op_x=1; cod_sos=53
          msgf=MUDAFONTE(999)
          DO WHILE op_x!=0 .AND.LEN(msgf)>0
           msgf=STRTRAN(msgf,CHR(251)," ")
           msgf=LEFT(msgf,13*drvfonte)+CHR(251)+SUBS(msgf,13*drvfonte+2)
           op_x=DBOX(msgf,05,63,E_MENU,,"FONTES",,,drvfonte+1)
           IF op_x>0
            drvfonte=op_x-1
            MUDAFONTE(drvfonte)
           ENDI
          ENDD

         CASE opc_03=5     // esquemas de cores
          CONFCORES()

         CASE opc_03=6     // confirma em campos
          drvconf=!drvconf
          SET(_SET_CONFIRM,drvconf)

         CASE opc_03=7     // confirma exclus”es
          drvexcl=!drvexcl

         CASE opc_03=8     // confirma inclus”es
          drvincl=!drvincl

         CASE opc_03=9     // excluidos vis¡veis
          drvvisivel=!drvvisivel
          SET(_SET_DELETED,!drvvisivel)

         CASE opc_03=10     // ajuda de campo ativa
          drvautohelp=!drvautohelp

         CASE opc_03=11     // liga/desliga mouse
          IF MOUSE()>0
           drvmouse=!drvmouse
          ENDI

          #ifdef COM_TUTOR
           IF acao_mac!="D"
            drvmouse=.f.
           ENDI
          #endi

         CASE opc_03=12     // sensibilidade mouse
          cod_sos=45
          AJMOUSE()

        ENDC
        CLEA GETS
        CLOS ALL
       ENDD
       SAVE TO (arqconf) ALL LIKE drv*             // diferente do atual

      CASE opc_02=6     // plano de senhas
       cod_sos=17
       MASENHA(1,55)
      CASE opc_02=7     // sobre...
       cod_sos=1
       ABOUT(3,55)

     ENDC
     CLEA GETS
     CLOS ALL
    ENDD

  ENDC
 END
 CLEA GETS
 CLOS ALL
ENDD

RETU

* \\ Final de ADR_MENU.PRG
€	 KINSCF9y–Ð  KINSCF9CODEC_ETEXTENDCODE	_SYMSTARTSYMSTARTSYMBOLSSYMBOLS_SYMENDSYMENDNULLBEGDATA_DATADATA_SYMPBDATA_SYMPDATA_SYMPEDATA_CONSTCONST_MSGMSG_BEGBSSBEGBSS_BSSBSS_ENDBSSENDBSSDGROUP8˜ @' ô˜ H  ˜ h  ë˜ `@ 	¯˜ h  
ã˜ h  ß˜ H  û˜ H  ÷˜ H ë˜ H  ï˜ H  ë˜ (  ˜ H  € ABOUTù–Î  ABOUTCODEC_ETEXTENDCODE	_SYMSTARTSYMSTARTSYMBOLSSYMBOLS_SYMENDSYMENDNULLBEGDATA_DATADATA_SYMPBDATA_SYMPDATA_SYMPEDATA_CONSTCONST_MSGMSG_BEGBSSBEGBSS_BSSBSS_ENDBSSENDBSSDGROUP¸˜ @}›˜ H  ˜ h  ë˜ ` 	N˜ h  
ã˜ h  ß˜ H  û˜ H  ÷˜ H ë˜ H  ï˜ H  ë˜ (  ˜ H  procedure rec_01f9
/*
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
 \ Empresa.: PresServ Inform tica-Limeira (019)452.6623
 \ Programa: REC_01F9.PRG
 \ Data....: 14-11-95
 \ Sistema.: Administradora de Funer rias
 \ Funcao..: Valida‡„o do campo ENDERECO, arquivo RECIBOS
 \ Analista: Ademilson Pedro Bom
 \ Criacao.: Programado manualmente pelo analista
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/

#include "admbig.ch"    // inicializa constantes manifestas


PARAMETROS('impnrrec',numero)
PARAMETROS('mproc1',LEFT(processo,5))
PARAMETROS('mproc2',RIGHT(processo,2))
RETU .T.  // <- deve retornar um valor L¢GICO

* \\ Final de REC_01F9.PRG
MZ@[­€  ÿÿÔE               /   +  Ç)  +  Y.  ’   ƒ*  ž*  ¹*  î*  c+  .  á  Œ  ”  (+  —   Ñ  *  5.  €)  #.  D/  -  †)  )  Í)  ×)  *  *  [*  e*  ô*  +  .+  ;+  i+  v+  å+  ;   Í   €  Ù  ²   C   Ò   P  d  ‰  ê  ö  š  ¸   ÿ  G.  #-  R	  Š	  Å  U*     »   Ý+  ‹   .  -.  ?.  Q.  c.  )  Ô)  *  b*  û*  5+  p+  x)  ¿)  *  M*  ~*  ™*  ´*  .  [  õõGõÕõ$õ0 õ=õ4õ¬õÇõˆõLõ1õ{ õ© õRõÎõJõßõžõ¸õõëõbõ|õ–õõõ» õÅ õ&õ­õLõXõíõ¬õÆõpõŠõ¤õ…õqõõÕõèõ´õÇõÚõvõwõœõdõ}õMõ_õ õ&õ<õ™õùõÈõõqõi ©~©©èÕ¤9>'›åÉ&bÁ Žž ŽùŽÊŽprocedure r03001f9
/*
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
 \ Empresa.: PresServ Inform tica-Limeira (019)452.6623
 \ Programa: R03001F9.PRG
 \ Data....: 02-08-96
 \ Sistema.: Administradora de Funer rias
 \ Funcao..: N' OP. do relat¢rio ADM_R030
 \ Analista: Ademilson Pedro Bom
 \ Criacao.: Programado manualmente pelo analistad
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/

#include "adrbig.ch"    // inicializa constantes manifestas

nucop:=2
RETU []       // <- deve retornar um valor qualquer

* \\ Final de R03001F9.PRG
/*
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
 \ Empresa.: PresServ Inform tica - Limeira (019)452.6623
 \ Programa: ADRBIG.CH
 \ Data....: 29-01-04
 \ Sistema.: Administradora - RECEP€„O
 \ Funcao..: Inicializa constantes do sistema
 \ Analista: Ademilson Pedro Bom
 \ Criacao.: GAS-Pro v4.0o
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/
#include "inkey.ch"          // constantes de codigos das teclas
#include "Fileio.ch"         // funcoes de leitura/gravacao de arquivo
#include "set.ch"            // constantes da funcao SETKEY()

#define NIV_CRI_LIVRE 2      // define quem podera acessar o criterio livre

/*
   As diretivas (#define) a seguir referem-se a configuracao da aplicacao

   COM_MAQCALC  cria "pop calculadora" acionada atraves da tecla F5
   COM_CALE ... cria "pop calendario"  acionado atraves da tecla F6
   COM_PROTECAO protege os arquivos ao acesso interativo dBASE
   COM_REDE ... prepara o sistema para operar em rede (multiusuario)
   COM_MOUSE .. prepara programa para funcionar com mouse (se existir)
   COM_TUTOR .. prepara aplicacao para gravar/ler macro (tutoriais)
   COM_LOCK.... cria protecao contra c¢pia
*/
#define COM_CALE
#define COM_MAQCALC
#define COM_REDE
#define COM_MOUSE
#define COM_TUTOR

/*
   Define variaveis a serem usadas na integridade referencial de
   arquivos subordinados (pai e filhos)
*/
#define INCLUI       0       // inclusao de novos registros
#define EXCLUI       1       // exclusao de registros
#define RECUPERA     2       // recupera registros
#define FORM_INVERSA 3       // exclui registros executando formula inversa
#define FORM_DIRETA  4       // recupera registros executando formula direta
#define POSICIONA    5       // abre/posicionas os arquvios relacionados

/*
   Define variaveis a serem usadas na integridade referencial em
   tabelas PTAB()
*/
#define INCREMENTA .t.       // incrementa campo INTREF do arquivo pesquisado
#define DECREMENTA .f.       // decrementa campo INTREF do arquivo pesquisado

/*
   Opcoes atribuidas `a variavel do menu de cadastramento (op_menu)
*/
#define INCLUSAO  1          // inclusao de registros
#define ALTERACAO 2          // alteracao de registros (proc edit)
#define PROJECOES 3          // consulta/tela paginada (funcao edita())
#define VAR_COMPL 4          // tela de variaveis complementares
#define TEL_EXTRA 5          // tela complemetar


/*
   Ativa atributo do esquema de cor corrente
*/
#define COR_PADRAO 0         // cor padrao (drvcorpad)
#define COR_GET    1         // cor do campo/menu (drvcorget)

/*
   tipos de video para funcao cardtype()
*/
#define V_CGA   0            // video cga
#define V_MONO  1            // video mono/hercules
#define V_EGA   2            // video ega
#define V_VGA   3            // video vga

/*
   Define variaveis a serem usadas na funcao DBOX() - 'caixa de dialogo`
*/
#define E_MENU .t.           // monta menu de barra
#define E_POPMENU .f.        // monta menu pop-down
#define NAO_APAGA .f.        // nao apagar janela ao selecionar

/*
   tratamento do mouse
*/
#define ESQUERDO    1        // botao esquerdo
#define DIREITO     2        // botao direito
#define CLICK    -100        // botao esquerdo foi clicado

/*
   Define variaveis usadas para facilitar a identificacao dentro
   do vetos sistema[]
*/
#define O_MENU      1   // titulo reduzido para menus
#define O_MENS      2   // titulo do menu de subsistemas
#define O_CHAVE     3   // chaves do arquivos
#define O_CONSU     4   // titulos para menus dos indices de consulta
#define O_ORDEM     5   // numeros sequenciais dos campos nos arqs indices
#define O_ARQUI     6   // nome do arquivo de dados
#define   O_NOME    1   // nome do arquivo de dados
#define   O_DIR_DBF 2   // diretorio do arquivo de dados
#define   O_DIR_NTX 3   // diretorio do arquivo de dados
#define O_INDIC     7   // nomes dos arquivos indices
#define O_DBRELA    8   // nome dos arquivos relacionados
#define O_CPRELA    9   // campos do relacionamento
#define O_TELA     10   // definicao da tela
#define   O_DEF     1   // numero de telas definidas
#define   O_ATUAL   2   // numero da tela atual
#define   O_LS      3   // linha superior da janela
#define   O_CS      4   // coluna superior da janela
#define   O_LI      5   // linha inferior da janela
#define   O_CI      6   // coluna inferior da janela
#define   O_SCROLL  7   // linha onde comeca o scroll
#define   O_QTDE    8   // quantas linhas vao rolar
#define O_OUTROS   11   // miscelanea
#define   O_NIVEL   1   // nivel de acesso do subsistema
#define   O_TPCHV   2   // tipo de chave primaria/nao primaria
#define   O_PEDEDIR 3   // pede diretorio do arquivo
#define O_CAMPO    12   // atributos dos campos do subsistema
#define   O_MASC    1   // mascara do campo
#define   O_TITU    2   // titulo do campo
#define   O_CMD     3   // comando especial (f8)
#define   O_DEFA    4   // default para o campo
#define   O_WHEN    5   // clausula when (pre validacao)
#define   O_CRIT    6   // expressao de validacao (critica)
#define   O_HELP    7   // texto de ajuda on-line do campo
#define O_FORMULA  13   // atributos das formulas do subsistema
#define   O_FORM    1   // formula a mostrar
#define   O_LINHA   2   // linha onde a formula sera' mostrada
#define   O_COLUNA  3   // coluna onde a formula sera' mostrada
#define O_CONDEXC 14    // condicao p/ exclusao de registros
#define O_CONDALT 15    // condicao p/ alteracao de registros
#define O_CONDREC 16    // condicao p/ recuperacao de registros

/*
   Comandos criados para auxiliar o comando GET para receber mais outros
   parametro e armazenar na variavel de instancia "CARGO". Este artificio
   e' usado para guardar o texto de ajuda e o comando a executrar quando
   a techa F8 for pressionada, o valor inicial e as formulas que serao
   mostrada apos a digitacao do campo
*/
#command AJUDA <var>     =>  STORECARGO(<var>,ATAIL(getlist),1)
#command CMDF8 <var>     =>  STORECARGO(<var>,ATAIL(getlist),2)
#command DEFAULT <var>   =>  STORECARGO(<var>,ATAIL(getlist),3)
#command MOSTRA <var>    =>  STORECARGO(<var>,ATAIL(getlist),4)
#command DEFINICAO <cp>  =>  STOREALL(<cp>,ATail(GetList))

#ifdef COM_TUTOR
 #command KEYBOARD <c>                                           ;
                          => if acao_mac="G" .OR. acao_mac="D"   ;
                           ;    __Keyboard( <c> )                ;
                           ; end
#endi

* \\ Final de ADRBIG.ch
GAS-Pro v4.0
001009025074001002013001003000176001
        CodBenefic:
 Oldescrito:                Oldclasse.:
 Prioridade:                Situa‡„o..:
 Oldespec..:
 Detalhes..:                Vantagens.:
 Condicoes.:                Informutil:
 Nome......:
 Endere‡o..:
 Bairro....:
 Cidade....:                                    CEP:
 Contato...:
 FoneCom1..:                 FoneCom2.:
 Fonecel...:                 Foneres1.:
 Email.....:
 Fax.......:                 Bip......:
 Fonesdiv..:
 DataInc...:                 DataAlt..:
 Codcidade.:                 Contrato.:
 Flagetq...:                 Codclasse:
[Ÿ]
Inclus„o~~26006
Manuten‡„o~~27007
Consulta~~28008
[Ÿ]
 32 
 2 
M‚dico

 12 
[Ÿ]
Especialidade

 15 
 12 
[Ÿ]
Cadastro de Credenciados
Credenciados







005
























 0 











 0 
 1 
-1 
-1 
 0 
-1 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
ai
C
E
 
 5 
 5 
 1 
 2 
 0 
Ai

!EMPT(ai)
Necess rio informar AI



 0 
 1 


codbenefic
C
E
 
 10 
 10 
 1 
 21 
 0 
Codbenefic

!EMPT(codbenefic)
Necess rio informar CODBENEFIC



 0 
 0 


oldescrito
C
E
 
 5 
 5 
 2 
 14 
 0 
Oldescrito

!EMPT(oldescrito)
Necess rio informar OLDESCRITO



 0 
 0 


oldclasse
C
E
 
 3 
 3 
 2 
 41 
 0 
Oldclasse

!EMPT(oldclasse)
Necess rio informar OLDCLASSE



 0 
 0 


prioridade
C
E
 
 2 
 2 
 3 
 14 
 0 
Prioridade

!EMPT(prioridade)
Necess rio informar PRIORIDADE



 0 
 0 


status
C
E
!!
 2 
 2 
 3 
 41 
 0 
Situa‡„o

!EMPT(status)
Necess rio informar SITUA€ŽO



 0 
 0 


oldespec
C
E
@!
 50 
 50 
 4 
 14 
 0 
Oldespec

!EMPT(oldespec)
Necess rio informar OLDESPEC



 0 
 0 


detalhes
M
E

 10 
 35 
 5 
 14 
 0 
Detalhes

!EMPT(detalhes)
Necess rio informar DETALHES



 0 
 0 


vantagens
M
E

 10 
 35 
 5 
 41 
 0 
Vantagens

!EMPT(vantagens)
Necess rio informar VANTAGENS



 0 
 0 


condicoes
M
E

 10 
 35 
 6 
 14 
 0 
Condicoes

!EMPT(condicoes)
Necess rio informar CONDICOES



 0 
 0 


informutil
M
E

 10 
 35 
 6 
 41 
 0 
Informutil

!EMPT(informutil)
Necess rio informar INFORMUTIL



 0 
 0 


nome
C
E
 
 50 
 50 
 7 
 14 
 0 
Nome

!EMPT(nome)
Necess rio informar NOME

Informe o nome do M‚dico

 0 
 0 


endereco
C
E
 
 50 
 50 
 8 
 14 
 0 
Endere‡o

 




 0 
 0 


bairro
C
E
@!
 30 
 30 
 9 
 14 
 0 
Bairro

!EMPT(bairro)
Necess rio informar BAIRRO



 0 
 0 


cidade
C
E
@!
 30 
 30 
 10 
 14 
 0 
Cidade

 




 0 
 0 


uf
C
E
!!
 2 
 2 
 10 
 45 
 0 
UF

VUF(uf)
UNIDADE DA FEDERA€ŽO inv lida



 0 
 0 


cep
C
E
@R 99999-999
 8 
 9 
 10 
 54 
 0 
CEP

!EMPT(cep)
Necess rio informar CEP



 0 
 0 


contato
C
E
@!
 50 
 50 
 11 
 14 
 0 
Contato

!EMPT(contato)
Necess rio informar CONTATO



 0 
 0 


fonecom1
C
E
 
 15 
 15 
 12 
 14 
 0 
Telefone

!EMPT(fonecom1)
Necess rio informar TELEFONE



 0 
 0 


fonecom2
C
E
@!
 15 
 15 
 12 
 41 
 0 
Fonecom2

!EMPT(fonecom2)
Necess rio informar FONECOM2



 0 
 0 


fonecel
C
E
@!
 15 
 15 
 13 
 14 
 0 
Fonecel

!EMPT(fonecel)
Necess rio informar FONECEL



 0 
 0 


foneres1
C
E
@!
 15 
 15 
 13 
 41 
 0 
Foneres1

!EMPT(foneres1)
Necess rio informar FONERES1



 0 
 0 


email
C
E
@!
 50 
 50 
 14 
 14 
 0 
Email

!EMPT(email)
Necess rio informar EMAIL



 0 
 0 


fax
C
E
@!
 15 
 15 
 15 
 14 
 0 
Fax

!EMPT(fax)
Necess rio informar FAX



 0 
 0 


bip
C
E
@!
 15 
 15 
 15 
 41 
 0 
Bip

!EMPT(bip)
Necess rio informar BIP



 0 
 0 


fonesdiv
C
E
@!
 30 
 30 
 16 
 14 
 0 
Fonesdiv

!EMPT(fonesdiv)
Necess rio informar FONESDIV



 0 
 0 


datainc
D
E
@D
 8 
 10 
 17 
 14 
 0 
Datainc

!EMPT(datainc)
Necess rio informar DATAINC



 0 
 0 


dataalt
D
E
@D
 8 
 10 
 17 
 41 
 0 
Dataalt

!EMPT(dataalt)
Necess rio informar DATAALT



 0 
 0 


codcidade
C
E
 
 4 
 4 
 18 
 14 
 0 
Codcidade

!EMPT(codcidade)
Necess rio informar CODCIDADE



 0 
 0 


contrato
C
E
 
 10 
 10 
 18 
 41 
 0 
Contrato

!EMPT(contrato)
Necess rio informar CONTRATO



 0 
 0 


flagetq
C
E
 
 10 
 10 
 19 
 14 
 0 
Flagetq

!EMPT(flagetq)
Necess rio informar FLAGETQ



 0 
 0 


codclasse
C
E
 
 6 
 6 
 19 
 41 
 0 
Codclasse

!EMPT(codclasse)
Necess rio informar CODCLASSE



 0 
 0 


 1 
porc.desconto
STR(ultvalor/valorpart*100,6,2)

 0 
 0 
 6 

 0 
 0 
 1 
TESPEC
1
 1 
!PTAB(especialid,'TESPEC',1)
1=3
 0 



especialid
C
especialid


 0 
€
 ADR_FUNC– ADR_FUNCCODEPTABCODEUSEARQCODECRITCODEEDITACODEMOV_PTRCODECABBRWCODEMONTABRWCODEFORCABRWCODE	ABREOUTROCODE
MOSTRA_RELCODEBRWFUNCCODEVALBRCODEIMP_BRWCODE
QUEBRA_BRWCODECABCONSCODE	CABCONS_OCODE
SEPARA_IMPCODE	TROCA_BRWCODELDBEDITCODE	MONTA_COLCODESEPARACODEDIR_CURCODECOLNOVACODEPEGARELACODESETARELACODEC_ETEXTENDCODE	_SYMSTARTSYMSTARTSYMBOLSSYMBOLS_SYMENDSYMENDNULLBEGDATA_DATADATA_SYMPBDATA_SYMPDATA_SYMPEDATA_CONSTCONST_MSGMSG_BEGBSSBEGBSS_BSSBSS_ENDBSSENDBSSDGROUPB˜ @procedure adm_r033
/*
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
 \ Empresa.: PresServ Inform tica-Limeira (019)452.6623
 \ Programa: ADM_R033.PRG
 \ Data....: 11-12-96
 \ Sistema.: Administradora - RECEP€„O
 \ Funcao..: Uma a uma Convencional
 \ Analista: Ademilson Pedro Bom
 \ Criacao.: GAS-Pro v3.0 
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/

#include "adrbig.ch"    // inicializa constantes manifestas

LOCAL dele_atu, getlist:={}
PARA  lin_menu, col_menu
PRIV  tem_borda:=.t., op_menu:=VAR_COMPL, l_s:=8, c_s:=16, l_i:=13, c_i:=59, tela_fundo:=SAVESCREEN(0,0,MAXROW(),79)
nucop=1
SETCOLOR(drvtittel)
vr_memo=NOVAPOSI(@l_s,@c_s,@l_i,@c_i)     // pega posicao atual da tela
CAIXA(mold,l_s,c_s,l_i,c_i)               // monta caixa da tela
@ l_s,c_s+14 SAY " TAXAS (2¦ VIA) "
SETCOLOR(drvcortel)
@ l_s+01,c_s+1 SAY " Contrato:"
@ l_s+04,c_s+1 SAY " Circular:  -               Confirma?"
rcodigo=SPAC(6)                                    // Codigo
rtipo=SPAC(1)                                      // Tipo
rcirc=SPAC(3)                                      // Circular
confirme=SPAC(1)                                   // Confirme?
DO WHILE .t.
 rola_t=.f.
 cod_sos=56
 SET KEY K_ALT_F8 TO ROLATELA
 SETCOLOR(drvcortel+","+drvcorget+",,,"+corcampo)
 @ l_s+01 ,c_s+12 GET  rcodigo;
                  PICT "999999";
                  VALI CRIT("PTAB(rcodigo,'GRUPOS',1)~Necess rio informar CODIGO")
                  AJUDA "Informe o n£mero do contrato"
                  CMDF8 "VDBF(6,3,20,77,'GRUPOS',{'grupo','codigo','nome','cidade'},1,'codigo',[])"
                  MOSTRA {"LEFT(TRAN(GRUPOS->nome,[@!]),35)", 2 , 5 }
                  MOSTRA {"LEFT(TRAN(GRUPOS->endereco,[]),35)", 3 , 5 }

 @ l_s+04 ,c_s+12 GET  rtipo;
                  PICT "!";
                  VALI CRIT("rtipo $ [123678]~TIPO n„o aceit vel")
                  AJUDA "Qual o tipo de lan‡amento"
                  CMDF8 "MTAB([1=J¢ia|2=Taxa|3=Carnˆ|6=J¢ia+Seguro|7=Taxa+Seguro|8=Carnˆ+Seguro],[TIPO])"

 @ l_s+04 ,c_s+14 GET  rcirc;
                  PICT "999";
                  VALI CRIT("PTAB(rcodigo+rtipo+rcirc,'TAXAS',1)~Necess rio informar CIRCULAR v lida")
                  AJUDA "Informe o n£mero da circular a imprimir"

 @ l_s+04 ,c_s+39 GET  confirme;
                  PICT "!";
                  VALI CRIT("confirme='S'.AND.V03301F9()~Digite S para confirmar|ou|Tecle ESC para cancelar")
                  AJUDA "Digite S para confirmar|ou|Tecle ESC para cancelar"

 READ
 SET KEY K_ALT_F8 TO
 IF rola_t
  ROLATELA(.f.)
  LOOP
 ENDI
 IF LASTKEY()=K_ESC                                // se quer cancelar
  RETU                                             // retorna
 ENDI

 #ifdef COM_REDE
  IF !USEARQ("TAXAS",.f.,10,1)                     // se falhou a abertura do arq
   RETU                                            // volta ao menu anterior
  ENDI
 #else
  USEARQ("TAXAS")                                  // abre o dbf e seus indices
 #endi

 PTAB(codigo,"GRUPOS",1,.t.)                       // abre arquivo p/ o relacionamento
 PTAB(GRUPOS->grupo,"ARQGRUP",1,.t.)
 PTAB(GRUPOS->regiao,"REGIAO",1,.t.)
 PTAB(GRUPOS->grupo+circ,"CIRCULAR",1,.t.)
 SET RELA TO codigo INTO GRUPOS,;                  // relacionamento dos arquivos
          TO GRUPOS->grupo INTO ARQGRUP,;
          TO GRUPOS->regiao INTO REGIAO,;
          TO GRUPOS->grupo+circ INTO CIRCULAR
 titrel:=criterio := ""                            // inicializa variaveis
 cpord="codigo"
 titrel:=chv_rela:=chv_1:=chv_2 := ""
 tps:=op_x:=ccop := 1
 IF !opcoes_rel(lin_menu,col_menu,15,11)           // nao quis configurar...
  CLOS ALL                                         // fecha arquivos e
  LOOP                                             // volta ao menu
 ENDI
 IF tps=2                                          // se vai para arquivo/video
  arq_=ARQGER()                                    // entao pega nome do arquivo
  IF EMPTY(arq_)                                   // se cancelou ou nao informou
   LOOP                                            // retorna
  ENDI
 ELSE
  arq_=drvporta                                    // porta de saida configurada
 ENDI
 SET PRINTER TO (arq_)                             // redireciona saida
 EXIT
ENDD
criterio_=criterio                                 // salva criterio e ordenacao
cpord_=cpord                                       // definidos se huver
criterio=""

#ifdef COM_REDE
 IF !USEARQ("CPRCIRC",.f.,10,1)                    // se falhou a abertura do arq
  RETU                                             // volta ao menu anterior
 ENDI
#else
 USEARQ("CPRCIRC")                                 // abre o dbf e seus indices
#endi

cpord="grupo+circ+DTOS(dfal)"
INDTMP()
criterio=criterio_                                 // restabelece criterio e
cpord=cpord_                                       // ordenacao definidos
SELE TAXAS
IF !EMPTY(drvtapg)                                 // existe configuracao de tam pag?
 op_=AT("NNN",drvtapg)                             // se o codigo que altera
 IF op_=0                                          // o tamanho da pagina
  msg="Configura‡„o do tamanho da p gina!"         // foi informado errado
  DBOX(msg,,,,,"ERRO!")                            // avisa
  CLOSE ALL                                        // fecha todos arquivos abertos
  RETU                                             // e cai fora...
 ENDI                                              // codigo para setar/resetar tam pag
 lpp_048=LEFT(drvtapg,op_-1)+"048"+SUBS(drvtapg,op_+3)
 lpp_066=LEFT(drvtapg,op_-1)+"066"+SUBS(drvtapg,op_+3)
ELSE
 lpp_048:=lpp_066 :=""                             // nao ira mudara o tamanho da pag
ENDI
DBOX("[ESC] Interrompe",15,,,NAO_APAGA)
dele_atu:=SET(_SET_DELETED,.t.)                    // os excluidos nao servem...
SET DEVI TO PRIN                                   // inicia a impressao
maxli=19                                           // maximo de linhas no relatorio
IMPCTL(lpp_048)                                    // seta pagina com 48 linhas
SET MARG TO 1                                      // ajusta a margem esquerda
IF tps=2
 IMPCTL("' '+CHR(8)")
ENDI
BEGIN SEQUENCE
 DO WHIL ccop<=nucop                               // imprime qde copias pedida
  pg_=1; cl=999
  INI_ARQ()                                        // acha 1o. reg valido do arquivo
  ccop++                                           // incrementa contador de copias
  ult_imp=0                                        // ultimo reg impresso
  DO WHIL !EOF()
   #ifdef COM_TUTOR
    IF IN_KEY()=K_ESC                              // se quer cancelar
   #else
    IF INKEY()=K_ESC                               // se quer cancelar
   #endi
    IF canc()                                      // pede confirmacao
     BREAK                                         // confirmou...
    ENDI
   ENDI
   IF codigo=M->rcodigo                            // se atender a condicao...
    REL_CAB(1,.t.)                                 // soma cl/imprime cabecalho
    @ cl,000 SAY "."
    ult_imp=RECNO()                                // ultimo reg impresso
    chv027=GRUPOS->grupo+TAXAS->circ
    SELE CPRCIRC
    SEEK chv027
    IF FOUND()
     DO WHIL ! EOF() .AND. chv027=LEFT(&(INDEXKEY(0)),LEN(chv027))
      #ifdef COM_TUTOR
       IF IN_KEY()=K_ESC                           // se quer cancelar
      #else
       IF INKEY()=K_ESC                            // se quer cancelar
      #endi
       IF canc()                                   // pede confirmacao
        BREAK                                      // confirmou...
       ENDI
      ENDI
      REL_CAB(1)                                   // soma cl/imprime cabecalho
      IMPCTL(drvpc20)                              // comprime os dados
      @ cl,030 SAY num                             // Contrato
      @ cl,041 SAY processo                        // Processo
      @ cl,054 SAY fal                             // Falecido
      @ cl,091 SAY TRAN(ALLTRIM(ends)+'-'+ALLTRIM(cids),"@!")// Ends
      @ cl,149 SAY TRAN(dfal,"@D")                 // Data
      IMPCTL(drvtc20)                              // retira comprimido
      SKIP                                         // pega proximo registro
     ENDD
    ENDI
    SELE TAXAS                                     // volta ao arquivo pai
    SKIP                                           // pega proximo registro
    cl=999                                         // forca salto de pagina
   ELSE                                            // se nao atende condicao
    SKIP                                           // pega proximo registro
   ENDI
  ENDD
  REL_RDP(.t.)                                     // imprime rodape' do relatorio
 ENDD ccop
 EJEC                                              // salta pagina
END SEQUENCE
SET MARG TO                                        // coloca margem esquerda = 0
IMPCTL(lpp_066)                                    // seta pagina com 66 linhas
SET PRINTER TO (drvporta)                          // fecha arquivo gerado (se houver)
SET DEVI TO SCRE                                   // direciona saida p/ video
IF tps=2                                           // se vai para arquivo/video
 BROWSE_REL(arq_,2,3,MAXROW()-2,78)
ENDI                                               // mostra o arquivo gravado
GRELA(15)                                          // grava variacao do relatorio
SELE TAXAS                                         // salta pagina
SET RELA TO                                        // retira os relacionamentos
SET(_SET_DELETED,dele_atu)                         // os excluidos serao vistos
RETU

STATIC PROC REL_RDP(volta_reg)                     // rodape'
LOCAL ar_:=ALIAS(), reg_atual
SELE TAXAS                                         // volta ao arquivo pai
reg_atual=RECNO()
IF volta_reg
 GO ult_imp                                        // ajusta reg p/ imp de campos no rodape'
ENDI
@ 21,008 SAY CHR(18)+CIRCULAR->menscirc            // Mensagem
@ 25,017 SAY TRAN(valor,"@E 999,999.99")           // Valor
@ 25,065 SAY TRAN(valor,"@E 999,999.99")           // Valor 2
@ 28,020 SAY TRAN(0,"########")                    // N§ Recibo
@ 28,068 SAY TRAN(0,"########")                    // N§ Recibo 2
@ 31,002 SAY TAXAS->circ+[     ]+DTOC(TAXAS->emissao_)+[     ]+STR(GRUPOS->funerais,2)// Circular 1
@ 31,038 SAY TAXAS->circ+[     ]+DTOC(TAXAS->emissao_)+[     ]+STR(GRUPOS->funerais,2)// Circular 2
@ 34,002 SAY GRUPOS->grupo +[        ]+codigo+[       ]+GRUPOS->cobrador// Grupo 1
@ 34,038 SAY GRUPOS->grupo +[        ]+codigo+[       ]+GRUPOS->cobrador// Grupo 2
@ 36,000 SAY GRUPOS->nome                          // Nome
@ 36,036 SAY GRUPOS->nome                          // Nome 2
@ 37,000 SAY GRUPOS->endereco                      // Endere‡o
@ 37,036 SAY GRUPOS->endereco                      // Endere‡o 2
@ 38,000 SAY GRUPOS->bairro                        // Bairro
@ 38,036 SAY GRUPOS->bairro                        // Bairro 2
@ 39,000 SAY GRUPOS->cidade+[ ] +GRUPOS->cep       // Cidade
@ 39,036 SAY GRUPOS->cidade+[ ] +GRUPOS->cep       // Cidade 2
@ 40,000 SAY [Inic:]+DTOC(GRUPOS->admissao)+[ Ult:]+GRUPOS->ultcirc+[ QtTx:]+STR(GRUPOS->qtcircs,3)// Inicio
@ 40,036 SAY [Inic:]+DTOC(GRUPOS->admissao)+[ Ult:]+GRUPOS->ultcirc+[ QtTx:]+STR(GRUPOS->qtcircs,3)// Inicio 2
@ 42,000 SAY ""
IF M->combarra=[S]
 CODBARRAS({{codigo+tipo+circ,4,10,18}},10,6)
ENDI
@ 43,002 SAY [ ]                                   // data 1
@ 43,039 SAY [ ]                                   // data 2
IF M->combarra=[S]
 CODBARRAS({{codigo+tipo+circ,4,10,18}},10,6)
ENDI
IF volta_reg
 GO reg_atual                                      // retorna reg a posicao original
ENDI
SELE (ar_)
RETU 

STATIC PROC REL_CAB(qt, volta_reg)                 // cabecalho do relatorio
LOCAL ar_:=ALIAS()
volta_reg=IF(volta_reg=NIL,.f.,volta_reg)
IF qt>0                                            // se parametro maior que 0
 cl=cl+qt                                          // soma no contador de linhas
ENDI
IF cl>maxli .OR. qt=0                              // quebra de pagina
 IF pg_>1
  REL_RDP(volta_reg)                               // imprime rodape' do relatorio
 ENDI
 SELE TAXAS                                        // volta ao arquivo pai
 @ 1,007 SAY GRUPOS->nome                          // Nome
 @ 1,058 SAY TRAN(codigo,"999999")                 // Codigo
 @ 1,076 SAY TRAN(GRUPOS->grupo,"!9")              // Grupo
 @ 3,032 SAY TRAN(valor,"@E 999,999.99")           // Valor
 SELE (ar_)
 cl=qt+7 ; pg_++
ENDI
RETU

* \\ Final de ADM_R033.PRG
€ OBXEC–S OBXECCODEOBX_INCLCODEOBX_RELCODE
OBX_ANT_SECODE
OBX_CRIA_SCODE
OBX_GERA_SCODE
OBX_GRAVA_CODEOBX_TELACODEOBX_GETSCODEOBX_GET1CODEC_ETEXTENDCODE	_SYMSTARTSYMSTARTSYMBOLSSYMBOLS_SYMENDSYMENDNULLBEGDATA_DATADATA_SYMPBDATA_SYMPDATA_SYMPEDATA_CONSTCONST_MSGMSG_BEGBSSBEGBSS_BSSBSS_ENDBSSENDBSSDGROUP˜ @€
 BXR_06F9>–Ñ  BXR_06F9CODEC_ETEXTENDCODE	_SYMSTARTSYMSTARTSYMBOLSSYMBOLS_SYMENDSYMENDNULLBEGDATA_DATADATA_SYMPBDATA_SYMPDATA_SYMPEDATA_CONSTCONST_MSGMSG_BEGBSSBEGBSS_BSSBSS_ENDBSSENDBSSDGROUPý˜ @Ÿy˜ H  ˜ h  ë˜ `0	½˜ h  
ã˜ h  ß˜ H  û˜ H  ÷˜ H ë˜ H  ï˜ H  ë˜ (  ˜ H  GAS-Pro v4.0
003004020078001001028001004001022001
 Codigo:                                         Situa‡„o:
  ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ Dados Pessoais ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 Nome..:                                     Nasc.:
 ECivil:                  CIC:               RG...:
 Ender.:                                     Bairr:
 Cidade:                           UF.:      CEP..:
 Natur.:                           Relig:
 Contato                           Tel:
 Categor.:     Carnˆ:      F.Pgto:
 Admiss„o:             T.Carˆncia:              Sai Taxas.:
 Vendedor:                                      Dia Pgto..:
 Regi„o..:                                      Observa‡„o:
 Cobrador:                                      Renova‡„o.:
 Funerais:       Circ.Inic:       Ult.:        Emit:      Baix:
 Participantes: Vivos:    Falecidos:    Dependentes:
 Ult.Altera‡„o:                       Ult.Impress„o:


















      M‰










02005COBRADOR.ATR
02005COBRADOR.ATR
[Ÿ]
Inclus„o~~26006
Manuten‡„o~~27007
Consulta~~28008
Consulta Inscritos~~29008CTAINSC.CEX
Consulta Taxas~~29008CTXAS.CEX
[Ÿ]
 42 
 2 
Contrato

 1 
[Ÿ]
p/Nome

 4 
[Ÿ]
Consulta contratos
Consulta Contratos

1=3
Mantido pelo sistema de Plano
1=3
Mantido pelo sistema de Plano
1=3
Mantido pelo sistema de Plano
005


1=3
Mantido pelo sistema de Plano
































 0 
 1 
-1 
-1 
 0 
-1 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
codigo
C
E
@!
 10 
 10 
 1 
 10 
 0 
Codigo

PTAB('',[ARQGRUP],1).AND.GRU_01F9()
CODIGO n„o aceit vel|N„o cadastrado na tabela de grupos

Entre com o n£mero do contrato
GRU_02F9()
 0 
 0 


grupo
C
I
!!
 2 
 2 
 0 
 0 
 0 
Grupo






 0 
 0 


situacao
C
E
9
 1 
 1 
 1 
 60 
 0 
Situa‡„o

situacao $ [12]
SITUA€ŽO n„o aceit vel
[1]
Digite 1 para ativo ou 2 para cancelado
MTAB([1=Ativo|2=Cancelado],[SITUA€ŽO])
 0 
 0 


nome
C
E
@!
 35 
 35 
 3 
 10 
 0 
Nome

!EMPT(nome)
Necess rio informar NOME



 0 
 0 


nascto_
D
E
@D
 8 
 10 
 3 
 53 
 0 
Nascto

 


Informe a data de nascimento do titular

 0 
 0 


estcivil
C
E
!!
 2 
 2 
 4 
 10 
 0 
Est Civil

(estcivil$tbestciv)
Informe Estado Civil|ou|Tecle F8 para consulta em tabela

Digite o Estado Civil do Titular|ou|Tecle F8 para consulta em tabela
MTAB(tbestciv,[EST CIVIL])
 0 
 0 


cpf
C
E
@R 999.999.999-99
 11 
 14 
 4 
 31 
 0 
CPF

VDV2(cpf).OR.EMPT(cpf)
CPF nÆo aceit vel

Informe o CIC (CPF) do titular

 0 
 0 


rg
C
E
@!
 20 
 20 
 4 
 53 
 0 
R.G.

 


Informe o n£mero do documento do titular

 0 
 0 


endereco
C
E
@!
 35 
 35 
 5 
 10 
 0 
Endere‡o

!EMPT(endereco)
Este endere‡o ser  utilizado na emissÆo das Taxas|para cobran‡a e em todas as telas de consulta.

Informe o Endere‡o para correspondˆncias.|Rua,n£mero,apto, blocl, etc...

 0 
 0 


bairro
C
E
@!
 20 
 20 
 5 
 53 
 0 
Bairro

!EMPT(bairro)
Necess rio informar BAIRRO do Titular

Informe o bairro ou regi„o do titular do contrato

 0 
 0 


cidade
C
E
@!
 25 
 25 
 6 
 10 
 0 
Cidade

!EMPT(cidade)
Necess rio informar MUNICIPIO para cobran‡a do Titular.
M->p_cidade
Digite a Cidade para correspondˆncia.

 0 
 0 


uf
C
E
!!
 2 
 2 
 6 
 41 
 0 
UF

VUF(uf).OR.EMPT(UF)
UNIDADE DA FEDERA€ŽO inv lida

Qual ‚ o estado da federa‡„o

 0 
 0 


cep
C
E
@R 99999-999
 8 
 9 
 6 
 53 
 0 
CEP

!EMPT(cep)
Necess rio informar CEP do Titular |com 08 digitos

Informe o CEP (8 digitos)|para facilitar a correspondˆncia

 0 
 0 


natural
C
E
@K!
 25 
 25 
 7 
 10 
 0 
Naturalidade

 

M->p_cidade
Informe a naturalidade do titular

 0 
 0 


relig
C
E
@!
 20 
 20 
 7 
 43 
 0 
Relig

 


Informe a religi„o do titular
__KEYBOARD([CATOLICO])
 0 
 0 


contato
C
E
@!
 25 
 25 
 8 
 10 
 0 
Contato

 


Digite o nome da pessoa para contato|

 0 
 0 


telefone
C
E
@!
 14 
 14 
 8 
 41 
 0 
Telefone

 


Informe o n£mero de telefone para|Contato com o contratante

 0 
 0 


tipcont
C
E
99
 2 
 2 
 9 
 12 
 0 
TipCont

PTAB(tipcont,'CLASSES',1)
Informe a Classe deste contrato

Qual a categoria do Contrato?|Tecle F8 para consulta em tabela
VDBF(6,20,20,77,'CLASSES',{'classcod','descricao','vljoia'},1,'classcod',[])
 0 
 0 


vlcarne
C
E
 
 3 
 3 
 9 
 23 
 0 
Vlcarne
!(CLASSES->prior=[S])
 


Qual o c¢digo de classifica‡Æo do valor do contrato?|Tecle F8 para consultar tabela|Obs.|Ser  preenchido quando for lan‡ada a|venda do contrato.
VDBF(6,52,20,77,'TCARNES',{'tip','pari','vali','parf'},1,'tip',[])
 0 
 0 


formapgto
C
E
99
 2 
 2 
 9 
 36 
 0 
FormaPgto
CLASSES->prior=[S]
 


Informe a forma de pagamento desejada|A Taxa de manuten‡Æo ser  emitida cada NN meses.

 0 
 0 


seguro
N
I
 
 2 
 0 
 0 
 0 
 0 
Seguro






 0 
 0 


admissao
D
E
@D
 8 
 10 
 10 
 12 
 0 
Admiss„o

!EMPT(admissao)
Necess rio informar DATA DE ADMISSŽO
DATE()
Informe a data da Admiss„o neste contrato
DATE()
 0 
 0 


tcarencia
D
E
@D
 8 
 10 
 10 
 36 
 0 
T.Carˆncia

 


Informe a data de t‚rmino da Carˆncia

 0 
 0 


saitxa
C
E
@R 99/99
 4 
 5 
 10 
 61 
 0 
Saitxa

!EMPT(saitxa).AND.MMAA(saitxa) .or.nivelop==3
Necess rio informar SAITXA (MM/AA)
SUBSTR(DTOC(admissao+(CLASSES->nrparc*30)),4,2)+RIGHT(DTOC(admissao+(CLASSES->nrparc*30)),2)
Informe o Mˆs a sair a 1¦ Taxa.

 0 
 0 


diapgto
C
E
99
 2 
 2 
 11 
 61 
 0 
Dia Pgto.

diapgto<[31]
DIA PGTO. n„o aceit vel|Digite um dia entre 01 e 30|ou|deixe com 00 para data igual ao grupo

Informe o melhor dia para pagamento

 0 
 0 


vendedor
C
E
!!!
 3 
 3 
 11 
 12 
 0 
Vendedor

PTAB(vendedor,'COBRADOR',1).OR.EMPT(vendedor)
VENDEDOR n„o existe na tabela

Informe o c¢digo do Vendedor|ou|Tecle F8 para consulta em arquivo
VDBF(6,7,20,77,'COBRADOR',{'cobrador','funcao','nome','cidade'},1,'cobrador')
 0 
 0 


regiao
C
E
999
 3 
 3 
 12 
 12 
 0 
Regi„o

PTAB(regiao,'REGIAO',1).OR.EMPT(VAL(regiao))
REGIŽO n„o existe na tabela

Informe a regi„o ou tecle F8 para busca em tabela
VDBF(6,38,20,77,'REGIAO',{'codigo','regiao'},1,'codigo')
 0 
 0 


cobrador
C
E
!!!
 3 
 3 
 13 
 12 
 0 
Cobrador

PTAB(cobrador,'COBRADOR',1)
COBRADOR n„o existe na tabela

Digite o c¢digo do COBRADOR que|receber  as Taxas deste contrato,|Tecle F8 para consultar os cobradores.
VDBF(6,39,20,77,'REGIAO',{'regiao','cobrador'},2,'cobrador',[!EMPT(cobrador)])
 0 
 0 


obs
M
E

 10 
 35 
 12 
 61 
 0 
Obs

 




 0 
 0 


renovar
D
E
@D
 8 
 10 
 13 
 61 
 0 
Renovar

 


Data final para renova‡Æo

 0 
 0 


funerais
N
E
99
 2 
 2 
 14 
 12 
 0 
Funerais

!(funerais<0)
FUNERAIS n„o aceit vel

N£mero de Funerais efetuados|para este processo

 0 
 0 


circinic
C
E
999
 3 
 3 
 14 
 29 
 0 
Circ.Inicial

 


Informe o n£mero da 1¦ Circular|que saiu para este contrato.

 0 
 0 


ultcirc
C
E
999
 3 
 3 
 14 
 41 
 0 
Ult.Circular

PTAB(IIF(CLASSES->prior=[S],M->mgrupvip,grupo)+ultcirc,'CIRCULAR',1).OR.ultcirc=[000].or.nivelop==3
Necess rio informar ULT.CIRCULAR

Entre com o £ltimo n£mero de circular|deste contrato.

 0 
 0 


qtcircs
N
E
999
 3 
 3 
 14 
 54 
 0 
Qt.Circulares

!(qtcircs<0)
QT.CIRCULARES n„o aceit vel



 0 
 0 


qtcircpg
N
E
999
 3 
 3 
 14 
 65 
 0 
Circ.Pagas

 


Informe a quantidade de Circulares|pagas/retornadas deste contrato

 0 
 0 


titular
C
I
 
 3 
 3 
 0 
 0 
 0 
Titular






 0 
 0 


particv
N
I
99
 2 
 2 
 0 
 0 
 0 
Part.Vivos






 0 
 0 


particf
N
I
99
 2 
 2 
 0 
 0 
 0 
Part.Falecidos






 0 
 0 


nrdepend
N
I
99
 2 
 2 
 0 
 0 
 0 
N§ Depend.






 0 
 0 


ultimp_
D
I
@D
 8 
 10 
 0 
 0 
 0 
Ult.Impress.






 0 
 0 


ender_
D
I
@D
 8 
 10 
 0 
 0 
 0 
élt.alter.endere‡o






 0 
 0 


ultend
C
I
 
 10 
 10 
 0 
 0 
 0 
UltEnd






 0 
 0 


 16 
Situacao
IIF(situacao=[2],[CANCELADO],[         ])

 1 
 62 
 9 

Part.Vivos
particv
99
 15 
 24 
 2 

Part.Falecidos
particf
99
 15 
 38 
 2 

Nome do Cobrado
IIF(PTAB(cobrador,'COBRADOR',1),COBRADOR->nome,[ ])

 13 
 16 
 30 

Nome do Vendedr
IIF(PTAB(vendedor,'COBRADOR',1),COBRADOR->nome,[ ])

 11 
 16 
 30 

grupo
IIF(!EMPT(grupo),grupo,[  ])

 1 
 22 
 2 

Descri‡„o Reg
REGIAO->regiao

 12 
 16 
 30 

Est.Civil
IIF(!EMPT(estcivil),SUBS(tbestciv,AT(estcivil,tbestciv),11),[])

 4 
 13 
 11 

N§ Depend.
nrdepend
99
 15 
 54 
 2 

Ult.Impress.
ultimp_
@D
 16 
 54 
 10 

élt.alter.ender
ender_
@D
 16 
 17 
 10 

UltEnd
ultend

 16 
 28 
 10 

Seguro
IIF(seguro>0,'SEGURO ('+str(seguro,2)+')',[   ])

 1 
 28 
 12 

Qt.Circulares
qtcircs
999
 0 
 0 
 3 

periodicidade
IIF(PTAB(tipcont,'CLASSES',1),ALLTRIM(CLASSES->descricao),[])+[ ]+IIF(formapgto$'01020304',SUBSTR(tbfpgto,(VAL(formapgto)-1)*13+1,13),[])

 9 
 39 
 35 

Idade
IIF(!EMPT(nascto_),LEFT(DLAPSO(DATE(),nascto_),10),[          ])

 3 
 64 
 10 

 3 
ARQGRUP
contrat
ARQGRUP->contrat + 1
ARQGRUP->contrat - 1



GRUPOS
ender_
DATE()




GRUPOS
ultend
M->usuario




 0 
 0 
 0 
procedure bxr_01f9
/*
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
 \ Empresa.: Ind£stria de Urnas Bignotto Ltda
 \ Programa: BXR_01F9.PRG
 \ Data....: 20-11-95
 \ Sistema.: Administradora de Funer rias
 \ Funcao..: F¢rmula (Circ 1 - 4) a mostrar na tela de BXREC
 \ Analista: Ademilson Pedro Bom
 \ Criacao.: Programado manualmente pelo analista
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/

#include "adrbig.ch"    // inicializa constantes manifesta

 LOCAL reg_dbf:=POINTER_DBF()
 LOCAL circax1:=circax2:=circax3:=circax4:=circax5:=circax6:=SPACE(46)
 LOCAL cipend:=ciatrz:=nrd:=vladd:=0, jrok
 IF !op_menu = INCLUSAO
  codigo:=BXREC->codigo
  RETU .T.
 ENDIF
 IF EMPT(codigo)
  RETU .T.
 ENDI
 dele_atu:=SET(_SET_DELETED,.t.)             // os excluidos nao servem...
 circax1:=circax2:=circax3:=circax4:=circax5:=circax6:=SPACE(46)

 PTAB(ALLTRIM(codigo),'GRUPOS',1)
 PTAB(ALLTRIM(codigo),'TAXAS',1)
 SELE TAXAS
 DO WHILE !EOF().AND.TAXAS->codigo=GRUPOS->codigo
  IF DELE()
   SKIP
   LOOP
  ENDI
  vladd:=0
  IF EMPT(TAXAS->valorpg)
   cipend++
   IF TAXAS->emissao_< DATE()
    ciatrz++
    jrok:=PTAB(tipo,'JUROS',1)
    nrd:=(DATE() - TAXAS->emissao_)
    IF jrok .AND. (nrd > JUROS->mltcaren)
     vladd+=TAXAS->valor*JUROS->multa/100
    ENDI
    IF jrok .AND. (nrd > JUROS->jrscaren)
     vladd+=TAXAS->valor*JUROS->juros/100*nrd
    ENDI
   ENDI
  ENDI
  IF cipend < 5 .AND. TAXAS->emissao_ <= DATE()+60
   circax1:=circax2
   circax2:=circax3
   circax3:=circax4
   circax4:=[ ]+TAXAS->tipo+[ ]+TAXAS->circ+[ ]+DTOC(TAXAS->emissao_)+[ ]+;
      TRANSF(TAXAS->valor+M->vladd,"@E 99,999.99")+[ ]+DTOC(TAXAS->pgto_)+;
      TRANSF(TAXAS->valorpg,"@E 99,999.99") //+[ ]+TAXAS->cobrador
  ENDI
  SKIP
 ENDDO
 @ l_s+07, c_s+46 SAY [   ]
 @ l_s+07, c_s+46 SAY TRAN(GRUPOS->qtcircs,[999])
 IF !EMPT(GRUPOS->nrsorteio)
   @ l_s+10,c_s+20 say [NS:]+GRUPOS->nrsorteio
 ENDIF
 IF !EMPT(GRUPOS->telefone)
  @ l_s+10, c_s+1 SAY [Tel.:]+xDECRIPT(GRUPOS->telefone)
 ENDI
 @ l_s+15, c_s+2 SAY [CPF: ]+TRAN(GRUPOS->cpf,[@R 999.999.999-99])+[  Dt.Nascto:]+DTOC(GRUPOS->nascto_)
 @ l_s+11, c_s+1 SAY SPACE(46)
 @ l_s+12, c_s+1 SAY SPACE(46)
 @ l_s+13, c_s+1 SAY SPACE(46)
 @ l_s+14, c_s+1 SAY SPACE(46)
 @ l_s+11, c_s+1 SAY circax1
 @ l_s+12, c_s+1 SAY circax2
 @ l_s+13, c_s+1 SAY circax3
 @ l_s+14, c_s+1 SAY circax4
 IF .t. //ciatrz > 4
  IF .t. // BXREC->tipo=' '
   DBOX(STRZERO(ciatrz,2)+" Circulares Pendentes Vencidas!",,,,,"ATEN€ŽO, "+usuario)
  ENDI
 ENDI
 POINTER_DBF(reg_dbf)
SET(_SET_DELETED,dele_atu)                         // os excluidos serao vistos

RETU []         // <- deve retornar um valor qualquer

* \\ Final de BXR_01F9.PRG
procedure v87001f9
/*
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
 \ Empresa.: PresServ Inform tica-Limeira (019)452.6623
 \ Programa: V87001F9.PRG
 \ Data....: 21-09-97
 \ Sistema.: Administradora - PLANO
 \ Funcao..: Valida‡„o da variavel CONFIRME, relatorio ADM_R038
 \ Analista: Ademilson Pedro Bom
 \ Criacao.: Programado manualmente pelo analista
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/

#include "adrbig.ch"    // inicializa constantes manifestas

// Preparados em R08701F9()
PUBL vlseg:=0, valororig:=0  // Composi‡„o do valor
PUBL lindeb:=[]  // Linha resumo dos d‚bitos (Tipo+circ ...)
PUBL detdeb [10] // Detalhamento dos d‚bitos tipo+circ+vencto+valor...
AFILL(detdeb,[])

// Preparados em R08703F9()
PUBL ultprc:=[]  // Ultima cartinha montada, se for igual n„o refaz...
PUBL detprc [10] // Cartinha dos falecidos
AFILL(detprc,[])

RETU .t.       // <- deve retornar um valor L¢GICO

* \\ Final de V87001F9.PRG
/*
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
 \ Empresa.: Ind£stria de Urnas Bignotto Ltda
 \ Programa: ADM_R030.PRG
 \ Data....: 09-08-96
 \ Sistema.: Administradora de Funer rias
 \ Funcao..: Fechamento Caixa
 \ Analista: Ademilson Pedro Bom
 \ Criacao.: GAS-Pro v2.0d
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/

#include "admbig.ch"    // inicializa constantes manifestas

LOCAL dele_atu, getlist:={}, li_det:=[]
PARA  lin_menu, col_menu
PRIV  tem_borda:=.t., op_menu:=VAR_COMPL, l_s:=10, c_s:=26, l_i:=14, c_i:=56, tela_fundo:=SAVESCREEN(0,0,MAXROW(),79)
nucop=1
SETCOLOR(drvtittel)
vr_memo=NOVAPOSI(@l_s,@c_s,@l_i,@c_i)     // pega posicao atual da tela
CAIXA(mold,l_s,c_s,l_i,c_i)               // monta caixa da tela
@ l_s,c_s+6 SAY " TRANSF.FINANCEIRO "
SETCOLOR(drvcortel)
@ l_s+01,c_s+1 SAY " Nr.Conta...:"
@ l_s+02,c_s+1 SAY " Fechamento.:"
nrconta=SPAC(10)                                   // Nr.Conta
emisini_=CTOD('')                                  // Lan‡to. inicial
DO WHILE .t.
 rola_t=.f.
 cod_sos=56
 SET KEY K_ALT_F8 TO ROLATELA
 SETCOLOR(drvcortel+","+drvcorget+",,,"+corcampo)
 @ l_s+01 ,c_s+15 GET  nrconta;
                  VALI CRIT("!EMPT(nrconta)~Necess rio informar NR.CONTA")
                  DEFAULT "M->usuario"
                  AJUDA "Informe a conta a fechar.|Tecle F8 para conta atual"
                  CMDF8 "IIF(EMPT(M->usuario),PADR(M->contaconv+M->ide_maq,10,' '),PADR(M->usuario,10,' '))"

 @ l_s+02 ,c_s+15 GET  emisini_;
                  PICT "@D";
                  VALI CRIT("emisini_=DATE()~Deve ser exatamente a data de hoje |Data do sistema")
                  DEFAULT "DATE()"
                  AJUDA "Informe a data inicial"

 READ
 SET KEY K_ALT_F8 TO
 IF rola_t
  ROLATELA(.f.)
  LOOP
 ENDI
 IF LASTKEY()=K_ESC                                // se quer cancelar
  RETU                                             // retorna
 ENDI

 #ifdef COM_REDE
  IF !USEARQ("ORDPGRC",.t.,10,1)                   // se falhou a abertura do arq
   RETU                                            // volta ao menu anterior
  ENDI
 #else
  USEARQ("ORDPGRC")                                // abre o dbf e seus indices
 #endi

 titrel:=criterio:=cpord := ""                     // inicializa variaveis
 titrel:=chv_rela:=chv_1:=chv_2 := ""
 tps:=op_x:=ccop := 1
 IF !opcoes_rel(lin_menu,col_menu,6,11)            // nao quis configurar...
  CLOS ALL                                         // fecha arquivos e
  LOOP                                             // volta ao menu
 ENDI
 IF tps=2                                          // se vai para arquivo/video
  arq_=ARQGER()                                    // entao pega nome do arquivo
  IF EMPTY(arq_)                                   // se cancelou ou nao informou
   LOOP                                            // retorna
  ENDI
 ELSE
  arq_=drvporta                                    // porta de saida configurada
 ENDI
 SET PRINTER TO (arq_)                             // redireciona saida
 EXIT
ENDD
criterio_=criterio                                 // salva criterio e ordenacao
cpord_=cpord                                       // definidos se huver
criterio=""

#ifdef COM_REDE
 IF !USEARQ("BXREC",.t.,10,1)                      // se falhou a abertura do arq
  RETU                                             // volta ao menu anterior
 ENDI
#else
 USEARQ("BXREC")                                   // abre o dbf e seus indices
#endi

cpord="numop+ano+numero"
INDTMP()

#ifdef COM_REDE
 IF !USEARQ("OBXEC",.t.,10,1)                      // se falhou a abertura do arq
  RETU                                             // volta ao menu anterior
 ENDI
#else
 USEARQ("OBXEC")                                   // abre o dbf e seus indices
#endi

cpord="numop+ano+numero"
INDTMP()
criterio=criterio_                                 // restabelece criterio e
cpord=cpord_                                       // ordenacao definidos
SELE ORDPGRC
DBOX("[ESC] Interrompe",15,,,NAO_APAGA)
dele_atu:=SET(_SET_DELETED,.t.)                    // os excluidos nao servem...
SET DEVI TO PRIN                                   // inicia a impressao
maxli=62                                           // maximo de linhas no relatorio
BEGIN SEQUENCE
 DO WHIL ccop<=nucop                               // imprime qde copias pedida
  pg_=1; cl=999
  INI_ARQ()                                        // acha 1o. reg valido do arquivo
  ccop++                                           // incrementa contador de copias
  tot015005 := 0                                   // inicializa variaves de totais
  DO WHIL !EOF()
   IF INKEY()=K_ESC                                // se quer cancelar
    IF canc()                                      // pede confirmacao
     BREAK                                         // confirmou...
    ENDI
   ENDI
   IF numconta==M->nrconta.AND.EMPT(fechto_)       // se atender a condicao...
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    IMPCTL(drvtc20)                                // retira comprimido
    @ cl,000 SAY TRAN(numop+R03001F9(),"999999")   // N§ OP.
    @ cl,007 SAY TRAN(origem,"!!!")                // Ori
    @ cl,011 SAY TRAN(historico,"999")             // Hist
    @ cl,016 SAY TRAN(debcred,"!")                 // D/C
    tot015005+=valortotal * IIF(debcred='C',1,-1)
    @ cl,019 SAY TRAN(valortotal * IIF(debcred='C',1,-1),"99999999.99")// Val Lan‡to
    @ cl,031 SAY TRAN(documento,"@!")              // Documento
    @ cl,044 SAY TRAN(complement,"@!")             // Complemento de Hist¢rico
    tot016005 := 0                                 // inicializa variaves de totais
    chv016=numop
    SELE BXREC
    SEEK chv016
    IF FOUND()
     IF cl+3>maxli                                 // se cabecalho do arq filho
      REL_CAB(0)                                   // nao cabe nesta pagina
     ENDI                                          // salta para a proxima pagina
     IMPCTL(drvpc20)                               // comprime os dados
     cl+=1                                         // soma contador de linha
     @ cl,001 SAY "Numero  Codig Cir Valor pago"
     cl+=1                                         // soma contador de linha
     @ cl,000 SAY "======== ===== === =========="
     IMPCTL(drvtc20)                               // retira comprimido
     DO WHIL ! EOF() .AND. chv016=numop //LEFT(&(INDEXKEY(0)),LEN(chv016))
      IF INKEY()=K_ESC                             // se quer cancelar
       IF canc()                                   // pede confirmacao
	BREAK                                      // confirmou...
       ENDI
      ENDI
      li_det+=TRAN(ano,"99")+;           // Ano
	      TRAN(numero,"999999")+[ ]+;          // Numero
	      TRAN(codigo,"99999")+[ ]+;           // Codigo
	      TRAN(circ,"999")+[ ]+;               // Circular
	      TRAN(valorpg,"@E 999,999.99")+[  ||  ]        // Valor pago
      tot016005+=vaìorpg
      IF LEN(ìi_det) > 120
       REL_CAB(1)                                   // soma cl/imprime cabecalho
       IMPCTL(drvpc20)                              // comprime os dados
       @ cl,000 SAY li_det                          // linha
       IMPCTL(drvtc20)                              // retira comprimido
       li_det:=[]
      ENDIF
      SKIP                                         // pega proximo registro
     ENDD
     IF !EMPT(li_det)
      REL_CAB(1)                                   // soma cl/imprime cabecalho
      IMPCTL(drvpc20)                              // comprime os dados
      @ cl,000 SAY li_det                          // linha
      IMPCTL(drvtc20)                              // retira comprimido
      li_det:=[]
     ENDIF
     IF cl+3>maxli                                 // se cabecalho do arq filho
      REL_CAB(0)                                   // nao cabe nesta pagina
     ENDI                                          // salta para a proxima pagina
     IMPCTL(drvpc20)                               // comprime os dados
     @ ++cl,019 SAY REPL('-',10)
     @ ++cl,019 SAY TRAN(tot016005,"@E 999,999.99")// total Valor pago
     IMPCTL(drvtc20)                               // retira comprimido
     cl+=1                                         // soma contador de linha
    ENDI
    SELE ORDPGRC                                   // volta ao arquivo pai
    tot016004 := 0                                 // inicializa variaves de totais
    chv016=numop
    SELE OBXEC
    SEEK chv016
    IF FOUND()
     IF cl+3>maxli                                 // se cabecalho do arq filho
      REL_CAB(0)                                   // nao cabe nesta pagina
     ENDI                                          // salta para a proxima pagina
     IMPCTL(drvpc20)                               // comprime os dados
     cl+=1                                         // soma contador de linha
     @ cl,001 SAY "Numero  Codig Valor pago Ref"
     cl+=1                                         // soma contador de linha
     @ cl,000 SAY "======== ===== ========== ======================="
     IMPCTL(drvtc20)                               // retira comprimido
     DO WHIL ! EOF() .AND. chv016=numop //LEFT(&(INDEXKEY(0)),LEN(chv016))
      IF INKEY()=K_ESC                             // se quer cancelar
       IF canc()                                   // pede confirmacao
	BREAK                                      // confirmou...
       ENDI
      ENDI
      li_det+=TRAN(ano,"99")+;                  // Ano
	      TRAN(numero,"999999")+[ ]+;           // Numero
	      TRAN(codigo,"99999")+[]+;            // Codigo
	      TRAN(valorpg,"@E 999,999.99")+[ ]+;   // Valor pago
	      ref+[|| ]                              // Ref
      tot016004+=valorpg
      IF LEN(li_det) > 120
       REL_CAB(1)                                   // soma cl/imprime cabecalho
       IMPCTL(drvpc20)                              // comprime os dados
       @ cl,000 SAY li_det                          // linha
       IMPCTL(drvtc20)                              // retira comprimido
       li_det:=[]
      ENDIF
      SKIP                                         // pega proximo registro
     ENDD
     IF !EMPT(li_det)
      REL_CAB(1)                                   // soma cl/imprime cabecalho
      IMPCTL(drvpc20)                              // comprime os dados
      @ cl,000 SAY li_det                          // linha
      IMPCTL(drvtc20)                              // retira comprimido
      li_det:=[]
     ENDIF
     IF cl+3>maxli                                 // se cabecalho do arq filho
      REL_CAB(0)                                   // nao cabe nesta pagina
     ENDI                                          // salta para a proxima pagina
     IMPCTL(drvpc20)                               // comprime os dados
     @ ++cl,015 SAY REPL('-',10)
     @ ++cl,015 SAY TRAN(tot016004,"@E 999,999.99")// total Valor pago
     IMPCTL(drvtc20)                               // retira comprimido
     cl+=1                                         // soma contador de linha
    ENDI
    SELE ORDPGRC                                   // volta ao arquivo pai
    SKIP                                           // pega proximo registro
   ELSE                                            // se nao atende condicao
    SKIP                                           // pega proximo registro
   ENDI
  ENDD
  IF cl+3>maxli                                    // se cabecalho do arq filho
   REL_CAB(0)                                      // nao cabe nesta pagina
  ENDI                                             // salta para a proxima pagina
  @ ++cl,019 SAY REPL('-',11)
  @ ++cl,019 SAY TRAN(tot015005,"99999999.99")     // total Val Lan‡to
 ENDD ccop
 EJEC                                              // salta pagina
END SEQUENCE
SET PRINTER TO (drvporta)                          // fecha arquivo gerado (se houver)
SET DEVI TO SCRE                                   // direciona saida p/ video
IF tps=2                                           // se vai para arquivo/video
 BROWSE_REL(arq_,2,3,MAXROW()-2,78)                // mostra o arquivo gravado
ENDI
GRELA(6)                                           // grava variacao do relatorio
msgt="PROCESSAMENTOS DO RELAT¢RIO|FECHAMENTO CAIXA"
ALERTA()
********
op_:=1 //=DBOX("Prosseguir|Cancelar opera‡„o",,,E_MENU,,msgt)
********
IF op_=1
 DBOX("Processando registros",,,,NAO_APAGA,"AGUARDE!")
 dele_atu:=SET(_SET_DELETED,.t.)                   // os excluidos nao servem...
 SELE ORDPGRC                                      // processamentos apos emissao
 INI_ARQ()                                         // acha 1o. reg valido do arquivo
 DO WHIL !EOF()
  IF numconta==M->nrconta.AND.EMPT(fechto_)        // se atender a condicao...

   #ifdef COM_REDE
    IF EMPT(fechto_)
     REPBLO('ORDPGRC->fechto_',DATE())
    ENDI
    IF EMPT(fechpor)
     REPBLO('ORDPGRC->fechpor',M->usuario)
    ENDI
   #else
    IF EMPT(fechto_)
     REPL ORDPGRC->fechto_ WITH DATE()
    ENDI
    IF EMPT(fechpor)
     REPL ORDPGRC->fechpor WITH M->usuario
    ENDI
   #endi

   SKIP                                            // pega proximo registro
  ELSE                                             // se nao atende condicao
   SKIP                                            // pega proximo registro
  ENDI
 ENDD
 ALERTA(2)
 DBOX("Processo terminado com sucesso!",,,,,msgt)
ENDI
SET(_SET_DELETED,dele_atu)                         // os excluidos serao vistos
RETU

STATIC PROC REL_CAB(qt)                            // cabecalho do relatorio
IF qt>0                                            // se parametro maior que 0
 cl=cl+qt                                          // soma no contador de linhas
ENDI
IF cl>maxli .OR. qt=0                              // quebra de pagina
 IMPAC(nemp,0,000)                                 // nome da empresa
 @ 0,071 SAY "PAG"
 @ 0,075 SAY TRAN(pg_,'9999')                      // n£mero da p gina
 IMPAC(nsis,1,000)                                 // t¡tulo aplica‡„o
 @ 1,071 SAY "ADM_R030"                            // c¢digo relat¢rio
 @ 2,000 SAY "TRANSF.FINANCEIRO "+M->nrconta
 @ 2,063 SAY NSEM(DATE())                          // dia da semana
 @ 2,071 SAY DTOC(DATE())                          // data do sistema
 @ 3,000 SAY titrel                                // t¡tulo a definir
 IMPAC("N§ OP. Ori Hist DC  Val Lan‡to Documento    Complemento de Hist¢rico",4,000)
 @ 5,000 SAY REPL("-",79)
 cl=qt+5 ; pg_++
ENDI
RETU

* \\ Final de ADM_R030.PRG
€
 COBRADOR"– COBRADORCODECOB_INCLCODECOB_TELACODECOB_GETSCODECOB_GET1CODECOB_MEMOCODEC_ETEXTENDCODE	_SYMSTARTSYMSTARTSYMBOLSSYMBOLS_SYMENDSYMENDNULLBEGDATA_DATADATA_SYMPBDATA_SYMPDATA_SYMPEDATA_CONSTCONST_MSGMSG_BEGBSSBEGBSS_BSSBSS_ENDBSSENDBSSDGROUP
 Start  Stop   Length Name                   Class                  Group
 00000H 0006EH 0006FH SIXUK_TEXT             CODE
 0006FH 00833H 007C5H NATION_TEXT            CODE
 00834H 010D7H 008A4H SMTMEMO1_TEXT          CODE
 010D8H 01B4CH 00A75H GAS_PROG               CODE
 01B4EH 04A7AH 02F2DH _TEXT                  CODE
 04A7CH 04A7CH 00000H SORTBLOC_TEXT          CODE
 04A7CH 04D68H 002EDH ASUPPORT_TEXT          CODE
 04D69H 05301H 00599H FILESYS_TEXT           CODE
 05302H 05B65H 00864H DATE_TEXT              CODE
 05B66H 05BB7H 00052H OSDATE_TEXT            CODE
 05BB8H 064CBH 00914H TXOPEN_TEXT            CODE
 064CCH 069E7H 0051CH DVC_TEXT               CODE
 069E8H 06A17H 00030H HARDINIT_TEXT          CODE
 06A18H 06A93H 0007CH MAIN_TEXT              CODE
 06A94H 06D13H 00280H UPREF_TEXT             CODE
 06D14H 06D4BH 00038H SYSCALL_TEXT           CODE
 06D4CH 07114H 003C9H EVENT_DRIVER_TEXT      CODE
 07116H 07F8DH 00E78H EVENT_TEXT             CODE
 07F8EH 083DFH 00452H DYNC_TEXT              CODE
 083E0H 08421H 00042H DYNA_TEXT              CODE
 08422H 08472H 00051H WEEDBED_TEXT           CODE
 08474H 08B85H 00712H SYMSYS_TEXT            CODE
 08B86H 0BE07H 03282H OM_TEXT                CODE
 0BE08H 0D961H 01B5AH STACK_TEXT             CODE
 0D962H 0DE33H 004D2H FIELD_TEXT             CODE
 0DE34H 0E7B1H 0097EH EXTEND_TEXT            CODE
 0E7B2H 0E96DH 001BCH CALL_TEXT              CODE
 0E96EH 0EB5BH 001EEH FGET_TEXT              CODE
 0EB5CH 0F14DH 005F2H SET_TEXT               CODE
 0F14EH 10B8FH 01A42H OPS_TEXT               CODE
 10B90H 11CABH 0111CH ERRSYS1_TEXT           CODE
 11CACH 11E2DH 00182H AEVAL_TEXT             CODE
 11E2EH 124BFH 00692H ALLOC_TEXT             CODE
 124C0H 1515DH 02C9EH VM_TEXT                CODE
 1515EH 1533AH 001DDH KMAP_TEXT              CODE
 1533CH 15586H 0024BH SUBAL_TEXT             CODE
 15588H 155ECH 00065H OSMEM_TEXT             CODE
 155EEH 155F1H 00004H OSME_TEXT              CODE
 155F2H 17C82H 02691H MACRO_TEXT             CODE
 17C84H 17D43H 000C0H XMACRO_TEXT            CODE
 17D44H 19EA1H 0215EH PLANKTON_TEXT          CODE
 19EA2H 19EBEH 0001DH INSTD_TEXT             CODE
 19EC0H 1B8FBH 01A3CH GT_TEXT                CODE
 1B8FCH 1CFD3H 016D8H TERM_TEXT              CODE
 1CFD4H 1D159H 00186H BOX_TEXT               CODE
 1D15AH 1D2EBH 00192H TCVT_TEXT              CODE
 1D2ECH 1DA07H 0071CH COLOR_TEXT             CODE
 1DA08H 1DA21H 0001AH SETCURS_TEXT           CODE
 1DA22H 1EA1DH 00FFCH PICT_TEXT              CODE
 1EA1EH 1F539H 00B1CH RDDSVR_TEXT            CODE
 1F53AH 1F677H 0013EH DBJUNCT_TEXT           CODE
 1F678H 20CD3H 0165CH WORKAREA_TEXT          CODE
 20CD4H 20EA5H 001D2H NET_TEXT               CODE
 20EA6H 20EA6H 00000H SDFDYN_TEXT            CODE
 20EA6H 20EBBH 00016H EMMALLOC_TEXT          CODE
 20EBCH 20EDBH 00020H EMMCONTX_TEXT          CODE
 20EDCH 20EEBH 00010H EMMFREE_TEXT           CODE
 20EECH 20F05H 0001AH EMMMAP_TEXT            CODE
 20F06H 20F1EH 00019H EMMPAGE_TEXT           CODE
 20F20H 20F36H 00017H EMMVERS_TEXT           CODE
 20F38H 20F42H 0000BH BEEP_TEXT              CODE
 20F43H 223E4H 014A2H SCREEN_DRIVER_TEXT     CODE
 223E5H 22763H 0037FH KEYBD_DRIVER_TEXT      CODE
 22764H 22764H 00000H 6CDXDYN_TEXT           CODE
 22764H 25D0BH 035A8H CDXCORE_TEXT           CODE
 25D0CH 25D0CH 00000H SWDATA_TEXT            CODE
 25D0CH 25D0CH 00000H SWDATA2_TEXT           CODE
 25D0CH 28511H 02806H SWDBF1_TEXT            CODE
 28512H 28512H 00000H SWDBFDYN_TEXT          CODE
 28512H 28512H 00000H SWNATIO_TEXT           CODE
 28512H 28512H 00000H SWSTACK_TEXT           CODE
 28512H 286A3H 00192H SWUTIL3_TEXT           CODE
 286A4H 2878BH 000E8H TSUPPORT_TEXT          CODE
 2878CH 28CB9H 0052EH VMAPI_TEXT             CODE
 28CBAH 28DE6H 0012DH DYNAMIC_TEXT           CODE
 28DE8H 294F9H 00712H DYNX_TEXT              CODE
 294FAH 29B27H 0062EH ITEMAPI_TEXT           CODE
 29B28H 2AC61H 0113AH $$$OVLCLP              CODE                   BLICLPMGR
 2AC62H 2AC77H 00016H $$$OVLDYN              CODE                   BLICLPMGR
 2AC78H 2C0B7H 01440H $$$OVLVEC              CODE                   BLIOVLMGR
 2C0B8H 2C0C3H 0000CH $$$OVLEXE              CODE                   BLIOVLMGR
 2C0C4H 2C0C4H 00000H C_ETEXT                ENDCODE
 2C0C4H 2E653H 02590H $$$KRNCDE              BLIKRNMGR              BLIKRNMGR
 2E654H 2F97FH 0132CH $$$KRNDAT              BLIKRNMGR              BLIKRNMGR
 2F980H 2F9DFH 00060H $$$KRNINI              BLIKRNMGR              BLIKRNMGR
 2F9E0H 2FA0FH 00030H $$$KRNEXI              BLIKRNMGR              BLIKRNMGR
 2FA10H 2FA10H 00000H $$$KRNEND              BLIKRNMGR              BLIKRNMGR
 2FA10H 2FA10H 00000H _SYMSTART              SYMSTART
 2FA10H 30A6FH 01060H SYMBOLS                SYMBOLS
 30A70H 30ABFH 00050H SYMBOLS                SYMBOLS
 30AC0H 30B3FH 00080H SYMBOLS                SYMBOLS
 30B40H 30C8FH 00150H SYMBOLS                SYMBOLS
 30C90H 30DCFH 00140H SYMBOLS                SYMBOLS
 30DD0H 30DEFH 00020H SYMBOLS                SYMBOLS
 30DF0H 30ECFH 000E0H SYMBOLS                SYMBOLS
 30ED0H 3147FH 005B0H SYMBOLS                SYMBOLS
 31480H 3153FH 000C0H SYMBOLS                SYMBOLS
 31540H 3160FH 000D0H SYMBOLS                SYMBOLS
 31610H 3161FH 00010H SYMBOLS                SYMBOLS
 31620H 3163FH 00020H SYMBOLS                SYMBOLS
 31640H 3172FH 000F0H SYMBOLS                SYMBOLS
 31730H 3177FH 00050H SYMBOLS                SYMBOLS
 31780H 317BFH 00040H SYMBOLS                SYMBOLS
 317C0H 31B0FH 00350H SYMBOLS                SYMBOLS
 31B10H 31B9FH 00090H SYMBOLS                SYMBOLS
 31BA0H 31BA0H 00000H SYMBOLS                SYMBOLS
 31BA0H 31BBFH 00020H SYMBOLS                SYMBOLS
 31BC0H 31BEFH 00030H SYMBOLS                SYMBOLS
 31BF0H 31C0FH 00020H SYMBOLS                SYMBOLS
 31C10H 31C3FH 00030H SYMBOLS                SYMBOLS
 31C40H 31C5FH 00020H SYMBOLS                SYMBOLS
 31C60H 31C9FH 00040H SYMBOLS                SYMBOLS
 31CA0H 31CBFH 00020H SYMBOLS                SYMBOLS
 31CC0H 31DAFH 000F0H SYMBOLS                SYMBOLS
 31DB0H 31F2FH 00180H SYMBOLS                SYMBOLS
 31F30H 321FFH 002D0H SYMBOLS                SYMBOLS
 32200H 324CFH 002D0H SYMBOLS                SYMBOLS
 324D0H 3256FH 000A0H SYMBOLS                SYMBOLS
 32570H 3257FH 00010H SYMBOLS                SYMBOLS
 32580H 3277FH 00200H SYMBOLS                SYMBOLS
 32780H 327BFH 00040H SYMBOLS                SYMBOLS
 327C0H 327CFH 00010H SYMBOLS                SYMBOLS
 327D0H 328EFH 00120H SYMBOLS                SYMBOLS
 328F0H 328FFH 00010H SYMBOLS                SYMBOLS
 32900H 3291FH 00020H SYMBOLS                SYMBOLS
 32920H 3292FH 00010H SYMBOLS                SYMBOLS
 32930H 3294FH 00020H SYMBOLS                SYMBOLS
 32950H 3295FH 00010H SYMBOLS                SYMBOLS
 32960H 3296FH 00010H SYMBOLS                SYMBOLS
 32970H 3297FH 00010H SYMBOLS                SYMBOLS
 32980H 3298FH 00010H SYMBOLS                SYMBOLS
 32990H 3299FH 00010H SYMBOLS                SYMBOLS
 329A0H 329BFH 00020H SYMBOLS                SYMBOLS
 329C0H 32A2FH 00070H SYMBOLS                SYMBOLS
 32A30H 32A9FH 00070H SYMBOLS                SYMBOLS
 32AA0H 32AEFH 00050H SYMBOLS                SYMBOLS
 32AF0H 32BBFH 000D0H SYMBOLS                SYMBOLS
 32BC0H 32BCFH 00010H SYMBOLS                SYMBOLS
 32BD0H 32BFFH 00030H SYMBOLS                SYMBOLS
 32C00H 32C5FH 00060H SYMBOLS                SYMBOLS
 32C60H 32C6FH 00010H SYMBOLS                SYMBOLS
 32C70H 32C7FH 00010H SYMBOLS                SYMBOLS
 32C80H 32C8FH 00010H SYMBOLS                SYMBOLS
 32C90H 32CDFH 00050H SYMBOLS                SYMBOLS
 32CE0H 32CEFH 00010H SYMBOLS                SYMBOLS
 32CF0H 32D9FH 000B0H SYMBOLS                SYMBOLS
 32DA0H 32DAFH 00010H SYMBOLS                SYMBOLS
 32DB0H 32E0FH 00060H SYMBOLS                SYMBOLS
 32E10H 32F4FH 00140H SYMBOLS                SYMBOLS
 32F50H 32FAFH 00060H SYMBOLS                SYMBOLS
 32FB0H 3300FH 00060H SYMBOLS                SYMBOLS
 33010H 3308FH 00080H SYMBOLS                SYMBOLS
 33090H 330FFH 00070H SYMBOLS                SYMBOLS
 33100H 331BFH 000C0H SYMBOLS                SYMBOLS
 331C0H 331CFH 00010H SYMBOLS                SYMBOLS
 331D0H 3323FH 00070H SYMBOLS                SYMBOLS
 33240H 3330FH 000D0H SYMBOLS                SYMBOLS
 33310H 333DFH 000D0H SYMBOLS                SYMBOLS
 333E0H 3343FH 00060H SYMBOLS                SYMBOLS
 33440H 3350FH 000D0H SYMBOLS                SYMBOLS
 33510H 335EFH 000E0H SYMBOLS                SYMBOLS
 335F0H 3365FH 00070H SYMBOLS                SYMBOLS
 33660H 3369FH 00040H SYMBOLS                SYMBOLS
 336A0H 3377FH 000E0H SYMBOLS                SYMBOLS
 33780H 3383FH 000C0H SYMBOLS                SYMBOLS
 33840H 338BFH 00080H SYMBOLS                SYMBOLS
 338C0H 33A8FH 001D0H SYMBOLS                SYMBOLS
 33A90H 33A90H 00000H SYMBOLS                SYMBOLS
 33A90H 33A90H 00000H SYMBOLS                SYMBOLS
 33A90H 33A90H 00000H SYMBOLS                SYMBOLS
 33A90H 33BDFH 00150H SYMBOLS                SYMBOLS
 33BE0H 33CBFH 000E0H SYMBOLS                SYMBOLS
 33CC0H 33D6FH 000B0H SYMBOLS                SYMBOLS
 33D70H 33D70H 00000H SYMBOLS                SYMBOLS
 33D70H 347AFH 00A40H SYMBOLS                SYMBOLS
 347B0H 355EFH 00E40H SYMBOLS                SYMBOLS
 355F0H 35A0FH 00420H SYMBOLS                SYMBOLS
 35A10H 35B7FH 00170H SYMBOLS                SYMBOLS
 35B80H 35F8FH 00410H SYMBOLS                SYMBOLS
 35F90H 35F9FH 00010H SYMBOLS                SYMBOLS
 35FA0H 3610FH 00170H SYMBOLS                SYMBOLS
 36110H 3613FH 00030H SYMBOLS                SYMBOLS
 36140H 36140H 00000H SYMBOLS                SYMBOLS
 36140H 36140H 00000H SYMBOLS                SYMBOLS
 36140H 3616FH 00030H SYMBOLS                SYMBOLS
 36170H 3618FH 00020H SYMBOLS                SYMBOLS
 36190H 36190H 00000H SYMBOLS                SYMBOLS
 36190H 36190H 00000H SYMBOLS                SYMBOLS
 36190H 361AFH 00020H SYMBOLS                SYMBOLS
 361B0H 361B0H 00000H SYMBOLS                SYMBOLS
 361B0H 3623FH 00090H SYMBOLS                SYMBOLS
 36240H 364EFH 002B0H SYMBOLS                SYMBOLS
 364F0H 364F0H 00000H SYMBOLS                SYMBOLS
 364F0H 364F0H 00000H SYMBOLS                SYMBOLS
 364F0H 366AFH 001C0H SYMBOLS                SYMBOLS
 366B0H 366B0H 00000H SYMBOLS                SYMBOLS
 366B0H 366BFH 00010H SYMBOLS                SYMBOLS
 366C0H 366C0H 00000H SYMBOLS                SYMBOLS
 366C0H 3670FH 00050H SYMBOLS                SYMBOLS
 36710H 3672FH 00020H SYMBOLS                SYMBOLS
 36730H 36730H 00000H SYMBOLS                SYMBOLS
 36730H 36730H 00000H SYMBOLS                SYMBOLS
 36730H 36730H 00000H SYMBOLS                SYMBOLS
 36730H 3679FH 00070H SYMBOLS                SYMBOLS
 367A0H 367AFH 00010H SYMBOLS                SYMBOLS
 367B0H 368CFH 00120H SYMBOLS                SYMBOLS
 368D0H 368D0H 00000H SYMBOLS                SYMBOLS
 368D0H 3691FH 00050H SYMBOLS                SYMBOLS
 36920H 3699FH 00080H SYMBOLS                SYMBOLS
 369A0H 369A0H 00000H SYMBOLS                SYMBOLS
 369A0H 369BFH 00020H SYMBOLS                SYMBOLS
 369C0H 369C0H 00000H SYMBOLS                SYMBOLS
 369C0H 369C0H 00000H SYMBOLS                SYMBOLS
 369C0H 36ABFH 00100H SYMBOLS                SYMBOLS
 36AC0H 36AC0H 00000H SYMBOLS                SYMBOLS
 36AC0H 36ACFH 00010H SYMBOLS                SYMBOLS
 36AD0H 36AD0H 00000H SYMBOLS                SYMBOLS
 36AD0H 36AD0H 00000H SYMBOLS                SYMBOLS
 36AD0H 36AD0H 00000H SYMBOLS                SYMBOLS
 36AD0H 36BBFH 000F0H SYMBOLS                SYMBOLS
 36BC0H 36BCFH 00010H SYMBOLS                SYMBOLS
 36BD0H 36BD0H 00000H SYMBOLS                SYMBOLS
 36BD0H 36BEFH 00020H SYMBOLS                SYMBOLS
 36BF0H 36BF0H 00000H SYMBOLS                SYMBOLS
 36BF0H 36BFFH 00010H SYMBOLS                SYMBOLS
 36C00H 36C1FH 00020H SYMBOLS                SYMBOLS
 36C20H 36DEFH 001D0H SYMBOLS                SYMBOLS
 36DF0H 36DFFH 00010H SYMBOLS                SYMBOLS
 36E00H 36E5FH 00060H SYMBOLS                SYMBOLS
 36E60H 36E8FH 00030H SYMBOLS                SYMBOLS
 36E90H 36F4FH 000C0H SYMBOLS                SYMBOLS
 36F50H 36F5FH 00010H SYMBOLS                SYMBOLS
 36F60H 36F7FH 00020H SYMBOLS                SYMBOLS
 36F80H 36FAFH 00030H SYMBOLS                SYMBOLS
 36FB0H 36FB0H 00000H SYMBOLS                SYMBOLS
 36FB0H 36FBFH 00010H SYMBOLS                SYMBOLS
 36FC0H 36FDFH 00020H SYMBOLS                SYMBOLS
 36FE0H 36FE0H 00000H SYMBOLS                SYMBOLS
 36FE0H 3720FH 00230H SYMBOLS                SYMBOLS
 37210H 3724FH 00040H SYMBOLS                SYMBOLS
 37250H 3726FH 00020H SYMBOLS                SYMBOLS
 37270H 372DFH 00070H SYMBOLS                SYMBOLS
 372E0H 3738FH 000B0H SYMBOLS                SYMBOLS
 37390H 373BFH 00030H SYMBOLS                SYMBOLS
 373C0H 373C0H 00000H _SYMEND                SYMEND
 373C0H 373C0H 00000H _CONST                 CONST
 373C0H 37561H 001A2H OPERR                  CONST
 37562H 37562H 00000H _MSG                   MSG
 37562H 37562H 00000H _BEGBSS                BEGBSS
 37562H 37562H 00000H _ENDBSS                ENDBSS
 37562H 37562H 00000H DMTB                   DLL
 37562H 37575H 00014H DMT                    DLL
 37576H 37576H 00000H DMTE                   DLL
 37580H 39115H 01B96H MACRO5_DATA            FAR_DATA
 39120H 3914EH 0002FH SWDATA5_DATA           FAR_DATA
 39150H 3915AH 0000BH SWDATA25_DATA          FAR_DATA
 39160H 3925AH 000FBH SWNATIO5_DATA          FAR_DATA
 39260H 39260H 00000H $$DYNBEGIN             $$DYNBEGIN             DYNGROUP
 39260H 392E7H 00088H $$DYNFNAMES            $$DYNFNAMES            DYNGROUP
 392F0H 392F0H 00000H $$DYNBPAGES            $$DYNPAGES             DYNGROUP
 392F0H 39CE5H 009F6H $$DYNPAGES             $$DYNPAGES             DYNGROUP
 39CF0H 39CF0H 00000H $$DYNEND               $$DYNEND               DYNGROUP
 39CF0H 3A293H 005A4H FAR_BSS                FAR_BSS
 3A2A0H 3A2E1H 00042H NULL                   BEGDATA                DGROUP
 3A2E2H 3EF7FH 04C9EH _DATA                  DATA                   DGROUP
 3EF80H 3EF80H 00000H _SYMPB                 DATA                   DGROUP
 3EF80H 3EF8FH 00010H _SYMP                  DATA                   DGROUP
 3EF90H 3EF90H 00000H _SYMPE                 DATA                   DGROUP
 3EF90H 3EF9DH 0000EH CDATA                  DATA                   DGROUP
 3EF9EH 3EF9EH 00000H XIFB                   DATA                   DGROUP
 3EF9EH 3EFA1H 00004H XIF                    DATA                   DGROUP
 3EFA2H 3EFA2H 00000H XIFE                   DATA                   DGROUP
 3EFA2H 3EFA2H 00000H XIB                    DATA                   DGROUP
 3EFA2H 3EFA5H 00004H XI                     DATA                   DGROUP
 3EFA6H 3EFA6H 00000H XIE                    DATA                   DGROUP
 3EFA6H 3EFA6H 00000H XPB                    DATA                   DGROUP
 3EFA6H 3EFA6H 00000H XP                     DATA                   DGROUP
 3EFA6H 3EFA6H 00000H XPE                    DATA                   DGROUP
 3EFA6H 3EFA6H 00000H XCB                    DATA                   DGROUP
 3EFA6H 3EFA6H 00000H XC                     DATA                   DGROUP
 3EFA6H 3EFA6H 00000H XCE                    DATA                   DGROUP
 3EFA6H 3EFA6H 00000H XCFB                   DATA                   DGROUP
 3EFA6H 3EFA6H 00000H XCF                    DATA                   DGROUP
 3EFA6H 3EFA6H 00000H XCFE                   DATA                   DGROUP
 3EFA6H 3EFA6H 00000H XNCB                   DATA                   DGROUP
 3EFA6H 3EFCDH 00028H XNC                    DATA                   DGROUP
 3EFCEH 3EFCEH 00000H XNCE                   DATA                   DGROUP
 3EFD0H 3F117H 00148H $LIB_TABLE             DATA                   DGROUP
 3F118H 3F189H 00072H CONST                  CONST                  DGROUP
 3F18AH 3F191H 00008H HDR                    MSG                    DGROUP
 3F192H 3F307H 00176H MSG                    MSG                    DGROUP
 3F308H 3F32EH 00027H PAD                    MSG                    DGROUP
 3F32FH 3F32FH 00001H EPAD                   MSG                    DGROUP
 3F330H 3F47DH 0014EH _BSS                   BSS                    DGROUP
 3F47EH 3F47EH 00000H XOB                    BSS                    DGROUP
 3F47EH 3F47EH 00000H XO                     BSS                    DGROUP
 3F47EH 3F47EH 00000H XOE                    BSS                    DGROUP
 3F480H 3F5F5H 00176H C_COMMON               BSS                    DGROUP
 3F600H 41DFFH 02800H STACK                  STACK                  DGROUP

 Overlays

 Section Pubs  Length Name                   Module
 0001H     1     212  GETENV_TEXT            GETENV
 0002H     2      52  SQUAWK_TEXT            SQUAWK
 0003H     9     630  INITEXIT_TEXT          INITEXIT
 0004H     6     828  APPINIT_TEXT           APPINIT
 0005H     3     358  APPEXIT_TEXT           APPEXIT
 0006H     2     368  RUN_TEXT               RUN
 0007H    14    2774  SEND_TEXT              SEND
 0008H     4     238  TB_TEXT                TB
 0009H     1     390  ACOPY_TEXT             ACOPY
 000AH     1     228  ADEL_TEXT              ADEL
 000BH     1     244  AINS_TEXT              AINS
 000CH     1      62  ATAIL_TEXT             ATAIL
 000DH     4    1464  MSAVE_TEXT             MSAVE
 000EH     4     564  MRELEASE_TEXT          MRELEASE
 000FH     2     600  ERRSYS0_TEXT           ERRSYS0
 0010H     6     476  SEQ_TEXT               SEQ
 0011H     6      80  CMEM_TEXT              CMEM
 0012H    11    1608  OUTSTD_TEXT            OUTSTD
 0013H     3     118  GX_TEXT                GX
 0014H     2      32  MAXROW_TEXT            MAXROW
 0015H     2     988  SAVEREST_TEXT          SAVEREST
 0016H     1     218  SCROLL_TEXT            SCROLL
 0017H     3    1352  GETS0_TEXT             GETS0
 0018H    18    3304  GETS1_TEXT             GETS1
 0019H    50    8194  GETS2_TEXT             GETS2
 001AH    15    1808  RDDORD_TEXT            RDDORD
 001BH    10    1574  DBCMD0_TEXT            DBCMD0
 001CH    39    3158  DBCMD1_TEXT            DBCMD1
 001DH     7     884  DBCMD2_TEXT            DBCMD2
 001EH     4    1048  DBCMD3_TEXT            DBCMD3
 001FH     2     262  DBCMD5_TEXT            DBCMD5
 0020H     3     384  LUPDATE_TEXT           LUPDATE
 0021H     2     650  DBSTRUCT_TEXT          DBSTRUCT
 0022H     4    1416  DBCREATE_TEXT          DBCREATE
 0023H    21    2858  SDF1_TEXT              SDF1
 0024H     2      62  SDF0_TEXT              SDF0
 0025H    10    1270  PHILES_TEXT            PHILES
 0026H     3      61  EMMCOUNT_TEXT          EMMCOUNT
 0027H     1      48  EMMINST_TEXT           EMMINST
 0028H     1     254  EXACTCMP_TEXT          EXACTCMP
 0029H     2     166  GETE_TEXT              GETE
 002AH     1     204  DISKSPAC_TEXT          DISKSPAC
 002BH     8     993  EXAMPLEA_TEXT          EXAMPLEA
 002CH     1     288  ALLTRIM_TEXT           ALLTRIM
 002DH     1     276  RIGHT_TEXT             RIGHT
 002EH     1     330  DESCEND_TEXT           DESCEND
 002FH     1     226  RAT_TEXT               RAT
 0030H     1     328  PADL_TEXT              PADL
 0031H     1     326  PADR_TEXT              PADR
 0032H     1     326  PADC_TEXT              PADC
 0033H     1     996  STRTRAN_TEXT           STRTRAN
 0034H     1     240  MEMOREAD_TEXT          MEMOREAD
 0035H     1     688  MEMOLINE_TEXT          MEMOLINE
 0036H     1     342  MLCOUNT_TEXT           MLCOUNT
 0037H     2     492  LINELEN_TEXT           LINELEN
 0038H     2     344  ASCAN_TEXT             ASCAN
 0039H     4     932  ASORT_TEXT             ASORT
 003AH     4    1152  DIRECT_TEXT            DIRECT
 003BH    49   11920  MEMOEDIT_TEXT          MEMOEDIT
 003CH    13    7322  TBROWSE0_TEXT          TBROWSE0
 003DH    66    9954  TBROWSE1_TEXT          TBROWSE1
 003EH     6     240  CDX0_TEXT              CDXMACH6
 003FH    17    3502  CDX2_TEXT              CDX2
 0040H     4    2910  CDX3_TEXT              CDX3
 0041H    14   12700  CDXCREAT_TEXT          CDXCREAT
 0042H    17    3004  CDXDIREC_TEXT          CDXDIREC
 0043H     2     440  CDXFREEL_TEXT          CDXFREEL
 0044H     4    3790  CDXINDEX_TEXT          CDXINDEX
 0045H     5     788  CDXLOCK_TEXT           CDXLOCK
 0046H     1     212  CDXTRYO_TEXT           CDXTRYO
 0047H     8    2294  SMTMEMO2_TEXT          SMTMEMO2
 0048H     3      70  SWDBF0_TEXT            SWDBF0
 0049H    18    3302  SWDBF2_TEXT            SWDBF2
 004AH     7    2130  SWENCODE_TEXT          SWENCODE
 004BH     2     466  SWFILE_TEXT            SWFILE
 004CH     5     134  SWIFUNC_TEXT           SWIFUNC
 004DH     6    1632  SWIND1_TEXT            SWIND1
 004EH     2    2360  SWINDEX1_TEXT          SWINDEX1
 004FH     5    1750  SWKILLT_TEXT           SWKILLT
 0050H     9    1020  SWLCK_TEXT             SWLCK
 0051H     8    3290  SWMEMO1_TEXT           SWMEMO1
 0052H     2     276  SWMEMO2_TEXT           SWMEMO2
 0053H     3    1074  SWOPT_TEXT             SWOPT
 0054H     5     510  SWPAGE_TEXT            SWPAGE
 0055H     5    1762  SWRLOCK_TEXT           SWRLOCK
 0056H     3    2048  SWSURF_TEXT            SWSURF
 0057H     3     748  SWTRIGGE_TEXT          SWTRIGGE
 0058H     8     978  SWUTIL_TEXT            SWUTIL
 0059H     4     418  SWUTIL2_TEXT           SWUTIL2
 005AH    13    3700  VFCORE_TEXT            VFCORE
 005BH     4    1242  M6CRTMAP_TEXT          M6CRTMAP
 005CH     1     960  M6CSAND_TEXT           M6CSAND
 005DH     1     406  M6CSNOT_TEXT           M6CSNOT
 005EH     1     778  M6CSOR_TEXT            M6CSOR
 005FH     7    1038  M6DBF1_TEXT            M6DBF1
 0060H     2     876  M6EQUAL_TEXT           M6EQUAL
 0061H     5     156  M6ERROR_TEXT           M6ERROR
 0062H     3     704  M6EVAL_TEXT            M6EVAL
 0063H     3    1414  M6FILT1_TEXT           M6FILT1
 0064H     5    1028  M6FILT2_TEXT           M6FILT2
 0065H     1     374  M6GETVAL_TEXT          M6GETVAL
 0066H     1     480  M6GREAT_TEXT           M6GREAT
 0067H     1     108  M6INIT_TEXT            M6INIT
 0068H     1     492  M6INSTR_TEXT           M6INSTR
 0069H     5    2314  M6ISKEY_TEXT           M6ISKEY
 006AH     2     876  M6ISOPT_TEXT           M6ISOPT
 006BH     1     420  M6LESS_TEXT            M6LESS
 006CH     4    1566  M6LOCA1_TEXT           M6LOCA1
 006DH     4    2024  M6LOGIC_TEXT           M6LOGIC
 006EH     1     626  M6NEQUAL_TEXT          M6NEQUAL
 006FH     2    1158  M6OPTDEL_TEXT          M6OPTDEL
 0070H     1     192  M6OURDRV_TEXT          M6OURDRV
 0071H     1     470  M6RANGE_TEXT           M6RANGE
 0072H     6    2462  M6SMART_TEXT           M6SMART
 0073H     6    1640  M6STKEXP_TEXT          M6STKEXP
 0074H     6     968  M6STRING_TEXT          M6STRING
 0075H     1     438  M6SWHILE_TEXT          M6SWHILE
 0076H     6    2646  M6TOKE_TEXT            M6TOKE
 0077H     4     696  M6TRANS_TEXT           M6TRANS
 0078H    13    3430  M6VMMAP_TEXT           M6VMMAP
 0079H     1     308  MEMORY_TEXT            MEMORY
 007AH    19    3030  DISKIO_TEXT            DISKIO
 007BH    23    6076  SORTOF_TEXT            SORTOF
 -------------------
 Total        177908
 -------------------

 Origin    Group
 29B2:0008 BLICLPMGR
 2AC7:0008 BLIOVLMGR
 2C0C:0004 BLIKRNMGR
 3926:0000 DYNGROUP
 3A2A:0000 DGROUP

  Address         Publics by Value

 0000:0000  Abs  __START_SYM
 0000:0000  Res  __NPREVC
 0000:0029  Res  __NNEXTC
 0000:0052  Res  __ZCMP
 0000:006E  Res  __FORCE_ASCII
 0006:010F  Res  _NATSORTVE
 0006:013E  Res  __NATRDDVER
 0006:0150  Res  __NLEXID
 0006:01BA  Res  __NSCANID
 0006:0238  Res  __UPCASE
 0006:024B  Res  __LOCASE
 0006:025E  Res  __CH_TYPE
 0006:02C7  Res  __NCOPYUC
 0006:02E6  Res  __NCOPYLC
 0006:0305  Res  __NTRIMLEN
 0006:0326  Res  __NPREVI
 0006:0339  Res  __NNEXTI
 0006:0350  Res  __NGET
 0006:0365  Res  __NPUT
 0006:037A  Res  __TCMP
 0006:03A2  Res  __DCMP
 0006:03C3  Res  __XCMP
 0006:03DD  Res  __SCANW
 0006:0411  Res  __SCANN
 0006:045F  Res  __NODE_SEARCH
 0006:04B9  Res  __S_ORDER
 0006:05BA  Res  _NATMSGVER
 0006:05D3  Res  ISNEGATIVE
 0006:0620  Res  ISAFFIRM
 0006:066D  Res  NATIONMSG
 0006:06B0  Res  __DAY_NAME
 0006:06C8  Res  __MONTH_NAME
 0006:06E0  Res  __YNSTR
 0006:06F2  Res  __NATMSGVER
 0006:0704  Res  __ERRORDESC
 0006:075C  Res  __NVERSION
 0006:07C2  Res  _CLIPINTL
 010D:0008  Res  VUF
 010D:004E  Res  DECRIPT
 010D:004E  Res  ENCRIPT
 010D:0176  Res  SEPLETRA
 010D:02BF  Res  QUALDIR
 010D:0346  Res  CHDIR
 010D:034A  Res  MKDIR
 010D:034E  Res  RMDIR
 010D:039F  Res  CALLINT
 010D:04A4  Res  VAL_CF
 010D:04B4  Res  VAL_AX
 010D:04BA  Res  VAL_BX
 010D:04C0  Res  VAL_CX
 010D:04C6  Res  VAL_DX
 010D:04CC  Res  VAL_DS
 010D:04D2  Res  VAL_ES
 010D:04D8  Res  VAL_DI
 010D:04DE  Res  VAL_SI
 010D:04E4  Res  VAL_FLAGS
 010D:04EC  Res  VAL_AH
 010D:04F2  Res  VAL_BH
 010D:04F8  Res  VAL_CH
 010D:04FE  Res  VAL_DH
 010D:0504  Res  VAL_AL
 010D:050A  Res  VAL_BL
 010D:0510  Res  VAL_CL
 010D:0516  Res  VAL_DL
 010D:060A  Res  OK_PRINT
 010D:0653  Res  PEEK
 010D:06E2  Res  POKE
 010D:07A7  Res  LTOC
 010D:07E9  Res  CONTA
 010D:0834  Res  IMPOK
 010D:0886  Res  F_ERROR
 010D:08AC  Res  IS_FERROR
 010D:08CD  Res  SET_FERROR
 010D:08EE  Res  CLR_FERROR
 010D:090D  Res  ALOCAMEM
 010D:0956  Res  QDE_FREE
 010D:095C  Res  HEXA_DEC
 010D:09F8  Res  TAMASTRI
 010D:0A15  Res  _CONTA
 010D:0A2B  Res  FONTEVGA
 01B4:001E  Res  __ASTART
 01B4:00C8  Res  __CINTDIV
 01B4:00D7  Res  __AMSG_EXIT
 01B4:00EC  Res  __CINIT
 01B4:01B0  Res  _EXIT
 01B4:01C7  Res  __EXIT
 01B4:020E  Res  __CTERMSUB
 01B4:024E  Res  __FPTRAP
 01B4:0254  Res  __FF_MSGBANNER
 01B4:0278  Res  __NULLCHECK
 01B4:029E  Res  __NMSG_TEXT
 01B4:02C9  Res  __NMSG_WRITE
 01B4:02F4  Res  __SETENVP
 01B4:0370  Res  __SETARGV
 01B4:0518  Res  __AFLDIV
 01B4:05B4  Res  __AFULMUL
 01B4:05B4  Res  __AFLMUL
 01B4:05E8  Res  __AFULREM
 01B4:0654  Res  __AFULDIV
 01B4:06C9  Res  __SLDS
 01B4:06CD  Res  __ELDS
 01B4:06EB  Res  __FLDS
 01B4:0715  Res  __SLDD
 01B4:0719  Res  __ELDD
 01B4:0739  Res  __FLDD
 01B4:0768  Res  __SLDT
 01B4:076E  Res  __FLDT
 01B4:07A2  Res  __SLDL
 01B4:07A6  Res  __ELDL
 01B4:07AF  Res  __SLDW
 01B4:07B3  Res  __ELDW
 01B4:07B9  Res  __FLDL
 01B4:07C0  Res  __FLDW
 01B4:07C2  Res  B$FIL2
 01B4:07C3  Res  B$FILD
 01B4:0817  Res  __FDUP
 01B4:0846  Res  __FLDZ
 01B4:086C  Res  __SSTS
 01B4:0870  Res  __FSTS
 01B4:0874  Res  __ESTS
 01B4:0884  Res  __SSTSP
 01B4:0888  Res  __FSTSP
 01B4:088C  Res  __ESTSP
 01B4:08BA  Res  __SSTD
 01B4:08BE  Res  __FSTD
 01B4:08C2  Res  __ESTD
 01B4:08D2  Res  __SSTDP
 01B4:08D6  Res  __FSTDP
 01B4:08DA  Res  __ESTDP
 01B4:0903  Res  __SSTT
 01B4:0907  Res  __FSTT
 01B4:091A  Res  __SSTTP
 01B4:091E  Res  __FSTTP
 01B4:0941  Res  B$FIS2
 01B4:0949  Res  B$FIST
 01B4:0951  Res  B$FUST
 01B4:0989  Res  __FTOL
 01B4:09C2  Res  __FTST
 01B4:09EF  Res  __FABS
 01B4:09FE  Res  __FCHS
 01B4:0A36  Res  __SSUBS
 01B4:0A3E  Res  __ESUBS
 01B4:0A45  Res  __FSUBS
 01B4:0A4E  Res  __SSUBSR
 01B4:0A56  Res  __ESUBSR
 01B4:0A5D  Res  __FSUBSR
 01B4:0A66  Res  __SMULS
 01B4:0A6E  Res  __EMULS
 01B4:0A75  Res  __FMULS
 01B4:0A7E  Res  __SDIVS
 01B4:0A86  Res  __EDIVS
 01B4:0A8D  Res  __FDIVS
 01B4:0A96  Res  __SDIVSR
 01B4:0A9E  Res  __EDIVSR
 01B4:0AA5  Res  __FDIVSR
 01B4:0AAE  Res  __SADDS
 01B4:0AB6  Res  __EADDS
 01B4:0ABD  Res  __FADDS
 01B4:0AF5  Res  __SSUBD
 01B4:0AFD  Res  __ESUBD
 01B4:0B04  Res  __FSUBD
 01B4:0B0D  Res  __SSUBDR
 01B4:0B15  Res  __ESUBDR
 01B4:0B1C  Res  __FSUBDR
 01B4:0B25  Res  __SMULD
 01B4:0B2D  Res  __EMULD
 01B4:0B34  Res  __FMULD
 01B4:0B3D  Res  __SDIVD
 01B4:0B45  Res  __EDIVD
 01B4:0B4C  Res  __FDIVD
 01B4:0B55  Res  __SDIVDR
 01B4:0B5D  Res  __EDIVDR
 01B4:0B64  Res  __FDIVDR
 01B4:0B6D  Res  __SADDD
 01B4:0B75  Res  __EADDD
 01B4:0B7C  Res  __FADDD
 01B4:0B9B  Res  __FSUB
 01B4:0BA0  Res  __FSUBR
 01B4:0BA5  Res  __FMUL
 01B4:0BAA  Res  __FDIV
 01B4:0BAF  Res  __FDIVR
 01B4:0BB4  Res  __FADD
 01B4:0BB9  Res  __FCOMPP
 01B4:0BB9  Res  B$FCMP
 01B4:0BBE  Res  __FCMP
 01B4:0C4C  Res  __FXCHQ
 01B4:0C5A  Res  __FXCH
 01B4:0C80  Res  __DCVT
 01B4:0C98  Res  $I4_ERRPINF
 01B4:0C98  Res  $I8_ERRINF
 01B4:0C98  Res  $I8_ERRMINF
 01B4:0C98  Res  $I8_ERRPINF
 01B4:0C98  Res  $I4_ERRMINF
 01B4:0C98  Res  $I4_ERRINF
 01B4:0CA2  Res  $I4_ERRDIV0
 01B4:0CA2  Res  $I8_ERRDIV0
 01B4:0CAC  Res  $I8_ERRINVLD
 01B4:0CAC  Res  $I4_ERRINVLD
 01B4:0CB6  Res  $I8_ERRSTACK
 01B4:0CC9  Res  __FPSIGNAL
 01B4:0D06  Res  __FPMATH
 01B4:0D34  Res  __SMOVTMPESBX
 01B4:0D36  Res  __SMOVTMPESSI
 01B4:0D4A  Res  __DMOVTMPESBX
 01B4:0D4C  Res  __DMOVTMPESSI
 01B4:0D62  Res  __DCVTST0
 01B4:0D6E  Res  __DCVTST0A
 01B4:0D71  Res  __DCVTDISI
 01B4:0DB0  Res  __CTRANDISP2
 01B4:0DC8  Res  __CTRANDISP1
 01B4:0EB4  Res  $I4_CMP
 01B4:0F07  Res  $I8_CMP
 01B4:0F59  Res  $I8_4
 01B4:0F9A  Res  $I4_8
 01B4:101C  Res  $I4_W
 01B4:101E  Res  $I4_Q
 01B4:1026  Res  $I4_S
 01B4:1032  Res  $I4_L
 01B4:104C  Res  $I8_W
 01B4:104E  Res  $I8_Q
 01B4:1056  Res  $I8_S
 01B4:1062  Res  $I8_L
 01B4:1081  Res  $I4_TO_S
 01B4:1086  Res  $I4_TO_SIRND
 01B4:1086  Res  $I4_TO_SRND
 01B4:108B  Res  $I8_TO_S
 01B4:1090  Res  $I8_TO_SRND
 01B4:1090  Res  $I8_TO_SIRND
 01B4:109D  Res  $I4_TO_W
 01B4:10A2  Res  $I4_TO_WRND
 01B4:10A2  Res  $I4_TO_WIRND
 01B4:10A7  Res  $I8_TO_W
 01B4:10AC  Res  $I8_TO_WRND
 01B4:10AC  Res  $I8_TO_WIRND
 01B4:10B4  Res  $I4_TO_LRND
 01B4:10B4  Res  $I4_TO_LIRND
 01B4:10B9  Res  $I8_TO_LIRND
 01B4:10B9  Res  $I8_TO_LRND
 01B4:10BE  Res  $I4_TO_L
 01B4:10C3  Res  $I8_TO_L
 01B4:10E3  Res  $I4_TO_QIRND
 01B4:10E3  Res  $I4_TO_QRND
 01B4:10E8  Res  $I8_TO_QIRND
 01B4:10E8  Res  $I8_TO_QRND
 01B4:1107  Res  $I8_TO_Q
 01B4:113C  Res  $I4_TO_Q
 01B4:11B8  Res  $I8_FIXRND
 01B4:11B8  Res  $I8_FIXIRND
 01B4:11DE  Res  $I4_FIXIRND
 01B4:11DE  Res  $I4_FIXRND
 01B4:1202  Res  $I8_FIX
 01B4:1212  Res  $I4_FIX
 01B4:132C  Res  $I4_SUBREV
 01B4:132E  Res  $I4_SUB
 01B4:1336  Res  $I4_ADD
 01B4:1408  Res  $I4_NORM
 01B4:1436  Res  $I4_ROUND
 01B4:1498  Res  $I4_MUL
 01B4:151C  Res  $I4_DIVREV
 01B4:151E  Res  $I4_DIV
 01B4:1626  Res  $I8_SUBREV
 01B4:1628  Res  $I8_SUB
 01B4:164B  Res  $I8_ADD
 01B4:177E  Res  $I8_NORM
 01B4:17D4  Res  $I8_ROUND
 01B4:1852  Res  $I8_MUL
 01B4:18B3  Res  $I8_DIVREV
 01B4:18B5  Res  $I8_DIV
 01B4:1BE7  Res  $I8_LGT
 01B4:1BFD  Res  $I8_LOG
 01B4:1CB4  Res  $I8_EXP
 01B4:1CC8  Res  $I8_EXPADJUST
 01B4:1D03  Res  $I8_PF_PWR
 01B4:1D1A  Res  $I8_C_PWR
 01B4:1D1E  Res  $I8_PWR
 01B4:1E18  Res  $I8_PWR_L
 01B4:1E18  Res  $I8_PF_PWR_L
 01B4:1EAE  Res  $I8_SQR
 01B4:1F6C  Res  $I8_ADDF
 01B4:1F70  Res  $I8_ADDFSI
 01B4:1F76  Res  $I8_SUBF
 01B4:1F7A  Res  $I8_SUBFSI
 01B4:1F80  Res  $I8_MULF
 01B4:1F84  Res  $I8_MULFSI
 01B4:1F8A  Res  $I8_DIVF
 01B4:1F8E  Res  $I8_DIVFSI
 01B4:1F94  Res  $I8_SUBR
 01B4:1F98  Res  $I8_SUBRDI
 01B4:1F9E  Res  $I8_DIVR
 01B4:1FA2  Res  $I8_DIVRDI
 01B4:1FA8  Res  $I8_CLEARAC
 01B4:1FB8  Res  $I8_MOVAC
 01B4:1FC1  Res  $I8_MOVAC_ARG
 01B4:1FD1  Res  $I8_MOVARG_AC
 01B4:1FD5  Res  $I8_MOVARG
 01B4:1FE0  Res  $I8_MOVTEMP
 01B4:1FEB  Res  $I8_PSHARG
 01B4:1FF0  Res  $I8_PSHAC
 01B4:1FF4  Res  $I8_PSHSI
 01B4:2002  Res  $I8_POPARG
 01B4:2007  Res  $I8_POPAC
 01B4:200B  Res  $I8_POPSI
 01B4:2019  Res  $I8_POLY
 01B4:205E  Res  $I8_EVEN
 01B4:2094  Res  $I8_EXPM1
 01B4:20A5  Res  $I8_EXPM1REDUCED
 01B4:20D5  Res  $I8_LNREDUCEAC_HI
 01B4:20DB  Res  $I8_LNREDUCE
 01B4:20EA  Res  $I8_RETONE
 01B4:20F4  Res  $I8_RETZERO
 01B4:210B  Res  $I8_OVERFLOWRANGE
 01B4:2110  Res  $I8_EXPHRANGE
 01B4:2118  Res  $I8_EXPRANGE
 01B4:211E  Res  $I8_RANGE
 01B4:2142  Res  $I8_P_Q
 01B4:2178  Res  $I8_Z2P_Q
 01B4:2189  Res  $I8_Z3P_Q
 01B4:2192  Res  $I8_REDUCE
 01B4:21AE  Res  $I8_TMUL
 01B4:2314  Res  $I8_TPWR10
 01B4:2384  Res  $I8_INPUT
 01B4:26D0  Res  $I8_OUTPUT
 01B4:27D0  Res  _FLOOR
 01B4:27E0  Res  _CEIL
 01B4:2846  Res  _FMOD
 01B4:28A1  Res  _POW
 01B4:28AA  Res  _LOG
 01B4:28B3  Res  _LOG10
 01B4:28BC  Res  _EXP
 01B4:28C5  Res  _SQRT
 01B4:28CE  Res  __MYALLOC
 01B4:2910  Res  __WRT2ERR
 01B4:291F  Res  _MATHERR
 01B4:292D  Res  __DVINIT
 01B4:2956  Res  __DVADD
 01B4:299D  Res  __DVSUB
 01B4:29E4  Res  __DVMUL
 01B4:2A2B  Res  __DVDIV
 01B4:2A72  Res  __DVTOQ
 01B4:2A8D  Res  __DVTOI
 01B4:2AA8  Res  __DVTOL
 01B4:2AC3  Res  __DVFMQ
 01B4:2B0B  Res  __DVFMI
 01B4:2B45  Res  __DVFML
 01B4:2B80  Res  __DVFMA
 01B4:2BFA  Res  __NTOA
 01B4:2CFC  Res  __ATON
 01B4:2D52  Res  __LNTOA
 01B4:2DF1  Res  __CFLTCVT
 01B4:2DF2  Res  __CROPZEROS
 01B4:2DF3  Res  __FASSIGN
 01B4:2DF4  Res  __FORCDECPT
 01B4:2DF5  Res  __POSITIVE
 01B4:2DF6  Res  __CFTOE
 01B4:2DF7  Res  __CFTOF
 01B4:2DF8  Res  __CFTOG
 01B4:2E10  Res  __TERMHOOK
 01B4:2E22  Res  __GTHOOK
 01B4:2E34  Res  __DBCMDHOOK
 01B4:2E46  Res  __AFLSHR
 01B4:2E52  Res  __AFLREM
 01B4:2EF4  Res  __AFNALDIV
 01B4:2F18  Res  __DYNXHOOK
 01B4:2F2A  Res  __DISKIOHOOK
 04A7:000C  Res  __PTOABSADDR
 04A7:002D  Res  _STRCPY
 04A7:004F  Res  _STCCPY
 04A7:0078  Res  _STRNCPY
 04A7:00A1  Res  __BSET
 04A7:00C4  Res  __BMOVE
 04A7:0119  Res  __BCOPY
 04A7:0137  Res  __BCOPYF
 04A7:0166  Res  __LCOPY
 04A7:0184  Res  __BCMP
 04A7:01AC  Res  __BSCAN
 04A7:01D0  Res  __U2HEX
 04A7:01FF  Res  _STRCAT
 04A7:0229  Res  _STPCHR
 04A7:0256  Res  _STPBLK
 04A7:027D  Res  _STRLEN
 04A7:0299  Res  __DOSFUNC
 04A7:02CB  Res  __ASMCALL
 04D6:0037  Res  __TINIT
 04D6:0085  Res  __TEND
 04D6:00CD  Res  __FSCREATE
 04D6:00FA  Res  __TCTEMP
 04D6:018B  Res  __FSOPEN
 04D6:01BC  Res  __FSCLOSE
 04D6:01DE  Res  __FSREAD
 04D6:020B  Res  __FSWRITE
 04D6:0238  Res  __FSSEEK
 04D6:0271  Res  __FSLOCK
 04D6:02B0  Res  __TMNAME
 04D6:02E6  Res  __FSDELETE
 04D6:030A  Res  __FSRENAME
 04D6:0331  Res  __THCOUNT
 04D6:0375  Res  __FSCOMMIT
 04D6:038F  Res  __FSERROR
 04D6:03B4  Res  __TISDEVICE
 04D6:03D3  Res  __TDEVRAW
 04D6:040F  Res  __F_FIRST
 04D6:0434  Res  __F_NEXT
 04D6:044F  Res  __DSPACE
 04D6:0473  Res  __TMKDIR
 04D6:04A0  Res  __TRMDIR
 04D6:04CD  Res  __TCHDIR
 04D6:04FA  Res  __TCURDRV
 04D6:0516  Res  __TCHDRV
 04D6:0541  Res  __TISDRV
 04D6:0565  Res  __TCURDIR
 0530:010C  Res  __DDMYTODATE
 0530:01EE  Res  __DDATETODMYD
 0530:0324  Res  __DSYSDATE
 0530:0348  Res  __DALPHATODATEFMT
 0530:045A  Res  __DALPHATODATEDBF
 0530:0514  Res  __DDATETOALPHAFMT
 0530:060A  Res  __DDATETOALPHADBF
 0530:0696  Res  __DSETFMT
 0530:084C  Res  __DSETEPOCH
 05B6:0006  Res  __OSDATE
 05B6:002D  Res  __OSTIME
 05BB:008E  Res  __SCAN_FILENAME
 05BB:01C0  Res  __TXOPEN
 05BB:0866  Res  FILE
 05BB:0894  Res  __FSEXTOPEN
 064C:000C  Res  __DVLT
 064C:0034  Res  __DVLE
 064C:005C  Res  __DVEQ
 064C:0084  Res  __DVGE
 064C:00AC  Res  __DVGT
 064C:00D4  Res  __DVNE
 064C:00FC  Res  __DVLTZ
 064C:0124  Res  __DVEQZ
 064C:014C  Res  __DVMOD
 064C:0196  Res  __DVNEG
 064C:01C6  Res  __DVABS
 064C:0218  Res  __DVINC
 064C:024C  Res  __DVDEC
 064C:0280  Res  __DVINT
 064C:02EA  Res  __DVPOW
 064C:0334  Res  __DVLOG
 064C:0372  Res  __DVSQR
 064C:03B0  Res  __DVEXP
 064C:03EE  Res  __DVRND
 069E:0008  Res  __SYSHARDINIT
 06A1:0008  Res  _TERM
 06A1:0036  Res  _MAIN
 06A9:017C  Res  __UPREFP
 06A9:0220  Res  __UPREF
 06D1:0004  Res  __SYSCALL
 06D4:0367  Res  __EVLOW
 06D4:0367  Res  __EVEENTRY
 0711:0568  Res  __EVSENDSTRUCT
 0711:0622  Res  __EVSENDID
 0711:0638  Res  __EVPOSTSTRUCT
 0711:0658  Res  __EVPOSTID
 0711:0686  Res  __EVREGRECEIVERFUNC
 0711:07B8  Res  __EVDEREGRECEIVER
 0711:07E6  Res  __SYSREGLOW
 0711:07FE  Res  __EVREGTYPE
 0711:0810  Res  __EVSEND
 0711:0816  Res  __EVPOST
 0711:0866  Res  __EVMODALREAD
 0711:092A  Res  __EVTRANSLATE
 0711:0974  Res  __EVBREAKENABLE
 0711:09AA  Res  __EVSCROLLPAUSE
 0711:0A00  Res  __EVSTROBE
 0711:0A24  Res  __BREAK_CYCLE
 0711:0AD4  Res  SETCANCEL
 0711:0B94  Res  ALTD
 0711:0DE6  Res  __EVENT_INIT
 07F8:00CC  Res  __DYNFREEMODULE
 07F8:01EC  Res  __DYNGETORDADDR
 07F8:0288  Res  __DYNGETNAMEDADDR
 07F8:035A  Res  __DYNLOADMODULE
 07F8:0426  Res  __DYNINIT
 07F8:0436  Res  __DYNINI
 083E:0000  Res  _DMOD_COUNT
 083E:0015  Res  _DINIT_INIT
 0842:0002  Res  __WEED_EATR
 0842:0030  Res  __START_PROC
 0847:0330  Res  _WEED_DIGESTR
 0847:035A  Res  __GET_SYM
 0847:0426  Res  __CHK_SYM
 0847:048A  Res  __CHK_SYM2
 0847:05A4  Res  __SYM_SEARCH
 0847:05F0  Res  __NEXT_SYM
 0847:0676  Res  __SYM_INIT
 08B8:03B4  Res  _ARRAYNEW
 08B8:04DE  Res  _BLOCKNEW
 08B8:0594  Res  _BYTESNEW
 08B8:0792  Res  __OCOPY
 0000:9876  Abs  __ACRTUSED
 0000:9876  Abs  __ACRTMSG
 0000:9876  Abs  __FLTUSED
 08B8:1AEE  Res  __XCHECK
 08B8:1AFC  Res  __OSCAVENGEALL
 08B8:1B50  Res  __OESTIMATE
 08B8:1B5C  Res  __IARRAYAT
 08B8:1BDE  Res  __CAT
 08B8:1CFA  Res  __CATPUT
 08B8:1ED8  Res  __IARRAYPUT
 08B8:1F04  Res  __IARRAYC2
 08B8:1FF6  Res  _VARRAY
 08B8:2038  Res  _VARRAYX
 08B8:208C  Res  _VARRAYLEN
 08B8:20CE  Res  __VDICT
 08B8:211E  Res  __VSETDICT
 08B8:218A  Res  _VSTR
 08B8:21E0  Res  _VSTRX
 08B8:2234  Res  _VSTR2
 08B8:2306  Res  _VSTRLOCK
 08B8:2370  Res  _VSTRUNLOCK
 08B8:23C4  Res  _VSTRCOLD
 08B8:241C  Res  _BYTESNEW2
 08B8:243C  Res  _OSTRDUP
 08B8:24F4  Res  __CATAT
 08B8:2568  Res  __CATPUTSTR
 08B8:26F6  Res  __IMAKEA
 08B8:275C  Res  __IMAKELA
 08B8:2818  Res  ARRAY
 08B8:28B6  Res  _CSCANCHECK
 08B8:294E  Res  __CCOPY
 08B8:29CC  Res  __CBECOME
 08B8:2BEC  Res  __CRESIZE
 08B8:2E9A  Res  ASIZE
 08B8:2EFE  Res  __AADD
 08B8:2F68  Res  __XUNLOCK
 08B8:2FBA  Res  __XXLOCK
 08B8:31D8  Res  __OM_INIT
 0BE0:0008  Res  __FIXLEN
 0BE0:012E  Res  __SPTOQ
 0BE0:0160  Res  __SPTOL
 0BE0:0196  Res  __PUTQ
 0BE0:01B8  Res  __PUTL
 0BE0:01D4  Res  __PUTLN
 0BE0:01F8  Res  __PUTCL
 0BE0:0234  Res  __PUTC
 0BE0:0268  Res  __PUTSYM
 0BE0:0286  Res  __PARAM
 0BE0:02FA  Res  __LPARAM
 0BE0:0358  Res  __ISAVERET
 0BE0:0378  Res  __RETL
 0BE0:0390  Res  __RETQ
 0BE0:03AE  Res  __RETC
 0BE0:09EE  Res  __IMVCLEAN
 0BE0:0A90  Res  __IMVWIPE
 0BE0:0B78  Res  __IGETM
 0BE0:0BDC  Res  __XPUSHM
 0BE0:0C1A  Res  __XPOPM
 0BE0:0C82  Res  __IPUBLICS
 0BE0:0C96  Res  __QQPUB
 0BE0:0CC0  Res  __IPRIVATES
 0BE0:0CD6  Res  __IPARAMS
 0BE0:0DC2  Res  __IPUSHM
 0BE0:0E2A  Res  __CALLERPOPM
 0BE0:0F64  Res  __IPOPM
 0BE0:0FB2  Res  __IPUSHMR
 0BE0:107C  Res  __IPUSHLR
 0BE0:10E4  Res  __IPUSHFLR
 0BE0:114C  Res  __IPUSHSR
 0BE0:11B4  Res  __ISINIT
 0BE0:1214  Res  __ISFRAME
 0BE0:1226  Res  __GETGRIP
 0BE0:1284  Res  __DROPGRIP
 0BE0:129C  Res  __IPUSHBLOCK
 0BE0:13B4  Res  __IZZBLOCK
 0BE0:1504  Res  __IXBLOCK
 0BE0:174C  Res  __IZZACT
 0BE0:188C  Res  __CEVAL0
 0BE0:18B6  Res  __CEVAL1
 0BE0:18EC  Res  __ACTINFO
 0BE0:1946  Res  __ACTCOUNT
 0BE0:19DE  Res  __STACK_EXIT
 0BE0:1A82  Res  __STACK_INIT
 0D96:0002  Res  __XPUSHF
 0D96:0188  Res  __XPOPF
 0D96:01F4  Res  __IPUSHV
 0D96:0282  Res  __IPUSHF
 0D96:02FC  Res  __IPOPF
 0D96:0376  Res  __IPUSHQF
 0D96:03FC  Res  __IPOPQF
 0D96:0482  Res  __FCHECK
 0DE3:0278  Res  __STORCLEN
 0DE3:036E  Res  __STORC
 0DE3:03AC  Res  __PARINFO
 0DE3:0402  Res  __PARINFA
 0DE3:051A  Res  __PARCPEEK
 0DE3:0566  Res  __PARC
 0DE3:0602  Res  __PARCSIZ
 0DE3:0646  Res  __PARCLEN
 0DE3:0670  Res  __PARNI
 0DE3:06B8  Res  __PARNL
 0DE3:0704  Res  __PARND
 0DE3:0768  Res  __PARL
 0DE3:077E  Res  __PARDS
 0DE3:07AA  Res  __STORND
 0DE3:07E4  Res  __STORNL
 0DE3:0804  Res  __STORNI
 0DE3:0824  Res  __STORL
 0DE3:0840  Res  __STORDS
 0DE3:087A  Res  __RETCLEN
 0DE3:08AC  Res  __RETNI
 0DE3:08CE  Res  __RETNL
 0DE3:08F2  Res  __RETND
 0DE3:091A  Res  __RETDS
 0DE3:094E  Res  __RET
 0DE3:0950  Res  __RETA
 0DE3:095E  Res  __EXMGRAB
 0DE3:096E  Res  __EXMBACK
 0E7B:005C  Res  __ICALL
 0E96:000E  Res  FIELDGET
 0E96:0086  Res  FIELDPUT
 0E96:0128  Res  FIELDPOS
 0EB5:000C  Res  __SETSTRUCT
 0EB5:0188  Res  SET
 0F14:010C  Res  __STRMINUS
 0F14:0202  Res  __MIN
 0F14:02D8  Res  __MAX
 0F14:03B2  Res  __MODULUS
 0F14:047E  Res  __INT
 0F14:0540  Res  __ROUND
 0F14:05D4  Res  __EXPON
 0F14:0714  Res  __LOGQ
 0F14:0720  Res  __QEXP
 0F14:072C  Res  __QSQRT
 0F14:0738  Res  __CHR
 0F14:0786  Res  __SPACE
 0F14:0810  Res  __SUB3
 0F14:0958  Res  __SUB2
 0F14:0A44  Res  __LEFT
 0F14:0AE8  Res  __STR3
 0F14:0BF8  Res  __STR2
 0F14:0CC0  Res  __STR1
 0F14:0D74  Res  __TRIM
 0F14:0DF0  Res  __LTRIM
 0F14:0E7E  Res  __UPPER
 0F14:0EE0  Res  __LOWER
 0F14:0F42  Res  __REPLICATE
 0F14:1068  Res  __VAL
 0F14:115A  Res  __LEN
 0F14:11A2  Res  __EMPTY
 0F14:1284  Res  __AT
 0F14:13C6  Res  __INSTR
 0F14:14FE  Res  __ASC
 0F14:1544  Res  __TIME
 0F14:15E8  Res  __SECONDS
 0F14:16A4  Res  __DATE
 0F14:16C4  Res  __DAY
 0F14:1712  Res  __MONTH
 0F14:1762  Res  __YEAR
 0F14:17B2  Res  __DOW
 0F14:1802  Res  __CMONTH
 0F14:1852  Res  __CDOW
 0F14:18A2  Res  __DTOC
 0F14:18E4  Res  __CTOD
 0F14:192A  Res  __DTOS
 0F14:196C  Res  __WORD
 0F14:19AA  Res  __VALTYPE
 0F14:1A46  Res  LEFT
 10B9:0036  Res  _TB
 10B9:0088  Res  __IERROR
 10B9:0136  Res  __AFAIL
 10B9:01CA  Res  __SODIUM
 10B9:01D6  Res  __SALTY_DYN
 10B9:025C  Res  __ECANCEL
 10B9:02C8  Res  ERRORINHAN
 10B9:0408  Res  __EGENCODE
 10B9:041C  Res  __ESEVERIT
 10B9:0430  Res  __ECANRETR
 10B9:0448  Res  __ECANDEFA
 10B9:0460  Res  __ECANSUBS
 10B9:0478  Res  __ETRIES
 10B9:048C  Res  __EOSCODE
 10B9:04A0  Res  __ESUBCODE
 10B9:04B4  Res  __ESUBSYST
 10B9:04C0  Res  __EDESCRIP
 10B9:04CC  Res  __EOPERATI
 10B9:04D8  Res  __EFILENAM
 10B9:04E4  Res  __EPARAMS
 10B9:04F0  Res  __ECARGO
 10B9:04FC  Res  __ESETGENC
 10B9:05C4  Res  __ESETSUBC
 10B9:061E  Res  __ESETOSCO
 10B9:0678  Res  __ESETSEVE
 10B9:06D2  Res  __ESETCAND
 10B9:0716  Res  __ESETCANR
 10B9:075A  Res  __ESETCANS
 10B9:079E  Res  __ESETTRIE
 10B9:07F8  Res  __ESETSUBS
 10B9:0808  Res  __ESETOPER
 10B9:0818  Res  __ESETDESC
 10B9:0828  Res  __ESETFILE
 10B9:0838  Res  __ESETPARA
 10B9:0848  Res  __ESETCARG
 10B9:0858  Res  ERRORNEW
 10B9:0AF0  Res  __EOP
 10B9:0BA8  Res  __EERROR
 10B9:0C0A  Res  __ENOALIAS
 10B9:0CB6  Res  __ENOVAR
 10B9:0D26  Res  __EERRORP
 10B9:0E3A  Res  __EARG
 10B9:0E56  Res  __ENOTABLE
 10B9:0ED0  Res  __ENOFUNC
 10B9:0F46  Res  __EREGNFHANDLER
 10B9:0F70  Res  __ENOMETHOD
 10B9:101E  Res  __EPSTACK
 10B9:1034  Res  ERRORBLOCK
 10B9:1094  Res  DOSERROR
 10B9:10BC  Res  __ESETDOSERROR
 10B9:10C8  Res  NETERR
 10B9:10FE  Res  __ESETNETERR
 10B9:110E  Res  __ECLASSNA
 11CA:000C  Res  AEVAL
 11E2:0264  Res  __CYCLEF
 11E2:04F8  Res  __XALLOC
 11E2:0592  Res  __XFREE
 11E2:061C  Res  __XGRAB
 11E2:064C  Res  __ALLOCF
 11E2:068E  Res  __FREEF
 124C:0760  Res  __VMADD
 124C:0B7E  Res  __VMPREALLOC
 124C:144E  Res  __VMDISCARD
 124C:150C  Res  __VMFREE
 124C:152E  Res  __VMPTR
 124C:158C  Res  __VMDIRTYPTR
 124C:15EA  Res  __VMTWO
 124C:16FA  Res  __VMALLOCF
 124C:1730  Res  __VMALLOC
 124C:1766  Res  __VMALLOCD
 124C:17A2  Res  __VMALLOCO
 124C:17E2  Res  __VMXFR
 124C:1B52  Res  __VMFIX
 124C:1C46  Res  __VMLOCKOVL
 124C:1D92  Res  __VMUNLOCKOVL
 124C:1DA0  Res  __VMPENDINGOVL
 124C:1DAE  Res  __VMUNLOCK
 124C:1DBC  Res  __VMLOCK
 124C:1E5E  Res  __VMLOCKSEG
 124C:1ECC  Res  __VMSIZE
 124C:1EDC  Res  __VMREALLOC
 124C:2040  Res  __VMXCHG
 124C:20D4  Res  __VMSTAT
 124C:21E0  Res  __VMSTATN
 124C:2222  Res  __VMSTATE
 124C:2250  Res  __V16
 124C:2318  Res  __V32
 124C:2496  Res  __MEM_RESUME
 124C:24B2  Res  __MEM_SUSPEND
 124C:2572  Res  __MEM_EXIT
 124C:267A  Res  _DSNORMAL
 124C:2694  Res  __EFAULT
 124C:2890  Res  __MEM_INIT2
 124C:28C4  Res  __MEM_INIT
 1515:000E  Res  __KMAPSCAN
 1515:013D  Res  __KMAPSET
 1515:0194  Res  __KMAPCLEAR
 1533:000C  Res  __MEMSUBFREE
 1533:0020  Res  __MEMSUBALLOC
 1533:00B1  Res  __MEMSUBALLOCFIRST
 1533:00C3  Res  __MEMSUBINFO
 1533:013D  Res  __MEMSUBAVAIL
 1533:014C  Res  __MEMSUBMAX
 1533:015D  Res  __MEMSUBEXTENT
 1533:0171  Res  __MEMSUBEMPTY
 1533:0188  Res  __MEMSUBREINIT
 1533:01D5  Res  __MEMSUBINIT
 1533:020E  Res  __MEMSUBNEXT
 1533:0253  Res  __MEMSUBCHECK
 1558:0008  Res  __OSALLOCDEFSEG
 1558:0032  Res  __OSAVAIL
 1558:0042  Res  __OSALLOC
 1558:0056  Res  __OSSIZE
 155E:000E  Res  __OSSTACKBASE
 155F:0EBC  Res  __LEX_
 155F:14E6  Res  __MAC_IMMED
 155F:1628  Res  __DBGMACRO
 155F:16D8  Res  __WAVE_
 155F:17EA  Res  __WAVEPOP_
 155F:186E  Res  __WAVEP_
 155F:18F2  Res  __WAVEL_
 155F:190A  Res  __WAVEA_
 155F:1B28  Res  __WAVEQ_
 155F:1B5E  Res  __WAVEPOPQ_
 155F:1B9A  Res  __WAVEF_
 155F:1C18  Res  __WAVEPOPF_
 155F:1C9C  Res  __WSYMBOL_
 155F:201A  Res  __TYPE_
 155F:20D4  Res  _AMBIGBLOCK
 155F:22CA  Res  _DOSTUFF
 155F:252C  Res  __PARSE_
 17C8:0004  Res  __VMACRO
 17C8:0066  Res  __BMACRO
 17D4:0004  Res  __PLANK_INIT
 17D4:0031  Res  __TPLANK
 17D4:006A  Res  _ERRORBUILD
 17D4:00D7  Res  _ERRORCYCLE
 17D4:0137  Res  __PLANKTON
 17D4:01C3  Res  __SPLANKTON
 17D4:01E2  Res  __DPLANKTON
 17D4:0409  Res  _DBGENTRY
 17D4:0427  Res  _DBGEXIT
 17D4:0445  Res  __NOCODE
 17D4:044D  Res  __DYNBADNEWS
 17D4:0458  Res  __0ERR
 17D4:0462  Res  __0ENDPROC
 17D4:0475  Res  __0NOP
 17D4:0478  Res  __0LINE
 17D4:04B9  Res  __0EVENTS
 17D4:04CD  Res  __0JMP
 17D4:04D4  Res  __0JF
 17D4:04F2  Res  __0JFPT
 17D4:0513  Res  __0JT
 17D4:0531  Res  __0JTPF
 17D4:0552  Res  __0JDBG
 17D4:0572  Res  __0UNDEF
 17D4:057A  Res  __0TRUE
 17D4:0589  Res  __0FALSE
 17D4:0596  Res  __0NULL
 17D4:05AF  Res  __0ZER0
 17D4:05C4  Res  __0ONE1
 17D4:05DB  Res  __0PUSHW
 17D4:05F0  Res  __0PUSHI
 17D4:0608  Res  __0PUSHN
 17D4:0632  Res  __0PUSHC
 17D4:065A  Res  __0PUSHBL
 17D4:068C  Res  __0ZZBLOCK
 17D4:069E  Res  __0DO
 17D4:078D  Res  __DDO
 17D4:0889  Res  __XDO
 17D4:08AB  Res  __0FUNC
 17D4:09BC  Res  __0XBLOCK
 17D4:0A34  Res  __XEVAL
 17D4:0B00  Res  __0SEND
 17D4:0BF1  Res  __0CALL
 17D4:0CD6  Res  __0PCOUNT
 17D4:0CEE  Res  __0FRAME
 17D4:0D37  Res  __0SINIT
 17D4:0D5F  Res  __0SFRAME
 17D4:0D7F  Res  __0PUBLICS
 17D4:0D98  Res  __0PRIVATES
 17D4:0DB1  Res  __0PARAMS
 17D4:0DCA  Res  __0ARRAYATI
 17D4:0DF1  Res  __0ARRAYAT
 17D4:0E5D  Res  __0ARRAYPUTI
 17D4:0E84  Res  __0ARRAYPUT
 17D4:0EF0  Res  __0MAKEA
 17D4:0F09  Res  __0MAKELA
 17D4:0F22  Res  __0PUSHL
 17D4:0F67  Res  __0POPL
 17D4:0FB5  Res  __0PUSHLR
 17D4:0FCE  Res  __0PUSHFL
 17D4:1016  Res  __0POPFL
 17D4:105E  Res  __0PUSHFLR
 17D4:1088  Res  __0PUSHS
 17D4:109F  Res  __0POPS
 17D4:10B6  Res  __0PUSHSR
 17D4:10CF  Res  __0PUSHM
 17D4:10F7  Res  __0MPUSHM
 17D4:1115  Res  __0POPM
 17D4:113D  Res  __0MPOPM
 17D4:115B  Res  __0PUSHMR
 17D4:1183  Res  __0MPUSHMR
 17D4:11A1  Res  __0PUSHF
 17D4:11C9  Res  __0MPUSHF
 17D4:11E7  Res  __0POPF
 17D4:120F  Res  __0MPOPF
 17D4:122D  Res  __0PUSHQF
 17D4:1255  Res  __0MPUSHQF
 17D4:1273  Res  __0POPQF
 17D4:129B  Res  __0MPOPQF
 17D4:12B9  Res  __0PUSHV
 17D4:12E1  Res  __0MPUSHV
 17D4:12FF  Res  __0PUSHRV
 17D4:131D  Res  __0SAVE_RET
 17D4:1324  Res  __0DOOP
 17D4:132A  Res  __0QSELF
 17D4:1334  Res  __0POP
 17D4:133A  Res  __0PUSHA
 17D4:1393  Res  __0MPUSHA
 17D4:13B5  Res  __0PUSHP
 17D4:13B8  Res  __0MPUSHP
 17D4:13BB  Res  __0SYMBOL
 17D4:13DF  Res  __0SYMF
 17D4:1408  Res  __0MSYMBOL
 17D4:141E  Res  __0MSYMF
 17D4:1439  Res  __0BEGIN_SEQ
 17D4:1460  Res  __0BREAK
 17D4:1467  Res  __0END_SEQ
 17D4:147A  Res  _COERCENUMS
 17D4:14F1  Res  _COERCEDNUMS
 17D4:15A1  Res  __0JNEI
 17D4:15E1  Res  __0JISW
 17D4:1621  Res  __XEQ
 17D4:164E  Res  __0EEQ
 17D4:1757  Res  __0EQ
 17D4:1820  Res  __0NE
 17D4:18EC  Res  __0LT
 17D4:19A8  Res  __XLT
 17D4:19DD  Res  __0LE
 17D4:1A99  Res  __0GT
 17D4:1B55  Res  __0GE
 17D4:1C11  Res  __0NOT
 17D4:1C25  Res  __0AND
 17D4:1C42  Res  __0OR
 17D4:1C5F  Res  __0NEGATE
 17D4:1CBE  Res  __0ABS
 17D4:1D27  Res  __0PLUS
 17D4:1EA0  Res  __0MINUS
 17D4:1F7F  Res  __0MULT
 17D4:2001  Res  __0DIVIDE
 17D4:209C  Res  __0DEC
 17D4:20FF  Res  __0INC
 19EA:0002  Res  __INSTD_
 19EC:00B4  Res  __GTWCREATE
 19EC:0116  Res  __GTWDESTROY
 19EC:016A  Res  __GTWFLASH
 19EC:024A  Res  __GTWAPP
 19EC:025E  Res  __GTWCURRENT
 19EC:0370  Res  __GTWPOS
 19EC:03A2  Res  __GTWVIS
 19EC:04F2  Res  __GTMODALREAD
 19EC:0F14  Res  __GTSLR
 19EC:0F86  Res  DISPBEGIN
 19EC:0F8C  Res  DISPEND
 19EC:0F92  Res  DISPCOUNT
 19EC:0FB4  Res  __GTSCRDIM
 19EC:0FCE  Res  __GTISCOLOR
 19EC:0FDE  Res  __GTMAXROW
 19EC:0FE8  Res  __GTMAXCOL
 19EC:0FF2  Res  __GTSETCURSOR
 19EC:1012  Res  __GTGETCURSOR
 19EC:1028  Res  __GTSETPOS
 19EC:104A  Res  __GTGETPOS
 19EC:106E  Res  __GTSETCOLOR
 19EC:109E  Res  __GTGETCOLOR
 19EC:10C2  Res  __GTSETBORDER
 19EC:1122  Res  __GTBEGINWRITE
 19EC:12EE  Res  __GTENDWRITE
 19EC:13EA  Res  __GTSCROLL
 19EC:1470  Res  __GTWRITEAT
 19EC:14DA  Res  __GTWRITE
 19EC:1506  Res  __GTWRITECON
 19EC:16A0  Res  __GTREPCHAR
 19EC:16F2  Res  __GTRECTSIZE
 19EC:1736  Res  __GTSAVE
 19EC:1790  Res  __GTREST
 19EC:17EA  Res  __GTBOX
 19EC:1858  Res  __GTBOXS
 19EC:1876  Res  __GTBOXD
 19EC:1894  Res  __GTSETSNOWFLAG
 19EC:18CC  Res  __GTSETBLINK
 19EC:18EC  Res  __GTFLUSHCURSOR
 19EC:1900  Res  __GTPREEXT
 19EC:1932  Res  __GTPOSTEXT
 19EC:199C  Res  __GTSETMODE
 19EC:19F0  Res  __GTDISPCOUNT
 19EC:1A08  Res  __GTDISPBEGIN
 19EC:1A2C  Res  __GTDISPEND
 1B8F:000C  Res  _SETLASTTRAN
 1B8F:001E  Res  __DBGTERMX
 1B8F:0238  Res  __INKEY0
 1B8F:025A  Res  _NOW
 1B8F:02AC  Res  __INKEY1
 1B8F:03AE  Res  NEXTKEY
 1B8F:041E  Res  LASTKEY
 1B8F:04C8  Res  __KEYBOARD
 1B8F:0616  Res  SETKEY
 1B8F:06EC  Res  __MODAL_KEY
 1B8F:0812  Res  __PCOL
 1B8F:0822  Res  __PROW
 1B8F:0832  Res  SETPRC
 1B8F:0A68  Res  __EJECT
 1B8F:0BD0  Res  __CQOUT
 1B8F:0BF6  Res  QQOUT
 1B8F:0CBC  Res  QOUT
 1B8F:0CD2  Res  __XSETCURSOR
 1B8F:0D10  Res  __SETPOS
 1B8F:0D5E  Res  __SETPOSBS
 1B8F:0D96  Res  DISPOUT
 1B8F:0E70  Res  __DEVPOS
 1B8F:0EF8  Res  DEVOUT
 1B8F:0FF8  Res  __ROW
 1B8F:1022  Res  __COL
 1B8F:13A2  Res  __XHELP
 1B8F:14E0  Res  __TERMSLR
 1B8F:1590  Res  __PRINTOUT
 1B8F:15B6  Res  __CONOUT
 1CFD:0004  Res  DISPBOX
 1D15:000A  Res  __TCVT
 1D2E:000C  Res  _CPARSE
 1D2E:0256  Res  _SPARSE
 1D2E:035C  Res  __XSETCOLOR
 1D2E:05E4  Res  SETCOLOR
 1D2E:05FE  Res  SETBLINK
 1D2E:0704  Res  COLORSELEC
 1DA0:0008  Res  SETCURSOR
 1DA2:0002  Res  __PARSEATS
 1DA2:01A2  Res  __PICTLITERAL
 1DA2:025C  Res  __DATETEMPLATE
 1DA2:0878  Res  __TBUFFPREP
 1DA2:0930  Res  __ZZTRAN
 1DA2:0CC2  Res  __ZTRAN
 1DA2:0E32  Res  __XTRAN
 1DA2:0E72  Res  __YTRAN
 1DA2:0EB4  Res  __TRANS
 1DA2:0F2E  Res  DEVOUTPICT
 1DA2:0FFC  Res  TRANSFORM
 1EA1:0064  Res  __ISRDD
 1EA1:028E  Res  __ISRDDTYPE
 1EA1:0536  Res  __DBUNLOADALL
 1EA1:05F2  Res  __RDDDISINHERIT
 1EA1:0642  Res  __RDDINHERIT
 1EA1:0704  Res  __XFTABLEGETPTR
 1EA1:0756  Res  __XFTABLEDISCARDPTR
 1EA1:07FA  Res  __RDDSERVERSHUTDOWN
 1EA1:0828  Res  RDDREGISTE
 1EA1:08DA  Res  RDDLIST
 1EA1:09F2  Res  __RDDEXTENDTYPE
 1EA1:0A8E  Res  __RDDFIELDTYPE
 1F53:0010  Res  __XPARAMERROR
 1F53:002A  Res  __XNOTABLEERROR
 1F53:0040  Res  __XSELECT
 1F53:00D2  Res  __STRIMTOUPPER
 20CD:0004  Res  __NETMESS
 20CD:0006  Res  __NETALCK
 20CD:004C  Res  __NETAUNL
 20CD:006C  Res  __NETFLCK
 20CD:008C  Res  __NETFUNL
 20CD:00AE  Res  __NETRLCK
 20CD:00D6  Res  __NETRUNL
 20CD:00FC  Res  __NETWHO
 20CD:0110  Res  NETNAME
 20CD:0190  Res  __INDEXEXCLLOCK
 20CD:01B4  Res  __INDEXEXCLUNLOCK
 20EA:0006  Res  __EMMALLOCPAGES
 20EB:000C  Res  __EMMCONTEXTSAVE
 20EB:001C  Res  __EMMCONTEXTREST
 20ED:000C  Res  __EMMDEALLOCPAGES
 20EE:000C  Res  __EMMMAPUNMAPPAGE
 20F0:0006  Res  __EMMGETPAGEFRAMESEG
 20F2:0000  Res  __EMMGETVERSION
 20F3:0008  Res  __BEEP_
 2276:0004  Res  _CDXTAGVALTOKEY
 2276:00BE  Res  _CDXTAGSKIP
 2276:07D0  Res  _CDXKEYSEEK
 2276:0FE8  Res  _CDXTAGGOTO
 2276:1090  Res  _CDXTAGINSERTKEY
 2276:23A0  Res  _CDXTAGDELETEKEY
 2276:2B4E  Res  __CDXGOCOLD
 2276:2F16  Res  _CDXTAGGOTOP
 2276:2F5C  Res  _CDXTAGGOBOTTOM
 2276:2FA4  Res  _CDXTAGGOSELF
 2276:310E  Res  _CDXTAGSEEK
 2276:3246  Res  __CDXKEYREFRESH
 2276:327C  Res  __CDXREBUILDKEYS
 25D0:000C  Res  __SWDOERROR
 25D0:00E2  Res  _SXDBFREAD
 25D0:03C6  Res  _SXDBFWRITE
 25D0:0648  Res  _SXDBFWRITEHEADER
 25D0:0782  Res  _GET_RECCOUNT
 25D0:07BE  Res  __SXDBFGOHOT
 25D0:0828  Res  __SXDBFGOCOLD
 25D0:088E  Res  __SXDBFGOTOID
 25D0:08D8  Res  __SXDBFGOTO
 25D0:09EA  Res  __SXDBFGOTOP
 25D0:0A2E  Res  __SXDBFGOBOTTOM
 25D0:0AA2  Res  __SXDBFSKIPRAW
 25D0:0B10  Res  __SXDBFSKIP
 25D0:0BD8  Res  __SXDBFFLUSH
 25D0:0CE6  Res  __SXDBFCLOSE
 25D0:0F98  Res  __SXDBFSETFIELDEXTENT
 25D0:0FD2  Res  __SXDBFADDFIELD
 25D0:1402  Res  __SWDEFALIAS
 25D0:1494  Res  __SXDBFOPEN
 25D0:182C  Res  __SXDBFCREATE
 25D0:1BAE  Res  __SXDBFNEW
 25D0:1BDA  Res  __SXDBFGETVARLEN
 25D0:1C4A  Res  __SXDBFGETVALUE
 25D0:1EAE  Res  __SXDBFPUTVALUE
 25D0:21DC  Res  __SXDBFBOF
 25D0:2212  Res  __SXDBFEOF
 25D0:2248  Res  __SXDBFFOUND
 25D0:227E  Res  __SXDBFLOCK
 25D0:22E0  Res  __SXDBFFLOCK
 25D0:2390  Res  __SXDBFAPPEND
 25D0:2672  Res  __SXDBFPUTREC
 25D0:26B8  Res  __SXDBFTRANSREC
 25D0:2786  Res  __SXDBFTRANS
 2851:0002  Res  __SWOURDRIVER
 2851:0132  Res  ___DBL2X
 286A:0004  Res  __TCREAT
 286A:001A  Res  __TUNLINK
 286A:002E  Res  __TOPEN
 286A:0044  Res  __TCLOSE
 286A:0054  Res  __TREAD
 286A:006E  Res  __TWRITE
 286A:0088  Res  __TLSEEK
 286A:00A2  Res  __TRENAME
 286A:00BC  Res  __TLOCK
 286A:00DC  Res  __TCOMMIT
 2878:000C  Res  __XVALLOC
 2878:0064  Res  __XVFREE
 2878:0090  Res  __XVREALLOC
 2878:00F8  Res  __XVLOCK
 2878:0142  Res  __XVWIRE
 2878:0188  Res  __XVUNLOCK
 2878:01D6  Res  __XVUNWIRE
 2878:01E6  Res  __XVLOCKCOUNT
 2878:0224  Res  __XVSIZE
 2878:0262  Res  __XVHEAPNEW
 2878:02D0  Res  __XVHEAPDESTROY
 2878:02E0  Res  __XVHEAPRESIZE
 2878:03D2  Res  __XVHEAPALLOC
 2878:0428  Res  __XVHEAPFREE
 2878:0478  Res  __XVHEAPLOCK
 2878:04E6  Res  __XVHEAPUNLOCK
 28CB:000A  Res  __DYN_INIT
 28CB:0015  Res  __DYN_RELEASE
 28CB:001C  Res  __DYN_GETNBRPAGES
 28CB:0054  Res  __DYN_GETPAGE
 28CB:00B9  Res  __DYN_FNAME
 28DE:0540  Res  __DYNX_READ
 28DE:068A  Res  __DYNXSLR
 294F:007A  Res  __ITEMSIZE
 294F:00BA  Res  __ITEMRELEASE
 294F:00D8  Res  __ITEMNEW
 294F:00E8  Res  __ITEMTYPE
 294F:00F6  Res  __ITEMPUTL
 294F:0126  Res  __ITEMPUTCL
 294F:0166  Res  __ITEMPUTC
 294F:018E  Res  __ITEMCOPYC
 294F:01D6  Res  __ITEMPUTNL
 294F:0208  Res  __ITEMPUTND
 294F:0252  Res  __ITEMPUTDS
 294F:02A8  Res  __ITEMGETC
 294F:02B6  Res  __ITEMFREEC
 294F:02CC  Res  __ITEMGETNL
 294F:02DA  Res  __ITEMGETL
 294F:02E6  Res  __ITEMGETDS
 294F:030E  Res  __ITEMGETND
 294F:0374  Res  __ITEMPARAM
 294F:03AC  Res  __ITEMRETURN
 294F:03D0  Res  __ITEMARRAYNEW
 294F:03EE  Res  __ITEMARRAYGET
 294F:042C  Res  __ITEMARRAYPUT
 294F:045A  Res  __EVALNEW
 294F:0480  Res  __EVALPUTPARAM
 294F:049E  Res  __EVALLAUNCH
 294F:05CC  Res  __EVALRELEASE
 29B2:0008  Pag  ADRBIG
 29B2:000F  Pag  PEGA_SENHA
 29B2:0016  Pag  FIM_PW
 29B2:0024  Pag  RDDSYS
 29B2:002B  Pag  SIXTOOLS
 29B2:0032  Pag  ODOMETER
 29B2:0040  Pag  BXR_07F9
 29B2:0047  Pag  BXR_06F9
 29B2:004E  Pag  BXR_02F9
 29B2:0055  Pag  BXR_01F9
 29B2:005C  Pag  BXREC
 29B2:0063  Pag  BXR_INCL
 29B2:006A  Pag  BXR_REL
 29B2:0071  Pag  BXR_ANT_SE
 29B2:0078  Pag  BXR_CRIA_S
 29B2:007F  Pag  BXR_GERA_S
 29B2:0086  Pag  BXR_GRAVA_
 29B2:008D  Pag  BXR_TELA
 29B2:0094  Pag  BXR_GETS
 29B2:009B  Pag  BXR_GET1
 29B2:00A2  Pag  ALE_01F9
 29B2:00A9  Pag  ALENDER
 29B2:00B0  Pag  ALE_INCL
 29B2:00B7  Pag  ALE_ANT_SE
 29B2:00BE  Pag  ALE_CRIA_S
 29B2:00C5  Pag  ALE_GERA_S
 29B2:00CC  Pag  ALE_GRAVA_
 29B2:00D3  Pag  ALE_TELA
 29B2:00DA  Pag  ALE_GETS
 29B2:00E1  Pag  ALE_GET1
 29B2:00E8  Pag  OBX_07F9
 29B2:00EF  Pag  OBX_01F9
 29B2:00F6  Pag  OBXEC
 29B2:00FD  Pag  OBX_INCL
 29B2:0104  Pag  OBX_REL
 29B2:010B  Pag  OBX_ANT_SE
 29B2:0112  Pag  OBX_CRIA_S
 29B2:0119  Pag  OBX_GERA_S
 29B2:0120  Pag  OBX_GRAVA_
 29B2:0127  Pag  OBX_TELA
 29B2:012E  Pag  OBX_GETS
 29B2:0135  Pag  OBX_GET1
 29B2:013C  Pag  GRU_01F9
 29B2:0143  Pag  GRU_02F9
 29B2:014A  Pag  GRUPOS
 29B2:0151  Pag  GRU_INCL
 29B2:0158  Pag  GRU_TELA
 29B2:015F  Pag  GRU_GETS
 29B2:0166  Pag  GRU_GET1
 29B2:016D  Pag  GRU_MEMO
 29B2:0174  Pag  TAX_INCL
 29B2:017B  Pag  TAX_TELA
 29B2:0182  Pag  TAX_GETS
 29B2:0189  Pag  TAX_GET1
 29B2:0190  Pag  ECO_INCL
 29B2:0197  Pag  ECO_TELA
 29B2:019E  Pag  ECO_GETS
 29B2:01A5  Pag  ECO_GET1
 29B2:01AC  Pag  INS_INCL
 29B2:01B3  Pag  INS_TELA
 29B2:01BA  Pag  INS_GETS
 29B2:01C1  Pag  INS_GET1
 29B2:01C8  Pag  CTAINSC
 29B2:01CF  Pag  CTXAS
 29B2:01D6  Pag  TAX_02F9
 29B2:01DD  Pag  INS_01F9
 29B2:01E4  Pag  INS_02F9
 29B2:01EB  Pag  GUI_07F9
 29B2:01F2  Pag  GUI_06F9
 29B2:01F9  Pag  GUI_08F9
 29B2:0200  Pag  GUI_02F9
 29B2:0207  Pag  GUIAS
 29B2:020E  Pag  GUI_INCL
 29B2:0215  Pag  GUI_REL
 29B2:021C  Pag  GUI_ANT_SE
 29B2:0223  Pag  GUI_CRIA_S
 29B2:022A  Pag  GUI_GERA_S
 29B2:0231  Pag  GUI_GRAVA_
 29B2:0238  Pag  GUI_TELA
 29B2:023F  Pag  GUI_GETS
 29B2:0246  Pag  GUI_GET1
 29B2:024D  Pag  MFILIAL
 29B2:0254  Pag  MFI_INCL
 29B2:025B  Pag  MFI_ANT_SE
 29B2:0262  Pag  MFI_CRIA_S
 29B2:0269  Pag  MFI_GERA_S
 29B2:0270  Pag  MFI_GRAVA_
 29B2:0277  Pag  MFI_TELA
 29B2:027E  Pag  MFI_GETS
 29B2:0285  Pag  MFI_GET1
 29B2:028C  Pag  ADP_R101
 29B2:029A  Pag  ADC_RX76
 29B2:02A8  Pag  GET_MSG
 29B2:02AF  Pag  R07701F9
 29B2:02B6  Pag  R07702F9
 29B2:02BD  Pag  CAD_04F9
 29B2:02C4  Pag  KINSCF9
 29B2:02CB  Pag  AFUNER
 29B2:02D2  Pag  AFU_INCL
 29B2:02D9  Pag  AFU_REL
 29B2:02E0  Pag  AFU_ANT_SE
 29B2:02E7  Pag  AFU_CRIA_S
 29B2:02EE  Pag  AFU_GERA_S
 29B2:02F5  Pag  AFU_GRAVA_
 29B2:02FC  Pag  AFU_TELA
 29B2:0303  Pag  AFU_GETS
 29B2:030A  Pag  AFU_GET1
 29B2:0311  Pag  R02001F9
 29B2:0318  Pag  R02002F9
 29B2:031F  Pag  ADM_R020
 29B2:032D  Pag  R02BP1F9
 29B2:0334  Pag  V02001F9
 29B2:033B  Pag  V02002F9
 29B2:0342  Pag  R02901F9
 29B2:0349  Pag  ADR_R029
 29B2:0357  Pag  RX2001F9
 29B2:035E  Pag  RX2002F9
 29B2:0365  Pag  ADM_RX20
 29B2:0373  Pag  RX2901F9
 29B2:037A  Pag  ADR_RX29
 29B2:0388  Pag  ADM_R029
 29B2:0396  Pag  ADM_R026
 29B2:03A4  Pag  ADM_R021
 29B2:03B2  Pag  DCI_P001
 29B2:03B9  Pag  DCI01F9
 29B2:03C0  Pag  DCI02F9
 29B2:03C7  Pag  DCI03F9
 29B2:03CE  Pag  DCI04F9
 29B2:03D5  Pag  ADM_RS18
 29B2:03E3  Pag  V01801F9
 29B2:03EA  Pag  ADM_R023
 29B2:03F8  Pag  V02301F9
 29B2:03FF  Pag  ADM_R022
 29B2:040D  Pag  R03001F9
 29B2:0414  Pag  ADM_R039
 29B2:0422  Pag  IMP_01F9
 29B2:0429  Pag  IMPPAR
 29B2:0430  Pag  IMP_INCL
 29B2:0437  Pag  IMP_TELA
 29B2:043E  Pag  IMP_GETS
 29B2:0445  Pag  IMP_GET1
 29B2:044C  Pag  MEDICOS
 29B2:0453  Pag  MED_INCL
 29B2:045A  Pag  MED_ANT_SE
 29B2:0461  Pag  MED_CRIA_S
 29B2:0468  Pag  MED_GERA_S
 29B2:046F  Pag  MED_GRAVA_
 29B2:0476  Pag  MED_TELA
 29B2:047D  Pag  MED_GETS
 29B2:0484  Pag  MED_GET1
 29B2:048B  Pag  MED_MEMO
 29B2:0492  Pag  TESPEC
 29B2:0499  Pag  TES_INCL
 29B2:04A0  Pag  TES_TELA
 29B2:04A7  Pag  TES_GETS
 29B2:04AE  Pag  TES_GET1
 29B2:04B5  Pag  JUROS
 29B2:04BC  Pag  JUR_INCL
 29B2:04C3  Pag  JUR_TELA
 29B2:04CA  Pag  JUR_GETS
 29B2:04D1  Pag  JUR_GET1
 29B2:04D8  Pag  TFILIAIS
 29B2:04DF  Pag  TFI_INCL
 29B2:04E6  Pag  TFI_TELA
 29B2:04ED  Pag  TFI_GETS
 29B2:04F4  Pag  TFI_GET1
 29B2:04FB  Pag  TFI_MEMO
 29B2:0502  Pag  ARQGRUP
 29B2:0509  Pag  ARQ_INCL
 29B2:0510  Pag  ARQ_TELA
 29B2:0517  Pag  ARQ_GETS
 29B2:051E  Pag  ARQ_GET1
 29B2:0525  Pag  REGIAO
 29B2:052C  Pag  REG_INCL
 29B2:0533  Pag  REG_ANT_SE
 29B2:053A  Pag  REG_CRIA_S
 29B2:0541  Pag  REG_GERA_S
 29B2:0548  Pag  REG_GRAVA_
 29B2:054F  Pag  REG_TELA
 29B2:0556  Pag  REG_GETS
 29B2:055D  Pag  REG_GET1
 29B2:0564  Pag  COB_01F9
 29B2:056B  Pag  COBRADOR
 29B2:0572  Pag  COB_INCL
 29B2:0579  Pag  COB_TELA
 29B2:0580  Pag  COB_GETS
 29B2:0587  Pag  COB_GET1
 29B2:058E  Pag  COB_MEMO
 29B2:0595  Pag  CLASSES
 29B2:059C  Pag  CLA_INCL
 29B2:05A3  Pag  CLA_ANT_SE
 29B2:05AA  Pag  CLA_CRIA_S
 29B2:05B1  Pag  CLA_GERA_S
 29B2:05B8  Pag  CLA_GRAVA_
 29B2:05BF  Pag  CLA_TELA
 29B2:05C6  Pag  CLA_GETS
 29B2:05CD  Pag  CLA_GET1
 29B2:05D4  Pag  CIRCULAR
 29B2:05DB  Pag  CIR_INCL
 29B2:05E2  Pag  CIR_TELA
 29B2:05E9  Pag  CIR_GETS
 29B2:05F0  Pag  CIR_GET1
 29B2:05F7  Pag  CPR_INCL
 29B2:05FE  Pag  CPR_TELA
 29B2:0605  Pag  CPR_GETS
 29B2:060C  Pag  CPR_GET1
 29B2:0613  Pag  PRCESSOS
 29B2:061A  Pag  PRC_INCL
 29B2:0621  Pag  PRC_TELA
 29B2:0628  Pag  PRC_GETS
 29B2:062F  Pag  PRC_GET1
 29B2:0636  Pag  FNCS
 29B2:063D  Pag  FNC_INCL
 29B2:0644  Pag  FNC_ANT_SE
 29B2:064B  Pag  FNC_CRIA_S
 29B2:0652  Pag  FNC_GERA_S
 29B2:0659  Pag  FNC_GRAVA_
 29B2:0660  Pag  FNC_TELA
 29B2:0667  Pag  FNC_GETS
 29B2:066E  Pag  FNC_GET1
 29B2:0675  Pag  FNC_MEMO
 29B2:067C  Pag  HISTORIC
 29B2:0683  Pag  HIS_INCL
 29B2:068A  Pag  HIS_ANT_SE
 29B2:0691  Pag  HIS_CRIA_S
 29B2:0698  Pag  HIS_GERA_S
 29B2:069F  Pag  HIS_GRAVA_
 29B2:06A6  Pag  HIS_TELA
 29B2:06AD  Pag  HIS_GETS
 29B2:06B4  Pag  HIS_GET1
 29B2:06BB  Pag  CSTSEG
 29B2:06C2  Pag  CST_INCL
 29B2:06C9  Pag  CST_TELA
 29B2:06D0  Pag  CST_GETS
 29B2:06D7  Pag  CST_GET1
 29B2:06DE  Pag  MEN_01F9
 29B2:06E5  Pag  MENSAG
 29B2:06EC  Pag  MEN_INCL
 29B2:06F3  Pag  MEN_ANT_SE
 29B2:06FA  Pag  MEN_CRIA_S
 29B2:0701  Pag  MEN_GERA_S
 29B2:0708  Pag  MEN_GRAVA_
 29B2:070F  Pag  MEN_TELA
 29B2:0716  Pag  MEN_GETS
 29B2:071D  Pag  MEN_GET1
 29B2:0724  Pag  MEN_MEMO
 29B2:072B  Pag  ORDPGRC
 29B2:0732  Pag  ORD_INCL
 29B2:0739  Pag  ORD_ANT_SE
 29B2:0740  Pag  ORD_CRIA_S
 29B2:0747  Pag  ORD_GERA_S
 29B2:074E  Pag  ORD_GRAVA_
 29B2:0755  Pag  ORD_TELA
 29B2:075C  Pag  ORD_GETS
 29B2:0763  Pag  ORD_GET1
 29B2:076A  Pag  PAR_ADM
 29B2:0771  Pag  PAR_TELA
 29B2:0778  Pag  PAR_GETS
 29B2:077F  Pag  PAR_GET1
 29B2:0786  Pag  ADR_ESTR
 29B2:078D  Pag  BXR_ESTR
 29B2:0794  Pag  ALE_ESTR
 29B2:079B  Pag  OBX_ESTR
 29B2:07A2  Pag  GRU_ESTR
 29B2:07A9  Pag  TAX_ESTR
 29B2:07B0  Pag  ECO_ESTR
 29B2:07B7  Pag  INS_ESTR
 29B2:07BE  Pag  GUI_ESTR
 29B2:07C5  Pag  AFU_ESTR
 29B2:07CC  Pag  IMP_ESTR
 29B2:07D3  Pag  MED_ESTR
 29B2:07DA  Pag  TES_ESTR
 29B2:07E1  Pag  JUR_ESTR
 29B2:07E8  Pag  TFI_ESTR
 29B2:07EF  Pag  ARQ_ESTR
 29B2:07F6  Pag  REG_ESTR
 29B2:07FD  Pag  COB_ESTR
 29B2:0804  Pag  CLA_ESTR
 29B2:080B  Pag  CIR_ESTR
 29B2:0812  Pag  CPR_ESTR
 29B2:0819  Pag  PRC_ESTR
 29B2:0820  Pag  FNC_ESTR
 29B2:0827  Pag  HIS_ESTR
 29B2:082E  Pag  CST_ESTR
 29B2:0835  Pag  MEN_ESTR
 29B2:083C  Pag  ORD_ESTR
 29B2:0843  Pag  PAR_ESTR
 29B2:084A  Pag  MFI_ESTR
 29B2:0851  Pag  ADR_ATRI
 29B2:0858  Pag  ADR_ATR1
 29B2:085F  Pag  ADR_ATR2
 29B2:0866  Pag  ADR_MENU
 29B2:086D  Pag  ADR_MANU
 29B2:0874  Pag  HELP_PROC
 29B2:087B  Pag  MKINX
 29B2:0882  Pag  CON_RX01
 29B2:0897  Pag  R001GF9
 29B2:089E  Pag  ABOUT
 29B2:08A5  Pag  ADR_PROC
 29B2:08AC  Pag  CBC1
 29B2:08B3  Pag  AJMOUSE
 29B2:08BA  Pag  BROWSE_REL
 29B2:08CF  Pag  DOSCOM
 29B2:08D6  Pag  PARAMETROS
 29B2:08DD  Pag  FILTRA
 29B2:08E4  Pag  FILTROINI
 29B2:08EB  Pag  VEOUTROS
 29B2:08F2  Pag  VE_CAMPOS
 29B2:08F9  Pag  INDTMP
 29B2:0900  Pag  REP
 29B2:0907  Pag  CONF
 29B2:090E  Pag  CLASS
 29B2:0915  Pag  CAPTURAARQ
 29B2:091C  Pag  CAPTURADIR
 29B2:0923  Pag  ESCOLHIDOU
 29B2:092A  Pag  LSTARQDIR
 29B2:0931  Pag  POSI
 29B2:0938  Pag  IMPRELA
 29B2:093F  Pag  REIMPTEL
 29B2:0946  Pag  EDIT
 29B2:094D  Pag  REGINICIO
 29B2:0954  Pag  INI_ARQ
 29B2:095B  Pag  FIM_ARQ
 29B2:0962  Pag  POSIPAI
 29B2:0969  Pag  IMP_FORM
 29B2:0970  Pag  PEGACHV2
 29B2:0977  Pag  GLOBAL
 29B2:097E  Pag  SUBNIVEL
 29B2:0985  Pag  INTREF
 29B2:098C  Pag  VE_REL
 29B2:0993  Pag  HELP
 29B2:099A  Pag  MHELP
 29B2:09A1  Pag  NADAFAZ
 29B2:09A8  Pag  INFOSIS
 29B2:09AF  Pag  TIRA_LANC
 29B2:09B6  Pag  FAZ_LANC
 29B2:09BD  Pag  MASENHA
 29B2:09C4  Pag  PWG_INCL
 29B2:09CB  Pag  PWG_TELA
 29B2:09D2  Pag  PWG_GETS
 29B2:09D9  Pag  PWG_GET1
 29B2:09E0  Pag  PWT_INCL
 29B2:09E7  Pag  PWT_TELA
 29B2:09EE  Pag  PWT_GETS
 29B2:09F5  Pag  PWT_GET1
 29B2:09FC  Pag  ERRORSYS
 29B2:0A03  Pag  ADR_FUNC
 29B2:0A0A  Pag  PTAB
 29B2:0A11  Pag  USEARQ
 29B2:0A18  Pag  CRIT
 29B2:0A1F  Pag  EDITA
 29B2:0A26  Pag  MOV_PTR
 29B2:0AB9  Pag  ADR_FUN2
 29B2:0AC0  Pag  CANC
 29B2:0AC7  Pag  ROLATELA
 29B2:0ACE  Pag  PEGAPAI
 29B2:0AD5  Pag  MENURELA
 29B2:0ADC  Pag  QUALRELA
 29B2:0AE3  Pag  OPCOES_REL
 29B2:0AEA  Pag  TP_SAIDA
 29B2:0AF1  Pag  TRANSCAMPO
 29B2:0AF8  Pag  ARQGER
 29B2:0AFF  Pag  PREPIMP
 29B2:0B06  Pag  CONFINCL
 29B2:0B0D  Pag  CONFEXCL
 29B2:0B14  Pag  CONFALT
 29B2:0B1B  Pag  ROLAPOP
 29B2:0B22  Pag  PEGADIR
 29B2:0B29  Pag  TRATADIR
 29B2:0B30  Pag  CRIADRV
 29B2:0B37  Pag  RCLA
 29B2:0B3E  Pag  COMPACTA
 29B2:0B45  Pag  CONFCORES
 29B2:0B4C  Pag  CONFPRN
 29B2:0B53  Pag  IMP_MARCA
 29B2:0B5A  Pag  IMP_PADRAO
 29B2:0B61  Pag  IMP_PORTA
 29B2:0B68  Pag  POE_GAUGE
 29B2:0B6F  Pag  POINTER_DB
 29B2:0B76  Pag  VDBF
 29B2:0B7D  Pag  MOUSETECLA
 29B2:0B8B  Pag  PWU_INCL
 29B2:0B92  Pag  PWU_TELA
 29B2:0B99  Pag  PWU_GETS
 29B2:0BA0  Pag  PWU_GET1
 29B2:0BA7  Pag  TROCASENHA
 29B2:0BAE  Pag  CRIADBF
 29B2:0BB5  Pag  IMPEXP
 29B2:0BBC  Pag  IMPCTL
 29B2:0BC3  Pag  IMPMEMO
 29B2:0BCA  Pag  MANUREF
 29B2:0BD8  Pag  ADR_OUTR
 29B2:0BDF  Pag  CALE
 29B2:0BE6  Pag  MAQCALC
 29B2:0BF4  Pag  VEINSCRITS
 29B2:0BFB  Pag  V00101F9
 29B2:0C02  Pag  V_CARENCIA
 29B2:0C09  Pag  XCRIPTOGRA
 29B2:0C10  Pag  XENCRIPT
 29B2:0C17  Pag  XDECRIPT
 29B2:0C1E  Pag  READMODAL
 29B2:0C25  Pag  GETREADER
 29B2:0C2C  Pag  AJUSTA_PIC
 29B2:0C33  Pag  GETAPPLYKE
 29B2:0C3A  Pag  GETPREVALI
 29B2:0C41  Pag  GETPOSTVAL
 29B2:0C48  Pag  GETDOSETKE
 29B2:0C72  Pag  __SETFORMA
 29B2:0C79  Pag  __KILLREAD
 29B2:0C80  Pag  GETACTIVE
 29B2:0C87  Pag  UPDATED
 29B2:0C8E  Pag  READEXIT
 29B2:0C95  Pag  READINSERT
 29B2:0CAA  Pag  RANGECHECK
 29B2:0CB1  Pag  READKILL
 29B2:0CB8  Pag  STORECARGO
 29B2:0CBF  Pag  STOREALL
 29B2:0CCD  Pag  IMPAC
 29B2:0CD4  Pag  EDIMEMO
 29B2:0CDB  Pag  MFUNC
 29B2:0CE2  Pag  MTAB
 29B2:0CE9  Pag  PWORD
 29B2:0CF0  Pag  VHORA
 29B2:0CF7  Pag  DLAPSO
 29B2:0CFE  Pag  CARDTYPE
 29B2:0D05  Pag  NMES
 29B2:0D0C  Pag  MMAA
 29B2:0D13  Pag  GDV1
 29B2:0D1A  Pag  VDV2
 29B2:0D21  Pag  VCGC
 29B2:0D28  Pag  EXT
 29B2:0D2F  Pag  BLOARQ
 29B2:0D36  Pag  REPBLO
 29B2:0D3D  Pag  DBOX
 29B2:0D59  Pag  JOGANOBUFF
 29B2:0D60  Pag  NOVAPOSI
 29B2:0D67  Pag  Q_TEC
 29B2:0D6E  Pag  LPAD
 29B2:0D75  Pag  CAIXA
 29B2:0D7C  Pag  NSEM
 29B2:0D83  Pag  MUDAFONTE
 29B2:0D8A  Pag  LEMANU
 29B2:0D91  Pag  ALERTA
 29B2:0D98  Pag  BLOREG
 29B2:0D9F  Pag  PARSE
 29B2:0DA6  Pag  GRELA
 29B2:0DAD  Pag  LRELA
 29B2:0DB4  Pag  SETS
 29B2:0DBB  Pag  ERROMSG
 29B2:0DC2  Pag  INVCOR
 29B2:0DC9  Pag  MUDA_PJ
 29B2:0DD0  Pag  MON_JAN_MO
 29B2:0DD7  Pag  MOUSE
 29B2:0DDE  Pag  MOUSECUR
 29B2:0DE5  Pag  MOUSEBOX
 29B2:0DEC  Pag  MOUSEGET
 29B2:0DF3  Pag  MOUSESET
 29B2:0DFA  Pag  NEXT_KEY
 29B2:0E01  Pag  IN_KEY
 29B2:0E0F  Pag  MONTA_BUFF
 29B2:0E16  Pag  KEYB_MAC
 29B2:0E1D  Pag  KEYBUFF
 29B2:0E24  Pag  INKY
 29B2:0E2B  Pag  POEHORA
 29B2:0E32  Pag  RESTSCR
 29B2:0E39  Pag  MOUSERAT
 29B2:0E40  Pag  NAOPISCA
 29B2:0E47  Pag  SERIAL
 29B2:0E4E  Pag  PARALELA
 29B2:0E55  Pag  MAIUSC
 29B2:0E8D  Pag  CBEAN
 29B2:0E94  Pag  CB39
 29B2:0E9B  Pag  CB25INT
 29B2:0EA2  Pag  CODBARRAS
 29B2:0EB0  Pag  EXTENSAO
 29B2:0EBE  Pag  SYSINIT
 29B2:0EC5  Pag  __SETCENTU
 29B2:0ECC  Pag  _EINSTVAR
 29B2:0ED3  Pag  __XSAVESCR
 29B2:0EDA  Pag  __XRESTSCR
 29B2:0EE8  Pag  __SETHELPK
 29B2:0EEF  Pag  GETNEW
 29B2:0EF6  Pag  __GETHASFO
 29B2:0EFD  Pag  __GETBUFFE
 29B2:0F04  Pag  __GETORIGI
 29B2:0F0B  Pag  __GETSETCA
 29B2:0F12  Pag  __GETSETBL
 29B2:0F19  Pag  __GETSETNA
 29B2:0F20  Pag  __GETSETPI
 29B2:0F27  Pag  __GETSETPB
 29B2:0F2E  Pag  __GETSETPR
 29B2:0F35  Pag  __GETSETSU
 29B2:0F3C  Pag  __GETSETEX
 29B2:0F43  Pag  __GETSETRE
 29B2:0F4A  Pag  __GETSETBU
 29B2:0F51  Pag  __GETBADDA
 29B2:0F58  Pag  __GETUNDO
 29B2:0F5F  Pag  __GETTODEC
 29B2:0F66  Pag  __GETDWLEF
 29B2:0F6D  Pag  READVAR
 29B2:0F7B  Pag  _DTXCONDSE
 29B2:0F82  Pag  DBCREATEIN
 29B2:0F89  Pag  DBSETINDEX
 29B2:0F90  Pag  DBCLEARIND
 29B2:0F97  Pag  DBREINDEX
 29B2:0F9E  Pag  DBSETORDER
 29B2:0FA5  Pag  INDEXEXT
 29B2:0FAC  Pag  INDEXKEY
 29B2:0FB3  Pag  __DBLOCATE
 29B2:0FBA  Pag  __DBCONTIN
 29B2:0FC8  Pag  __DBCOPY
 29B2:0FCF  Pag  __DBAPP
 29B2:0FD6  Pag  __FLEDIT
 29B2:0FE4  Pag  __DBSDF
 29B2:0FF2  Pag  SDF
 29B2:0FF9  Pag  STRZERO
 29B2:1000  Pag  AFILL
 29B2:1007  Pag  ACLONE
 29B2:100E  Pag  DEFPATH
 29B2:1015  Pag  __DEFPATH
 29B2:101C  Pag  ADIR
 29B2:1023  Pag  __TSETCARG
 29B2:102A  Pag  __TSETCOLU
 29B2:1031  Pag  __TCARGO
 29B2:1038  Pag  __TCOLUMN
 29B2:103F  Pag  __TCOLCOUN
 29B2:1046  Pag  __TSETRTOP
 29B2:104D  Pag  __TSETRLEF
 29B2:1054  Pag  __TSETRBOT
 29B2:105B  Pag  __TSETRRIG
 29B2:1062  Pag  __TSETHEAD
 29B2:1069  Pag  __TSETCOLS
 29B2:1070  Pag  __TSETFOOT
 29B2:1077  Pag  __TSETCOLO
 29B2:107E  Pag  __TSETSKIP
 29B2:1085  Pag  __TSETTOP
 29B2:108C  Pag  __TSETBOTT
 29B2:1093  Pag  __TADDCOLU
 29B2:109A  Pag  __TINSCOLU
 29B2:10A1  Pag  __TDELCOLU
 29B2:10A8  Pag  TBROWSENEW
 29B2:10AF  Pag  __CSETWIDT
 29B2:10B6  Pag  __CSETBLOC
 29B2:10BD  Pag  __CSETDEFC
 29B2:10C4  Pag  __CSETCOLO
 29B2:10CB  Pag  __CSETHEAD
 29B2:10D2  Pag  __CSETFOOT
 29B2:10D9  Pag  __CSETHSEP
 29B2:10E0  Pag  __CSETFSEP
 29B2:10E7  Pag  __CSETCOLS
 29B2:10EE  Pag  __CSETPICT
 29B2:10F5  Pag  TBCOLUMNNE
 29B2:110A  Pag  SIXCDX
 29B2:1111  Pag  SX_DEFTRIG
 29B2:1118  Pag  BLICALC50
 29B2:111F  Pag  BLIMEMAVL
 29B2:1126  Pag  BLIMEMMAX
 29B2:112D  Pag  BLPRFPRG
 29B2:1134  Pag  BLERRC50
 2AC7:0008  Ovl  __GETENV
 2AC7:0014  Ovl  __AWK
 2AC7:001A  Ovl  __SQU
 2AC7:0026  Ovl  __QUIT
 2AC7:002C  Ovl  __SYSINIT
 2AC7:0032  Ovl  __SYSSUSPEND
 2AC7:0038  Ovl  __SYSRESUME
 2AC7:003E  Ovl  __SYSEXIT
 2AC7:0044  Ovl  __SYSLEVEL
 2AC7:004A  Ovl  __SYSERRORLEVEL
 2AC7:0050  Ovl  __SYSPOSTARGS
 2AC7:0056  Ovl  ERRORLEVEL
 2AC7:0062  Ovl  __APPINITREGISTER
 2AC7:0068  Ovl  __APPMAIN
 2AC7:0092  Ovl  __APPEXITREGISTER
 2AC7:0098  Ovl  __APPEXIT
 2AC7:00A4  Ovl  __SYSTEM
 2AC7:00AA  Ovl  __RUN
 2AC7:00B6  Ovl  __ISENDP
 2AC7:00BC  Ovl  __CLASSSEL
 2AC7:00C2  Ovl  __CLASSINS
 2AC7:00C8  Ovl  __MDCREATE
 2AC7:00D4  Ovl  __MDADD
 2AC7:00DA  Ovl  __MDASSOCIATE
 2AC7:00EC  Ovl  __CLASSNEW
 2AC7:00F2  Ovl  __CLASSADD
 2AC7:0104  Ovl  __CLASSNAM
 2AC7:0110  Ovl  __TBNAME
 2AC7:0116  Ovl  PROCNAME
 2AC7:011C  Ovl  PROCLINE
 2AC7:0122  Ovl  PROCFILE
 2AC7:0128  Ovl  ACOPY
 2AC7:012E  Ovl  ADEL
 2AC7:0134  Ovl  AINS
 2AC7:013A  Ovl  ATAIL
 2AC7:0152  Ovl  __MSAVE
 2AC7:0158  Ovl  __MRESTORE
 2AC7:0164  Ovl  __MXRELEAS
 2AC7:016A  Ovl  __MRELEASE
 2AC7:0170  Ovl  __MCLEAR
 2AC7:0188  Ovl  __CREATEERRORDICT
 2AC7:019A  Ovl  __IENDSEQ
 2AC7:01A0  Ovl  __END_SEQ
 2AC7:01A6  Ovl  __SEQREG
 2AC7:01AC  Ovl  __IBEGINSEQ
 2AC7:01B2  Ovl  __IBREAKCONT
 2AC7:01BE  Ovl  _MALLOC
 2AC7:01C4  Ovl  _FREE
 2AC7:01CA  Ovl  __FMALLOC
 2AC7:01D0  Ovl  __FFREE
 2AC7:01D6  Ovl  __NMALLOC
 2AC7:01DC  Ovl  __NFREE
 2AC7:01F4  Ovl  __COUTSTD
 2AC7:01FA  Ovl  __ERRMSG
 2AC7:0200  Ovl  __COUTERR
 2AC7:0206  Ovl  __ERRMSGN
 2AC7:020C  Ovl  __NONOALER
 2AC7:0212  Ovl  OUTSTD
 2AC7:0218  Ovl  ALERT
 2AC7:021E  Ovl  OUTERR
 2AC7:0224  Ovl  __OUTINI
 2AC7:0230  Ovl  ISCOLOR
 2AC7:0236  Ovl  SETMODE
 2AC7:023C  Ovl  NOSNOW
 2AC7:0248  Ovl  MAXROW
 2AC7:024E  Ovl  MAXCOL
 2AC7:025A  Ovl  SAVESCREEN
 2AC7:0260  Ovl  RESTSCREEN
 2AC7:0266  Ovl  SCROLL
 2AC7:0278  Ovl  __GETSETUP
 2AC7:027E  Ovl  __GETCLASS
 2AC7:028A  Ovl  __GETCDISP
 2AC7:0290  Ovl  __TOGET
 2AC7:0296  Ovl  __GETROW
 2AC7:02A2  Ovl  __GETCOL
 2AC7:02A8  Ovl  _DISPLAYTHEGET
 2AC7:02AE  Ovl  _GETGETCONTEXT
 2AC7:02B4  Ovl  _SETGETCONTEXT
 2AC7:02BA  Ovl  __GETSETRO
 2AC7:02C0  Ovl  __GETSETCO
 2AC7:02C6  Ovl  __GETVARGE
 2AC7:02CC  Ovl  __GETVARPU
 2AC7:02D2  Ovl  __GET
 2AC7:02D8  Ovl  __GETA
 2AC7:02E4  Ovl  __GETCOLOR
 2AC7:02EA  Ovl  __GETSETCS
 2AC7:0302  Ovl  __GETTYPE
 2AC7:030E  Ovl  __GETSETFO
 2AC7:0320  Ovl  __GETPOS
 2AC7:032C  Ovl  __GETINSER
 2AC7:0338  Ovl  __GETDECPO
 2AC7:033E  Ovl  __GETOVERS
 2AC7:034A  Ovl  __GETCHANG
 2AC7:0350  Ovl  __GETKILLF
 2AC7:0356  Ovl  __GETCLEAR
 2AC7:035C  Ovl  __GETLEFT
 2AC7:0362  Ovl  __GETRIGHT
 2AC7:036E  Ovl  __GETASSIG
 2AC7:0374  Ovl  __GETMINUS
 2AC7:037A  Ovl  __GETHOME
 2AC7:0386  Ovl  __GETEND
 2AC7:038C  Ovl  __GETTYPEO
 2AC7:0392  Ovl  __GETWORDL
 2AC7:039E  Ovl  __GETWORDR
 2AC7:03A4  Ovl  __GETREJEC
 2AC7:03AA  Ovl  __GETDELET
 2AC7:03B6  Ovl  __GETWORDD
 2AC7:03BC  Ovl  __GETSETPO
 2AC7:03C2  Ovl  __GETRITED
 2AC7:03C8  Ovl  __GETBACKS
 2AC7:03CE  Ovl  __GETUPDAT
 2AC7:03D4  Ovl  __GETSETCH
 2AC7:03EC  Ovl  __GETUNTRA
 2AC7:03FE  Ovl  __GETREFOR
 2AC7:0404  Ovl  __GETSETCL
 2AC7:040A  Ovl  __GETRESET
 2AC7:041C  Ovl  __GETSETMI
 2AC7:0422  Ovl  __GETDISPL
 2AC7:042E  Ovl  ORDFOR
 2AC7:0434  Ovl  ORDLISTADD
 2AC7:043A  Ovl  ORDCONDSET
 2AC7:0440  Ovl  ORDDESTROY
 2AC7:0446  Ovl  ORDLISTCLE
 2AC7:044C  Ovl  ORDCREATE
 2AC7:0452  Ovl  ORDLISTREB
 2AC7:0458  Ovl  ORDSETFOCU
 2AC7:045E  Ovl  ORDBAGEXT
 2AC7:046A  Ovl  ORDBAGNAME
 2AC7:0470  Ovl  ORDNAME
 2AC7:0476  Ovl  ORDNUMBER
 2AC7:047C  Ovl  ORDKEY
 2AC7:0482  Ovl  INDEXORD
 2AC7:0494  Ovl  RDDNAME
 2AC7:049A  Ovl  __DBCMDSLR
 2AC7:04A0  Ovl  RDDSETDEFA
 2AC7:04A6  Ovl  DBSETDRIVE
 2AC7:04AC  Ovl  DBCLOSEALL
 2AC7:04B2  Ovl  DBCLOSEARE
 2AC7:04B8  Ovl  DBUSEAREA
 2AC7:04BE  Ovl  __DEFDRIVER
 2AC7:04C4  Ovl  DBTABLEEXT
 2AC7:04D0  Ovl  DBAPPEND
 2AC7:04D6  Ovl  __FLOCK
 2AC7:04DC  Ovl  DBDELETE
 2AC7:04E2  Ovl  __AXPROUT
 2AC7:04E8  Ovl  __EOF
 2AC7:04EE  Ovl  DBSELECTAR
 2AC7:04F4  Ovl  DBRECALL
 2AC7:04FA  Ovl  __BOF
 2AC7:0500  Ovl  __DBPACK
 2AC7:0506  Ovl  DBEVAL
 2AC7:050C  Ovl  __FOUND
 2AC7:0512  Ovl  __DBZAP
 2AC7:0518  Ovl  __DELETED
 2AC7:051E  Ovl  DBSEEK
 2AC7:0524  Ovl  DBCOMMIT
 2AC7:052A  Ovl  __RECNO
 2AC7:0530  Ovl  DBCOMMITAL
 2AC7:0536  Ovl  __LASTREC
 2AC7:053C  Ovl  __FIELDNAME
 2AC7:0542  Ovl  DBUNLOCK
 2AC7:0548  Ovl  DBUNLOCKAL
 2AC7:054E  Ovl  DBSKIP
 2AC7:0554  Ovl  __FCOUNT
 2AC7:055A  Ovl  __FSELECT0
 2AC7:0560  Ovl  DBRLOCKLIS
 2AC7:0566  Ovl  __FSELECT1
 2AC7:056C  Ovl  DBGOTOP
 2AC7:0572  Ovl  DBRLOCK
 2AC7:057E  Ovl  USED
 2AC7:0584  Ovl  DBGOBOTTOM
 2AC7:058A  Ovl  ALIAS
 2AC7:0596  Ovl  DBGOTO
 2AC7:059C  Ovl  DBRUNLOCK
 2AC7:05A2  Ovl  __AXPRIN
 2AC7:05A8  Ovl  __LOCK
 2AC7:05AE  Ovl  __V2ALIAS
 2AC7:05B4  Ovl  __XAPPEND
 2AC7:05C0  Ovl  DBCLEARFIL
 2AC7:05C6  Ovl  DBSETFILTE
 2AC7:05CC  Ovl  DBFILTER
 2AC7:05D2  Ovl  DBCLEARREL
 2AC7:05D8  Ovl  DBSETRELAT
 2AC7:05DE  Ovl  DBRELATION
 2AC7:05E4  Ovl  DBRSELECT
 2AC7:05F0  Ovl  __DBTRANS
 2AC7:05F6  Ovl  __DBTRANSR
 2AC7:05FC  Ovl  __DBFIELDINDEX
 2AC7:0602  Ovl  ___DBBUILDTRANS
 2AC7:060E  Ovl  __DBSETLOC
 2AC7:0614  Ovl  __DBSETFOU
 2AC7:0620  Ovl  HEADER
 2AC7:0626  Ovl  RECSIZE
 2AC7:062C  Ovl  LUPDATE
 2AC7:063E  Ovl  DBSTRUCT
 2AC7:0656  Ovl  __DBOPENSD
 2AC7:065C  Ovl  DBCREATE
 2AC7:0668  Ovl  __SDFOPEN
 2AC7:066E  Ovl  __SDFCREATE
 2AC7:0674  Ovl  __SDFDELETE
 2AC7:067A  Ovl  __SDFGOTOP
 2AC7:0686  Ovl  __SDFDELETED
 2AC7:068C  Ovl  __SDFSKIP
 2AC7:0692  Ovl  __SDFEOF
 2AC7:069E  Ovl  __SDFGETVALUE
 2AC7:06A4  Ovl  __SDFAPPEND
 2AC7:06B0  Ovl  __SDFNEW
 2AC7:06B6  Ovl  __SDFCLOSE
 2AC7:06BC  Ovl  __SDFSTRUCTSIZE
 2AC7:06C8  Ovl  __SDFSYSNAME
 2AC7:06D4  Ovl  __SDFSETFIELDEXTENT
 2AC7:06DA  Ovl  __SDFPUTVALUE
 2AC7:06E0  Ovl  __SDFADDFIELD
 2AC7:06EC  Ovl  __SDFGETFUNCTABLE
 2AC7:06F2  Ovl  _SDFINIT
 2AC7:06FE  Ovl  FSEEK
 2AC7:0704  Ovl  FCREATE
 2AC7:070A  Ovl  FERASE
 2AC7:0710  Ovl  FOPEN
 2AC7:0716  Ovl  FRENAME
 2AC7:071C  Ovl  FERROR
 2AC7:0722  Ovl  FCLOSE
 2AC7:0728  Ovl  FREAD
 2AC7:072E  Ovl  FREADSTR
 2AC7:0734  Ovl  FWRITE
 2AC7:0740  Ovl  __EMMGETALLOCPAGECOUNT
 2AC7:0746  Ovl  __EMMGETTOTALPAGECOUNT
 2AC7:074C  Ovl  __EMMGETUNALLOCPAGECOUNT
 2AC7:0758  Ovl  __EMMINSTALLED
 2AC7:075E  Ovl  __EXACTCMP
 2AC7:076A  Ovl  GETENV
 2AC7:0770  Ovl  GETE
 2AC7:0776  Ovl  DISKSPACE
 2AC7:0782  Ovl  CURDIR
 2AC7:0788  Ovl  ISPRINTER
 2AC7:078E  Ovl  TONE
 2AC7:0794  Ovl  I2BIN
 2AC7:079A  Ovl  BIN2I
 2AC7:07A0  Ovl  L2BIN
 2AC7:07A6  Ovl  BIN2L
 2AC7:07AC  Ovl  BIN2W
 2AC7:07B2  Ovl  ALLTRIM
 2AC7:07B8  Ovl  RIGHT
 2AC7:07BE  Ovl  DESCEND
 2AC7:07C4  Ovl  RAT
 2AC7:07CA  Ovl  PADL
 2AC7:07D0  Ovl  PADR
 2AC7:07D6  Ovl  PADC
 2AC7:07DC  Ovl  STRTRAN
 2AC7:07E2  Ovl  MEMOREAD
 2AC7:07E8  Ovl  MEMOLINE
 2AC7:07EE  Ovl  MLCOUNT
 2AC7:07FA  Ovl  _LINELEN
 2AC7:0800  Ovl  _FETCHAR
 2AC7:080C  Ovl  _ASCANSUB
 2AC7:0812  Ovl  ASCAN
 2AC7:081E  Ovl  ASORT
 2AC7:0848  Ovl  DIRECTORY
 2AC7:0878  Ovl  MEMOEDIT
 2AC7:0992  Ovl  __TOTBROWS
 2AC7:099E  Ovl  __XTBRSETUP
 2AC7:09C2  Ovl  __CCLASSNA
 2AC7:09C8  Ovl  __TOTBCOLU
 2AC7:09E0  Ovl  __TCURSROW
 2AC7:09E6  Ovl  _PAN
 2AC7:09F2  Ovl  __TROWCOUN
 2AC7:09F8  Ovl  __TLEFTVIS
 2AC7:0A04  Ovl  __TRIGHTVI
 2AC7:0A0A  Ovl  __TUP
 2AC7:0A10  Ovl  __TCURSCOL
 2AC7:0A16  Ovl  __TDOWN
 2AC7:0A1C  Ovl  __TBBANG
 2AC7:0A2E  Ovl  __TLEFT
 2AC7:0A34  Ovl  __TEBANG
 2AC7:0A46  Ovl  __TRIGHT
 2AC7:0A4C  Ovl  __TSTABLE
 2AC7:0A52  Ovl  __TINVALID
 2AC7:0A58  Ovl  __TPGUP
 2AC7:0A5E  Ovl  __TAUTOLIT
 2AC7:0A64  Ovl  __TREFRESH
 2AC7:0A6A  Ovl  __TPGDN
 2AC7:0A70  Ovl  __TFREEZE
 2AC7:0A7C  Ovl  __TLINEFRE
 2AC7:0A82  Ovl  __THOME
 2AC7:0A88  Ovl  __TSETCONF
 2AC7:0A8E  Ovl  __TSTABILI
 2AC7:0A9A  Ovl  __TBEND
 2AC7:0AA6  Ovl  __TPANLEFT
 2AC7:0AB2  Ovl  __TFORCEST
 2AC7:0AB8  Ovl  __TPANRIGH
 2AC7:0ABE  Ovl  __TGOTOP
 2AC7:0AC4  Ovl  __TSETCURR
 2AC7:0AD0  Ovl  __TGOBOTTO
 2AC7:0AD6  Ovl  __TCLASSNA
 2AC7:0ADC  Ovl  __TPANHOME
 2AC7:0AE2  Ovl  __TSETCURC
 2AC7:0AF4  Ovl  __TPANEND
 2AC7:0AFA  Ovl  __THILITE
 2AC7:0B00  Ovl  __TDEHILIT
 2AC7:0B06  Ovl  __TSETBBAN
 2AC7:0B0C  Ovl  __TCOLORRE
 2AC7:0B1E  Ovl  __TSETEBAN
 2AC7:0B3C  Ovl  __TSETSTAB
 2AC7:0B48  Ovl  __TSETAUTO
 2AC7:0B54  Ovl  __TCOLWIDT
 2AC7:0B5A  Ovl  __TSETFREE
 2AC7:0B6C  Ovl  _CDXINIT
 2AC7:0B72  Ovl  __CDXPLACEKEYP
 2AC7:0B78  Ovl  __CDXNEW
 2AC7:0B7E  Ovl  __CDXGETFUNCTABLE
 2AC7:0B84  Ovl  _CDXOPTIMIZE4SPEED
 2AC7:0B8A  Ovl  __CDXWEP
 2AC7:0B96  Ovl  __CDXORDERINFO
 2AC7:0B9C  Ovl  __CDXSTRUCTSIZE
 2AC7:0BA2  Ovl  __CDXGOHOT
 2AC7:0BA8  Ovl  __CDXGOTOP
 2AC7:0BAE  Ovl  __CDXGOBOTTOM
 2AC7:0BBA  Ovl  __CDXSYSNAME
 2AC7:0BC0  Ovl  __CDXGOTO
 2AC7:0BC6  Ovl  __CDXPACK
 2AC7:0BCC  Ovl  __CDXZAPTABLE
 2AC7:0BD2  Ovl  __CDXGOTOID
 2AC7:0BD8  Ovl  __CDXINDEXEXPR
 2AC7:0BDE  Ovl  __CDXFLUSH
 2AC7:0BE4  Ovl  __CDXFORCEREL
 2AC7:0BEA  Ovl  __CDXSORT
 2AC7:0BF0  Ovl  __CDXORDERLISTCLEAR
 2AC7:0BF6  Ovl  __CDXORDERBAGEXT
 2AC7:0C02  Ovl  __CDXOPEN
 2AC7:0C08  Ovl  __CDXCLOSE
 2AC7:0C0E  Ovl  __CDXORDERCREATE
 2AC7:0C14  Ovl  __CDXORDERLISTADD
 2AC7:0C2C  Ovl  _CDXINDEXCREATE
 2AC7:0C32  Ovl  __CDXISREINDEX
 2AC7:0C38  Ovl  __CDXPLACEKEY
 2AC7:0C3E  Ovl  _CDXINITTAGINDEX
 2AC7:0C5C  Ovl  __CDXORDERLISTREBUILD
 2AC7:0CE6  Ovl  _CDXINDEXGROW
 2AC7:0CEC  Ovl  _CDXINDEXSHRINK
 2AC7:0CF8  Ovl  __CDXCHKEXPR
 2AC7:0CFE  Ovl  __CDXALIASXLATE
 2AC7:0D0A  Ovl  _CDXINDEXOPEN
 2AC7:0D16  Ovl  _CDXLOCK
 2AC7:0D1C  Ovl  _CDXUNLOCK
 2AC7:0D28  Ovl  _CDXTAGUNLOCK
 2AC7:0D2E  Ovl  _CDXTAGLOCK
 2AC7:0D34  Ovl  __CDXTAGFINDKEY
 2AC7:0D4C  Ovl  __SMTAMEMOSIZE
 2AC7:0D52  Ovl  __SMTARRAYTOMEMO
 2AC7:0D58  Ovl  __SMTWRITEARRAY
 2AC7:0D5E  Ovl  __SMTMEMOTOARRAY
 2AC7:0D76  Ovl  _SXDBFINIT
 2AC7:0D7C  Ovl  __SXDBFPLACERECP
 2AC7:0D82  Ovl  __SXDBFGETFUNCTABLE
 2AC7:0D8E  Ovl  __SXDBFRECCOUNT
 2AC7:0D94  Ovl  __SXDBFCHILDSYNC
 2AC7:0D9A  Ovl  __SXDBFSYSNAME
 2AC7:0DA0  Ovl  __SXDBFPACK
 2AC7:0DA6  Ovl  __SXDBFSTRUCTSIZE
 2AC7:0DAC  Ovl  __SXDBFCHILDEND
 2AC7:0DB2  Ovl  __SXDBFCHILDSTART
 2AC7:0DB8  Ovl  __SXDBFZAP
 2AC7:0DBE  Ovl  __SXDBFDELETE
 2AC7:0DC4  Ovl  __SXDBFRECALL
 2AC7:0DCA  Ovl  __SXDBFPLACEREC
 2AC7:0DD0  Ovl  __SXDBFINFO
 2AC7:0DD6  Ovl  __SXDBFSORT
 2AC7:0DE2  Ovl  __SXDBFDELETED
 2AC7:0DE8  Ovl  __SXDBFFORCEREL
 2AC7:0DEE  Ovl  __SXDBFSETFILTER
 2AC7:0DF4  Ovl  __SXDBFRECNO
 2AC7:0E00  Ovl  SX_ENCRYPT
 2AC7:0E06  Ovl  SX_DECRYPT
 2AC7:0E0C  Ovl  __SX_ENCRYPT
 2AC7:0E12  Ovl  __SX_SETSEED
 2AC7:0E18  Ovl  SX_SETPASS
 2AC7:0E1E  Ovl  __SX_DECRYPT
 2AC7:0E24  Ovl  __SX_SETKEY
 2AC7:0E30  Ovl  __SWOPENER
 2AC7:0E36  Ovl  _SWFLENGTH
 2AC7:0E42  Ovl  SX_ISREIND
 2AC7:0E48  Ovl  SX_KEYSINC
 2AC7:0E4E  Ovl  SX_STEP
 2AC7:0E54  Ovl  SX_I_INDEX
 2AC7:0E5A  Ovl  SX_I_TAGNA
 2AC7:0E66  Ovl  __SWORDERASNUMBER
 2AC7:0E6C  Ovl  __SWORDERLISTFOCUS
 2AC7:0E72  Ovl  __SWORDSET
 2AC7:0E78  Ovl  _SWINDEXCLOSE
 2AC7:0E7E  Ovl  __SWNUKETAG
 2AC7:0E84  Ovl  __SWADJUSTLIST
 2AC7:0E90  Ovl  __SWSEEK
 2AC7:0E96  Ovl  __SWSKIPRAW
 2AC7:0EA2  Ovl  SX_KILLTAG
 2AC7:0EA8  Ovl  __SWORDERDESTROY
 2AC7:0EB4  Ovl  SX_TAGDELE
 2AC7:0EC6  Ovl  __SEXRLCK
 2AC7:0ECC  Ovl  __SEXRUNL
 2AC7:0ED2  Ovl  __SEXFLCK
 2AC7:0ED8  Ovl  __SEXFUNL
 2AC7:0EDE  Ovl  __SEXALCK
 2AC7:0EE4  Ovl  __SEXAUNL
 2AC7:0EEA  Ovl  __SEXWPCHK
 2AC7:0EF0  Ovl  _SEXLOCK
 2AC7:0EF6  Ovl  _SEXUNLOCK
 2AC7:0F02  Ovl  __SWFINDFREEBLOCK
 2AC7:0F08  Ovl  __SWFLUSHMEMOROOT
 2AC7:0F0E  Ovl  __SWISFREEBLOCK
 2AC7:0F14  Ovl  __SWINSERTFREEBLOCK
 2AC7:0F1A  Ovl  __SWKILLMEMOROOT
 2AC7:0F20  Ovl  __SWEXPANDLASTBLOCK
 2AC7:0F26  Ovl  __SWREADMEMOROOT
 2AC7:0F2C  Ovl  __SWGETFREEBLOCK
 2AC7:0F38  Ovl  __SXENCMEMOREAD
 2AC7:0F3E  Ovl  __SXENCMEMOWRITE
 2AC7:0F4A  Ovl  __SWCONDCLEAR
 2AC7:0F50  Ovl  __SEXORDERCONDITION
 2AC7:0F56  Ovl  _SXCONDSET
 2AC7:0F62  Ovl  ___CDXPAGEREAD
 2AC7:0F68  Ovl  ___CDXPAGEAPPEND
 2AC7:0F6E  Ovl  ___NSXPAGEREAD
 2AC7:0F74  Ovl  ___NSXPAGEREADLOCK
 2AC7:0F7A  Ovl  ___CDXPAGEREADLOCK
 2AC7:0F86  Ovl  __SXISLOCKED
 2AC7:0F8C  Ovl  __SXRLOCK
 2AC7:0F92  Ovl  __SXUNLOCK
 2AC7:0F98  Ovl  __SXGETLOCKS
 2AC7:0F9E  Ovl  __SXDBFUNLOCK
 2AC7:0FAA  Ovl  _SWFINDTAG
 2AC7:0FB0  Ovl  __SWSURFACE
 2AC7:0FB6  Ovl  _SWFINDINDEX
 2AC7:0FC2  Ovl  _SX_TRIGVA
 2AC7:0FC8  Ovl  SX_SETTRIG
 2AC7:0FCE  Ovl  __SXCALLTRIGGER
 2AC7:0FDA  Ovl  __SXPARSENAME
 2AC7:0FE0  Ovl  __SXGETEXT
 2AC7:0FE6  Ovl  __CDXSWAPBYTES
 2AC7:0FEC  Ovl  __SEXTRIM_N
 2AC7:0FF2  Ovl  __SXMAKESTR
 2AC7:0FF8  Ovl  __CLIPALLOC
 2AC7:0FFE  Ovl  __CLIPFREE
 2AC7:1004  Ovl  __SXNAMEEXT
 2AC7:1010  Ovl  __SXSMARTUPPER
 2AC7:1016  Ovl  __SWOURDBFDRIVER
 2AC7:101C  Ovl  _SWPARM2TYPE
 2AC7:1022  Ovl  __SXSWAPBYTES
 2AC7:102E  Ovl  __VFGETLEN
 2AC7:103A  Ovl  __VFGETBLOCK
 2AC7:1040  Ovl  SX_DTOP
 2AC7:1046  Ovl  SX_PTOD
 2AC7:1058  Ovl  __VFPUTBLOCK
 2AC7:105E  Ovl  SX_VFGET
 2AC7:106A  Ovl  __VFPUTVALUE
 2AC7:1070  Ovl  __VFGETVALUE
 2AC7:1076  Ovl  __VFGETTYPE
 2AC7:1082  Ovl  ___M6FREESIMPLE
 2AC7:1088  Ovl  ___M6CREATEMAP
 2AC7:109A  Ovl  ___M6CASEAND
 2AC7:10A0  Ovl  ___M6CASENOT
 2AC7:10A6  Ovl  ___M6CASEOR
 2AC7:10B2  Ovl  ___M6INITSTRUCTS
 2AC7:10B8  Ovl  __M6STRUCTSIZE
 2AC7:10BE  Ovl  __M6GOCOLD
 2AC7:10C4  Ovl  __M6CLOSE
 2AC7:10CA  Ovl  __M6SETFILTER
 2AC7:10D0  Ovl  __M6CLEARFILTER
 2AC7:10D6  Ovl  __M6PACK
 2AC7:10E2  Ovl  ___M6EQUALS
 2AC7:10E8  Ovl  ___M6CURRENT
 2AC7:10F4  Ovl  M6_RECCOUN
 2AC7:10FA  Ovl  _M6SET
 2AC7:1100  Ovl  ___M6RECCOUNT
 2AC7:1106  Ovl  M6_ERROR
 2AC7:110C  Ovl  ___M6ERROR
 2AC7:1118  Ovl  ___M6FREETOKE
 2AC7:111E  Ovl  ___M6DROPMAP
 2AC7:1124  Ovl  ___M6EVALUATE
 2AC7:1130  Ovl  ___M6NEXTFILTERREC
 2AC7:1136  Ovl  ___M6NEXTBITRAW
 2AC7:113C  Ovl  __M6SKIPFILTER
 2AC7:1148  Ovl  ___M6INITFILTER
 2AC7:114E  Ovl  ___M6KILLFILTER
 2AC7:1154  Ovl  M6_ISFILTE
 2AC7:115A  Ovl  M6_REFRESH
 2AC7:1160  Ovl  M6_DBFILTE
 2AC7:1166  Ovl  ___M6GETVALUE
 2AC7:116C  Ovl  ___M6GREATER
 2AC7:1172  Ovl  M6INIT
 2AC7:1178  Ovl  ___M6INSTR
 2AC7:1184  Ovl  ___M6FOXEMPTY
 2AC7:118A  Ovl  ___M6FOXDATA
 2AC7:1190  Ovl  ___M6ISKEY
 2AC7:1196  Ovl  ___M6ISKEYEXPR
 2AC7:119C  Ovl  ___M6ALIASTRIM
 2AC7:11A8  Ovl  ___M6ISOPT
 2AC7:11AE  Ovl  _M6ISOPTIM
 2AC7:11B4  Ovl  ___M6LESS
 2AC7:11C0  Ovl  ___M6MAPCOPY
 2AC7:11C6  Ovl  M6_FILTCOP
 2AC7:11CC  Ovl  ___M6FREELOCATE
 2AC7:11D2  Ovl  _M6CONTINU
 2AC7:11DE  Ovl  ___M6EVALAND
 2AC7:11E4  Ovl  ___M6EVALOR
 2AC7:11EA  Ovl  ___M6EVALNOT
 2AC7:11F0  Ovl  ___M6EVALXOR
 2AC7:11F6  Ovl  ___M6NOTEQUALS
 2AC7:1202  Ovl  ___M6OPTIMIZEDELETED
 2AC7:1208  Ovl  ___M6OPTIMIZEPARTIAL
 2AC7:120E  Ovl  __M6OURDRIVER
 2AC7:1214  Ovl  ___M6ISRANGE
 2AC7:1220  Ovl  ___M6ISUPPER
 2AC7:1226  Ovl  ___M6ISYEARDATE
 2AC7:122C  Ovl  ___M6ISYEARDTOS
 2AC7:1232  Ovl  ___M6ISEMPTY
 2AC7:124A  Ovl  ___M6STACKEXPR
 2AC7:1250  Ovl  ___M6ISBADEXPR
 2AC7:1256  Ovl  ___M6STACKAND
 2AC7:125C  Ovl  ___M6STACKOR
 2AC7:1262  Ovl  ___M6STACKNOT
 2AC7:1268  Ovl  ___M6SIMPSTRING
 2AC7:1274  Ovl  ___M6ISSUBSTR
 2AC7:127A  Ovl  ___M6MEMCHR
 2AC7:1280  Ovl  ___M6INCSTR
 2AC7:1286  Ovl  ___M6AREYOUSPACED
 2AC7:128C  Ovl  ___M6MATCHPAREN
 2AC7:1292  Ovl  ___M6MATCHPARENQ
 2AC7:1298  Ovl  ___M6SETWHILE
 2AC7:12B0  Ovl  ___M6MATCHBRACK
 2AC7:12B6  Ovl  ___M6TOKENIZE
 2AC7:12CE  Ovl  ___M6TRANSP
 2AC7:12D4  Ovl  ___M6KIND
 2AC7:12DA  Ovl  ___M6PRIORITY
 2AC7:12E0  Ovl  ___M6TRANSLATE
 2AC7:12EC  Ovl  ___M6NEWMAP
 2AC7:12F2  Ovl  ___M6BITNO
 2AC7:12F8  Ovl  ___M6UNLOCKALL
 2AC7:12FE  Ovl  ___M6FREEMAP
 2AC7:1304  Ovl  ___M6NEXTHANDLE
 2AC7:130A  Ovl  ___M6HANDLE2MAP
 2AC7:1310  Ovl  ___M6TOUCHBIT
 2AC7:1316  Ovl  ___M6ISSET
 2AC7:131C  Ovl  ___M6GOBIT
 2AC7:1322  Ovl  ___M6NEXTBIT
 2AC7:1328  Ovl  ___M6BITCOUNT
 2AC7:132E  Ovl  ___M6ISMAPEMPTY
 2AC7:1334  Ovl  _M6ERROR
 2AC7:133A  Ovl  MEMORY
 2AC7:1346  Ovl  __PAGE_UNLOCK
 2AC7:1358  Ovl  __PAGE_READLOCK
 2AC7:1364  Ovl  __PAGE_READ
 2AC7:1376  Ovl  __PAGE_UPDATE
 2AC7:1382  Ovl  __PAGE_WRITE
 2AC7:1388  Ovl  __DISKIOSLR
 2AC7:138E  Ovl  __PAGE_FLUSH
 2AC7:1394  Ovl  __XPAGE_READ
 2AC7:139A  Ovl  __PAGE_CLEAR
 2AC7:13A0  Ovl  __XPAGE_UPDATE
 2AC7:13B2  Ovl  __PAGE_APPEND
 2AC7:13BE  Ovl  __SORTSETFIELD
 2AC7:13C4  Ovl  _MERGE
 2AC7:13CA  Ovl  __SORTSORT
 2AC7:13D0  Ovl  __SORTADVANCE
 2AC7:13DC  Ovl  __SORTCOMPLETE
 2AC7:13E2  Ovl  __SORTEND
 2AC7:143C  Ovl  __SORTINIT
 2C0C:020A  Res  _BLIDEMCAL
 2C0C:0211  Res  _BLIDEMDTE
 2C0C:026A  Res  _BLIDEMMIN
 2C0C:0271  Res  _BLIERRNUM
 2C0C:0276  Res  _BLIERRPRM
 2C0C:0280  Res  _BLIOVLOPS
 2C0C:028A  Res  _BLIOVLRES
 2C0C:02C5  Res  _BLIOVLSIZ
 2C0C:02CF  Res  _BLIOVLSUS
 2C0C:030A  Res  _BLIREINIT
 2C0C:030A  Res  $$VMREINIT
 2C0C:033C  Res  _BLISERNUM
 2C0C:0342  Res  $$VMUNHOOK
 2C0C:0342  Res  _BLIUNHOOK
 2C0C:0386  Res  _BLIVERNUM
 2C0C:073E  Res  $$$OVLEND
 2C0C:08F7  Res  $$$OVLDEF
 2C0C:1010  Res  _BLITOTACT
 2C0C:1020  Res  _BLITOTLOD
 2C0C:103E  Res  _BLITOTSIZ
 2C0C:21B0  Res  $$$OVLERR
 2C0C:21C2  Res  $$$OVLINI
 2C0C:23E4  Res  $$$OVLCLP
 2C0C:2404  Res  BLICALNUM
 2C0C:240D  Res  BLIDEMCAL
 2C0C:2418  Res  BLIDEMDTE
 2C0C:2420  Res  BLIDEMMIN
 2C0C:242B  Res  BLIERRNUM
 2C0C:2433  Res  BLIERRPRM
 2C0C:243B  Res  BLIMEMPAK
 2C0C:2459  Res  BLIOVLCLR
 2C0C:2470  Res  BLIOVLOPS
 2C0C:2478  Res  BLIOVLRES
 2C0C:247E  Res  BLIOVLSIZ
 2C0C:2486  Res  BLIOVLSUS
 2C0C:248F  Res  BLIREINIT
 2C0C:2495  Res  BLISERNUM
 2C0C:249D  Res  BLIUNHOOK
 2C0C:24A3  Res  BLIVERNUM
 2C0C:2594  Res  $$$OVLPRM
 2C0C:280B  Res  $$$OVLDAT
 2C0C:28A6  Res  $$$OVLPRC
 2C0C:295F  Res  $$$KRNSEG
 2FA1:0000  Res  __WEEDBED
 373C:0000  Res  __WEEDEND
 3758:0000  Res  _T_START
 3758:0188  Res  _T_TRAN
 3758:05BA  Res  _ACCESSOR
 3758:0740  Res  _N_START
 3758:08C8  Res  _N_TRAN
 3758:0E84  Res  _D_RED
 3758:100A  Res  _R_START
 3758:1192  Res  _R_SYMB
 3758:1434  Res  _R_PROD
 3758:16D6  Res  _P_LENGTH
 3758:17E0  Res  _H_SYMBOL
 3758:18EA  Res  _STUFF
 3912:0000  Res  _SEXEMPTY
 3912:0002  Res  __SXCOPYRIGHT
 3915:0000  Res  __SXDEFTRIGGERNAME
 3916:0000  Res  _SEXMCORRUPTED
 3916:001C  Res  _SEXMKEYTOOLONG
 3916:0034  Res  _SEXMCANTFINDKEY
 3916:0056  Res  _SEXMINVALIDKEYLEN
 3916:006A  Res  _SEXMBADINDEXEXPR
 3916:0080  Res  _SEXMLOCKTIMEOUT
 3916:008E  Res  _SEXMNOSTRUCTURAL
 3916:00AC  Res  _SEXMINVALIDORDER
 3916:00BC  Res  _SEXMNOMEMO
 3916:00D8  Res  _SEXMNONCOMPACT
 39CF:0000  Res  __CDXSUPER
 39CF:0128  Res  _SEXKEYBUFFER
 39CF:0328  Res  _SEXBUFFER
 39CF:0428  Res  _SXTAGINFO
 39CF:047C  Res  __M6SUPER
 3A2A:0048  Res  _NSXMEMOSDD
 3A2A:007E  Res  _NTXMEMOSDD
 3A2A:00B4  Res  _CDXMEMOSDD
 3A2A:00EA  Res  __MEMOEXT
 3A2A:0172  Res  __ASIZDS
 3A2A:0174  Res  __ATOPSP
 3A2A:0176  Res  __AEXIT_RTN
 3A2A:0178  Res  __ABRKTB
 3A2A:01C8  Res  __ABRKTBE
 3A2A:01C8  Res  __ABRKP
 3A2A:01CA  Res  __ACFINFO
 3A2A:01D7  Res  __AINTDIV
 3A2A:01DB  Res  __FAC
 3A2A:01E3  Res  _ERRNO
 3A2A:01E5  Res  __UMASKVAL
 3A2A:01E7  Res  __PSPADR
 3A2A:01E9  Res  __PSP
 3A2A:01EB  Res  __DOSVERMAJOR
 3A2A:01EB  Res  __OSMAJOR
 3A2A:01EB  Res  __OSVERSION
 3A2A:01EC  Res  __DOSVERMINOR
 3A2A:01EC  Res  __OSMINOR
 3A2A:01ED  Res  __OSMODE
 3A2A:01EE  Res  __DOSERRNO
 3A2A:01EE  Res  __OSERR
 3A2A:01F0  Res  __NFILE
 3A2A:01F2  Res  __OSFILE
 3A2A:0206  Res  ___ARGC
 3A2A:0208  Res  ___ARGV
 3A2A:020C  Res  _ENVIRON
 3A2A:0210  Res  __PGMPTR
 3A2A:0216  Res  __CHILD
 3A2A:0218  Res  __OVLFLAG
 3A2A:0219  Res  __INTNO
 3A2A:021A  Res  __OVLVEC
 3A2A:021E  Res  __ADBGMSG
 3A2A:023A  Res  _HUGE
 3A2A:0242  Res  __MATHERR_FLAG
 3A2A:0244  Res  OPTAB
 3A2A:026A  Res  __FCSP
 3A2A:026C  Res  __FPSIGADR
 3A2A:0270  Res  __FCTMP
 3A2A:03DA  Res  __FCTOPST
 3A2A:03EE  Res  $I8_RESULT
 3A2A:03EE  Res  $I4_RESULT
 3A2A:0426  Res  $I4_ROUND_FLAG
 3A2A:0427  Res  $I4_ROUND_EXP
 3A2A:0429  Res  $I4_AC_HI
 3A2A:042D  Res  $I4_AC_LO
 3A2A:043E  Res  $I8_ROUND_FLAG
 3A2A:043F  Res  $I8_ROUND_EXP
 3A2A:0441  Res  $I8_AC_HI
 3A2A:0449  Res  $I8_AC_LO
 3A2A:04DA  Res  $I8_HALF
 3A2A:04E2  Res  $I8_ONE
 3A2A:04EA  Res  $I8_TWO
 3A2A:04F2  Res  $I8_ARG
 3A2A:04FA  Res  $I8_TEMP
 3A2A:051B  Res  $I8_LOG_HI
 3A2A:0523  Res  $I8_LOG_LO
 3A2A:0590  Res  $I8_Z
 3A2A:0598  Res  $I8_ZZ
 3A2A:05A0  Res  $I8_PZZ
 3A2A:05B8  Res  $I8_INPUT_WS
 3A2A:05B9  Res  $I8_IMPLICIT_EXP
 3A2A:062E  Res  __SFIELDS
 3A2A:0632  Res  __SFCOUNT
 3A2A:0634  Res  __SLBASE
 3A2A:0638  Res  __SRBASE
 3A2A:063C  Res  __SRSIZE
 3A2A:0644  Res  __TERROR
 3A2A:0646  Res  __HORROR
 3A2A:0648  Res  __TVERSION
 3A2A:064A  Res  __TXERROR
 3A2A:064C  Res  __TXCLASS
 3A2A:064E  Res  __TXACTION
 3A2A:0650  Res  __TXLOCUS
 3A2A:0810  Res  __MSCONFLICT1
 3A2A:0810  Res  __CFLTCVT_TAB
 3A2A:08A0  Res  __XARGC
 3A2A:08A2  Res  __XARGV
 3A2A:0914  Res  C50R100
 3A2A:0916  Res  CLIPPER520
 3A2A:0A1C  Res  __EVKBDENTRY
 3A2A:0A46  Res  _DMOD_TABLE
 3A2A:0A70  Res  __OGEN0
 3A2A:0B0C  Res  __OGEN1
 3A2A:0BA8  Res  __OGEN
 3A2A:0BAC  Res  __OBOUNDS
 3A2A:0BB4  Res  __OPF
 3A2A:0BB6  Res  __OPX
 3A2A:0BF8  Res  __XLOCK
 3A2A:0BFA  Res  __XGRIP1
 3A2A:0BFC  Res  __XGRIP2
 3A2A:0BFE  Res  __XGRIP3
 3A2A:0C00  Res  __XSEGMIN
 3A2A:0C02  Res  __XSAFE
 3A2A:0C3A  Res  __SYMEVAL
 3A2A:0C42  Res  __IBPUSHTRAN
 3A2A:0C46  Res  __IBEVALTRAN
 3A2A:0C4A  Res  __EVAL
 3A2A:0C4C  Res  __TOS
 3A2A:0C4E  Res  __EVALHIGH
 3A2A:0C50  Res  __ESTATLOW
 3A2A:0C52  Res  __ESTAT
 3A2A:0C54  Res  __EEXTENT
 3A2A:0C56  Res  __LBASE
 3A2A:0C58  Res  __FBASE
 3A2A:0C5A  Res  __SBASE
 3A2A:0C5C  Res  __PCOUNT
 3A2A:0C5E  Res  __FZZCOUNT
 3A2A:0C62  Res  __LINE_NUM
 3A2A:0C64  Res  __XLINE
 3A2A:0C66  Res  __SYSFLAGS
 3A2A:0C70  Res  __MSTACK
 3A2A:0C74  Res  __MLINK
 3A2A:0C78  Res  __MCOUNT
 3A2A:0C7A  Res  __MTOP
 3A2A:0C7C  Res  __MBP
 3A2A:0C7E  Res  __PTOP
 3A2A:0D80  Res  __SET
 3A2A:0DFC  Res  __SETHANDLER
 3A2A:0F84  Res  __ERRORDICT
 3A2A:0F90  Res  __SALT
 3A2A:0F92  Res  __NETERR
 3A2A:1124  Res  __FSEGS
 3A2A:1128  Res  __LONESEGS
 3A2A:1136  Res  __OSEGS
 3A2A:1D78  Res  __STACKBASE
 3A2A:1D7A  Res  __STACKSLOP
 3A2A:1E04  Res  _PRESERVE1
 3A2A:1E08  Res  _PRESERVE2
 3A2A:1E0C  Res  _OVERLAYTOP
 3A2A:1E0E  Res  _OVERLAYLINE
 3A2A:1E10  Res  _OVERLAYLEVEL
 3A2A:1E12  Res  __MEMCOUNT
 3A2A:1E14  Res  __DISKIODROP
 3A2A:1E18  Res  _SWAPLOWEVENTID
 3A2A:1E1A  Res  _RECEIVERHANDLE
 3A2A:21A4  Res  _MACRO_ERROR
 3A2A:2864  Res  _REZ_ALIAS
 3A2A:2AAA  Res  __MACROP
 3A2A:2AB0  Res  __PFVERSION
 3A2A:2AB2  Res  __PFLOCK
 3A2A:2AB4  Res  __DYN_GETPP
 3A2A:2AB8  Res  __DBGCOMM
 3A2A:2C0E  Res  __PREEXTP
 3A2A:2C12  Res  __POSTEXTP
 3A2A:2C16  Res  __ALERTP
 3A2A:2D74  Res  __NO_SNOW
 3A2A:2D76  Res  __NBUFF
 3A2A:2E64  Res  __TCSTR
 3A2A:2E68  Res  __TCLEN
 3A2A:2ED4  Res  __COLORCOUNT
 3A2A:2ED6  Res  __COLORS
 3A2A:2F52  Res  __TBUFF
 3A2A:2F56  Res  __TBUFFSIZE
 3A2A:2F8E  Res  __GETDICT
 3A2A:31C6  Res  _VGETSYS
 3A2A:321A  Res  __SELECTION
 3A2A:3220  Res  __WORKAREAS
 3A2A:3368  Res  __WAFUNCTABLE
 3A2A:34B8  Res  __SDFSUPER
 3A2A:35F8  Res  _VSDF
 3A2A:3756  Res  __NASCII
 3A2A:3758  Res  __NDBCS
 3A2A:4266  Res  _VDISPLAY
 3A2A:43C4  Res  _VKEYBOARD
 3A2A:4484  Res  _VSIXCDX
 3A2A:44C0  Res  _CDXIDXSDD
 3A2A:4508  Res  __CDXFUNCTABLE
 3A2A:46D0  Res  __CDXDIRECT
 3A2A:4796  Res  __SWSKIPOPT
 3A2A:4798  Res  __SWSKIPCNT
 3A2A:479A  Res  __SEXFPATH
 3A2A:479E  Res  __SEXERROR
 3A2A:47A0  Res  _SEXDIRTYREAD
 3A2A:47A2  Res  _SEXSORTOPTION
 3A2A:47A4  Res  _SLOCALERR
 3A2A:47C8  Res  __SEXLOCKRETRY
 3A2A:47CA  Res  _UIKEYDUPECNT
 3A2A:47CC  Res  _UIKEYITEMLEN
 3A2A:47CE  Res  _UIKEYTRAIL
 3A2A:47D0  Res  _ULKEYRECNO
 3A2A:47D4  Res  ___SWCHKHIGHLOW
 3A2A:47D8  Res  ___SWSCOPEEND
 3A2A:47DC  Res  __SEXISREINDEX
 3A2A:47DE  Res  _SEXIINFO
 3A2A:47EE  Res  _CPDEFTRIGGER
 3A2A:47F2  Res  _CPPENDTRIGGER
 3A2A:47F6  Res  _CADEFCODE
 3A2A:4800  Res  _SXENCRBUFF
 3A2A:4804  Res  _SXENCRBUFFSIZE
 3A2A:4806  Res  __SEXAUTOOPEN
 3A2A:4808  Res  __SEXAUTOSHARE
 3A2A:480A  Res  __SEXMEMOSIZE
 3A2A:480E  Res  __SEXMEMOCHANGED
 3A2A:4810  Res  _BHAVEMEMOEXT
 3A2A:4812  Res  __SEXSKIP0REFRESH
 3A2A:4814  Res  __SEXSTRUCTURALCHECK
 3A2A:4992  Res  _VSXDBF
 3A2A:49C8  Res  __SWMEMOSIGNATURE
 3A2A:49D2  Res  __SWSTACK
 3A2A:4C08  Res  _CBIT_ON
 3A2A:4C10  Res  _CBIT_OFF
 3A2A:4C1C  Res  __DYN_USED
 3A2A:4C8C  Res  __PAGE_ERROR
 3A2A:4C8E  Res  __PAGE_GOT
 3A2A:4CE0  Res  ___SYMPB
 3A2A:4CF0  Res  ___SYMPE
 3A2A:4CF2  Res  __FPINIT
 3A2A:4D0E  Res  __DYNINA
 3A2A:4D12  Res  __MACROINA
 3A2A:4D30  Res  __LTABLE
 3A2A:4D30  Res  _VDB
 3A2A:4D30  Res  _VPICT
 3A2A:4D30  Res  _VOPS
 3A2A:4D30  Res  _VTERM
 3A2A:4D30  Res  _VMACRO
 3A2A:5090  Res  _EDATA
 3A2A:5090  Res  __EDATA
 3A2A:51E0  Res  _THEGET
 3A2A:51E2  Res  _THEGINFO
 3A2A:520E  Res  _THEBUFF
 3A2A:5212  Res  _THEBUFFLEN
 3A2A:5214  Res  _THETEMP
 3A2A:5218  Res  _THETEMPLEN
 3A2A:521A  Res  _EBREAK
 3A2A:521C  Res  _FPMEMOREAD
 3A2A:5220  Res  _FPMEMOWRITE
 3A2A:5224  Res  __SXDBFSUPER
 3A2A:534C  Res  __AM6SET
 3A2A:5360  Res  __END
 3A2A:5360  Res  _END

 Program entry point at 2C0C:0004
GAS-Pro v4.0
008006017077001007027001015001176001

ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 Codigo..........:
 Termino Carencia:
 Obs1............:
 Obs2............:
 Obs3............:
[Ÿ]
Inclus„o~~26006
Manuten‡„o~~27007
Consulta~~28008
[Ÿ]
 11 
 2 
Sequencia

 2 
[Ÿ]
Contrato

 5 
[Ÿ]
Avisos / carencias
Avisos / Carencias







005




































-1 
 1 
-1 
-1 
 0 
-1 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
filial
C
I
@!
 2 
 2 
 0 
 0 
 0 
Filial






 0 
 0 


seq0
C
V
999999
 6 
 6 
 1 
 3 
 0 
Seq0






 0 
 1 


data_
D
V
@D
 8 
 10 
 1 
 49 
 0 
Data_



DATE()


 0 
 0 


por
C
V
 
 10 
 10 
 1 
 60 
 0 
Por



M->usuario


 0 
 0 


codigo
C
E
@!
 9 
 9 
 3 
 20 
 0 
Codigo

(PTAB(ALLTRIM(codigo),[GRUPOS]).AND.BXR_07F9()).AND.(PTAB(codigo,'TAXAS',1).OR.1=1).AND.CAD_04F9(op_menu)
Contrato inv lido |ou inexistente

Informe o n£mero do contrato
VDBF(6,3,20,77,'GRUPOS',{'codigo','grupo','nome','endereco'},1,'codigo',[])
 0 
 0 


tcarenc_
D
E
@D
 8 
 10 
 4 
 20 
 0 
Termino Carencia

 


Informe a data do termino da carencia
date()+90
 0 
 0 


obs1
C
E
@!
 50 
 50 
 5 
 20 
 0 
Obs1

 




 0 
 0 


obs2
C
E
@!
 50 
 50 
 6 
 20 
 0 
Obs2

 




 0 
 0 


obs3
C
E
@!
 50 
 50 
 7 
 20 
 0 
Obs3

 




 0 
 0 


idxd
C
I
@!
 15 
 15 
 0 
 0 
 0 
Idxd






 0 
 0 


idxm
C
I
@!
 15 
 15 
 0 
 0 
 0 
Idxm






 0 
 0 


 1 
nome
iif(ptab(codigo,[grupos]),grupos->nome,[ ])

 3 
 31 
 35 

 3 
MFILIAL
idxd
dtoS(DATE())+time()+M->por

EMPT(idxd)


MFILIAL
idxm
DTOS(DATE())+time()+M->por




MFILIAL
filial
M->p_filial




 0 
 0 
 0 
procedure imp_01f9
/*
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
 \ Empresa.: PresServ Inform tica-Limeira (019)452.6623
 \ Programa: IMP_01F9.PRG
 \ Data....: 06-05-97
 \ Sistema.: Administradora - RECEP€„O
 \ Funcao..: F¢rmula (processo falec.) a mostrar na tela de IMPPAR
 \ Analista: Ademilson Pedro Bom
 \ Criacao.: Programado manualmente pelo analista
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/

#include "adrbig.ch"    // inicializa constantes manifestas

IF base=[AFU]
 IF PTAB(LEFT(docto,9),[AFUNER],1)
  RETU AFUNER->falecido
 ENDIF
ENDI
IF base=[BXR]
 IF PTAB(LEFT(docto,8),[BXREC],1)
  RETU BXREC->codigo+[ ]+BXREC->tipo+[ ]+BXREC->circ+[ ]+;
       TRAN(BXREC->valorpg,"@E 999,999.99")
 ENDIF
ENDIF
IF base=[OBX]
 IF PTAB(LEFT(docto,8),[OBXEC],1)
  RETU OBXEC->codigo+[ ]+OBXEC->ref+[ ]+;
       TRAN(OBXEC->valorpg,"@E 999,999.99")
 ENDIF
ENDIF

RETU [<<N„o encontrado>>]      // <- deve retornar um valor qualquer

* \\ Final de IMP_01F9.PRG
GAS-Pro v4.0
006003022079001028029016019001176001


-----------------------------------------------------------------------
              Cobran‡a:                           Valor.:

Contrato..:                                       Data..:
Nome......:
Endere‡o..:
Bairro....:
Cid./Cobr.:                                         ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
                                                    Op:
Valor:

ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ


-----------------------------------------------------------------------
              Cobran‡a:                           Valor.:

Contrato..:                                       Data..:
Nome......:
Endere‡o..:
Bairro....:                                         ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Cid./Cobr.:                                         Op:
Valor:
[Ÿ]
 30 
BXREC
Recibos (2¦via)


PTAB(PADR(SUBSTR(M->ide_maq,2),4)+[BXR],[IMPPAR],1).AND.numero=LEFT(IMPPAR->docto,8)
011

























 0 
 1 










 0 
 2 
 0 
 33 
 1 
 3 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
-1 
 0 
-1 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
N§ Recibo
numero
@R 99-999999
 9 
C
 4 
 1 


          










Ident1
LEFT(M->setup1,35)

 35 
C
 1 
 1 


 û        










Ident2
M->setup2

 50 
C
 2 
 1 


          










Valor
valorpg
@E 999,999.99
 10 
N
 4 
 59 


û         










Ref.:
cobranca

 18 
C
 4 
 27 


û         










Grupo 1
GRUPOS->grupo +[  ]+codigo

 10 
C
 6 
 13 


û         










Descri‡„o 1
CLASSES->descricao
@!
 35 
C
 5 
 13 


          










Nome
GRUPOS->nome

 35 
C
 7 
 13 


û         










Endere‡o
GRUPOS->endereco
 
 35 
C
 8 
 13 


          










Bairro
GRUPOS->bairro
 
 25 
C
 9 
 13 


          










Cidade
GRUPOS->cidade+[ ] +GRUPOS->cobrador

 35 
C
 10 
 13 


          










Valor Ext
chr(15)+'('+SUBSTR(EXT(valorpg),1,AT('/',EXT(valorpg))-1)+')'+chr(18)

 70 
C
 12 
 8 


          










data 1
emitido_
@D
 10 
C
 6 
 59 


          










operador
LEFT(por,1)+LOWER(SUBSTR(por,2))

 15 
C
 11 
 57 


          










2 Ident1
LEFT(M->setup1,35)

 35 
C
 15 
 1 


 û        










2 Ident 2
M->setup2

 50 
C
 16 
 1 


          










2 N§ Recibo
M->nrauxrec
@R 99-999999
 9 
C
 18 
 1 


          










Valor pago
valorpg
@E 999,999.99
 10 
N
 18 
 59 


û         










Ref.:
cobranca

 18 
C
 18 
 26 


û         










Grupo
GRUPOS->grupo +[  ]+codigo

 10 
C
 20 
 13 


û         










Descri‡„o 2
CLASSES->descricao
@!
 35 
C
 19 
 13 


          










Nome
GRUPOS->nome

 35 
C
 21 
 13 


û         










Endere‡o
GRUPOS->endereco

 35 
C
 22 
 13 


          










Bairro
GRUPOS->bairro

 25 
C
 23 
 13 


          










Cidade
GRUPOS->cidade+[ ] +GRUPOS->cobrador

 35 
C
 24 
 13 


          










Valor Ext
chr(15)+'('+SUBSTR(EXT(valorpg),1,AT('/',EXT(valorpg))-1)+')'+chr(18)

 70 
C
 25 
 8 


          










Emitido em
emitido_
@D
 10 
D
 20 
 59 


          










Operador
LEFT(por,1)+LOWER(SUBSTR(por,2))

 15 
C
 24 
 57 


          










codigo barras1
cobranca

 25 
4
 27 
 10 


          










codigo barras2
cobranca

 25 
4
 28 
 10 


          










 9 
Nome da empresa
nemp

 0 
 0 
 44 

T¡tulo aplica‡„o
nsis

 0 
 0 
 25 

Data do sistema
DTOC(DATE())

 0 
 0 
 8 

Nome do mˆs
NMES(DATE())

 0 
 0 
 8 

Dia da semana
NSEM(DATE())

 0 
 0 
 7 

N£mero da p gina
TRAN(pg_,'9999')

 0 
 0 
 4 

C¢digo relat¢rio
"ADM_RS18"

 0 
 0 
 8 

T¡tulo a definir
titrel

 0 
 0 
 30 

Hora da emiss„o
hora_rel_

 0 
 0 
 5 

 0 
 0 
 0 
 6 
GRUPOS
 1 
codigo



TAXAS
 1 
cobranca



ARQGRUP
 1 
GRUPOS->grupo



COBRADOR
 1 
TAXAS->cobrador



REGIAO
 1 
GRUPOS->regiao



CLASSES
 1 
GRUPOS->tipcont



t   b                      PW_GRUPO   C                   PW_NOGRUPO C                     ¤•¤–µ©Á®Á½¸È·´·¦Ã…“€
 RX2002F9–Ñ  RX2002F9CODEC_ETEXTENDCODE	_SYMSTARTSYMSTARTSYMBOLSSYMBOLS_SYMENDSYMENDNULLBEGDATA_DATADATA_SYMPBDATA_SYMPDATA_SYMPEDATA_CONSTCONST_MSGMSG_BEGBSSBEGBSS_BSSBSS_ENDBSSENDBSSDGROUP@˜ @è0˜ H  ˜ h  ë˜ `0 	¿˜ h  
ã˜ h  ß˜ H  û˜ H  ÷˜ H ë˜ H  ï˜ H  ë˜ (  ˜ H  procedure r08701f9
/*
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
 \ Empresa.: PresServ Inform tica-Limeira (019)452.6623
 \ Programa: R08702F9.PRG
 \ Data....: 17-09-97
 \ Sistema.: Administradora - PLANO
 \ Funcao..: Express„o de filtro do relat¢rio ADP_R087.PRG
 \ Analista: Ademilson Pedro Bom
 \ Criacao.: Programado manualmente pelo analista
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/

#include "adrbig.ch"    // inicializa constantes manifestas
donex:=V87001F9()
DO CASE
CASE valorpg>0 // J  paga, tchau!!!
 donex:=.f.
CASE !(SUBSTR('123  123',VAL(tipo),1)=M->rtp) //N„o ‚ meu tipo!!!
 donex:=.f.
CASE (stat>[1].AND.!(M->rreimp=[S])) //J  foi impressa !!!
 donex:=.f.
CASE !EMPT(M->rgrupo).AND.!(GRUPOS->grupo=M->rgrupo)// Quero s¢ o grupo!!
 donex:=.f.
CASE VAL(M->rproxcirc)>0.AND.(TAXAS->circ<M->rproxcirc)//Circular menor
 donex:=.f.
CASE VAL(M->rultcirc)>0.AND.(TAXAS->circ>M->rultcirc)//Circular maior
 donex:=.f.
CASE VAL(M->rcod1)>0.AND.TAXAS->codigo<M->rcod1
 donex:=.f.
CASE VAL(M->rcod2)>0.AND.TAXAS->codigo>M->rcod2
 donex:=.f.
CASE TAXAS->emissao_< M->rem1_.OR.TAXAS->emissao_>M->rem2_
 donex:=.f.
OTHERWISE
 donex:=.t.
ENDCASE

RETU  M->donex     // <- deve retornar um valor L¢GICO

* \\ Final de R08701F9.PRG
/*
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
 \ Empresa.: Ind£stria de Urnas Bignotto Ltda
 \ Programa: ADM_R033.PRG
 \ Data....: 18-11-96
 \ Sistema.: Administradora -CRD/COBRAN€A
 \ Funcao..: Uma a uma
 \ Analista: Ademilson Pedro Bom
 \ Criacao.: GAS-Pro v3.0 
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/
#include "adcbig.ch"    // inicializa constantes manifestas

LOCAL dele_atu, getlist:={}
PARA  lin_menu, col_menu
PRIV  tem_borda:=.t., op_menu:=VAR_COMPL, l_s:=8, c_s:=16, l_i:=13, c_i:=59, tela_fundo:=SAVESCREEN(0,0,MAXROW(),79)
nucop=1
SETCOLOR(drvtittel)
vr_memo=NOVAPOSI(@l_s,@c_s,@l_i,@c_i)     // pega posicao atual da tela
CAIXA(mold,l_s,c_s,l_i,c_i)               // monta caixa da tela
@ l_s,c_s+14 SAY " TAXAS (2¦ VIA) "
SETCOLOR(drvcortel)
@ l_s+01,c_s+1 SAY " Contrato:"
@ l_s+04,c_s+1 SAY " Circular:  -               Confirma?"
rcodigo=SPAC(6)                                    // Codigo
rtipo=SPAC(1)                                      // Tipo
rcirc=SPAC(3)                                      // Circular
confirme=SPAC(1)                                   // Confirme?
DO WHILE .t.
 rola_t=.f.
 cod_sos=56
 SET KEY K_ALT_F8 TO ROLATELA
 SETCOLOR(drvcortel+","+drvcorget+",,,"+corcampo)
 @ l_s+01 ,c_s+12 GET  rcodigo;
                  PICT "999999";
                  VALI CRIT("PTAB(rcodigo,'GRUPOS',1)~Necess rio informar CODIGO")
                  AJUDA "Informe o n£mero do contrato"
                  CMDF8 "VDBF(6,3,20,77,'GRUPOS',{'grupo','codigo','nome','cidade'},1,'codigo',[])"
                  MOSTRA {"LEFT(TRAN(GRUPOS->nome,[@!]),35)", 2 , 5 }
                  MOSTRA {"LEFT(TRAN(GRUPOS->endereco,[]),35)", 3 , 5 }

 @ l_s+04 ,c_s+12 GET  rtipo;
                  PICT "!";
                  VALI CRIT("rtipo $ [123678]~TIPO n„o aceit vel")
                  AJUDA "Qual o tipo de lan‡amento"
                  CMDF8 "MTAB([1=J¢ia|2=Taxa|3=Carnˆ|6=J¢ia+Seguro|7=Taxa+Seguro|8=Carnˆ+Seguro],[TIPO])"

 @ l_s+04 ,c_s+14 GET  rcirc;
                  PICT "999";
                  VALI CRIT("PTAB(rcodigo+rtipo+rcirc,'TAXAS',1)~Necess rio informar CIRCULAR v lida")
                  AJUDA "Informe o n£mero da circular a imprimir"

 @ l_s+04 ,c_s+39 GET  confirme;
                  PICT "!";
                  VALI CRIT("confirme='S'.AND.V03301F9()~Digite S para confirmar|ou|Tecle ESC para cancelar")
                  AJUDA "Digite S para confirmar|ou|Tecle ESC para cancelar"

 READ
 SET KEY K_ALT_F8 TO
 IF rola_t
  ROLATELA(.f.)
  LOOP
 ENDI
 IF LASTKEY()=K_ESC                                // se quer cancelar
  RETU                                             // retorna
 ENDI

 #ifdef COM_REDE
  IF !USEARQ("TAXAS",.f.,10,1)                     // se falhou a abertura do arq
   RETU                                            // volta ao menu anterior
  ENDI
 #else
  USEARQ("TAXAS")                                  // abre o dbf e seus indices
 #endi

 PTAB(codigo,"GRUPOS",3,.t.)                       // abre arquivo p/ o relacionamento
 PTAB(GRUPOS->grupo,"ARQGRUP",1,.t.)
 PTAB(GRUPOS->regiao,"REGIAO",1,.t.)
 PTAB(GRUPOS->grupo+circ,"CIRCULAR",1,.t.)
 SET RELA TO codigo INTO GRUPOS,;                  // relacionamento dos arquivos
          TO GRUPOS->grupo INTO ARQGRUP,;
          TO GRUPOS->regiao INTO REGIAO,;
          TO GRUPOS->grupo+circ INTO CIRCULAR
 titrel:=criterio := ""                            // inicializa variaveis
 cpord="codigo"
 titrel:=chv_rela:=chv_1:=chv_2 := ""
 tps:=op_x:=ccop := 1
 IF !opcoes_rel(lin_menu,col_menu,16,11)           // nao quis configurar...
  CLOS ALL                                         // fecha arquivos e
  LOOP                                             // volta ao menu
 ENDI
 IF tps=2                                          // se vai para arquivo/video
  arq_=ARQGER()                                    // entao pega nome do arquivo
  IF EMPTY(arq_)                                   // se cancelou ou nao informou
   LOOP                                            // retorna
  ENDI
 ELSE
  arq_=drvporta                                    // porta de saida configurada
 ENDI
 SET PRINTER TO (arq_)                             // redireciona saida
 EXIT
ENDD
criterio_=criterio                                 // salva criterio e ordenacao
cpord_=cpord                                       // definidos se huver
criterio=""

#ifdef COM_REDE
 IF !USEARQ("CPRCIRC",.f.,10,1)                    // se falhou a abertura do arq
  RETU                                             // volta ao menu anterior
 ENDI
#else
 USEARQ("CPRCIRC")                                 // abre o dbf e seus indices
#endi

cpord="grupo+circ+DTOS(dfal)"
INDTMP()
criterio=criterio_                                 // restabelece criterio e
cpord=cpord_                                       // ordenacao definidos
SELE TAXAS
IF !EMPTY(drvtapg)                                 // existe configuracao de tam pag?
 op_=AT("NNN",drvtapg)                             // se o codigo que altera
 IF op_=0                                          // o tamanho da pagina
  msg="Configura‡„o do tamanho da p gina!"         // foi informado errado
  DBOX(msg,,,,,"ERRO!")                            // avisa
  CLOSE ALL                                        // fecha todos arquivos abertos
  RETU                                             // e cai fora...
 ENDI                                              // codigo para setar/resetar tam pag
 lpp_048=LEFT(drvtapg,op_-1)+"048"+SUBS(drvtapg,op_+3)
 lpp_066=LEFT(drvtapg,op_-1)+"066"+SUBS(drvtapg,op_+3)
ELSE
 lpp_048:=lpp_066 :=""                             // nao ira mudara o tamanho da pag
ENDI
DBOX("[ESC] Interrompe",15,,,NAO_APAGA)
dele_atu:=SET(_SET_DELETED,.t.)                    // os excluidos nao servem...
SET DEVI TO PRIN                                   // inicia a impressao
maxli=19                                           // maximo de linhas no relatorio
IMPCTL(lpp_048)                                    // seta pagina com 48 linhas
SET MARG TO 1                                      // ajusta a margem esquerda
IF tps=2
 IMPCTL("' '+CHR(8)")
ENDI
BEGIN SEQUENCE
 DO WHIL ccop<=nucop                               // imprime qde copias pedida
  pg_=1; cl=999
  INI_ARQ()                                        // acha 1o. reg valido do arquivo
  ccop++                                           // incrementa contador de copias
  ult_imp=0                                        // ultimo reg impresso
  DO WHIL !EOF()
   #ifdef COM_TUTOR
    IF IN_KEY()=K_ESC                              // se quer cancelar
   #else
    IF INKEY()=K_ESC                               // se quer cancelar
   #endi
    IF canc()                                      // pede confirmacao
     BREAK                                         // confirmou...
    ENDI
   ENDI
   IF codigo=M->rcodigo                            // se atender a condicao...
    REL_CAB(1,.t.)                                 // soma cl/imprime cabecalho
    @ cl,000 SAY "."
    ult_imp=RECNO()                                // ultimo reg impresso
    chv033=GRUPOS->grupo+TAXAS->circ
    SELE CPRCIRC
    SEEK chv033
    IF FOUND()
     DO WHIL ! EOF() .AND. chv033=LEFT(&(INDEXKEY(0)),LEN(chv033))
      #ifdef COM_TUTOR
       IF IN_KEY()=K_ESC                           // se quer cancelar
      #else
       IF INKEY()=K_ESC                            // se quer cancelar
      #endi
       IF canc()                                   // pede confirmacao
        BREAK                                      // confirmou...
       ENDI
      ENDI
      REL_CAB(1)                                   // soma cl/imprime cabecalho
      IMPCTL(drvpc20)                              // comprime os dados
      @ cl,030 SAY num                             // Contrato
      @ cl,041 SAY processo                        // Processo
      @ cl,054 SAY fal                             // Falecido
      @ cl,091 SAY TRAN(ALLTRIM(ends)+'-'+ALLTRIM(cids),"@!")// Ends
      @ cl,149 SAY TRAN(dfal,"@D")                 // Data
      IMPCTL(drvtc20)                              // retira comprimido
      SKIP                                         // pega proximo registro
     ENDD
    ENDI
    SELE TAXAS                                     // volta ao arquivo pai
    SKIP                                           // pega proximo registro
    cl=999                                         // forca salto de pagina
   ELSE                                            // se nao atende condicao
    SKIP                                           // pega proximo registro
   ENDI
  ENDD
  REL_RDP(.t.)                                     // imprime rodape' do relatorio
 ENDD ccop
 EJEC                                              // salta pagina
END SEQUENCE
SET MARG TO                                        // coloca margem esquerda = 0
IMPCTL(lpp_066)                                    // seta pagina com 66 linhas
SET PRINTER TO (drvporta)                          // fecha arquivo gerado (se houver)
SET DEVI TO SCRE                                   // direciona saida p/ video
IF tps=2                                           // se vai para arquivo/video
 BROWSE_REL(arq_,2,3,MAXROW()-2,78)
ENDI                                               // mostra o arquivo gravado
GRELA(16)                                          // grava variacao do relatorio
SELE TAXAS                                         // salta pagina
SET RELA TO                                        // retira os relacionamentos
SET(_SET_DELETED,dele_atu)                         // os excluidos serao vistos
RETU

STATIC PROC REL_RDP(volta_reg)                     // rodape'
LOCAL ar_:=ALIAS(), reg_atual
SELE TAXAS                                         // volta ao arquivo pai
reg_atual=RECNO()
IF volta_reg
 GO ult_imp                                        // ajusta reg p/ imp de campos no rodape'
ENDI
@ 21,008 SAY CHR(18)+CIRCULAR->menscirc            // Mensagem
@ 25,017 SAY TRAN(valor,"@E 999,999.99")           // Valor
@ 25,065 SAY TRAN(valor,"@E 999,999.99")           // Valor 2
@ 28,020 SAY TRAN(0,"########")                    // N§ Recibo
@ 28,068 SAY TRAN(0,"########")                    // N§ Recibo 2
@ 31,002 SAY TAXAS->circ+[     ]+DTOC(TAXAS->emissao_)+[     ]+STR(GRUPOS->funerais,2)// Circular 1
@ 31,038 SAY TAXAS->circ+[     ]+DTOC(TAXAS->emissao_)+[     ]+STR(GRUPOS->funerais,2)// Circular 2
@ 34,002 SAY GRUPOS->grupo +[        ]+codigo+[       ]+GRUPOS->cobrador// Grupo 1
@ 34,038 SAY GRUPOS->grupo +[        ]+codigo+[       ]+GRUPOS->cobrador// Grupo 2
@ 36,000 SAY GRUPOS->nome                          // Nome
@ 36,036 SAY GRUPOS->nome                          // Nome 2
@ 37,000 SAY GRUPOS->endereco                      // Endere‡o
@ 37,036 SAY GRUPOS->endereco                      // Endere‡o 2
@ 38,000 SAY GRUPOS->bairro                        // Bairro
@ 38,036 SAY GRUPOS->bairro                        // Bairro 2
@ 39,000 SAY GRUPOS->cidade+[ ] +GRUPOS->cep       // Cidade
@ 39,036 SAY GRUPOS->cidade+[ ] +GRUPOS->cep       // Cidade 2
@ 40,000 SAY [Inic:]+DTOC(GRUPOS->admissao)+[ Ult:]+GRUPOS->ultcirc+[ QtTx:]+STR(GRUPOS->qtcircs,3)// Inicio
@ 40,036 SAY [Inic:]+DTOC(GRUPOS->admissao)+[ Ult:]+GRUPOS->ultcirc+[ QtTx:]+STR(GRUPOS->qtcircs,3)// Inicio 2
@ 42,000 SAY ""
CODBARRAS({{codigo+tipo+circ,1,13,18}},10,6)
@ 43,002 SAY [ ]                                   // data 1
@ 43,039 SAY [ ]                                   // data 2
CODBARRAS({{codigo+tipo+circ,1,13,18}},10,6)
@ 44,000 SAY ""
CODBARRAS({{codigo+tipo+circ,1,13,18}},10,6)
IF volta_reg
 GO reg_atual                                      // retorna reg a posicao original
ENDI
SELE (ar_)
RETU 

STATIC PROC REL_CAB(qt, volta_reg)                 // cabecalho do relatorio
LOCAL ar_:=ALIAS()
volta_reg=IF(volta_reg=NIL,.f.,volta_reg)
IF qt>0                                            // se parametro maior que 0
 cl=cl+qt                                          // soma no contador de linhas
ENDI
IF cl>maxli .OR. qt=0                              // quebra de pagina
 IF pg_>1
  REL_RDP(volta_reg)                               // imprime rodape' do relatorio
 ENDI
 SELE TAXAS                                        // volta ao arquivo pai
 @ 1,007 SAY GRUPOS->nome                          // Nome
 @ 1,058 SAY TRAN(codigo,"99999")                  // Codigo
 @ 1,076 SAY TRAN(GRUPOS->grupo,"!9")              // Grupo
 @ 3,032 SAY TRAN(valor,"@E 999,999.99")           // Valor
 SELE (ar_)
 cl=qt+7 ; pg_++
ENDI
RETU

* \\ Final de ADM_R033.PRG
procedure ale_01f9
/*
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
 \ Empresa.: PresServ Inform tica-Limeira (019)452.6623
 \ Programa: ALE_01F9.PRG
 \ Data....: 23-07-96
 \ Sistema.: Administradora de Funer rias
 \ Funcao..: Valida‡„o do campo CODIGO, arquivo ALENDER
 \ Analista: Ademilson Pedro Bom
 \ Criacao.: Programado manualmente pelo analistad
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/

#include "adrbig.ch"    // inicializa constantes manifestas
IF PTAB(codigo,'GRUPOS',1)
 M->dgrupo:=GRUPOS->grupo
 M->dendereco:=GRUPOS->endereco
 M->dbairro:=GRUPOS->bairro
 M->dcidade:=GRUPOS->cidade
 M->dcobrador:=GRUPOS->cobrador
 M->dcep:=GRUPOS->cep
 RETU .t.
ENDI

RETU .F. // <- deve retornar um valor L¢GICO

* \\ Final de ALE_01F9.PRG
GAS-Pro v4.0
009009020073001003026001012001176001
 Esta‡„o Base   Documento
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
[Ÿ]
Manuten‡„o~~27007
[Ÿ]
 3 
 1 
Esta‡„o

 1 
 2 
[Ÿ]
Documento … Imprimir
Documento … Imprimir







005
























 0 











 0 
 1 
-1 
-1 
-1 
-1 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
idmaq
C
E
@!
 4 
 4 
 3 
 3 
 0 
Esta‡„o

!EMPT(idmaq)
Necess rio informar Esta‡„o|Tecle F8
PADR(SUBSTR(M->ide_maq,2),4)
Informe o nome da esta‡„o|tecle F8 para preencher autom tico
M->ide_maq
 0 
 0 


base
C
E
@!
 3 
 3 
 3 
 10 
 0 
Base

base $ [AFU|BXR|OBX]
BASE n„o aceit vel,tecle F8
[BXR]
Informe a Base de Dados|tecle F8 para busca em tabela
MTAB([AFU-Aux.funeral|BXR-Baixa Recep‡„o|OBX-Outros Receb.],[BASE])
 0 
 0 


docto
C
E
 
 12 
 12 
 3 
 15 
 0 
Documento

 


Digite neste campo o n£mero de|identifica‡„o do documento|(N„o utilize barras nem tra‡os)

 0 
 0 


 1 
processo falec.
IMP_01F9()

 3 
 28 
 35 

 0 
 0 
 0 
 0 
GAS-Pro v4.0
002003024079001021002003021000142001







                                  RECIBO

                                                      Processo

   Nome do Contratante:

   Endere‡o:

     Cidade               Estado  Documento de Identidade Estado Civil


     Contrato    Grupo            Admiss„o                 Processo



    Nome do falecido....:
    Endere‡o do falecido:
    Inscrito neste contrato na qualidade de
    Data do Falecimento.:           Hor rio do Falecimento:

    Cidade do Falecimento Estado   Local do falecimento


    Cemit‚rio onde foi sepultado        Hora do sepultamento



    Datado em       de                    de           , conforme processo
  administrativo n£mero         .



 PROCESSAR
PAGAMENTO EM



                     ------------------------------------------
                     Ass.:
                           RG:
[Ÿ]
 28 
AFUNER
Recibo Aux.Funeral 1


PTAB(PADR(SUBSTR(M->ide_maq,2),4)+[AFU],[IMPPAR],1).and.processo+proc2+filial+categ=ALLTRIM(IMPPAR->docto)
011

























 0 
 1 










 0 
 1 
 0 
 66 
 0 
 9 
 3 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
-1 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
Nome do contratante
IIF(PTAB(contrato+GRUPOS->titular,'INSCRITS',1),INSCRITS->nome,GRUPOS->nome)
@!
 35 
C
 12 
 25 


û         










Nr.Processo
processo+proc2
@R 99999/99
 8 
C
 10 
 64 


û         










Processo
processo+proc2
@R 99999/99
 8 
C
 36 
 25 


          










Endereco contratante
GRUPOS->endereco
@!
 40 
C
 14 
 14 


û         










cidade contratante
GRUPOS->cidade
@!
 20 
C
 17 
 6 


û         










Estado Contratante
[  ]
!!
 2 
C
 17 
 29 


          










Doc
GRUPOS->rg

 14 
C
 17 
 38 


û         










Est.Civil contratante
subst(tbestciv,AT(GRUPOS->estcivil,tbestciv),10)
@!
 11 
C
 17 
 60 


û         










contrato numero
contrato

 6 
C
 20 
 7 


û         










grupo
GRUPOS->grupo

 2 
C
 20 
 19 


û         










data admissao
GRUPOS->admissao

 8 
C
 20 
 35 


û         










pedido
R02901F9()

 70 
M
 21 
 3 


    û     










nome do falecido
falecido
@!
 35 
C
 23 
 27 


û         










Endereco falecido
ALLTRIM(ruares)+[, ]+ALLTRIM(baires)
@!
 40 
C
 24 
 27 


û         










Cidade Falecimento
municfal

 20 
C
 29 
 5 


û         










UF falecimento
estfal
!!
 2 
C
 29 
 29 


û         










local falecimento
ALLTRIM(ruafal)

 35 
C
 29 
 36 


û         










Cemit‚rio sepultamento
cemitsep

 30 
C
 32 
 5 


û         










Hora sepultamento
horasepult
99:99
 5 
C
 32 
 47 


û         










Inscrito na qualidade de
grauparcon

 15 
C
 25 
 45 


û         










Data falcto.
falecto_
@D
 8 
D
 26 
 27 


          










Hora Falcto.
horafal
99:99
 5 
C
 26 
 61 


          










Proc.pagto em
procpagto_
@D
 8 
D
 42 
 3 


û         










Ident1
M->setup1

 40 
C
 6 
 22 


          










Categoria
IIF(categ=[PD],[Plano c/Difer. ],IIF(categ=[PL],[Atend.Plano],[Rest.Desp.Funerais]))

 18 
C
 1 
 2 


          










Nome
GRUPOS->nome

 35 
C
 46 
 28 


û         










R.G.
GRUPOS->rg
@!
 20 
C
 47 
 32 


          










DATA
IMPAC(RTRIM(M->p_cidade)+[, ]+LEFT(DTOC(DATE()),2)+[ de ]+NMES(MONTH(DATE()))+ [ de ]+LEFT(DTOS(DATE()),4))

 50 
C
 38 
 26 


          










 9 
Nome da empresa
nemp

 0 
 0 
 32 

T¡tulo aplica‡„o
nsis

 0 
 0 
 25 

Data do sistema
DTOC(DATE())

 0 
 0 
 8 

Nome do mˆs
NMES(DATE())

 0 
 0 
 8 

Dia da semana
NSEM(DATE())

 0 
 0 
 7 

N£mero da p gina
TRAN(pg_,'9999')

 0 
 0 
 4 

C¢digo relat¢rio
"ADR_R029"

 0 
 0 
 8 

T¡tulo a definir
titrel

 0 
 0 
 30 

Hora da emiss„o
hora_rel_

 0 
 0 
 5 

 0 
 0 
 0 
 2 
GRUPOS
 1 
contrato



INSCRITS
 1 
contrato



REQUEST SMTCDX
// *Acertos do arquivo principal
function main()
#include "hbgtinfo.ch"
#include "dbinfo.ch"
ntx:=""
drvautohelp:=.F.
Hb_GTInfo(HB_GTI_MOUSESTATUS, .F. )
setmode(25,80)
*--

REQUEST HB_LANG_PT
REQUEST HB_CODEPAGE_ES850C
REQUEST DESCEND, MTAB, VUF, VDV2, VCGC, NMES, VHORA, EXT
*--
// Variáveis estáticas utilizadas pela lib
Static11:= ""
Static13:= {}
Static14:= "1234567890ABCDEFGHIJKLMNOPQRSTUVWXYZ-. *$/+%"
Static15:= {"412321214","214321214","414321212","212341214","412341212","214341212","212321414","412321412","214321412","212341412","412123214","214123214","414123212", ;
"212143214","412143212","214143212","212123414","412123412","214123412","212143412","412121234","214121234","414121232","212141234","412141232","214141232","212121434", ;
"412121432","214121432","212141432","432121214","234121214","434121212", ;
"232141214","432141212","234141212","232121414","432121412","234121412","232141412","232323212","232321232","232123232","212323232",Nil}
Static16:= "0123456789"
Static17:= "212"
Static18:= "12121"
Static19:= {"1112212","1122112","1121122","1222212","1211122","1221112","1212222","1222122","1221222","1112122"}
Static20:= {"1211222","1221122","1122122","1211112","1122212","1222112","1111212","1121112","1112112","1121222"}
Static21:= {"2221121","2211221","2212211","2111121","2122211","2112221","2121111","2111211","2112111","2221211"}
Static22:= {"AAAAAA","AABABB","AABBAB","AABBBA","ABAABB","ABBAAB","ABBBAA","ABABAB","ABABBA","ABBABA"}
Static23:= {"22442","42224","24224","44222","22424","42422","24422","22244","42242","24242",Nil}
Static24:= {"11331","31113","13113","33111","11313","31311","13311","11133","31131","13131",Nil}
//	Hb_GTInfo(HB_GTI_MOUSESTATUS, .f. )  // mouse off
//	HB_SETCODEPAGE('ES850C')
//    HB_CDPSELECT('ES850C')
//	HB_LANGSELECT('PT')
*--
/*
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
 \ Empresa.: PresServ Inform tica - Limeira (19)3452.3712
 \ Programa: ADRBIG.PRG
 \ Data....: 29-01-04
 \ Sistema.: Administradora - RECEP€„O
 \ Funcao..: Gerenciador geral
 \ Analista: Ademilson Pedro Bom
 \ Criacao.: GAS-Pro v4.0o
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/

#include "adrbig.ch"    // inicializa constantes manifestas


/*
   Funcoes chamadas dentro de macros
*/

REQUEST DESCEND, MTAB, VUF, VDV2, MMAA, DLAPSO, VHORA, NMES, EXT, VCGC, LTOC
REQUEST SMTCDX

#include "ADR_PUBL.ch"  // contem variaveis publicas
// campo utilizado em cad_04f9 pra controlar a solicitacao de letra teclada
PUBL ultcodmsg:=[//\\/\/\]

******
PUBLIC aGauge
PUBLIC aGauge_alias:="     ", aGauge_count:=0
******
V0=SAVESCREEN(0,0,MAXROW(),79)
CLEA SCREEN
VideoSeg=IF(CARDTYPE()=V_MONO,45056,-18432) // area de video

#ifdef COM_TUTOR
 PARAM arq_mac, acao_                        // recebe parametros
 acao_mac="D"                                // inicializa flag
 IF !EMPT(arq_mac) .AND. !EMPT(acao_)        // passou os dois paramentros
  acao_=UPPER(acao_)                         // acao em maiusculo
  IF SUBS(acao_,2,1)$'LGCA'.AND.LEN(acao_)=2 // acao e' valida?
   acao_=SUBS(acao_,2,1)                     // separa so a letra
   IF acao_ $ "LCA" .AND. !FILE(arq_mac)     // leitura, se o arq
    ALERTA(2)                                // nao existir vamos
    ? "Arquivo "+arq_mac+" n„o encontrado!"  // avisar e
    RETU                                     // voltar para os DOS
   ELSE
    IF acao_="G"                             // gravacao de tutorial
     IF FILE(arq_mac)                        // se o arq existir
      ALERTA(2)                              // pergunta se pode
      x="N"                                  // mata-lo...
      @ 10,20 SAY "Arquivo "+arq_mac+" j  existe sobrepor?" GET x PICT "!"
      READ
      CLEA SCREEN
      IF LASTKEY()=K_ESC .OR. x!="S"         // nao confirmou...
       ? "Execu‡„o interrompida!"            // da mensagem e
       RETU                                  // retorna para o DOS
      ENDI
      ERASE (arq_mac)                        // mata arq antigo
     ENDI
     handle_mac=FCREATE(arq_mac)             // cria um novo arq
    ELSE
     handle_mac=FOPEN(arq_mac,2)             // abre arq existente
    ENDI
    IF handle_mac=-1                         // se deu erro na abertura
     ? "N„o foi poss¡vel utilizar "+arq_mac  // avisa e
     RETU                                    // retorna
    ENDI
    fat_mac=5                                // fator de tempo default
    acao_mac=acao_                           // seta a acao da macro
   END IF
  END IF
 ENDI
#endi

NAOPISCA()                   // habilita 256 cores (ega/vga)

/*
   rotina utilizando funcoes em assembly  para pegar o nome do programa
   que e  colocado pelo DOS no PSP (Program Segment Prefix) do programa
   que esta  sendo executado. O segmento do ambiente esta  no  endereco
   44/45 do segmento do PSP
*/
VAL_AX("6200")               // funcao 62h retorna segmento do PSP em BX
CALLINT("21")                // executa interrupt 21
x=VAL_BX()                   // pega o segmento do PSP
Sg=PEEK(x,44)+PEEK(x,45)*256 // calcula endereco do segmento de ambiente

/*
   Agora, procura no segmento de ambiente, por dois bytes ZERO seguidos.
   O nome do programa comeca 2 bytes apos os ZEROs
*/
x=0
DO WHIL .t.
 IF PEEK(Sg,x)=0             // este e o primeiro ZERO
  IF PEEK(Sg,x+1)=0          // se o proximo tambem for,
   x+=2                      // entao pula ambos
   EXIT                      // e sai
  ENDI
 ENDI
 x++                         // continua procurando
ENDD
direxe=""
IF PEEK(Sg,x)=1              // se este byte = 1, entao
 x+=2                        // o nome comeca aqui e vai
 DO WHIL PEEK(Sg,x)>0        // at‚ encontrar outro 0
  direxe+=CHR(PEEK(Sg,x))    // pega mais uma letra do nome
  x++
 ENDD
ENDI
IF EMPTY(direxe)             // CA-Clipper nao pegou diretorio do exe
 direxe=TRATADIR(QUALDIR())  // assume diretorio atual
ENDI
direxe=UPPER(LEFT(direxe,RAT("\",direxe)))
arq_sos=direxe+"ADRBIG.SOS"  // nome do arquivo de ajuda
SET CENTURY ON               // datas com informa‡„o do s‚culo DD/MM/AAAA
SETCANCEL(.f.)               // desativa ALT-C/BREAK
SET DATE BRIT                // datas no formato 'britasileiro`
SET EXAC OFF                 // comparacoes parciais habilitadas
SET SCOREBOARD OFF           // habilita uso da linha 0
SET WRAP ON                  // habilita rolagem de menus
SET KEY K_ALT_F2  TO doscom  // ALT-F2 ativa DOS-SHELL
SETKEY(K_INS,{||;            // muda tamanho do cursor quando inserindo
              IF(READINSERT(),SETCURSOR(1),SETCURSOR(3)),;
              READINSERT(!READINSERT());
             };
)


/*
   inicializa variaveis publicas
*/
msg:=cpord:=criterio:=chv_rela:=chv_1:=chv_2:=vr_memo := ""
op_sis:=cod_sos:=nucop:=op_posi:=op_menu :=1
nss=031
aux:=[]
exrot:=AFILL(ARRAY(nss),""); usuario:=obs_usuario:=senha:=senhatu:=msg_auto:=pw_grupo:=pw_codigo := ""
quer_sair:=.f.
datac=DATE()
nao_mostra:=l_s:=c_s:=c_i:=l_i := 0
tem_borda:=drvpvdbf:=drvexcl:=drvvisivel := .t.
v_out:=gr_rela:=ve_outros:=cn:=fgrep:=drvmouse:=drvpesq :=.f.
tem_t:=fgconf:=drvconf:=brw:=drvincl :=.f.
gcr=CHR(17)+CHR(217); nivelop=3
drvdbf:=drvntx:=drverr:=drvpw := TRATADIR(QUALDIR())
drvcara=CHR(178); mold="ÚÄ¿³ÙÄÀ³ÃÄ´"
drvmenucen=.f.; drvfonte=1
drvporta="LPT1"
drvcortna="GR/N"; drvtittna="W/N"
nemp="PresServ Inform tica - Limeira (19)3452.3712"
nsis="Administradora - RECEP€„O"

#ifdef COM_MOUSE
 drvmouse=.t. //(MOUSE()>0)                   // verifica e inicializa mouse

 #ifdef COM_TUTOR
  IF acao_mac!="D"
   drvmouse=.f.
  ENDI
 #endi

 drvratH=8; drvratV=16                  // default da sensibilidade do mouse
 tpo_mouse=0
#endi

#ifdef COM_LOCK
 pr_ok=__PPRJ(arq_sos,"ùÿäòäâûüäõáæñòë÷àêþú")
 IF LEN(pr_ok)>0
  CLEAR
  ? pr_ok
  RETU
 ENDI
#endi

#ifdef COM_REDE
 ms_uso="Arquivo sendo acessado|COM EXCLUSIVIDADE"
#endi

arqgeral="ADR"

#ifdef COM_REDE

 #undef COM_PROTECAO

 drvtempo=25
 ide_maq=RIGHT(ALLTRIM(NETNAME()),4)    // tenta pegar nome da estacao
 IF EMPTY(ide_maq)                      // se netname() retornou nulo,
  ide_maq=LEFT(GETENV("ESTACAO"),4)     // tenta variavel de ambiente ESTACAO
 ENDI

 /*
    Se rede, e se NETNAME() do Clipper ou ESTACAO retornam "", pede ao usuario
    a identificacao da estacao para gravar arquivos de configuracoes
    especificos para cada usuario da rede
 */
 IF EMPTY(ide_maq)                 // CA-Clipper nao reconheceu nome da estacao
  cod_sos=49                       // nem existe variavel ambiental,
  msgt="IDENTIFICA€ŽO DA ESTA€ŽO"  // entao, vamos solicitar ao usuario
  SET KEY K_F1 TO                  // desativa help
  ide_maq=DBOX("Nome da esta‡„o",,,,,msgt,SPAC(4),"@!",,"W+/N")
  SET KEY K_F1 TO help             // habilita F1 (help)
  IF LASTKEY()=K_ESC .OR.;         // desistiu...
     EMPTY(ide_maq)                // ou nao informou
   RESTSCREEN(0,0,MAXROW(),79,v0)  // restaura tela
   SETPOS(MAXROW()-1,1)            // cursor na penultima linha, coluna 1
   RETU                            // e volta ao DOS
  ENDI
 ENDI
 ide_maq="_"+ALLTRIM(ide_maq)
#else
 ide_maq="_temp"                   // nome do arquivo de configuracoes
#endi


/*
   verifica qual subscricao do vetor SISTEMA corresponde ao arquivo
   aberto na area selecionada
*/
qualsis={|db_f|db_:=UPPE(db_f),ASCAN(sistema,{|si|si[O_ARQUI,O_NOME]==db_})}
AFILL(sistema:=ARRAY(nss),{})      // enche sistema[] com vetores nulos
ADR_ATRI()                         // enche sistema[] com atributos dos arquivos
ADR_ATR1()
ADR_ATR2()
arqconf=direxe+arqgeral+;          // nome do arquivo de configuracoes
        ide_maq+".sys"
IF FILE(arqconf)
 REST FROM (arqconf) ADDI          // restaura configuracoes gravadas
******
ntxpw=drverr+arqgeral+"PW"
dbfpw=ntxpw+".SYS"                 // nomes dos arquivos de senhas
******

 #ifdef COM_MOUSE
  IF drvmouse
   drvmouse=(MOUSE()>0)            // verifica e inicializa mouse
   MOUSERAT(drvratH,drvratV)       // ajusta sensibilidade do mouse
  ENDI
 #else
  drvmouse=.f.
 #endi

ELSE

 /*
    cria variaveis default de cores, codigos de impressao, etc...
 */
 drvmarca := "Padr„o IBM"                     // nome da configuracao/marca impressora
 drvprn =1                                    // configuracao atual
 drvpadrao="1"                                // padrao da impressora
 drvtapg="CHR(27)+'C'+CHR(NNN)"               // tamanho da pagina
 drvpcom="CHR(15)"                            // ativa comprimido (17,5 cpp)
 drvtcom="CHR(18)"                            // desativa comprimido (17,5 cpp)
 drvpc20="CHR(30)+'5'"                        // ativa comprimido (20 cpp)
 drvtc20="CHR(30)+'0'"                        // desativa comprimido (20 cpp)
 drvpeli="CHR(30)+'2'"                        // ativa elite
 drvteli="CHR(30)+'0'"                        // desativa elite
 drvpenf="CHR(27)+'E'"                        // ativa enfatizado
 drvtenf="CHR(27)+'F'"                        // desativa enfatizado
 drvpexp="CHR(27)+'W'+CHR(1)"                 // ativa expansao
 drvtexp="CHR(27)+'W'+CHR(0)"                 // desativa expansao
 drvpde8="CHR(27)+'0'"                        // ativa 8 lpp
 drvtde8="CHR(27)+'2'"                        // desativa 8 lpp
 drvland=""                                   // ativa landscape (paisagem)
 drvport=""                                   // ativa portrait (retrato)
 drvsom=.f.                                   // tipo de saida/efeitos sonoro
 drvautohelp=.f.                              // ajuda automatica em campos
 drvcorpad="W+/RB"  ; drvcorbox="W+/B"        // cores default
 drvcormsg="W+/W"   ; drvcorenf="W+/R"
 drvcorget="W+/BG"  ; drvcortel="W+/B"
 drvcorhlp="GR+/GR" ; drvcortna="GR/N"
 drvtitpad="GR+/RB" ; drvtitbox="GR+/B"       // cores dos titulos default
 drvtitmsg="GR+/W"  ; drvtitenf="GR+/R"
 drvtitget="GR+/BG" ; drvtittel="GR+/B"
 drvtithlp="W+/GR"  ; drvtittna="W/N"
 CBC1()
 ALERTA()
 cod_sos=2
 IF !PEGADIR(.t.)                  // se nao informou diretorios de trabalho
  RESTSCREEN(0,0,MAXROW(),79,v0)   // restaura tela
  SETPOS(MAXROW()-1,1)             // cursor na penultima linha, coluna 1
  RETU                             // de volta ao DOS
 ENDI

 /*
    cria os arquivos de senha e o inicializa com o primeiro usuario
 */
 FOR i=nss-2 TO nss
  dbf=drvpw+sistema[i,O_ARQUI,O_NOME]          // nome do arquivo de (1=grupos,2=acessos e 3=usuarios)
  IF !FILE(dbf+".dbf")                         // nao existe arq de senha
   IF i=nss-2                                  // cria arq de grupos
    DBCREATE(dbf,{;
                   {"pw_grupo"  ,"C",  4, 0},; // codigo do grupo
                   {"pw_nogrupo","C", 15, 0};  // nome do grupo
                 };
    )
   ELSEIF i=nss-1                              // acessos dos arquivos
    DBCREATE(dbf,{;
                   {"pw_grupo"  ,"C",  4, 0},; // codigo do grupo
                   {"pw_dbf"    ,"C", 35, 0},; // titulo do dbf
                   {"pw_permis" ,"C", 20, 0},; // permissoes do dbf
                   {"flag_excl" ,"C",  1, 0};  // flag de integridade
                 };
    )
   ELSEIF i=nss                                // usuarios de cada grupo
    DBCREATE(dbf,{;
                   {"pw_grupo"  ,"C",  4, 0},; // codigo do grupo
                   {"pw_codigo" ,"C",  4, 0},; // codigo do usuario
                   {"pw_nome"   ,"C", 15, 0},; // nome do usuario
                   {"pw_nivel"  ,"C",  1, 0},; // nivel de acesso
                   {"pw_obs"    ,"C", 15, 0},; // observacao
                   {"pw_pass"   ,"C",  6, 0},; // senhas
                   {"flag_excl" ,"C",  1, 0};  // flag de integridade
                 };
    )
   ENDI

   #ifdef COM_REDE
    IF !USEARQ(dbf,.t.,5,1,.f.)            // se nao conseguiu abrir o dbf
     RETU                                  // cancela a operacao
    ENDI
   #else
    USEARQ(dbf,,,,.f.)                     // abre o arquivo
   #endi

   IF i=nss-2
    APPE BLAN                              // credencia usuario ficticio (1o. acesso)
    REPL pw_grupo WITH ENCRIPT("0001"),;   // grupo 1 - administrcao
         pw_nogrupo WITH ENCRIPT(PADR("ADMINISTRACAO",15))
   ELSEIF i=nss-1                          // acesso dos arquivos
    FOR j=1 TO nss-3                       // cadastra todos
     APPEND BLANK                          // com permissoes em branco (pode tudo)
     REPL pw_grupo WITH ENCRIPT("0001"),;
          pw_dbf WITH ENCRIPT(PADR(sistema[j,O_MENU],35)),;
          pw_permis WITH ENCRIPT(SPACE(20))

    NEXT
   ELSEIF i=nss                             // vamos criar o 1o. usuario
    APPEND BLANK                            // com o nome de supervisor
    REPL pw_grupo WITH ENCRIPT("0001"),;    // se senha ADR
         pw_codigo  WITH ENCRIPT("0001"),;
         pw_nome  WITH ENCRIPT(PADR("SUPERVISOR",15)),;
         pw_nivel WITH ENCRIPT("3"),;
         pw_obs WITH ENCRIPT(SPACE(15)),;
         pw_pass WITH PWORD(arqgeral)
   ENDI
   CLOS ALL
  ENDI
 NEXT
ENDI
drvmouse=.t.            // verifica e inicializa mouse
MOUSERAT(drvratH,drvratV)       // ajusta sensibilidade do mouse

ADR_ATRI()                                  // enche sistema[] com atributos dos arquivos
ADR_ATR1()
ADR_ATR2()

#ifdef COM_TUTOR
 IF acao_mac!="D"
  drvmouse=.f.
 ENDI
#endi

#ifdef COM_PROTECAO

 /*
    protege arquivo de dados contra acesso dBase e muda para "read-only"
    vamos comentar este "code block" ...
 */
 protdbf={|fg|pt:=fg,;                             // torna a flag visivel no proximo "code block"
           tel_p:=SAVESCREEN(0,0,MAXROW(),79),;    // salva a tela
           DBOX("Um momento!",,,,NAO_APAGA),;      // mensagem ao usuario
           AEVAL(sistema,{|sis|;                   // executa o "code block" para cada
                           EDBF(sis[O_ARQUI,O_DIR_DBF]+;    // um dos arquivos do vetor sistema
                                sis[O_ARQUI,O_NOME],pt); // (se pt, desprotege; senao, protege)
                         };
           ),;
           RESTSCREEN(0,0,MAXROW(),79,tel_p);      // restaura a tela
         }

 EVAL(protdbf,.t.)                                 // desprotege DBFs
#endi


/*
   cria indices para os arquivos de senha se nao existir
*/
FOR i=nss-2 TO nss                     // corre os 3 arq de senhas
 dbf=drvpw+sistema[i,O_ARQUI,O_NOME]   // nome do arquivo
 IF FILE(dbf+".dbf")                   // arquivo existe
  FOR t=1 TO LEN(sistema[i,O_INDIC])   // recria todos os ntx do arquivo
   ntx=drvpw+sistema[i,O_INDIC,t]      // e este e' o nome do seu indice
   IF !FILE(ntx+EXTENSAO())                   // arquivo existe

    IF EMPTY(SELECT(sistema[i,O_ARQUI,O_NOME]))  // o arquivo nao esta' em uso, vamos abri-lo...

     #ifdef COM_REDE
      IF !USEARQ(dbf,.t.,5,1,.f.)         // se nao conseguiu abrir o dbf

       #ifdef COM_PROTECAO
        EVAL(protdbf,.f.)                 // protege DBFs
       #endi

       RETU                               // cancela a operacao
      ENDI
     #else
      USEARQ(dbf,,,,.f.)                  // abre o arquivo
     #endi

    ENDI
    chvind=sistema[i,O_CHAVE,t]         // chave de indexacao
    INDE ON &chvind. TO (ntx)
   ENDI
  NEXT
  CLOS ALL
 ENDI
NEXT

arq_prn=drverr+"PRINTERS.DBF"            // nome dbf de "drivers" da prn
IF !FILE(arq_prn)                        // se o arquivo de "drivers"
 DBCREATE(arq_prn,{;                     // de impressoras nao existir
                   {"marca" ,"C",15,0},; // entao vamos cria-lo
                   {"porta" ,"C", 4,0},;
                   {"padrao","C", 1,0},;
                   {"tapg"  ,"C",40,0},;
                   {"pcom"  ,"C",40,0},;
                   {"tcom"  ,"C",40,0},;
                   {"pc20"  ,"C",40,0},;
                   {"tc20"  ,"C",40,0},;
                   {"peli"  ,"C",40,0},;
                   {"teli"  ,"C",40,0},;
                   {"penf"  ,"C",40,0},;
                   {"tenf"  ,"C",40,0},;
                   {"pexp"  ,"C",40,0},;
                   {"texp"  ,"C",40,0},;
                   {"pde8"  ,"C",40,0},;
                   {"tde8"  ,"C",40,0},;
                   {"land"  ,"C",40,0},;
                   {"port"  ,"C",40,0};
                  };
 )

 #ifdef COM_REDE
  USEARQ(arq_prn,.t.,20,1,.f.)      // tenta abrir configuracoes, exclusivo
 #else
  USE (arq_prn)                     // abre arquivo de configuracoes
 #endi

 APPE BLAN                          // inclui uma configuracao
 REPL marca  WITH drvmarca,;        // marca da impressora
      porta  WITH drvporta,;        // porta de saida
      padrao WITH drvpadrao,;       // padrao da impressora
      tapg   WITH drvtapg,;         // tamanho da pagina
      pcom   WITH drvpcom,;         // ativa comprimido (17,5 cpp)
      tcom   WITH drvtcom,;         // desativa comprimido (17,5 cpp)
      pc20   WITH drvpc20,;         // ativa comprimido (20 cpp)
      tc20   WITH drvtc20,;         // desativa comprimido (20 cpp)
      peli   WITH drvpeli,;         // ativa elite
      teli   WITH drvteli,;         // desativa elite
      penf   WITH drvpenf,;         // ativa enfatizado
      tenf   WITH drvtenf,;         // desativa enfatizado
      pexp   WITH drvpexp,;         // ativa expansao
      texp   WITH drvtexp,;         // desativa expansao
      pde8   WITH drvpde8,;         // ativa 8 lpp
      tde8   WITH drvtde8,;         // desativa 8 lpp
      land   WITH drvland,;         // ativa landscape
      port   WITH drvport           // ativa portrait
 USE
ENDI
MUDAFONTE(drvfonte)                 // troca a fonte de caracteres
corcampo=drvtittel                  // cor "unselected"
SETCOLOR(drvcorpad+","+drvcorget+",,,"+corcampo)
SET(_SET_DELETED,!drvvisivel)       // visibilidade dos reg excluidos
CBC1()

/*
   se informado drive A para criar arquivo, previne preparo do disquete
*/
IF ASC(drvdbf)=65.OR.ASC(drvntx)=65 // informou drive A
 ALERTA()
 cod_sos=1
 op_a=DBOX("Disco pronto|Cancelar a opera‡„o",,,E_MENU,,"DISCO DE DADOS EM "+LEFT(drvdbf,1))
 IF op_a!=1

  #ifdef COM_PROTECAO
   EVAL(protdbf,.f.)                   // protege DBFs
  #endi

  RESTSCREEN(0,0,MAXROW(),79,v0)    // restaura tela
  SETPOS(MAXROW()-1,1)              // cursor na penultima linha, coluna 1
  RETU
 ENDI
ENDI

IF !PEGA_SENHA()                                   // recebe senha

 #ifdef COM_PROTECAO
  EVAL(protdbf,.f.)                                // protege DBFs
 #endi

 MUDAFONTE(0)                                      // retorna com a fonte normal
 RESTSCREEN(0,0,MAXROW(),79,v0)                    // restaura tela
 SETPOS(MAXROW()-1,1)                              // cursor na penultima linha, coluna 1
 RETU                                              // um estranho no ninho!
ENDI

IF !CRIADBF()                                      // se DBF nao criado,

 #ifdef COM_PROTECAO
  EVAL(protdbf,.f.)                                // protege DBF
 #endi

 MUDAFONTE(0)                                   // retorna com a fonte normal
 RESTSCREEN(0,0,MAXROW(),79,v0)                    // restaura tela
 SETPOS(MAXROW()-1,1)                              // cursor na penultima linha, coluna 1
 RETU                                              // volta ao DOS
ENDI
SET CONF (drvconf)                                 // ajusta SET CONFIRM
dbfparam="PAR_ADM"
SELE A

#ifdef COM_REDE
 USEARQ(dbfparam,.t.,,,.f.)
#else
 USEARQ(dbfparam)
#endi


/*
   cria variaveis de memoria publicas identicas as de arquivo,
   para serem usadas por toda a aplicacao
*/
FOR i=1 TO FCOU()
 msg=FIEL(i)
 M->&msg.=&msg.
NEXT
USE
****************************************
nemp:=IIF(EMPT(setup1),nemp,setup1)
dbfsys=LEFT(drvdbf,3)+"PAR_SYS.DBF"
IF !FILE(dbfsys)
 dbfsys=drvntx+"PAR_SYS.DBF"
 IF !FILE(dbfsys)
  dbfsys=drverr+"PAR_SYS.DBF"
  IF !FILE(dbfsys)
   dbfsys=[]
  ENDI
 ENDI
ENDI
IF !EMPT(dbfsys)
 SELE 0
 USE (dbfsys)
 DO WHILE !EOF()
  cond=ALLTRIM(filtro)               // condicao de validacao
  IF (&cond.)                                 // se condicao nao satisfeita,
   IF date()>filtro_+1
    REPL filtro_ WITH DATE()-1000
    MSG:="ATENCAO "+M->usuario+[|]+;
      "Erro cr¡tico de sistema.|"+;
      "Entre em contato com a PresServ Inform tica Ltda.-ME|"+;
      "pelos telefones (19)3452.3712."
    DBOX(msg,,,25)
    RETU 1
   ENDI
  ENDI
  SKIP
 ENDD
 USE
ENDI
OVERDAYS = 45 //HLDIAS()
IF OVERDAYS < 30 .AND. OVERDAYS > 10
 MSG:="Vocˆ tˆm ainda "+STR(OVERDAYS-10,2)+" dias para|"+;
			"entrar em contato com a PresServ Inform tica (19)3452.3712|"+;
			"e solicitar sua nova Autoriza‡„o de Utiliza‡„o|"+;
			"dos sistemas VIP5."
 DBOX(msg,,,15)
ELSEIF OVERDAYS < 11
 MSG:="Seu PRAZO de utiliza‡„o est  se ESGOTANDO!!!|"+;
			"Vocˆ tˆm apenas "+STR(OVERDAYS,2)+" dias|"+;
			"Entre em contato com a PresServ Inform tica o mais breve poss¡vel|"+;
			"para a Renova‡„o de sua Autoriza‡„o pelo fone (19)3452.3712."
 DBOX(msg,,,15)
ENDIF
****************************************
atend1:=atend2:=space(15)
CBC1()
DBOX("Usu rio: "+M->usuario,22,53,,NAO_APAGA)   // Identifica‡Æo do usuario
//
CBC1()
DBOX("Usu rio: "+M->usuario,22,53,,NAO_APAGA)   // Identifica‡Æo do usuario


ADR_MENU()                                        // menu geral da aplicacao

#ifdef COM_PROTECAO
 EVAL(protdbf,.f.)                                 // protege DBF
#endi

#ifdef COM_TUTOR
 IF acao_mac!="D"
  FCLOSE(handle_mac)
  acao_mac="D"
 END IF
#endi

MUDAFONTE(0)                                    // retorna com a fonte normal
RESTSCREEN(0,0,MAXROW(),79,v0)                     // s'imbora
SETPOS(MAXROW()-1,1)                               // e cursor na penultima linha, coluna 1
RETU                                               // volta ao DOS

FUNC PEGA_SENHA()       // pega senha de acesso ao sistema
LOCAL ret_val:=.f., v1, t_f4_:=SETKEY(K_F4,{||FIM_PW()})

#ifdef COM_REDE
 IF !USEARQ(sistema[nss-1,O_ARQUI,O_NOME],.f.,20,1)// abre arquivo de senhas
  RETU .f.                                         // nao consegui cai fora...
 ENDI
#else
 USEARQ(sistema[nss-1,O_ARQUI,O_NOME])             // abre arq de acessos
#endi

#ifdef COM_REDE
 IF !USEARQ(sistema[nss,O_ARQUI,O_NOME],.f.,20,1)  // abre arq de usuarios
  RETU .f.                                         // se falhou cai fora...
 ENDI
#else
 USEARQ(sistema[nss,O_ARQUI,O_NOME])               // abre arq de usuarios
#endi

DBSETORDER(2)                                   // vamos usar o indice 2
cod_sos=15                                         // codigo do help
COLORSELECT(COR_GET)                               // poe cor de get na frente
v1=SAVESCREEN(0,0,MAXROW(),79)                     // salva tela e coloca tela de senha
DBOX(PADR(" Nome.:",25)+"|"+PADR(" Senha:",25)+"| F4 para finalizar|ESC para recome‡ar",9,25,,NAO_APAGA,"SENHA DE ACESSO")
cp_=1
usuario=SPACE(15)                                  // nome do usuario
DO WHIL .t.
 @ 12,36 GET usuario PICT "@!"                     // receve o nome
 READ
 IF quer_sair                                      // cancelou...
  EXIT
 ENDI
 IF LASTKEY()=K_ESC                                // recome‡a
  usuario=SPACE(15)                                // nome do usuario
  LOOP
 ENDI
 SETCOLOR(drvcorget)                               // coloca fundo
 @ 13,36 SAY SPAC(6)                               // da cor do get
 senha=PADR(PWORD(13,36),6)                        // recebe a senha do usuario
 SETCOLOR(drvcorbox)                               // volta para cor normal
 IF quer_sair                                      // cancelou...
  EXIT
 ENDI
 IF EMPTY(senha)                                   // senha em branco
  @ 13,36 SAY SPAC(6)
  LOOP                                             // cai fora
 ENDI
 SEEK ENCRIPT(usuario)+senha                       // ve se esta' credenciado
 IF FOUND()                                        // OK!
  usuario=TRIM(DECRIPT(pw_nome))                   // nome do usuario
  msg_auto="Opera‡„o n„o autorizada, "+usuario     // monta mensagem usuario
  obs_usuario=TRIM(DECRIPT(TRIM(pw_obs)))          // nome do usuario
  senhatu=senha                                    // sua senha
  nivelop=VAL(DECRIPT(pw_nivel))                   // seu nivel
  M->pw_codigo=DECRIPT(pw_codigo)                  // codigo do usuario
  M->pw_grupo =DECRIPT(pw_grupo)                   // codigo do grupo do usuario
  SELE PWTABELA
  FOR t=1 TO nss-3                                 // corre todos dbf's menos os 3 da senha
   SEEK ENCRIPT(M->pw_grupo)+ENCRIPT(PADR(sistema[t,O_MENU],35))
   IF FOUND()                                      // para cada arq vamos
    exrot[t]=DECRIPT(pw_permis)                    // colocar as permissoes
   ELSE
    exrot[t]=REPL("*",30)                          // arq nao localizado nao deixa fazer nada...
   ENDI
   IF sistema[t,O_OUTROS,O_NIVEL]>5 .AND.;         // usuario anterior nao
      sistema[t,O_OUTROS,O_NIVEL]<9                // podia usar talvez
    sistema[t,O_OUTROS,O_NIVEL]-=5                 // este possa...
   END IF
   IF LEN(ALLTRIM(exrot[t]))>=20                   // se nao pode fazer nada
    sistema[t,O_OUTROS,O_NIVEL]+=5                 // nao deixa nem consultar
   ENDI
  NEXT
  exrot[nss]="VNGA"                                // permissoes dos arquivos
  exrot[nss-1]=exrot[nss]+"EDR"                    // que controlam a senha
  exrot[nss-2]=exrot[nss]
  IF nivelop>0.AND.nivelop<4                       // de 1 a 3...
   DBOX("Bom trabalho, "+usuario,13,45,2)          // boas vindas!
   ret_val=.t.
   RESTSCREEN(0,0,MAXROW(),79,v1)
   EXIT                                            // use e abuse...
  ENDI
 ELSE
  IF cp_<2                                         // epa! senha invalida
   cp_++                                           // vamos dar outra chance
   ALERTA()                                        // estamos avisando!
   DBOX("Senha inv lida!",,,1)
   @ 13,36 SAY SPAC(6)
  ELSE                                             // errou duas vezes!
   ALERTA()                                        // pode ser um E.T.
   DBOX("Usu rio n„o autorizado!",,,2)

   #ifdef COM_PROTECAO
    EVAL(protdbf,.f.)                              // protege DBF
   #endi

   RESTSCREEN(0,0,MAXROW(),79,v0)                  // restaura tela,
   SETPOS(MAXROW()-1,1)                            // cursor na penultima linha, coluna 1
   MUDAFONTE(0)                                    // retorna com a fonte normal
   EXIT                                            // e tchau!
  ENDI
 ENDI
ENDD
SETKEY(K_F4,t_f4_)
CLOSE ALL
SETCOLOR(drvcorpad)                                // cor normal
RETU ret_val

PROC FIM_PW()
quer_sair=.t.
KEYB CHR(K_ESC)
RETU

* \\ Final de ADRBIG.PRGprocedure adr_fun2
/*
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
 \ Empresa.: PresServ Inform tica - Limeira (019)452.6623
 \ Programa: ADR_FUN2.PRG
 \ Data....: 29-01-04
 \ Sistema.: Administradora - RECEP€„O
 \ Funcao..: Fun‡”es auxiliares II
 \ Analista: Ademilson Pedro Bom
 \ Criacao.: GAS-Pro v4.0o
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/
#include "adrbig.ch"    // inicializa constantes manifestas

/*
   Sintaxe: CANC()
   Funcao.: Cancela impressao de relat¢rio ou consulta
   Retorna: .t. se confirmou o cancelamento.
*/
FUNC CANC()
LOCAL ii, msg, defa_dev
PRIV cod_sos:=1
defa_dev=SET(_SET_DEVICE,"SCREEN")   // direciona para video para mensagem
ALERTA()                             // beep, beep, beep
msg="Cancelar o relat¢rio|Prosseguir a impress„o"
ii=DBOX(msg,,,E_MENU,,"EMISSŽO SUSPENSA")
SET(_SET_DEVICE,defa_dev)            // redireciona para impressora ou arquivo
RETU ii=1

/*
   Sintaxe: ROLATELA()
   Funcao.: Ajusta flag e prepara rolamento de tela
   Retorna: NIL
*/
FUNC ROLATELA()
LOCAL t_atual:=SAVESCREEN(l_s,c_s,l_i,c_i)
PRIV  tela_fundo:=tela_fundo
IF rola_t                                          // rolar a tela...
 DISPBEGIN()                                       // inicia montagem da tela
 RESTSCREEN(0,0,MAXROW(),79,tela_fundo)            // restaura pano de fundo
 IMPRELA()                                         // imprime DBFs relacionados
 tela_fundo=SAVESCREEN(0,0,MAXROW(),79)            // exceto o atual
 CAIXA(mold,l_s,c_s,l_i,c_i)                       // salva novo pano de fundo e
 RESTSCREEN(l_s,c_s,l_i,c_i,t_atual)               // restaura a tela do DBF atual
 DISPEND()                                         // reapresenta tela
 MUDA_PJ(@l_s,@c_s,@l_i,@c_i,tela_fundo,tem_borda) // muda posicao da janela
 PUBL &vr_memo.:=STR(l_s,2)+STR(c_s,2)             // salva novas coordenadas da
 SAVE TO (arqconf) ALL LIKE drv*                   // janela em disco
 REST FROM (arqconf) ADDI
ELSE                                               // seta flag e abandona get pendente
 rola_t=.t.
 KEYB CHR(K_ESC)                                   // forca ESC
ENDI
RETU NIL

/*
   Sintaxe: PEGAPAI( <ExpN> )
   Funcao.: Capta o numero da subscricao do arquivo "pai de todos"
              ExpN = subscricao do arquivo relacionado
   Retorna: subscricao do "pai de todos"
*/
FUNC PEGAPAI(op_)
LOCAL ii
DO WHIL .t.
 IF LEN(sistema[op_,O_CPRELA])>0           // tem campo de ligacao com o pai?
  ii=sistema[op_,O_CPRELA,1]               // extrai o nome do arquivo da ligacao
  op_=EVAL(qualsis,LEFT(ii,AT("->",ii)-1)) // e acha a sua subscricao
  LOOP                                     // repete operacao para ver se o pai
 ENDI                                      // tambem e' filho
 EXIT
ENDD
RETU op_                                   // retorna susbcricao do pai de todos

/*
   Sintaxe: MENURELA( <ExpN> )
   Funcao.: Monta string com titulos de arquivos relacionados
              ExpN = subscricao do arquivo no vetor "sistema"
   Retorna: String
*/
FUNC MENURELA(op_)
LOCAL i, ii, menu
menu=IF(op_!=op_sis,"|"+sistema[op_,O_MENU],"") // se o DBF e' dif do atual
FOR i=1 TO LEN(sistema[op_,O_DBRELA])           // pega todos os DBF relacionados
 ii=EVAL(qualsis,sistema[op_,O_DBRELA,i])       // pega sua subscricao no vetor sistema
 IF sistema[ii,O_OUTROS,O_NIVEL]<5              // pode visualizar o arquivo?
  IF LEN(sistema[ii,O_DBRELA])>0                // se o DBF da relacao tem suas proprias
   menu=menu+MENURELA(ii)                       // relacoes chama a funcao recursivamente
  ELSE                                          // se DBF relacionado nao tem relacao
   IF ii!=op_sis                                // e nao e' o DBF atual
    menu+="|"+sistema[ii,O_MENU]                // entao monta string
   ENDI
  ENDI
 ENDI
NEXT
RETU menu                                       // retorna string dos nomes do DBFs

/*
   Sintaxe: QUALRELA( <ExpN1> <,ExpN2> <,ExpN3> )
   Funcao.: Pega subscricao do enesimo arquivo da relacao
              ExpN1 = subscricao do arquivo atual
              ExpN2 = enesimo arquivo da relacao
              ExpN3 = valor temporario que contera' a qde de arquivos
                      da relacao. Passar sempre 0.
   Retorna: Subscricao encontrada
*/
FUNC QUALRELA(op_,op_esc,qt_op)
LOCAL i, ii, menu:=0
IF op_!=op_sis                             // se nao for o DBF atual, soma
 qt_op++                                   // 1 na qde de DBFs relacionados
 IF op_esc=qt_op                           // e' o enesimo arquivo da relacao
  menu=op_                                 // prepara p/ retornar sua subscricao
 ENDI
ENDI
IF menu=0                                  // ainda nao achou o enesimo arquivo
 FOR i=1 TO LEN(sistema[op_,O_DBRELA])     // pega todos os DBF da relacao
  ii=EVAL(qualsis,sistema[op_,O_DBRELA,i]) // pega sua subscricao no vetor sistema
  IF sistema[ii,O_OUTROS,O_NIVEL]<5        // pode visualizar o arquivo?
   IF LEN(sistema[ii,O_DBRELA])>0          // se o DBF da relacao tem suas proprias
    menu=QUALRELA(ii,op_esc,@qt_op)        // relacoes chama a funcao recursivamente
    IF menu>0                              // se achou o enesimo,
     EXIT                                  // cai fora
    ENDI
   ELSE                                    // se DBF relacionado nao tem relacao
    IF ii!=op_sis                          // e nao e' o DBF atual
     IF ++qt_op=op_esc                     // entao soma qde de DBFs da relacao
      menu=ii                              // e verifica se e' o enesimo
      EXIT                                 // se for, cai fora
     ENDI
    ENDI
   ENDI
  ENDI
 NEXT
ENDI
RETU menu                                  // retorna o enesimo DBF da relacao

/*
   Sintaxe: OPCOES_REL( <N1> <,N2> <,N3> <,N4> <,C1> )
   Funcao.: Abre diversas op‡”es para emissao de relatorio
               N1,N2 = coordenada linha/coluna superior do menu de opcoes
                  N3 = Numero sequencial para montar nome de arquivo para
                       gravar as variacoes do relatorio.
                  N4 = codigo do bloco de ajuda (cod_sos)
                  C1 = filtro inicial do relatorio
   Retorna: .t. se vai prosseguir
*/
FUNC OPCOES_REL(l_m,c_m,op_rel,sos_cod,fil_ini)
LOCAL li_, op_x, ant_, cr_i, or_i, t_opc:=SAVESCREEN(0,0,MAXROW(),79)
op_x=LRELA(l_m,c_m,op_rel)     // verifica/seleciona relatorios gravados
IF op_x=2                      // leu um relatorio gravado anteriormente
 improk=.t.
 IF tps=1                      // vai para impressora...
  improk=PREPIMP()             // confima preparacao da impressora
 ENDI
 IF !improk                    // cancelou
  op_x=0
 ELSE
  INDTMP()                     // verifica/indexa o arquivo se for necessario
 ENDI
 RETU .t.                      // retorna
ENDI
fil_ini=IF(fil_ini=NIL,"",fil_ini)
nucop=1
or_i=cpord                     // salva ordenacao inicial
ant_=criterio+cpord+titrel     // salva criterio, ordenacao e titulo atuais
DO WHIL op_x>0
 cod_sos=sos_cod
 msg="Prosseguir|Sa¡da: "        // monta menu de opcoes
 IF tps=1 .AND. !EMPTY(drvporta) // se a saida e para prn
  msg+=drvmarca+" em "+drvporta  // pega conf atual
 ELSE                            // caso contrario
  msg+="Arquivo/Video"           // coloca a palavra "Arquivo/Video"
 ENDI
 msg+="|Filtrar|C¢pia(s) ("+TRAN(nucop,"99")+")"+;
      "|Ordenar|T¡tulo"
 IF !EMPTY(titrel)             // se tem titulo coloca-o no menu
  msg+=": "+IF(LEN(titrel)>30,LEFT(titrel,30)+"...",titrel)
 ENDI
 cr_i=criterio+cpord+titrel    // se tem alteracao, liga
 gr_rela=(ant_!=cr_i)          // flag de gravacao de relatorio
 msgt="OP€”ES DO RELAT¢RIO"    // recebe opcao desejada
 RESTSCREEN(0,0,MAXROW(),79,t_opc)
 op_x=DBOX(msg,l_m,c_m,E_MENU,NAO_APAGA,msgt,,,op_x)
 DO CASE
  CASE op_x=1                  // prossegue...
   IF tps=1                    // vai para impressora.....
    IF !PREPIMP()              // pede confirmacao da impressora
     LOOP                      // nao quis mais, volta para menu de opcoes
    ENDI
   ENDI
   IF LEN(fil_ini)>0           // se tem filtro inicial
    IF LEN(criterio)>0         // vamos concatenar com filtro feito pelo usuario
     criterio=fil_ini+".AND. ("+criterio+")"
    ELSE
     criterio=fil_ini          // usuario nao fez filtro. Pega o inicial...
    ENDI
   ENDI
   INDTMP()                    // verifica/indexa o arquivo se for necessario
   EXIT

  CASE op_x=2                  // tipo de saida
   tps=TP_SAIDA(IF(l_m=NIL,NIL,l_m+2),IF(c_m=NIL,NIL,c_m+8),.t.)

  CASE op_x=3                  // pega criterio de selecao dos registro
   FILTRA(.f.)                 // parametro .f. = nao indexa ao final da selecao

  CASE op_x=4                  // numero de copias a emitir
   nucop=DBOX("(de 1 a 99)",IF(l_m=NIL,NIL,l_m+2),IF(c_m=NIL,NIL,c_m+8),,,"QUANTIDADE DE C¢PIAS",nucop,"99")
   nucop=IF(nucop<1.OR.LASTKEY()=K_ESC,1,nucop)

  CASE op_x=5                  // escolhe uma nova ordem
   cpord=or_i                  // inicializa ordenacao
   CLASS(.f.)

  CASE op_x=6                  // recebe um titulo para o sistema
   msg="Informe, se Desejar:"
   titrel=LEFT(titrel+SPAC(70),70)
   titrel=ALLTRIM(DBOX(msg,,,,,"T¡TULO DO RELAT¢RIO",titrel))
   RESTSCREEN(0,0,MAXROW(),79,t_opc)

 ENDC
ENDD                           // restaura a tela
RESTSCREEN(0,0,MAXROW(),79,t_opc)
RETU(op_x=1)                   // retorna .t. se quiser prosseguir

/*
   Sintaxe: TP_SAIDA( <N1> <,N2> <,L> )
   Funcao.: Permite a escolha das diversas configuracoes da impressora
              N1,N2 = coordenada linha/coluna superior do menu
               ExpL = se .t. deixa escolher saida para arquivo/video
   Retorna: o tipo de saida escolhido
*/
FUNC TP_SAIDA(l_tp,c_tp,arq_vid)
LOCAL ar_, i:=1
tps:=IF(TYPE("tps")="N",tps,1)
ar_=SELECT()               // salva area atual e
SELE 0                     // vai p/ uma area vazia

#ifdef COM_REDE
 IF ! USEARQ(arq_prn,.f.,20,1,.f.)
  RETU tps                 // falhou abertura, retorna
 ENDI
#else
 USE (arq_prn)             // abre arquivo de configuracoes
#endi

msg=""                     // variavel que contera as configuracoes
DO WHIL !EOF()             // le todo o arquivo
 msg+="|"+ALLTRIM(marca)+; // e vai montando a variavel
      " em "+porta         // para o menu de tipos de saidas
 IF drvporta=porta .AND.;  // pega impressora configurada
    drvmarca=ALLTRIM(marca)// para o default do menu
  i=RECNO()
 ENDI
 SKIP
ENDD
msg=SUBS(msg,2)            // retira o primeiro "|"
IF arq_vid                 // se pode enviar para arq/video
 IF !EMPTY(msg)            // se tem impressora
  msg+="|"                 // coloca conector
 ENDI
 msg+="Arquivo/Video"     // acrescenta esta opcao
END IF
IF !EMPTY(msg)
 i=DBOX(msg,l_tp,c_tp,E_MENU,,"TIPO DE SA¡DA",,,i)
 IF i>0                     // escolheu um tipo...
  tps=IF(i<=RECC(),1,2)     // ajusta tps: 1-impressora, 2=arquivo
  IF tps=1
   drvprn=i                 // ajusta default da configuracao atual
   GO drvprn                // reinicializa as variaveis de impressao
   FOR i=1 TO FCOU()        // de acordo com configuracao escolhida
    msg=FIEL(i)
    drv&msg.=ALLTRIM(FIELDGET(i))
   NEXT
   SAVE TO (arqconf) ALL LIKE drv* // salva mo disco configuracao escolhida
  ENDI
 ENDI
ENDI
USE                        // fecha o arq de conf de prn
SELE (ar_)                 // volta para area anterior
RETU tps

/*
   Sintaxe: TRANSCAMPO( <ExpL> <,ExpC> [,ExpN] [,ExpL] )
   Funcao.: Adapta campo para pesquisa segundo seu tipo
             ExpL = se .t. monta expressao com conteudo do campo, caso
                    contrario, monta expressao com o nome do campo
             ExpC = nome do campo para adaptacao
             ExpN = numero do campo dentro da estrutura do DBF
             ExpL = se .t. ou nula data sera tranformada para DTOS()
                    caso contratio, datas sera transformada para DTOC()
   Retorna: String convertida
*/
FUNC TRANSCAMPO(conteudo_,chv_,indcp_,fdata_)
LOCAL tp_cp:=VALTYPE(&chv_.), cp_, estr_dbf:=DBSTRUCT()
 fdata_=IF(fdata_=NIL, .t., fdata_)
IF conteudo_
 IF tp_cp="D"
  IF fdata_
   cp_=DTOS(&chv_.)
  ELSE
   cp_=DTOC(&chv_.)
  ENDI
 ELSEIF tp_cp="N"
  IF indcp_=NIL
   cp_=STR(&chv_.)
  ELSE
   cp_=STR(&chv_.,estr_dbf[indcp_,3],estr_dbf[indcp_,4])
  ENDI
 ELSE
  cp_=&chv_.
 ENDI
ELSE
 IF tp_cp="D"
  IF fdata_
   cp_="DTOS("+chv_+")"
  ELSE
   cp_="DTOC("+chv_+")"
  ENDI
 ELSEIF tp_cp="N"
  IF indcp_=NIL
   cp_="STR("+chv_+")"
  ELSE
   cp_="STR("+chv_+","+LPAD(estr_dbf[indcp_,3],2,"0")+","+LPAD(estr_dbf[indcp_,4],2,"0")+")"
  ENDI
 ELSE
  cp_=chv_
 ENDI
ENDI
RETU cp_

/*
   Sintaxe: ARQGER()
   Funcao.: recebe nome do arquivo
   Retorna: String (nome do arquivo)
*/
FUNC ARQGER()
LOCAL defa_:=drvdbf+"TMP"+ide_maq, t_l, t_r
t_l=SETKEY(K_LEFT,NIL)                         // desabilita seta -> e <-
t_r=SETKEY(K_RIGHT,NIL)
KEYB CHR(K_END)                                   // cursor no final do drive sugerido
mask_="*.PRN"                                     // mascara dos campos da lista
SET KEY K_F10 TO CAPTURAARQ()                     // f10 pega arq da lista
arq_=DBOX("Nome do arquivo",,,,,"ARQUIVO EM DISCO|F10=captura arquivo",PADR(defa_,150),"@S50@!")
SET KEY K_F10 TO                                  // desativa f10
arq_=TRIM(arq_)
SETKEY(K_LEFT,t_l)                             // reabilita setas cursoras
SETKEY(K_RIGHT,t_r)
RETU IF(LEN(SUBS(arq_,RAT("\",arq_)+1))<1.OR.; // nome do arquivo sem dir ou
     LASTKEY()=K_ESC,"",arq_)                  // ou cancelou

/*
   Sintaxe: PREPIMP( [msgt] )
   Funcao.: Apresenta mensagem para preparo da impressora
            msgt=titulo para menu
   Retorna: .t. se pronta
*/
FUNC PREPIMP(msgt)
PRIV cod_sos:=29
msgt=IF(msgt=NIL,"ATEN€ŽO, "+usuario,msgt)
ALERTA(3)
op_=1
DO WHILE op_=1
 msg="Impressora pronta|Cancelar opera‡„o"
 op_=DBOX(msg,,,E_MENU,,msgt)             // solicita preparo da impressora
 IF LEFT(drvporta,3)="LPT".AND.op_=1
  IF !IMPOK(VAL(SUBS(drvporta,4,1)))      // porta paralela podemos testar
   ALERTA(4)
   DBOX("Impressora n„o pronta!",,,,,"ATEN€ŽO, "+usuario)
   LOOP                                   // fora de linha, ficamos por aqui
  ENDI
 ENDI
 EXIT                                     // s'imbora
ENDD
RETU (op_=1)                              // retorna .T. se pronta

/*
   Sintaxe: CONFINCL()
   Funcao.: Apresenta mensagem para confirmar a inclusao
   Retorna: .t. se inclusao ok
*/
FUNC CONFINCL()
PRIV cod_sos:=1
ALERTA(2)
op_=1
msg="Efetuar inclus„o|Corrigir digita‡„o"
op_=DBOX(msg,l_i-1,c_i-10,E_MENU,,"ATEN€ŽO, "+usuario) // solicita confirmacao
RETU (op_=1)     // retorna .T. se quer incluir

/*
   Sintaxe: CONFEXCL()
   Funcao.: Apresenta mensagem para confirmacao da exclusao e
            verifica se o reg pode ser excluido
   Retorna: .t. se ok
*/
FUNC CONFEXCL()
LOCAL op_:=1
PRIV cod_sos:=1
IF drvexcl                                      // se conf de exclusao
 ALERTA(1)                                      // esta ligada, vamos
 cod_sos=1                                      // pedir confirmacao
 msg=IF(LEN(sistema[op_sis,O_DBRELA])>0,"|(INCLUSIVE RELACIONADOS)","")
 msg="EXCLUIR"+msg
 op_=DBOX("Sim|N„o",17,,E_MENU,,msg)
ENDI
IF op_=1.AND.!EMPT(sistema[op_sis,O_CONDEXC,1]) // se tem condicao de
 IF !&(sistema[op_sis,O_CONDEXC,1])             // exclusao e se esse
  ALERTA(2)                                     // reg nao pode ser
  op_=2                                         // excluido, avisa o
  msg=sistema[op_sis,O_CONDEXC,2]               // motivo e prepara
  DBOX(msg,,,,,"ATEN€ŽO!|IMPOSS¡VEL EXCLUIR")   // para retornar .f.
 ENDI
ENDI
RETU op_=1

/*
   Sintaxe: CONFALT()
   Funcao.: verifica se o reg pode ser alterado
   Retorna: .t. se ok
*/
FUNC CONFALT()
LOCAL op_:=1
PRIV cod_sos:=1
IF !EMPT(sistema[op_sis,O_CONDALT,1])         // se tem condicao de
 IF !&(sistema[op_sis,O_CONDALT,1])           // alteracao e se esse
  ALERTA(2)                                   // reg nao pode ser
  op_=2                                       // alterado, avisa o
  msg=sistema[op_sis,O_CONDALT,2]             // motivo e prepara
  DBOX(msg,,,,,"ATEN€ŽO!|IMPOSS¡VEL ALTERAR") // para retornar .f.
 ENDI
ENDI
RETU op_=1

/*
   Sintaxe: ROLAPOP( <ExpN> )
   Funcao.: Efetua a rolagem do menu pop-down
   Retorna: NIL
*/
FUNC ROLAPOP(q_t)
IF q_t=NIL               // se nao tem parametro desabilita setas da
 SETKEY(K_LEFT,NIL)      // esquerda/direita, caso contrario, liga as
 SETKEY(K_RIGHT,NIL)     // teclas com a qde de ESC, SETA e ENTER
ELSE                     // nesessarios para rolar a janela na horizontal
 SETKEY(K_LEFT,{||KEYBUFF(REPL(CHR(K_ESC),q_t)+CHR(K_LEFT)+CHR(K_ENTER))})
 SETKEY(K_RIGHT,{||KEYBUFF(REPL(CHR(K_ESC),q_t)+CHR(K_RIGHT)+CHR(K_ENTER))})
ENDI
RETU NIL

/*
   Sintaxe: PEGADIR( <ExpL> )
   Funcao.: Pega novo diret¢rio de trabalho para a aplica‡„o
              ExpL = se .f., so pega diretorios de dados e de indices
                     se .t. recebe o diret¢rio do ERROS.DBF tambem
   Retorna: .t. se nao foi cancelado
*/
FUNC PEGADIR(pri_vez)
LOCAL cn, drv_dbf, drv_ntx, drv_err:=drverr, t, msgt, msg, ado_, aio_,;
      add_, aid_, drv_, ntx_, cria_dbf:=.f., u_drv, u_ntx
cn=.f.

#ifdef COM_PROTECAO
 IF !pri_vez                                     // se veio do apoio
  EVAL(protdbf,.f.)                              // protege DBFs
 ENDI
#endi

IF !pri_vez                                      // so quer trocar diretorio
 SAVE TO (arqconf) ALL LIKE drv*                 // salva configuracao atual
ENDI
u_drv=drvdbf
u_ntx=drvntx
FOR t=0 TO nss-3
 IF t=0 .OR. sistema[t,O_OUTROS,O_PEDEDIR]       // pedir diretorio deste arq?
  IF t=0
   msgt="DIRET¢RIOS DE TRABALHO"
   drv_="drvdbf"
   ntx_="drvntx"
  ELSE
   msgt="DIRET¢RIO EXCLUSIVO DO|SUBSISTEMA '"+UPPER(sistema[t,O_MENU])+"`"
   drv_="drvdbf"+LEFT(sistema[t,O_ARQUI,O_NOME],3)
   ntx_="drvntx"+LEFT(sistema[t,O_ARQUI,O_NOME],3)
  ENDI
  msgt+="|F10=captura diret¢rio"
  drv_dbf=&drv_.
  drv_ntx=&ntx_.
  DO WHIL !cn
   SET KEY K_F10 TO CAPTURADIR()                 // f10 pega diretorio
   msg="Arquivo de dados"
   &drv_.=u_drv
   &drv_.=DBOX(msg,,,,,msgt,PADR(&drv_.,50),"@!")// diretorio dos DBF
   IF LASTKEY()=K_ESC                            // cancelou
    cn=.t.                                       // flag de cancelamento
    &drv_.=drv_dbf                               // desfaz drives modificados
    &ntx_.=drv_ntx
    LOOP
   ENDI
   &drv_.=TRATADIR(ALLTRIM(&drv_.))              // tira espacos e coloca "\" no final
   IF !criadrv(&drv_.)                           // verifica/cria diretorio
    LOOP                                         // desistiu de criar
   ENDI
   msg+=": "+&drv_.                              // diretorio dos NTX
   u_drv=&drv_.
   &ntx_.=u_ntx
   &ntx_.=DBOX(msg+"|*|Arquivos de ¡ndices",,,,,msgt,PADR(&ntx_.,50),"@!")
   IF LASTKEY()=K_ESC                            // se cancelou,
    LOOP                                         // volta a pedir dir DBF
   ENDI
   &ntx_.=TRATADIR(ALLTRIM(&ntx_.))              // tira espacos e coloca "\" no final
   IF !criadrv(&ntx_.)                           // verifica/cria diretorio
    LOOP                                         // desistiu de criar
   ENDI
   u_ntx=&ntx_.
   msg+="|Arquivo de ¡ndices: "+&ntx_.
   IF pri_vez .AND. t=0                          // recebe diretorio do ERROS.DBF
    drverr=DBOX(msg+"|*|Arquivos de apoio … aplica‡„o:",,,,,msgt,PADR(drverr,50),"@!")
    IF LASTKEY()=K_ESC                           // se cancelou,
     LOOP                                        // volta a pedir dir DBF
    ENDI
    drverr=TRATADIR(ALLTRIM(drverr))             // tira espacos e coloca "\" no final
    IF !criadrv(drverr)                          // verifica/cria diretorio
     LOOP                                        // desistiu de criar
    ENDI
    msg+="|Arquivos de apoio: "+drverr
    drvpw=DBOX(msg+"|*|Arquivo de senhas:",,,,,msgt,PADR(drvpw,50),"@!")
    IF LASTKEY()=K_ESC                           // se cancelou,
     LOOP                                        // volta a pedir dir DBF SENHAS
    ENDI
    drvpw=TRATADIR(ALLTRIM(drvpw))               // tira espacos e coloca "\" no final
    IF !criadrv(drvpw)                           // verifica/cria diretorio
     LOOP                                        // desistiu de criar
    ENDI
    msg+="|Arquivo de senhas: "+drvpw
   ENDI
   msg=msgt+"|*|"+msg
   SET KEY K_F10 TO
   ALERTA(1)
   op_=DBOX("Prosseguir|Corrigir",,,E_MENU,,msg) // confirma as informacoes
   IF op_=1                                      // se tudo certo,
    EXIT                                         // sai do loop
   ENDI
  ENDD
  SET KEY K_F10 TO
  IF (!(&drv_.==drv_dbf) .OR.;                   // se mudou diretorio de trabalho
     !(&ntx_.==drv_ntx))                         // e nao for a primeira vez, seta
   cria_dbf=.t.
  ENDI
  IF !pri_vez                                    // se nao for a 1a. vez
   EXIT                                          // nao pega dir dos dbf exclusivos
  ENDI
 ENDI
NEXT
IF cn                                            // se cancelou,
 IF !pri_vez
  REST FROM (arqconf) ADDI                       // restaura configuracoes
 ENDI
ELSE
 ADR_ATRI()                                      // vamos reenche-lo
 ADR_ATR1()
 ADR_ATR2()
 IF cria_dbf .AND. !pri_vez                      // mudou diretorios?
  cn=!CRIADBF()                                  // cria dbf's e ntx's
 ENDI
 SAVE TO (arqconf) ALL LIKE drv*                 // salva diretorios no disco
ENDI

#ifdef COM_PROTECAO
 IF !pri_vez                                     // se veio do apoio
  EVAL(protdbf,.t.)                              // desprotege DBFs
 ENDI
#endi

RETU !cn

FUNC TRATADIR(drv_)  // trata diretorio informado
drv_=ALLTRIM(drv_)                               // tira espacos
drv_=IF(RIGHT(drv_,1)!="\".AND.;                 // diretorio tem que
       LEN(drv_)>0,drv_+"\",drv_)                // terminar com barra (\)
RETU drv_

/*
   Sintaxe: CRIADRV( <ExpC> )
   Funcao.: Testa/cria se nao exitir o diretorio ExpC
   Retorna: .t. se teve sucesso.
*/
FUNC CRIADRV(drv_)
LOCAL drv_atual:="\"+CURDIR(),x
drv_=LEFT(drv_,LEN(drv_)-1)
IF !CHDIR(drv_) .AND. LEN(drv_)>2              // se diretorio nao existe
 ALERTA(2)                                     // beep, beep e
 x="Criar "+drv_+"|Digitar outro diret¢rio"    // pergunta se quer
 op_=DBOX(x,,,E_MENU,,"DIRET¢RIO NŽO EXISTE!") // cria-lo
 IF op_!=1                                     // se nao quis...
  RETU .f.                                     // retorna
 ENDI
 IF !MKDIR(drv_)                               // se nao conseguiu criar
  ALERTA(4)                                    // avisa e retorna
  x="Erro ao criar o diret¢rio"
  op_=DBOX(x,,,3,,"ERRO!")
  RETU .f.
 ENDI
ELSE                                           // ok diretorio existe
 CHDIR(drv_atual)                              // posiciona dentro dele
ENDI
RETU .t.

PROC RCLA     // reconstroi indices
LOCAL msg, op_a:=1, db, ii, rcla_t, cur_atual:=SETCURSOR(0)
msg:=db := ""                                   // monta menu de dbf
FOR i=1 TO nss-IF(nivelop=3,0,3)                // se for o gerente, entra
 IF LEN(sistema[i,O_CPRELA])=0 .AND.;           // so o "pai" e se
    LEN(sistema[i,O_INDIC])>0                   // tiver indice definido
  msg+="|"+sistema[i,O_MENU]                    // este entra no menu...
  db+=RIGHT(STR(1000+i),3)                      // subscricao dentro de "sistema"
 ENDI
NEXT
rcla_t=SAVESCREEN(0,0,MAXROW(),79)              // sava tela
DO WHIL op_a>0
 op_sis=1
 RESTSCREEN(0,0,MAXROW(),79,rcla_t)             // escolhe um dbf para indexacao
 op_a=DBOX(SUBS(msg,2),03,55,E_MENU,NAO_APAGA,"BASE DE DADOS",,,op_a)
 IF op_a>0                                      // escolheu um...
  op_sis=op_a
  ii=VAL(SUBS(db,op_sis*3-2,3))                 // acha sua subscricao
  FOR op_sis=ii TO nss                          // indexa "pais e filhos"
   IF PEGAPAI(op_sis)!=ii                       // nao e' um "filho"
    EXIT
   ENDI
   dbf=sistema[op_sis,O_ARQUI,O_NOME]           // nome do arquivo dbf

   #ifdef COM_REDE
    IF !USEARQ(dbf,.t.,5,1,.f.)                 // se nao conseguiu abrir o dbf
     RETU                                       // cancela a operacao
    ENDI
   #else
    USEARQ(dbf,,,,.f.)                          // abre o arquivo
   #endi

   FOR t=1 TO LEN(sistema[op_sis,O_INDIC])      // recria todos os ntx do arquivo
    ntx=sistema[op_sis,O_ARQUI,O_DIR_NTX]+sistema[op_sis,O_INDIC,t]+EXTENSAO() // nome do indice
    POE_GAUGE("Classificando o arquivo|"+ntx,"AGUARDE!")
    chvind=sistema[op_sis,O_CHAVE,t]            // chave de indexacao
    INDE ON &chvind. TO (ntx) EVAL POE_GAUGE() EVERY (LASTREC()/20)
   NEXT
   CLOS ALL
  NEXT
  op_a++                                        // default para o proximo
 ENDI
ENDD
 SETCURSOR(cur_atual)                           // retorna o cursor ao normal
RETU

PROC COMPACTA    // exclusao fisica de registros
LOCAL msg, op_a:=1, db, ii, pack_t, cur_atual:=SETCURSOR(0)
LOCAL dele_atu:=SET(_SET_DELETED,.t.), tmp
msg:=db := ""
FOR i=1 TO nss-IF(nivelop=3,0,3)          // monta menu de arquivos
 IF LEN(sistema[i,O_CPRELA])=0 .AND.;  // so entre os "pais" e
    LEN(sistema[i,O_INDIC])>0          // quem tem indice
  msg+="|"+sistema[i,O_MENU]           // este serve
  db+=RIGHT(STR(1000+i),3)             // subscricao dentro de "sistema"
 ENDI
NEXT
pack_t=SAVESCREEN(0,0,MAXROW(),79)     // salva tela
DO WHIL op_a>0
 op_sis=1
 RESTSCREEN(0,0,MAXROW(),79,pack_t)    // escolhe um arquivo para o pack
 op_a=DBOX(SUBS(msg,2),03,55,E_MENU,NAO_APAGA,"BASE DE DADOS",,,op_a)
 IF op_a>0                             // escolheu um...
  op_sis=op_a                          // subscricao do dbf escolhido
  ii=VAL(SUBS(db,op_sis*3-2,3))
  FOR op_sis=ii TO nss                 // compacta o "pai e seus filhos"
   IF PEGAPAI(op_sis)!=ii              // e' "filho"?
    EXIT
   ENDI
   dbf=sistema[op_sis,O_ARQUI,O_NOME]  // nome do dbf

   #ifdef COM_REDE
    IF !USEARQ(dbf,.t.,5,1,.f.)        // se nao conseguiu abrir o arquivo
    SET(_SET_DELETED,dele_atu)         // os excluidos serao vistos
     RETU                              // cancela a operacao
    ENDI
   #else
    USEARQ(dbf,,,,.f.)                 // abre o arquivo
   #endi

   dbf=sistema[op_sis,O_ARQUI,O_DIR_DBF]+dbf           // nome do dbf
   tmp=sistema[op_sis,O_ARQUI,O_DIR_DBF]+"temp$.dbf"   // nome tmp para copiar
   POE_GAUGE("Compactando o arquivo|"+dbf,"AGUARDE!","Registros feitos:")  // msg de gauge
   GO TOP                                              // inicio do dbf
   COPY TO &tmp. WHILE POE_GAUGE()                     // copia reg nao excluido para tmp
   CLOS ALL                                            // fecha o arquivo
   ERASE &dbf..dbf                                     // apaga arq dbf
   RENAME &tmp. TO &dbf..dbf                           // remomea temp para o dbf
   dbf+=EXTENSAO(.f.)                                  // idem para o .dbt se existir
   tmp=sistema[op_sis,O_ARQUI,O_DIR_DBF]+"temp$"+EXTENSAO(.f.) // nome do .dbt temporario
   IF FILE(dbf)                                        // .dbt existe?
    ERASE (dbf)                                        // apaga e
    RENAME (tmp) TO (dbf)                              // copia tmp para o .dbt
   ENDI
   dbf=sistema[op_sis,O_ARQUI,O_NOME]           // nome do dbf

   #ifdef COM_REDE
    IF !USEARQ(dbf,.t.,5,1,.f.)                 // se nao conseguiu abrir o dbf
     SET(_SET_DELETED,dele_atu)                 // os excluidos serao vistos
     RETU                                       // cancela a operacao
    ENDI
   #else
    USEARQ(dbf,,,,.f.)                          // abre o arquivo sem indice
   #endi

   FOR t=1 TO LEN(sistema[op_sis,O_INDIC])   // recria todos os ntx do arquivo
    ntx=sistema[op_sis,O_ARQUI,O_DIR_NTX]+sistema[op_sis,O_INDIC,t]+EXTENSAO() // nome do indice
    POE_GAUGE("Classificando o arquivo|"+ntx,"AGUARDE!")
    chvind=sistema[op_sis,O_CHAVE,t]                                // chave de indexacao
    INDE ON &chvind. TO (ntx) EVAL POE_GAUGE() EVERY (LASTREC()/20) // indexa colocando gauge
   NEXT
   CLOS ALL
  NEXT
  op_a++
 ENDI
ENDD
SET(_SET_DELETED,dele_atu)             // os excluidos serao vistos
SETCURSOR(cur_atual)              // retorna o cursor ao normal
RETU

PROC CONFCORES      // Configura‡„o de cores
LOCAL fez_conf:=.f.
NAOPISCA()                                   // habilita 256 cores (ega/vga)
maxfore=IF(CARDTYPE()>=V_EGA, 32, 16)        // numero maximo de cores
maxcol =IF(CARDTYPE()>=V_EGA, 71, 39)        // ultima coluna das cores

tb={;
     "N" , "B"  , "G"  , "BG" ,;             // tabela de cores literais
     "R" , "RB" , "GR" , "W"  ,;
     "N+", "B+" , "G+" , "BG+",;
     "R+", "RB+", "GR+", "W+" ;
   }
qcor={;
       drvcorpad, drvcorbox, drvcormsg,;     // cores configuraveis
       drvcorenf, drvcorget, drvcortel,;
       drvcortna, drvcorhlp;
     }

qtit={;
       drvtitpad, drvtitbox, drvtitmsg,;     // cores de titulos configuraveis
       drvtitenf, drvtitget, drvtittel,;
       drvtittna, drvtithlp;
     }

SET CURSO OFF                                // apaga cursor
SETCOLOR(drvcorbox)
CAIXA(mold+" ",12,5,23,maxcol)
FOR fundo=0 TO 7                             // monta janela de selecao
 FOR frente=0 TO maxfore-1                   // das cores a serem configuradas
  cor=STR(frente,2)+"/"+STR(fundo,1)+IF(frente>15,"*","")
  SETCOLOR(cor)
  @ 14+fundo,6+(2*frente) SAY " þ "
 NEXT
NEXT
op_cor=1
DO WHILE .t.
 cod_sos=44
 msg="Pano do fundo|Janelas|Caixas de di logos|Avisos e erros|Menus e campos|Tela de digita‡„o|Tela de digita‡„o n„o ativa|Janela de ajuda"
 op_cor=DBOX(msg,4,38,E_MENU,,"ESQUEMAS DE CORES",,,op_cor)
 IF op_cor=0                                 // volta ao menu
  EXIT
 ENDI
 fg=LEFT(qcor[op_cor],AT("/",qcor[op_cor])-1)// cor da frente literal
 fg=ASCAN(tb,{|ve_a|fg==ve_a})               // numero da cor da frente
 bg=SUBS(qcor[op_cor],AT("/",qcor[op_cor])+1)// cor do fundo  literal
 IF "*" $ bg                                 // se 'blink` soma 16 na cor
  bg=STRTRAN(bg,"*"); fg=fg+16               // da frente
 ENDI
 bg=ASCAN(tb,{|ve_a|bg==ve_a})               // numero da cor do fundo
 ti=LEFT(qtit[op_cor],AT("/",qtit[op_cor])-1)// cor da frente do titulo literal
 ti=ASCAN(tb,{|ve_a|ti==ve_a})               // numero da cor da titulo
 tela_cor=SAVESCREEN(0,0,MAXROW(),79)
 qcor_antes=qcor[op_cor]; qtit_antes=qtit[op_cor]
 DO WHILE .t.
  SETCOLOR(qtit[op_cor])                     // monta janela para exemplo
  CAIXA(mold,4,33,12,64)                     // da selecao de cores
  @ 6,34 SAY REPL("Ä",30)
  @ 5,34 SAY "EXEMPLO DO ESQUEMA SELECIONADO"
  SETCOLOR(qcor[op_cor])
  IF op_cor=1                                // enche caixa-exemplo com
   FOR t=1 TO 5                              // o fundo que estiver selecionado
    @ 6+t,34 SAY REPL(drvcara,30)
   NEXT
  ELSE                                       // mostra mensagens na caixa-exemplo
   @  8,34 SAY PADC(CHR(24)+" e "+CHR(25)+" muda fundo",30)
   @  9,34 SAY PADC("^"+CHR(27)+" e ^"+CHR(26)+" muda t¡tulo",30)
   @ 10,34 SAY PADC("ENTER para aceitar esquema",30)
   @ 11,34 SAY PADC("ESC para terminar",30)
   IF op_cor=5                               // se for menu, mostra como
    SETCOLOR(INVCOR(qcor[5]))                // vai ficar
   ENDI
   @ 7,34 SAY PADC(CHR(27)+" e "+CHR(26)+" muda frente",30)
  ENDI
  SETCOLOR(drvcorbox)
  tc_=SAVESCREEN(12,5,23,maxcol)
  IF INT(fg/17)!=INT(ti/17)                  // fundo do titulo tem que
   ti=IF(fg>16,ti+16,ti-16)                  // ter a mesma cor do restante
  ENDI
  le=12+bg; ce=fg*2+4; ct=ti*2+5
  @ le,ce,le+2,ce+2 BOX LEFT(mold,8)         // imprime caixa de selecao
  IF op_cor>1                                // se nao for pano de fundo,
   @ 22,Ct SAY CHR(30)                       // imprime ponteiro de selecao
  ENDI                                       // da cor do titulo
  cod_sos=51

  #ifdef COM_MOUSE
   tecl=MOUSETECLA(14,7,22,7+(maxfore-1)*2)  // teclou algo ou clicou o mouse?
   IF tecl=CLICK                             // o mouse foi clicado
    li:=co:=0
    MOUSEGET(@li,@co)                        // coordenadas do mouse
    IF li=22                                 // lin 22 quer modificar o titulo
     ct=co+IF(co%2=0,1,0)
     IF ti=(ct-5)/2                          // clicado 2 vezes no mesmo lugar
      tecl=K_ENTER                           // forca saida da configuracao
     ELSE
      ti=(ct-5)/2                            // calcula nova cor do titulo
      tecl=32
     ENDI
    ELSE                                     // clicou em cima das cores
     le=li; ce=co-IF(co%2=0,0,1)
     IF bg=le-13 .AND. fg=(ce-4)/2           // 2 vezes no mesmo lugar
      tecl=K_ENTER                           // forca saida
     ELSE
      bg=le-13; fg=(ce-4)/2                  // calcula novas cores
      tecl=32
     ENDI
    ENDI
   ENDI
  #else

   tecl=IN_KEY(0)

  #endi

  RESTSCREEN(12,5,23,maxcol,tc_)
  IF fg<17
   liminf=1; limsup=16
  ELSE
   liminf=17; limsup=32
  ENDI
  DO CASE
   CASE tecl=K_ESC                           // abandonou
    qcor[op_cor]=qcor_antes                  // restaura cores anteriores
    qtit[op_cor]=qtit_antes
    EXIT

   CASE tecl=K_ENTER                         // escolheu cor
    EXIT

   CASE tecl=K_CTRL_D                        // pra direita
    fg=IF(fg<maxfore,fg+1,1)

   CASE tecl=K_CTRL_S                        // para esquerda
    fg=IF(fg>1 ,fg-1,maxfore)

   CASE tecl=K_CTRL_E                        // para cima
    bg=IF(bg>1,bg-1,7)

   CASE tecl=K_CTRL_X                        // para baixo
    bg=IF(bg<8,bg+1,1)

   CASE tecl=K_F1                            // help
    EVAL(SETKEY(K_F1))

   CASE tecl=K_CTRL_RIGHT .AND. op_cor>1     // pra direita
    ti=IF(ti<limsup,ti+1,liminf)

   CASE tecl=K_CTRL_LEFT .AND. op_cor>1      // para esquerda
    ti=IF(ti>liminf,ti-1,limsup)

  ENDC
  /*
     converte cor numerica em cor literal
  */
  qcor[op_cor]=tb[fg-IF(fg>16,16,0)]+"/"+tb[bg]+IF(fg>16,"*","")
  qtit[op_cor]=tb[ti-IF(ti>16,16,0)]+"/"+tb[bg]+IF(fg>16,"*","")
 ENDD
 IF qcor[op_cor]!=qcor_antes .OR. qtit[op_cor]!=qtit_antes
  fez_conf=.t.                               // trocou de cor
 ENDI
 RESTSCREEN(0,0,MAXROW(),79,tela_cor)
ENDD
SET CURSO ON                                 // acende o cursor
IF fez_conf                                  // configurou cores
 drvcorpad=qcor[1]; drvcorbox=qcor[2]        // significa que as cores
 drvcormsg=qcor[3]; drvcorenf=qcor[4]        // foram alteradas, entao,
 drvcorget=qcor[5]; drvcortel=qcor[6]        // move para as variaveis do sistema
 drvcortna=qcor[7]; drvcorhlp=qcor[8]
 drvtitpad=qtit[1]; drvtitbox=qtit[2]
 drvtitmsg=qtit[3]; drvtitenf=qtit[4]
 drvtitget=qtit[5]; drvtittel=qtit[6]
 drvtittna=qtit[7]; drvtithlp=qtit[8]
 SETCOLOR(drvcorpad+","+drvcorget+",,,"+drvcortel)
 SAVE TO (arqconf) ALL LIKE drv*             // grava configuracoes,
 corcampo=drvtittel                          // cor "unselected"
 CBC1()
 v01=SAVESCREEN(0,0,MAXROW(),79)             // salva para o break
 BREAK                                       // forca a volta para o menu geral
ENDI
SET CURSO ON                                 // acende o cursor
RETU


PROC CONFPRN     // Cria/Muda configuracao para a impressora
LOCAL i,l_,c_,op_imp:=1
PRIV  ar_prn, pd_prn                 // area do arquivo de configuracoes

pd_prn="1. IBM  9 pinos   |2. IBM 24 pinos   |3. Epson  9 pinos |"+;
       "4. Epson 24 pinos |5. Hp DeskJet     |6. Hp DeskJet Plus|"+;
       "7. Hp LaseJet II  |8. Hp LaseJet III  "  // padroes das impressoras
#ifdef COM_REDE
 IF ! USEARQ(arq_prn,.t.,20,1,.f.)   // falhou abertura modo
  RETU                               // exclusivo, retorna
 ENDI
#else
 USE (arq_prn)                       // abre arquivo de configuracoes
#endi

ar_prn=SELECT()                      // qual e' o numero da area
DO WHIL .t.
 rel_imp=""                          // variavel que contera as configuracoes
 GO TOP                              // ja existentes
 IF !EOF()
  DO WHIL !EOF()                     // le todo o arquivo
   rel_imp+="|"+ALLTRIM(marca)+;     // e vai montando a variavel
            " em "+porta             // para o menu de configuracoes
   SKIP
  ENDD
 ENDI
 volta_ac=.f.                        // flag p/ dizer que o DEL foi
 rel_imp="* NOVA *"+rel_imp          // pressionado denotr da DBOX()
 cod_sos=42
 op_imp=DBOX(rel_imp,05,63,E_MENU,NAO_APAGA,"IMPRESSORAS|(DEL=APAGA)",,,op_imp)
 IF volta_ac                         // quer apagar a configuracao?
  IF LASTREC()>1
   GO op_imp-1                        // posiciona nela e
   ALERTA()                           // pede confirmacao
   msg="Cancelar a opera‡„o|Efetivar exclus„o"
   op_=DBOX(msg,,,E_MENU,,"EXCLUINDO CONFIGURA€ŽO|¯ "+ALLTRIM(marca)+"em "+porta+" ®")
   IF op_=2                           // se confirmou exclusao elimina
    DELE                              // o registro logicamente e
    PACK                              // fisicamente do arquivo
   ENDI
  ENDI
  LOOP                               // retorna para menu de conf
 ENDI
 IF op_imp=0                         // ESC quer voltar
  EXIT
 ELSEIF op_imp=1                     // que fazer uma nova configuracao
  GO BOTT
  SKIP
 ELSE                                // escolheu um configuracao ja pronta
  GO op_imp-1                        // posiciona dentro do dbf
 ENDI
 FOR i=1 TO FCOU()                   // cria variaveis de memoria
  msg=FIEL(i)                        // com o mesmo nome das variaveis
  M->&msg.=FIELDGET(i)               // do arquivo
 NEXT
 SELE 0                              // torna as variaveis visiveis
 cod_sos=18
 v4=SAVESCREEN(0,0,MAXROW(),79)      // salva tela
 DBOX(REPL("|",18),2,11,,NAO_APAGA,PADC("CONSULTE O MANUAL DA SUA IMPRESSORA",54,CHR(0)),,,,drvcortel)
 IF !EMPTY(padrao)                   // se existe um padrao...
  SETCOLOR(drvtittel)                // imprime o seu nome
  @ 07,40 SAY SUBS(pd_prn,19*VAL(padrao)-18,18)
 ENDI
 SETCOLOR(drvcortel)                 // recebe as informacoes da configuracao

 @ 05,13 SAY "Marca da impressora.......";
         GET marca;                  // maraca da impressora
         WHEN "IMP_MARCA(marca)";
         VALI CRIT("!EMPT(marca)~MARCA Ilegal!")

 @ 06,13 SAY "Porta de sa¡da............";
         GET porta PICT "@!";        // para ativa
         WHEN "IMP_PORTA(porta,5,60)";
         VALI CRIT("!EMPT(porta)~PORTA Ilegal!")

 @ 07,13 SAY "Padr„o da impressora......";
         GET padrao PICT "@!";       // padrao da impressora
         WHEN "IMP_PADRAO(padrao)";
         VALI CRIT("padrao $ '12345678' ~PADRŽO Ilegal!")

                                     // os codigos de impressao
 @ 08,13 SAY "Linhas por p ginas........" GET tapg PICT "@S28"
 @ 09,13 SAY "   Ativa comprime 17,5 cpp" GET pcom PICT "@S28"
 @ 10,13 SAY "Desativa comprime 17,5 cpp" GET tcom PICT "@S28"
 @ 11,13 SAY "   Ativa comprime 20 cpp.." GET pc20 PICT "@S28"
 @ 12,13 SAY "Desativa comprime 20 cpp.." GET tc20 PICT "@S28"
 @ 13,13 SAY "   Ativa elite............" GET peli PICT "@S28"
 @ 14,13 SAY "Desativa elite............" GET teli PICT "@S28"
 @ 15,13 SAY "   Ativa negrito.........." GET penf PICT "@S28"
 @ 16,13 SAY "Desativa negrito.........." GET tenf PICT "@S28"
 @ 17,13 SAY "   Ativa expandido........" GET pexp PICT "@S28"
 @ 18,13 SAY "Desativa expandido........" GET texp PICT "@S28"
 @ 19,13 SAY "   Ativa 8 lin/pol........" GET pde8 PICT "@S28"
 @ 20,13 SAY "Desativa 8 lin/pol........" GET tde8 PICT "@S28"
 @ 21,13 SAY "   Ativa landscape........" GET land PICT "@S28"
 @ 22,13 SAY "Desativa landscape........" GET port PICT "@S28"
 READ
 SELE (ar_prn)                       // seleciona arq de configuracao
 IF LASTKEY()!=K_ESC                 // se nao abandonou com ESC
  IF EOF()                           // se quer incluir mais uma conf
   APPEND BLAN                       // cria um registro em branco
  ENDI
  FOR i=1 TO FCOU()                  // joga para o arquivo as
   msg=FIEL(i)                       // informacoes digitadas
   REPL &msg. WITH M->&msg.
  NEXT
 ENDI
 RESTSCREEN(0,0,MAXROW(),79,v4)      // restaura a tela anterior
ENDD
drvprn=IF(RECC()<drvprn,1,drvprn)    // ajusta configuracao atual
GO drvprn                            // inicializa novamente as
FOR i=1 TO FCOU()                    // variaveis de impressao
 msg=FIEL(i)                         // para as novas configuracoes
 drv&msg.=ALLTRIM(FIELDGET(i))
NEXT
CLOSE ALL                            // fecha o arquivo
RETU                                 // volta para o menu anterior

FUNC IMP_MARCA(m)   // escolhe a marca da impressora
LOCAL op_, msg, x:=1, mar_:=""
PRIV  cod_sos:=60
msg="Padrao IBM  |HP Laser IIP|"+;        // menu de modelos de
    "DeskJet 500 |Rima        |"+;        // impressoras
    "Epson       |Outras"
IF !EMPTY(m)                              // se esta alterando uma conf
 x=AT(UPPER(LEFT(m,12)),UPPER(msg))       // procura o default
 x=IF(x>0,CONTA("|",LEFT(msg,x))+1,6)
ENDI
op_=DBOX(msg,05,60,E_MENU,,,,,x)          // apresenta menu de impressoras
IF op_>0                                  // escolheu uma...
 IF EMPTY(m) .OR. op_!=x                  // e nao e a mesma
  mar_=PADR(SUBS(msg,1+13*(op_-1),12),15) // sujestao do nome da marca
  IF op_!=6                               // se nao for "outras" inicializa
   land=SPAC(40)                          // ativa landscape
   port=SPAC(40)                          // ativa portrait
   tapg=SPAC(40)                          // tamanho da pagina e
  ENDI
  DO CASE

   CASE op_=1                             //   * PADRAO IBM *
    padrao="1"                            // padrao
    tapg=PADR("CHR(27)+'C'+CHR(NNN)",40)  // tamanho da pagina
    pcom=PADR("CHR(15)",40)               // ativa comprimido 17,5 cpp
    tcom=PADR("CHR(18)",40)               // desativa comprimido 17,5 cpp
    pc20=PADR("CHR(30)+'5'",40)           // ativa comprimido 20 cpp
    tc20=PADR("CHR(30)+'0'",40)           // desativa comprimido 20 cpp
    peli=PADR("CHR(30)+'2'",40)           // ativa elite
    teli=PADR("CHR(30)+'0'",40)           // desativa elite
    penf=PADR("CHR(27)+'E'",40)           // ativa negrito
    tenf=PADR("CHR(27)+'F'",40)           // desativa negrito
    pexp=PADR("CHR(27)+'W'+CHR(1)",40)    // ativa expandido
    texp=PADR("CHR(27)+'W'+CHR(0)",40)    // desativa expandido
    pde8=PADR("CHR(27)+'0'",40)           // ativa 8 lin/pol
    tde8=PADR("CHR(27)+'2'",40)           // ativa 6 lin/pol

   CASE op_=2 .OR. op_=3                  //    * HP  LASER *
    padrao=IF(op_=2,"7","5")              // padrao
    pcom=PADR("CHR(27)+'(s16.67H'",40)    // ativa comprimido 17,5 cpp
    tcom=PADR("CHR(27)+'(s10H'",40)       // desativa comprimido 17,5 cpp
    pc20=PADR("CHR(27)+'(s16.67H'",40)    // ativa comprimido 20 cpp
    tc20=PADR("CHR(27)+'(s10H'",40)       // desativa comprimido 20 cpp
    peli=PADR("CHR(27)+'(s12H'",40)       // ativa elite
    teli=PADR("CHR(27)+'(s10H'",40)       // desativa elite
    penf=PADR("CHR(27)+'(s3B'",40)        // ativa negrito
    tenf=PADR("CHR(27)+'(s-3B'",40)       // desativa negrito
    pexp=PADR("CHR(27)+'(s3B'",40)        // ativa expandido
    texp=PADR("CHR(27)+'(s-3B'",40)       // desativa expandido
    pde8=PADR("CHR(27)+'(s1P'",40)        // ativa 8 lin/pol
    tde8=PADR("CHR(27)+'(s0P'",40)        // ativa 6 lin/pol
    land=PADR("CHR(27)+'&l1O'",40)        // ativa landscape
    port=PADR("CHR(27)+'&l0O'",40)        // ativa portrait

   CASE op_=4                             //    * RIMA *
    padrao="1"                            // padrao
    tapg=PADR("CHR(27)+'C'+CHR(NNN)",40)  // tamanho da pagina
    pcom=PADR("CHR(15)",40)               // ativa comprimido 17,5 cpp
    tcom=PADR("CHR(18)",40)               // desativa comprimido 17,5 cpp
    pc20=PADR("CHR(27)+'['+CHR(5)",40)    // ativa comprimido 20 cpp
    tc20=PADR("CHR(27)+'['+CHR(0)",40)    // desativa comprimido 20 cpp
    peli=PADR("CHR(27)+'['+CHR(2)",40)    // ativa elite
    teli=PADR("CHR(27)+'['+CHR(1)",40)    // desativa elite
    penf=PADR("CHR(27)+'E'",40)           // ativa negrito
    tenf=PADR("CHR(27)+'F'",40)           // desativa negrito
    pexp=PADR("CHR(27)+'W'+CHR(1)",40)    // ativa expandido
    texp=PADR("CHR(27)+'W'+CHR(0)",40)    // desativa expandido
    pde8=PADR("CHR(27)+'0'",40)           // ativa 8 lin/pol
    tde8=PADR("CHR(27)+'2'",40)           // ativa 6 lin/pol

   CASE op_=5                             //    * EPSON *
    padrao="3"                            // padrao
    tapg=PADR("CHR(27)+'C'+CHR(NNN)",40)  // tamanho da pagina
    pcom=PADR("CHR(15)",40)               // ativa comprimido 17,5 cpp
    tcom=PADR("CHR(18)",40)               // desativa comprimido 17,5 cpp
    pc20=PADR("CHR(27)+'M'+CHR(15)",40)   // ativa comprimido 20 cpp
    tc20=PADR("CHR(27)+'P'",40)           // desativa comprimido 20 cpp
    peli=PADR("CHR(27)+'M'",40)           // ativa elite
    teli=PADR("CHR(27)+'P'",40)           // desativa elite
    penf=PADR("CHR(27)+'E'",40)           // ativa negrito
    tenf=PADR("CHR(27)+'F'",40)           // desativa negrito
    pexp=PADR("CHR(27)+'W'+CHR(1)",40)    // ativa expandido
    texp=PADR("CHR(27)+'W'+CHR(0)",40)    // desativa expandido
    pde8=PADR("CHR(27)+'0'",40)           // ativa 8 lin/pol
    tde8=PADR("CHR(27)+'2'",40)           // ativa 6 lin/pol

  ENDC
  x=SETCOLOR(drvtittel)                   // reimprime codigos na tela
  @ 07,40 SAY SUBS(pd_prn,19*VAL(padrao)-18,18)
  @ 08,40 SAY tapg PICT "@S28"
  @ 09,40 SAY pcom PICT "@S28"
  @ 10,40 SAY tcom PICT "@S28"
  @ 11,40 SAY pc20 PICT "@S28"
  @ 12,40 SAY tc20 PICT "@S28"
  @ 13,40 SAY peli PICT "@S28"
  @ 14,40 SAY teli PICT "@S28"
  @ 15,40 SAY penf PICT "@S28"
  @ 16,40 SAY tenf PICT "@S28"
  @ 17,40 SAY pexp PICT "@S28"
  @ 18,40 SAY texp PICT "@S28"
  @ 19,40 SAY pde8 PICT "@S28"
  @ 20,40 SAY tde8 PICT "@S28"
  @ 21,40 SAY land PICT "@S28"
  @ 22,40 SAY port PICT "@S28"
  SETCOLOR(x)
 ENDI
ENDI
RETU mar_                                 // retorna sempre verdade

FUNC IMP_PADRAO(p)   // escolhe o padrao
LOCAL op_:=1, msg
PRIV  cod_sos:=61
IF !EMPTY(p)                              // se esta alterando uma conf
 op_=VAL(p)                               // procura o default
ENDI
op_=DBOX(pd_prn,05,60,E_MENU,,,,,op_)     // apresenta menu de padroes
IF op_>0                                  // escolheu um...
 x=SETCOLOR(drvtittel)                    // reimprime nome do padrao
 @ 07,40 SAY SUBS(pd_prn,19*op_-18,18)
 SETCOLOR(x)
 op_=LTRIM(STR(op_))
ELSE
 op_=""
ENDI
RETU op_                                  // retorna sempre verdade

FUNC IMP_PORTA(p,l_,c_,ap_ja_,msgT)    // menu de portas ativas
LOCAL msg:="", t, op_, tp_sai_:=""
PRIV  cod_sos:=37
FOR t=1 TO 3                                // verifica quais as portas
 IF PARALELA(t)                             // paralelas estao ativa
  msg+="|Lpt"+STR(t,1)                      // para montar a varivel que
 ENDI                                       // contera o menu de portas
NEXT                                        // ativas
FOR t=1 TO 4
 IF SERIAL(t)                               // idem para os portas
  msg+="|Com"+STR(t,1)                      // seriais...
 ENDI
NEXT
IF !EMPTY(msg)                              // existe pelo menos um porta?
 op_=AT(UPPER(p),UPPER(msg))
 msg=SUBS(msg,2)
 op_=IF(op_>0,CONTA("|",LEFT(msg,op_))+1,1) // acha o defautl do menu
 op_=DBOX(msg,l_,c_,E_MENU,ap_ja_,msgT,,,op_)// apresenta menu
 IF op_>0                                   // escolheu uma...
  tp_sai_=UPPER(SUBS(msg,1+5*(op_-1),4))    // forca conteudo da porta
 ENDI
ENDI
RETU tp_sai_                                // retorna sempre verdade

FUNC POE_GAUGE(msg_,tit_,tit_reg)  // coloca gauge na tela
STATIC l_g, c_g, ct_g:=0, so_conta // linha e coluna do inicio gauge
LOCAL x, defa_dev, i
IF msg_!=NIL                      // mensagem da dbox
 so_conta=(tit_reg!=NIL)          // vai contar ou colocar %
 ct_g=0                           // contador de registro ja processados
 IF so_conta                      // se vai contar concatena msg que
  msg_+="|*|"+tit_reg+"       0"  // vamos mostrar qtde de reg processados
 ELSE                             // processo em todo o arq
  msg_+="|*|"+REPL("°",20)        // concatena gauge no final
 ENDI
 x=DBOX(msg_,,,,NAO_APAGA,tit_)   // coloca msg na tela
 SETCOLOR(drvtitbox)              // cor do titulo para gauge
 l_g = VAL(PARSE(@x,"|"))         // linha e
 c_g = VAL(x)                     // coluna de inicio do gauge
 IF so_conta                      // vai contar registro
  c_g+=LEN(tit_reg)+1             // posiciona cursor apos msg de proc
 ENDI
ELSE                              // coloca o gauge
 ct_g++                           // conta quantos ja foi feito
 IF so_conta                      // gauge em contador
  IF INT(ct_g/30)=ct_g/30         // mostra em 30 em 30
   x=RIGHT(SPACE(8)+STR(ct_g),8)  // coloca qtde na tela sem
   FOR i=1 TO 8                   // usar o SAY (pode estar imprimindo)
    POKE(-18432,(l_g*160)+((c_g+i)*2),ASC(SUBS(x,i+1,1)))
   NEXT
  ENDI
 ELSE                             // gauge com percentual
  @ l_g,c_g SAY REPL("Û",MIN(ct_g,20)) // coloca na msg
 END IF
ENDI
RETURN .t.                        // sempre retorna verdadeiro
/*
   Sintaxe: POINTER_DBF( [ExpA] [,ExpL] )
   Funcao.: acha/restaura ponteiro dos dbf do vetor sistema
               ExpA = arranjo de RECNO() dos dbf do vetor sistema
               ExpL = se .t. deixa abertos os dbf's usados apos salvamento
   Retorna: arranjo de RECNO() dos dbf do vetor sistema
*/
FUNC POINTER_DBF(reg_dbf, deixa_ab)
LOCAL t, i_, ar_, i_reg, i_ord, i_tmp, db_, db_s, repoe:=(reg_dbf!=NIL), rel_dbf:={}, seq_dbf, cp_, db_r
PRIV cpord:="", criterio:="", chv_rela:="", chv_1:=""
deixa_ab=IF(deixa_ab=NIL,.f.,deixa_ab)
IF !repoe                        // ira retornar os RECNO() de cada dbf
 reg_dbf:={}                     // inicializa vetor de retorno
 ar_=ALIAS()                     // salva area atual
ENDI
FOR t=1 TO nss                   // para cada sistema do vetor sistema...
 db_=sistema[t,O_ARQUI,O_NOME]   // nome do dbf
 db_s=LEFT(db_,3)+"_SEQ"       // nome do dbf de sequencia
 IF repoe                        // vai repor os ponteiros dos dbf's
  IF reg_dbf[t,1]>=0             // se o arquivo estava aberto
   IF !EMPTY(SELECT(db_))         // se o dbf esta aberto
    IF LEN(reg_dbf[t,3])=0 .AND. LEN((db_)->(INDEXKEY(LEN(sistema[t,O_INDIC])+1)))>0
     CLOSE (db_)                  // e ind tmp nao for o mesmo
    ENDI                          // fecha arq para abrir ind novamente
   ENDI

   #ifdef COM_REDE
    USEARQ(db_,.f.)              // selecina ou abre o arquivo
   #else
    USEARQ(db_)                  // selecina ou abre o arquivo
   #endi

   IF LEN(reg_dbf[t,3])>0        // tinha indice temporario
    IF INDEXKEY(LEN(sistema[t,O_INDIC])+1)<>reg_dbf[t,3]
     cpord=reg_dbf[t,3]          // se nao for o mesmo
     INDTMP()                    // indexa novamente
    ENDI
   ENDI
   DBSETORDER(reg_dbf[t,2])      // restaura o indice e o
   GO reg_dbf[t,1]               // seu ponteiro
   SET RELA TO                   // retira todas as relacoes existentes
   IF reg_dbf[t,5]>=0            // se tem sequencial
    USEARQ(db_s,.f.,,,.f.)       // abre arquivo de cps sequencial
    GO reg_dbf[t,5]              // e reposiciona seu ponteiro
   ENDI
  ELSE                           // se o arquivo estava fechado
   IF !EMPTY(SELECT(db_)) .AND.; // e agora esta aberto
      !deixa_ab                  // e quer fechar,
    CLOSE (db_)                  // entao vamos fecha-lo
   ENDI
  ENDI
 ELSE                            // acha situacao dos dbf's
  IF !EMPTY(SELECT(db_))         // se o dbf esta aberto
   i_reg=(db_)->(RECNO())        // pega o seu ponteiro
   i_ord=(db_)->(INDEXORD())  // e o seu indice atual
   i_tmp=(db_)->(INDEXKEY(LEN(sistema[t,O_INDIC])+1)) // indice temporario
   rel_dbf:={}                   // relacoes do arquivo
   i_=1                          // pega todas que existir
   DO WHILE LEN((db_)->(DBRELATION(i_)))>0
    AADD(rel_dbf,{(db_)->(DBRELATION(i_)),ALIAS((db_)->(DBRSELECT(i_)))}) // adiciona ponteiro ao vetor de retorno
    i_++
   ENDD
   IF !EMPTY(SELECT(db_s))       // se o dbf de sequencial esta aberto
    seq_dbf=(db_s)->(RECNO())    // pega o seu ponteiro
   ELSE
    seq_dbf=-1                   // nao tem cp sequencial
   ENDI
  ELSE                           // caso contrario vamos
   i_tmp=""
   i_reg:=i_ord:=seq_dbf := -1   // nao tem relacao zera o vetor
   rel_dbf:={}
  ENDI
  AADD(reg_dbf,{i_reg,i_ord,i_tmp,rel_dbf,seq_dbf}) // adiciona ponteiro ao vetor de retorno
 ENDI
NEXT
IF !repoe                        // se esta enchendo o vetor, adiciona
 AADD(reg_dbf,ar_)               // a area atual no ultimo elemento
ELSE                             // se esta restabelecendo,
 FOR t=1 TO nss                  // vamos recolocar as relacoes...
  db_=sistema[t,O_ARQUI,O_NOME]  // nome do dbf
  IF LEN(reg_dbf[t,4])>0         // tem relacoes?
   SELE (db_)                    // vai para area do dbf
   FOR i_=1 TO LEN(reg_dbf[t,4]) // e corre todos as relacoes anteriores
    cp_=reg_dbf[t,4,i_,1]        // expresao de ligacao
    db_r=reg_dbf[t,4,i_,2]       // dbf de ligacao
    SET RELA ADDI TO &cp_. INTO &db_r. // recoloca a relacao
   NEXT
  ENDI
 NEXT
 IF LEN(reg_dbf[nss+1])>0        // se tinha dbf aberto na area atual
  SELE (reg_dbf[nss+1])          // vamos abri-lo
 ELSE
  SELE 0                         // abre primeira area livre
 ENDI
ENDI
RETU reg_dbf                     // retorna vetor

/*
   Sintaxe: VDBF( <N1> <,N2> <,N3> <,N4> <,ExpC1> [,ExpA1] [,ExpN] [,ExpC2] [,ExpC3])
   Funcao.: Abre janela de consulta a outro arquivo da aplicacao
              N1,N2,N3,N4 = coordenadas da janela
                    ExpC1 = nome do arquivo a ser consultado
                    ExpA1 = arranjo de campos a mostrar na consulta
                     ExpN = ordem do indice associado ao arquivo
                    ExpC2 = campo a ser transferido para o get pendente
                    ExpC3 = expressao de filtro inicial
   Retorna: logico sempre .t.
*/
FUNC VDBF(l_1,c_1,l_2,c_2,db,cp_db,ord_db,cp_trans,fil_db)
LOCAL v_ar, v_:=SAVESCREEN(0,0,MAXROW(),79), t_w, t_r, t_c, t_7, t_9,;
      reg_dbf:={}, ret_val, del_a
PRIV tela_fundo, cod_sos:=10
v_ar=READVAR()
ord_db=IF(ord_db=NIL,1,ord_db)
reg_dbf=POINTER_DBF()                     // salva situacao de todos dbf's
del_a:=SET(_SET_DELETED,!drvvisivel)      // coloca visibilidade escolhida
tem_t=.f.
IF !EMPTY(v_ar)                           // alguma variavel pendente?
 IF VALTYPE(&v_ar.) $ "CNDL" .AND.;       // se for caracter, numerica, data
    !EMPTY(&v_ar.)                        // ou logico e tiver conteudo
  tem_t=!("OP_" $ UPPER(v_ar))            // e nao for de menu, pode
  v_ar=TRIM(TRANSCAMPO(.t.,v_ar))         // transferir para o get pendente
 ENDI
ENDI
PTAB(IF(tem_t,v_ar,"%^"),db,1)            // abre arquivo e tenta posicionar

#ifdef COM_REDE
 IF NETERR()                              // se ocorreu erro de abertura
  RETU .t.                                // retorna
 ENDI
#endi

SELE (db)                                 // seleciona o arquivo escolhido
IF EOF()                                  // se fim de arquivo,
 DBSETORDER(ord_db)                       // vai para o indice desejado
 GO TOP                                   // vai para o 1o. registro
ELSE
 DBSETORDER(ord_db)                       // vai para o indice desejado
ENDI
t_w:=SETKEY(K_CTRL_W,NIL)                 // desabilita e salva
t_r:=SETKEY(K_CTRL_R,NIL)                 // as teclas de controle
t_c:=SETKEY(K_CTRL_C,NIL)
t_7:=SETKEY(K_F7,NIL); t_9:=SETKEY(K_F9,NIL)
IF sistema[EVAL(qualsis,ALIAS()),O_OUTROS,O_NIVEL]>nivelop
 ALERTA()                                 // usuario nao tem permissao
 DBOX(msg_auto,,,3)                       // avisa
ELSE
 l_2=IF(l_2-l_1-1>RECC(),l_1+RECC()+1,l_2)
 v_out=.t.
 EDITA(l_1,c_1,l_2,c_2,.t.,cp_db,,fil_db)
 IF LASTKEY()!=K_ESC .AND. cp_trans!=NIL
  ret_val=&cp_trans.
 ENDI
 v_out=.f.
ENDI
SET(_SET_DELETED,del_a)                   // retorna a visibilidade dos excluidos
POINTER_DBF(reg_dbf)                      // restaura ponteiro dos dbf's
SETKEY(K_CTRL_W,t_w)                      // restaura teclas de controle
SETKEY(K_CTRL_R,t_r)
SETKEY(K_CTRL_C,t_c)
SETKEY(K_F7,t_7); SETKEY(K_F9,t_9)
RESTSCREEN(0,0,MAXROW(),79,v_)            // restaura tela
RETU ret_val


#ifdef COM_MOUSE

 /*
    Sintaxe: MOUSETECLA( [N1] [,N2] [,N3] [,N4] [,ExpL] )
    Funcao.: Aguarda digita‡„o de tecla com controle de mouse
               N1,N2,N3,N4 = janela de avaliacao
                      ExpL = .f. somente as bordas da janela serao verificadas
    Retorna: codigo ASCII da tecla digitada
 */
 FUNC MOUSETECLA(l1,c1,l2,c2,cx_toda)
 LOCAL tecl_p, i, li:=1, co:=1, clic:=0, Tp_Sai, lin_cur, col_cur,;
       cur_, e_calc:=(PROCNAME(3)="MAQCALC")
 IF drvmouse                            // mouse esta' ligado?
  lin_cur=ROW()                         // salva linha e
  col_cur=COL()                         // coluna atual do mouse
  cur_=SETCURSOR()                      // setuacao atual do cursor
  IF e_calc                             // mouse na calculadora
   l1=lisu_+5                           // ajusta area de atuacao do mouse
   c1=cosu_+2
   l2=lisu_+8
   c2=cosu_+22
  ELSE
   l1=IF(l1=NIL,0,l1)                   // acha a area de atuacao do mouse
   c1=IF(c1=NIL,0,c1)
   l2=IF(l2=NIL,MAXROW(),l2)
   c2=IF(c2=NIL,79,c2)
  ENDI
  cx_toda=IF(cx_toda=NIL,.t.,cx_toda)   // avalia toda a area de atuacao do mouse?
  MOUSEBOX(l1,c1,l2,c2)                 // define area do mouse
  Tecl_p=0
  MOUSECUR(.t.)                         // liga cursor do mouse

  #ifdef COM_REDE
   Tp_Sai=SECONDS()+drvtempo            // tempo de "refresh"
  #endi

  DO WHIL Tecl_p=0

   #ifdef COM_REDE
    IF drvtempo>0.AND.SECONDS()>Tp_Sai  // see' tempo do "refresh"
     EXIT                               // cai fora...
    ENDI
   #endi

   DO WHILE (clic:=MOUSEGET(@li,@co))>0 // espera um clique do mouse
    IF SECONDS()>tpo_mouse              // botao do mouse retido por mais de 1 seg,
     EXIT                               // significa mouse sendo arrastado com
    ENDI                                // o botao apertado
   ENDD
   tecl_p=NEXT_KEY()                    // le tecla do buffer do teclado
   IF tecl_p=0                          // esta vazio
    IF clic=ESQUERDO                    // botao esquerdo pressionado
     tecl_p=CLICK
     IF li=l1 .OR. li=l2 .OR. cx_toda   // avalia onde foi o clique
      IF CLICK_EM(gcr,li,co)
       tecl_p=K_ENTER
      ELSEIF CLICK_EM("F10",li,co)
       tecl_p=K_F10
      ELSEIF CLICK_EM("F9",li,co)
       tecl_p=K_F9
      ELSEIF CLICK_EM("F8",li,co)
       tecl_p=K_F8
      ELSEIF CLICK_EM("F4",li,co)
       tecl_p=K_F4
      ELSEIF CLICK_EM("F3",li,co)
       tecl_p=K_F3
      ELSEIF CLICK_EM("TAB",li,co)
       tecl_p=K_TAB
      ELSEIF CLICK_EM(CHR(27),li,co)
       tecl_p=K_LEFT
      ELSEIF CLICK_EM(CHR(26),li,co)
       tecl_p=K_RIGHT
      ELSEIF CLICK_EM(CHR(24),li,co)
       tecl_p=K_UP
      ELSEIF CLICK_EM(CHR(25),li,co)
       tecl_p=K_DOWN
      ELSEIF CLICK_EM("PgUp",li,co) .OR. CLICK_EM(CHR(30),li,co)
       tecl_p=K_PGUP
      ELSEIF CLICK_EM("PgDn",li,co) .OR. CLICK_EM(CHR(31),li,co)
       tecl_p=K_PGDN
      ELSEIF CLICK_EM("Topo",li,co) .OR. CLICK_EM(CHR(174),li,co)
       tecl_p=K_CTRL_PGUP
      ELSEIF CLICK_EM("Fim",li,co)  .OR. CLICK_EM(CHR(175),li,co)
       tecl_p=K_CTRL_PGDN
      ELSEIF CLICK_EM(CHR(18),li,co)
       tecl_p=74
      ELSEIF e_calc                     // clique da calculadora sobre
       msg="1234567890.+-*/%^#$C=R"     // um numero ou sinal
       FOR i=1 TO LEN(msg)
        IF CLICK_EM(SUBS(msg,i,1),li,co)
         tecl_p=ASC(SUBS(msg,i,1))
         EXIT
        ENDI
       NEXT
      ENDI
     ENDI
    ELSEIF clic=DIREITO                 // botao da direita
     tecl_p=K_ESC                       // abandona com ESC
    ELSE
     tpo_mouse=-1                       // reseta o tempo do mouse
    ENDI
    IF tecl_p>2                         // tecla de funcao clicada
     KEYB CHR(tecl_p)                   // forca tecla no buffer do teclado
     IN_KEY(0)
    ENDI
   ELSE
    IN_KEY(0)                           // recebe tecla digitada
   ENDI
  ENDD
  MOUSECUR(.f.)                         // deliga cursor do mouse
  tpo_mouse=IF(tpo_mouse=-1,SECONDS()+1,tpo_mouse)
  IF cur_!=0
   SETPOS(lin_cur,col_cur)              // retorna o cursor a posicao original
  ENDI
 ELSE                                   // mouse esta' desligado...

  #ifdef COM_REDE
   tecl_p=IN_KEY(drvtempo)              // faz "refresh" a cada drvtempo seg
  #else
   tecl_p=IN_KEY(0)                     // aguarda usuario teclar algo
  #endi

 ENDI
 RETU tecl_p                            // retorna tecla desejada

 /*
    Sintaxe: CLICK_EM( <ExpC> <,ExpN1> <,ExpN2> )
    Funcao.: Verifica se ExpC esta sobre as coordenadas ExpN1 e ExpN2
    Retorna: .t. se teve sucesso
 */
 STATIC FUNC CLICK_EM(te_cl,li,co)
 LOCAL t_s:="", t1, t2, t_
 t1=LEN(te_cl)                          // salva trecho de tela nas
 t_ := SAVESCREEN(li,co-t1,li,co+t1)    // coordenadas do clique
 t1=LEN(t_)
 FOR t2=1 TO t1 STEP 2                  // separa os atributos das letras
  t_s+=SUBST(t_,t2,1)                   // do trecho salvo
 NEXT
 t1=AT(te_cl,t_s)                       // tecla esta sob o cursor?
 IF t1>0                                // verifica se a tecla nao e'
  t2=ASC(SUBS(t_s,t1-1,1))              // um pedaco de palavvra
  t1=ASC(SUBS(t_s,t1+LEN(te_cl),1))
  IF (t1<65 .OR. t1>125) .AND. (t2<65 .OR. t2>125)
   RETU .t.                             // ok. a tecla foi clicada
  ENDI
 ENDI
 RETU .f.                               // a tecla nao foi clicada

#endi


PROC PWU_incl(reg_cop)  // inclusao no arquivo PWUSUA
LOCAL getlist:={},cabem:=1,rep:=ARRAY(FCOU()),ult_reg:=RECN(),dbfseq_,;
      ctl_r, ctl_c, t_f3_, t_f4_, l_max
PRIV op_menu:=INCLUSAO, sq_atual_, op_sis, l_s, c_s, l_i, c_i, cod_sos, chv_rela, chv_1, chv_2, tem_borda, criterio:="", cpord:="", l_a
op_sis=EVAL(qualsis,"PWUSUA")
chv_rela=""
FOR i=1 TO LEN(sistema[op_sis,O_CPRELA])
 chv_rela+="+"+TRANSCAMPO(.f.,sistema[op_sis,O_CPRELA,i],i)
NEXT
chv_rela=IF(LEN(chv_rela)>2,SUBS(chv_rela,2),"")
PEGACHV2()
FOR i=1 TO FCOU()                         // cria/declara privadas as
 msg=FIEL(i)                              // variaveis de memoria com
 PRIV &msg.                               // o mesmo nome dos campos
NEXT                                      // do arquivo
IF reg_cop!=NIL                           // quer repetir todo o reg atual
 FOR i=1 TO FCOU()                        // para cada campo,
  msg=FIEL(i)                             // salva o conteudo
  rep[i]=&msg.                            // para repetir
 NEXT
ELSE
 AFILL(rep,"")                            // eche com valor vazio
ENDI
t_f3_=SETKEY(K_F3,{||rep()})              // repeticao reg anterior
t_f4_=SETKEY(K_F4,{||conf()})             // confirma campos com ENTER
ctl_w=SETKEY(K_CTRL_W,{||nadafaz()})      // enganando o CA-Clipper...
ctl_c=SETKEY(K_CTRL_C,{||nadafaz()})
ctl_r=SETKEY(K_CTRL_R,{||nadafaz()})
DISPBEGIN()                               // monta tela na pagina de traz
IMPRELA()                                 // imp telas do pai
PWU_TELA()                                // imp tela para inclusao
INFOSIS(.t.)                              // exibe informacao no rodape' da tela
l_a=Sistema[op_sis,O_TELA,O_SCROLL]
DISPEND()                                 // apresenta tela de uma vez so
DO WHIL cabem>0
 rola_t=.f.                               // flag se quer rolar a tela
 SELE PWUSUA
 M->pw_codigo="0001"                      // procura proximo numero do usuario
 GO TOP
 DO WHILE !EOF()                          // corre todo dbf e ve qual o valor do maior cod do usuario
  IF VAL(DECRIPT(pw_codigo))>=VAL(M->pw_codigo)
   M->pw_codigo=LPAD(STR(VAL(DECRIPT(pw_codigo))+1),4,[0])
  ENDI
  SKIP
 ENDD
 
 /*
    cria variaveis de memoria identicas as de arquivo, para inclusao
    de registros
 */
 FOR i=3 TO FCOU()
  msg=FIEL(i)
  M->&msg.=IF((fgrep .OR. reg_cop!=NIL).AND.!EMPT(rep[1]),DECRIPT(rep[i]),&msg.)
 NEXT
 
 /*
    inicializa campos de relacionamentos do com os campos do arquivo
    superior (grupo)
 */
 FOR i=1 TO LEN(sistema[op_sis,O_CPRELA])
  msg=FIEL(VAL(SUBS(sistema[op_sis,O_ORDEM,1],i*2-1,2)))
  M->&msg.=DECRIPT(&(sistema[op_sis,O_CPRELA,i]))
 NEXT
 cabem=DISKSPACE(;                        // pode incluir mais...
          IF(;
             LEN(sistema[op_sis,O_ARQUI,O_DIR_DBF])<2.OR.sistema[op_sis,O_ARQUI,O_DIR_DBF]="\",;
             0,;
             ASC(sistema[op_sis,O_ARQUI,O_DIR_DBF])-64;
          );
       )
 cabem=INT((cabem-2048)/PWUSUA->(RECSIZE()))
 IF cabem<1                               // mais nenhum!!!
  ALERTA()
  msg="Verifique ESPA€O EM DISCO, "+usuario
  DBOX(msg,,,,,"INCLUSŽO INTERROMPIDA!")  // vamos parar por aqui!
  EXIT
 ENDI
 SELE 0                                   // torna visiveis variaveis de memoria
 PWU_GET1(INCLUI)                         // recebe campos
 SELE PWUSUA
 IF LASTKEY()=K_ESC                       // se cancelou
  cabem=0                                 // prepara saida da inclusao
  LOOP
 ENDI

 #ifdef COM_REDE
  GO BOTT                                 // vamos bloquear o final do
  SKIP                                    // arq para que nehum outro
  BLOREG(0,.5)                            // usuario possa incluir
 #endi

 M->pw_grupo=ENCRIPT(M->pw_grupo)

 APPEND BLANK                             // inclui reg em branco no dbf
 FOR i=1 TO FCOU()                        // para cada campo,
  msg=FIEL(i)                             // salva o conteudo
  rep[i]=M->&msg.                         // para repetir
  REPL &msg. WITH rep[i]                  // enche o campo do arquivo
 NEXT

 #ifdef COM_REDE
  UNLOCK                                  // libera o registro e
  COMMIT                                  // forca gravacao
 #else
  IF RECC()-INT(RECC()/20)*20=0           // a cada 20 registros
   COMMIT                                 // digitados forca gravacao
  ENDI
 #endi

 TROCASENHA(.t.,DECRIPT(pw_nome))         // digita a senha

 ult_reg=RECN()                           // ultimo registro digitado
 l_max=l_s+Sistema[op_sis,O_TELA,O_SCROLL]+Sistema[op_sis,O_TELA,O_QTDE]
 IF l_s+l_a+1<l_max                       // se nao atingiu o fim da tela
  l_a++                                   // digita na proxima linha
 ELSE                                     // se nao rola a campos para cima
  SCROLL(l_s+Sistema[op_sis,O_TELA,O_SCROLL],c_s+02,l_max-1,c_s+05,1)
  SCROLL(l_s+Sistema[op_sis,O_TELA,O_SCROLL],c_s+11,l_max-1,c_s+25,1)
  SCROLL(l_s+Sistema[op_sis,O_TELA,O_SCROLL],c_s+29,l_max-1,c_s+29,1)
  SCROLL(l_s+Sistema[op_sis,O_TELA,O_SCROLL],c_s+37,l_max-1,c_s+51,1)
 ENDI
 IF reg_cop!=NIL                          // estava na consulta e quis rep o campo
  EXIT                                    // cai fora...
 ENDI
ENDD
GO ult_reg                                // para o ultimo reg digitado
SETKEY(K_F3,t_f3_)                        // restaura teclas de funcoes
SETKEY(K_F4,t_f4_)
SETKEY(K_CTRL_W,ctl_w)
SETKEY(K_CTRL_C,ctl_c)
SETKEY(K_CTRL_R,ctl_r)
RETU

PROC PWU_tela     // tela do arquivo PWUSUA
tem_borda=.t.
l_s=Sistema[op_sis,O_TELA,O_LS]           // coordenadas da tela
c_s=Sistema[op_sis,O_TELA,O_CS]
l_i=Sistema[op_sis,O_TELA,O_LI]
c_i=Sistema[op_sis,O_TELA,O_CI]
SETCOLOR(drvtittel)
vr_memo=NOVAPOSI(@l_s,@c_s,@l_i,@c_i)     // pega posicao atual da tela
CAIXA(mold,l_s,c_s,l_i,c_i)               // monta caixa da tela
i=LEN(sistema[op_sis,O_MENS])/2
@ l_s,c_s-1+(c_i-c_s+1)/2-i SAY " "+MAIUSC(sistema[op_sis,O_MENS])+" "
SETCOLOR(drvcortel)
@ l_s+01,c_s+1 SAY " C¢digo ³ Nome            ³ Nivel ³ Obs"
@ l_s+02,c_s+1 SAY "ÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ"
@ l_s+03,c_s+1 SAY "        ³                 ³       ³"
@ l_s+04,c_s+1 SAY "        ³                 ³       ³"
@ l_s+05,c_s+1 SAY "        ³                 ³       ³"
@ l_s+06,c_s+1 SAY "        ³                 ³       ³"
@ l_s+07,c_s+1 SAY "        ³                 ³       ³"
@ l_s+08,c_s+1 SAY "        ³                 ³       ³"
@ l_s+09,c_s+1 SAY "        ³                 ³       ³"
RETU

PROC PWU_gets     // mostra variaveis do arquivo PWUSUA
LOCAL getlist := {}, l_max, reg_atual:=RECNO()
PRIV  l_a:=Sistema[op_sis,O_TELA,O_SCROLL], _codigo, _nome, _nivel, _obs
PWU_TELA()
l_max=l_s+Sistema[op_sis,O_TELA,O_SCROLL]+Sistema[op_sis,O_TELA,O_QTDE]
SETCOLOR(drvcortel+","+drvcorget+",,,"+corcampo)
DO WHILE !EOF() .AND. l_s+l_a<l_max .AND.;
   &(INDEXKEY(0))=IF(EMPT(criterio),"","T")+chv_1
 _codigo=DECRIPT(pw_codigo)               // desencripta campos
 _nome=DECRIPT(pw_nome)                   // antes de mostrar
 _nivel=DECRIPT(pw_nivel)
 _obs=DECRIPT(pw_obs)
 @ l_s+l_a,c_s+02 GET  _codigo;
                  PICT sistema[op_sis,O_CAMPO,02,O_MASC]

 @ l_s+l_a,c_s+11 GET  _nome;
                  PICT sistema[op_sis,O_CAMPO,03,O_MASC]

 @ l_s+l_a,c_s+29 GET  _nivel;
                  PICT sistema[op_sis,O_CAMPO,04,O_MASC]

 @ l_s+l_a,c_s+37 GET  _obs

 SETCOLOR(drvcortel+","+drvcortel+",,,"+drvcortel)
 l_a++
 SKIP
ENDD
GO reg_atual
SETCOLOR(drvcortel+","+drvcorget+",,,"+corcampo)
CLEAR GETS
RETU

PROC PWU_get1(tp_mov, excl_rela)     // capta variaveis do arquivo PWUSUA
LOCAL getlist := {}
PRIV _codigo, _nome, _nivel, _obs
excl_rela=IF(excl_rela=NIL,.f.,excl_rela) // exclusao do pai?
IF tp_mov=INCLUI
 IF TYPE("l_a")!="N"                      // linha atual do scroll
  l_a=Sistema[op_sis,O_TELA,O_SCROLL]
 ENDI
 DO WHILE .t.
  rola_t=.f.
  SET KEY K_ALT_F8 TO ROLATELA
  SETCOLOR(drvcortel+","+drvcorget+",,,"+corcampo)
  IF op_menu=ALTERACAO                    // na alteracao
   _codigo=DECRIPT(pw_codigo)             // desencripta
   _nome=DECRIPT(pw_nome)                 // campos do arquivo
   _nivel=DECRIPT(pw_nivel)
   _obs=DECRIPT(pw_obs)
  ELSE                                    // na inclusao
   _codigo=M->pw_codigo                   // pega da memoria
   _nome=M->pw_nome                       // os campos ja desencriptados
   _nivel=M->pw_nivel
   _obs=M->pw_obs
  ENDI
  @ l_s+l_a,c_s+02 GET _codigo;           // mostra codigo do usuario
                   PICT sistema[op_sis,O_CAMPO,02,O_MASC]
  CLEA GETS
  @ l_s+l_a,c_s+11 GET  _nome;            // recebe os outros campos
                   PICT sistema[op_sis,O_CAMPO,03,O_MASC]
                   DEFINICAO 3

  @ l_s+l_a,c_s+29 GET  _nivel;
                   PICT sistema[op_sis,O_CAMPO,04,O_MASC]
                   DEFINICAO 4

  @ l_s+l_a,c_s+37 GET  _obs
                   DEFINICAO 5

  READ
  SET KEY K_ALT_F8 TO                     // desabilita alt+f8
  IF rola_t                               // quer rolar a tela
   ROLATELA()                             // entao deixa
   LOOP                                   // volta para digiracao
  ENDI
  IF LASTKEY()!=K_ESC .AND. drvincl .AND. op_menu=INCLUSAO
   IF !CONFINCL()                         // confirma inclusao
    LOOP                                  // nao confirmou...
   ENDI
  ENDI
  IF op_menu=ALTERACAO                    // na alteracao
   REPL pw_codigo WITH ENCRIPT(_codigo),; // encripta e grava
        pw_nome WITH ENCRIPT(_nome),;     // os campos no dbf
        pw_nivel WITH ENCRIPT(_nivel),;
        pw_obs WITH ENCRIPT(_obs)
  ELSE                                    // na inclusao
   M->pw_codigo=DECRIPT(_codigo)          // encripta variaveis
   M->pw_nome=DECRIPT(_nome)              // na memoria
   M->pw_nivel=DECRIPT(_nivel)
   M->pw_obs=DECRIPT(_obs)
  ENDI
  EXIT
 ENDD
ENDI
IF tp_mov=EXCLUI .OR. tp_mov=FORM_INVERSA

 #ifdef COM_REDE
  IF !excl_rela                         // esta excluindo o pai
   REPL flag_excl WITH '*'              // coloca uma marca
  ENDI
 #else
  IF !excl_rela                         // esta excluindo o pai
   REPL flag_excl WITH '*'              // coloca uma marca
  ENDI
 #endi

 DELE
ELSEIF tp_mov=INCLUI .OR. tp_mov=RECUPERA .OR. tp_mov=FORM_DIRETA
 IF (op_menu=INCLUSAO .AND. LASTKEY()!=K_ESC) .OR. op_menu!=INCLUSAO
  IF tp_mov=RECUPERA .AND. op_menu!=INCLUSAO .AND. (PWGRUPOS->(DELE()))
   msg="|"+sistema[EVAL(qualsis,"PWGRUPOS"),O_MENU]
   ALERTA(2)
   DBOX("Registro exclu¡do em:"+msg+"|*",,,,,"IMPOSS¡VEL RECUPERAR!")
  ELSE
   IF !excl_rela                       // esta recuperando o pai
    IF op_menu=INCLUSAO                // desfaz a flag
     flag_excl=' '
    ELSE
     REPL flag_excl WITH ' '
    ENDI
   ENDI
   IF op_menu!=INCLUSAO                // se nao esta incluindo
    RECA                               // recura o registro
   ENDI
  ENDI
 ENDI
ENDI
RETU

PROC TROCASENHA(_gerente,_usu)  // pega senha para cadastro
LOCAL rg_:=RECNO(), od_
PRIV cod_sos:=16,l_s,c_s,l_i,c_i, op_sis:=nss
SAVE SCREEN

#ifdef COM_REDE
 IF !USEARQ(sistema[nss,O_ARQUI,O_NOME])           // abre arq de usuarios
  RETU                                             // arquivo volta ao menu anterior
 ENDI
#else
 USEARQ(sistema[nss,O_ARQUI,O_NOME])               // abre arq de usuarios
#endi

DBSETORDER(2)                              // coloca no indice certo
SETCOLOR(drvtittel)                        // cor da tela
tem_borda=.t.
l_s=11; c_s=19; l_i=17; c_i=51             // coordenadas da tela
vr_memo=NOVAPOSI(@l_s,@c_s,@l_i,@c_i)      // pega posicao atual da tela
CAIXA(mold,l_s,c_s,l_i,c_i)                // monta caixa da tela
SETCOLOR(drvcortel)
@ l_s+01,c_s+1 SAY "     USURIO "+_usu    // com msg na tela
@ l_s+03,c_s+1 SAY IF(_gerente,"       Senha:"," Senha atual:")
@ l_s+04,c_s+1 SAY IF(_gerente," Confirma‡„o:"," Senha  nova:")
@ l_s+05,c_s+1 SAY "              (ESC recome‡ar)"
DO WHILE .t.
 SETCOLOR(drvcorbox)                       // cor da janela
 @ l_s+4,c_s+15 SAY SPAC(6)                // limpa na tela
 SETCOLOR(drvcorget)                       // coloca fundo
 @ l_s+3,c_s+15 SAY SPAC(6)                // da cor do get
 senha=PADR(PWORD(l_s+3,c_s+15),6)         // recebe a senha
 SETCOLOR(drvcorbox)                       // cor da janela
 @ l_s+3,c_s+15 SAY PADR(REPL("þ",LEN(RTRIM(DECRIPT(senha)))),6) // coloca senha na tela se fundo
 IF senha!=senhatu .AND. !EMPT(senha) .AND. _gerente=.f.  // epa! e' um ET!
  ALERTA()                                 // beep, beep, beep
  DBOX(_usu+",|Sua senha n„o confere!",14,40,3,,"ATEN€ŽO!")
  EXIT
 ELSEIF !EMPT(senha)                       // senao, pode alterar
  SETCOLOR(drvcorget)                      // coloca fundo
  @ l_s+4,c_s+15 SAY SPAC(6)               // da cor do get
  senhatu=PADR(PWORD(l_s+04,c_s+15),6)     // recebe nova senha
  SETCOLOR(drvcorbox)                      // coloca cor da janela
  IF senha!=senhatu                        // senha diferente da atual
   IF _gerente=.f.                         // nao e' o gernte
    SEEK ENCRIPT(PADR(_usu,15))+senhatu    // verifica se um outro usuario
    IF FOUND()                             // esta' usando esta senha
     ALERTA()
     msg="Senha inv lida"                  // boing... vamos dar qualquer
     DBOX(msg,l_s+04,c_s+19,3,,"ATEN€ŽO!") // aviso, a menos que esta senha
     @ l_s+03,c_s+15 SAY SPAC(6)           // pertenca a outro usuario
     @ l_s+04,c_s+15 SAY SPAC(6)
    ELSE                                   // senha ok.
     SEEK ENCRIPT(PADR(_usu,15))+senha     // posiciona sobre o registro

     #ifdef COM_REDE
      REPBLO("pw_pass",senhatu)             // bloqueia e muda a senha
     #else
      REPL pw_pass WITH senhatu             // e muda a senha
     #endi

     EXIT
    ENDI
   ELSE                                    // e' o gerente
    msg="Senha n„o confere!"               // entao avisa que
    DBOX(msg,l_s+04,c_s+19,3,,"ATEN€ŽO!")  // a senha nao confere
    @ l_s+03,c_s+15 SAY SPAC(6)
    @ l_s+04,c_s+15 SAY SPAC(6)
   ENDI
  ELSE                                     // senhas nao foi alterada
   IF _gerente                             // e' o gerente
    SEEK ENCRIPT(PADR(_usu,15))+senha      // verifica se um outro usuario
    IF FOUND()                             // esta' usando esta senha
     ALERTA()
     msg="Senha inv lida"                  // boing... vamos dar qualquer
     DBOX(msg,l_s+04,c_s+19,3,,"ATEN€ŽO!") // aviso, a menos que esta senha
     @ l_s+03,c_s+15 SAY SPAC(6)           // pertenca a outro usuario
     @ l_s+04,c_s+15 SAY SPAC(6)
     LOOP
    ELSE                                   // senha ok.
     GO rg_

     #ifdef COM_REDE
      REPBLO("pw_pass",senha)              // bloqueia e muda a senha
     #else
      REPL pw_pass WITH senha              // e muda a senha
     #endi

    ENDI
   ENDI
   EXIT                                    // cai fora
  ENDI
 ENDI
ENDD
DBSETORDER(1)                              // retorna a ordem original
GO rg_
REST SCREEN
RETU

/*
   Sintaxe: CRIADBF()
   Funcao.: Verifica e cria os arquivos DBF e NTX, quando nao existirem.
   Retorna: .t. se teve sucesso
*/
FUNC CRIADBF
LOCAL tel_a:=SAVESCREEN(0,0,MAXROW(),79), cur_atual:=SETCURSOR(0)  // salva a tela/cursor
FOR i=1 TO nss                              // para cada subsistema,
 dbf=sistema[i,O_ARQUI,O_DIR_DBF]+sistema[i,O_ARQUI,O_NOME]; harq=.f. // obtem nome do DBF
 IF !FILE(dbf+".dbf")                       // existe?
  IF i=1
   cod_sos=1
   ALERTA(3)                                // beep, beep, beep
   msg="Criar os arquivos|"+;               // confirma a criacao
       "Abandonar a opera‡„o"
   op_=DBOX(msg,,,E_MENU,,"ARQUIVOS NŽO ENCONTRADOS")
   IF op_!=1
    RETU (.f.)                              // retorna .f. pois abandonou
   ENDI
  ENDI
  harq=.t.                                  // monta o nome do modulo
  stru=LEFT(sistema[i,O_ARQUI,O_NOME],3)+"_estr" // que cria a estrutura
  DBOX(dbf+".DBF",,,,NAO_APAGA,"CRIANDO")   // avisa...
  &stru.()                                  // e cria a estrutura
  RESTSCREEN(0,0,MAXROW(),79,tel_a)         // restaura a tela
 ENDI
 FOR t=1 TO LEN(sistema[i,O_INDIC])         // para cada indice do subsistema
  ntx=sistema[i,O_ARQUI,O_DIR_NTX]+sistema[i,O_INDIC,t] // obtem nome do indice
  IF !FILE(ntx+EXTENSAO()).OR.harq          // se nao existir ou criou estrutura
   POE_GAUGE(ntx+EXTENSAO(),"CRIANDO")      // vamos criar...

   #ifdef COM_REDE
    IF !USEARQ(dbf,.t.,20,1,.f.)            // tenta abrir arquivo modo exclusivo
     SETPOS(23,1)
     RETU (.f.)                             // retorna .f., pois nao conseguiu
    ENDI
   #else
    USEARQ(dbf,,,,.f.)                      // abre arquivo e indexa
   #endi

   INDE ON &(sistema[i,O_CHAVE,t]) TO (ntx) EVAL POE_GAUGE() EVERY (LASTREC()/20)
   RESTSCREEN(0,0,MAXROW(),79,tel_a)        // restaura tela
  ENDI
 NEXT
 CLOS ALL                                   // fecha tudo
NEXT
dbfparam="PAR_ADM"
SELE A

#ifdef COM_REDE
 USEARQ(dbfparam,.t.,,,.f.)
#else
 USEARQ(dbfparam)
#endi

/*
   se nao existir nenhum registro no arquivo cria-o e coloca o valor
   inicial para cada um dos campos
*/
IF EOF() .OR. BOF()
 APPE BLAN
 REPL nrcanc WITH 000000
 REPL contarec WITH [RECEP]
 REPL contapag WITH [RECEP]
 REPL histrccar WITH LPAD([004],03,[0])
 REPL histrcfcc WITH LPAD([001],03,[0])
 REPL histrcrec WITH LPAD([002],03,[0])
 REPL histpg WITH LPAD([003],03,[0])
 REPL p_cidade WITH [LIMEIRA]
 REPL p_recp WITH [S]
 REPL setup1 WITH [Ind£stria de Urnas Bignotto Ltda]
ENDI

/*
   cria variaveis de memoria publicas identicas as de arquivo,
   para serem usadas por toda a aplicacao
*/
FOR i=1 TO FCOU()
 msg=FIEL(i)
 M->&msg.=&msg.
NEXT
USE
SETCURSOR(cur_atual)                        // retorna o cursor ao normal
RETU (.t.)                                  // retorna .t. - ok

/*
   Sintaxe: IMPEXP(<ExpN1> <,ExpN2> <,Exp> <,ExpN3> )
   Funcao.: Imprime conteudo expandido na impressora
              ExpN1 = linha a imprimir o conteudo
              ExpN2 = coluna a imprimir o conteudo
              Exp   = expressao a imprimir
              ExpN3 = largura total ocupada pela expressao
   Retorna: NIL
*/
FUNC IMPEXP(l_,c_,cp_,lg_)
@ l_,c_ SAY &drvpexp.+TRAN(cp_,"")+&drvtexp. // imprime campo expandido
SETPRC(l_,c_+lg_)                            // e ajusta o "carro" da
RETURN NIL                                   // impressora

/*
   Sintaxe: IMPCTL( <ExpC> )
   Funcao.: Imprime codigo de controle na impressora
              ExpC = codigo de controle
   Retorna: NIL
*/
FUNC IMPCTL(ctl_)
LOCAL li_:=PROW(), co_:=PCOL() // salva posicao do carro da impressora
IF LEN(ctl_)>0                 // se foi passado um codigo de controle
 lp_=SET(_SET_PRINTER,.t.)     // liga "echo" para impressora
 lc_=SET(_SET_CONSOLE,.f.)     // desliga saidas para video
 ?? &ctl_.                     // imprime caracteres de controle
 SET(_SET_PRINTER,lp_)         // retorna o "echo" original da impressora
 SET(_SET_CONSOLE,lc_)         // impressao no video habilitada
 SETPRC(li_,co_)               // retorna cabeca impressora
ENDI
RETURN NIL                     // para a posicao original

/*
   Sintaxe: IMPMEMO( <ExpM> <,N1> <,N2> <,N3> <,N4> <,ExpL> )
   Funcao.: Imprime campo "memo" em relat¢rio
              ExpM = campo "memo" a imprimir
              N1   = largura do campo "memo"
              N2   = linha a extrair e imprimir do campo "memo"
              N3/N4= linha e coluna onde sera impressa a linha
              ExpL = se .t., imprime alinhado
   Retorna: NIL
*/
FUNC IMPMEMO(cp_,tam_,nl_,l_,c_,just_)
LOCAL i_:=.f., ii_:=MEMOLINE(cp_,tam_,nl_)
IF just_.AND.RIGHT(RTRIM(ii_),1)!="."  // nao vamos justificar a
 i_=.t.                                // ultima linha do memo
ENDI
IMPAC(ii_,l_,c_,i_)                    // imprime linha do memo acentuada
RETU NIL

/*
   Sintaxe: MANUREF( <ExpC1> <,ExpC2> [,ExpN] <,ExpL> )
   Funcao.: Executa integridade referencial em tabelas
              ExpC1 = chave de acesso ao arquivo em ExpC2
              ExpC2 = arquivo alvo do processo de integridade
              ExpN  = ordem de pesquisa no arquivo. Se omitida, sera 1.
              ExpL  = se .t., soma mais 1 no campo de integridade (INTREF),
                      senao diminui 1.
   Retorna: NIL
*/
FUNC MANUREF(ch_,db_,or_dem,soma_)
or_=or_dem
IF TYPE("or_")="L"                            // ajusta parametros passados
 soma_=or_                                    // se soma ou dininui e a
 or_=1                                        // ordem do indice de pesquisa
ENDI
soma_=IF(soma_,1,-1)                          // transforma logico em numero
IF PTAB(ch_,db_,or_)                          // acha o reg referenciado

 #ifdef COM_REDE
  REPBLO(db_+'->intref',&("{||"+db_+"->intref+"+STR(soma_)+"}"))// atualiza cp da referencia
 #else
  REPL &db_.->intref WITH &db_.->intref+soma_ // atualiza cp da referencia
 #endi

ENDI
RETU NIL

* \\ Final de ADR_FUN2.PRG
GAS-Pro v3.0
011021014062001001019001012000176001
 Processo:
 Confirme:
[Ÿ]
[Ÿ]
 2 
 0 
Recibo Aux.Funeral 1
Recibo Aux.Funeral 1







056







 0 
 0 
-1 
-1 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
rproc
C
E
@R 99999/9999-99
 11 
 13 
 1 
 12 
 0 
Processo

!EMPT(RPROC).AND.PTAB(rproc,[AFUNER],1)
Campo utilizado para localiza‡„o dos documentos.|Tecle F8 para busca em tabela
IIF(PTAB(PADR(SUBSTR(M->ide_maq,2),4)+[AFU],[IMPPAR],1),ALLTRIM(IMPPAR->docto),[])
Digite neste campo o n£mero de|identifica‡„o do processo
VDBF(6,12,20,77,'AFUNER',{'processo','proc2','categ','contrato','falecido'},1,'V02001F9()',[])
 0 
 0 


confirme
C
E
!
 1 
 1 
 2 
 12 
 0 
Confirme

confirme='S'.AND.V02002F9()
CONFIRME n„o aceit vel|Digite S para confirmar|ou|Tecle ESC para cancelar

Digite S para confirmar|ou|tecle ESC para cancelar

 0 
 0 


 0 
 0 
 0 
 0 
 0 
€
 ADM_R020Y–ì  ADM_R020CODEREL_CABCODER02BP1F9CODEC_ETEXTENDCODE	_SYMSTARTSYMSTARTSYMBOLSSYMBOLS_SYMENDSYMENDNULLBEGDATA_DATADATA_SYMPBDATA_SYMPDATA_SYMPEDATA_CONSTCONST_MSGMSG_BEGBSSBEGBSS_BSSBSS_ENDBSSENDBSSDGROUP²˜ @ˆ|˜ @!õ˜ @ ñ˜ H  	˜ h  
ã˜ `Ð˜ h  Û˜ h  ×˜ H  ó˜ H  ï˜ H ã˜ H  ç˜ H  /*
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
 \ Empresa.: Ind£stria de Urnas Bignotto Ltda
 \ Programa: BXR_01F9.PRG
 \ Data....: 20-11-95
 \ Sistema.: Administradora de Funer rias
 \ Funcao..: F¢rmula (Circ 1 - 4) a mostrar na tela de BXREC
 \ Analista: Ademilson Pedro Bom
 \ Criacao.: Programado manualmente pelo analista
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/

#include "adrbig.ch"    // inicializa constantes manifesta

 LOCAL reg_dbf:=POINTER_DBF()
 LOCAL circax1:=circax2:=circax3:=circax4:=circax5:=circax6:=SPACE(46)
 LOCAL cipend:=ciatrz:=nrd:=vladd:=0, jrok
 IF !op_menu = INCLUSAO
  codigo:=BXREC->codigo
  RETU .T.
 ENDIF
 IF EMPT(codigo)
  RETU .T.
 ENDI
 dele_atu:=SET(_SET_DELETED,.t.)             // os excluidos nao servem...
 circax1:=circax2:=circax3:=circax4:=circax5:=circax6:=SPACE(46)

 PTAB(ALLTRIM(codigo),'GRUPOS',1)
 PTAB(ALLTRIM(codigo),'TAXAS',1)
 SELE TAXAS
 DO WHILE !EOF().AND.GRUPOS->codigo=TAXAS->codigo
  IF DELE()
   SKIP
   LOOP
  ENDI
  vladd:=0
  IF EMPT(TAXAS->valorpg)
   cipend++
   IF TAXAS->emissao_< DATE()
    ciatrz++
    jrok:=PTAB(tipo,'JUROS',1)
    nrd:=(DATE() - TAXAS->emissao_)
    IF jrok .AND. (nrd > JUROS->mltcaren)
     vladd+=TAXAS->valor*JUROS->multa/100
    ENDI
    IF jrok .AND. (nrd > JUROS->jrscaren)
     vladd+=TAXAS->valor*JUROS->juros/100*nrd
    ENDI
   ENDI
  ENDI
  IF cipend < 5 .AND. TAXAS->emissao_ <= DATE()+60
   circax1:=circax2
   circax2:=circax3
   circax3:=circax4
   circax4:=[ ]+TAXAS->tipo+[ ]+TAXAS->circ+[ ]+DTOC(TAXAS->emissao_)+[ ]+;
      TRANSF(TAXAS->valor+M->vladd,"@E 99,999.99")+[ ]+DTOC(TAXAS->pgto_)+;
      TRANSF(TAXAS->valorpg,"@E 99,999.99") //+[ ]+TAXAS->cobrador
  ENDI
  SKIP
 ENDDO
 @ l_s+07, c_s+46 SAY [   ]
 @ l_s+07, c_s+46 SAY TRAN(GRUPOS->qtcircs,[999])
 IF !EMPT(GRUPOS->nrsorteio)
   @ l_s+10,c_s+20 say [NS:]+GRUPOS->nrsorteio
 ENDIF
 IF !EMPT(GRUPOS->telefone)
  @ l_s+10, c_s+1 SAY [Tel.:]+xDECRIPT(GRUPOS->telefone)
 ENDI
 @ l_s+15, c_s+2 SAY [CPF: ]+TRAN(GRUPOS->cpf,[@R 999.999.999-99])+[  Dt.Nascto:]+DTOC(GRUPOS->nascto_)
 @ l_s+11, c_s+1 SAY SPACE(46)
 @ l_s+12, c_s+1 SAY SPACE(46)
 @ l_s+13, c_s+1 SAY SPACE(46)
 @ l_s+14, c_s+1 SAY SPACE(46)
 @ l_s+11, c_s+1 SAY circax1
 @ l_s+12, c_s+1 SAY circax2
 @ l_s+13, c_s+1 SAY circax3
 @ l_s+14, c_s+1 SAY circax4
 IF .t. //ciatrz > 4
  IF .t. // BXREC->tipo=' '
   DBOX(STRZERO(ciatrz,2)+" Circulares Pendentes Vencidas!",,,,,"ATEN€ŽO, "+usuario)
  ENDI
 ENDI
 POINTER_DBF(reg_dbf)
SET(_SET_DELETED,dele_atu)                         // os excluidos serao vistos

RETU []         // <- deve retornar um valor qualquer

* \\ Final de BXR_01F9.PRG
procedure rx2001f9
/*
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
 \ Empresa.: PresServ Inform tica-Limeira (019)452.6623
 \ Programa: Rx2001F9.PRG
 \ Data....: 23-07-96
 \ Sistema.: Administradora de Funer rias
 \ Funcao..: recibo do relat¢rio ADM_R020
 \ Analista: Ademilson Pedro Bom
 \ Criacao.: Programado manualmente pelo analistad
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/

#include "adrbig.ch"    // inicializa constantes manifestas
 li_aux:=space(1024)
 li_aux:=[O Contratante acima qualificado (ou seu representante legal) ]
 li_aux+=[vem mui respeitosamente … presen‡a desta empresa ]
 li_aux+=ALLTRIM(M->setup1)+[, ]
 IF !EMPT(M->cgcsetup)
  li_aux+=[inscrita no CGC sob n§ ]+TRAN(M->cgcsetup,"@R 99.999.999/9999-99")+[, ]
 ENDI
 li_aux+=[requerer que ]
 li_aux+=[se digne autorizar o ]+&drvPenf+[Pagamento/Atendimento Funeral]
 li_aux+=&drvtenf+[ (conforme cl usulas contratuais) ]
 li_aux+=[referente as respectivas notas fiscais e/ou recibos que est„o ]
 li_aux+=[anexados a este processo administrativo e que totalizam o valor ]
 li_aux+=[de ]+&drvpenf+[R$]+ALLTRIM(TRAN(vlauxilio,[@E 999,999.99]))+;
  [ (]+LEFT(EXT(vlauxilio),AT([/],EXT(vlauxilio))-1)+[)]+&drvtenf
 li_aux+=[ por ocasi„o do falecimento descrito abaixo: ]
RETU M->li_aux       // <- deve retornar um valor qualquer

* \\ Final de Rx2001F9.PRG
             H $ pw_grupo                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   ”   ¬ ¸ Ä Ð Ü è ô  $0<HT`lx„œ¨´ÀÌØäðü ,8DP\ht€Œ˜¤°¼ÈÔàìø(4@LXdp|ˆ” ¬¸ÄÐÜèô       ¤•¤–                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                fc \prjbpv4\reciv\%1.prg \beta\rec2003\%1.prg | more
€
 INS_01F9E–Ñ  INS_01F9CODEC_ETEXTENDCODE	_SYMSTARTSYMSTARTSYMBOLSSYMBOLS_SYMENDSYMENDNULLBEGDATA_DATADATA_SYMPBDATA_SYMPDATA_SYMPEDATA_CONSTCONST_MSGMSG_BEGBSSBEGBSS_BSSBSS_ENDBSSENDBSSDGROUP˜ @r ©˜ H  ˜ h  ë˜ `P 	Ÿ˜ h  
ã˜ h  ß˜ H  û˜ H  ÷˜ H ë˜ H  ï˜ H  ë˜ (  ˜ H  procedure cad_04f9
/*
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
 \ Empresa.: Ind£stria de Urnas Bignotto Ltda
 \ Programa: CAD_04F9.PRG
 \ Data....: 22-04-97
 \ Sistema.: Controle de Processos da Funer ria
 \ Funcao..: Valida‡„o do campo CONTRATO, arquivo CADPROC
 \ Analista: Ademilson Pedro Bom
 \ Criacao.: Programado manualmente pelo analista
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/

#include "adrbig.ch"    // inicializa constantes manifestas
para op_menu
LOCAL reg_dbf1:=POINTER_DBF() , contraux:=GRUPOS->codigo
LOCAL cipend:=vlpend:=0
IF !(op_menu=INCLUSAO)
 retu .t.
ENDI

IF !(contraux=ultcodmsg)
 msg:=[  --->   A T E N C A O  <---|| FAVOR CONFIRMAR|| CPF e Data de Nascimento||]
 KEY2seek:=[ABCDEFGHIJKLMNOPQRSTUVYXWZ]
 KEY2seek+=key2seek
 KEY2seek+=key2seek
 key2press:=[]
 do while EMPT(key2press)
  key2press:=right(str(seconds()),2)
  if (key2press=[00])
   key2press:=[]
  endi
 endd
 key2press:=substr(key2seek,val(key2press),1)

// msg+=[     Tecle <]+key2press+[> para sair|]
 msg+=[     Tecle algo para sair|]
 pressedkey:=[ ]
 do while !(pressedkey=key2press)
  pressedkey:=DBOX(msg,,,,,"ATEN€ŽO! "+usuario," ","!",,)        // avisa ao usuario
  pressedkey:=UPPER(pressedkey)
  EXIT
 endd
 ultcodmsg:=contraux
endi
msg_obs_aux:=msg:=[]
IF PTAB(contraux,[MFILIAL],2,.t.)
 SELE MFILIAL
 DO WHILE !EOF().AND.codigo=contraux
  IF DELE()
   SKIP
   LOOP
  ENDI
  msg_obs_aux+=[**> ATENCAO   ATENCAO   ATENCAO <**]+[|]
  msg_obs_fim:=[***--(]+ALLTRIM(idxd)+[)--***]+[|]
  IF !EMPT(tcarenc_)
   msg_obs_aux+=[ Contrato em Carencia por negociacao ate ]+dtoc(TCARENc_)+[|]
  ENDI
  msg_obs_aux+=ALLTRIM(obs1)+[|]+;
                         ALLTRIM(obs2)+[|]+;
                         ALLTRIM(obs3)+[|]+;
                         msg_obs_fim
  SKIP
  msg_obs_fim:=[]
 ENDD
 msg:=msg_obs_aux
ENDI
ctlmax:=IIF(GRUPOS->codigo=[020],60,10)
for ctmsg=1 to ctlmax
 IF ctlmax=10
  msgaux:=MEMOLINE(GRUPOS->obs,60,ctmsg)
 ELSE
  msgaux:=MEMOLINE(GRUPOS->obs,60,ctmsg)
 ENDI
 IF !EMPT(msgaux)
  msg+=msgaux+[|]
 ENDI
next
PTAB(LEFT(GRUPOS->codigo,09),'TAXAS',1)
SELE TAXAS
DO WHILE !EOF() .AND.codigo=LEFT(GRUPOS->codigo,09)
 IF valorpg=0.AND.emissao_<=DATE()
  msg+=[Contrato com 1 ou + d‚bitos pendentes.|]
  exit
 ENDI
 SKIP
ENDD
IF !EMPT(msg)
// op_=DBOX(msg,,,E_MENU,,"SITUACAO DO CONTRATO!") //
 op_=DBOX(msg,,,E_MENU,,"SITUACAO DO CONTRATO!") //
 msg:=[]
ENDI
PTAB([],[MENSAG])
SELE MENSAG
DO WHILE ! EOF()
 SELE GRUPOS
 cond=LEFT(MENSAG->filtro,AT("~",MENSAG->filtro)-1)               // condicao de validacao
 OP_=0
 msg:=[...]
 MSGAUX:=[MENSAGEM]
 alerta()
 IF (&cond.)                                 // se condicao nao satisfeita,
  nrlin:=mlcount(MENSAG->mens1,60)
  FOR OP_ = 1 TO nrlin
   msgAUX:=MEMOLINE(MENSAG->mens1,60,OP_)
   msg+=[|]+msgAUX
  NEXT
  msg+=[|...]
  ALERTA()                                   // beep, beep, beep
  DBOX(msg,,,E_MENU,,"ATEN€ŽO! "+usuario)        // avisa ao usuario
 ENDI
 SELE MENSAG
 SKIP
ENDD


 POINTER_DBF(reg_dbf1)

RETU .t.  // <- deve retornar um valor L¢GICO

* \\ Final de CAD_04F9.PRG
GAS-Pro v4.0
002003024079001008075001010001176001
                                                                 PAG


Processo Proc.Pgto em  Valor Auxilio  Nome do falecido
           Nome do Declarante                       Contrato   Pago em
-------------------------------------------------------------------------
[Ÿ]
 7 
AFUNER
Processar Pgto em

DTOS(procpagto_)
procpagto_>=M->data1_.AND.procpagto_<=M->data2_
011

























 0 
 1 










 0 
 1 
 0 
 66 
 0 
 6 
 3 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
-1 
 0 
 0 
-1 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
Processo
processo+proc2
99999/99
 8 
C
 7 
 1 


          










Proc.Pgto em
procpagto_
@D
 8 
C
 7 
 12 


          










Valor Auxilio
vlauxilio
99999999999.99
 14 
N
 7 
 23 


          










Nome do falecido
falecido
@!
 35 
C
 7 
 39 


          










Nome
nomedec
@!
 35 
C
 8 
 12 


          










Contrato
contrato
999999
 6 
C
 8 
 54 


          










Pago em
pagtoem_
@D
 8 
D
 8 
 65 


          










 9 
Nome da empresa
nemp

 1 
 1 
 32 

T¡tulo aplica‡„o
nsis

 2 
 1 
 25 

Data do sistema
DTOC(DATE())

 3 
 59 
 8 

Nome do mˆs
NMES(DATE())

 0 
 0 
 8 

Dia da semana
NSEM(DATE())

 0 
 0 
 7 

N£mero da p gina
TRAN(pg_,'9999')

 1 
 70 
 4 

C¢digo relat¢rio
"ADM_R021"

 2 
 66 
 8 

T¡tulo a definir
titrel

 3 
 1 
 30 

Hora da emiss„o
hora_rel_

 3 
 69 
 5 

 0 
 0 
 0 
 0 
/*
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
 \ Empresa.: PresServ Inform tica - Limeira (019)452.6623
 \ Programa: AFUNER.PRG
 \ Data....: 04-11-03
 \ Sistema.: Administradora - RECEP€„O
 \ Funcao..: Gerenciador do subsistema de lan‡amento aux.funeral
 \ Analista: Ademilson Pedro Bom
 \ Criacao.: GAS-Pro v4.0n
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/

#include "adrbig.ch"    // inicializa constantes manifestas

PARA lin_menu,col_menu
PRIV op_sis, tela_fundo:=SAVESCREEN(0,0,MAXROW(),79), l_s, c_s, l_i, c_i, l_a

op_sis=EVAL(qualsis,"AFUNER")
IF nivelop<sistema[op_sis,O_OUTROS,O_NIVEL]        // se usuario nao tem permissao,
 ALERTA()                                          // entao, beep, beep, beep
 DBOX(msg_auto,,,3)                                // lamentamos e
 RETU                                              // retornamos ao menu
ENDI
cn:=fgrep :=.f.

#ifdef COM_LOCK
 IF LEN(pr_ok)>0                                   // se a protecao acusou
  ? pr_ok                                          // erro, avisa e
  QUIT                                             // encerra a aplicacao
 ENDI
#endi

t_fundo=SAVESCREEN(0,0,MAXROW(),79)                // salva tela do fundo
op_cad=1
DO WHIL op_cad!=0
 criterio=""
 RESTSCREEN(0,0,MAXROW(),79,t_fundo)               // restaura tela do fundo
 cod_sos=5 ; cn=.f.
 CLEA TYPEAHEAD                                    // limpa o buffer do teclado
 fgrep=.f.
 SET KEY K_F3 TO                                   // retira das teclas F3 e F4 as
 SET KEY K_F4 TO                                   // funcoes de repeticao e confirmacao
 msg="Inclus„o~1|"+;
     "Manuten‡„o~2|"+;
     "Consulta~3"
 op_cad=DBOX(msg,lin_menu,col_menu,E_MENU,NAO_APAGA,MAIUSC(sistema[op_sis,O_MENU]),,,op_cad)
 IF op_cad!=0                                      // se escolheu uma opcao
  Tela_fundo=SAVESCREEN(0,0,MAXROW(),79)           // salva a tela para ROLATELA()
  PARAMETROS(dbfparam)
  SELE A                                           // e abre o arquivo e seus indices

  #ifdef COM_REDE
   IF !USEARQ(sistema[op_sis,O_ARQUI,O_NOME],.f.,20,1)
                                                   // se falhou a abertura do
    RETU                                           // arquivo volta ao menu anterior
   ENDI
  #else
   USEARQ(sistema[op_sis,O_ARQUI,O_NOME])
  #endi

  SET KEY K_F9 TO veoutros                         // habilita consulta em outros arquivos
 ENDI
 DO CASE
  CASE op_cad=01                                   // inclus„o
   op_menu=INCLUSAO
   IF AT("D",exrot[op_sis])=0                      // se usuario pode fazer inclusao
    AFU_INCL()                                     // neste arquivo chama prg de inclusao
   ELSE                                            // caso contrario vamos avisar que
    ALERTA()                                       // ele nao tem permissao para isto
    DBOX(msg_auto,,,3)
   ENDI

  CASE op_cad=02                                   // manuten‡„o
   op_menu=ALTERACAO
   cod_sos=7
   EDIT()

  CASE op_cad=03                                   // consulta
   op_menu=PROJECOES
   cod_sos=8
   EDITA(03,03,MAXROW()-2,77)

 ENDC
 SET KEY K_F9 TO                                   // F9 nao mais consultara outros arquivos
 CLOS ALL                                          // fecha todos arquivos abertos
ENDD
RETU

PROC AFU_incl(reg_cop)  // inclusao no arquivo AFUNER
LOCAL getlist:={},cabem:=1,rep:=ARRAY(FCOU()),ult_reg:=RECN(),cond_incl_,dbfseq_,;
      ctl_r, ctl_c, ctl_w, t_f3_, t_f4_, dele_atu:=SET(_SET_DELETED,.f.)
PRIV op_menu:=INCLUSAO, sq_atual_, tem_borda, criterio:="", cpord:=""
cond_incl_={||nivelop>1}                           // condicao de inclusao de registros
IF !EVAL(cond_incl_)                               // se nao pode incluir
 ALERTA(2)                                         // avisa o motivo
 DBOX("Permitido apenas a usu rios cadastrados|com n¡vel de Manuten‡„o ou Maior",,,4,,"ATEN€ŽO, "+usuario)
 RETU                                              // e retorna
ENDI
FOR i=1 TO FCOU()                                  // cria/declara privadas as
 msg=FIEL(i)                                       // variaveis de memoria com
 PRIV &msg.                                        // o mesmo nome dos campos
NEXT                                               // do arquivo
IF reg_cop!=NIL                                    // quer repetir todo o reg atual
 FOR i=1 TO FCOU()                                 // para cada campo,
  msg=FIEL(i)                                      // salva o conteudo
  rep[i]=&msg.                                     // para repetir
 NEXT
ELSE
 AFILL(rep,"")                                     // eche com valor vazio
ENDI
t_f3_=SETKEY(K_F3,{||rep()})                       // repeticao reg anterior
t_f4_=SETKEY(K_F4,{||conf()})                      // confirma campos com ENTER
ctl_w=SETKEY(K_CTRL_W,{||nadafaz()})               // enganando o CA-Clipper...
ctl_c=SETKEY(K_CTRL_C,{||nadafaz()})
ctl_r=SETKEY(K_CTRL_R,{||nadafaz()})

#ifdef COM_REDE
 AFU_CRIA_SEQ()                                    // cria dbf de controle de cp sequenciais
 FOR i=1 TO FCOU()                                 // cria/declara privadas as
  msg="sq_"+FIEL(i)                                // variaveis de memoria com
  PRIV &msg.                                       // o mesmo nome dos campos
 NEXT                                              // do arquivo com extensao _seq
#endi

DO WHIL cabem>0
 cod_sos=6
 rola_t=.f.                                        // flag se quer rolar a tela
 SELE AFUNER
 GO BOTT                                           // forca o
 SKIP                                              // final do arquivo
 
 /*
    cria variaveis de memoria identicas as de arquivo, para inclusao
    de registros
 */
 FOR i=1 TO FCOU()
  msg=FIEL(i)
  M->&msg.=IF((fgrep .OR. reg_cop!=NIL).AND.!EMPT(rep[1]),rep[i],&msg.)
 NEXT
 DISPBEGIN()                                       // apresenta a tela de uma vez so
 AFU_TELA()
 INFOSIS(.t.)                                      // exibe informacao no rodape' da tela
 DISPEND()
 AFU_GERA_SEQ()
 IF !EVAL(cond_incl_)
  EXIT
 ENDI
 cabem=DISKSPACE(;
          IF(;
             LEN(sistema[op_sis,O_ARQUI,O_DIR_DBF])<2.OR.sistema[op_sis,O_ARQUI,O_DIR_DBF]="\",;
             0,;
             ASC(sistema[op_sis,O_ARQUI,O_DIR_DBF])-64;
          );
       )
 cabem=INT((cabem-2048)/AFUNER->(RECSIZE()))
 IF cabem<1                                        // mais nenhum!!!
  ALERTA()
  msg="Verifique ESPA€O EM DISCO, "+usuario
  DBOX(msg,,,,,"INCLUSŽO INTERROMPIDA!")           // vamos parar por aqui!
  EXIT
 ENDI
 SELE 0                                            // torna visiveis variaveis de memoria
 SETCOLOR(drvcortel+","+drvcorget+",,,"+corcampo)
 SET KEY K_ALT_F8 TO ROLATELA
 
 /*
    recebe chaves do arquivo de indice basico
 */
 @ l_s+01 ,c_s+14 GET  processo;
                  PICT sistema[op_sis,O_CAMPO,01,O_MASC]
                  DEFINICAO 1

 @ l_s+01 ,c_s+20 GET  proc2;
                  PICT sistema[op_sis,O_CAMPO,02,O_MASC]
                  DEFINICAO 2

 READ
 SET KEY K_ALT_F8 TO
 IF rola_t
  ROLATELA()

  #ifdef COM_REDE
   AFU_ANT_SEQ()                                   // decrementa sequencial
  #endi

  LOOP
 ENDI
 SELE AFUNER
 IF LASTKEY()=K_ESC                                // cancelou ou chave em branco
  cabem=0                                          // prepara saida da inclusao
  LOOP                                             // volta p/ menu de cadastramento
 ENDI
 SEEK M->processo+M->proc2
 aprov_reg_=(FOUND().AND.DELE().AND.!drvvisivel)   // vai aproveitar o registro?
 IF FOUND() .AND. !aprov_reg_                      // pesquisou e achou!
  op_menu=ALTERACAO                                // seta flag de ateracao

  #ifdef COM_REDE
   AFU_ANT_SEQ()                                   // decrementa sequencial
   SELE AFUNER
  #endi

  DISPBEGIN()
  AFU_GETS()                                       // mostra conteudo do registro
  INFOSIS(.f.)                                     // exibe informacao no rodape' da tela
  DISPEND()
  ALERTA()
  msg="Consultar/alterar|Retornar … inclus„o"      // pergunta se deseja
  op_=DBOX(msg,,,E_MENU,,"REGISTRO J EXISTE")     // alterar o registro
  IF op_ =1                                        // caso afirmativo
   EDIT()                                          // deixa alterar
  ENDI
  op_menu=INCLUSAO
  LOOP                                             // volta para inclusao
 ENDI
 SELE 0
 AFU_GET1(INCLUI)                                  // recebe campos
 SELE AFUNER
 IF LASTKEY()=K_ESC                                // se cancelou

  #ifdef COM_REDE
   AFU_ANT_SEQ()                                   // decrementa sequencial
  #endi

  ALERTA()                                         // avisa que o registro
  DBOX("Registro n„o inclu¡do!",18,,1)             // nao foi incluido, e volta
  LOOP
 ENDI

 #ifdef COM_REDE
  GO BOTT                                          // vamos bloquear o final do
  SKIP                                             // arq para que nehum outro
  BLOREG(0,.5)                                     // usuario possa incluir
  SEEK M->processo+M->proc2                        // se registro foi incluido
  aprov_reg_=(FOUND().AND.DELE().AND.!drvvisivel)  // vai aproveitar o registro?
  IF FOUND() .AND. !aprov_reg_                     // por outro usuario, entao
   BLOREG(0,.5)
   FOR i=1 TO FCOU()
    msg=FIEL(i)
    rep[i]=&msg.
    REPL &msg. WITH M->&msg.
   NEXT
   AFU_GET1(FORM_INVERSA)                          // executa formula inversa
   RECA
   FOR i=1 TO FCOU()
    msg=FIEL(i)
    REPL &msg. WITH rep[i]
   NEXT
   ALERTA(4)                                       // beep 4 vezes
   msg="Registro acabou de ser|inclu¡do por outro usu rio!"
   DBOX(msg,,,,,"ATEN€ŽO!")                        // avisa
   SELE AFUNER
   UNLOCK                                          // libera o registro
   LOOP                                            // e recebe chave novamente
  ENDI
 #endi

 IF aprov_reg_                                     // se vai aproveitar reg excluido

  #ifdef COM_REDE
   BLOREG(0,.5)
  #endi

  RECA                                             // excluido, vamos recupera-lo
 ELSE                                              // caso contrario
  APPEND BLANK                                     // inclui reg em branco no dbf
 ENDI
 FOR i=1 TO FCOU()                                 // para cada campo,
  msg=FIEL(i)                                      // salva o conteudo
  rep[i]=M->&msg.                                  // para repetir
  REPL &msg. WITH rep[i]                           // enche o campo do arquivo
 NEXT

 #ifdef COM_REDE
  UNLOCK                                           // libera o registro e
  COMMIT                                           // forca gravacao
 #else
  IF RECC()-INT(RECC()/20)*20=0                    // a cada 20 registros
   COMMIT                                          // digitados forca gravacao
  ENDI
 #endi

 ult_reg=RECN()                                    // ultimo registro digitado
 AFU_REL(ult_reg)                               // imprime relat apos inclusao
 IF reg_cop!=NIL                                   // estava na consulta e quis rep o campo
  sq_atual_=NIL
  EXIT                                             // cai fora...
 ENDI
ENDD

#ifdef COM_REDE
 AFU_ANT_SEQ()                                     // restaura sequencial anterior
 SELE AFUNER
#endi

GO ult_reg                                         // para o ultimo reg digitado
SETKEY(K_F3,t_f3_)                                 // restaura teclas de funcoes
SETKEY(K_F4,t_f4_)
SET(_SET_DELETED,dele_atu)                            // ecluidos visiveis/invisiveis
SETKEY(K_CTRL_W,ctl_w)
SETKEY(K_CTRL_C,ctl_c)
SETKEY(K_CTRL_R,ctl_r)
RETU


PROC AFU_REL(ult_reg)  // imprime relatorio apos inclusao
LOCAL p_imp:=.t., i_ok:=.f., imp_rel:=.f.
DO WHIL .t.
 SAVE SCREEN                     // salva a tela

 #ifdef COM_REDE
  tps=TP_SAIDA(,,.t.)            // escolhe a impressora
  IF LASTKEY()=K_ESC             // se teclou ESC
   EXIT                          // cai fora...
  ENDI
  IF tps=2 .OR. PREPIMP("AUXILIO FUNERAL")   // se nao vai para video conf impressora pronta
   IF categ=[AF]
    ADM_R020(tps,0,ult_reg)
    ADR_R029(tps,0,ult_reg)
   ELSE
    ADM_RX20(tps,0,ult_reg)
    ADR_RX29(tps,0,ult_reg)
   ENDI
   ADM_R029(tps,0,ult_reg)
 #else
  IF PREPIMP("AUXILIO FUNERAL")              // confima preparacao da impressora
   IF categ=[AF]
    ADM_R020(0,0,ult_reg)
    ADR_R029(0,0,ult_reg)
   ELSE
    ADM_RX20(0,0,ult_reg)
    ADR_RX29(0,0,ult_reg)
   ENDI
   ADM_R029(0,0,ult_reg)
 #endi

 REST SCREEN                    // restaura tela
  msg="Prosseguir|Outra c¢pia"
  op_=1 //DBOX(msg,,,E_MENU,,"FIM DE IMPRESSŽO") // quer emitir outra copia?
  IF op_=2
   LOOP                         // nao quer...
  ENDI
 ENDI
 EXIT
ENDD
RETU


#ifdef COM_REDE
 PROC AFU_ANT_SEQ(est_seq)     // restaura sequencial anterior
 SELE AFU_SEQ     // seleciona arquivo de controle de sequencial
 BLOARQ(0,.5)     // esta estacao foi a ultima a incluir?
 IF sq_atual_ == processo
  REPL processo WITH sq_processo
  REPL intlan WITH sq_intlan
 ENDI
 UNLOCK           // libera DBF para outros usuarios
 COMMIT           // atualiza cps sequenciais no disco
 RETU
#endi


PROC AFU_CRIA_SEQ   // cria dbf de controle de campos sequenciais
LOCAL dbfseq_:=sistema[op_sis,O_ARQUI,O_DIR_DBF]+"AFU_seq" // arq temporario
SELE 0                          // seleciona area vazia
IF !FILE(dbfseq_+".dbf")        // se o dbf nao existe
 DBCREATE(dbfseq_,{;            // vamos criar a sua estrutura
                    {"processo"  ,"C",  5, 0},;
                    {"intlan"    ,"C",  8, 0};
                  };
 )
ENDI
USEARQ(dbfseq_,.f.,,,.f.)       // abre arquivo de cps sequencial
IF RECC()=0                     // se o dbf foi criado agora
 BLOARQ(0,.5)                   // inclui um registro que tera
 APPEND BLANK                   // os ultomos cps sequenciais
 SELE AFUNER
 IF RECC()>0                    // se o DBF nao estiver
  SET ORDER TO 0                // vazio, entao enche DBF seq
  GO BOTT                       // com o ultimo reg digitado
  REPL AFU_SEQ->processo WITH processo
  REPL AFU_SEQ->intlan WITH intlan
  DBSETORDER(1)                 // retorna ao indice principal
 ENDI
 SELE AFU_SEQ                   // seleciona arq de sequencias
 UNLOCK                         // libera DBF para outros usuarios
 COMMIT                         // atualiza cps sequenciais no disco
ENDI
RETURN

PROC AFU_GERA_SEQ()

#ifdef COM_REDE
 LOCAL ar_:=SELEC()
#else
 LOCAL reg_:=RECNO(),ord_ind:=INDEXORD()
#endi


#ifdef COM_REDE
 SELE AFU_SEQ
 BLOARQ(0,.5)
 sq_processo=AFU_SEQ->processo
 sq_intlan=AFU_SEQ->intlan
#else
 DBSETORDER(0)
 GO BOTT
#endi

M->processo=LPAD(STR(VAL(processo)+1),05,[0])
M->intlan=LPAD(STR(VAL(intlan)+1),08,[0])

#ifdef COM_REDE
 AFU_GRAVA_SEQ()
 sq_atual_=AFU_SEQ->processo
 UNLOCK                                            // libera o registro
 COMMIT
 SELE (ar_)
#else
 DBSETORDER(ord_ind)
 GO reg_
#endi

RETU

PROC AFU_GRAVA_SEQ
REPL processo WITH M->processo
REPL intlan WITH M->intlan
RETU

PROC AFU_tela     // tela do arquivo AFUNER
tem_borda=.t.
l_s=Sistema[op_sis,O_TELA,O_LS]           // coordenadas da tela
c_s=Sistema[op_sis,O_TELA,O_CS]
l_i=Sistema[op_sis,O_TELA,O_LI]
c_i=Sistema[op_sis,O_TELA,O_CI]
SETCOLOR(drvtittel)
vr_memo=NOVAPOSI(@l_s,@c_s,@l_i,@c_i)     // pega posicao atual da tela
CAIXA(mold,l_s,c_s,l_i,c_i)               // monta caixa da tela
i=LEN(sistema[op_sis,O_MENS])/2
@ l_s,c_s-1+(c_i-c_s+1)/2-i SAY " "+MAIUSC(sistema[op_sis,O_MENS])+" "
SETCOLOR(drvcortel)
@ l_s+01,c_s+1 SAY " Processo..:      /  /    de             Categoria:"
@ l_s+02,c_s+1 SAY " ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ   Dados do Contratante  ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ"
@ l_s+03,c_s+1 SAY " Contrato...:"
@ l_s+04,c_s+1 SAY " Grau.......:"
@ l_s+05,c_s+1 SAY " Respons vel:                                     (Declarante)"
@ l_s+06,c_s+1 SAY " Endere‡o...:                                      Fone:"
@ l_s+07,c_s+1 SAY " ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ   Dados do Falecido   ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ"
@ l_s+08,c_s+1 SAY " Inscrito..:"
@ l_s+09,c_s+1 SAY " Rua...:                                 Bairro:"
@ l_s+10,c_s+1 SAY " Cidade:                           UF:     Dt.Nasc.:"
@ l_s+11,c_s+1 SAY " ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ   Dados do Falecimento   ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ"
@ l_s+12,c_s+1 SAY " Data:            hora:        Endere‡o:"
@ l_s+13,c_s+1 SAY "               Cidade:                           UF:"
@ l_s+14,c_s+1 SAY " Seu sepultamento ser  ..:            hora:"
@ l_s+15,c_s+1 SAY "                Cemit‚rio:"
@ l_s+16,c_s+1 SAY " Funcion rio respons vel.:"
@ l_s+18,c_s+1 SAY " Proc. Pgto em:              Vl.Auxilio:                Pago em"
RETU

PROC AFU_gets     // mostra variaveis do arquivo AFUNER
LOCAL getlist := {}, ord_, chv_, ar_get1:=ALIAS(), op_ant := op_menu
AFU_TELA()
SETCOLOR(drvcortel+","+drvcorget+",,,"+corcampo)
PTAB(CONTRATO,'GRUPOS',1)
PTAB(FUNCRESP,'FNCS',1)
PTAB(PROCESSO+PROC2+M->P_FILIAL+CATEG,[PRCESSOS],1)
PTAB(PADR(SUBSTR(M->IDE_MAQ,2),4)+[AFU],[IMPPAR],1)
CRIT("",,"5")
@ l_s+01 ,c_s+14 GET  processo;
                 PICT sistema[op_sis,O_CAMPO,01,O_MASC]

@ l_s+01 ,c_s+20 GET  proc2;
                 PICT sistema[op_sis,O_CAMPO,02,O_MASC]
		 CRIT(sistema[op_sis,O_CAMPO,02,O_CRIT],,"5")

@ l_s+01 ,c_s+30 GET  ocorr_;
		 PICT sistema[op_sis,O_CAMPO,04,O_MASC]

@ l_s+01 ,c_s+53 GET  categ;
		 PICT sistema[op_sis,O_CAMPO,05,O_MASC]
		 CRIT(sistema[op_sis,O_CAMPO,05,O_CRIT],,"4")

@ l_s+03 ,c_s+15 GET  contrato;
		 PICT sistema[op_sis,O_CAMPO,06,O_MASC]
		 CRIT(sistema[op_sis,O_CAMPO,06,O_CRIT],,"1|2|6")

@ l_s+04 ,c_s+15 GET  grauparcon

@ l_s+05 ,c_s+15 GET  nomedec;
		 PICT sistema[op_sis,O_CAMPO,08,O_MASC]

@ l_s+06 ,c_s+15 GET  ruadec;
                 PICT sistema[op_sis,O_CAMPO,09,O_MASC]

@ l_s+06 ,c_s+58 GET  fonedec;
                 PICT sistema[op_sis,O_CAMPO,10,O_MASC]

@ l_s+08 ,c_s+14 GET  codigofal

@ l_s+08 ,c_s+33 GET  falecido

@ l_s+09 ,c_s+10 GET  ruares

@ l_s+09 ,c_s+50 GET  baires

@ l_s+10 ,c_s+10 GET  munres

@ l_s+10 ,c_s+40 GET  estres;
                 PICT sistema[op_sis,O_CAMPO,16,O_MASC]

@ l_s+10 ,c_s+54 GET  nascto_;
                 PICT sistema[op_sis,O_CAMPO,17,O_MASC]

@ l_s+12 ,c_s+08 GET  falecto_;
                 PICT sistema[op_sis,O_CAMPO,18,O_MASC]

@ l_s+12 ,c_s+25 GET  horafal;
                 PICT sistema[op_sis,O_CAMPO,19,O_MASC]

@ l_s+12 ,c_s+42 GET  ruafal

@ l_s+13 ,c_s+24 GET  municfal

@ l_s+13 ,c_s+54 GET  estfal;
                 PICT sistema[op_sis,O_CAMPO,22,O_MASC]

@ l_s+14 ,c_s+28 GET  sepult_;
                 PICT sistema[op_sis,O_CAMPO,23,O_MASC]

@ l_s+14 ,c_s+45 GET  horasepult;
                 PICT sistema[op_sis,O_CAMPO,24,O_MASC]

@ l_s+15 ,c_s+28 GET  cemitsep

@ l_s+16 ,c_s+28 GET  funcresp;
                 PICT sistema[op_sis,O_CAMPO,26,O_MASC]
                 CRIT(sistema[op_sis,O_CAMPO,26,O_CRIT],,"3")

@ l_s+18 ,c_s+17 GET  procpagto_;
                 PICT sistema[op_sis,O_CAMPO,27,O_MASC]

@ l_s+18 ,c_s+42 GET  vlauxilio;
                 PICT sistema[op_sis,O_CAMPO,28,O_MASC]

@ l_s+18 ,c_s+65 GET  pagtoem_;
                 PICT sistema[op_sis,O_CAMPO,29,O_MASC]

CLEAR GETS
RETU

PROC AFU_get1(tp_mov)     // capta variaveis do arquivo AFUNER
LOCAL getlist := {}, ord_, chv_, ar_get1:=ALIAS(), op_ant := op_menu
PRIV  blk_afuner:=.t.

IF tp_mov=INCLUI
 DO WHILE .t.
  rola_t=.f.
  SET KEY K_ALT_F8 TO ROLATELA
  SETCOLOR(drvcortel+","+drvcorget+",,,"+corcampo)
  CRIT("",,"5")
  @ l_s+01 ,c_s+30 GET  ocorr_;
                   PICT sistema[op_sis,O_CAMPO,04,O_MASC]
                   DEFINICAO 4

  @ l_s+01 ,c_s+53 GET  categ;
                   PICT sistema[op_sis,O_CAMPO,05,O_MASC]
                   DEFINICAO 5
                   MOSTRA sistema[op_sis,O_FORMULA,4]

  @ l_s+03 ,c_s+15 GET  contrato;
                   PICT sistema[op_sis,O_CAMPO,06,O_MASC]
                   DEFINICAO 6
                   MOSTRA sistema[op_sis,O_FORMULA,1]
                   MOSTRA sistema[op_sis,O_FORMULA,2]
                   MOSTRA sistema[op_sis,O_FORMULA,6]

  @ l_s+04 ,c_s+15 GET  grauparcon
                   DEFINICAO 7

  @ l_s+05 ,c_s+15 GET  nomedec;
                   PICT sistema[op_sis,O_CAMPO,08,O_MASC]
                   DEFINICAO 8

  @ l_s+06 ,c_s+15 GET  ruadec;
                   PICT sistema[op_sis,O_CAMPO,09,O_MASC]
                   DEFINICAO 9

  @ l_s+06 ,c_s+58 GET  fonedec;
                   PICT sistema[op_sis,O_CAMPO,10,O_MASC]
                   DEFINICAO 10

  @ l_s+08 ,c_s+14 GET  codigofal
                   DEFINICAO 11

  @ l_s+08 ,c_s+33 GET  falecido
                   DEFINICAO 12

  @ l_s+09 ,c_s+10 GET  ruares
                   DEFINICAO 13

  @ l_s+09 ,c_s+50 GET  baires
                   DEFINICAO 14

  @ l_s+10 ,c_s+10 GET  munres
                   DEFINICAO 15

  @ l_s+10 ,c_s+40 GET  estres;
                   PICT sistema[op_sis,O_CAMPO,16,O_MASC]
                   DEFINICAO 16

  @ l_s+10 ,c_s+54 GET  nascto_;
                   PICT sistema[op_sis,O_CAMPO,17,O_MASC]
                   DEFINICAO 17

  @ l_s+12 ,c_s+08 GET  falecto_;
                   PICT sistema[op_sis,O_CAMPO,18,O_MASC]
                   DEFINICAO 18

  @ l_s+12 ,c_s+25 GET  horafal;
                   PICT sistema[op_sis,O_CAMPO,19,O_MASC]
                   DEFINICAO 19

  @ l_s+12 ,c_s+42 GET  ruafal
                   DEFINICAO 20

  @ l_s+13 ,c_s+24 GET  municfal
                   DEFINICAO 21

  @ l_s+13 ,c_s+54 GET  estfal;
                   PICT sistema[op_sis,O_CAMPO,22,O_MASC]
                   DEFINICAO 22

  @ l_s+14 ,c_s+28 GET  sepult_;
                   PICT sistema[op_sis,O_CAMPO,23,O_MASC]
                   DEFINICAO 23

  @ l_s+14 ,c_s+45 GET  horasepult;
                   PICT sistema[op_sis,O_CAMPO,24,O_MASC]
                   DEFINICAO 24

  @ l_s+15 ,c_s+28 GET  cemitsep
                   DEFINICAO 25

  @ l_s+16 ,c_s+28 GET  funcresp;
                   PICT sistema[op_sis,O_CAMPO,26,O_MASC]
                   DEFINICAO 26
                   MOSTRA sistema[op_sis,O_FORMULA,3]

  @ l_s+18 ,c_s+17 GET  procpagto_;
                   PICT sistema[op_sis,O_CAMPO,27,O_MASC]
                   DEFINICAO 27

  @ l_s+18 ,c_s+42 GET  vlauxilio;
                   PICT sistema[op_sis,O_CAMPO,28,O_MASC]
                   DEFINICAO 28

  @ l_s+18 ,c_s+65 GET  pagtoem_;
                   PICT sistema[op_sis,O_CAMPO,29,O_MASC]
                   DEFINICAO 29

  READ
  SET KEY K_ALT_F8 TO
  IF rola_t
   ROLATELA()
   LOOP
  ENDI
  IF LASTKEY()!=K_ESC .AND. drvincl .AND. op_menu=INCLUSAO
   IF !CONFINCL()
    LOOP
   ENDI
  ENDI
  EXIT
 ENDD
ENDI
PTAB(CONTRATO,'GRUPOS',1)
PTAB(CONTRATO,'TAXAS',1)
PTAB(GRUPOS->GRUPO,'ARQGRUP',1)
PTAB(CODIGOFAL,'INSCRITS',1)
PTAB(FUNCRESP,'FNCS',1)
PTAB(PROCESSO+PROC2+M->P_FILIAL+CATEG,[PRCESSOS],1)
PTAB(PADR(SUBSTR(M->IDE_MAQ,2),4)+[AFU],[IMPPAR],1)
IF tp_mov=EXCLUI .OR. tp_mov=FORM_INVERSA

 #ifdef COM_REDE
  PARAMETROS(dbfparam,'procimp',processo+proc2+filial)
 #else
  PARAMETROS(dbfparam,'procimp',processo+proc2+filial)
 #endi

 IF 1=3
  IF !EMPTY(PRCESSOS->codlan)
   TIRA_LANC("PRCESSOS",LEFT(PRCESSOS->codlan,16))
  ENDI
 ENDI
 IF 1=3
  IF !EMPTY(IMPPAR->codlan)
   TIRA_LANC("IMPPAR",LEFT(IMPPAR->codlan,16))
  ENDI
 ENDI
 IF !EMPTY(ALIAS())
  DELE
 ENDI
ELSEIF tp_mov=INCLUI .OR. tp_mov=RECUPERA .OR. tp_mov=FORM_DIRETA
 IF (op_menu=INCLUSAO .AND. LASTKEY()!=K_ESC) .OR. op_menu!=INCLUSAO
  IF !PTAB(processo+proc2+M->p_filial+categ,[PRCESSOS],1)
   ord_=LEN(sistema[EVAL(qualsis,"PRCESSOS"),O_CHAVE])
   IF !EMPTY(PRCESSOS->codlan)
    chv_=LEFT(PRCESSOS->codlan,16)
   ELSE
    IF TYPE("M->intlan")="C" .AND. EMPTY(intlan)
     chv_="AFU-"+M->intlan+"-001"
    ELSE
     chv_="AFU-"+intlan+"-001"
    ENDI
   ENDI
   PTAB(chv_,"PRCESSOS",ord_)
   FAZ_LANC("PRCESSOS",chv_)
   REPL PRCESSOS->processo WITH processo+proc2+M->p_filial,;
        PRCESSOS->categ WITH categ,;
        PRCESSOS->grup WITH GRUPOS->grupo,;
        PRCESSOS->num WITH contrato,;
        PRCESSOS->grau WITH SUBSTR(codigofal,7,1),;
        PRCESSOS->seq WITH VAL(SUBSTR(codigofal,8,2)),;
        PRCESSOS->seg WITH nomedec,;
        PRCESSOS->ends WITH ruares,;
        PRCESSOS->cids WITH munres,;
        PRCESSOS->fal WITH falecido,;
        PRCESSOS->sep WITH cemitsep,;
        PRCESSOS->dfal WITH falecto_
   SELE PRCESSOS                                   // arquivo alvo do lancamento
   op_menu=ALTERACAO
   PRC_GET1(FORM_DIRETA)                           // faz processo do arq do lancamento
   op_menu=op_ant

   #ifdef COM_REDE
    UNLOCK                                         // libera o registro
   #endi

   IF EMPT(ar_get1)                                // retorna para area original
    SELE 0
   ELSE
    SELE (ar_get1)
   ENDI
  ENDI
  IF !PTAB(PADR(SUBSTR(M->ide_maq,2),4)+[AFU],[IMPPAR],1)
   ord_=LEN(sistema[EVAL(qualsis,"IMPPAR"),O_CHAVE])
   IF !EMPTY(IMPPAR->codlan)
    chv_=LEFT(IMPPAR->codlan,16)
   ELSE
    IF TYPE("M->intlan")="C" .AND. EMPTY(intlan)
     chv_="AFU-"+M->intlan+"-002"
    ELSE
     chv_="AFU-"+intlan+"-002"
    ENDI
   ENDI
   PTAB(chv_,"IMPPAR",ord_)
   FAZ_LANC("IMPPAR",chv_)
   REPL IMPPAR->idmaq WITH PADR(SUBSTR(M->ide_maq,2),4),;
        IMPPAR->base WITH [AFU]

   #ifdef COM_REDE
    IMPPAR->(DBUNLOCK())                           // libera o registro
   #endi

  ENDI
  PARAMETROS(dbfparam,'procimp',processo+proc2+filial)

  #ifdef COM_REDE
   IF op_menu=INCLUSAO
    filial=M->p_filial
   ELSE
    REPL filial WITH M->p_filial
   ENDI
   IF PTAB(processo+proc2+M->p_filial+categ,[PRCESSOS],1).AND.(EMPT(PRCESSOS->saiu).OR.PRCESSOS->saiu=ARQGRUP->ultcirc)
    REPBLO('PRCESSOS->categ',{||categ})
   ENDI
   IF PTAB(processo+proc2+M->p_filial+categ,[PRCESSOS],1).AND.(EMPT(PRCESSOS->saiu).OR.PRCESSOS->saiu=ARQGRUP->ultcirc)
    REPBLO('PRCESSOS->ends',{||ruares})
   ENDI
   IF PTAB(processo+proc2+M->p_filial+categ,[PRCESSOS],1).AND.(EMPT(PRCESSOS->saiu).OR.PRCESSOS->saiu=ARQGRUP->ultcirc)
    REPBLO('PRCESSOS->cids',{||munres})
   ENDI
   IF PTAB(processo+proc2+M->p_filial+categ,[PRCESSOS],1).AND.(EMPT(PRCESSOS->saiu).OR.PRCESSOS->saiu=ARQGRUP->ultcirc)
    REPBLO('PRCESSOS->fal',{||falecido})
   ENDI
   IF PTAB(processo+proc2+M->p_filial+categ,[PRCESSOS],1).AND.(EMPT(PRCESSOS->saiu).OR.PRCESSOS->saiu=ARQGRUP->ultcirc)
    REPBLO('PRCESSOS->dfal',{||falecto_})
   ENDI
   IF PTAB(PADR(M->ide_maq,4)+[AFU],[IMPPAR],1)
    REPBLO('IMPPAR->docto',{||processo+proc2+filial+categ})
   ENDI
  #else
  PARAMETROS(dbfparam,'procimp',processo+proc2+filial)
   IF op_menu=INCLUSAO
    filial=M->p_filial
   ELSE
    REPL filial WITH M->p_filial
   ENDI
   IF PTAB(processo+proc2+M->p_filial+categ,[PRCESSOS],1).AND.(EMPT(PRCESSOS->saiu).OR.PRCESSOS->saiu=ARQGRUP->ultcirc)
    REPL PRCESSOS->categ WITH categ
   ENDI
   IF PTAB(processo+proc2+M->p_filial+categ,[PRCESSOS],1).AND.(EMPT(PRCESSOS->saiu).OR.PRCESSOS->saiu=ARQGRUP->ultcirc)
    REPL PRCESSOS->ends WITH ruares
   ENDI
   IF PTAB(processo+proc2+M->p_filial+categ,[PRCESSOS],1).AND.(EMPT(PRCESSOS->saiu).OR.PRCESSOS->saiu=ARQGRUP->ultcirc)
    REPL PRCESSOS->cids WITH munres
   ENDI
   IF PTAB(processo+proc2+M->p_filial+categ,[PRCESSOS],1).AND.(EMPT(PRCESSOS->saiu).OR.PRCESSOS->saiu=ARQGRUP->ultcirc)
    REPL PRCESSOS->fal WITH falecido
   ENDI
   IF PTAB(processo+proc2+M->p_filial+categ,[PRCESSOS],1).AND.(EMPT(PRCESSOS->saiu).OR.PRCESSOS->saiu=ARQGRUP->ultcirc)
    REPL PRCESSOS->dfal WITH falecto_
   ENDI
   IF PTAB(PADR(M->ide_maq,4)+[AFU],[IMPPAR],1)
    REPL IMPPAR->docto WITH processo+proc2+filial+categ
   ENDI
  #endi

  IF op_menu!=INCLUSAO
   RECA
  ENDI
 ENDI
ENDI
RETU

* \\ Final de AFUNER.PRG
€ AFUNER±–T AFUNERCODEAFU_INCLCODEAFU_RELCODE
AFU_ANT_SECODE
AFU_CRIA_SCODE
AFU_GERA_SCODE
AFU_GRAVA_CODEAFU_TELACODEAFU_GETSCODEAFU_GET1CODEC_ETEXTENDCODE	_SYMSTARTSYMSTARTSYMBOLSSYMBOLS_SYMENDSYMENDNULLBEGDATA_DATADATA_SYMPBDATA_SYMPDATA_SYMPEDATA_CONSTCONST_MSGMSG_BEGBSSBEGBSS_BSSBSS_ENDBSSENDBSSDGROUP²˜ @ô%˜ @—	w˜ @7Û˜ @| 	“˜ @J
À˜ @Ñ 6˜ @2 Ñ˜ @Õ%˜ @å˜ @øï˜ H  ë˜ h  Ç˜ ``
GAS-Pro v3.0
011003022079001001001001012000176001
[Ÿ]
 5 
CPRCIRC
Processos (2¦ via)
GRUPOS->grupo+TAXAS->circ
grupo+circ+DTOS(dfal)

011









 0 
 0 
 0 
 48 
 1 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
-1 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
Processo
processo
 
 9 
C
 1 
 42 


          










Contrato
num

 5 
C
 1 
 31 


          










Falecido
fal

 35 
C
 1 
 55 


          










Ends
ALLTRIM(ends)+'-'+ALLTRIM(cids)
@!
 40 
C
 1 
 92 


          










Data
dfal
@D
 8 
D
 1 
 150 


          










 9 
Nome da empresa
nemp

 0 
 0 
 16 

T¡tulo aplica‡„o
nsis

 0 
 0 
 29 

Data do sistema
DTOC(DATE())

 0 
 0 
 8 

Nome do mˆs
NMES(DATE())

 0 
 0 
 8 

Dia da semana
NSEM(DATE())

 0 
 0 
 7 

N£mero da p gina
TRAN(pg_,'9999')

 0 
 0 
 4 

C¢digo relat¢rio
"ADM_R034"

 0 
 0 
 8 

T¡tulo a definir
titrel

 0 
 0 
 30 

Hora da emiss„o
hora_rel_

 0 
 0 
 5 

 0 
 0 
 0 
 0 
procedure final
#include "SIXNSX.CH"
#define RDDNAME "SIXNSX"
#define MEMOEXT ".SMT"
set date brit
set cent on
? [Juntando arquivos Plano e IV]
?
? [Processando Associados.]
use ..\arquivos\grupos
zap
? [Juntando Vip4]
appe from grupl
? [Juntando IV]
appe from gruiv
? [organizando por contrato]
inde on codigo to ..\indices\grupos1
? [organizando por nome]
inde on nome to ..\indices\grupos2

? [Processando Cobrancas.]
use ..\arquivos\taxas
zap
? [Juntando Vip4]
appe from taxpl
? [juntando IV]
appe from taxiv
? [Reorganizando codigos]
repl circ with right([000]+circ,3), tipo with IIF(tipo$[0123456789],tipo,[0]) all
repl codigo with left(codigo,9)+tipo+circ all
? [Organizando por contrato]
inde on codigo to ..\indices\taxas1
? [Organizando por cobranca]
inde on cobranca to ..\indices\taxas2
? [Organizando por cod.Lancto]
inde on codlan to ..\indices\taxas3


? [Processando Inscritos.]
use ..\arquivos\inscrits
zap
? [Juntando Vip4]
appe from inspl
? [Juntando IV]
appe from insiv
? [Reorganizando codigos]
repl codigo with left(codigo,9)+grau+str(seq,3) all
? [Organizando por contrato]
inde on codigo to ..\indices\inscrit1
? [Organizando por nome]
inde on nome to ..\indices\inscrit2
procedure rx2901f9
/*
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
 \ Empresa.: PresServ Inform tica-Limeira (019)452.6623
 \ Programa: R02901F9.PRG
 \ Data....: 22-09-97
 \ Sistema.: Administradora - RECEP€„O
 \ Funcao..: pedido do relat¢rio ADR_R029
 \ Analista: Ademilson Pedro Bom
 \ Criacao.: Programado manualmente pelo analista
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/

#include "adrbig.ch"    // inicializa constantes manifestas

 li_aux:=space(1024)
 li_aux:=[O Contratante acima qualificado (ou seu representante legal) ]
 li_aux+=[declara que recebeu de ]
 li_aux+=ALLTRIM(M->setup1)+[, ]
 IF !EMPT(M->cgcsetup)
  li_aux+=[inscrita no CGC sob n§ ]+TRAN(M->cgcsetup,"@R 99.999.999/9999-99")+[, ]
 ENDI
 li_aux+=[o ]+&drvpenf+[Pagamento/Atendimento Funeral]+&drvtenf+[,  ]
 li_aux+=[por ocasi„o do falecimento abaixo descrito, conforme ]
 li_aux+=[processo administrativo contendo requerimento e as ]
 li_aux+=[respectivas notas fiscais e/ou recibos, os quais totalizam ]
 li_aux+=[o valor de ]+&drvpenf+[R$]+ALLTRIM(TRAN(vlauxilio,[@E 999,999.99]))+;
  [ (]+LEFT(EXT(vlauxilio),AT([/],EXT(vlauxilio))-1)+[). ]+&drvtenf

RETU M->li_aux       // <- deve retornar um valor qualquer

* \\ Final de R02901F9.PRG
GAS-Pro v4.0
006003022079001016001016007001176001


-----------------------------------------------------------------------
                                                  Valor.:
Referˆnte.:
Contrato..:                                       Data..:
Nome......:
Endere‡o..:
Bairro....:
Cid./Cobr.:                                         ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
                                                    Op:
Valor:

ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ


-----------------------------------------------------------------------
                                                  Valor.:
Referˆnte.:
Contrato..:                                       Data..:
Nome......:
Endere‡o..:
Bairro....:                                         ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Cid./Cobr.:                                         Op:
Valor:
[Ÿ]
 27 
OBXEC
Outros recibos (2¦Via)


PTAB(PADR(SUBSTR(M->ide_maq,2),4)+[OBX],[IMPPAR],1).AND.ano+numero=LEFT(IMPPAR->docto,8)
011

























 0 
 1 










 0 
 2 
 0 
 33 
 1 
 3 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
-1 
 0 
-1 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
N§ Recibo
M->nrauxrec
@R 99-999999
 9 
C
 4 
 1 


          










Ident1
LEFT(M->setup1,35)

 35 
C
 1 
 1 


 û        










Ident2
M->setup2

 50 
C
 2 
 1 


          










Valor
valorpg
@E 999,999.99
 10 
N
 4 
 59 


û         










Ref
ref

 25 
C
 5 
 15 


û         










Grupo 1
GRUPOS->grupo +[  ]+codigo

 10 
C
 6 
 15 


û         










Nome
GRUPOS->nome

 35 
C
 7 
 15 


û         










Endere‡o
GRUPOS->endereco
 
 35 
C
 8 
 15 


          










Bairro
GRUPOS->bairro
 
 25 
C
 9 
 15 


          










Cidade
GRUPOS->cidade+[ ] +GRUPOS->cobrador

 35 
C
 10 
 15 


          










Valor Ext
chr(15)+'('+SUBSTR(EXT(valorpg),1,AT('/',EXT(valorpg))-1)+')'+chr(18)

 70 
C
 12 
 8 


          










data 1
emitido_
@D
 10 
C
 6 
 59 


          










operador
LEFT(por,1)+LOWER(SUBSTR(por,2))

 15 
C
 11 
 57 


          










2 Ident1
LEFT(M->setup1,35)

 35 
C
 15 
 1 


 û        










2 Ident 2
M->setup2

 50 
C
 16 
 1 


          










2 N§ Recibo
M->nrauxrec
@R 99-999999
 9 
C
 18 
 1 


          










Valor pago
valorpg
@E 999,999.99
 10 
N
 18 
 59 


û         










Ref
ref

 25 
C
 19 
 13 


û         










Grupo
GRUPOS->grupo +[  ]+codigo

 10 
C
 20 
 13 


û         










Nome
GRUPOS->nome

 35 
C
 21 
 13 


û         










Endere‡o
GRUPOS->endereco

 35 
C
 22 
 13 


          










Bairro
GRUPOS->bairro

 25 
C
 23 
 13 


          










Cidade
GRUPOS->cidade+[ ] +GRUPOS->cobrador

 35 
C
 24 
 13 


          










Valor Ext
chr(15)+'('+SUBSTR(EXT(valorpg),1,AT('/',EXT(valorpg))-1)+')'+chr(18)

 70 
C
 25 
 8 


          










Emitido em
emitido_
@D
 10 
D
 20 
 59 


          










Operador
LEFT(por,1)+LOWER(SUBSTR(por,2))

 15 
C
 24 
 57 


          










Altera‡„o de Endere‡o
[Endere‡o alterado em ] +DTOC(ALENDER->data_)

 40 
C
 26 
 8 
PTAB(codigo,'ALENDER',1)

          










 9 
Nome da empresa
nemp

 0 
 0 
 32 

T¡tulo aplica‡„o
nsis

 0 
 0 
 25 

Data do sistema
DTOC(DATE())

 0 
 0 
 8 

Nome do mˆs
NMES(DATE())

 0 
 0 
 8 

Dia da semana
NSEM(DATE())

 0 
 0 
 7 

N£mero da p gina
TRAN(pg_,'9999')

 0 
 0 
 4 

C¢digo relat¢rio
"ADM_R023"

 0 
 0 
 8 

T¡tulo a definir
titrel

 0 
 0 
 30 

Hora da emiss„o
hora_rel_

 0 
 0 
 5 

 0 
 0 
 0 
 4 
GRUPOS
 1 
codigo



ARQGRUP
 1 
GRUPOS->grupo



COBRADOR
 1 
GRUPOS->cobrador



REGIAO
 1 
GRUPOS->regiao



procedure v02401f9
/*
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
 \ Empresa.: PresServ Inform tica-Limeira (019)452.6623
 \ Programa: V02401F9.PRG
 \ Data....: 03-01-96
 \ Sistema.: Administradora de Funer rias
 \ Funcao..: Valida‡„o da variavel CONFIRME, relatorio ADM_R024
 \ Analista: Ademilson Pedro Bom
 \ Criacao.: Programado manualmente pelo analista
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/

#include "admbig.ch"    // inicializa constantes manifestas

/*
   -------------------------------------------------------------------
   Se abrir outros arquivos salve situacao anterior e restaure ao sair
   como no exemplo abaixo:
     LOCAL reg_dbf:=POINTER_DBF()
     ...        ...        ...        ...
     POINTER_DBF(reg_dbf)
     RETU
   -------------------------------------------------------------------
*/
   PARAMETROS('valor1',M->rvalor1)
   PARAMETROS('valor2',M->rvalor2)
   PARAMETROS('valor3',M->rvalor3)

RETU .t.   // <- deve retornar um valor L¢GICO

* \\ Final de V02401F9.PRG
/*
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
 \ Empresa.: Ind£stria de Urnas Bignotto Ltda
 \ Programa: ADM_RV33.PRG
 \ Data....: 06-08-97
 \ Sistema.: Administradora - PLANO
 \ Funcao..: Impress„o das Taxas
 \ Analista: Ademilson Pedro Bom
 \ Criacao.: GAS-Pro v3.0 
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/

#include "adrbig.ch"    // inicializa constantes manifestas

LOCAL dele_atu, getlist:={}, so_um_reg, sit_dbf
PARA  lin_menu, col_menu, imp_reg
PRIV  tem_borda:=.t., op_menu:=VAR_COMPL, l_s:=11, c_s:=20, l_i:=16, c_i:=61, tela_fundo:=SAVESCREEN(0,0,MAXROW(),79)
nucop=1
so_um_reg=(PCOU()>2)
IF !so_um_reg                             // vai receber a variaveis?
 SETCOLOR(drvtittel)
 vr_memo=NOVAPOSI(@l_s,@c_s,@l_i,@c_i)    // pega posicao atual da tela
 CAIXA(mold,l_s,c_s,l_i,c_i)              // monta caixa da tela
 @ l_s,c_s+9 SAY " GRUPOS C/TAXAS A EMITIR "
 SETCOLOR(drvcortel)
 @ l_s+01,c_s+1 SAY " Grupo..:      De:       -"
 @ l_s+02,c_s+1 SAY " £ltima Circular.:"
 @ l_s+03,c_s+1 SAY " Pr¢xima Circular:        Confirme:"
ENDI
rgrupo=SPAC(2)                                     // Grupo
rproxcirc=SPAC(3)                                  // N§Proxima Circ.
confirme=SPAC(1)                                   // Confirme
DO WHILE .t.
 rola_t=.f.
 cod_sos=56
 IF !so_um_reg
  SET KEY K_ALT_F8 TO ROLATELA
  SETCOLOR(drvcortel+","+drvcorget+",,,"+corcampo)
  @ l_s+01 ,c_s+11 GET  rgrupo;
                   PICT "!!";
                   VALI CRIT("PTAB(rgrupo,'ARQGRUP',1).or.EMPT(rgrupo)~GRUPO n„o existe na tabela|Deixe sem preencher para imprimir de todos")
                   AJUDA "Entre com o grupo ou |tecle F8 para consulta em tabela"
		   CMDF8 "VDBF(6,33,20,77,'ARQGRUP',{'grup','inicio','final','ultcirc','emissao_','procpend'},1,'grup',[])"
                   MOSTRA {"LEFT(TRAN(ARQGRUP->inicio,[999999]),06)", 1 , 20 }
                   MOSTRA {"LEFT(TRAN(ARQGRUP->final,[999999]),06)", 1 , 27 }
		   MOSTRA {"LEFT(TRAN(ARQGRUP->ultcirc,[999]),03)", 2 , 20 }
                   MOSTRA {"LEFT(TRAN(ARQGRUP->emissao_,[@D]),08)", 2 , 24 }

  @ l_s+03 ,c_s+20 GET  rproxcirc;
                   PICT "999";
		   VALI CRIT("rproxcirc=ARQGRUP->proxcirc.or.rproxcirc='000'~Circular n„o preparada para emiss„o|Deixe com zeros para imprimir todos os preparados")
		   DEFAULT "ARQGRUP->proxcirc"
		   AJUDA "Entre com o n£mero da pr¢xima circular"
		   CMDF8 "STRZERO(VAL(ARQGRUP->ultcirc)+1,3)"

  @ l_s+03 ,c_s+37 GET  confirme;
                   PICT "!";
                   VALI CRIT("confirme='S'~CONFIRME n„o aceit vel")
                   AJUDA "Digite S para confirmar|ou|tecle ESC para cancelar"

  READ
  SET KEY K_ALT_F8 TO
  IF rola_t
   ROLATELA(.f.)
   LOOP
  ENDI
  IF LASTKEY()=K_ESC                               // se quer cancelar
   RETU                                            // retorna
  ENDI
 ENDI

 #ifdef COM_REDE
  IF !USEARQ("TAXAS",.f.,10,1)                     // se falhou a abertura do arq
   RETU                                            // volta ao menu anterior
  ENDI
 #else
  USEARQ("TAXAS")                                  // abre o dbf e seus indices
 #endi

 PTAB(codigo,"GRUPOS",1,.t.)                       // abre arquivo p/ o relacionamento
 PTAB(GRUPOS->grupo,"ARQGRUP",1,.t.)
 PTAB(GRUPOS->regiao,"REGIAO",1,.t.)
 PTAB(GRUPOS->grupo+circ,"CIRCULAR",1,.t.)
 SET RELA TO codigo INTO GRUPOS,;                  // relacionamento dos arquivos
          TO GRUPOS->grupo INTO ARQGRUP,;
          TO GRUPOS->regiao INTO REGIAO,;
	  TO GRUPOS->grupo+circ INTO CIRCULAR
 titrel:=criterio := ""                            // inicializa variaveis
 cpord="cobrador+codigo+tipo+circ"
 titrel:=chv_rela:=chv_1:=chv_2 := ""
 tps:=op_x:=ccop := 1
 arq_=drvporta                                     // porta de saida configurada
 IF !so_um_reg
  IF !opcoes_rel(lin_menu,col_menu,29,11)          // nao quis configurar...
   CLOS ALL                                        // fecha arquivos e
   LOOP                                            // volta ao menu
  ENDI

 #ifdef COM_REDE

  ELSE

   tps=lin_menu

 #endi

 ENDI
 IF tps=2                                          // se vai para arquivo/video
  arq_=ARQGER()                                    // entao pega nome do arquivo
  IF EMPTY(arq_)                                   // se cancelou ou nao informou
   LOOP                                            // retorna
  ENDI
 ELSE
  arq_=drvporta                                    // porta de saida configurada
 ENDI
 SET PRINTER TO (arq_)                             // redireciona saida
 EXIT
ENDD
criterio_=criterio                                 // salva criterio e ordenacao
cpord_=cpord                                       // definidos se huver
criterio=""

#ifdef COM_REDE
 IF !USEARQ("CPRCIRC",.f.,10,1)                    // se falhou a abertura do arq
  RETU                                             // volta ao menu anterior
 ENDI
#else
 USEARQ("CPRCIRC")                                 // abre o dbf e seus indices
#endi

cpord="grupo+circ+DTOS(dfal)"
INDTMP()
criterio=criterio_                                 // restabelece criterio e
cpord=cpord_                                       // ordenacao definidos
SELE TAXAS
IF !EMPTY(drvtapg)                                 // existe configuracao de tam pag?
 op_=AT("NNN",drvtapg)                             // se o codigo que altera
 IF op_=0                                          // o tamanho da pagina
  msg="Configura‡„o do tamanho da p gina!"         // foi informado errado
  DBOX(msg,,,,,"ERRO!")                            // avisa
  CLOSE ALL                                        // fecha todos arquivos abertos
  RETU                                             // e cai fora...
 ENDI                                              // codigo para setar/resetar tam pag
 lpp_048=LEFT(drvtapg,op_-1)+"048"+SUBS(drvtapg,op_+3)
 lpp_066=LEFT(drvtapg,op_-1)+"066"+SUBS(drvtapg,op_+3)
ELSE
 lpp_048:=lpp_066 :=""                             // nao ira mudara o tamanho da pag
ENDI
DBOX("[ESC] Interrompe",15,,,NAO_APAGA)
dele_atu:=SET(_SET_DELETED,.t.)                    // os excluidos nao servem...
SET DEVI TO PRIN                                   // inicia a impressao
maxli=19                                           // maximo de linhas no relatorio
IMPCTL(lpp_048)                                    // seta pagina com 48 linhas
SET MARG TO 1                                      // ajusta a margem esquerda
IF tps=2
 IMPCTL("' '+CHR(8)")
ENDI
BEGIN SEQUENCE
 DO WHIL ccop<=nucop                               // imprime qde copias pedida
  pg_=1; cl=999
  IF so_um_reg
   GO imp_reg
  ELSE
   INI_ARQ()                                       // acha 1o. reg valido do arquivo
  ENDI
  ccop++                                           // incrementa contador de copias
  ult_imp=0                                        // ultimo reg impresso
  DO WHIL !EOF().AND.(!so_um_reg.OR.imp_reg=RECN())
   #ifdef COM_TUTOR
    IF IN_KEY()=K_ESC                              // se quer cancelar
   #else
    IF INKEY()=K_ESC                               // se quer cancelar
   #endi
    IF canc()                                      // pede confirmacao
     BREAK                                         // confirmou...
    ENDI
   ENDI
   IF (tipo$[27].AND.(EMPT(M->rgrupo).OR.GRUPOS->grupo=M->rgrupo).AND.(M->rproxcirc=[000].OR.ARQGRUP->proxcirc=M->rproxcirc)) .OR. so_um_reg// se atender a condicao...
    REL_CAB(1,.t.)                                 // soma cl/imprime cabecalho
    @ cl,000 SAY "."
    ult_imp=RECNO()                                // ultimo reg impresso
    chv048=GRUPOS->grupo+TAXAS->circ
    SELE CPRCIRC
    SEEK chv048
    IF FOUND()
     DO WHIL ! EOF() .AND. chv048=grupo+circ //LEFT(&(INDEXKEY(0)),LEN(chv048))
      #ifdef COM_TUTOR
       IF IN_KEY()=K_ESC                           // se quer cancelar
      #else
       IF INKEY()=K_ESC                            // se quer cancelar
      #endi
       IF canc()                                   // pede confirmacao
	BREAK                                      // confirmou...
       ENDI
      ENDI
      REL_CAB(1)                                   // soma cl/imprime cabecalho
      IMPCTL(drvpc20)                              // comprime os dados
      @ cl,030 SAY CPRCIRC->num                    // Contrato
      @ cl,041 SAY TRAN(CPRCIRC->processo,"@R 99999/99/!!") // Processo
      @ cl,054 SAY CPRCIRC->fal                    // Falecido
      @ cl,091 SAY TRAN(ALLTRIM(CPRCIRC->ends)+'-'+ALLTRIM(CPRCIRC->cids),"@!")// Ends
      @ cl,149 SAY TRAN(CPRCIRC->dfal,"@D")        // Data
      IMPCTL(drvtc20)                              // retira comprimido
      SKIP                                         // pega proximo registro
     ENDD
    ENDI
    SELE TAXAS                                     // volta ao arquivo pai
    SKIP                                           // pega proximo registro
    cl=999                                         // forca salto de pagina
   ELSE                                            // se nao atende condicao
    SKIP                                           // pega proximo registro
   ENDI
  ENDD
  REL_RDP(.t.)                                     // imprime rodape' do relatorio
 ENDD ccop
 EJEC                                              // salta pagina
END SEQUENCE
SET MARG TO                                        // coloca margem esquerda = 0
IMPCTL(lpp_066)                                    // seta pagina com 66 linhas
SET PRINTER TO (drvporta)                          // fecha arquivo gerado (se houver)
SET DEVI TO SCRE                                   // direciona saida p/ video
IF tps=2                                           // se vai para arquivo/video
 BROWSE_REL(arq_,2,3,MAXROW()-2,78)
ENDI                                               // mostra o arquivo gravado
GRELA(29)                                          // grava variacao do relatorio
msgt="PROCESSAMENTOS DO RELAT¢RIO|IMPRESSŽO TAXAS"
ALERTA()
IF so_um_reg
 op_=1
ELSE
 op_=DBOX("Prosseguir|Cancelar opera‡„o",,,E_MENU,,msgt)
ENDI
IF op_=1
 DBOX("Processando registros|<      %>",,,,NAO_APAGA,"AGUARDE!")
 dele_atu:=SET(_SET_DELETED,.t.)                   // os excluidos nao servem...
 SELE TAXAS                                        // processamentos apos emissao
 IF so_um_reg
  GO imp_reg
 ELSE
  INI_ARQ()                                        // acha 1o. reg valido do arquivo
 ENDI
 gauge(0)
 DO WHIL !EOF().AND.(!so_um_reg.OR.imp_reg=RECN())
  gauge(1)
   IF (tipo$[27].AND.(EMPT(M->rgrupo).OR.GRUPOS->grupo=M->rgrupo).AND.(M->rproxcirc=[000].OR.ARQGRUP->proxcirc=M->rproxcirc)) .OR. so_um_reg// se atender a condicao...

   #ifdef COM_REDE
    IF stat < [2]
     REPBLO('TAXAS->stat',{||[2]})
    ENDI
   #else
    IF stat < [2]
     REPL TAXAS->stat WITH [2]
    ENDI
   #endi
   ENDI
   SKIP                                            // pega proximo registro
 ENDD
 ALERTA(2)
// DBOX("Processo terminado com sucesso!",,,,,msgt)
ENDI
SELE TAXAS                                         // salta pagina
SET RELA TO                                        // retira os relacionamentos
SET(_SET_DELETED,dele_atu)                         // os excluidos serao vistos
IF so_um_reg
 POINTER_DBF(sit_dbf)
ENDI
RETU

STATIC PROC REL_RDP(volta_reg)                     // rodape'
LOCAL ar_:=ALIAS(), reg_atual
SELE TAXAS                                         // volta ao arquivo pai
reg_atual=RECNO()
IF volta_reg
 GO ult_imp                                        // ajusta reg p/ imp de campos no rodape'
ENDI
IMPCTL(drvtc20)                              // retira comprimido
@ 21,017 SAY CIRCULAR->menscirc            // Mensagem
@ 25,017 SAY TRAN(TAXAS->valor,"@E 999,999.99")    // Valor
@ 25,065 SAY TRAN(TAXAS->valor,"@E 999,999.99")    // Valor 2
@ 28,020 SAY TRAN(0,"########")                    // N§ Recibo
@ 28,068 SAY TRAN(0,"########")                    // N§ Recibo 2
@ 31,002 SAY TAXAS->tipo+[-]+TAXAS->circ+[   ]+DTOC(TAXAS->emissao_)+[     ]+STR(GRUPOS->funerais,2)// Circular 1
@ 31,038 SAY TAXAS->tipo+[-]+TAXAS->circ+[   ]+DTOC(TAXAS->emissao_)+[     ]+STR(GRUPOS->funerais,2)// Circular 2
@ 34,002 SAY GRUPOS->grupo +[        ]+TAXAS->codigo+[       ]+GRUPOS->cobrador// Grupo 1
@ 34,038 SAY GRUPOS->grupo +[        ]+TAXAS->codigo+[       ]+GRUPOS->cobrador// Grupo 2
@ 36,000 SAY GRUPOS->nome                          // Nome
@ 36,036 SAY GRUPOS->nome                          // Nome 2
@ 37,000 SAY GRUPOS->endereco                      // Endere‡o
@ 37,036 SAY GRUPOS->endereco                      // Endere‡o 2
@ 38,000 SAY GRUPOS->bairro                        // Bairro
@ 38,036 SAY GRUPOS->bairro                        // Bairro 2
@ 39,000 SAY GRUPOS->cidade+[ ] +GRUPOS->cep       // Cidade
@ 39,036 SAY GRUPOS->cidade+[ ] +GRUPOS->cep       // Cidade 2
@ 40,000 SAY [Inic:]+DTOC(GRUPOS->admissao)+[ Ult:]+GRUPOS->ultcirc+[ QtTx:]+STR(GRUPOS->qtcircs,3)// Inicio
@ 40,036 SAY [Inic:]+DTOC(GRUPOS->admissao)+[ Ult:]+GRUPOS->ultcirc+[ QtTx:]+STR(GRUPOS->qtcircs,3)// Inicio 2
@ 42,000 SAY ""
IF M->combarra=[S]
 CODBARRAS({{TAXAS->codigo+TAXAS->tipo+TAXAS->circ,1,13,18}},10,6)
ENDI
@ 43,002 SAY [ ]                                   // data 1
@ 43,039 SAY [ ]                                   // data 2
IF M->combarra=[S]
 CODBARRAS({{TAXAS->codigo+TAXAS->tipo+TAXAS->circ,1,13,18}},10,6)
ENDI
IF volta_reg
 GO reg_atual                                      // retorna reg a posicao original
ENDI
SELE (ar_)
RETU 

STATIC PROC REL_CAB(qt, volta_reg)                 // cabecalho do relatorio
LOCAL ar_:=ALIAS()
volta_reg=IF(volta_reg=NIL,.f.,volta_reg)
IF qt>0                                            // se parametro maior que 0
 cl=cl+qt                                          // soma no contador de linhas
ENDI
IF cl>maxli .OR. qt=0                              // quebra de pagina
 IF pg_>1
  REL_RDP(volta_reg)                               // imprime rodape' do relatorio
 ENDI
 SELE TAXAS                                        // volta ao arquivo pai
 @ 1,007 SAY GRUPOS->nome                          // Nome
 @ 1,058 SAY TRAN(TAXAS->codigo,"999999")          // Codigo
 @ 1,076 SAY TRAN(GRUPOS->grupo,"!!")              // Grupo
 @ 3,032 SAY TRAN(TAXAS->valor,"@E 999,999.99")    // Valor
 SELE (ar_)
 cl=qt+7 ; pg_++
ENDI
RETU

* \\ Final de ADM_RV33.PRG
GAS-Pro v4.0
003009024072001002018001005001176001
 Conta Recebto.:         Conta Pagto.:
 H.Abertura Cx.:
 H.Recebimentos:
 H.Outros Receb:
 Hist.Pagamento:
       ÄÄÄÄÄÄÄÄÄÄ Dados do £ltimo lan‡amento ÄÄÄÄÄÄÄÄÄÄ
 Grupo.:    Filial:     C¢digo:        Inscr:    Seq:
       ÄÄÄÄÄÄÄÄÄÄÄÄÄ Dados de uso interno ÄÄÄÄÄÄÄÄÄÄÄÄÄ
 Cancelamentos:           Reintegra‡”es:
 Recibo 2¦ Via:           Contr.        Tipo   Circ
 C¢digo de Grupo para o VIP:
 Imprime recibo com c¢digo barra?
 Os Inscritos est„o cadastrados?
 Imprime os recibos da recep‡„o c/Falecidos?
 Cidade:
 Usar como padr„o recibos em formul rio branco?
       ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ Dados da Empresa ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
                                         CGC
[Ÿ]
[Ÿ]
 39 
 0 
Parƒmetros do sistema
Parƒmetros







054
























 0 











 0 
 2 
-1 
-1 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
pgrupo
C
V
!!
 2 
 2 
 7 
 10 
 0 
Grupo






 0 
 0 


p_filial
C
E
@!
 2 
 2 
 7 
 21 
 0 
C¢digo

 


Informe o c¢digo da filial

 0 
 0 


pcontrato
C
V
999999
 6 
 6 
 7 
 33 
 0 
Codigo






 0 
 0 


pgrau
C
V
9
 1 
 1 
 7 
 47 
 0 
Inscr.






 0 
 0 


pseq
N
V
99
 2 
 2 
 7 
 55 
 0 
Seq






 0 
 0 


pverpag
C
I
!
 1 
 1 
 0 
 0 
 0 
Verificar Pagas?






 0 
 0 


preplanc
C
I
!
 1 
 1 
 0 
 0 
 0 
Repetir lan‡amento?






 0 
 0 


lastcodigo
C
I
999999
 6 
 6 
 0 
 0 
 0 
Maior Contrato






 0 
 0 


nrcanc
N
V
999999
 6 
 6 
 9 
 17 
 0 
N£mero



000000


 0 
 0 


nrreint
N
V
999999
 6 
 6 
 9 
 42 
 0 
Nrreint






 0 
 0 


contarec
C
E
@!
 5 
 5 
 1 
 18 
 0 
Conta Recepcao

!EMPT(contarec)
Necess rio informar CONTA RECEPCAO p/recebimentos
[RECEP]
Informe a Conta que receber |os lan‡amentos da recep‡„o.

 0 
 0 


contapag
C
E
@!
 5 
 5 
 1 
 41 
 0 
Conta Pagamento

!EMPT(contapag)
Necess rio informar CONTA RECEPCAO p/Pagamentos
[RECEP]
Informe a Conta que pagar |os lan‡amentos da recep‡„o.

 0 
 0 


histrccar
C
E
999
 3 
 3 
 2 
 18 
 0 
Hist¢rico

histrccar=[000].OR. PTAB(histrccar,'HISTORIC',1)
HIST¢RICO n„o existe na tabela
[004]
Informe o hist¢rico do lan‡amento|para parcelas recebidas na Recep‡„o.
VDBF(6,24,20,77,'HISTORIC',{'historico','descricao','tipo'},1,'historico',[HISTORIC->origem$'ADM   '])
 0 
 0 


histrcfcc
C
E
999
 3 
 3 
 3 
 18 
 0 
Hist¢rico

histrcfcc=[000].OR. PTAB(histrcfcc,'HISTORIC',1)
HIST¢RICO n„o existe na tabela
[001]
Informe o hist¢rico do lan‡amento de|recebimento de FCC.
VDBF(6,24,20,77,'HISTORIC',{'historico','descricao','tipo'},1,'historico',[HISTORIC->origem$'ADM   '])
 0 
 0 


histrcrec
C
E
999
 3 
 3 
 4 
 18 
 0 
Hist¢rico

histrcrec=[000].OR. PTAB(histrcrec,'HISTORIC',1)
HIST¢RICO n„o existe na tabela
[002]
Informe o hist¢rico do lan‡amento|para taxas recebidas na Recep‡„o.
VDBF(6,24,20,77,'HISTORIC',{'historico','descricao','tipo'},1,'historico',[HISTORIC->origem$'ADM   '])
 0 
 0 


histpg
C
E
999
 3 
 3 
 5 
 18 
 0 
Hist¢rico

histpg=[000].OR. PTAB(histpg,'HISTORIC',1)
HIST¢RICO n„o existe na tabela
[003]
Informe o hist¢rico|para lan‡amento de pagamentos.
VDBF(6,24,20,77,'HISTORIC',{'historico','descricao','tipo'},1,'historico',[HISTORIC->origem$'ADM   '])
 0 
 0 


nrauxrec
C
E
@R 99-999999
 8 
 9 
 10 
 17 
 0 
N§ Recibo

!EMPT(nrauxrec)
Necess rio informar N§ RECIBO

Informe o n£mero do recibo a imprimir.|no formato AA-NNNNNN|onde: AA=Ano, N=n£mero

 0 
 0 


mcodigo
C
E
999999
 6 
 6 
 10 
 34 
 0 
Codigo

PTAB(mcodigo,'GRUPOS',1).AND.PTAB(mcodigo,'TAXAS',1).OR.mcodigo=[00000]
C¢digo inv lido ou sem Taxas pendentes

Informe o n£mero do contrato
VDBF(6,26,20,77,'GRUPOS',{'grupo','codigo','nome'},1,'codigo',[situacao=1])
 0 
 0 


mtipo
C
E
!
 1 
 1 
 10 
 46 
 0 
Tipo

mtipo $ [123678]
TIPO n„o aceit vel

Qual o tipo de lan‡amento
MTAB([1=J¢ia|2=Taxa|3=Carnˆ|6=J¢ia+Seguro|7=Taxa+Seguro|8=Carnˆ+Seguro],[TIPO])
 0 
 0 


mcirc
C
E
999
 3 
 3 
 10 
 53 
 0 
Circular
!(mcodigo=[00000])
PTAB(mcodigo+mcirc,'TAXAS',1).AND.PTAB(GRUPOS->grupo+mcirc,'CIRCULAR',1)
Necess rio informar CIRCULAR existente

N£mero da Circular|Mantido pela emissao de recibos
VDBF(6,22,20,77,'TAXAS',{'codigo','circ','emissao_','valor','valorpg','forma'},1,'circ',[])
 0 
 0 


mgrupvip
C
E
!!
 2 
 2 
 11 
 30 
 0 
Grup

EMPT(mgrupvip).OR.PTAB(mgrupvip,'ARQGRUP',1)
GRUP n„o existe na tabela

Entre com o c¢digo do Grupo que ser  utilizado|como controle dos contratos VIPs.

 0 
 0 


combarra
C
E
!
 1 
 1 
 12 
 35 
 0 
Combarra

combarra$'SN '
COMBARRA n„o aceit vel|Digite S ou N

Informe se os recibos devem ser impressos|com o c¢digo de barras

 0 
 0 


cinscr
C
E
!
 1 
 1 
 13 
 34 
 0 
Com Inscritos

cinscr$'SN '
Digite S ou N

Informe se os Inscritos estÆo cadastrados

 0 
 0 


comfalec
C
E
!
 1 
 1 
 14 
 46 
 0 
Com Falecido

comfalec$'SN '
Digite S para imprimir recibos com os|Falecidos da circular.

Informe se os recibos da recep‡Æo|devem ser impressos com os|falecidos (cartinha)

 0 
 0 


mproc1
C
I
99999
 5 
 5 
 0 
 0 
 0 
Processo






 0 
 0 


mproc2
C
I
99
 2 
 2 
 0 
 0 
 0 
Ano






 0 
 0 


mproc3
C
I
!!
 2 
 2 
 0 
 0 
 0 
Mproc3






 0 
 0 


impnrrec
C
I
99999
 5 
 5 
 0 
 0 
 0 
N£mero






 0 
 0 


procimp
C
I
@R 99999/99/!!
 9 
 11 
 0 
 0 
 0 
Procimp






 0 
 0 


pvalor
N
I
@E 999,999.99
 9 
 10 
 0 
 0 
 2 
Valor






 0 
 0 


pcob
C
I
!!!
 3 
 3 
 0 
 0 
 0 
Cobrador






 0 
 0 


mmesref
C
I
@R 99/99
 4 
 5 
 0 
 0 
 0 
Mˆs Ref.






 0 
 0 


pnumfcc
C
I
 
 8 
 8 
 0 
 0 
 0 
Pnumfcc






 0 
 0 


p_cidade
C
E
@!
 25 
 25 
 15 
 10 
 0 
Munic¡pio

!EMPT(p_cidade)
Necess rio informar MUNIC¡PIO
[LIMEIRA]
Entre com o nome do Munic¡pio

 0 
 0 


p_recp
C
E
!
 1 
 1 
 16 
 49 
 0 
Recibo Padr„o

(p_recp$[SN ])
RECIBO PADRŽO n„o aceit vel|Digite S, N ou deixe sem preencher.
[S]
Digite S para utilizar o modelo|Padronizado de recibos (formul rio branco)|ou N para recibos personalizados
MTAB([S-Recibos em pap‚l branco|N-Recibos pr‚-impressos],[RECIBO PADRŽO])
 0 
 0 


setup1
C
E
 
 40 
 40 
 18 
 1 
 0 
Ident1

!EMPT(setup1)
Digite o nome da Empresa|Ser  utilizado em relat¢rios
[Ind£stria de Urnas Bignotto Ltda]
Informe o nome da Empresa

 0 
 0 


cgcsetup
C
E
@R 99.999.999/9999-99
 14 
 18 
 18 
 45 
 0 
CGC

VCGC(cgcsetup).or.EMPT(cgcsetup)
Necess rio informar CGC



 0 
 0 


setup2
C
E
 
 50 
 50 
 19 
 9 
 0 
Ident2

!EMPT(setup2)
Digite o endere‡o,|ser  a 2¦ linha de cabe‡alho|de alguns relat¢rios

Digite o endere‡o.
Informe o endere‡o da Empresa
 0 
 0 


setup3
C
E
 
 50 
 50 
 20 
 9 
 0 
Setup3

 


Informe a 3¦ linha de cabe‡alho.|Ex.: Telefone, Fax, etc...

 0 
 0 


 4 
Desc.Pgto.
IIF(PTAB(histpg,'HISTORIC',1),HISTORIC->descricao,SPACE(40))

 5 
 22 
 40 

Desc.Recebto
IIF(PTAB(histrcrec,'HISTORIC',1),HISTORIC->descricao,SPACE(40))

 3 
 22 
 40 

Desc.Receb.FCC
IIF(PTAB(histrcfcc,'HISTORIC',1),HISTORIC->descricao,SPACE(40))

 2 
 22 
 40 

Descri‡„o de Hi
IIF(PTAB(histrccar,'HISTORIC',1),HISTORIC->descricao,SPACE(40))

 4 
 22 
 40 

 0 
 0 
 0 
 0 
      SIxMemo                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 GAS-Pro v3.0
009013013066001001012001010000176001
 Tipo..:
 N£mero:
[Ÿ]
[Ÿ]
 2 
 0 
Documento … Imprimir
Documento … Imprimir







056







 0 
 0 
-1 
-1 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
tipdoc
C
E
!!!
 3 
 3 
 1 
 10 
 0 
Tipo
MTAB([BXR-Recebimentos|OBX-Outros recebimentos|AFU-Aux¡lio Funeral],[TIPO])
 

[BXR]
Informe o tipo do documento a imprimir|Tecle F8 para tabela auxiliar.
MTAB([BXR-Recebimentos|OBX-Outros recebimentos|AFU-Aux¡lio Funeral],[TIPO])
 0 
 0 


docto
C
E
 
 12 
 12 
 2 
 10 
 0 
Documento
DCI01F9()
 

IIF(PTAB(PADR(SUBSTR(M->ide_maq,2),4)+tipdoc,[IMPPAR],1),IMPPAR->docto,[ ])
Digite neste campo o n£mero de|identifica‡„o do documento|(N„o utilize barras nem tra‡os)
DCI01F9()
 0 
 0 


 2 
Tipo do docto
DCI03F9(M->tipdoc)

 1 
 14 
 35 

Descr.Documento
DCI04F9(M->tipdoc)

 3 
 2 
 50 

 0 
 0 
 0 
 0 
/*
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
 \ Empresa.: Ind£stria de Urnas Bignotto Ltda
 \ Programa: ADP_R066.PRG
 \ Data....: 03-03-97
 \ Sistema.: Administradora - PLANO
 \ Funcao..: Impress„o VIP
 \ Analista: Ademilson Pedro Bom
 \ Criacao.: GAS-Pro v3.0 
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/

#include "adpbig.ch"    // inicializa constantes manifestas

LOCAL dele_atu, getlist:={}
PARA  lin_menu, col_menu
PRIV  tem_borda:=.t., op_menu:=VAR_COMPL, l_s:=7, c_s:=17, l_i:=12, c_i:=61, tela_fundo:=SAVESCREEN(0,0,MAXROW(),79)
nucop=1
SETCOLOR(drvtittel)
vr_memo=NOVAPOSI(@l_s,@c_s,@l_i,@c_i)     // pega posicao atual da tela
CAIXA(mold,l_s,c_s,l_i,c_i)               // monta caixa da tela
@ l_s,c_s+15 SAY " IMPRESSŽO VIP "
SETCOLOR(drvcortel)
@ l_s+01,c_s+1 SAY "  Emiss„o de.:          at‚.:"
@ l_s+02,c_s+1 SAY "  Contrato de:          at‚.:"
@ l_s+04,c_s+1 SAY "  Confirme..:"
rem1_=CTOD('')                                     // Emiss„o
rem2_=CTOD('')                                     // Emiss„o
rcod1=SPAC(6)                                      // Contrato
rcod2=SPAC(6)                                      // Contrato
confirme=SPAC(1)                                   // Confirme
DO WHILE .t.
 rola_t=.f.
 cod_sos=56
 SET KEY K_ALT_F8 TO ROLATELA
 SETCOLOR(drvcortel+","+drvcorget+",,,"+corcampo)
 @ l_s+01 ,c_s+16 GET  rem1_;
                  PICT "@D";
                  VALI CRIT("!EMPT(Rem1_)~Informe uma data v lida p/ EMISSŽO | data de hoje ou posterior.")
                  DEFAULT "CTOD('01'+SUBSTR(DTOC(DATE()-30),3))"
                  AJUDA "Data da Emiss„o da Circular.| Para atualizar circulares se n„o preenchidas| com antecedˆncia."

 @ l_s+01 ,c_s+31 GET  rem2_;
                  PICT "@D";
                  VALI CRIT("!EMPT(Rem2_)~Informe uma data v lida, deve ser posterior|a inicial")
                  DEFAULT "rem1_+30"
                  AJUDA "Emitir as emitidas para que vencimento?"

 @ l_s+02 ,c_s+16 GET  rcod1;
                  PICT "999999";
                  VALI CRIT("PTAB(rcod1,'GRUPOS',1).OR.rcod1='000000'~CODIGO n„o aceit vel|Digite zeros para listar todos os|contratos no intervalo")
                  AJUDA "Entre com o n£mero do contrato"
		  CMDF8 "VDBF(6,26,20,77,'GRUPOS',{'grupo','codigo','nome'},1,'codigo')"

 @ l_s+02 ,c_s+31 GET  rcod2;
                  PICT "999999";
                  VALI CRIT("PTAB(rcod2,'GRUPOS',1).OR.rcod2 >= rcod1~CODIGO n„o aceit vel|Digite zeros para listar todos os|contratos no intervalo")
                  AJUDA "Entre com o n£mero do contrato"
                  CMDF8 "VDBF(6,26,20,77,'GRUPOS',{'grupo','codigo','nome'},1,'codigo')"

 @ l_s+04 ,c_s+15 GET  confirme;
                  PICT "!";
                  VALI CRIT("confirme= 'S'~CONFIRME n„o aceit vel|Digite S ou Tecle ESC")
                  AJUDA "Digite S para confirmar |ou|Tecle ESC para cancelar"

 READ
 SET KEY K_ALT_F8 TO
 IF rola_t
  ROLATELA(.f.)
  LOOP
 ENDI
 IF LASTKEY()=K_ESC                                // se quer cancelar
  RETU                                             // retorna
 ENDI

 #ifdef COM_REDE
  IF !USEARQ("TAXAS",.t.,10,1)                     // se falhou a abertura do arq
   RETU                                            // volta ao menu anterior
  ENDI
 #else
  USEARQ("TAXAS")                                  // abre o dbf e seus indices
 #endi

 PTAB(codigo,"GRUPOS",1,.t.)                       // abre arquivo p/ o relacionamento
 PTAB(GRUPOS->tipcont,"CLASSES",1,.t.)
 PTAB(cobrador,"COBRADOR",1,.t.)
 PTAB(codigo+tipo+circ,"CSTSEG",3,.t.)
 PTAB(codigo,"MENSAG",1,.t.)
 SET RELA TO codigo INTO GRUPOS,;                  // relacionamento dos arquivos
	  TO GRUPOS->tipcont INTO CLASSES,;
	  TO cobrador INTO COBRADOR,;
	  TO codigo+tipo+circ INTO CSTSEG,;
	  TO codigo INTO MENSAG
 titrel:=criterio:=cpord := ""                     // inicializa variaveis
 titrel:=chv_rela:=chv_1:=chv_2 := ""
 tps:=op_x:=ccop := 1
 IF !opcoes_rel(lin_menu,col_menu,10,11)           // nao quis configurar...
  CLOS ALL                                         // fecha arquivos e
  LOOP                                             // volta ao menu
 ENDI
 IF tps=2                                          // se vai para arquivo/video
  arq_=ARQGER()                                    // entao pega nome do arquivo
  IF EMPTY(arq_)                                   // se cancelou ou nao informou
   LOOP                                            // retorna
  ENDI
 ELSE
  arq_=drvporta                                    // porta de saida configurada
 ENDI
 SET PRINTER TO (arq_)                             // redireciona saida
 EXIT
ENDD
IF !EMPTY(drvtapg)                                 // existe configuracao de tam pag?
 op_=AT("NNN",drvtapg)                             // se o codigo que altera
 IF op_=0                                          // o tamanho da pagina
  msg="Configura‡„o do tamanho da p gina!"         // foi informado errado
  DBOX(msg,,,,,"ERRO!")                            // avisa
  CLOSE ALL                                        // fecha todos arquivos abertos
  RETU                                             // e cai fora...
 ENDI                                              // codigo para setar/resetar tam pag
 lpp_026=LEFT(drvtapg,op_-1)+"026"+SUBS(drvtapg,op_+3)
 lpp_066=LEFT(drvtapg,op_-1)+"066"+SUBS(drvtapg,op_+3)
ELSE
 lpp_026:=lpp_066 :=""                             // nao ira mudara o tamanho da pag
ENDI
DBOX("[ESC] Interrompe",15,,,NAO_APAGA)
dele_atu:=SET(_SET_DELETED,.t.)                    // os excluidos nao servem...
SET DEVI TO PRIN                                   // inicia a impressao
maxli=24                                           // maximo de linhas no relatorio
IMPCTL(lpp_026)                                    // seta pagina com 26 linhas
SET MARG TO 1                                      // ajusta a margem esquerda
IF tps=2
 IMPCTL("' '+CHR(8)")
ENDI
BEGIN SEQUENCE
 DO WHIL ccop<=nucop                               // imprime qde copias pedida
  pg_=1; cl=999
  INI_ARQ()                                        // acha 1o. reg valido do arquivo
  ccop++                                           // incrementa contador de copias
  DO WHIL !EOF()
   #ifdef COM_TUTOR
    IF IN_KEY()=K_ESC                              // se quer cancelar
   #else
    IF INKEY()=K_ESC                               // se quer cancelar
   #endi
    IF canc()                                      // pede confirmacao
     BREAK                                         // confirmou...
    ENDI
   ENDI
   IF R06601F9()                                   // se atender a condicao...
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,015 SAY "Contr :"
    IF PTAB(codigo+[1]+circ,"CSTSEG",3,.t.)
     valororig=CSTSEG->vlorig
    ELSE
     valororig=valor   // variavel temporaria
    ENDI
    @ cl,023 SAY TRAN(valororig,"@E 999,999.99")   // Valor Contribuicao
    @ cl,062 SAY "Contr :"
    @ cl,069 SAY TRAN(valororig,"@E 999,999.99")   // Valor Contribuicao 2
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,015 SAY "Seguro:"
    @ cl,023 SAY TRAN(valor-valororig,"@E 999,999.99")// Valor Seguro
    @ cl,062 SAY "Seguro:"
    @ cl,069 SAY TRAN(valor-valororig,"@E 999,999.99")// Valor Seguro 2
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,015 SAY "TOTAL.:"
    IF R06601F9()                                  // pode imprimir?
     @ cl,023 SAY TRAN(valor,"@E 999,999.99")      // Valor Total
    ENDI
    @ cl,062 SAY "TOTAL.:"
    @ cl,069 SAY TRAN(valor,"@E 999,999.99")       // Valor Total 2
    REL_CAB(3)                                     // soma cl/imprime cabecalho
    IMPEXP(cl,000,GRUPOS->codigo,12)               // Codigo
    IMPCTL(drvpenf)
    @ cl,023 SAY [/]+tipo+[/]+circ+[ ]             // compl.codigo 2
    IMPCTL(drvtenf)
    IMPEXP(cl,039,GRUPOS->codigo,12)               // Codigo 2
    IMPCTL(drvpenf)
    @ cl,062 SAY [/]+tipo+[/]+circ+[ ]             // compl.codigo 1
    IMPCTL(drvtenf)
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY "Vencto.:"
    @ cl,009 SAY TRAN(emissao_,"@D")               // Emissao
    @ cl,020 SAY "Admiss:"
    @ cl,027 SAY TRAN(GRUPOS->admissao,"@D")       // Admiss„o
    @ cl,039 SAY "Vencto.:"
    @ cl,048 SAY TRAN(emissao_,"@D")               // Emissao 2
    @ cl,059 SAY "Admiss:"
    @ cl,066 SAY TRAN(GRUPOS->admissao,"@D")       // Admiss„o 2
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY "Cobrador..:"
    @ cl,011 SAY COBRADOR->cobrador+[ ]+LEFT(COBRADOR->nome,15)// Cobrador
    @ cl,039 SAY "Cobrador..:"
    @ cl,050 SAY COBRADOR->cobrador+[ ]+LEFT(COBRADOR->nome,15)// Cobrador 2
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY ALLTRIM(CLASSES->descricao)+[ ]+IIF(GRUPOS->formapgto$[01,02,03,04,05],SUBSTR(tbfpgto,(VAL(GRUPOS->formapgto)-1)*13+1,13),GRUPOS->formapgto)// definicao 1
    @ cl,039 SAY ALLTRIM(CLASSES->descricao)+[ ]+IIF(GRUPOS->formapgto$[01,02,03,04,05],SUBSTR(tbfpgto,(VAL(GRUPOS->formapgto)-1)*13+1,13),GRUPOS->formapgto)// definicao 2
    REL_CAB(2)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY GRUPOS->nome                      // Nome
    @ cl,039 SAY GRUPOS->nome                      // Nome 2
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY GRUPOS->endereco                  // Endere‡o
    @ cl,039 SAY GRUPOS->endereco                  // Endere‡o 2
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY GRUPOS->bairro                    // Bairro
    @ cl,039 SAY GRUPOS->bairro                    // Bairro 2
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY GRUPOS->cep+[ ]+ALLTRIM(GRUPOS->cidade)+[, ]+GRUPOS->uf// Cidade
    @ cl,039 SAY GRUPOS->cep+[ ]+ALLTRIM(GRUPOS->cidade)+[, ]+GRUPOS->uf// Cidade 2
    REL_CAB(3)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY ""
    IF M->combarra=[S]
     CODBARRAS({{codigo+tipo+circ,4,13,19}},10,6)
    ENDI
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY ""
    IF M->combarra=[S]
     CODBARRAS({{codigo+tipo+circ,4,13,19}},10,6)
    ENDI
    SKIP                                           // pega proximo registro
    cl=999                                         // forca salto de pagina
   ELSE                                            // se nao atende condicao
    SKIP                                           // pega proximo registro
   ENDI
  ENDD
 ENDD ccop
 EJEC                                              // salta pagina
END SEQUENCE
SET MARG TO                                        // coloca margem esquerda = 0
IMPCTL(lpp_066)                                    // seta pagina com 66 linhas
SET PRINTER TO (drvporta)                          // fecha arquivo gerado (se houver)
SET DEVI TO SCRE                                   // direciona saida p/ video
IF tps=2                                           // se vai para arquivo/video
 BROWSE_REL(arq_,2,3,MAXROW()-2,78)
ENDI                                               // mostra o arquivo gravado
GRELA(10)                                          // grava variacao do relatorio
msgt="PROCESSAMENTOS DO RELAT¢RIO|IMPRESSŽO VIP"
ALERTA()
op_=DBOX("Prosseguir|Cancelar opera‡„o",,,E_MENU,,msgt)
IF op_=1
 DBOX("Processando registros",,,,NAO_APAGA,"AGUARDE!")
 dele_atu:=SET(_SET_DELETED,.t.)                   // os excluidos nao servem...
 SELE TAXAS                                        // processamentos apos emissao
 INI_ARQ()                                         // acha 1o. reg valido do arquivo
 DO WHIL !EOF()
  IF R06601F9()                                    // se atender a condicao...

   #ifdef COM_REDE
    IF stat < [2]
     REPBLO('TAXAS->stat',{||[2]})
    ENDI
   #else
    IF stat < [2]
     REPL TAXAS->stat WITH [2]
    ENDI
   #endi

   SKIP                                            // pega proximo registro
  ELSE                                             // se nao atende condicao
   SKIP                                            // pega proximo registro
  ENDI
 ENDD
 ALERTA(2)
 DBOX("Processo terminado com sucesso!",,,,,msgt)
ENDI
SELE TAXAS                                         // salta pagina
SET RELA TO                                        // retira os relacionamentos
SET(_SET_DELETED,dele_atu)                         // os excluidos serao vistos
RETU

STATIC PROC REL_CAB(qt)                            // cabecalho do relatorio
IF qt>0                                            // se parametro maior que 0
 cl=cl+qt                                          // soma no contador de linhas
ENDI
IF cl>maxli .OR. qt=0                              // quebra de pagina
 cl=qt+1 ; pg_++
ENDI
RETU

* \\ Final de ADP_R066.PRG
procedure dci01f9
/*
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
 \ Empresa.: PresServ Inform tica-Limeira (019)452.6623
 \ Programa: DCI01F9.PRG
 \ Data....: 29-08-97
 \ Sistema.: Administradora - RECEP€„O
 \ Funcao..: Fun‡„o F8 da variavel DOCTO, relatorio DCI_P001
 \ Analista: Ademilson Pedro Bom
 \ Criacao.: Programado manualmente pelo analista
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/

#include "adrbig.ch"    // inicializa constantes manifestas
priva donedci:=[]
IF tipdoc=[BXR]
 donedci:=VDBF(6,20,20,77,'BXREC',{'ano','numero','codigo','tipo','circ','valorpg','emitido_'},1,'DCI02F9([BXR])',[])
ELSEIF tipdoc=[OBX]
 donedci:=VDBF(6,4,20,77,'OBXEC',{'ano','numero','codigo','ref','valorpg','emitido_'},1,'DCI02F9([OBX])',[])
ELSEIF tipdoc=[AFU]
 donedci:=VDBF(6,3,20,77,'AFUNER',{'processo','proc2','filial','ocorr_','categ','contrato','falecido'},1,'DCI02F9([AFU])',[])
ELSEIF tipdoc=[BXF]
 donedci:=VDBF(6,23,20,77,'BXFCC',{'idfilial','numero','lancto_','cobrador','baixa_','vltaxas'},1,'DCI02F9([BXF])',[])
ELSEIF tipdoc=[CAD]
 donedci:=VDBF(6,3,20,77,'CADPROC',{'processo','proc2','filial','ocorr_','tippgto','valor','falecido'},1,'DCI02F9([CAD])',[])
ELSEIF tipdoc=[PCO]
 donedci:=VDBF(6,12,20,77,'PCOROAS',{'numero','nomesolic','processo'},1,'DCI02F9([PCO])',[])
ELSEIF tipdoc=[NFI]
 donedci:=VDBF(6,7,20,77,'NFISCAL',{'numeronf','processo','firma'},1,'DCI02F9([NFI])',[])
ELSEIF tipdoc=[REC]
 donedci:=VDBF(6,3,20,77,'RECIBOS',{'ano','numero','processo','valor','nome'},1,'DCI02F9([REC])',[])
ELSEIF tipdoc=[RCO]
 donedci:=VDBF(6,12,20,77,'RCOROAS',{'ano','numero','processo','nome'},1,'DCI02F9([RCO])',[])
ENDI
RETU M->donedci       // <- deve retornar um valor qualquer

FUNCTION dci02f9
PARA doneaux
IF doneaux=[BXR]
 RETU BXREC->ano+BXREC->numero
ELSEIF doneaux=[OBX]
 RETU OBXEC->ano+OBXEC->numero
ELSEIF doneaux=[AFU]
 RETU AFUNER->processo+AFUNER->proc2+AFUNER->filial
ELSEIF doneaux=[BXF]
 RETU BXFCC->idfilial+BXFCC->numero
ELSEIF doneaux=[CAD]
 RETU CADPROC->processo+CADPROC->proc2+CADPROC->filial
ELSEIF doneaux=[PCO]
 RETU PCOROAS->numero
ELSEIF doneaux=[NFI]
 RETU NFISCAL->numeronf
ELSEIF doneaux=[REC]
 RETU RECIBOS->ano+RECIBOS->numero
ELSEIF doneaux=[RCO]
 RETU RCOROAS->ano+RCOROAS->numero

ENDI
RETU []
* \\ Final de DCI01F9.PRG
      SIxMemo                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 /*
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
 \ Empresa.: Ind£stria de Urnas Bignotto Ltda
 \ Programa: ADM_R024.PRG
 \ Data....: 03-01-96
 \ Sistema.: Administradora de Funer rias
 \ Funcao..: Transferˆncia FCC
 \ Analista: Ademilson Pedro Bom
 \ Criacao.: GAS-Pro v2.0
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/

#include "admbig.ch"    // inicializa constantes manifestas

LOCAL dele_atu, getlist:={}
PARA  lin_menu, col_menu
PRIV  tem_borda:=.t., op_menu:=1, l_s:=9, c_s:=20, l_i:=15, c_i:=61, tela_fundo:=SAVESCREEN(0,0,MAXROW(),79)
nucop=1
SETCOLOR(drvtittel)
vr_memo=NOVAPOSI(@l_s,@c_s,@l_i,@c_i)     // pega posicao atual da tela
CAIXA(mold,l_s,c_s,l_i,c_i)               // monta caixa da tela
@ l_s,c_s+12 SAY " TRANSFERENCIA FCC "
SETCOLOR(drvcortel)
@ l_s+01,c_s+1 SAY " Valor Normal....:"
@ l_s+02,c_s+1 SAY " Valor 1§ Retorno:"
@ l_s+03,c_s+1 SAY " Valor 2§ Retorno:"
@ l_s+04,c_s+1 SAY " Valor 3§ Retorno:"
@ l_s+05,c_s+1 SAY "                      Confirma?"
rvalor=0                                           // Valor Normal
rvalor1=0                                          // Valor 1§ Retorno
rvalor2=0                                          // Valor 2§ Retorno
rvalor3=0                                          // Valor 3§ Retorno
confirme=SPAC(1)                                   // Confirme?
DO WHILE .t.
 rola_t=.f.
 cod_sos=56
 SET KEY K_ALT_F8 TO ROLATELA
 SETCOLOR(drvcortel+","+drvcorget+",,,"+corcampo)
 @ l_s+01 ,c_s+20 GET  rvalor;
                  PICT "@E 999,999.99";
                  VALI CRIT("rvalor>0~VALOR NORMAL n„o aceit vel")
                  AJUDA "Informe o valor da circular| ainda n„o vencida."

 @ l_s+02 ,c_s+20 GET  rvalor1;
                  PICT "@E 999,999.99";
                  VALI CRIT("rvalor1>0~VALOR 1§ RETORNO n„o aceit vel")
                  DEFAULT "M->valor1"
                  AJUDA "Informe o valor cobrado no primeiro retorno"

 @ l_s+03 ,c_s+20 GET  rvalor2;
                  PICT "@E 999,999.99";
                  VALI CRIT("rvalor2>0~VALOR 2§ RETORNO n„o aceit vel")
                  DEFAULT "M->valor2"
                  AJUDA "Informe o valor do segundo retorno"

 @ l_s+04 ,c_s+20 GET  rvalor3;
                  PICT "@E 999,999.99";
                  VALI CRIT("rvalor3>0~VALOR 3§ RETORNO n„o aceit vel")
                  DEFAULT "M->valor3"
                  AJUDA "Informe o valor do Terceiro retorno"

 @ l_s+05 ,c_s+34 GET  confirme;
                  PICT "!";
                  VALI CRIT("confirme=[S].and.V02401F9()~CONFIRME? n„o aceit vel|Tecle ESC para cancelar.")
                  AJUDA "Digite S para confirmar o tecle ESC"

 READ
 SET KEY K_ALT_F8 TO
 IF rola_t
  ROLATELA(.f.)
  LOOP
 ENDI
 IF LASTKEY()=K_ESC                                // se quer cancelar
  RETU                                             // retorna
 ENDI

 #ifdef COM_REDE
  IF !USEARQ("BXFCC",.t.,10,1)                     // se falhou a abertura do arq
   RETU                                            // volta ao menu anterior
  ENDI
 #else
  USEARQ("BXFCC")                                  // abre o dbf e seus indices
 #endi

 PTAB(cobrador,"COBRADOR",1,.t.)                   // abre arquivo p/ o relacionamento
 SET RELA TO cobrador INTO COBRADOR                // relacionamento dos arquivos
 titrel:=criterio:=cpord := ""                     // inicializa variaveis
 titrel:=chv_rela:=chv_1:=chv_2 := ""
 tps:=op_x:=ccop := 1
 arq_=drvporta                                     // porta de saida configurada
 IF !opcoes_rel(lin_menu,col_menu,1,11)            // nao quis configurar...
  CLOS ALL                                         // fecha arquivos e
  LOOP                                             // volta ao menu
 ENDI
 IF tps=2                                          // se vai para arquivo/video
  arq_=ARQGER()                                    // entao pega nome do arquivo
  IF EMPTY(arq_)                                   // se cancelou ou nao informou
   LOOP                                            // retorna
  ENDI
 ENDI
 SET PRINTER TO (arq_)                             // redireciona saida
 EXIT
ENDD
criterio_=criterio                                 // salva criterio e ordenacao
cpord_=cpord                                       // definidos se huver
criterio=""

#ifdef COM_REDE
 IF !USEARQ("BXTXAS",.t.,10,1)                     // se falhou a abertura do arq
  RETU                                             // volta ao menu anterior
 ENDI
#else
 USEARQ("BXTXAS")                                  // abre o dbf e seus indices
#endi

PTAB(codigo,"GRUPOS",3,.t.)                        // abre arquivo p/ o relacionamento
PTAB(codigo+circ,"TAXAS",1,.t.)
PTAB(GRUPOS->grupo+circ,"CIRCULAR",1,.t.)
PTAB(COBRADOR->cobrador+CIRCULAR->mesref+CIRCULAR->grupo+CIRCULAR->circ,"FCCOB",1,.t.)
SET RELA TO codigo INTO GRUPOS,;                   // relacionamento dos arquivos
         TO codigo+circ INTO TAXAS,;
         TO GRUPOS->grupo+circ INTO CIRCULAR,;
         TO COBRADOR->cobrador+CIRCULAR->mesref+CIRCULAR->grupo+CIRCULAR->circ INTO FCCOB
cpord="numero"
INDTMP()

#ifdef COM_REDE
 IF !USEARQ("RETTXAS",.t.,10,1)                    // se falhou a abertura do arq
  RETU                                             // volta ao menu anterior
 ENDI
#else
 USEARQ("RETTXAS")                                 // abre o dbf e seus indices
#endi

PTAB(codigo,"GRUPOS",3,.t.)                        // abre arquivo p/ o relacionamento
PTAB(codigo+circ,"TAXAS",1,.t.)
PTAB(GRUPOS->grupo+circ,"CIRCULAR",1,.t.)
PTAB(COBRADOR->cobrador+CIRCULAR->mesref+CIRCULAR->grupo+CIRCULAR->circ,"FCCOB",1,.t.)
SET RELA TO codigo INTO GRUPOS,;                   // relacionamento dos arquivos
         TO codigo+circ INTO TAXAS,;
         TO GRUPOS->grupo+circ INTO CIRCULAR,;
         TO COBRADOR->cobrador+CIRCULAR->mesref+CIRCULAR->grupo+CIRCULAR->circ INTO FCCOB
cpord="numero"
INDTMP()
criterio=criterio_                                 // restabelece criterio e
cpord=cpord_                                       // ordenacao definidos
SELE BXFCC
DBOX("[ESC] Interrompe",15,,,NAO_APAGA)
dele_atu:=SET(_SET_DELETED,.t.)                    // os excluidos nao servem...
SET DEVI TO PRIN                                   // inicia a impressao
maxli=62                                           // maximo de linhas no relatorio
BEGIN SEQUENCE
 DO WHIL ccop<=nucop                               // imprime qde copias pedida
  pg_=1; cl=999
  INI_ARQ()                                        // acha 1o. reg valido do arquivo
  ccop++                                           // incrementa contador de copias
  ult_imp=0                                        // ultimo reg impresso
  DO WHIL !EOF()
   IF INKEY()=K_ESC                                // se quer cancelar
    IF canc()                                      // pede confirmacao
     BREAK                                         // confirmou...
    ENDI
   ENDI
   IF PTAB(numero,'BXTXAS',1).OR.PTAB(numero,'RETTXAS',1)// se atender a condicao...
    REL_CAB(1,.t.)                                 // soma cl/imprime cabecalho
    @ cl,000 SAY TRAN(numero,"9999999")            // Numero
    @ cl,008 SAY cobrador+[-]+LEFT(COBRADOR->nome,20)// Cobrador
    @ cl,032 SAY TRAN(totalrec,"99999999.99")      // Total Receb.
    @ cl,044 SAY TRAN(despesas,"99999999.99")      // Despesas
    @ cl,056 SAY TRAN(comissao,"99999999.99")      // Comiss„o
    @ cl,068 SAY TRAN(parcpag,"999")               // Parc Pag
    @ cl,072 SAY TRAN(parcret,"999")               // Parc Ret
    ult_imp=RECNO()                                // ultimo reg impresso
    chv011=numero
    SELE BXTXAS
    SEEK chv011
    IF FOUND()
     IF cl+3>maxli                                 // se cabecalho do arq filho
      REL_CAB(0)                                   // nao cabe nesta pagina
     ENDI                                          // salta para a proxima pagina
     cl+=1                                         // soma contador de linha
     @ cl,001 SAY "Seq  Codigo Circular Valor pago MOTIVO"
     cl+=1                                         // soma contador de linha
     @ cl,000 SAY "===== ====== ======== ========== =============================="
     DO WHIL ! EOF() .AND. chv011=numero //LEFT(&(INDEXKEY(0)),LEN(chv011))
      IF INKEY()=K_ESC                             // se quer cancelar
       IF canc()                                   // pede confirmacao
	BREAK                                      // confirmou...
       ENDI
      ENDI
      IF !EMPT(R02501F9()) //Inverter filtro no processamento //// se atender a condicao...
       REL_CAB(1)                                  // soma cl/imprime cabecalho
       @ cl,000 SAY TRAN(seq,"99999")              // Seq
       @ cl,006 SAY TRAN(codigo,"99999")           // Codigo
       @ cl,013 SAY TRAN(circ,"999")               // Circular
       @ cl,022 SAY TRAN(IIF(TAXAS->(EOF()),0,TAXAS->valor),"@E 999,999.99")// Valor pago
       @ cl,033 SAY R02501F9()                     // MOTIVO
       SKIP                                        // pega proximo registro
      ELSE                                         // se nao atende condicao
       SKIP                                        // pega proximo registro
      ENDI
     ENDD
     cl+=3                                         // soma contador de linha
    ENDI
    SELE BXFCC                                     // volta ao arquivo pai
    chv011=numero
    SELE RETTXAS
    SEEK chv011
    IF FOUND()
     IF cl+3>maxli                                 // se cabecalho do arq filho
      REL_CAB(0)                                   // nao cabe nesta pagina
     ENDI                                          // salta para a proxima pagina
     cl+=1                                         // soma contador de linha
     @ cl,001 SAY "Seq  Codigo Circular Valor pago MOTIVO"
     cl+=1                                         // soma contador de linha
     @ cl,000 SAY "===== ====== ======== ========== =============================="
     DO WHIL ! EOF() .AND. chv011=numero //LEFT(&(INDEXKEY(0)),LEN(chv011))
      IF INKEY()=K_ESC                             // se quer cancelar
       IF canc()                                   // pede confirmacao
        BREAK                                      // confirmou...
       ENDI
      ENDI
      IF !EMPT(R02501F9()) //Inverter filtro no processamento //// se atender a condicao...
       REL_CAB(1)                                  // soma cl/imprime cabecalho
       @ cl,000 SAY TRAN(seq,"99999")              // Seq
       @ cl,006 SAY TRAN(codigo,"99999")           // Codigo
       @ cl,013 SAY TRAN(circ,"999")               // Circular
       @ cl,022 SAY TRAN(IIF(TAXAS->(EOF()),0,TAXAS->valor),"@E 999,999.99")// Valor pago
       @ cl,033 SAY R02501F9()                     // MOTIVO
       SKIP                                        // pega proximo registro
      ELSE                                         // se nao atende condicao
       SKIP                                        // pega proximo registro
      ENDI
     ENDD
     cl+=3                                         // soma contador de linha
    ENDI
    SELE BXFCC                                     // volta ao arquivo pai
    SKIP                                           // pega proximo registro
   ELSE                                            // se nao atende condicao
    SKIP                                           // pega proximo registro
   ENDI
  ENDD
 ENDD ccop
 REL_RDP(.t.)                                      // imprime rodape' do relatorio
 EJEC                                              // salta pagina
END SEQUENCE
SET PRINTER TO (drvporta)                          // fecha arquivo gerado (se houver)
SET DEVI TO SCRE                                   // direciona saida p/ video
SELE RETTXAS                                       // salta pagina
*SET RELA TO                                        // retira os relacionamentos
SELE BXTXAS                                        // salta pagina
*SET RELA TO                                        // retira os relacionamentos
SELE BXFCC                                         // salta pagina
*SET RELA TO                                        // retira os relacionamentos
IF tps=2                                           // se vai para arquivo/video
 BROWSE_REL(arq_,2,3,MAXROW()-2,78)                // mostra o arquivo gravado
ENDI
GRELA(1)                                           // grava variacao do relatorio

#ifdef COM_REDE
 IF !USEARQ("FCCOB",.t.,10,1)                      // se falhou a abertura do arq
  RETU                                             // volta ao menu anterior
 ENDI
#else
 USEARQ("FCCOB")                                   // abre o dbf e seus indices
#endi

msgt="PROCESSAMENTOS DO RELAT¢RIO|TRANSFERENCIA FCC"
ALERTA()
op_=DBOX("Prosseguir|Cancelar opera‡„o",,,E_MENU,,msgt)
IF op_=1
 DBOX("Processando registros",,,,NAO_APAGA,"AGUARDE!")
 dele_atu:=SET(_SET_DELETED,.t.)                   // os excluidos nao servem...
 SELE BXFCC                                        // processamentos apos emissao
 INI_ARQ()                                         // acha 1o. reg valido do arquivo
 DO WHIL !EOF()
  IF PTAB(numero,'BXTXAS',1)                       // se atender a condicao...
   chv011=numero
   SELE BXTXAS
   SEEK chv011
   IF FOUND()
    DO WHIL ! EOF() .AND. chv011=numero //LEFT(&(INDEXKEY(0)),LEN(chv011))
     IF EMPT(R02501F9()) //Inverter filtro no processamento //// se atender a condicao...
      IF (TAXAS->cobrador!=BXFCC->cobrador).AND.!PTAB(BXFCC->cobrador+CIRCULAR->mesref+GRUPOS->grupo+circ,'FCCOB',1)
       SELE FCCOB                                  // arquivo alvo do lancamento

       #ifdef COM_REDE
	DO WHIL .t.
	 APPE BLAN                                 // tenta abri-lo
	 IF NETERR()                               // nao conseguiu
	  DBOX(ms_uso,20)                          // avisa e
	  LOOP                                     // tenta novamente
	 ENDI
	 EXIT                                      // ok. registro criado
	ENDD
       #else
	APPE BLAN                                  // cria registro em branco
       #endi

       SELE BXTXAS                                 // inicializa registro em branco
       REPL FCCOB->cobrador WITH BXFCC->cobrador,;
	    FCCOB->mesref WITH CIRCULAR->mesref,;
	    FCCOB->grupo WITH GRUPOS->grupo,;
	    FCCOB->circ WITH circ,;
	    FCCOB->valorun WITH TAXAS->valor

       #ifdef COM_REDE
        FCCOB->(DBUNLOCK())                        // libera o registro
       #endi

      ENDI

      #ifdef COM_REDE
       IF (GRUPOS->cobrador!=BXFCC->cobrador).AND.PTAB(GRUPOS->cobrador+CIRCULAR->mesref+GRUPOS->grupo+circ,'FCCOB',1)
        REPBLO('FCCOB->qtdemit',FCCOB->qtdemit - 1)
       ENDI
       IF (GRUPOS->cobrador!=BXFCC->cobrador).AND.PTAB(BXFCC->cobrador+CIRCULAR->mesref+GRUPOS->grupo+CIRCULAR->circ,'FCCOB',1)
        REPBLO('FCCOB->qtdemit',FCCOB->qtdemit + 1)
       ENDI
       REPBLO('TAXAS->pgto_',BXFCC->lancto_)
       REPBLO('TAXAS->valorpg',TAXAS->valor)
       REPBLO('TAXAS->cobrador',BXFCC->cobrador)
       REPBLO('TAXAS->forma',[P])
       REPBLO('TAXAS->baixa_',DATE())
       REPBLO('TAXAS->por',M->usuario)
       REPBLO('BXFCC->vlrbaix',BXFCC->vlrbaix + TAXAS->valor)
       IF PTAB(BXFCC->cobrador+CIRCULAR->mesref+CIRCULAR->grupo+CIRCULAR->circ,'FCCOB',1)
        REPBLO('FCCOB->qtdpaga',FCCOB->qtdpaga + 1)
       ENDI
       REPBLO('CIRCULAR->pagos',CIRCULAR->pagos+1)
      #else
       IF (GRUPOS->cobrador!=BXFCC->cobrador).AND.PTAB(GRUPOS->cobrador+CIRCULAR->mesref+GRUPOS->grupo+circ,'FCCOB',1)
        REPL FCCOB->qtdemit WITH FCCOB->qtdemit - 1
       ENDI
       IF (GRUPOS->cobrador!=BXFCC->cobrador).AND.PTAB(BXFCC->cobrador+CIRCULAR->mesref+GRUPOS->grupo+CIRCULAR->circ,'FCCOB',1)
        REPL FCCOB->qtdemit WITH FCCOB->qtdemit + 1
       ENDI
       REPL TAXAS->pgto_ WITH BXFCC->lancto_
       REPL TAXAS->valorpg WITH TAXAS->valor
       REPL TAXAS->cobrador WITH BXFCC->cobrador
       REPL TAXAS->forma WITH [P]
       REPL TAXAS->baixa_ WITH DATE()
       REPL TAXAS->por WITH M->usuario
       REPL BXFCC->vlrbaix WITH BXFCC->vlrbaix + TAXAS->valor
       IF PTAB(BXFCC->cobrador+CIRCULAR->mesref+CIRCULAR->grupo+CIRCULAR->circ,'FCCOB',1)
        REPL FCCOB->qtdpaga WITH FCCOB->qtdpaga + 1
       ENDI
       REPL CIRCULAR->pagos WITH CIRCULAR->pagos+1
      #endi

      DELE                                         // exclui registro processado
      SKIP                                         // pega proximo registro
     ELSE                                          // se nao atende condicao
      SKIP                                         // pega proximo registro
     ENDI
    ENDD
   ENDI
   SELE BXFCC                                      // volta ao arquivo pai
   chv011=numero
   SELE RETTXAS
   SEEK chv011
   IF FOUND()
    DO WHIL ! EOF() .AND. chv011=numero //LEFT(&(INDEXKEY(0)),LEN(chv011))
     IF EMPT(R02501F9()) //Inverter filtro no processamento //// se atender a condicao...
      IF (TAXAS->cobrador!=BXFCC->cobrador).AND.!PTAB(BXFCC->cobrador+CIRCULAR->mesref+GRUPOS->grupo+circ,'FCCOB',1)
       SELE FCCOB                                  // arquivo alvo do lancamento

       #ifdef COM_REDE
        DO WHIL .t.
         APPE BLAN                                 // tenta abri-lo
         IF NETERR()                               // nao conseguiu
          DBOX(ms_uso,20)                          // avisa e
          LOOP                                     // tenta novamente
         ENDI
         EXIT                                      // ok. registro criado
        ENDD
       #else
        APPE BLAN                                  // cria registro em branco
       #endi

       SELE RETTXAS                                // inicializa registro em branco
       REPL FCCOB->cobrador WITH BXFCC->cobrador,;
            FCCOB->mesref WITH CIRCULAR->mesref,;
            FCCOB->grupo WITH GRUPOS->grupo,;
            FCCOB->circ WITH circ,;
            FCCOB->valorun WITH TAXAS->valor

       #ifdef COM_REDE
        FCCOB->(DBUNLOCK())                        // libera o registro
       #endi

      ENDI

      #ifdef COM_REDE
       IF (GRUPOS->cobrador!=BXFCC->cobrador).AND.PTAB(GRUPOS->cobrador+CIRCULAR->mesref+GRUPOS->grupo+circ,'FCCOB',1)
        REPBLO('FCCOB->qtdemit',FCCOB->qtdemit - 1)
       ENDI
       IF (GRUPOS->cobrador!=BXFCC->cobrador).AND.PTAB(BXFCC->cobrador+CIRCULAR->mesref+GRUPOS->grupo+CIRCULAR->circ,'FCCOB',1)
        REPBLO('FCCOB->qtdemit',FCCOB->qtdemit + 1)
       ENDI
       REPBLO('BXFCC->vlrretor',BXFCC->vlrretor + TAXAS->valor)
       REPBLO('TAXAS->pgto_',BXFCC->lancto_)
       REPBLO('TAXAS->valor',IIF(TAXAS->valor<M->rvalor1,M->rvalor1,IIF(TAXAS->valor<M->rvalor2,M->rvalor2,M->rvalor3)))
       REPBLO('TAXAS->cobrador',BXFCC->cobrador)
       REPBLO('TAXAS->forma',[R])
       IF PTAB(BXFCC->cobrador+CIRCULAR->mesref+CIRCULAR->grupo+CIRCULAR->circ,'FCCOB',1)
	REPBLO('FCCOB->qtdret',FCCOB->qtdret + 1)
       ENDI
      #else
       IF (GRUPOS->cobrador!=BXFCC->cobrador).AND.PTAB(GRUPOS->cobrador+CIRCULAR->mesref+GRUPOS->grupo+circ,'FCCOB',1)
        REPL FCCOB->qtdemit WITH FCCOB->qtdemit - 1
       ENDI
       IF (GRUPOS->cobrador!=BXFCC->cobrador).AND.PTAB(BXFCC->cobrador+CIRCULAR->mesref+GRUPOS->grupo+CIRCULAR->circ,'FCCOB',1)
        REPL FCCOB->qtdemit WITH FCCOB->qtdemit + 1
       ENDI
       REPL BXFCC->vlrretor WITH BXFCC->vlrretor + TAXAS->valor
       REPL TAXAS->pgto_ WITH BXFCC->lancto_
       REPL TAXAS->valor WITH IIF(TAXAS->valor<M->rvalor1,M->rvalor1,IIF(TAXAS->valor<M->rvalor2,M->rvalor2,M->rvalor3))
       REPL TAXAS->cobrador WITH BXFCC->cobrador
       REPL TAXAS->forma WITH [R]
       IF PTAB(BXFCC->cobrador+CIRCULAR->mesref+CIRCULAR->grupo+CIRCULAR->circ,'FCCOB',1)
        REPL FCCOB->qtdret WITH FCCOB->qtdret + 1
       ENDI
      #endi

      DELE                                         // exclui registro processado
      SKIP                                         // pega proximo registro
     ELSE                                          // se nao atende condicao
      SKIP                                         // pega proximo registro
     ENDI
    ENDD
   ENDI
   SELE BXFCC                                      // volta ao arquivo pai
   SKIP                                            // pega proximo registro
  ELSE                                             // se nao atende condicao
   SKIP                                            // pega proximo registro
  ENDI
 ENDD
 SET(_SET_DELETED,.f.)                             // os excluidos serao vistos
 SELE BXTXAS                                       // arquivo origem do processamento
 PACK                                              // elimina os registros excluidos
 SELE RETTXAS                                      // arquivo origem do processamento
 PACK                                              // elimina os registros excluidos
 CLOSE ALL                                         // fecha todos arquivos abertos
 ALERTA(2)
 DBOX("Processo terminado com sucesso!",,,,,msgt)
ENDI
SET(_SET_DELETED,dele_atu)                         // os excluidos serao vistos
RETU

STATIC PROC REL_RDP(volta_reg)                     // rodape'
LOCAL ar_:=ALIAS(), reg_atual
SELE BXFCC                                         // volta ao arquivo pai
reg_atual=RECNO()
IF volta_reg
 GO ult_imp                                        // ajusta reg p/ imp de campos no rodape'
ENDI
@ 63,012 SAY "Valor pago :"
@ 63,024 SAY TRAN(vlrbaix,"99999999.99")           // Vlr.Baixado
@ 63,039 SAY "Valor Retornado:"
@ 63,056 SAY TRAN(vlrretor,"99999999.99")          // Vlr.Retorno
IF volta_reg
 GO reg_atual                                      // retorna reg a posicao original
ENDI
SELE (ar_)
RETU

STATIC PROC REL_CAB(qt, volta_reg)                 // cabecalho do relatorio
volta_reg=IF(volta_reg=NIL,.f.,volta_reg)
IF qt>0                                            // se parametro maior que 0
 cl=cl+qt                                          // soma no contador de linhas
ENDI
IF cl>maxli .OR. qt=0                              // quebra de pagina
 IF pg_>1
  REL_RDP(volta_reg)                               // imprime rodape' do relatorio
 ENDI
 IMPAC(nemp,0,000)                                 // nome da empresa
 @ 0,067 SAY "PAG"
 @ 0,071 SAY TRAN(pg_,'9999')                      // n£mero da p gina
 IMPAC(nsis,1,000)                                 // t¡tulo aplica‡„o
 @ 1,067 SAY "ADM_R024"                            // c¢digo relat¢rio
 @ 2,000 SAY "CRITICA DE FCC"
 @ 2,059 SAY NSEM(DATE())                          // dia da semana
 @ 2,067 SAY DTOC(DATE())                          // data do sistema
 @ 3,000 SAY titrel                                // t¡tulo a definir
 IMPAC("Numero  Cob                     Totl Receb.    Despesas    Comiss„o Pag Ret",4,000)
 @ 5,000 SAY REPL("-",75)
 cl=qt+5 ; pg_++
ENDI
RETU

* \\ Final de ADM_R024.PRG
/*
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
 \ Empresa.: Ind£stria de Urnas Bignotto Ltda
 \ Programa: BXR_07F9.PRG
 \ Data....: 28-11-95
 \ Sistema.: Administradora de Funer rias
 \ Funcao..: Valor inicial do campo VALORPG, arquivo BXREC
 \ Analista: Ademilson Pedro Bom
 \ Criacao.: Programado manualmente pelo analista
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/

#include "adrbig.ch"    // inicializa constantes manifestas
LOCAL reg_dbf:=POINTER_DBF()
PRIVA respx,nomx:=space(35)
if op_menu#INCLUSAO
 retu PTAB(codigo,[GRUPOS],1)
endi
PTAB([],[GRUPOS],1,.t.)

nome:=space(35)
//DBOX([>]+CODIGO+[<])
IF EMPT(codigo)
 nomx=DBOX("Nome",,,,,"Informe o nome a procurar",nomx,"@!")

 IF PTAB(alltrim(nomx),[GRUPOS],2,.t.)
	codigo:=GRUPOS->codigo
	codigo:=VDBF(6,3,20,77,'GRUPOS',{'nome','codigo','endereco','tcarencia'},5,'codigo')
	nome:=GRUPOS->nome

 ELSE
  msgt="Nome n„o encontrado como titular|Procurar como inscrito?"
  ALERTA()
  op_=DBOX("Prosseguir|Cancelar opera‡„o",,,E_MENU,,msgt)
  IF op_ = 1
   IF !PTAB(alltrim(nomx),[INSCRITS],2,.t.)
    PTAB(ALLTRIM(LEFT(nomx,AT(' ',nomx))),[INSCRITS],2,.t.)
   ENDI
	 codigo:=INSCRITS->codigo+INSCRITS->grau+STR(INSCRITS->seq,2)
   nome:=alltrim(inscrits->nome)
	 codiGO:=VDBF(6,3,20,77,'INSCRITS',{'nome','codigo','grau','seq','tcarencia','vivofalec','tipo'},2,'codigo')
	 nome:=INSCRITS->nome
   codigo:=IIF(codigo=NIL,SPACE(9),left(codigo,9))
  ENDI

 ENDI

 IF LASTKEY()=K_ESC             // se teclou ESC
	codigo=SPACE(9)
	POINTER_DBF(reg_dbf)
	RETU .f.
 ENDI
ELSEIF LEN(ALLTRIM(codigo))<9.AND.!EMPT(CODIGO)
 msg_ins:=cod_msg:=[]
 nopc:=1
 tem10:=ptab('010'+strzero(VAL(codigo),6),[GRUPOS],1)
 IF tem10
  cod_msg+=GRUPOS->codigo
 	msg_ins+=GRUPOS->codigo+' '+GRUPOS->nome//+' '+GRUPOS->endereco+' '//+DTOC(GRUPOS->tcarencia)
 ENDI

 tem20:=ptab('020'+strzero(VAL(codigo),6),[GRUPOS],1)
 IF tem20
  IF tem10
   msg_ins+=[|]
  ENDI
  cod_msg+=GRUPOS->codigo
 	msg_ins+=GRUPOS->codigo+' '+GRUPOS->nome//+' '+GRUPOS->endereco//+' '+DTOC(GRUPOS->tcarencia)
 ENDI
 if len(cod_msg) > 9
  msg_:=[Escolha o contrato|Codigo Nome                           Endereco]
  nopc:=DBOX(msg_ins,,,E_MENU,,msg_,,,nopc)
 endi
 codigo:=SUBSTR(cod_msg,((nopc-1)*9)+1,9)

ENDI
respx:=LEFT(codigo,9)

IF PTAB(respx,[GRUPOS],1)
 titular:=GRUPOS->nome
// dbox(titular+respx)
ENDI

POINTER_DBF(reg_dbf)

retu PTAB(respx,[GRUPOS],1)	 // <- deve retornar um valor qualquer


/*
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
 \ Empresa.: PresServ Inform tica - Limeira (019)452.6623
 \ Programa: ADM_R021.PRG
 \ Data....: 04-11-03
 \ Sistema.: Administradora - RECEP€„O
 \ Funcao..: Processar Pgto em
 \ Analista: Ademilson Pedro Bom
 \ Criacao.: GAS-Pro v4.0n
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/

#include "adrbig.ch"    // inicializa constantes manifestas

PRIV dele_atu, cur_atual, getlist:={}
PARA lin_menu, col_menu
PRIV  tem_borda:=.t., op_menu:=VAR_COMPL, l_s:=10, c_s:=20, l_i:=13, c_i:=61, tela_fundo:=SAVESCREEN(0,0,MAXROW(),79)
nucop=1
SETCOLOR(drvtittel)
vr_memo=NOVAPOSI(@l_s,@c_s,@l_i,@c_i)     // pega posicao atual da tela
CAIXA(mold,l_s,c_s,l_i,c_i)               // monta caixa da tela
@ l_s,c_s+12 SAY " PROCESSAR PGTO EM "
SETCOLOR(drvcortel)
@ l_s+01,c_s+1 SAY " Data Inicial:"
@ l_s+02,c_s+1 SAY " Data Final..:"
PRIV data1_:=CTOD('')                              // Data Inicial
PRIV data2_:=CTOD('')                              // Data Final
DO WHILE .t.
 rola_t=.f.
 cod_sos=56
 SET KEY K_ALT_F8 TO ROLATELA
 SETCOLOR(drvcortel+","+drvcorget+",,,"+corcampo)
 @ l_s+01 ,c_s+16 GET  data1_;
                  PICT "@D";
                  VALI CRIT("!EMPT(data1_)~Necess rio informar DATA INICIAL")
                  AJUDA "Considerar a partir de..."

 @ l_s+02 ,c_s+16 GET  data2_;
                  PICT "@D";
                  VALI CRIT("!EMPT(data2_)~Necess rio informar DATA FINAL")
                  AJUDA "At‚ a data ..."

 READ
 SET KEY K_ALT_F8 TO
 IF rola_t
  ROLATELA(.f.)
  LOOP
 ENDI
 IF LASTKEY()=K_ESC                                // se quer cancelar
  RETU                                             // retorna
 ENDI

 #ifdef COM_REDE
  IF !USEARQ("AFUNER",.f.,10,1)                    // se falhou a abertura do arq
   RETU                                            // volta ao menu anterior
  ENDI
 #else
  USEARQ("AFUNER")                                 // abre o dbf e seus indices
 #endi

 titrel:=criterio := ""                            // inicializa variaveis
 cpord="DTOS(procpagto_)"
 chv_rela:=chv_1:=chv_2 := ""
 tps:=op_x:=ccop := 1
 fil_ini=""
 IF !opcoes_rel(lin_menu,col_menu,7,11,fil_ini)    // nao quis configurar...
  CLOS ALL                                         // fecha arquivos e
  LOOP                                             // volta ao menu
 ENDI
 IF tps=2                                          // se vai para arquivo/video
  arq_=ARQGER()                                    // entao pega nome do arquivo
  IF EMPTY(arq_)                                   // se cancelou ou nao informou
   LOOP                                            // retorna
  ENDI
 ELSE
  arq_=drvporta                                    // porta de saida configurada
 ENDI
 SET PRINTER TO (arq_)                             // redireciona saida
 EXIT
ENDD
cur_atual=SETCURSOR(0)
dele_atu:=SET(_SET_DELETED,.t.)                    // os excluidos nao servem...
POE_GAUGE("[ESC] Interrompe","AGUARDE...","Emitidos:")
SET DEVI TO PRIN                                   // inicia a impressao
maxli=62                                           // maximo de linhas no relatorio
hora_rel_=LEFT(TIME(),5)                           // hora de emissao do relatorio
BEGIN SEQUENCE
 DO WHIL ccop<=nucop                               // imprime qde copias pedida
  pg_=1; cl=50000
  INI_ARQ()                                        // acha 1o. reg valido do arquivo
  IF EOF()
   EXIT
  ENDI
  ccop++                                           // incrementa contador de copias
  qqu018=0                                         // contador de registros
  DO WHIL !EOF().AND.POE_GAUGE()
   IF IN_KEY()=K_ESC                               // se quer cancelar
    IF canc()                                      // pede confirmacao
     BREAK                                         // confirmou...
    ENDI
   ENDI
   IF procpagto_>=M->data1_.AND.procpagto_<=M->data2_// se atender a condicao...
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY TRAN(processo+proc2+filial,"@R 99999/99/!!")   // Processo
    @ cl,012 SAY TRAN(procpagto_,"@D")             // Proc.Pgto em
    @ cl,023 SAY TRAN(vlauxilio,"9999999.99")  // Valor Auxilio
    @ cl,038 SAY TRAN(falecido,"@!")               // Nome do falecido
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,011 SAY TRAN(nomedec,"@!")                // Nome
    @ cl,053 SAY TRAN(contrato,"@R 999.999999")           // Contrato
    @ cl,065 SAY TRAN(pagtoem_,"@D")               // Pago em
    qqu018++                                       // soma contadores de registros
    SKIP                                           // pega proximo registro
   ELSE                                            // se nao atende condicao
    SKIP                                           // pega proximo registro
   ENDI
  ENDD
  REL_CAB(2)                                       // soma cl/imprime cabecalho
  @ cl,000 SAY "*** Quantidade total "+TRAN(qqu018,"@E 999,999")
 ENDD ccop
 EJEC                                              // salta pagina
END SEQUENCE
SETCURSOR(cur_atual)
SET PRINTER TO (drvporta)                          // fecha arquivo gerado (se houver)
SET DEVI TO SCRE                                   // direciona saida p/ video
IF tps=2                                           // se vai para arquivo/video
 BROWSE_REL(arq_,2,3,MAXROW()-2,78)
ENDI          // mostra o arquivo gravado
GRELA(7)                                           // grava variacao do relatorio
SET(_SET_DELETED,dele_atu)                         // os excluidos serao vistos
RETU

STATIC PROC REL_CAB(qt)                            // cabecalho do relatorio
IF qt>0                                            // se parametro maior que 0
 cl=cl+qt                                          // soma no contador de linhas
ENDI
IF cl>maxli .OR. qt=0                              // quebra de pagina
 IMPAC(nemp,0,000)                                 // nome da empresa
 @ 0,065 SAY "PAG"
 @ 0,069 SAY TRAN(pg_,'9999')                      // n£mero da p gina
 IMPAC(nsis,1,000)                                 // t¡tulo aplica‡„o
 @ 1,065 SAY "ADM_R021"                            // c¢digo relat¢rio
 @ 2,000 SAY titrel                                // t¡tulo a definir
 @ 2,058 SAY DTOC(DATE())                          // data do sistema
 @ 2,068 SAY hora_rel_                             // hora da emiss„o
 @ 3,000 SAY "Processo Proc.Pgto em  Valor Auxilio  Nome do falecido"
 @ 4,011 SAY "Nome do Declarante                       Contrato   Pago em"
 @ 5,000 SAY REPL("-",73)
 cl=qt+5 ; pg_++
ENDI
RETU

* \\ Final de ADM_R021.PRG
procedure obx_01f9
/*
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
 \ Empresa.: Ind£stria de Urnas Bignotto Ltda
 \ Programa: BXR_01F9.PRG
 \ Data....: 20-11-95
 \ Sistema.: Administradora de Funer rias
 \ Funcao..: F¢rmula (Circ 1 - 4) a mostrar na tela de BXREC
 \ Analista: Ademilson Pedro Bom
 \ Criacao.: Programado manualmente pelo analista
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/

#include "adrbig.ch"    // inicializa constantes manifesta

 LOCAL reg_dbf:=POINTER_DBF()
 LOCAL circax1:=circax2:=circax3:=circax4:=circax5:=circax6:=SPACE(46)
 LOCAL cipend:=ciatrz:=nrd:=vladd:=0, jrok
 IF !op_menu = INCLUSAO
  codigo:=OBXEC->codigo
  RETU .T.
 ENDIF
 IF EMPT(codigo)
  RETU .T.
 ENDI

 dele_atu:=SET(_SET_DELETED,.t.)             // os excluidos nao servem...
 circax1:=circax2:=circax3:=circax4:=circax5:=circax6:=SPACE(46)

 PTAB(ALLTRIM(codigo),'GRUPOS',1)
 PTAB(ALLTRIM(codigo),'TAXAS',1)
 SELE TAXAS
// DBOX(CODIGO+[|TAXAS ]+TAXAS->codigo+[|Grupos ]+GRUPOS->codigo)
 DO WHILE !EOF().AND.TAXAS->codigo=GRUPOS->codigo
  IF DELE()
   SKIP
   LOOP
  ENDI
  vladd:=0
  IF EMPT(TAXAS->valorpg)
   cipend++
   IF TAXAS->emissao_< DATE()
    ciatrz++
    jrok:=PTAB(tipo,'JUROS',1)
    nrd:=(DATE() - TAXAS->emissao_)
    IF jrok .AND. (nrd > JUROS->mltcaren)
     vladd+=TAXAS->valor*JUROS->multa/100
    ENDI
    IF jrok .AND. (nrd > JUROS->jrscaren)
     vladd+=TAXAS->valor*JUROS->juros/100*nrd
    ENDI
   ENDI
  ENDI
  IF cipend < 5 .AND. TAXAS->emissao_ <= DATE()+60
   circax1:=circax2
   circax2:=circax3
   circax3:=circax4
   circax4:=[ ]+TAXAS->tipo+[ ]+TAXAS->circ+[ ]+DTOC(TAXAS->emissao_)+[ ]+;
      TRANSF(TAXAS->valor+M->vladd,"@E 99,999.99")+[ ]+DTOC(TAXAS->pgto_)+;
      TRANSF(TAXAS->valorpg,"@E 99,999.99") //+[ ]+TAXAS->cobrador
  ENDI
  SKIP
 ENDDO
 @ l_s+07, c_s+46 SAY [   ]
 @ l_s+07, c_s+46 SAY TRAN(GRUPOS->qtcircs,[999])
 IF !EMPT(GRUPOS->telefone)
  @ l_s+10, c_s+1 SAY [Tel.:]+xDECRIPT(GRUPOS->telefone)
 ENDI
 @ l_s+11, c_s+1 SAY SPACE(46)
 @ l_s+12, c_s+1 SAY SPACE(46)
 @ l_s+13, c_s+1 SAY SPACE(46)
 @ l_s+14, c_s+1 SAY SPACE(46)
 @ l_s+11, c_s+1 SAY circax1
 @ l_s+12, c_s+1 SAY circax2
 @ l_s+13, c_s+1 SAY circax3
 @ l_s+14, c_s+1 SAY circax4
 IF .t. //ciatrz > 4
  IF .t. // OBXEC->tipo=' '
   DBOX(STRZERO(ciatrz,2)+" Circulares Pendentes Vencidas!",,,,,"ATEN€ŽO, "+usuario)
  ENDI
 ENDI
 POINTER_DBF(reg_dbf)
SET(_SET_DELETED,dele_atu)                         // os excluidos serao vistos

RETU []         // <- deve retornar um valor qualquer

* \\ Final de BXR_01F9.PRG
/*
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
 \ Empresa.: PresServ Inform tica-Limeira (019)452.6623
 \ Programa: ADM_R026.PRG
 \ Data....: 30-06-97
 \ Sistema.: Administradora - RECEP€„O
 \ Funcao..: Capa de Processo
 \ Analista: Ademilson Pedro Bom
 \ Criacao.: GAS-Pro v3.0 
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/

#include "adrbig.ch"    // inicializa constantes manifestas

LOCAL dele_atu, getlist:={}
PARA  lin_menu, col_menu
PRIV  tem_borda:=.t., op_menu:=VAR_COMPL, l_s:=10, c_s:=20, l_i:=13, c_i:=61, tela_fundo:=SAVESCREEN(0,0,MAXROW(),79)
nucop=1
SETCOLOR(drvtittel)
vr_memo=NOVAPOSI(@l_s,@c_s,@l_i,@c_i)     // pega posicao atual da tela
CAIXA(mold,l_s,c_s,l_i,c_i)               // monta caixa da tela
@ l_s,c_s+10 SAY " IMPRESSŽO AUX.FUNERAL "
SETCOLOR(drvcortel)
@ l_s+01,c_s+1 SAY " Processo:"
@ l_s+02,c_s+1 SAY " Confirme:"
rproc=SPAC(11)                                     // Processo
confirme=SPAC(1)                                   // Confirme
DO WHILE .t.
 rola_t=.f.
 cod_sos=56
 SET KEY K_ALT_F8 TO ROLATELA
 SETCOLOR(drvcortel+","+drvcorget+",,,"+corcampo)
 @ l_s+01 ,c_s+12 GET  rproc;
                  PICT "@R 99999/9999-99";
		  VALI CRIT("!EMPT(RPROC).AND.PTAB(M->rproc,[AFUNER],1)~Campo utilizado para localiza‡„o dos documentos.|Tecle F8 para busca em tabela")
                  DEFAULT "IIF(PTAB(PADR(SUBSTR(M->ide_maq,2),4)+[AFU],[IMPPAR],1),ALLTRIM(IMPPAR->docto),[])"
                  AJUDA "Digite neste campo o n£mero de|identifica‡„o do processo"
                  CMDF8 "VDBF(6,12,20,77,'AFUNER',{'processo','proc2','categ','contrato','falecido'},1,'V02001F9()',[])"

 @ l_s+02 ,c_s+12 GET  confirme;
                  PICT "!";
                  VALI CRIT("confirme='S'.AND.V02002F9()~CONFIRME n„o aceit vel|Digite S para confirmar|ou|Tecle ESC para cancelar")
                  AJUDA "Digite S para confirmar|ou|tecle ESC para cancelar"

 READ
 SET KEY K_ALT_F8 TO
 IF rola_t
  ROLATELA(.f.)
  LOOP
 ENDI
 IF LASTKEY()=K_ESC                                // se quer cancelar
  RETU                                             // retorna
 ENDI

 #ifdef COM_REDE
  IF !USEARQ("AFUNER",.f.,10,1)                    // se falhou a abertura do arq
   RETU                                            // volta ao menu anterior
  ENDI
 #else
  USEARQ("AFUNER")                                 // abre o dbf e seus indices
 #endi

 PTAB(contrato,"GRUPOS",1,.t.)                     // abre arquivo p/ o relacionamento
 PTAB(funcresp,"FNCS",1,.t.)
 PTAB(GRUPOS->tipcont,"CLASSES",1,.t.)
 SET RELA TO contrato INTO GRUPOS,;                // relacionamento dos arquivos
          TO funcresp INTO FNCS,;
          TO GRUPOS->tipcont INTO CLASSES
 titrel:=criterio:=cpord := ""                     // inicializa variaveis
 titrel:=chv_rela:=chv_1:=chv_2 := ""
 tps:=op_x:=ccop := 1
 IF !opcoes_rel(lin_menu,col_menu,4,11)            // nao quis configurar...
  CLOS ALL                                         // fecha arquivos e
  LOOP                                             // volta ao menu
 ENDI
 IF tps=2                                          // se vai para arquivo/video
  arq_=ARQGER()                                    // entao pega nome do arquivo
  IF EMPTY(arq_)                                   // se cancelou ou nao informou
   LOOP                                            // retorna
  ENDI
 ELSE
  arq_=drvporta                                    // porta de saida configurada
 ENDI
 SET PRINTER TO (arq_)                             // redireciona saida
 EXIT
ENDD
IF !EMPTY(drvtapg)                                 // existe configuracao de tam pag?
 op_=AT("NNN",drvtapg)                             // se o codigo que altera
 IF op_=0                                          // o tamanho da pagina
  msg="Configura‡„o do tamanho da p gina!"         // foi informado errado
  DBOX(msg,,,,,"ERRO!")                            // avisa
  CLOSE ALL                                        // fecha todos arquivos abertos
  RETU                                             // e cai fora...
 ENDI                                              // codigo para setar/resetar tam pag
 lpp_050=LEFT(drvtapg,op_-1)+"050"+SUBS(drvtapg,op_+3)
 lpp_066=LEFT(drvtapg,op_-1)+"066"+SUBS(drvtapg,op_+3)
ELSE
 lpp_050:=lpp_066 :=""                             // nao ira mudara o tamanho da pag
ENDI
DBOX("[ESC] Interrompe",15,,,NAO_APAGA)
dele_atu:=SET(_SET_DELETED,.t.)                    // os excluidos nao servem...
SET DEVI TO PRIN                                   // inicia a impressao
maxli=65                                           // maximo de linhas no relatorio
IMPCTL(lpp_050)                                    // seta pagina com 50 linhas
IMPCTL(drvpde8)                                    // ativa 8 lpp
IF tps=2
 IMPCTL("' '+CHR(8)")
ENDI
BEGIN SEQUENCE
 DO WHIL ccop<=nucop                               // imprime qde copias pedida
  pg_=1; cl=999
  INI_ARQ()                                        // acha 1o. reg valido do arquivo
  ccop++                                           // incrementa contador de copias
  IF PTAB(PADR(SUBSTR(M->ide_maq,2),4)+[AFU],[IMPPAR],1)
   PTAB(ALLTRIM(IMPPAR->docto),[AFUNER],1)
  ENDI// se atender a condicao...
  DO WHIL !EOF()
   #ifdef COM_TUTOR
    IF IN_KEY()=K_ESC                              // se quer cancelar
   #else
    IF INKEY()=K_ESC                               // se quer cancelar
   #endi
    IF canc()                                      // pede confirmacao
     BREAK                                         // confirmou...
    ENDI
   ENDI
   IF PTAB(PADR(SUBSTR(M->ide_maq,2),4)+[AFU],[IMPPAR],1).and.processo+proc2+filial+categ=ALLTRIM(IMPPAR->docto)// se atender a condicao...
    REL_CAB(3)                                     // soma cl/imprime cabecalho
    @ cl,060 SAY TRAN(processo+proc2,"@R 99999/99")// N£mero Processo
    REL_CAB(12)                                    // soma cl/imprime cabecalho
    @ cl,011 SAY TRAN(falecido,"@!")               // Nome do falecido
    REL_CAB(2)                                     // soma cl/imprime cabecalho
    @ cl,011 SAY ALLTRIM(ruares)+[ ]+ALLTRIM(baires)+'-'+ALLTRIM(munres)// endereco (falecido)
    REL_CAB(2)                                     // soma cl/imprime cabecalho
    @ cl,019 SAY TRAN(falecto_,"@D")               // Data falcto.
    @ cl,056 SAY TRAN(horafal,"99:99")             // Hora Falcto.
    REL_CAB(2)                                     // soma cl/imprime cabecalho
    @ cl,019 SAY TRAN(ALLTRIM(ruafal),"@!")        // Rua Falecimento
    REL_CAB(4)                                     // soma cl/imprime cabecalho
    @ cl,012 SAY TRAN(nomedec,"@!")                // Declarante
    REL_CAB(2)                                     // soma cl/imprime cabecalho
    @ cl,012 SAY ALLTRIM(ruadec)                   // endereco (declarante)
    @ cl,056 SAY fonedec                           // fone declarante
    REL_CAB(11)                                    // soma cl/imprime cabecalho
    @ cl,012 SAY CLASSES->descricao                // tipo de plano
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,025 SAY IIF(categ=[PD],[Plano c/Difer. ],IIF(categ=[PL],[Atend.Plano],[Auxilio Funeral  ]))// Categoria
    REL_CAB(3)                                     // soma cl/imprime cabecalho
    @ cl,016 SAY FNCS->nome                        // Motorista respons vel
    @ cl,054 SAY TRAN(contrato,"999999")           // CONTRATO
    @ cl,066 SAY GRUPOS->grupo                     // GRUPO
    REL_CAB(13)                                    // soma cl/imprime cabecalho
    @ cl,015 SAY TRAN(cemitsep,"@!")               // Cemit‚rio Sepultamento
    REL_CAB(2)                                     // soma cl/imprime cabecalho
    @ cl,021 SAY horasepult                        // hora sepultamento
    IF !EMPT(sepult_)                              // pode imprimir?
     @ cl,058 SAY DTOC(sepult_)                    // data sepultamento
    ENDI
    SKIP                                           // pega proximo registro
    cl=999                                         // forca salto de pagina
   ELSE                                            // se nao atende condicao
    SKIP                                           // pega proximo registro
   ENDI
   EXIT
  ENDD
 ENDD ccop
 EJEC                                              // salta pagina
END SEQUENCE
IMPCTL(drvtde8)                                    // ativa 6 lpp
IMPCTL(lpp_066)                                    // seta pagina com 66 linhas
SET PRINTER TO (drvporta)                          // fecha arquivo gerado (se houver)
SET DEVI TO SCRE                                   // direciona saida p/ video
IF tps=2                                           // se vai para arquivo/video
 BROWSE_REL(arq_,2,3,MAXROW()-2,78)
ENDI                                               // mostra o arquivo gravado
GRELA(4)                                           // grava variacao do relatorio
SELE AFUNER                                        // salta pagina
SET RELA TO                                        // retira os relacionamentos
SET(_SET_DELETED,dele_atu)                         // os excluidos serao vistos
RETU

STATIC PROC REL_CAB(qt)                            // cabecalho do relatorio
IF qt>0                                            // se parametro maior que 0
 cl=cl+qt                                          // soma no contador de linhas
ENDI
IF cl>maxli .OR. qt=0                              // quebra de pagina
 cl=qt+5 ; pg_++
ENDI
RETU

* \\ Final de ADM_R026.PRG
BIF3°  •  B órì  `ç   ˆ½ B£&Os ÿÿ  th BY!€*  ÿÿ  \@ ¿o€*@ ÿÿ  Ø• Br%´@ ÿÿ9 ä€¿Y!€*h    ¬F¿dGAS-Pro v3.0
011021014062001001001001012000176001
 Processo:
 Confirme:
[Ÿ]
[Ÿ]
 2 
 0 
Impress„o Aux.Funeral
Impress„o Aux.Funeral







056







 0 
 0 
-1 
-1 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
rproc
C
E
@R 99999/9999-99
 11 
 13 
 1 
 12 
 0 
Processo

!EMPT(RPROC).AND.PTAB(M->rproc,[AFUNER],1)
Campo utilizado para localiza‡„o dos documentos.|Tecle F8 para busca em tabela
IIF(PTAB(PADR(SUBSTR(M->ide_maq,2),4)+[AFU],[IMPPAR],1),ALLTRIM(IMPPAR->docto),[])
Digite neste campo o n£mero de|identifica‡„o do processo
VDBF(6,12,20,77,'AFUNER',{'processo','proc2','categ','contrato','falecido'},1,'V02001F9()',[])
 0 
 0 


confirme
C
E
!
 1 
 1 
 2 
 12 
 0 
Confirme

confirme='S'.AND.V02002F9()
CONFIRME n„o aceit vel|Digite S para confirmar|ou|Tecle ESC para cancelar

Digite S para confirmar|ou|tecle ESC para cancelar

 0 
 0 


 0 
 0 
 0 
 0 
 0 
procedure grupos
/*
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
 \ Empresa.: PresServ Inform tica - Limeira (019)452.6623
 \ Programa: GRUPOS.PRG
 \ Data....: 12-11-03
 \ Sistema.: Administradora - RECEP€„O
 \ Funcao..: Gerenciador do subsistema de consulta contratos
 \ Analista: Ademilson Pedro Bom
 \ Criacao.: GAS-Pro v4.0n
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/

#include "adrbig.ch"    // inicializa constantes manifestas

PARA lin_menu,col_menu
PRIV op_sis, tela_fundo:=SAVESCREEN(0,0,MAXROW(),79), l_s, c_s, l_i, c_i, l_a

op_sis=EVAL(qualsis,"GRUPOS")
IF nivelop<sistema[op_sis,O_OUTROS,O_NIVEL]        // se usuario nao tem permissao,
 ALERTA()                                          // entao, beep, beep, beep
 DBOX(msg_auto,,,3)                                // lamentamos e
 RETU                                              // retornamos ao menu
ENDI
cn:=fgrep :=.f.

#ifdef COM_LOCK
 IF LEN(pr_ok)>0                                   // se a protecao acusou
  ? pr_ok                                          // erro, avisa e
  QUIT                                             // encerra a aplicacao
 ENDI
#endi

t_fundo=SAVESCREEN(0,0,MAXROW(),79)                // salva tela do fundo
op_cad=1
DO WHIL op_cad!=0
 criterio=""
 RESTSCREEN(0,0,MAXROW(),79,t_fundo)               // restaura tela do fundo
 cod_sos=5 ; cn=.f.
 CLEA TYPEAHEAD                                    // limpa o buffer do teclado
 fgrep=.f.
 SET KEY K_F3 TO                                   // retira das teclas F3 e F4 as
 SET KEY K_F4 TO                                   // funcoes de repeticao e confirmacao
 msg="Inclus„o~1|"+;
     "Manuten‡„o~2|"+;
     "Consulta~3|"+;
     "Consulta Inscritos~4|"+;
     "Consulta Taxas~5"
 op_cad=DBOX(msg,lin_menu,col_menu,E_MENU,NAO_APAGA,MAIUSC(sistema[op_sis,O_MENU]),,,op_cad)
 IF op_cad!=0                                      // se escolheu uma opcao
  Tela_fundo=SAVESCREEN(0,0,MAXROW(),79)           // salva a tela para ROLATELA()
  PARAMETROS(dbfparam)
  SELE A                                           // e abre o arquivo e seus indices

  #ifdef COM_REDE
   IF !USEARQ(sistema[op_sis,O_ARQUI,O_NOME],.f.,20,1)
                                                   // se falhou a abertura do
    RETU                                           // arquivo volta ao menu anterior
   ENDI
  #else
   USEARQ(sistema[op_sis,O_ARQUI,O_NOME])
  #endi

  SET KEY K_F9 TO veoutros                         // habilita consulta em outros arquivos
 ENDI
 DO CASE
  CASE op_cad=01                                   // inclus„o
   op_menu=INCLUSAO
   IF AT("D",exrot[op_sis])=0                      // se usuario pode fazer inclusao
    GRU_INCL()                                     // neste arquivo chama prg de inclusao
   ELSE                                            // caso contrario vamos avisar que
    ALERTA()                                       // ele nao tem permissao para isto
    DBOX(msg_auto,,,3)
   ENDI

  CASE op_cad=02                                   // manuten‡„o
   op_menu=ALTERACAO
   cod_sos=7
   EDIT()

  CASE op_cad=03                                   // consulta
   op_menu=PROJECOES
   cod_sos=8
   EDITA(03,03,MAXROW()-2,77)

  CASE op_cad=04                                   // consulta inscritos
   cod_sos=8
   CTAINSC()

  CASE op_cad=05                                   // consulta taxas
   cod_sos=8
   CTXAS()

 ENDC
 SET KEY K_F9 TO                                   // F9 nao mais consultara outros arquivos
 CLOS ALL                                          // fecha todos arquivos abertos
ENDD
RETU

PROC GRU_incl(reg_cop)  // inclusao no arquivo GRUPOS
LOCAL getlist:={}, cabem:=1, rep:=ARRAY(FCOU()), ult_reg:=RECN(), cond_incl_,;
      ctl_r, ctl_c, ctl_w, t_f3_, t_f4_, dele_atu:=SET(_SET_DELETED,.f.)
PRIV op_menu:=INCLUSAO, tem_borda, criterio:="", cpord:=""
cond_incl_={||1=3}                                 // condicao de inclusao de registros
IF !EVAL(cond_incl_)                               // se nao pode incluir
 ALERTA(2)                                         // avisa o motivo
 DBOX("Mantido pelo sistema de Plano",,,4,,"ATEN€ŽO, "+usuario)
 RETU                                              // e retorna
ENDI
atend1:=atend2:=space(15)
FOR i=1 TO FCOU()                                  // cria/declara privadas as
 msg=FIEL(i)                                       // variaveis de memoria com
 PRIV &msg.                                        // o mesmo nome dos campos
NEXT                                               // do arquivo
IF reg_cop!=NIL                                    // quer repetir todo o reg atual
 FOR i=1 TO FCOU()                                 // para cada campo,
  msg=FIEL(i)                                      // salva o conteudo
  rep[i]=&msg.                                     // para repetir
 NEXT
ELSE
 AFILL(rep,"")                                     // eche com valor vazio
ENDI
t_f3_=SETKEY(K_F3,{||rep()})                       // repeticao reg anterior
t_f4_=SETKEY(K_F4,{||conf()})                      // confirma campos com ENTER
ctl_w=SETKEY(K_CTRL_W,{||nadafaz()})               // enganando o CA-Clipper...
ctl_c=SETKEY(K_CTRL_C,{||nadafaz()})
ctl_r=SETKEY(K_CTRL_R,{||nadafaz()})
DO WHIL cabem>0
 cod_sos=6
 rola_t=.f.                                        // flag se quer rolar a tela
 SELE GRUPOS
 GO BOTT                                           // forca o
 SKIP                                              // final do arquivo
 
 /*
    cria variaveis de memoria identicas as de arquivo, para inclusao
    de registros
 */
 atend1:=atend2:=space(15)
 FOR i=1 TO FCOU()
  msg=FIEL(i)
  M->&msg.=IF((fgrep .OR. reg_cop!=NIL).AND.!EMPT(rep[1]),rep[i],&msg.)
 NEXT
 DISPBEGIN()                                       // apresenta a tela de uma vez so
 GRU_GETS()
 IMPRELA()
 GRU_TELA()
 INFOSIS(.t.)                                      // exibe informacao no rodape' da tela
 DISPEND()
 IF !EVAL(cond_incl_)
  EXIT
 ENDI
 cabem=DISKSPACE(;
          IF(;
             LEN(sistema[op_sis,O_ARQUI,O_DIR_DBF])<2.OR.sistema[op_sis,O_ARQUI,O_DIR_DBF]="\",;
             0,;
             ASC(sistema[op_sis,O_ARQUI,O_DIR_DBF])-64;
          );
       )
 cabem=INT((cabem-2048)/GRUPOS->(RECSIZE()))
 IF cabem<1                                        // mais nenhum!!!
  ALERTA()
  msg="Verifique ESPA€O EM DISCO, "+usuario
  DBOX(msg,,,,,"INCLUSŽO INTERROMPIDA!")           // vamos parar por aqui!
  EXIT
 ENDI
 SELE 0                                            // torna visiveis variaveis de memoria
 SETCOLOR(drvcortel+","+drvcorget+",,,"+corcampo)
 SET KEY K_ALT_F8 TO ROLATELA
 
 /*
    recebe chaves do arquivo de indice basico
 */
 @ l_s+01 ,c_s+10 GET  codigo;
                  PICT sistema[op_sis,O_CAMPO,01,O_MASC]
                  DEFINICAO 1

 READ
 SET KEY K_ALT_F8 TO
 IF rola_t
  ROLATELA()
  LOOP
 ENDI
 SELE GRUPOS
 IF LASTKEY()=K_ESC                                // cancelou ou chave em branco
  cabem=0                                          // prepara saida da inclusao
  LOOP                                             // volta p/ menu de cadastramento
 ENDI
 SEEK M->codigo
 aprov_reg_=(FOUND().AND.DELE().AND.!drvvisivel)   // vai aproveitar o registro?
 IF FOUND() .AND. !aprov_reg_                      // pesquisou e achou!
  op_menu=ALTERACAO                                // seta flag de ateracao
  DISPBEGIN()
  GRU_GETS()
  IMPRELA()
  GRU_GETS()                                       // mostra conteudo do registro
  INFOSIS(.f.)                                     // exibe informacao no rodape' da tela
  DISPEND()
  ALERTA()
  msg="Consultar/alterar|Retornar … inclus„o"      // pergunta se deseja
  op_=DBOX(msg,,,E_MENU,,"REGISTRO J EXISTE")     // alterar o registro
  IF op_ =1                                        // caso afirmativo
   EDIT()                                          // deixa alterar
  ENDI
  op_menu=INCLUSAO
  LOOP                                             // volta para inclusao
 ENDI
 SELE 0
 GRU_GET1(INCLUI)                                  // recebe campos
 SELE GRUPOS
 IF LASTKEY()=K_ESC                                // se cancelou
  ALERTA()                                         // avisa que o registro
  DBOX("Registro n„o inclu¡do!",18,,1)             // nao foi incluido, e volta
  LOOP
 ENDI

 #ifdef COM_REDE
  GO BOTT                                          // vamos bloquear o final do
  SKIP                                             // arq para que nehum outro
  BLOREG(0,.5)                                     // usuario possa incluir
  SEEK M->codigo                                   // se registro foi incluido
  aprov_reg_=(FOUND().AND.DELE().AND.!drvvisivel)  // vai aproveitar o registro?
  IF FOUND() .AND. !aprov_reg_                     // por outro usuario, entao
   BLOREG(0,.5)
   FOR i=1 TO FCOU()
    msg=FIEL(i)
    rep[i]=&msg.
    REPL &msg. WITH M->&msg.
   NEXT
   GRU_GET1(FORM_INVERSA)                          // executa formula inversa
   RECA
   FOR i=1 TO FCOU()
    msg=FIEL(i)
    REPL &msg. WITH rep[i]
   NEXT
   ALERTA(4)                                       // beep 4 vezes
   msg="Registro acabou de ser|inclu¡do por outro usu rio!"
   DBOX(msg,,,,,"ATEN€ŽO!")                        // avisa
   SELE GRUPOS
   UNLOCK                                          // libera o registro
   LOOP                                            // e recebe chave novamente
  ENDI
 #endi

 IF aprov_reg_                                     // se vai aproveitar reg excluido

  #ifdef COM_REDE
   BLOREG(0,.5)
  #endi

  RECA                                             // excluido, vamos recupera-lo
 ELSE                                              // caso contrario
  APPEND BLANK                                     // inclui reg em branco no dbf
 ENDI
 FOR i=1 TO FCOU()                                 // para cada campo,
  msg=FIEL(i)                                      // salva o conteudo
  rep[i]=M->&msg.                                  // para repetir
  REPL &msg. WITH rep[i]                           // enche o campo do arquivo
 NEXT

 #ifdef COM_REDE
  UNLOCK                                           // libera o registro e
  COMMIT                                           // forca gravacao
 #else
  IF RECC()-INT(RECC()/20)*20=0                    // a cada 20 registros
   COMMIT                                          // digitados forca gravacao
  ENDI
 #endi

 ult_reg=RECN()                                    // ultimo registro digitado
 IF sistema[EVAL(qualsis,"TAXAS"),O_OUTROS,O_NIVEL]<5
  SUBNIVEL("TAXAS")
 ENDI
 IF sistema[EVAL(qualsis,"ECOB"),O_OUTROS,O_NIVEL]<5
  SUBNIVEL("ECOB")
 ENDI
 IF sistema[EVAL(qualsis,"INSCRITS"),O_OUTROS,O_NIVEL]<5
  SUBNIVEL("INSCRITS")
 ENDI
 IF reg_cop!=NIL                                   // estava na consulta e quis rep o campo
  EXIT                                             // cai fora...
 ENDI
ENDD
GO ult_reg                                         // para o ultimo reg digitado
SETKEY(K_F3,t_f3_)                                 // restaura teclas de funcoes
SETKEY(K_F4,t_f4_)
SET(_SET_DELETED,dele_atu)                            // ecluidos visiveis/invisiveis
SETKEY(K_CTRL_W,ctl_w)
SETKEY(K_CTRL_C,ctl_c)
SETKEY(K_CTRL_R,ctl_r)
RETU


PROC GRU_tela     // tela do arquivo GRUPOS
tem_borda=.t.
l_s=Sistema[op_sis,O_TELA,O_LS]           // coordenadas da tela
c_s=Sistema[op_sis,O_TELA,O_CS]
l_i=Sistema[op_sis,O_TELA,O_LI]
c_i=Sistema[op_sis,O_TELA,O_CI]
SETCOLOR(drvtittel)
vr_memo=NOVAPOSI(@l_s,@c_s,@l_i,@c_i)     // pega posicao atual da tela
CAIXA(mold,l_s,c_s,l_i,c_i)               // monta caixa da tela
i=LEN(sistema[op_sis,O_MENS])/2
@ l_s,c_s-1+(c_i-c_s+1)/2-i SAY " "+MAIUSC(sistema[op_sis,O_MENS])+" "
SETCOLOR(drvcortel)
@ l_s+01,c_s+1 SAY " Codigo:                                         Situa‡„o:"
@ l_s+02,c_s+1 SAY "  ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ Dados Pessoais ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ"
@ l_s+03,c_s+1 SAY " Nome..:                                     Nasc.:"
@ l_s+04,c_s+1 SAY " ECivil:                  CIC:               RG...:"
@ l_s+05,c_s+1 SAY " Ender.:                                     Bairr:"
@ l_s+06,c_s+1 SAY " Cidade:                           UF.:      CEP..:"
@ l_s+07,c_s+1 SAY " Natur.:                           Relig:"
@ l_s+08,c_s+1 SAY " Contato                           Tel:"
@ l_s+09,c_s+1 SAY " Categor.:     Carnˆ:      F.Pgto:"
@ l_s+10,c_s+1 SAY " Admiss„o:             T.Carˆncia:              Sai Taxas.:"
@ l_s+11,c_s+1 SAY " Vendedor:                                      Dia Pgto..:"
@ l_s+12,c_s+1 SAY " Regi„o..:                                      Observa‡„o:"
@ l_s+13,c_s+1 SAY " Cobrador:                                      Renova‡„o.:"
@ l_s+14,c_s+1 SAY " Funerais:       Circ.Inic:       Ult.:        Emit:      Baix:"
@ l_s+15,c_s+1 SAY " Atendimento.1:                      2:"
@ l_s+16,c_s+1 SAY " Participantes: Vivos:    Falecidos:    Dependentes:"
@ l_s+17,c_s+1 SAY " email:                                             "
@ l_s+18,c_s+1 SAY " Ult.Altera‡„o:                       Ult.Impress„o:"
RETU

PROC GRU_gets     // mostra variaveis do arquivo GRUPOS
LOCAL getlist := {}, t_f7_
GRU_TELA()
SETCOLOR(drvcortel+","+drvcorget+",,,"+corcampo)
PTAB('',[ARQGRUP],1)
PTAB(TIPCONT,'CLASSES',1)
PTAB(VENDEDOR,'COBRADOR',1)
PTAB(REGIAO,'REGIAO',1)
PTAB(COBRADOR,'COBRADOR',1)
PTAB(IIF(CLASSES->PRIOR=[S],M->MGRUPVIP,GRUPO)+ULTCIRC,'CIRCULAR',1)
CRIT("",,"2|3|6|9|10|11|12|13")
@ l_s+01 ,c_s+10 GET  codigo;
                 PICT sistema[op_sis,O_CAMPO,01,O_MASC]

@ l_s+01 ,c_s+60 GET  situacao;
                 PICT sistema[op_sis,O_CAMPO,03,O_MASC]
                 CRIT(sistema[op_sis,O_CAMPO,03,O_CRIT],,"1")

@ l_s+03 ,c_s+10 GET  nome;
                 PICT sistema[op_sis,O_CAMPO,04,O_MASC]

@ l_s+03 ,c_s+53 GET  nascto_;
                 PICT sistema[op_sis,O_CAMPO,05,O_MASC]
                 CRIT(sistema[op_sis,O_CAMPO,05,O_CRIT],,"16")

@ l_s+04 ,c_s+10 GET  estcivil;
                 PICT sistema[op_sis,O_CAMPO,06,O_MASC]
                 CRIT(sistema[op_sis,O_CAMPO,06,O_CRIT],,"8")

@ l_s+04 ,c_s+31 GET  cpf;
                 PICT sistema[op_sis,O_CAMPO,07,O_MASC]

@ l_s+04 ,c_s+53 GET  rg;
                 PICT sistema[op_sis,O_CAMPO,08,O_MASC]

@ l_s+05 ,c_s+10 GET  endereco;
                 PICT sistema[op_sis,O_CAMPO,09,O_MASC]

@ l_s+05 ,c_s+53 GET  bairro;
                 PICT sistema[op_sis,O_CAMPO,10,O_MASC]

@ l_s+06 ,c_s+10 GET  cidade;
                 PICT sistema[op_sis,O_CAMPO,11,O_MASC]

@ l_s+06 ,c_s+41 GET  uf;
                 PICT sistema[op_sis,O_CAMPO,12,O_MASC]

@ l_s+06 ,c_s+53 GET  cep;
                 PICT sistema[op_sis,O_CAMPO,13,O_MASC]

@ l_s+07 ,c_s+10 GET  natural;
                 PICT sistema[op_sis,O_CAMPO,14,O_MASC]

@ l_s+07 ,c_s+43 GET  relig;
                 PICT sistema[op_sis,O_CAMPO,15,O_MASC]

@ l_s+08 ,c_s+10 GET  contato;
                 PICT sistema[op_sis,O_CAMPO,16,O_MASC]

@ l_s+08 ,c_s+41 GET  telefone;
                 PICT sistema[op_sis,O_CAMPO,17,O_MASC]

@ l_s+09 ,c_s+12 GET  tipcont;
                 PICT sistema[op_sis,O_CAMPO,18,O_MASC]

@ l_s+09 ,c_s+23 GET  vlcarne

@ l_s+09 ,c_s+36 GET  formapgto;
                 PICT sistema[op_sis,O_CAMPO,20,O_MASC]
                 CRIT(sistema[op_sis,O_CAMPO,20,O_CRIT],,"15")

@ l_s+10 ,c_s+12 GET  admissao;
                 PICT sistema[op_sis,O_CAMPO,22,O_MASC]

@ l_s+10 ,c_s+36 GET  tcarencia;
                 PICT sistema[op_sis,O_CAMPO,23,O_MASC]

@ l_s+10 ,c_s+61 GET  saitxa;
                 PICT sistema[op_sis,O_CAMPO,24,O_MASC]

@ l_s+11 ,c_s+61 GET  diapgto;
                 PICT sistema[op_sis,O_CAMPO,25,O_MASC]

@ l_s+11 ,c_s+12 GET  vendedor;
                 PICT sistema[op_sis,O_CAMPO,26,O_MASC]

@ l_s+12 ,c_s+12 GET  regiao;
                 PICT sistema[op_sis,O_CAMPO,27,O_MASC]
                 CRIT(sistema[op_sis,O_CAMPO,27,O_CRIT],,"7")

@ l_s+13 ,c_s+12 GET  cobrador;
                 PICT sistema[op_sis,O_CAMPO,28,O_MASC]
                 CRIT(sistema[op_sis,O_CAMPO,28,O_CRIT],,"4|5")

@ l_s+12 ,c_s+61 SAY "{M} "

@ l_s+13 ,c_s+61 GET  renovar;
                 PICT sistema[op_sis,O_CAMPO,30,O_MASC]

@ l_s+14 ,c_s+12 GET  funerais;
                 PICT sistema[op_sis,O_CAMPO,31,O_MASC]

@ l_s+14 ,c_s+29 GET  circinic;
                 PICT sistema[op_sis,O_CAMPO,32,O_MASC]

@ l_s+14 ,c_s+41 GET  ultcirc;
                 PICT sistema[op_sis,O_CAMPO,33,O_MASC]

@ l_s+14 ,c_s+54 GET  qtcircs;
                 PICT sistema[op_sis,O_CAMPO,34,O_MASC]

@ l_s+14 ,c_s+65 GET  qtcircpg;
                 PICT sistema[op_sis,O_CAMPO,35,O_MASC]

@ l_s+15 ,c_s+16 GET  atend1;
                 PICT sistema[op_sis,O_CAMPO,45,O_MASC]

@ l_s+17 ,c_s+16 GET  email;
                 PICT sistema[op_sis,O_CAMPO,50,O_MASC]

CLEAR GETS
RETU

PROC GRU_get1(tp_mov)     // capta variaveis do arquivo GRUPOS
LOCAL getlist := {}, t_f7_
PRIV  blk_grupos:=.t.

IF tp_mov=INCLUI
 DO WHILE .t.
  rola_t=.f.
  memo29:="{F7}"
  t_f7_=SETKEY(K_F7,{||GRU_memo()})
  SET KEY K_ALT_F8 TO ROLATELA
  SETCOLOR(drvcortel+","+drvcorget+",,,"+corcampo)
  CRIT("",,"2|3|6|9|10|11|12|13")
  @ l_s+01 ,c_s+60 GET  situacao;
                   PICT sistema[op_sis,O_CAMPO,03,O_MASC]
                   DEFINICAO 3
                   MOSTRA sistema[op_sis,O_FORMULA,1]

  @ l_s+03 ,c_s+10 GET  nome;
                   PICT sistema[op_sis,O_CAMPO,04,O_MASC]
                   DEFINICAO 4

  @ l_s+03 ,c_s+53 GET  nascto_;
                   PICT sistema[op_sis,O_CAMPO,05,O_MASC]
                   DEFINICAO 5
                   MOSTRA sistema[op_sis,O_FORMULA,16]

  @ l_s+04 ,c_s+10 GET  estcivil;
                   PICT sistema[op_sis,O_CAMPO,06,O_MASC]
                   DEFINICAO 6
                   MOSTRA sistema[op_sis,O_FORMULA,8]

  @ l_s+04 ,c_s+31 GET  cpf;
                   PICT sistema[op_sis,O_CAMPO,07,O_MASC]
                   DEFINICAO 7

  @ l_s+04 ,c_s+53 GET  rg;
                   PICT sistema[op_sis,O_CAMPO,08,O_MASC]
                   DEFINICAO 8

  @ l_s+05 ,c_s+10 GET  endereco;
                   PICT sistema[op_sis,O_CAMPO,09,O_MASC]
                   DEFINICAO 9

  @ l_s+05 ,c_s+53 GET  bairro;
                   PICT sistema[op_sis,O_CAMPO,10,O_MASC]
                   DEFINICAO 10

  @ l_s+06 ,c_s+10 GET  cidade;
                   PICT sistema[op_sis,O_CAMPO,11,O_MASC]
                   DEFINICAO 11

  @ l_s+06 ,c_s+41 GET  uf;
                   PICT sistema[op_sis,O_CAMPO,12,O_MASC]
                   DEFINICAO 12

  @ l_s+06 ,c_s+53 GET  cep;
                   PICT sistema[op_sis,O_CAMPO,13,O_MASC]
                   DEFINICAO 13

  @ l_s+07 ,c_s+10 GET  natural;
                   PICT sistema[op_sis,O_CAMPO,14,O_MASC]
                   DEFINICAO 14

  @ l_s+07 ,c_s+43 GET  relig;
                   PICT sistema[op_sis,O_CAMPO,15,O_MASC]
                   DEFINICAO 15

  @ l_s+08 ,c_s+10 GET  contato;
                   PICT sistema[op_sis,O_CAMPO,16,O_MASC]
                   DEFINICAO 16

  @ l_s+08 ,c_s+41 GET  telefone;
                   PICT sistema[op_sis,O_CAMPO,17,O_MASC]
                   DEFINICAO 17

  @ l_s+09 ,c_s+12 GET  tipcont;
                   PICT sistema[op_sis,O_CAMPO,18,O_MASC]
                   DEFINICAO 18

  @ l_s+09 ,c_s+23 GET  vlcarne
                   DEFINICAO 19

  @ l_s+09 ,c_s+36 GET  formapgto;
                   PICT sistema[op_sis,O_CAMPO,20,O_MASC]
                   DEFINICAO 20
                   MOSTRA sistema[op_sis,O_FORMULA,15]

  @ l_s+10 ,c_s+12 GET  admissao;
                   PICT sistema[op_sis,O_CAMPO,22,O_MASC]
                   DEFINICAO 22

  @ l_s+10 ,c_s+36 GET  tcarencia;
                   PICT sistema[op_sis,O_CAMPO,23,O_MASC]
                   DEFINICAO 23

  @ l_s+10 ,c_s+61 GET  saitxa;
                   PICT sistema[op_sis,O_CAMPO,24,O_MASC]
                   DEFINICAO 24

  @ l_s+11 ,c_s+61 GET  diapgto;
                   PICT sistema[op_sis,O_CAMPO,25,O_MASC]
                   DEFINICAO 25

  @ l_s+11 ,c_s+12 GET  vendedor;
                   PICT sistema[op_sis,O_CAMPO,26,O_MASC]
                   DEFINICAO 26

  @ l_s+12 ,c_s+12 GET  regiao;
                   PICT sistema[op_sis,O_CAMPO,27,O_MASC]
                   DEFINICAO 27
                   MOSTRA sistema[op_sis,O_FORMULA,7]

  @ l_s+13 ,c_s+12 GET  cobrador;
                   PICT sistema[op_sis,O_CAMPO,28,O_MASC]
                   DEFINICAO 28
                   MOSTRA sistema[op_sis,O_FORMULA,4]
                   MOSTRA sistema[op_sis,O_FORMULA,5]

  @ l_s+12 ,c_s+61 GET  memo29;
                   PICT "@!"
                   DEFINICAO 29

  @ l_s+13 ,c_s+61 GET  renovar;
                   PICT sistema[op_sis,O_CAMPO,30,O_MASC]
                   DEFINICAO 30

  @ l_s+14 ,c_s+12 GET  funerais;
                   PICT sistema[op_sis,O_CAMPO,31,O_MASC]
                   DEFINICAO 31

  @ l_s+14 ,c_s+29 GET  circinic;
                   PICT sistema[op_sis,O_CAMPO,32,O_MASC]
                   DEFINICAO 32

  @ l_s+14 ,c_s+41 GET  ultcirc;
                   PICT sistema[op_sis,O_CAMPO,33,O_MASC]
                   DEFINICAO 33

  @ l_s+14 ,c_s+54 GET  qtcircs;
                   PICT sistema[op_sis,O_CAMPO,34,O_MASC]
                   DEFINICAO 34

  @ l_s+14 ,c_s+65 GET  qtcircpg;
                   PICT sistema[op_sis,O_CAMPO,35,O_MASC]
                   DEFINICAO 35

  @ l_s+15 ,c_s+16 GET  atend1;
                   PICT sistema[op_sis,O_CAMPO,45,O_MASC]
                   DEFINICAO 45
  READ
  SETKEY(K_F7,t_f7_)
  SET KEY K_ALT_F8 TO
  IF rola_t
   ROLATELA()
   LOOP
  ENDI
  IF LASTKEY()!=K_ESC .AND. drvincl .AND. op_menu=INCLUSAO
   IF !CONFINCL()
    LOOP
   ENDI
  ENDI
  EXIT
 ENDD
ENDI
PTAB('',[ARQGRUP],1)
PTAB(TIPCONT,'CLASSES',1)
PTAB(VENDEDOR,'COBRADOR',1)
PTAB(REGIAO,'REGIAO',1)
PTAB(COBRADOR,'COBRADOR',1)
PTAB(IIF(CLASSES->PRIOR=[S],M->MGRUPVIP,GRUPO)+ULTCIRC,'CIRCULAR',1)
IF tp_mov=EXCLUI .OR. tp_mov=FORM_INVERSA

 #ifdef COM_REDE
  REPBLO('ARQGRUP->contrat',{||ARQGRUP->contrat - 1})
 #else
  REPL ARQGRUP->contrat WITH ARQGRUP->contrat - 1
 #endi

 INTREF(FORM_INVERSA)
 IF !EMPTY(ALIAS())
  DELE
 ENDI
ELSEIF tp_mov=INCLUI .OR. tp_mov=RECUPERA .OR. tp_mov=FORM_DIRETA
 IF (op_menu=INCLUSAO .AND. LASTKEY()!=K_ESC) .OR. op_menu!=INCLUSAO

  #ifdef COM_REDE
   REPBLO('ARQGRUP->contrat',{||ARQGRUP->contrat + 1})
   IF op_menu=INCLUSAO
    ender_=DATE()
   ELSE
    REPL ender_ WITH DATE()
   ENDI
   IF op_menu=INCLUSAO
    ultend=M->usuario
   ELSE
    REPL ultend WITH M->usuario
   ENDI
  #else
   REPL ARQGRUP->contrat WITH ARQGRUP->contrat + 1
   IF op_menu=INCLUSAO
    ender_=DATE()
   ELSE
    REPL ender_ WITH DATE()
   ENDI
   IF op_menu=INCLUSAO
    ultend=M->usuario
   ELSE
    REPL ultend WITH M->usuario
   ENDI
  #endi

  IF op_menu!=INCLUSAO
   RECA
   INTREF(FORM_DIRETA)
  ENDI
 ENDI
ENDI
RETU

PROC GRU_MEMO
IF READVAR()="MEMO29"
 EDIMEMO("obs",sistema[op_sis,O_CAMPO,29,O_TITU],14,2,23,38)
ENDI
RETU

PROC TAX_incl(reg_cop)  // inclusao no arquivo TAXAS
LOCAL getlist:={}, cabem:=1, rep:=ARRAY(FCOU()), ult_reg:=RECN(),;
      ctl_r, ctl_c, t_f3_, t_f4_, l_max, dele_atu:=SET(_SET_DELETED,.f.)
PRIV op_menu:=INCLUSAO, op_sis, l_s, c_s, l_i, c_i, cod_sos, tem_borda, criterio:="", cpord:="", l_a
op_sis=EVAL(qualsis,"TAXAS")
IF AT("D",exrot[op_sis])>0
 RETU
ENDI
FOR i=1 TO FCOU()                                  // cria/declara privadas as
 msg=FIEL(i)                                       // variaveis de memoria com
 PRIV &msg.                                        // o mesmo nome dos campos
NEXT                                               // do arquivo
IF reg_cop!=NIL                                    // quer repetir todo o reg atual
 FOR i=1 TO FCOU()                                 // para cada campo,
  msg=FIEL(i)                                      // salva o conteudo
  rep[i]=&msg.                                     // para repetir
 NEXT
ELSE
 AFILL(rep,"")                                     // eche com valor vazio
ENDI
t_f3_=SETKEY(K_F3,{||rep()})                       // repeticao reg anterior
t_f4_=SETKEY(K_F4,{||conf()})                      // confirma campos com ENTER
ctl_w=SETKEY(K_CTRL_W,{||nadafaz()})               // enganando o CA-Clipper...
ctl_c=SETKEY(K_CTRL_C,{||nadafaz()})
ctl_r=SETKEY(K_CTRL_R,{||nadafaz()})
DISPBEGIN()                                        // monta tela na pagina de traz
IMPRELA()                                          // imp telas do pai
TAX_TELA()                                         // imp tela para inclusao
INFOSIS(.t.)                                       // exibe informacao no rodape' da tela
l_a=Sistema[op_sis,O_TELA,O_SCROLL]
DISPEND()                                          // apresenta tela de uma vez so
DO WHIL cabem>0
 cod_sos=6
 rola_t=.f.                                        // flag se quer rolar a tela
 SELE TAXAS
 GO BOTT                                           // forca o
 SKIP                                              // final do arquivo
 
 /*
    cria variaveis de memoria identicas as de arquivo, para inclusao
    de registros
 */
 FOR i=1 TO FCOU()
  msg=FIEL(i)
  M->&msg.=IF((fgrep .OR. reg_cop!=NIL).AND.!EMPT(rep[1]),rep[i],&msg.)
 NEXT
 
 /*
    inicializa campos de relacionamentos do com os campos do arquivo
    superior (pai)
 */
 FOR i=1 TO LEN(sistema[op_sis,O_CPRELA])
  msg=FIEL(VAL(SUBS(sistema[op_sis,O_ORDEM,1],i*2-1,2)))
  M->&msg.=&(sistema[op_sis,O_CPRELA,i])
 NEXT
 cabem=DISKSPACE(;
          IF(;
             LEN(sistema[op_sis,O_ARQUI,O_DIR_DBF])<2.OR.sistema[op_sis,O_ARQUI,O_DIR_DBF]="\",;
             0,;
             ASC(sistema[op_sis,O_ARQUI,O_DIR_DBF])-64;
          );
       )
 cabem=INT((cabem-2048)/TAXAS->(RECSIZE()))
 IF cabem<1                                        // mais nenhum!!!
  ALERTA()
  msg="Verifique ESPA€O EM DISCO, "+usuario
  DBOX(msg,,,,,"INCLUSŽO INTERROMPIDA!")           // vamos parar por aqui!
  EXIT
 ENDI
 SELE 0                                            // torna visiveis variaveis de memoria
 SETCOLOR(drvcortel+","+drvcorget+",,,"+corcampo)
 SET KEY K_ALT_F8 TO ROLATELA
 
 /*
    recebe chaves do arquivo de indice basico
 */
 @ l_s+l_a,c_s+11 GET  cobranca;
                  PICT sistema[op_sis,O_CAMPO,02,O_MASC]
                  DEFINICAO 2

 READ
 SET KEY K_ALT_F8 TO
 IF rola_t
  ROLATELA()
  LOOP
 ENDI
 SELE TAXAS
 IF LASTKEY()=K_ESC                                // cancelou ou chave em branco
  cabem=0                                          // prepara saida da inclusao
  LOOP                                             // volta p/ menu de cadastramento
 ENDI
 SEEK M->codigo+M->cobranca
 aprov_reg_=(FOUND().AND.DELE().AND.!drvvisivel)   // vai aproveitar o registro?
 IF FOUND() .AND. !aprov_reg_                      // pesquisou e achou!
  l_a=Sistema[op_sis,O_TELA,O_SCROLL]
  op_menu=ALTERACAO                                // seta flag de ateracao
  DISPBEGIN()
  TAX_GETS()                                       // mostra conteudo do registro
  INFOSIS(.f.)                                     // exibe informacao no rodape' da tela
  DISPEND()
  ALERTA()
  msg="Consultar/alterar|Retornar … inclus„o"      // pergunta se deseja
  op_=DBOX(msg,,,E_MENU,,"REGISTRO J EXISTE")     // alterar o registro
  IF op_ =1                                        // caso afirmativo
   EDIT()                                          // deixa alterar
  ENDI
  op_menu=INCLUSAO
  DISPBEGIN()
  TAX_TELA()
  INFOSIS(.t.)                                     // exibe informacao no rodape' da tela
  DISPEND()
  LOOP                                             // volta para inclusao
 ENDI
 SELE 0
 TAX_GET1(INCLUI)                                  // recebe campos
 SELE TAXAS
 IF LASTKEY()=K_ESC                                // se cancelou
  ALERTA()                                         // avisa que o registro
  DBOX("Registro n„o inclu¡do!",18,,1)             // nao foi incluido, e volta
  LOOP
 ENDI

 #ifdef COM_REDE
  GO BOTT                                          // vamos bloquear o final do
  SKIP                                             // arq para que nehum outro
  BLOREG(0,.5)                                     // usuario possa incluir
  SEEK M->codigo+M->cobranca                       // se registro foi incluido
  aprov_reg_=(FOUND().AND.DELE().AND.!drvvisivel)  // vai aproveitar o registro?
  IF FOUND() .AND. !aprov_reg_                     // por outro usuario, entao
   BLOREG(0,.5)
   FOR i=1 TO FCOU()
    msg=FIEL(i)
    rep[i]=&msg.
    REPL &msg. WITH M->&msg.
   NEXT
   TAX_GET1(FORM_INVERSA)                          // executa formula inversa
   RECA
   FOR i=1 TO FCOU()
    msg=FIEL(i)
    REPL &msg. WITH rep[i]
   NEXT
   ALERTA(4)                                       // beep 4 vezes
   msg="Registro acabou de ser|inclu¡do por outro usu rio!"
   DBOX(msg,,,,,"ATEN€ŽO!")                        // avisa
   SELE TAXAS
   UNLOCK                                          // libera o registro
   LOOP                                            // e recebe chave novamente
  ENDI
 #endi

 IF aprov_reg_                                     // se vai aproveitar reg excluido

  #ifdef COM_REDE
   BLOREG(0,.5)
  #endi

  RECA                                             // excluido, vamos recupera-lo
 ELSE                                              // caso contrario
  APPEND BLANK                                     // inclui reg em branco no dbf
 ENDI
 FOR i=1 TO FCOU()                                 // para cada campo,
  msg=FIEL(i)                                      // salva o conteudo
  rep[i]=M->&msg.                                  // para repetir
  REPL &msg. WITH rep[i]                           // enche o campo do arquivo
 NEXT

 #ifdef COM_REDE
  UNLOCK                                           // libera o registro e
  COMMIT                                           // forca gravacao
 #else
  IF RECC()-INT(RECC()/20)*20=0                    // a cada 20 registros
   COMMIT                                          // digitados forca gravacao
  ENDI
 #endi

 ult_reg=RECN()                                    // ultimo registro digitado
 l_max=l_s+Sistema[op_sis,O_TELA,O_SCROLL]+Sistema[op_sis,O_TELA,O_QTDE]
 IF l_s+l_a+1<l_max                                // se nao atingiu o fim da tela
  l_a++                                            // digita na proxima linha
 ELSE                                              // se nao rola a campos para cima
  SCROLL(l_s+Sistema[op_sis,O_TELA,O_SCROLL],c_s+11,l_max-1,c_s+28,1)
  SCROLL(l_s+Sistema[op_sis,O_TELA,O_SCROLL],c_s+30,l_max-1,c_s+39,1)
  SCROLL(l_s+Sistema[op_sis,O_TELA,O_SCROLL],c_s+41,l_max-1,c_s+50,1)
  SCROLL(l_s+Sistema[op_sis,O_TELA,O_SCROLL],c_s+53,l_max-1,c_s+62,1)
  SCROLL(l_s+Sistema[op_sis,O_TELA,O_SCROLL],c_s+64,l_max-1,c_s+73,1)
  SCROLL(l_s+Sistema[op_sis,O_TELA,O_SCROLL],c_s+75,l_max-1,c_s+77,1)
  SCROLL(l_s+Sistema[op_sis,O_TELA,O_SCROLL],c_s+01,l_max-1,c_s+08,1)
 ENDI
 IF reg_cop!=NIL                                   // estava na consulta e quis rep o campo
  EXIT                                             // cai fora...
 ENDI
ENDD
GO ult_reg                                         // para o ultimo reg digitado
SETKEY(K_F3,t_f3_)                                 // restaura teclas de funcoes
SETKEY(K_F4,t_f4_)
SET(_SET_DELETED,dele_atu)                            // ecluidos visiveis/invisiveis
SETKEY(K_CTRL_W,ctl_w)
SETKEY(K_CTRL_C,ctl_c)
SETKEY(K_CTRL_R,ctl_r)
RETU


PROC TAX_tela     // tela do arquivo TAXAS
tem_borda=.t.
l_s=Sistema[op_sis,O_TELA,O_LS]           // coordenadas da tela
c_s=Sistema[op_sis,O_TELA,O_CS]
l_i=Sistema[op_sis,O_TELA,O_LI]
c_i=Sistema[op_sis,O_TELA,O_CI]
SETCOLOR(drvtittel)
vr_memo=NOVAPOSI(@l_s,@c_s,@l_i,@c_i)     // pega posicao atual da tela
CAIXA(mold,l_s,c_s,l_i,c_i)               // monta caixa da tela
i=LEN(sistema[op_sis,O_MENS])/2
@ l_s,c_s-1+(c_i-c_s+1)/2-i SAY " "+MAIUSC(sistema[op_sis,O_MENS])+" "
SETCOLOR(drvcortel)
@ l_s+01,c_s+1 SAY "N§                            Emissao       Valor  ³ Pagto    Valor Pago Stat"
@ l_s+02,c_s+1 SAY "ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ"
@ l_s+03,c_s+1 SAY "                                                   ³"
@ l_s+04,c_s+1 SAY "                                                   ³"
@ l_s+05,c_s+1 SAY "                                                   ³"
@ l_s+06,c_s+1 SAY "                                                   ³"
@ l_s+07,c_s+1 SAY "                                                   ³"
@ l_s+08,c_s+1 SAY "                                                   ³"
@ l_s+09,c_s+1 SAY "                                                   ³"
RETU

PROC TAX_gets     // mostra variaveis do arquivo TAXAS
LOCAL getlist := {}, l_max, reg_atual:=RECNO()
PRIV  l_a:=Sistema[op_sis,O_TELA,O_SCROLL]
TAX_TELA()
l_max=l_s+Sistema[op_sis,O_TELA,O_SCROLL]+Sistema[op_sis,O_TELA,O_QTDE]
SETCOLOR(drvcortel+","+drvcorget+",,,"+corcampo)
DO WHILE !EOF() .AND. l_s+l_a<l_max .AND.;
   &(INDEXKEY(0))=IF(EMPT(criterio),"","T")+chv_1
 CRIT("",,"1|2")
 @ l_s+l_a,c_s+11 GET  cobranca;
                  PICT sistema[op_sis,O_CAMPO,02,O_MASC]

 @ l_s+l_a,c_s+30 GET  emissao_;
                  PICT sistema[op_sis,O_CAMPO,05,O_MASC]

 @ l_s+l_a,c_s+41 GET  valor;
                  PICT sistema[op_sis,O_CAMPO,06,O_MASC]

 @ l_s+l_a,c_s+53 GET  pgto_;
                  PICT sistema[op_sis,O_CAMPO,07,O_MASC]

 @ l_s+l_a,c_s+64 GET  valorpg;
                  PICT sistema[op_sis,O_CAMPO,08,O_MASC]

 SETCOLOR(drvcortel+","+drvcortel+",,,"+drvcortel)
 l_a++
 SKIP
ENDD
GO reg_atual
SETCOLOR(drvcortel+","+drvcorget+",,,"+corcampo)
CLEAR GETS
RETU

PROC TAX_get1(tp_mov, excl_rela)     // capta variaveis do arquivo TAXAS
LOCAL getlist := {}
PRIV  blk_taxas:=.t.
excl_rela=IF(excl_rela=NIL,.f.,excl_rela)
IF tp_mov=INCLUI
 IF TYPE("l_a")!="N"
  l_a=Sistema[op_sis,O_TELA,O_SCROLL]
 ENDI
 DO WHILE .t.
  rola_t=.f.
  SET KEY K_ALT_F8 TO ROLATELA
  SETCOLOR(drvcortel+","+drvcorget+",,,"+corcampo)
  CRIT("",,"1|2")
  @ l_s+l_a,c_s+30 GET  emissao_;
                   PICT sistema[op_sis,O_CAMPO,05,O_MASC]
                   DEFINICAO 5

  @ l_s+l_a,c_s+41 GET  valor;
                   PICT sistema[op_sis,O_CAMPO,06,O_MASC]
                   DEFINICAO 6

  @ l_s+l_a,c_s+53 GET  pgto_;
                   PICT sistema[op_sis,O_CAMPO,07,O_MASC]
                   DEFINICAO 7

  @ l_s+l_a,c_s+64 GET  valorpg;
                   PICT sistema[op_sis,O_CAMPO,08,O_MASC]
                   DEFINICAO 8

  READ
  SET KEY K_ALT_F8 TO
  IF rola_t
   ROLATELA()
   LOOP
  ENDI
  IF LASTKEY()!=K_ESC .AND. drvincl .AND. op_menu=INCLUSAO
   IF !CONFINCL()
    LOOP
   ENDI
  ENDI
  EXIT
 ENDD
ENDI
PTAB(COBRADOR,'COBRADOR',1)
PTAB(COBRADOR+M->MMESREF,'FCCOB',1)
IF tp_mov=EXCLUI .OR. tp_mov=FORM_INVERSA
 IF !EMPTY(codlan) .AND. tp_mov=EXCLUI
  ALERTA()       // existe registro validado aqui!
  msg="Registro de Lan‡amento"
  DBOX(msg,,,,,"IMPOSS¡VEL EXCLUIR!")
 ELSE

  #ifdef COM_REDE
   IF !tipo='1'
    REPBLO('GRUPOS->qtcircs',{||GRUPOS->qtcircs - 1})
   ENDI
   IF !tipo='1'.AND.valorpg>0
    REPBLO('GRUPOS->qtcircpg',{||GRUPOS->qtcircpg - 1})
   ENDI
   IF !excl_rela
    IF !EMPTY(ALIAS())
     REPL flag_excl WITH '*'
    ENDI
   ENDI
  #else
   IF !tipo='1'
    REPL GRUPOS->qtcircs WITH GRUPOS->qtcircs - 1
   ENDI
   IF !tipo='1'.AND.valorpg>0
    REPL GRUPOS->qtcircpg WITH GRUPOS->qtcircpg - 1
   ENDI
   IF !excl_rela
    IF !EMPTY(ALIAS())
     REPL flag_excl WITH '*'
    ENDI
   ENDI
  #endi

  IF !EMPTY(ALIAS())
   DELE
  ENDI
 ENDI
ELSEIF tp_mov=INCLUI .OR. tp_mov=RECUPERA .OR. tp_mov=FORM_DIRETA
 IF (op_menu=INCLUSAO .AND. LASTKEY()!=K_ESC) .OR. op_menu!=INCLUSAO
  IF !EMPTY(codlan) .AND. tp_mov=RECUPERA
   ALERTA()      // existe registro validado aqui!
   msg="Registro de Lan‡amento"
   DBOX(msg,,,,,"IMPOSS¡VEL RECUPERAR!")
  ELSE
   IF tp_mov=RECUPERA .AND. op_menu!=INCLUSAO .AND. (GRUPOS->(DELE()))
    msg="|"+sistema[EVAL(qualsis,"GRUPOS"),O_MENU]
    ALERTA(2)
    DBOX("Registro exclu¡do em:"+msg+"|*",,,,,"IMPOSS¡VEL RECUPERAR!")
   ELSE

    #ifdef COM_REDE
     IF !tipo='1'
      REPBLO('GRUPOS->qtcircs',{||GRUPOS->qtcircs + 1})
     ENDI
     IF !tipo='1'.AND.valorpg>0
      REPBLO('GRUPOS->qtcircpg',{||GRUPOS->qtcircpg + 1})
     ENDI
     IF !tipo='1'.AND.circ>GRUPOS->ultcirc
      REPBLO('GRUPOS->ultcirc',{||circ})
     ENDI
     IF !excl_rela
      IF op_menu=INCLUSAO
       flag_excl=' '
      ELSE
       REPL flag_excl WITH ' '
      ENDI
     ENDI
    #else
     IF !tipo='1'
      REPL GRUPOS->qtcircs WITH GRUPOS->qtcircs + 1
     ENDI
     IF !tipo='1'.AND.valorpg>0
      REPL GRUPOS->qtcircpg WITH GRUPOS->qtcircpg + 1
     ENDI
     IF !tipo='1'.AND.circ>GRUPOS->ultcirc
      REPL GRUPOS->ultcirc WITH circ
     ENDI
     IF !excl_rela
      IF op_menu=INCLUSAO
       flag_excl=' '
      ELSE
       REPL flag_excl WITH ' '
      ENDI
     ENDI
    #endi

    IF op_menu!=INCLUSAO
     RECA
    ENDI
   ENDI
  ENDI
 ENDI
ENDI
RETU

PROC ECO_incl(reg_cop)  // inclusao no arquivo ECOB
LOCAL getlist:={}, cabem:=1, rep:=ARRAY(FCOU()), ult_reg:=RECN(),;
      ctl_r, ctl_c, ctl_w, t_f3_, t_f4_, dele_atu:=SET(_SET_DELETED,.f.)
PRIV op_menu:=INCLUSAO, op_sis, l_s, c_s, l_i, c_i, cod_sos, tem_borda, criterio:="", cpord:=""
op_sis=EVAL(qualsis,"ECOB")
IF AT("D",exrot[op_sis])>0
 RETU
ENDI
FOR i=1 TO FCOU()                                  // cria/declara privadas as
 msg=FIEL(i)                                       // variaveis de memoria com
 PRIV &msg.                                        // o mesmo nome dos campos
NEXT                                               // do arquivo
IF reg_cop!=NIL                                    // quer repetir todo o reg atual
 FOR i=1 TO FCOU()                                 // para cada campo,
  msg=FIEL(i)                                      // salva o conteudo
  rep[i]=&msg.                                     // para repetir
 NEXT
ELSE
 AFILL(rep,"")                                     // eche com valor vazio
ENDI
t_f3_=SETKEY(K_F3,{||rep()})                       // repeticao reg anterior
t_f4_=SETKEY(K_F4,{||conf()})                      // confirma campos com ENTER
ctl_w=SETKEY(K_CTRL_W,{||nadafaz()})               // enganando o CA-Clipper...
ctl_c=SETKEY(K_CTRL_C,{||nadafaz()})
ctl_r=SETKEY(K_CTRL_R,{||nadafaz()})
DO WHIL cabem>0
 cod_sos=6
 rola_t=.f.                                        // flag se quer rolar a tela
 SELE ECOB
 GO BOTT                                           // forca o
 SKIP                                              // final do arquivo
 
 /*
    cria variaveis de memoria identicas as de arquivo, para inclusao
    de registros
 */
 FOR i=1 TO FCOU()
  msg=FIEL(i)
  M->&msg.=IF((fgrep .OR. reg_cop!=NIL).AND.!EMPT(rep[1]),rep[i],&msg.)
 NEXT
 
 /*
    inicializa campos de relacionamentos do com os campos do arquivo
    superior (pai)
 */
 FOR i=1 TO LEN(sistema[op_sis,O_CPRELA])
  msg=FIEL(VAL(SUBS(sistema[op_sis,O_ORDEM,1],i*2-1,2)))
  M->&msg.=&(sistema[op_sis,O_CPRELA,i])
 NEXT
 DISPBEGIN()                                       // apresenta a tela de uma vez so
 ECO_TELA()
 INFOSIS(.t.)                                      // exibe informacao no rodape' da tela
 DISPEND()
 cabem=DISKSPACE(;
          IF(;
             LEN(sistema[op_sis,O_ARQUI,O_DIR_DBF])<2.OR.sistema[op_sis,O_ARQUI,O_DIR_DBF]="\",;
             0,;
             ASC(sistema[op_sis,O_ARQUI,O_DIR_DBF])-64;
          );
       )
 cabem=INT((cabem-2048)/ECOB->(RECSIZE()))
 IF cabem<1                                        // mais nenhum!!!
  ALERTA()
  msg="Verifique ESPA€O EM DISCO, "+usuario
  DBOX(msg,,,,,"INCLUSŽO INTERROMPIDA!")           // vamos parar por aqui!
  EXIT
 ENDI
 SELE 0                                            // torna visiveis variaveis de memoria
 SETCOLOR(drvcortel+","+drvcorget+",,,"+corcampo)
 SET KEY K_ALT_F8 TO ROLATELA
 
 /*
    recebe chaves do arquivo de indice basico
 */
 @ l_s+01 ,c_s+12 GET  tipo;
                  PICT sistema[op_sis,O_CAMPO,02,O_MASC]
                  DEFINICAO 2
                  MOSTRA sistema[op_sis,O_FORMULA,1]

 READ
 SET KEY K_ALT_F8 TO
 IF rola_t
  ROLATELA()
  LOOP
 ENDI
 SELE ECOB
 IF LASTKEY()=K_ESC                                // cancelou ou chave em branco
  cabem=0                                          // prepara saida da inclusao
  LOOP                                             // volta p/ menu de cadastramento
 ENDI
 SEEK M->codigo+M->tipo
 aprov_reg_=(FOUND().AND.DELE().AND.!drvvisivel)   // vai aproveitar o registro?
 IF FOUND() .AND. !aprov_reg_                      // pesquisou e achou!
  op_menu=ALTERACAO                                // seta flag de ateracao
  DISPBEGIN()
  ECO_GETS()                                       // mostra conteudo do registro
  INFOSIS(.f.)                                     // exibe informacao no rodape' da tela
  DISPEND()
  ALERTA()
  msg="Consultar/alterar|Retornar … inclus„o"      // pergunta se deseja
  op_=DBOX(msg,,,E_MENU,,"REGISTRO J EXISTE")     // alterar o registro
  IF op_ =1                                        // caso afirmativo
   EDIT()                                          // deixa alterar
  ENDI
  op_menu=INCLUSAO
  LOOP                                             // volta para inclusao
 ENDI
 SELE 0
 ECO_GET1(INCLUI)                                  // recebe campos
 SELE ECOB
 IF LASTKEY()=K_ESC                                // se cancelou
  ALERTA()                                         // avisa que o registro
  DBOX("Registro n„o inclu¡do!",18,,1)             // nao foi incluido, e volta
  LOOP
 ENDI

 #ifdef COM_REDE
  GO BOTT                                          // vamos bloquear o final do
  SKIP                                             // arq para que nehum outro
  BLOREG(0,.5)                                     // usuario possa incluir
  SEEK M->codigo+M->tipo                           // se registro foi incluido
  aprov_reg_=(FOUND().AND.DELE().AND.!drvvisivel)  // vai aproveitar o registro?
  IF FOUND() .AND. !aprov_reg_                     // por outro usuario, entao
   BLOREG(0,.5)
   FOR i=1 TO FCOU()
    msg=FIEL(i)
    rep[i]=&msg.
    REPL &msg. WITH M->&msg.
   NEXT
   ECO_GET1(FORM_INVERSA)                          // executa formula inversa
   RECA
   FOR i=1 TO FCOU()
    msg=FIEL(i)
    REPL &msg. WITH rep[i]
   NEXT
   ALERTA(4)                                       // beep 4 vezes
   msg="Registro acabou de ser|inclu¡do por outro usu rio!"
   DBOX(msg,,,,,"ATEN€ŽO!")                        // avisa
   SELE ECOB
   UNLOCK                                          // libera o registro
   LOOP                                            // e recebe chave novamente
  ENDI
 #endi

 IF aprov_reg_                                     // se vai aproveitar reg excluido

  #ifdef COM_REDE
   BLOREG(0,.5)
  #endi

  RECA                                             // excluido, vamos recupera-lo
 ELSE                                              // caso contrario
  APPEND BLANK                                     // inclui reg em branco no dbf
 ENDI
 FOR i=1 TO FCOU()                                 // para cada campo,
  msg=FIEL(i)                                      // salva o conteudo
  rep[i]=M->&msg.                                  // para repetir
  REPL &msg. WITH rep[i]                           // enche o campo do arquivo
 NEXT

 #ifdef COM_REDE
  UNLOCK                                           // libera o registro e
  COMMIT                                           // forca gravacao
 #else
  IF RECC()-INT(RECC()/20)*20=0                    // a cada 20 registros
   COMMIT                                          // digitados forca gravacao
  ENDI
 #endi

 ult_reg=RECN()                                    // ultimo registro digitado
 IF reg_cop!=NIL                                   // estava na consulta e quis rep o campo
  EXIT                                             // cai fora...
 ENDI
ENDD
GO ult_reg                                         // para o ultimo reg digitado
SETKEY(K_F3,t_f3_)                                 // restaura teclas de funcoes
SETKEY(K_F4,t_f4_)
SET(_SET_DELETED,dele_atu)                            // ecluidos visiveis/invisiveis
SETKEY(K_CTRL_W,ctl_w)
SETKEY(K_CTRL_C,ctl_c)
SETKEY(K_CTRL_R,ctl_r)
RETU


PROC ECO_tela     // tela do arquivo ECOB
tem_borda=.t.
l_s=Sistema[op_sis,O_TELA,O_LS]           // coordenadas da tela
c_s=Sistema[op_sis,O_TELA,O_CS]
l_i=Sistema[op_sis,O_TELA,O_LI]
c_i=Sistema[op_sis,O_TELA,O_CI]
SETCOLOR(drvtittel)
vr_memo=NOVAPOSI(@l_s,@c_s,@l_i,@c_i)     // pega posicao atual da tela
CAIXA(mold,l_s,c_s,l_i,c_i)               // monta caixa da tela
i=LEN(sistema[op_sis,O_MENS])/2
@ l_s,c_s-1+(c_i-c_s+1)/2-i SAY " "+MAIUSC(sistema[op_sis,O_MENS])+" "
SETCOLOR(drvcortel)
@ l_s+01,c_s+1 SAY " Tipo....:"
@ l_s+02,c_s+1 SAY " Endere‡o:"
@ l_s+03,c_s+1 SAY " Bairro..:"
@ l_s+04,c_s+1 SAY " CEP.....:"
@ l_s+05,c_s+1 SAY " Cidade..:                            Est.:"
@ l_s+06,c_s+1 SAY " Telefone:"
@ l_s+07,c_s+1 SAY " Obs.....:"
RETU

PROC ECO_gets     // mostra variaveis do arquivo ECOB
LOCAL getlist := {}
ECO_TELA()
SETCOLOR(drvcortel+","+drvcorget+",,,"+corcampo)
IF &(INDEXKEY(0))=IF(EMPT(criterio),"","T")+chv_1
 CRIT("",,"2")
 @ l_s+01 ,c_s+12 GET  tipo;
                  PICT sistema[op_sis,O_CAMPO,02,O_MASC]
                  CRIT(sistema[op_sis,O_CAMPO,02,O_CRIT],,"1")

 @ l_s+02 ,c_s+12 GET  endereco;
                  PICT sistema[op_sis,O_CAMPO,03,O_MASC]

 @ l_s+03 ,c_s+12 GET  bairro;
                  PICT sistema[op_sis,O_CAMPO,04,O_MASC]

 @ l_s+04 ,c_s+12 GET  cep;
                  PICT sistema[op_sis,O_CAMPO,05,O_MASC]

 @ l_s+05 ,c_s+12 GET  cidade;
                  PICT sistema[op_sis,O_CAMPO,06,O_MASC]

 @ l_s+05 ,c_s+45 GET  uf;
                  PICT sistema[op_sis,O_CAMPO,07,O_MASC]

 @ l_s+06 ,c_s+12 GET  telefone;
                  PICT sistema[op_sis,O_CAMPO,08,O_MASC]

 @ l_s+07 ,c_s+12 GET  obs

ENDI
CLEAR GETS
RETU

PROC ECO_get1(tp_mov, excl_rela)     // capta variaveis do arquivo ECOB
LOCAL getlist := {}
PRIV  blk_ecob:=.t.
excl_rela=IF(excl_rela=NIL,.f.,excl_rela)
IF tp_mov=INCLUI
 DO WHILE .t.
  rola_t=.f.
  SET KEY K_ALT_F8 TO ROLATELA
  SETCOLOR(drvcortel+","+drvcorget+",,,"+corcampo)
  CRIT("",,"2")
  @ l_s+02 ,c_s+12 GET  endereco;
                   PICT sistema[op_sis,O_CAMPO,03,O_MASC]
                   DEFINICAO 3

  @ l_s+03 ,c_s+12 GET  bairro;
                   PICT sistema[op_sis,O_CAMPO,04,O_MASC]
                   DEFINICAO 4

  @ l_s+04 ,c_s+12 GET  cep;
                   PICT sistema[op_sis,O_CAMPO,05,O_MASC]
                   DEFINICAO 5

  @ l_s+05 ,c_s+12 GET  cidade;
                   PICT sistema[op_sis,O_CAMPO,06,O_MASC]
                   DEFINICAO 6

  @ l_s+05 ,c_s+45 GET  uf;
                   PICT sistema[op_sis,O_CAMPO,07,O_MASC]
                   DEFINICAO 7

  @ l_s+06 ,c_s+12 GET  telefone;
                   PICT sistema[op_sis,O_CAMPO,08,O_MASC]
                   DEFINICAO 8

  @ l_s+07 ,c_s+12 GET  obs
                   DEFINICAO 9

  READ
  SET KEY K_ALT_F8 TO
  IF rola_t
   ROLATELA()
   LOOP
  ENDI
  IF LASTKEY()!=K_ESC .AND. drvincl .AND. op_menu=INCLUSAO
   IF !CONFINCL()
    LOOP
   ENDI
  ENDI
  EXIT
 ENDD
ENDI
IF tp_mov=EXCLUI .OR. tp_mov=FORM_INVERSA

 #ifdef COM_REDE
  IF !excl_rela
   IF !EMPTY(ALIAS())
    REPL flag_excl WITH '*'
   ENDI
  ENDI
 #else
  IF !excl_rela
   IF !EMPTY(ALIAS())
    REPL flag_excl WITH '*'
   ENDI
  ENDI
 #endi

 IF !EMPTY(ALIAS())
  DELE
 ENDI
ELSEIF tp_mov=INCLUI .OR. tp_mov=RECUPERA .OR. tp_mov=FORM_DIRETA
 IF (op_menu=INCLUSAO .AND. LASTKEY()!=K_ESC) .OR. op_menu!=INCLUSAO
  IF tp_mov=RECUPERA .AND. op_menu!=INCLUSAO .AND. (GRUPOS->(DELE()))
   msg="|"+sistema[EVAL(qualsis,"GRUPOS"),O_MENU]
   ALERTA(2)
   DBOX("Registro exclu¡do em:"+msg+"|*",,,,,"IMPOSS¡VEL RECUPERAR!")
  ELSE
    IF op_menu=INCLUSAO
     data_=DATE()
    ELSE
     REPL data_ WITH DATE()
    ENDI
    IF !excl_rela
     IF op_menu=INCLUSAO
      flag_excl=' '
     ELSE
      REPL flag_excl WITH ' '
     ENDI
    ENDI
   IF op_menu!=INCLUSAO
    RECA
   ENDI
  ENDI
 ENDI
ENDI
RETU

PROC INS_incl(reg_cop)  // inclusao no arquivo INSCRITS
LOCAL getlist:={}, cabem:=1, rep:=ARRAY(FCOU()), ult_reg:=RECN(),;
      ctl_r, ctl_c, ctl_w, t_f3_, t_f4_, dele_atu:=SET(_SET_DELETED,.f.)
PRIV op_menu:=INCLUSAO, op_sis, l_s, c_s, l_i, c_i, cod_sos, tem_borda, criterio:="", cpord:=""
op_sis=EVAL(qualsis,"INSCRITS")
IF AT("D",exrot[op_sis])>0
 RETU
ENDI
FOR i=1 TO FCOU()                                  // cria/declara privadas as
 msg=FIEL(i)                                       // variaveis de memoria com
 PRIV &msg.                                        // o mesmo nome dos campos
NEXT                                               // do arquivo
IF reg_cop!=NIL                                    // quer repetir todo o reg atual
 FOR i=1 TO FCOU()                                 // para cada campo,
  msg=FIEL(i)                                      // salva o conteudo
  rep[i]=&msg.                                     // para repetir
 NEXT
ELSE
 AFILL(rep,"")                                     // eche com valor vazio
ENDI
t_f3_=SETKEY(K_F3,{||rep()})                       // repeticao reg anterior
t_f4_=SETKEY(K_F4,{||conf()})                      // confirma campos com ENTER
ctl_w=SETKEY(K_CTRL_W,{||nadafaz()})               // enganando o CA-Clipper...
ctl_c=SETKEY(K_CTRL_C,{||nadafaz()})
ctl_r=SETKEY(K_CTRL_R,{||nadafaz()})
DO WHIL cabem>0
 cod_sos=6
 rola_t=.f.                                        // flag se quer rolar a tela
 SELE INSCRITS
 GO BOTT                                           // forca o
 SKIP                                              // final do arquivo
 
 /*
    cria variaveis de memoria identicas as de arquivo, para inclusao
    de registros
 */
 FOR i=1 TO FCOU()
  msg=FIEL(i)
  M->&msg.=IF((fgrep .OR. reg_cop!=NIL).AND.!EMPT(rep[1]),rep[i],&msg.)
 NEXT
 
 /*
    inicializa campos de relacionamentos do com os campos do arquivo
    superior (pai)
 */
 FOR i=1 TO LEN(sistema[op_sis,O_CPRELA])
  msg=FIEL(VAL(SUBS(sistema[op_sis,O_ORDEM,1],i*2-1,2)))
  M->&msg.=&(sistema[op_sis,O_CPRELA,i])
 NEXT
 DISPBEGIN()                                       // apresenta a tela de uma vez so
 INS_TELA()
 INFOSIS(.t.)                                      // exibe informacao no rodape' da tela
 DISPEND()
 cabem=DISKSPACE(;
          IF(;
             LEN(sistema[op_sis,O_ARQUI,O_DIR_DBF])<2.OR.sistema[op_sis,O_ARQUI,O_DIR_DBF]="\",;
             0,;
             ASC(sistema[op_sis,O_ARQUI,O_DIR_DBF])-64;
          );
       )
 cabem=INT((cabem-2048)/INSCRITS->(RECSIZE()))
 IF cabem<1                                        // mais nenhum!!!
  ALERTA()
  msg="Verifique ESPA€O EM DISCO, "+usuario
  DBOX(msg,,,,,"INCLUSŽO INTERROMPIDA!")           // vamos parar por aqui!
  EXIT
 ENDI
 SELE 0                                            // torna visiveis variaveis de memoria
 SETCOLOR(drvcortel+","+drvcorget+",,,"+corcampo)
 SET KEY K_ALT_F8 TO ROLATELA

 /*
    recebe chaves do arquivo de indice basico
 */
 @ l_s+01 ,c_s+09 GET  grau;
                  PICT sistema[op_sis,O_CAMPO,02,O_MASC]
                  DEFINICAO 2
                  MOSTRA sistema[op_sis,O_FORMULA,1]

 READ
 SET KEY K_ALT_F8 TO
 IF rola_t
  ROLATELA()
  LOOP
 ENDI
 SELE INSCRITS
 IF LASTKEY()=K_ESC                                // cancelou ou chave em branco
  cabem=0                                          // prepara saida da inclusao
  LOOP                                             // volta p/ menu de cadastramento
 ENDI
 SEEK M->codigo+M->grau
 aprov_reg_=(FOUND().AND.DELE().AND.!drvvisivel)   // vai aproveitar o registro?
 IF FOUND() .AND. !aprov_reg_                      // pesquisou e achou!
  op_menu=ALTERACAO                                // seta flag de ateracao
  DISPBEGIN()
  INS_GETS()                                       // mostra conteudo do registro
  INFOSIS(.f.)                                     // exibe informacao no rodape' da tela
  DISPEND()
  ALERTA()
  msg="Consultar/alterar|Retornar … inclus„o"      // pergunta se deseja
  op_=DBOX(msg,,,E_MENU,,"REGISTRO J EXISTE")     // alterar o registro
  IF op_ =1                                        // caso afirmativo
   EDIT()                                          // deixa alterar
  ENDI
  op_menu=INCLUSAO
  LOOP                                             // volta para inclusao
 ENDI
 SELE 0
 INS_GET1(INCLUI)                                  // recebe campos
 SELE INSCRITS
 IF LASTKEY()=K_ESC                                // se cancelou
  ALERTA()                                         // avisa que o registro
  DBOX("Registro n„o inclu¡do!",18,,1)             // nao foi incluido, e volta
  LOOP
 ENDI

 #ifdef COM_REDE
  GO BOTT                                          // vamos bloquear o final do
  SKIP                                             // arq para que nehum outro
  BLOREG(0,.5)                                     // usuario possa incluir
  SEEK M->codigo+M->grau                           // se registro foi incluido
  aprov_reg_=(FOUND().AND.DELE().AND.!drvvisivel)  // vai aproveitar o registro?
  IF FOUND() .AND. !aprov_reg_                     // por outro usuario, entao
   BLOREG(0,.5)
   FOR i=1 TO FCOU()
    msg=FIEL(i)
    rep[i]=&msg.
    REPL &msg. WITH M->&msg.
   NEXT
   INS_GET1(FORM_INVERSA)                          // executa formula inversa
   RECA
   FOR i=1 TO FCOU()
    msg=FIEL(i)
    REPL &msg. WITH rep[i]
   NEXT
   ALERTA(4)                                       // beep 4 vezes
   msg="Registro acabou de ser|inclu¡do por outro usu rio!"
   DBOX(msg,,,,,"ATEN€ŽO!")                        // avisa
   SELE INSCRITS
   UNLOCK                                          // libera o registro
   LOOP                                            // e recebe chave novamente
  ENDI
 #endi

 IF aprov_reg_                                     // se vai aproveitar reg excluido

  #ifdef COM_REDE
   BLOREG(0,.5)
  #endi

  RECA                                             // excluido, vamos recupera-lo
 ELSE                                              // caso contrario
  APPEND BLANK                                     // inclui reg em branco no dbf
 ENDI
 FOR i=1 TO FCOU()                                 // para cada campo,
  msg=FIEL(i)                                      // salva o conteudo
  rep[i]=M->&msg.                                  // para repetir
  REPL &msg. WITH rep[i]                           // enche o campo do arquivo
 NEXT

 #ifdef COM_REDE
  UNLOCK                                           // libera o registro e
  COMMIT                                           // forca gravacao
 #else
  IF RECC()-INT(RECC()/20)*20=0                    // a cada 20 registros
   COMMIT                                          // digitados forca gravacao
  ENDI
 #endi

 ult_reg=RECN()                                    // ultimo registro digitado
 IF reg_cop!=NIL                                   // estava na consulta e quis rep o campo
  EXIT                                             // cai fora...
 ENDI
ENDD
GO ult_reg                                         // para o ultimo reg digitado
SETKEY(K_F3,t_f3_)                                 // restaura teclas de funcoes
SETKEY(K_F4,t_f4_)
SET(_SET_DELETED,dele_atu)                            // ecluidos visiveis/invisiveis
SETKEY(K_CTRL_W,ctl_w)
SETKEY(K_CTRL_C,ctl_c)
SETKEY(K_CTRL_R,ctl_r)
RETU


PROC INS_tela     // tela do arquivo INSCRITS
tem_borda=.t.
l_s=Sistema[op_sis,O_TELA,O_LS]           // coordenadas da tela
c_s=Sistema[op_sis,O_TELA,O_CS]
l_i=Sistema[op_sis,O_TELA,O_LI]
c_i=Sistema[op_sis,O_TELA,O_CI]
SETCOLOR(drvtittel)
vr_memo=NOVAPOSI(@l_s,@c_s,@l_i,@c_i)     // pega posicao atual da tela
CAIXA(mold,l_s,c_s,l_i,c_i)               // monta caixa da tela
i=LEN(sistema[op_sis,O_MENS])/2
@ l_s,c_s-1+(c_i-c_s+1)/2-i SAY " "+MAIUSC(sistema[op_sis,O_MENS])+" "
SETCOLOR(drvcortel)
@ l_s+01,c_s+1 SAY " Inscr:                                            (                   )"
@ l_s+02,c_s+1 SAY "ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ"
@ l_s+03,c_s+1 SAY " Nome:                                     Nasc.:"
@ l_s+04,c_s+1 SAY " Est.Civil.:     Sexo:    T.Carˆncia:             CPF:                 "
@ l_s+05,c_s+1 SAY " Vivo/Falec:     Falecto..:            Tipo:      N§ Processo:"
RETU

PROC INS_gets     // mostra variaveis do arquivo INSCRITS
LOCAL getlist := {}, tl_item_
INS_TELA()
SETCOLOR(drvcortel+","+drvcorget+",,,"+corcampo)
IF &(INDEXKEY(0))=IF(EMPT(criterio),"","T")+chv_1
 CRIT("",,"2|3")
 @ l_s+01 ,c_s+09 GET  grau;
                  PICT sistema[op_sis,O_CAMPO,02,O_MASC]
                  CRIT(sistema[op_sis,O_CAMPO,02,O_CRIT],,"1")

 @ l_s+01 ,c_s+10 GET  seq;
                  PICT sistema[op_sis,O_CAMPO,03,O_MASC]

 @ l_s+03 ,c_s+08 GET  nome;
                  PICT sistema[op_sis,O_CAMPO,05,O_MASC]

 @ l_s+03 ,c_s+51 GET  nascto_;
                  PICT sistema[op_sis,O_CAMPO,06,O_MASC]
                  CRIT(sistema[op_sis,O_CAMPO,06,O_CRIT],,"4")

 @ l_s+04 ,c_s+14 GET  estcivil

 @ l_s+04 ,c_s+24 GET  sexo;
                  PICT sistema[op_sis,O_CAMPO,09,O_MASC]

 @ l_s+04 ,c_s+39 GET  tcarencia;
                  PICT sistema[op_sis,O_CAMPO,10,O_MASC]

 @ l_s+04 ,c_s+56 GET  cpf;
                  PICT sistema[op_sis,O_CAMPO,18,O_MASC]

 @ l_s+05 ,c_s+14 GET  vivofalec;
                  PICT sistema[op_sis,O_CAMPO,12,O_MASC]

 @ l_s+05 ,c_s+29 GET  falecto_;
                  PICT sistema[op_sis,O_CAMPO,13,O_MASC]

 @ l_s+05 ,c_s+46 GET  tipo;
                  PICT sistema[op_sis,O_CAMPO,14,O_MASC]

 @ l_s+05 ,c_s+64 GET  procnr;
                  PICT sistema[op_sis,O_CAMPO,15,O_MASC]

ENDI
CLEAR GETS
RETU

PROC INS_get1(tp_mov, excl_rela)     // capta variaveis do arquivo INSCRITS
LOCAL getlist := {}, tl_item_
PRIV  blk_inscrits:=.t.
excl_rela=IF(excl_rela=NIL,.f.,excl_rela)
IF tp_mov=INCLUI
 DO WHILE .t.
  rola_t=.f.
  SET KEY K_ALT_F8 TO ROLATELA
  SETCOLOR(drvcortel+","+drvcorget+",,,"+corcampo)
  CRIT("",,"2|3")
  @ l_s+01 ,c_s+10 GET  seq;
                   PICT sistema[op_sis,O_CAMPO,03,O_MASC]
                   DEFINICAO 3

  @ l_s+03 ,c_s+08 GET  nome;
                   PICT sistema[op_sis,O_CAMPO,05,O_MASC]
                   DEFINICAO 5

  @ l_s+03 ,c_s+51 GET  nascto_;
                   PICT sistema[op_sis,O_CAMPO,06,O_MASC]
                   DEFINICAO 6
                   MOSTRA sistema[op_sis,O_FORMULA,4]

  @ l_s+04 ,c_s+14 GET  estcivil
                   DEFINICAO 7

  @ l_s+04 ,c_s+24 GET  sexo;
                   PICT sistema[op_sis,O_CAMPO,09,O_MASC]
                   DEFINICAO 9

  @ l_s+04 ,c_s+39 GET  tcarencia;
                   PICT sistema[op_sis,O_CAMPO,10,O_MASC]
                   DEFINICAO 10

  @ l_s+04 ,c_s+56 GET  cpf;
                   PICT sistema[op_sis,O_CAMPO,18,O_MASC]
                   DEFINICAO 18

  @ l_s+05 ,c_s+14 GET  vivofalec;
                   PICT sistema[op_sis,O_CAMPO,12,O_MASC]
                   DEFINICAO 12

  @ l_s+05 ,c_s+29 GET  falecto_;
                   PICT sistema[op_sis,O_CAMPO,13,O_MASC]
                   DEFINICAO 13

  @ l_s+05 ,c_s+46 GET  tipo;
                   PICT sistema[op_sis,O_CAMPO,14,O_MASC]
                   DEFINICAO 14

  @ l_s+05 ,c_s+64 GET  procnr;
                   PICT sistema[op_sis,O_CAMPO,15,O_MASC]
                   DEFINICAO 15

  READ
  SET KEY K_ALT_F8 TO
  IF rola_t
   ROLATELA()
   LOOP
  ENDI
  IF LASTKEY()!=K_ESC .AND. drvincl .AND. op_menu=INCLUSAO
   IF !CONFINCL()
    LOOP
   ENDI
  ENDI
  EXIT
 ENDD
ENDI
IF tp_mov=EXCLUI .OR. tp_mov=FORM_INVERSA

 #ifdef COM_REDE
  IF !EMPTY(ALIAS())
   REPL lancto_ WITH date()
  ENDI
  IF ehtitular=[S]
   REPBLO('GRUPOS->titular',{||[   ]})
  ENDI
  IF vivofalec=[V]
   REPBLO('GRUPOS->particv',{||GRUPOS->particv - 1})
  ENDI
  IF vivofalec=[F]
   REPBLO('GRUPOS->particf',{||GRUPOS->particf - 1})
  ENDI
  IF grau=[8]
   REPBLO('GRUPOS->nrdepend',{||GRUPOS->nrdepend - 1})
  ENDI
  IF !excl_rela
   IF !EMPTY(ALIAS())
    REPL flag_excl WITH '*'
   ENDI
  ENDI
 #else
  IF !EMPTY(ALIAS())
   REPL lancto_ WITH date()
  ENDI
  IF ehtitular=[S]
   REPL GRUPOS->titular WITH [   ]
  ENDI
  IF vivofalec=[V]
   REPL GRUPOS->particv WITH GRUPOS->particv - 1
  ENDI
  IF vivofalec=[F]
   REPL GRUPOS->particf WITH GRUPOS->particf - 1
  ENDI
  IF grau=[8]
   REPL GRUPOS->nrdepend WITH GRUPOS->nrdepend - 1
  ENDI
  IF !excl_rela
   IF !EMPTY(ALIAS())
    REPL flag_excl WITH '*'
   ENDI
  ENDI
 #endi

 IF !EMPTY(ALIAS())
  DELE
 ENDI
 IF op_menu!=PROJECOES .AND. op_menu!=TEL_EXTRA
  REIMPTEL()
 ENDI
ELSEIF tp_mov=INCLUI .OR. tp_mov=RECUPERA .OR. tp_mov=FORM_DIRETA
 IF (op_menu=INCLUSAO .AND. LASTKEY()!=K_ESC) .OR. op_menu!=INCLUSAO
  IF tp_mov=RECUPERA .AND. op_menu!=INCLUSAO .AND. (GRUPOS->(DELE()))
   msg="|"+sistema[EVAL(qualsis,"GRUPOS"),O_MENU]
   ALERTA(2)
   DBOX("Registro exclu¡do em:"+msg+"|*",,,,,"IMPOSS¡VEL RECUPERAR!")
  ELSE
    IF op_menu=INCLUSAO
     lancto_=date()
    ELSE
     REPL lancto_ WITH date()
    ENDI

   #ifdef COM_REDE
    IF ehtitular=[S]
     REPBLO('GRUPOS->titular',{||grau+STRZERO(seq,2)})
    ENDI
    IF vivofalec=[V]
     REPBLO('GRUPOS->particv',{||GRUPOS->particv + 1})
    ENDI
    IF vivofalec=[F]
     REPBLO('GRUPOS->particf',{||GRUPOS->particf + 1})
    ENDI
    IF grau=[8]
     REPBLO('GRUPOS->nrdepend',{||GRUPOS->nrdepend + 1})
    ENDI
    IF !excl_rela
     IF op_menu=INCLUSAO
      flag_excl=' '
     ELSE
      REPL flag_excl WITH ' '
     ENDI
    ENDI
   #else
    IF op_menu=INCLUSAO
     lancto_=date()
    ELSE
     REPL lancto_ WITH date()
    ENDI
    IF ehtitular=[S]
     REPL GRUPOS->titular WITH grau+STRZERO(seq,2)
    ENDI
    IF vivofalec=[V]
     REPL GRUPOS->particv WITH GRUPOS->particv + 1
    ENDI
    IF vivofalec=[F]
     REPL GRUPOS->particf WITH GRUPOS->particf + 1
    ENDI
    IF grau=[8]
     REPL GRUPOS->nrdepend WITH GRUPOS->nrdepend + 1
    ENDI
    IF !excl_rela
     IF op_menu=INCLUSAO
      flag_excl=' '
     ELSE
      REPL flag_excl WITH ' '
     ENDI
    ENDI
   #endi

   IF op_menu!=INCLUSAO
    RECA
   ENDI
   IF (tp_mov=INCLUI .OR. tp_mov=RECUPERA) .AND. op_menu!=PROJECOES .AND. op_menu!=TEL_EXTRA
    REIMPTEL()
   ENDI
  ENDI
 ENDI
ENDI
RETU

* \\ Final de GRUPOS.PRG
/*
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
 \ Empresa.: PresServ Inform tica - Limeira (019)452.6623
 \ Programa: GRUPOS.PRG
 \ Data....: 12-11-03
 \ Sistema.: Administradora - RECEP€„O
 \ Funcao..: Gerenciador do subsistema de consulta contratos
 \ Analista: Ademilson Pedro Bom
 \ Criacao.: GAS-Pro v4.0n
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/

#include "adrbig.ch"    // inicializa constantes manifestas

PARA lin_menu,col_menu
PRIV op_sis, tela_fundo:=SAVESCREEN(0,0,MAXROW(),79), l_s, c_s, l_i, c_i, l_a

op_sis=EVAL(qualsis,"GRUPOS")
IF nivelop<sistema[op_sis,O_OUTROS,O_NIVEL]        // se usuario nao tem permissao,
 ALERTA()                                          // entao, beep, beep, beep
 DBOX(msg_auto,,,3)                                // lamentamos e
 RETU                                              // retornamos ao menu
ENDI
cn:=fgrep :=.f.

#ifdef COM_LOCK
 IF LEN(pr_ok)>0                                   // se a protecao acusou
  ? pr_ok                                          // erro, avisa e
  QUIT                                             // encerra a aplicacao
 ENDI
#endi

t_fundo=SAVESCREEN(0,0,MAXROW(),79)                // salva tela do fundo
op_cad=1
DO WHIL op_cad!=0
 criterio=""
 RESTSCREEN(0,0,MAXROW(),79,t_fundo)               // restaura tela do fundo
 cod_sos=5 ; cn=.f.
 CLEA TYPEAHEAD                                    // limpa o buffer do teclado
 fgrep=.f.
 SET KEY K_F3 TO                                   // retira das teclas F3 e F4 as
 SET KEY K_F4 TO                                   // funcoes de repeticao e confirmacao
 msg="Inclus„o~1|"+;
     "Manuten‡„o~2|"+;
     "Consulta~3|"+;
     "Consulta Inscritos~4|"+;
     "Consulta Taxas~5"
 op_cad=DBOX(msg,lin_menu,col_menu,E_MENU,NAO_APAGA,MAIUSC(sistema[op_sis,O_MENU]),,,op_cad)
 IF op_cad!=0                                      // se escolheu uma opcao
  Tela_fundo=SAVESCREEN(0,0,MAXROW(),79)           // salva a tela para ROLATELA()
  PARAMETROS(dbfparam)
  SELE A                                           // e abre o arquivo e seus indices

  #ifdef COM_REDE
   IF !USEARQ(sistema[op_sis,O_ARQUI,O_NOME],.f.,20,1)
                                                   // se falhou a abertura do
    RETU                                           // arquivo volta ao menu anterior
   ENDI
  #else
   USEARQ(sistema[op_sis,O_ARQUI,O_NOME])
  #endi

  SET KEY K_F9 TO veoutros                         // habilita consulta em outros arquivos
 ENDI
 DO CASE
  CASE op_cad=01                                   // inclus„o
   op_menu=INCLUSAO
   IF AT("D",exrot[op_sis])=0                      // se usuario pode fazer inclusao
    GRU_INCL()                                     // neste arquivo chama prg de inclusao
   ELSE                                            // caso contrario vamos avisar que
    ALERTA()                                       // ele nao tem permissao para isto
    DBOX(msg_auto,,,3)
   ENDI

  CASE op_cad=02                                   // manuten‡„o
   op_menu=ALTERACAO
   cod_sos=7
   EDIT()

  CASE op_cad=03                                   // consulta
   op_menu=PROJECOES
   cod_sos=8
   EDITA(03,03,MAXROW()-2,77)

  CASE op_cad=04                                   // consulta inscritos
   cod_sos=8
   CTAINSC()

  CASE op_cad=05                                   // consulta taxas
   cod_sos=8
   CTXAS()

 ENDC
 SET KEY K_F9 TO                                   // F9 nao mais consultara outros arquivos
 CLOS ALL                                          // fecha todos arquivos abertos
ENDD
RETU

PROC GRU_incl(reg_cop)  // inclusao no arquivo GRUPOS
LOCAL getlist:={}, cabem:=1, rep:=ARRAY(FCOU()), ult_reg:=RECN(), cond_incl_,;
      ctl_r, ctl_c, ctl_w, t_f3_, t_f4_, dele_atu:=SET(_SET_DELETED,.f.)
PRIV op_menu:=INCLUSAO, tem_borda, criterio:="", cpord:=""
cond_incl_={||1=3}                                 // condicao de inclusao de registros
IF !EVAL(cond_incl_)                               // se nao pode incluir
 ALERTA(2)                                         // avisa o motivo
 DBOX("Mantido pelo sistema de Plano",,,4,,"ATEN€ŽO, "+usuario)
 RETU                                              // e retorna
ENDI
atend1:=atend2:=space(15)
FOR i=1 TO FCOU()                                  // cria/declara privadas as
 msg=FIEL(i)                                       // variaveis de memoria com
 PRIV &msg.                                        // o mesmo nome dos campos
NEXT                                               // do arquivo
IF reg_cop!=NIL                                    // quer repetir todo o reg atual
 FOR i=1 TO FCOU()                                 // para cada campo,
  msg=FIEL(i)                                      // salva o conteudo
  rep[i]=&msg.                                     // para repetir
 NEXT
ELSE
 AFILL(rep,"")                                     // eche com valor vazio
ENDI
t_f3_=SETKEY(K_F3,{||rep()})                       // repeticao reg anterior
t_f4_=SETKEY(K_F4,{||conf()})                      // confirma campos com ENTER
ctl_w=SETKEY(K_CTRL_W,{||nadafaz()})               // enganando o CA-Clipper...
ctl_c=SETKEY(K_CTRL_C,{||nadafaz()})
ctl_r=SETKEY(K_CTRL_R,{||nadafaz()})
DO WHIL cabem>0
 cod_sos=6
 rola_t=.f.                                        // flag se quer rolar a tela
 SELE GRUPOS
 GO BOTT                                           // forca o
 SKIP                                              // final do arquivo
 
 /*
    cria variaveis de memoria identicas as de arquivo, para inclusao
    de registros
 */
 atend1:=atend2:=space(15)
 FOR i=1 TO FCOU()
  msg=FIEL(i)
  M->&msg.=IF((fgrep .OR. reg_cop!=NIL).AND.!EMPT(rep[1]),rep[i],&msg.)
 NEXT
 DISPBEGIN()                                       // apresenta a tela de uma vez so
 GRU_GETS()
 IMPRELA()
 GRU_TELA()
 INFOSIS(.t.)                                      // exibe informacao no rodape' da tela
 DISPEND()
 IF !EVAL(cond_incl_)
  EXIT
 ENDI
 cabem=DISKSPACE(;
          IF(;
             LEN(sistema[op_sis,O_ARQUI,O_DIR_DBF])<2.OR.sistema[op_sis,O_ARQUI,O_DIR_DBF]="\",;
             0,;
             ASC(sistema[op_sis,O_ARQUI,O_DIR_DBF])-64;
          );
       )
 cabem=INT((cabem-2048)/GRUPOS->(RECSIZE()))
 IF cabem<1                                        // mais nenhum!!!
  ALERTA()
  msg="Verifique ESPA€O EM DISCO, "+usuario
  DBOX(msg,,,,,"INCLUSŽO INTERROMPIDA!")           // vamos parar por aqui!
  EXIT
 ENDI
 SELE 0                                            // torna visiveis variaveis de memoria
 SETCOLOR(drvcortel+","+drvcorget+",,,"+corcampo)
 SET KEY K_ALT_F8 TO ROLATELA
 
 /*
    recebe chaves do arquivo de indice basico
 */
 @ l_s+01 ,c_s+10 GET  codigo;
                  PICT sistema[op_sis,O_CAMPO,01,O_MASC]
                  DEFINICAO 1

 READ
 SET KEY K_ALT_F8 TO
 IF rola_t
  ROLATELA()
  LOOP
 ENDI
 SELE GRUPOS
 IF LASTKEY()=K_ESC                                // cancelou ou chave em branco
  cabem=0                                          // prepara saida da inclusao
  LOOP                                             // volta p/ menu de cadastramento
 ENDI
 SEEK M->codigo
 aprov_reg_=(FOUND().AND.DELE().AND.!drvvisivel)   // vai aproveitar o registro?
 IF FOUND() .AND. !aprov_reg_                      // pesquisou e achou!
  op_menu=ALTERACAO                                // seta flag de ateracao
  DISPBEGIN()
  GRU_GETS()
  IMPRELA()
  GRU_GETS()                                       // mostra conteudo do registro
  INFOSIS(.f.)                                     // exibe informacao no rodape' da tela
  DISPEND()
  ALERTA()
  msg="Consultar/alterar|Retornar … inclus„o"      // pergunta se deseja
  op_=DBOX(msg,,,E_MENU,,"REGISTRO J EXISTE")     // alterar o registro
  IF op_ =1                                        // caso afirmativo
   EDIT()                                          // deixa alterar
  ENDI
  op_menu=INCLUSAO
  LOOP                                             // volta para inclusao
 ENDI
 SELE 0
 GRU_GET1(INCLUI)                                  // recebe campos
 SELE GRUPOS
 IF LASTKEY()=K_ESC                                // se cancelou
  ALERTA()                                         // avisa que o registro
  DBOX("Registro n„o inclu¡do!",18,,1)             // nao foi incluido, e volta
  LOOP
 ENDI

 #ifdef COM_REDE
  GO BOTT                                          // vamos bloquear o final do
  SKIP                                             // arq para que nehum outro
  BLOREG(0,.5)                                     // usuario possa incluir
  SEEK M->codigo                                   // se registro foi incluido
  aprov_reg_=(FOUND().AND.DELE().AND.!drvvisivel)  // vai aproveitar o registro?
  IF FOUND() .AND. !aprov_reg_                     // por outro usuario, entao
   BLOREG(0,.5)
   FOR i=1 TO FCOU()
    msg=FIEL(i)
    rep[i]=&msg.
    REPL &msg. WITH M->&msg.
   NEXT
   GRU_GET1(FORM_INVERSA)                          // executa formula inversa
   RECA
   FOR i=1 TO FCOU()
    msg=FIEL(i)
    REPL &msg. WITH rep[i]
   NEXT
   ALERTA(4)                                       // beep 4 vezes
   msg="Registro acabou de ser|inclu¡do por outro usu rio!"
   DBOX(msg,,,,,"ATEN€ŽO!")                        // avisa
   SELE GRUPOS
   UNLOCK                                          // libera o registro
   LOOP                                            // e recebe chave novamente
  ENDI
 #endi

 IF aprov_reg_                                     // se vai aproveitar reg excluido

  #ifdef COM_REDE
   BLOREG(0,.5)
  #endi

  RECA                                             // excluido, vamos recupera-lo
 ELSE                                              // caso contrario
  APPEND BLANK                                     // inclui reg em branco no dbf
 ENDI
 FOR i=1 TO FCOU()                                 // para cada campo,
  msg=FIEL(i)                                      // salva o conteudo
  rep[i]=M->&msg.                                  // para repetir
  REPL &msg. WITH rep[i]                           // enche o campo do arquivo
 NEXT

 #ifdef COM_REDE
  UNLOCK                                           // libera o registro e
  COMMIT                                           // forca gravacao
 #else
  IF RECC()-INT(RECC()/20)*20=0                    // a cada 20 registros
   COMMIT                                          // digitados forca gravacao
  ENDI
 #endi

 ult_reg=RECN()                                    // ultimo registro digitado
 IF sistema[EVAL(qualsis,"TAXAS"),O_OUTROS,O_NIVEL]<5
  SUBNIVEL("TAXAS")
 ENDI
 IF sistema[EVAL(qualsis,"ECOB"),O_OUTROS,O_NIVEL]<5
  SUBNIVEL("ECOB")
 ENDI
 IF sistema[EVAL(qualsis,"INSCRITS"),O_OUTROS,O_NIVEL]<5
  SUBNIVEL("INSCRITS")
 ENDI
 IF reg_cop!=NIL                                   // estava na consulta e quis rep o campo
  EXIT                                             // cai fora...
 ENDI
ENDD
GO ult_reg                                         // para o ultimo reg digitado
SETKEY(K_F3,t_f3_)                                 // restaura teclas de funcoes
SETKEY(K_F4,t_f4_)
SET(_SET_DELETED,dele_atu)                            // ecluidos visiveis/invisiveis
SETKEY(K_CTRL_W,ctl_w)
SETKEY(K_CTRL_C,ctl_c)
SETKEY(K_CTRL_R,ctl_r)
RETU


PROC GRU_tela     // tela do arquivo GRUPOS
tem_borda=.t.
l_s=Sistema[op_sis,O_TELA,O_LS]           // coordenadas da tela
c_s=Sistema[op_sis,O_TELA,O_CS]
l_i=Sistema[op_sis,O_TELA,O_LI]
c_i=Sistema[op_sis,O_TELA,O_CI]
SETCOLOR(drvtittel)
vr_memo=NOVAPOSI(@l_s,@c_s,@l_i,@c_i)     // pega posicao atual da tela
CAIXA(mold,l_s,c_s,l_i,c_i)               // monta caixa da tela
i=LEN(sistema[op_sis,O_MENS])/2
@ l_s,c_s-1+(c_i-c_s+1)/2-i SAY " "+MAIUSC(sistema[op_sis,O_MENS])+" "
SETCOLOR(drvcortel)
@ l_s+01,c_s+1 SAY " Codigo:                                         Situa‡„o:"
@ l_s+02,c_s+1 SAY "  ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ Dados Pessoais ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ"
@ l_s+03,c_s+1 SAY " Nome..:                                     Nasc.:"
@ l_s+04,c_s+1 SAY " ECivil:                  CIC:               RG...:"
@ l_s+05,c_s+1 SAY " Ender.:                                     Bairr:"
@ l_s+06,c_s+1 SAY " Cidade:                           UF.:      CEP..:"
@ l_s+07,c_s+1 SAY " Natur.:                           Relig:"
@ l_s+08,c_s+1 SAY " Contato                           Tel:"
@ l_s+09,c_s+1 SAY " Categor.:     Carnˆ:      F.Pgto:"
@ l_s+10,c_s+1 SAY " Admiss„o:             T.Carˆncia:              Sai Taxas.:"
@ l_s+11,c_s+1 SAY " Vendedor:                                      Dia Pgto..:"
@ l_s+12,c_s+1 SAY " Regi„o..:                                      Observa‡„o:"
@ l_s+13,c_s+1 SAY " Cobrador:                                      Renova‡„o.:"
@ l_s+14,c_s+1 SAY " Funerais:       Circ.Inic:       Ult.:        Emit:      Baix:"
@ l_s+15,c_s+1 SAY " Atendimento.1:                      2:"
@ l_s+16,c_s+1 SAY " Participantes: Vivos:    Falecidos:    Dependentes:"
@ l_s+17,c_s+1 SAY " Ult.Altera‡„o:                       Ult.Impress„o:"
RETU

PROC GRU_gets     // mostra variaveis do arquivo GRUPOS
LOCAL getlist := {}, t_f7_
GRU_TELA()
SETCOLOR(drvcortel+","+drvcorget+",,,"+corcampo)
PTAB('',[ARQGRUP],1)
PTAB(TIPCONT,'CLASSES',1)
PTAB(VENDEDOR,'COBRADOR',1)
PTAB(REGIAO,'REGIAO',1)
PTAB(COBRADOR,'COBRADOR',1)
PTAB(IIF(CLASSES->PRIOR=[S],M->MGRUPVIP,GRUPO)+ULTCIRC,'CIRCULAR',1)
CRIT("",,"2|3|6|9|10|11|12|13")
@ l_s+01 ,c_s+10 GET  codigo;
                 PICT sistema[op_sis,O_CAMPO,01,O_MASC]

@ l_s+01 ,c_s+60 GET  situacao;
                 PICT sistema[op_sis,O_CAMPO,03,O_MASC]
                 CRIT(sistema[op_sis,O_CAMPO,03,O_CRIT],,"1")

@ l_s+03 ,c_s+10 GET  nome;
                 PICT sistema[op_sis,O_CAMPO,04,O_MASC]

@ l_s+03 ,c_s+53 GET  nascto_;
                 PICT sistema[op_sis,O_CAMPO,05,O_MASC]
                 CRIT(sistema[op_sis,O_CAMPO,05,O_CRIT],,"16")

@ l_s+04 ,c_s+10 GET  estcivil;
                 PICT sistema[op_sis,O_CAMPO,06,O_MASC]
                 CRIT(sistema[op_sis,O_CAMPO,06,O_CRIT],,"8")

@ l_s+04 ,c_s+31 GET  cpf;
                 PICT sistema[op_sis,O_CAMPO,07,O_MASC]

@ l_s+04 ,c_s+53 GET  rg;
                 PICT sistema[op_sis,O_CAMPO,08,O_MASC]

@ l_s+05 ,c_s+10 GET  endereco;
                 PICT sistema[op_sis,O_CAMPO,09,O_MASC]

@ l_s+05 ,c_s+53 GET  bairro;
                 PICT sistema[op_sis,O_CAMPO,10,O_MASC]

@ l_s+06 ,c_s+10 GET  cidade;
                 PICT sistema[op_sis,O_CAMPO,11,O_MASC]

@ l_s+06 ,c_s+41 GET  uf;
                 PICT sistema[op_sis,O_CAMPO,12,O_MASC]

@ l_s+06 ,c_s+53 GET  cep;
                 PICT sistema[op_sis,O_CAMPO,13,O_MASC]

@ l_s+07 ,c_s+10 GET  natural;
                 PICT sistema[op_sis,O_CAMPO,14,O_MASC]

@ l_s+07 ,c_s+43 GET  relig;
                 PICT sistema[op_sis,O_CAMPO,15,O_MASC]

@ l_s+08 ,c_s+10 GET  contato;
                 PICT sistema[op_sis,O_CAMPO,16,O_MASC]

@ l_s+08 ,c_s+41 GET  telefone;
                 PICT sistema[op_sis,O_CAMPO,17,O_MASC]

@ l_s+09 ,c_s+12 GET  tipcont;
                 PICT sistema[op_sis,O_CAMPO,18,O_MASC]

@ l_s+09 ,c_s+23 GET  vlcarne

@ l_s+09 ,c_s+36 GET  formapgto;
                 PICT sistema[op_sis,O_CAMPO,20,O_MASC]
                 CRIT(sistema[op_sis,O_CAMPO,20,O_CRIT],,"15")

@ l_s+10 ,c_s+12 GET  admissao;
                 PICT sistema[op_sis,O_CAMPO,22,O_MASC]

@ l_s+10 ,c_s+36 GET  tcarencia;
                 PICT sistema[op_sis,O_CAMPO,23,O_MASC]

@ l_s+10 ,c_s+61 GET  saitxa;
                 PICT sistema[op_sis,O_CAMPO,24,O_MASC]

@ l_s+11 ,c_s+61 GET  diapgto;
                 PICT sistema[op_sis,O_CAMPO,25,O_MASC]

@ l_s+11 ,c_s+12 GET  vendedor;
                 PICT sistema[op_sis,O_CAMPO,26,O_MASC]

@ l_s+12 ,c_s+12 GET  regiao;
                 PICT sistema[op_sis,O_CAMPO,27,O_MASC]
                 CRIT(sistema[op_sis,O_CAMPO,27,O_CRIT],,"7")

@ l_s+13 ,c_s+12 GET  cobrador;
                 PICT sistema[op_sis,O_CAMPO,28,O_MASC]
                 CRIT(sistema[op_sis,O_CAMPO,28,O_CRIT],,"4|5")

@ l_s+12 ,c_s+61 SAY "{M} "

@ l_s+13 ,c_s+61 GET  renovar;
                 PICT sistema[op_sis,O_CAMPO,30,O_MASC]

@ l_s+14 ,c_s+12 GET  funerais;
                 PICT sistema[op_sis,O_CAMPO,31,O_MASC]

@ l_s+14 ,c_s+29 GET  circinic;
                 PICT sistema[op_sis,O_CAMPO,32,O_MASC]

@ l_s+14 ,c_s+41 GET  ultcirc;
                 PICT sistema[op_sis,O_CAMPO,33,O_MASC]

@ l_s+14 ,c_s+54 GET  qtcircs;
                 PICT sistema[op_sis,O_CAMPO,34,O_MASC]

@ l_s+14 ,c_s+65 GET  qtcircpg;
                 PICT sistema[op_sis,O_CAMPO,35,O_MASC]

@ l_s+15 ,c_s+16 GET  atend1;
                 PICT sistema[op_sis,O_CAMPO,45,O_MASC]

CLEAR GETS
RETU

PROC GRU_get1(tp_mov)     // capta variaveis do arquivo GRUPOS
LOCAL getlist := {}, t_f7_
PRIV  blk_grupos:=.t.

IF tp_mov=INCLUI
 DO WHILE .t.
  rola_t=.f.
  memo29:="{F7}"
  t_f7_=SETKEY(K_F7,{||GRU_memo()})
  SET KEY K_ALT_F8 TO ROLATELA
  SETCOLOR(drvcortel+","+drvcorget+",,,"+corcampo)
  CRIT("",,"2|3|6|9|10|11|12|13")
  @ l_s+01 ,c_s+60 GET  situacao;
                   PICT sistema[op_sis,O_CAMPO,03,O_MASC]
                   DEFINICAO 3
                   MOSTRA sistema[op_sis,O_FORMULA,1]

  @ l_s+03 ,c_s+10 GET  nome;
                   PICT sistema[op_sis,O_CAMPO,04,O_MASC]
                   DEFINICAO 4

  @ l_s+03 ,c_s+53 GET  nascto_;
                   PICT sistema[op_sis,O_CAMPO,05,O_MASC]
                   DEFINICAO 5
                   MOSTRA sistema[op_sis,O_FORMULA,16]

  @ l_s+04 ,c_s+10 GET  estcivil;
                   PICT sistema[op_sis,O_CAMPO,06,O_MASC]
                   DEFINICAO 6
                   MOSTRA sistema[op_sis,O_FORMULA,8]

  @ l_s+04 ,c_s+31 GET  cpf;
                   PICT sistema[op_sis,O_CAMPO,07,O_MASC]
                   DEFINICAO 7

  @ l_s+04 ,c_s+53 GET  rg;
                   PICT sistema[op_sis,O_CAMPO,08,O_MASC]
                   DEFINICAO 8

  @ l_s+05 ,c_s+10 GET  endereco;
                   PICT sistema[op_sis,O_CAMPO,09,O_MASC]
                   DEFINICAO 9

  @ l_s+05 ,c_s+53 GET  bairro;
                   PICT sistema[op_sis,O_CAMPO,10,O_MASC]
                   DEFINICAO 10

  @ l_s+06 ,c_s+10 GET  cidade;
                   PICT sistema[op_sis,O_CAMPO,11,O_MASC]
                   DEFINICAO 11

  @ l_s+06 ,c_s+41 GET  uf;
                   PICT sistema[op_sis,O_CAMPO,12,O_MASC]
                   DEFINICAO 12

  @ l_s+06 ,c_s+53 GET  cep;
                   PICT sistema[op_sis,O_CAMPO,13,O_MASC]
                   DEFINICAO 13

  @ l_s+07 ,c_s+10 GET  natural;
                   PICT sistema[op_sis,O_CAMPO,14,O_MASC]
                   DEFINICAO 14

  @ l_s+07 ,c_s+43 GET  relig;
                   PICT sistema[op_sis,O_CAMPO,15,O_MASC]
                   DEFINICAO 15

  @ l_s+08 ,c_s+10 GET  contato;
                   PICT sistema[op_sis,O_CAMPO,16,O_MASC]
                   DEFINICAO 16

  @ l_s+08 ,c_s+41 GET  telefone;
                   PICT sistema[op_sis,O_CAMPO,17,O_MASC]
                   DEFINICAO 17

  @ l_s+09 ,c_s+12 GET  tipcont;
                   PICT sistema[op_sis,O_CAMPO,18,O_MASC]
                   DEFINICAO 18

  @ l_s+09 ,c_s+23 GET  vlcarne
                   DEFINICAO 19

  @ l_s+09 ,c_s+36 GET  formapgto;
                   PICT sistema[op_sis,O_CAMPO,20,O_MASC]
                   DEFINICAO 20
                   MOSTRA sistema[op_sis,O_FORMULA,15]

  @ l_s+10 ,c_s+12 GET  admissao;
                   PICT sistema[op_sis,O_CAMPO,22,O_MASC]
                   DEFINICAO 22

  @ l_s+10 ,c_s+36 GET  tcarencia;
                   PICT sistema[op_sis,O_CAMPO,23,O_MASC]
                   DEFINICAO 23

  @ l_s+10 ,c_s+61 GET  saitxa;
                   PICT sistema[op_sis,O_CAMPO,24,O_MASC]
                   DEFINICAO 24

  @ l_s+11 ,c_s+61 GET  diapgto;
                   PICT sistema[op_sis,O_CAMPO,25,O_MASC]
                   DEFINICAO 25

  @ l_s+11 ,c_s+12 GET  vendedor;
                   PICT sistema[op_sis,O_CAMPO,26,O_MASC]
                   DEFINICAO 26

  @ l_s+12 ,c_s+12 GET  regiao;
                   PICT sistema[op_sis,O_CAMPO,27,O_MASC]
                   DEFINICAO 27
                   MOSTRA sistema[op_sis,O_FORMULA,7]

  @ l_s+13 ,c_s+12 GET  cobrador;
                   PICT sistema[op_sis,O_CAMPO,28,O_MASC]
                   DEFINICAO 28
                   MOSTRA sistema[op_sis,O_FORMULA,4]
                   MOSTRA sistema[op_sis,O_FORMULA,5]

  @ l_s+12 ,c_s+61 GET  memo29;
                   PICT "@!"
                   DEFINICAO 29

  @ l_s+13 ,c_s+61 GET  renovar;
                   PICT sistema[op_sis,O_CAMPO,30,O_MASC]
                   DEFINICAO 30

  @ l_s+14 ,c_s+12 GET  funerais;
                   PICT sistema[op_sis,O_CAMPO,31,O_MASC]
                   DEFINICAO 31

  @ l_s+14 ,c_s+29 GET  circinic;
                   PICT sistema[op_sis,O_CAMPO,32,O_MASC]
                   DEFINICAO 32

  @ l_s+14 ,c_s+41 GET  ultcirc;
                   PICT sistema[op_sis,O_CAMPO,33,O_MASC]
                   DEFINICAO 33

  @ l_s+14 ,c_s+54 GET  qtcircs;
                   PICT sistema[op_sis,O_CAMPO,34,O_MASC]
                   DEFINICAO 34

  @ l_s+14 ,c_s+65 GET  qtcircpg;
                   PICT sistema[op_sis,O_CAMPO,35,O_MASC]
                   DEFINICAO 35

  @ l_s+15 ,c_s+16 GET  atend1;
                   PICT sistema[op_sis,O_CAMPO,45,O_MASC]
                   DEFINICAO 45
  READ
  SETKEY(K_F7,t_f7_)
  SET KEY K_ALT_F8 TO
  IF rola_t
   ROLATELA()
   LOOP
  ENDI
  IF LASTKEY()!=K_ESC .AND. drvincl .AND. op_menu=INCLUSAO
   IF !CONFINCL()
    LOOP
   ENDI
  ENDI
  EXIT
 ENDD
ENDI
PTAB('',[ARQGRUP],1)
PTAB(TIPCONT,'CLASSES',1)
PTAB(VENDEDOR,'COBRADOR',1)
PTAB(REGIAO,'REGIAO',1)
PTAB(COBRADOR,'COBRADOR',1)
PTAB(IIF(CLASSES->PRIOR=[S],M->MGRUPVIP,GRUPO)+ULTCIRC,'CIRCULAR',1)
IF tp_mov=EXCLUI .OR. tp_mov=FORM_INVERSA

 #ifdef COM_REDE
  REPBLO('ARQGRUP->contrat',{||ARQGRUP->contrat - 1})
 #else
  REPL ARQGRUP->contrat WITH ARQGRUP->contrat - 1
 #endi

 INTREF(FORM_INVERSA)
 IF !EMPTY(ALIAS())
  DELE
 ENDI
ELSEIF tp_mov=INCLUI .OR. tp_mov=RECUPERA .OR. tp_mov=FORM_DIRETA
 IF (op_menu=INCLUSAO .AND. LASTKEY()!=K_ESC) .OR. op_menu!=INCLUSAO

  #ifdef COM_REDE
   REPBLO('ARQGRUP->contrat',{||ARQGRUP->contrat + 1})
   IF op_menu=INCLUSAO
    ender_=DATE()
   ELSE
    REPL ender_ WITH DATE()
   ENDI
   IF op_menu=INCLUSAO
    ultend=M->usuario
   ELSE
    REPL ultend WITH M->usuario
   ENDI
  #else
   REPL ARQGRUP->contrat WITH ARQGRUP->contrat + 1
   IF op_menu=INCLUSAO
    ender_=DATE()
   ELSE
    REPL ender_ WITH DATE()
   ENDI
   IF op_menu=INCLUSAO
    ultend=M->usuario
   ELSE
    REPL ultend WITH M->usuario
   ENDI
  #endi

  IF op_menu!=INCLUSAO
   RECA
   INTREF(FORM_DIRETA)
  ENDI
 ENDI
ENDI
RETU

PROC GRU_MEMO
IF READVAR()="MEMO29"
 EDIMEMO("obs",sistema[op_sis,O_CAMPO,29,O_TITU],14,2,23,38)
ENDI
RETU

PROC TAX_incl(reg_cop)  // inclusao no arquivo TAXAS
LOCAL getlist:={}, cabem:=1, rep:=ARRAY(FCOU()), ult_reg:=RECN(),;
      ctl_r, ctl_c, t_f3_, t_f4_, l_max, dele_atu:=SET(_SET_DELETED,.f.)
PRIV op_menu:=INCLUSAO, op_sis, l_s, c_s, l_i, c_i, cod_sos, tem_borda, criterio:="", cpord:="", l_a
op_sis=EVAL(qualsis,"TAXAS")
IF AT("D",exrot[op_sis])>0
 RETU
ENDI
FOR i=1 TO FCOU()                                  // cria/declara privadas as
 msg=FIEL(i)                                       // variaveis de memoria com
 PRIV &msg.                                        // o mesmo nome dos campos
NEXT                                               // do arquivo
IF reg_cop!=NIL                                    // quer repetir todo o reg atual
 FOR i=1 TO FCOU()                                 // para cada campo,
  msg=FIEL(i)                                      // salva o conteudo
  rep[i]=&msg.                                     // para repetir
 NEXT
ELSE
 AFILL(rep,"")                                     // eche com valor vazio
ENDI
t_f3_=SETKEY(K_F3,{||rep()})                       // repeticao reg anterior
t_f4_=SETKEY(K_F4,{||conf()})                      // confirma campos com ENTER
ctl_w=SETKEY(K_CTRL_W,{||nadafaz()})               // enganando o CA-Clipper...
ctl_c=SETKEY(K_CTRL_C,{||nadafaz()})
ctl_r=SETKEY(K_CTRL_R,{||nadafaz()})
DISPBEGIN()                                        // monta tela na pagina de traz
IMPRELA()                                          // imp telas do pai
TAX_TELA()                                         // imp tela para inclusao
INFOSIS(.t.)                                       // exibe informacao no rodape' da tela
l_a=Sistema[op_sis,O_TELA,O_SCROLL]
DISPEND()                                          // apresenta tela de uma vez so
DO WHIL cabem>0
 cod_sos=6
 rola_t=.f.                                        // flag se quer rolar a tela
 SELE TAXAS
 GO BOTT                                           // forca o
 SKIP                                              // final do arquivo
 
 /*
    cria variaveis de memoria identicas as de arquivo, para inclusao
    de registros
 */
 FOR i=1 TO FCOU()
  msg=FIEL(i)
  M->&msg.=IF((fgrep .OR. reg_cop!=NIL).AND.!EMPT(rep[1]),rep[i],&msg.)
 NEXT
 
 /*
    inicializa campos de relacionamentos do com os campos do arquivo
    superior (pai)
 */
 FOR i=1 TO LEN(sistema[op_sis,O_CPRELA])
  msg=FIEL(VAL(SUBS(sistema[op_sis,O_ORDEM,1],i*2-1,2)))
  M->&msg.=&(sistema[op_sis,O_CPRELA,i])
 NEXT
 cabem=DISKSPACE(;
          IF(;
             LEN(sistema[op_sis,O_ARQUI,O_DIR_DBF])<2.OR.sistema[op_sis,O_ARQUI,O_DIR_DBF]="\",;
             0,;
             ASC(sistema[op_sis,O_ARQUI,O_DIR_DBF])-64;
          );
       )
 cabem=INT((cabem-2048)/TAXAS->(RECSIZE()))
 IF cabem<1                                        // mais nenhum!!!
  ALERTA()
  msg="Verifique ESPA€O EM DISCO, "+usuario
  DBOX(msg,,,,,"INCLUSŽO INTERROMPIDA!")           // vamos parar por aqui!
  EXIT
 ENDI
 SELE 0                                            // torna visiveis variaveis de memoria
 SETCOLOR(drvcortel+","+drvcorget+",,,"+corcampo)
 SET KEY K_ALT_F8 TO ROLATELA
 
 /*
    recebe chaves do arquivo de indice basico
 */
 @ l_s+l_a,c_s+11 GET  cobranca;
                  PICT sistema[op_sis,O_CAMPO,02,O_MASC]
                  DEFINICAO 2

 READ
 SET KEY K_ALT_F8 TO
 IF rola_t
  ROLATELA()
  LOOP
 ENDI
 SELE TAXAS
 IF LASTKEY()=K_ESC                                // cancelou ou chave em branco
  cabem=0                                          // prepara saida da inclusao
  LOOP                                             // volta p/ menu de cadastramento
 ENDI
 SEEK M->codigo+M->cobranca
 aprov_reg_=(FOUND().AND.DELE().AND.!drvvisivel)   // vai aproveitar o registro?
 IF FOUND() .AND. !aprov_reg_                      // pesquisou e achou!
  l_a=Sistema[op_sis,O_TELA,O_SCROLL]
  op_menu=ALTERACAO                                // seta flag de ateracao
  DISPBEGIN()
  TAX_GETS()                                       // mostra conteudo do registro
  INFOSIS(.f.)                                     // exibe informacao no rodape' da tela
  DISPEND()
  ALERTA()
  msg="Consultar/alterar|Retornar … inclus„o"      // pergunta se deseja
  op_=DBOX(msg,,,E_MENU,,"REGISTRO J EXISTE")     // alterar o registro
  IF op_ =1                                        // caso afirmativo
   EDIT()                                          // deixa alterar
  ENDI
  op_menu=INCLUSAO
  DISPBEGIN()
  TAX_TELA()
  INFOSIS(.t.)                                     // exibe informacao no rodape' da tela
  DISPEND()
  LOOP                                             // volta para inclusao
 ENDI
 SELE 0
 TAX_GET1(INCLUI)                                  // recebe campos
 SELE TAXAS
 IF LASTKEY()=K_ESC                                // se cancelou
  ALERTA()                                         // avisa que o registro
  DBOX("Registro n„o inclu¡do!",18,,1)             // nao foi incluido, e volta
  LOOP
 ENDI

 #ifdef COM_REDE
  GO BOTT                                          // vamos bloquear o final do
  SKIP                                             // arq para que nehum outro
  BLOREG(0,.5)                                     // usuario possa incluir
  SEEK M->codigo+M->cobranca                       // se registro foi incluido
  aprov_reg_=(FOUND().AND.DELE().AND.!drvvisivel)  // vai aproveitar o registro?
  IF FOUND() .AND. !aprov_reg_                     // por outro usuario, entao
   BLOREG(0,.5)
   FOR i=1 TO FCOU()
    msg=FIEL(i)
    rep[i]=&msg.
    REPL &msg. WITH M->&msg.
   NEXT
   TAX_GET1(FORM_INVERSA)                          // executa formula inversa
   RECA
   FOR i=1 TO FCOU()
    msg=FIEL(i)
    REPL &msg. WITH rep[i]
   NEXT
   ALERTA(4)                                       // beep 4 vezes
   msg="Registro acabou de ser|inclu¡do por outro usu rio!"
   DBOX(msg,,,,,"ATEN€ŽO!")                        // avisa
   SELE TAXAS
   UNLOCK                                          // libera o registro
   LOOP                                            // e recebe chave novamente
  ENDI
 #endi

 IF aprov_reg_                                     // se vai aproveitar reg excluido

  #ifdef COM_REDE
   BLOREG(0,.5)
  #endi

  RECA                                             // excluido, vamos recupera-lo
 ELSE                                              // caso contrario
  APPEND BLANK                                     // inclui reg em branco no dbf
 ENDI
 FOR i=1 TO FCOU()                                 // para cada campo,
  msg=FIEL(i)                                      // salva o conteudo
  rep[i]=M->&msg.                                  // para repetir
  REPL &msg. WITH rep[i]                           // enche o campo do arquivo
 NEXT

 #ifdef COM_REDE
  UNLOCK                                           // libera o registro e
  COMMIT                                           // forca gravacao
 #else
  IF RECC()-INT(RECC()/20)*20=0                    // a cada 20 registros
   COMMIT                                          // digitados forca gravacao
  ENDI
 #endi

 ult_reg=RECN()                                    // ultimo registro digitado
 l_max=l_s+Sistema[op_sis,O_TELA,O_SCROLL]+Sistema[op_sis,O_TELA,O_QTDE]
 IF l_s+l_a+1<l_max                                // se nao atingiu o fim da tela
  l_a++                                            // digita na proxima linha
 ELSE                                              // se nao rola a campos para cima
  SCROLL(l_s+Sistema[op_sis,O_TELA,O_SCROLL],c_s+11,l_max-1,c_s+28,1)
  SCROLL(l_s+Sistema[op_sis,O_TELA,O_SCROLL],c_s+30,l_max-1,c_s+39,1)
  SCROLL(l_s+Sistema[op_sis,O_TELA,O_SCROLL],c_s+41,l_max-1,c_s+50,1)
  SCROLL(l_s+Sistema[op_sis,O_TELA,O_SCROLL],c_s+53,l_max-1,c_s+62,1)
  SCROLL(l_s+Sistema[op_sis,O_TELA,O_SCROLL],c_s+64,l_max-1,c_s+73,1)
  SCROLL(l_s+Sistema[op_sis,O_TELA,O_SCROLL],c_s+75,l_max-1,c_s+77,1)
  SCROLL(l_s+Sistema[op_sis,O_TELA,O_SCROLL],c_s+01,l_max-1,c_s+08,1)
 ENDI
 IF reg_cop!=NIL                                   // estava na consulta e quis rep o campo
  EXIT                                             // cai fora...
 ENDI
ENDD
GO ult_reg                                         // para o ultimo reg digitado
SETKEY(K_F3,t_f3_)                                 // restaura teclas de funcoes
SETKEY(K_F4,t_f4_)
SET(_SET_DELETED,dele_atu)                            // ecluidos visiveis/invisiveis
SETKEY(K_CTRL_W,ctl_w)
SETKEY(K_CTRL_C,ctl_c)
SETKEY(K_CTRL_R,ctl_r)
RETU


PROC TAX_tela     // tela do arquivo TAXAS
tem_borda=.t.
l_s=Sistema[op_sis,O_TELA,O_LS]           // coordenadas da tela
c_s=Sistema[op_sis,O_TELA,O_CS]
l_i=Sistema[op_sis,O_TELA,O_LI]
c_i=Sistema[op_sis,O_TELA,O_CI]
SETCOLOR(drvtittel)
vr_memo=NOVAPOSI(@l_s,@c_s,@l_i,@c_i)     // pega posicao atual da tela
CAIXA(mold,l_s,c_s,l_i,c_i)               // monta caixa da tela
i=LEN(sistema[op_sis,O_MENS])/2
@ l_s,c_s-1+(c_i-c_s+1)/2-i SAY " "+MAIUSC(sistema[op_sis,O_MENS])+" "
SETCOLOR(drvcortel)
@ l_s+01,c_s+1 SAY "N§                            Emissao       Valor  ³ Pagto    Valor Pago Stat"
@ l_s+02,c_s+1 SAY "ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ"
@ l_s+03,c_s+1 SAY "                                                   ³"
@ l_s+04,c_s+1 SAY "                                                   ³"
@ l_s+05,c_s+1 SAY "                                                   ³"
@ l_s+06,c_s+1 SAY "                                                   ³"
@ l_s+07,c_s+1 SAY "                                                   ³"
@ l_s+08,c_s+1 SAY "                                                   ³"
@ l_s+09,c_s+1 SAY "                                                   ³"
RETU

PROC TAX_gets     // mostra variaveis do arquivo TAXAS
LOCAL getlist := {}, l_max, reg_atual:=RECNO()
PRIV  l_a:=Sistema[op_sis,O_TELA,O_SCROLL]
TAX_TELA()
l_max=l_s+Sistema[op_sis,O_TELA,O_SCROLL]+Sistema[op_sis,O_TELA,O_QTDE]
SETCOLOR(drvcortel+","+drvcorget+",,,"+corcampo)
DO WHILE !EOF() .AND. l_s+l_a<l_max .AND.;
   &(INDEXKEY(0))=IF(EMPT(criterio),"","T")+chv_1
 CRIT("",,"1|2")
 @ l_s+l_a,c_s+11 GET  cobranca;
                  PICT sistema[op_sis,O_CAMPO,02,O_MASC]

 @ l_s+l_a,c_s+30 GET  emissao_;
                  PICT sistema[op_sis,O_CAMPO,05,O_MASC]

 @ l_s+l_a,c_s+41 GET  valor;
                  PICT sistema[op_sis,O_CAMPO,06,O_MASC]

 @ l_s+l_a,c_s+53 GET  pgto_;
                  PICT sistema[op_sis,O_CAMPO,07,O_MASC]

 @ l_s+l_a,c_s+64 GET  valorpg;
                  PICT sistema[op_sis,O_CAMPO,08,O_MASC]

 SETCOLOR(drvcortel+","+drvcortel+",,,"+drvcortel)
 l_a++
 SKIP
ENDD
GO reg_atual
SETCOLOR(drvcortel+","+drvcorget+",,,"+corcampo)
CLEAR GETS
RETU

PROC TAX_get1(tp_mov, excl_rela)     // capta variaveis do arquivo TAXAS
LOCAL getlist := {}
PRIV  blk_taxas:=.t.
excl_rela=IF(excl_rela=NIL,.f.,excl_rela)
IF tp_mov=INCLUI
 IF TYPE("l_a")!="N"
  l_a=Sistema[op_sis,O_TELA,O_SCROLL]
 ENDI
 DO WHILE .t.
  rola_t=.f.
  SET KEY K_ALT_F8 TO ROLATELA
  SETCOLOR(drvcortel+","+drvcorget+",,,"+corcampo)
  CRIT("",,"1|2")
  @ l_s+l_a,c_s+30 GET  emissao_;
                   PICT sistema[op_sis,O_CAMPO,05,O_MASC]
                   DEFINICAO 5

  @ l_s+l_a,c_s+41 GET  valor;
                   PICT sistema[op_sis,O_CAMPO,06,O_MASC]
                   DEFINICAO 6

  @ l_s+l_a,c_s+53 GET  pgto_;
                   PICT sistema[op_sis,O_CAMPO,07,O_MASC]
                   DEFINICAO 7

  @ l_s+l_a,c_s+64 GET  valorpg;
                   PICT sistema[op_sis,O_CAMPO,08,O_MASC]
                   DEFINICAO 8

  READ
  SET KEY K_ALT_F8 TO
  IF rola_t
   ROLATELA()
   LOOP
  ENDI
  IF LASTKEY()!=K_ESC .AND. drvincl .AND. op_menu=INCLUSAO
   IF !CONFINCL()
    LOOP
   ENDI
  ENDI
  EXIT
 ENDD
ENDI
PTAB(COBRADOR,'COBRADOR',1)
PTAB(COBRADOR+M->MMESREF,'FCCOB',1)
IF tp_mov=EXCLUI .OR. tp_mov=FORM_INVERSA
 IF !EMPTY(codlan) .AND. tp_mov=EXCLUI
  ALERTA()       // existe registro validado aqui!
  msg="Registro de Lan‡amento"
  DBOX(msg,,,,,"IMPOSS¡VEL EXCLUIR!")
 ELSE

  #ifdef COM_REDE
   IF !tipo='1'
    REPBLO('GRUPOS->qtcircs',{||GRUPOS->qtcircs - 1})
   ENDI
   IF !tipo='1'.AND.valorpg>0
    REPBLO('GRUPOS->qtcircpg',{||GRUPOS->qtcircpg - 1})
   ENDI
   IF !excl_rela
    IF !EMPTY(ALIAS())
     REPL flag_excl WITH '*'
    ENDI
   ENDI
  #else
   IF !tipo='1'
    REPL GRUPOS->qtcircs WITH GRUPOS->qtcircs - 1
   ENDI
   IF !tipo='1'.AND.valorpg>0
    REPL GRUPOS->qtcircpg WITH GRUPOS->qtcircpg - 1
   ENDI
   IF !excl_rela
    IF !EMPTY(ALIAS())
     REPL flag_excl WITH '*'
    ENDI
   ENDI
  #endi

  IF !EMPTY(ALIAS())
   DELE
  ENDI
 ENDI
ELSEIF tp_mov=INCLUI .OR. tp_mov=RECUPERA .OR. tp_mov=FORM_DIRETA
 IF (op_menu=INCLUSAO .AND. LASTKEY()!=K_ESC) .OR. op_menu!=INCLUSAO
  IF !EMPTY(codlan) .AND. tp_mov=RECUPERA
   ALERTA()      // existe registro validado aqui!
   msg="Registro de Lan‡amento"
   DBOX(msg,,,,,"IMPOSS¡VEL RECUPERAR!")
  ELSE
   IF tp_mov=RECUPERA .AND. op_menu!=INCLUSAO .AND. (GRUPOS->(DELE()))
    msg="|"+sistema[EVAL(qualsis,"GRUPOS"),O_MENU]
    ALERTA(2)
    DBOX("Registro exclu¡do em:"+msg+"|*",,,,,"IMPOSS¡VEL RECUPERAR!")
   ELSE

    #ifdef COM_REDE
     IF !tipo='1'
      REPBLO('GRUPOS->qtcircs',{||GRUPOS->qtcircs + 1})
     ENDI
     IF !tipo='1'.AND.valorpg>0
      REPBLO('GRUPOS->qtcircpg',{||GRUPOS->qtcircpg + 1})
     ENDI
     IF !tipo='1'.AND.circ>GRUPOS->ultcirc
      REPBLO('GRUPOS->ultcirc',{||circ})
     ENDI
     IF !excl_rela
      IF op_menu=INCLUSAO
       flag_excl=' '
      ELSE
       REPL flag_excl WITH ' '
      ENDI
     ENDI
    #else
     IF !tipo='1'
      REPL GRUPOS->qtcircs WITH GRUPOS->qtcircs + 1
     ENDI
     IF !tipo='1'.AND.valorpg>0
      REPL GRUPOS->qtcircpg WITH GRUPOS->qtcircpg + 1
     ENDI
     IF !tipo='1'.AND.circ>GRUPOS->ultcirc
      REPL GRUPOS->ultcirc WITH circ
     ENDI
     IF !excl_rela
      IF op_menu=INCLUSAO
       flag_excl=' '
      ELSE
       REPL flag_excl WITH ' '
      ENDI
     ENDI
    #endi

    IF op_menu!=INCLUSAO
     RECA
    ENDI
   ENDI
  ENDI
 ENDI
ENDI
RETU

PROC ECO_incl(reg_cop)  // inclusao no arquivo ECOB
LOCAL getlist:={}, cabem:=1, rep:=ARRAY(FCOU()), ult_reg:=RECN(),;
      ctl_r, ctl_c, ctl_w, t_f3_, t_f4_, dele_atu:=SET(_SET_DELETED,.f.)
PRIV op_menu:=INCLUSAO, op_sis, l_s, c_s, l_i, c_i, cod_sos, tem_borda, criterio:="", cpord:=""
op_sis=EVAL(qualsis,"ECOB")
IF AT("D",exrot[op_sis])>0
 RETU
ENDI
FOR i=1 TO FCOU()                                  // cria/declara privadas as
 msg=FIEL(i)                                       // variaveis de memoria com
 PRIV &msg.                                        // o mesmo nome dos campos
NEXT                                               // do arquivo
IF reg_cop!=NIL                                    // quer repetir todo o reg atual
 FOR i=1 TO FCOU()                                 // para cada campo,
  msg=FIEL(i)                                      // salva o conteudo
  rep[i]=&msg.                                     // para repetir
 NEXT
ELSE
 AFILL(rep,"")                                     // eche com valor vazio
ENDI
t_f3_=SETKEY(K_F3,{||rep()})                       // repeticao reg anterior
t_f4_=SETKEY(K_F4,{||conf()})                      // confirma campos com ENTER
ctl_w=SETKEY(K_CTRL_W,{||nadafaz()})               // enganando o CA-Clipper...
ctl_c=SETKEY(K_CTRL_C,{||nadafaz()})
ctl_r=SETKEY(K_CTRL_R,{||nadafaz()})
DO WHIL cabem>0
 cod_sos=6
 rola_t=.f.                                        // flag se quer rolar a tela
 SELE ECOB
 GO BOTT                                           // forca o
 SKIP                                              // final do arquivo
 
 /*
    cria variaveis de memoria identicas as de arquivo, para inclusao
    de registros
 */
 FOR i=1 TO FCOU()
  msg=FIEL(i)
  M->&msg.=IF((fgrep .OR. reg_cop!=NIL).AND.!EMPT(rep[1]),rep[i],&msg.)
 NEXT
 
 /*
    inicializa campos de relacionamentos do com os campos do arquivo
    superior (pai)
 */
 FOR i=1 TO LEN(sistema[op_sis,O_CPRELA])
  msg=FIEL(VAL(SUBS(sistema[op_sis,O_ORDEM,1],i*2-1,2)))
  M->&msg.=&(sistema[op_sis,O_CPRELA,i])
 NEXT
 DISPBEGIN()                                       // apresenta a tela de uma vez so
 ECO_TELA()
 INFOSIS(.t.)                                      // exibe informacao no rodape' da tela
 DISPEND()
 cabem=DISKSPACE(;
          IF(;
             LEN(sistema[op_sis,O_ARQUI,O_DIR_DBF])<2.OR.sistema[op_sis,O_ARQUI,O_DIR_DBF]="\",;
             0,;
             ASC(sistema[op_sis,O_ARQUI,O_DIR_DBF])-64;
          );
       )
 cabem=INT((cabem-2048)/ECOB->(RECSIZE()))
 IF cabem<1                                        // mais nenhum!!!
  ALERTA()
  msg="Verifique ESPA€O EM DISCO, "+usuario
  DBOX(msg,,,,,"INCLUSŽO INTERROMPIDA!")           // vamos parar por aqui!
  EXIT
 ENDI
 SELE 0                                            // torna visiveis variaveis de memoria
 SETCOLOR(drvcortel+","+drvcorget+",,,"+corcampo)
 SET KEY K_ALT_F8 TO ROLATELA
 
 /*
    recebe chaves do arquivo de indice basico
 */
 @ l_s+01 ,c_s+12 GET  tipo;
                  PICT sistema[op_sis,O_CAMPO,02,O_MASC]
                  DEFINICAO 2
                  MOSTRA sistema[op_sis,O_FORMULA,1]

 READ
 SET KEY K_ALT_F8 TO
 IF rola_t
  ROLATELA()
  LOOP
 ENDI
 SELE ECOB
 IF LASTKEY()=K_ESC                                // cancelou ou chave em branco
  cabem=0                                          // prepara saida da inclusao
  LOOP                                             // volta p/ menu de cadastramento
 ENDI
 SEEK M->codigo+M->tipo
 aprov_reg_=(FOUND().AND.DELE().AND.!drvvisivel)   // vai aproveitar o registro?
 IF FOUND() .AND. !aprov_reg_                      // pesquisou e achou!
  op_menu=ALTERACAO                                // seta flag de ateracao
  DISPBEGIN()
  ECO_GETS()                                       // mostra conteudo do registro
  INFOSIS(.f.)                                     // exibe informacao no rodape' da tela
  DISPEND()
  ALERTA()
  msg="Consultar/alterar|Retornar … inclus„o"      // pergunta se deseja
  op_=DBOX(msg,,,E_MENU,,"REGISTRO J EXISTE")     // alterar o registro
  IF op_ =1                                        // caso afirmativo
   EDIT()                                          // deixa alterar
  ENDI
  op_menu=INCLUSAO
  LOOP                                             // volta para inclusao
 ENDI
 SELE 0
 ECO_GET1(INCLUI)                                  // recebe campos
 SELE ECOB
 IF LASTKEY()=K_ESC                                // se cancelou
  ALERTA()                                         // avisa que o registro
  DBOX("Registro n„o inclu¡do!",18,,1)             // nao foi incluido, e volta
  LOOP
 ENDI

 #ifdef COM_REDE
  GO BOTT                                          // vamos bloquear o final do
  SKIP                                             // arq para que nehum outro
  BLOREG(0,.5)                                     // usuario possa incluir
  SEEK M->codigo+M->tipo                           // se registro foi incluido
  aprov_reg_=(FOUND().AND.DELE().AND.!drvvisivel)  // vai aproveitar o registro?
  IF FOUND() .AND. !aprov_reg_                     // por outro usuario, entao
   BLOREG(0,.5)
   FOR i=1 TO FCOU()
    msg=FIEL(i)
    rep[i]=&msg.
    REPL &msg. WITH M->&msg.
   NEXT
   ECO_GET1(FORM_INVERSA)                          // executa formula inversa
   RECA
   FOR i=1 TO FCOU()
    msg=FIEL(i)
    REPL &msg. WITH rep[i]
   NEXT
   ALERTA(4)                                       // beep 4 vezes
   msg="Registro acabou de ser|inclu¡do por outro usu rio!"
   DBOX(msg,,,,,"ATEN€ŽO!")                        // avisa
   SELE ECOB
   UNLOCK                                          // libera o registro
   LOOP                                            // e recebe chave novamente
  ENDI
 #endi

 IF aprov_reg_                                     // se vai aproveitar reg excluido

  #ifdef COM_REDE
   BLOREG(0,.5)
  #endi

  RECA                                             // excluido, vamos recupera-lo
 ELSE                                              // caso contrario
  APPEND BLANK                                     // inclui reg em branco no dbf
 ENDI
 FOR i=1 TO FCOU()                                 // para cada campo,
  msg=FIEL(i)                                      // salva o conteudo
  rep[i]=M->&msg.                                  // para repetir
  REPL &msg. WITH rep[i]                           // enche o campo do arquivo
 NEXT

 #ifdef COM_REDE
  UNLOCK                                           // libera o registro e
  COMMIT                                           // forca gravacao
 #else
  IF RECC()-INT(RECC()/20)*20=0                    // a cada 20 registros
   COMMIT                                          // digitados forca gravacao
  ENDI
 #endi

 ult_reg=RECN()                                    // ultimo registro digitado
 IF reg_cop!=NIL                                   // estava na consulta e quis rep o campo
  EXIT                                             // cai fora...
 ENDI
ENDD
GO ult_reg                                         // para o ultimo reg digitado
SETKEY(K_F3,t_f3_)                                 // restaura teclas de funcoes
SETKEY(K_F4,t_f4_)
SET(_SET_DELETED,dele_atu)                            // ecluidos visiveis/invisiveis
SETKEY(K_CTRL_W,ctl_w)
SETKEY(K_CTRL_C,ctl_c)
SETKEY(K_CTRL_R,ctl_r)
RETU


PROC ECO_tela     // tela do arquivo ECOB
tem_borda=.t.
l_s=Sistema[op_sis,O_TELA,O_LS]           // coordenadas da tela
c_s=Sistema[op_sis,O_TELA,O_CS]
l_i=Sistema[op_sis,O_TELA,O_LI]
c_i=Sistema[op_sis,O_TELA,O_CI]
SETCOLOR(drvtittel)
vr_memo=NOVAPOSI(@l_s,@c_s,@l_i,@c_i)     // pega posicao atual da tela
CAIXA(mold,l_s,c_s,l_i,c_i)               // monta caixa da tela
i=LEN(sistema[op_sis,O_MENS])/2
@ l_s,c_s-1+(c_i-c_s+1)/2-i SAY " "+MAIUSC(sistema[op_sis,O_MENS])+" "
SETCOLOR(drvcortel)
@ l_s+01,c_s+1 SAY " Tipo....:"
@ l_s+02,c_s+1 SAY " Endere‡o:"
@ l_s+03,c_s+1 SAY " Bairro..:"
@ l_s+04,c_s+1 SAY " CEP.....:"
@ l_s+05,c_s+1 SAY " Cidade..:                            Est.:"
@ l_s+06,c_s+1 SAY " Telefone:"
@ l_s+07,c_s+1 SAY " Obs.....:"
RETU

PROC ECO_gets     // mostra variaveis do arquivo ECOB
LOCAL getlist := {}
ECO_TELA()
SETCOLOR(drvcortel+","+drvcorget+",,,"+corcampo)
IF &(INDEXKEY(0))=IF(EMPT(criterio),"","T")+chv_1
 CRIT("",,"2")
 @ l_s+01 ,c_s+12 GET  tipo;
                  PICT sistema[op_sis,O_CAMPO,02,O_MASC]
                  CRIT(sistema[op_sis,O_CAMPO,02,O_CRIT],,"1")

 @ l_s+02 ,c_s+12 GET  endereco;
                  PICT sistema[op_sis,O_CAMPO,03,O_MASC]

 @ l_s+03 ,c_s+12 GET  bairro;
                  PICT sistema[op_sis,O_CAMPO,04,O_MASC]

 @ l_s+04 ,c_s+12 GET  cep;
                  PICT sistema[op_sis,O_CAMPO,05,O_MASC]

 @ l_s+05 ,c_s+12 GET  cidade;
                  PICT sistema[op_sis,O_CAMPO,06,O_MASC]

 @ l_s+05 ,c_s+45 GET  uf;
                  PICT sistema[op_sis,O_CAMPO,07,O_MASC]

 @ l_s+06 ,c_s+12 GET  telefone;
                  PICT sistema[op_sis,O_CAMPO,08,O_MASC]

 @ l_s+07 ,c_s+12 GET  obs

ENDI
CLEAR GETS
RETU

PROC ECO_get1(tp_mov, excl_rela)     // capta variaveis do arquivo ECOB
LOCAL getlist := {}
PRIV  blk_ecob:=.t.
excl_rela=IF(excl_rela=NIL,.f.,excl_rela)
IF tp_mov=INCLUI
 DO WHILE .t.
  rola_t=.f.
  SET KEY K_ALT_F8 TO ROLATELA
  SETCOLOR(drvcortel+","+drvcorget+",,,"+corcampo)
  CRIT("",,"2")
  @ l_s+02 ,c_s+12 GET  endereco;
                   PICT sistema[op_sis,O_CAMPO,03,O_MASC]
                   DEFINICAO 3

  @ l_s+03 ,c_s+12 GET  bairro;
                   PICT sistema[op_sis,O_CAMPO,04,O_MASC]
                   DEFINICAO 4

  @ l_s+04 ,c_s+12 GET  cep;
                   PICT sistema[op_sis,O_CAMPO,05,O_MASC]
                   DEFINICAO 5

  @ l_s+05 ,c_s+12 GET  cidade;
                   PICT sistema[op_sis,O_CAMPO,06,O_MASC]
                   DEFINICAO 6

  @ l_s+05 ,c_s+45 GET  uf;
                   PICT sistema[op_sis,O_CAMPO,07,O_MASC]
                   DEFINICAO 7

  @ l_s+06 ,c_s+12 GET  telefone;
                   PICT sistema[op_sis,O_CAMPO,08,O_MASC]
                   DEFINICAO 8

  @ l_s+07 ,c_s+12 GET  obs
                   DEFINICAO 9

  READ
  SET KEY K_ALT_F8 TO
  IF rola_t
   ROLATELA()
   LOOP
  ENDI
  IF LASTKEY()!=K_ESC .AND. drvincl .AND. op_menu=INCLUSAO
   IF !CONFINCL()
    LOOP
   ENDI
  ENDI
  EXIT
 ENDD
ENDI
IF tp_mov=EXCLUI .OR. tp_mov=FORM_INVERSA

 #ifdef COM_REDE
  IF !excl_rela
   IF !EMPTY(ALIAS())
    REPL flag_excl WITH '*'
   ENDI
  ENDI
 #else
  IF !excl_rela
   IF !EMPTY(ALIAS())
    REPL flag_excl WITH '*'
   ENDI
  ENDI
 #endi

 IF !EMPTY(ALIAS())
  DELE
 ENDI
ELSEIF tp_mov=INCLUI .OR. tp_mov=RECUPERA .OR. tp_mov=FORM_DIRETA
 IF (op_menu=INCLUSAO .AND. LASTKEY()!=K_ESC) .OR. op_menu!=INCLUSAO
  IF tp_mov=RECUPERA .AND. op_menu!=INCLUSAO .AND. (GRUPOS->(DELE()))
   msg="|"+sistema[EVAL(qualsis,"GRUPOS"),O_MENU]
   ALERTA(2)
   DBOX("Registro exclu¡do em:"+msg+"|*",,,,,"IMPOSS¡VEL RECUPERAR!")
  ELSE
    IF op_menu=INCLUSAO
     data_=DATE()
    ELSE
     REPL data_ WITH DATE()
    ENDI
    IF !excl_rela
     IF op_menu=INCLUSAO
      flag_excl=' '
     ELSE
      REPL flag_excl WITH ' '
     ENDI
    ENDI
   IF op_menu!=INCLUSAO
    RECA
   ENDI
  ENDI
 ENDI
ENDI
RETU

PROC INS_incl(reg_cop)  // inclusao no arquivo INSCRITS
LOCAL getlist:={}, cabem:=1, rep:=ARRAY(FCOU()), ult_reg:=RECN(),;
      ctl_r, ctl_c, ctl_w, t_f3_, t_f4_, dele_atu:=SET(_SET_DELETED,.f.)
PRIV op_menu:=INCLUSAO, op_sis, l_s, c_s, l_i, c_i, cod_sos, tem_borda, criterio:="", cpord:=""
op_sis=EVAL(qualsis,"INSCRITS")
IF AT("D",exrot[op_sis])>0
 RETU
ENDI
FOR i=1 TO FCOU()                                  // cria/declara privadas as
 msg=FIEL(i)                                       // variaveis de memoria com
 PRIV &msg.                                        // o mesmo nome dos campos
NEXT                                               // do arquivo
IF reg_cop!=NIL                                    // quer repetir todo o reg atual
 FOR i=1 TO FCOU()                                 // para cada campo,
  msg=FIEL(i)                                      // salva o conteudo
  rep[i]=&msg.                                     // para repetir
 NEXT
ELSE
 AFILL(rep,"")                                     // eche com valor vazio
ENDI
t_f3_=SETKEY(K_F3,{||rep()})                       // repeticao reg anterior
t_f4_=SETKEY(K_F4,{||conf()})                      // confirma campos com ENTER
ctl_w=SETKEY(K_CTRL_W,{||nadafaz()})               // enganando o CA-Clipper...
ctl_c=SETKEY(K_CTRL_C,{||nadafaz()})
ctl_r=SETKEY(K_CTRL_R,{||nadafaz()})
DO WHIL cabem>0
 cod_sos=6
 rola_t=.f.                                        // flag se quer rolar a tela
 SELE INSCRITS
 GO BOTT                                           // forca o
 SKIP                                              // final do arquivo
 
 /*
    cria variaveis de memoria identicas as de arquivo, para inclusao
    de registros
 */
 FOR i=1 TO FCOU()
  msg=FIEL(i)
  M->&msg.=IF((fgrep .OR. reg_cop!=NIL).AND.!EMPT(rep[1]),rep[i],&msg.)
 NEXT
 
 /*
    inicializa campos de relacionamentos do com os campos do arquivo
    superior (pai)
 */
 FOR i=1 TO LEN(sistema[op_sis,O_CPRELA])
  msg=FIEL(VAL(SUBS(sistema[op_sis,O_ORDEM,1],i*2-1,2)))
  M->&msg.=&(sistema[op_sis,O_CPRELA,i])
 NEXT
 DISPBEGIN()                                       // apresenta a tela de uma vez so
 INS_TELA()
 INFOSIS(.t.)                                      // exibe informacao no rodape' da tela
 DISPEND()
 cabem=DISKSPACE(;
          IF(;
             LEN(sistema[op_sis,O_ARQUI,O_DIR_DBF])<2.OR.sistema[op_sis,O_ARQUI,O_DIR_DBF]="\",;
             0,;
             ASC(sistema[op_sis,O_ARQUI,O_DIR_DBF])-64;
          );
       )
 cabem=INT((cabem-2048)/INSCRITS->(RECSIZE()))
 IF cabem<1                                        // mais nenhum!!!
  ALERTA()
  msg="Verifique ESPA€O EM DISCO, "+usuario
  DBOX(msg,,,,,"INCLUSŽO INTERROMPIDA!")           // vamos parar por aqui!
  EXIT
 ENDI
 SELE 0                                            // torna visiveis variaveis de memoria
 SETCOLOR(drvcortel+","+drvcorget+",,,"+corcampo)
 SET KEY K_ALT_F8 TO ROLATELA
 
 /*
    recebe chaves do arquivo de indice basico
 */
 @ l_s+01 ,c_s+09 GET  grau;
                  PICT sistema[op_sis,O_CAMPO,02,O_MASC]
                  DEFINICAO 2
                  MOSTRA sistema[op_sis,O_FORMULA,1]

 READ
 SET KEY K_ALT_F8 TO
 IF rola_t
  ROLATELA()
  LOOP
 ENDI
 SELE INSCRITS
 IF LASTKEY()=K_ESC                                // cancelou ou chave em branco
  cabem=0                                          // prepara saida da inclusao
  LOOP                                             // volta p/ menu de cadastramento
 ENDI
 SEEK M->codigo+M->grau
 aprov_reg_=(FOUND().AND.DELE().AND.!drvvisivel)   // vai aproveitar o registro?
 IF FOUND() .AND. !aprov_reg_                      // pesquisou e achou!
  op_menu=ALTERACAO                                // seta flag de ateracao
  DISPBEGIN()
  INS_GETS()                                       // mostra conteudo do registro
  INFOSIS(.f.)                                     // exibe informacao no rodape' da tela
  DISPEND()
  ALERTA()
  msg="Consultar/alterar|Retornar … inclus„o"      // pergunta se deseja
  op_=DBOX(msg,,,E_MENU,,"REGISTRO J EXISTE")     // alterar o registro
  IF op_ =1                                        // caso afirmativo
   EDIT()                                          // deixa alterar
  ENDI
  op_menu=INCLUSAO
  LOOP                                             // volta para inclusao
 ENDI
 SELE 0
 INS_GET1(INCLUI)                                  // recebe campos
 SELE INSCRITS
 IF LASTKEY()=K_ESC                                // se cancelou
  ALERTA()                                         // avisa que o registro
  DBOX("Registro n„o inclu¡do!",18,,1)             // nao foi incluido, e volta
  LOOP
 ENDI

 #ifdef COM_REDE
  GO BOTT                                          // vamos bloquear o final do
  SKIP                                             // arq para que nehum outro
  BLOREG(0,.5)                                     // usuario possa incluir
  SEEK M->codigo+M->grau                           // se registro foi incluido
  aprov_reg_=(FOUND().AND.DELE().AND.!drvvisivel)  // vai aproveitar o registro?
  IF FOUND() .AND. !aprov_reg_                     // por outro usuario, entao
   BLOREG(0,.5)
   FOR i=1 TO FCOU()
    msg=FIEL(i)
    rep[i]=&msg.
    REPL &msg. WITH M->&msg.
   NEXT
   INS_GET1(FORM_INVERSA)                          // executa formula inversa
   RECA
   FOR i=1 TO FCOU()
    msg=FIEL(i)
    REPL &msg. WITH rep[i]
   NEXT
   ALERTA(4)                                       // beep 4 vezes
   msg="Registro acabou de ser|inclu¡do por outro usu rio!"
   DBOX(msg,,,,,"ATEN€ŽO!")                        // avisa
   SELE INSCRITS
   UNLOCK                                          // libera o registro
   LOOP                                            // e recebe chave novamente
  ENDI
 #endi

 IF aprov_reg_                                     // se vai aproveitar reg excluido

  #ifdef COM_REDE
   BLOREG(0,.5)
  #endi

  RECA                                             // excluido, vamos recupera-lo
 ELSE                                              // caso contrario
  APPEND BLANK                                     // inclui reg em branco no dbf
 ENDI
 FOR i=1 TO FCOU()                                 // para cada campo,
  msg=FIEL(i)                                      // salva o conteudo
  rep[i]=M->&msg.                                  // para repetir
  REPL &msg. WITH rep[i]                           // enche o campo do arquivo
 NEXT

 #ifdef COM_REDE
  UNLOCK                                           // libera o registro e
  COMMIT                                           // forca gravacao
 #else
  IF RECC()-INT(RECC()/20)*20=0                    // a cada 20 registros
   COMMIT                                          // digitados forca gravacao
  ENDI
 #endi

 ult_reg=RECN()                                    // ultimo registro digitado
 IF reg_cop!=NIL                                   // estava na consulta e quis rep o campo
  EXIT                                             // cai fora...
 ENDI
ENDD
GO ult_reg                                         // para o ultimo reg digitado
SETKEY(K_F3,t_f3_)                                 // restaura teclas de funcoes
SETKEY(K_F4,t_f4_)
SET(_SET_DELETED,dele_atu)                            // ecluidos visiveis/invisiveis
SETKEY(K_CTRL_W,ctl_w)
SETKEY(K_CTRL_C,ctl_c)
SETKEY(K_CTRL_R,ctl_r)
RETU


PROC INS_tela     // tela do arquivo INSCRITS
tem_borda=.t.
l_s=Sistema[op_sis,O_TELA,O_LS]           // coordenadas da tela
c_s=Sistema[op_sis,O_TELA,O_CS]
l_i=Sistema[op_sis,O_TELA,O_LI]
c_i=Sistema[op_sis,O_TELA,O_CI]
SETCOLOR(drvtittel)
vr_memo=NOVAPOSI(@l_s,@c_s,@l_i,@c_i)     // pega posicao atual da tela
CAIXA(mold,l_s,c_s,l_i,c_i)               // monta caixa da tela
i=LEN(sistema[op_sis,O_MENS])/2
@ l_s,c_s-1+(c_i-c_s+1)/2-i SAY " "+MAIUSC(sistema[op_sis,O_MENS])+" "
SETCOLOR(drvcortel)
@ l_s+01,c_s+1 SAY " Inscr:                                            (                   )"
@ l_s+02,c_s+1 SAY "ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ"
@ l_s+03,c_s+1 SAY " Nome:                                     Nasc.:"
@ l_s+04,c_s+1 SAY " Est.Civil.:     Sexo.....:          T.Carˆncia.:"
@ l_s+05,c_s+1 SAY " Vivo/Falec:     Falecto..:            Tipo:      N§ Processo:"
RETU

PROC INS_gets     // mostra variaveis do arquivo INSCRITS
LOCAL getlist := {}, tl_item_
INS_TELA()
SETCOLOR(drvcortel+","+drvcorget+",,,"+corcampo)
IF &(INDEXKEY(0))=IF(EMPT(criterio),"","T")+chv_1
 CRIT("",,"2|3")
 @ l_s+01 ,c_s+09 GET  grau;
                  PICT sistema[op_sis,O_CAMPO,02,O_MASC]
                  CRIT(sistema[op_sis,O_CAMPO,02,O_CRIT],,"1")

 @ l_s+01 ,c_s+10 GET  seq;
                  PICT sistema[op_sis,O_CAMPO,03,O_MASC]

 @ l_s+03 ,c_s+08 GET  nome;
                  PICT sistema[op_sis,O_CAMPO,05,O_MASC]

 @ l_s+03 ,c_s+51 GET  nascto_;
                  PICT sistema[op_sis,O_CAMPO,06,O_MASC]
                  CRIT(sistema[op_sis,O_CAMPO,06,O_CRIT],,"4")

 @ l_s+04 ,c_s+14 GET  estcivil

 @ l_s+04 ,c_s+33 GET  sexo;
                  PICT sistema[op_sis,O_CAMPO,09,O_MASC]

 @ l_s+04 ,c_s+51 GET  tcarencia;
                  PICT sistema[op_sis,O_CAMPO,10,O_MASC]

 @ l_s+05 ,c_s+14 GET  vivofalec;
                  PICT sistema[op_sis,O_CAMPO,12,O_MASC]

 @ l_s+05 ,c_s+29 GET  falecto_;
                  PICT sistema[op_sis,O_CAMPO,13,O_MASC]

 @ l_s+05 ,c_s+46 GET  tipo;
                  PICT sistema[op_sis,O_CAMPO,14,O_MASC]

 @ l_s+05 ,c_s+64 GET  procnr;
                  PICT sistema[op_sis,O_CAMPO,15,O_MASC]

ENDI
CLEAR GETS
RETU

PROC INS_get1(tp_mov, excl_rela)     // capta variaveis do arquivo INSCRITS
LOCAL getlist := {}, tl_item_
PRIV  blk_inscrits:=.t.
excl_rela=IF(excl_rela=NIL,.f.,excl_rela)
IF tp_mov=INCLUI
 DO WHILE .t.
  rola_t=.f.
  SET KEY K_ALT_F8 TO ROLATELA
  SETCOLOR(drvcortel+","+drvcorget+",,,"+corcampo)
  CRIT("",,"2|3")
  @ l_s+01 ,c_s+10 GET  seq;
                   PICT sistema[op_sis,O_CAMPO,03,O_MASC]
                   DEFINICAO 3

  @ l_s+03 ,c_s+08 GET  nome;
                   PICT sistema[op_sis,O_CAMPO,05,O_MASC]
                   DEFINICAO 5

  @ l_s+03 ,c_s+51 GET  nascto_;
                   PICT sistema[op_sis,O_CAMPO,06,O_MASC]
                   DEFINICAO 6
                   MOSTRA sistema[op_sis,O_FORMULA,4]

  @ l_s+04 ,c_s+14 GET  estcivil
                   DEFINICAO 7

  @ l_s+04 ,c_s+33 GET  sexo;
                   PICT sistema[op_sis,O_CAMPO,09,O_MASC]
                   DEFINICAO 9

  @ l_s+04 ,c_s+51 GET  tcarencia;
                   PICT sistema[op_sis,O_CAMPO,10,O_MASC]
                   DEFINICAO 10

  @ l_s+05 ,c_s+14 GET  vivofalec;
                   PICT sistema[op_sis,O_CAMPO,12,O_MASC]
                   DEFINICAO 12

  @ l_s+05 ,c_s+29 GET  falecto_;
                   PICT sistema[op_sis,O_CAMPO,13,O_MASC]
                   DEFINICAO 13

  @ l_s+05 ,c_s+46 GET  tipo;
                   PICT sistema[op_sis,O_CAMPO,14,O_MASC]
                   DEFINICAO 14

  @ l_s+05 ,c_s+64 GET  procnr;
                   PICT sistema[op_sis,O_CAMPO,15,O_MASC]
                   DEFINICAO 15

  READ
  SET KEY K_ALT_F8 TO
  IF rola_t
   ROLATELA()
   LOOP
  ENDI
  IF LASTKEY()!=K_ESC .AND. drvincl .AND. op_menu=INCLUSAO
   IF !CONFINCL()
    LOOP
   ENDI
  ENDI
  EXIT
 ENDD
ENDI
IF tp_mov=EXCLUI .OR. tp_mov=FORM_INVERSA

 #ifdef COM_REDE
  IF !EMPTY(ALIAS())
   REPL lancto_ WITH date()
  ENDI
  IF ehtitular=[S]
   REPBLO('GRUPOS->titular',{||[   ]})
  ENDI
  IF vivofalec=[V]
   REPBLO('GRUPOS->particv',{||GRUPOS->particv - 1})
  ENDI
  IF vivofalec=[F]
   REPBLO('GRUPOS->particf',{||GRUPOS->particf - 1})
  ENDI
  IF grau=[8]
   REPBLO('GRUPOS->nrdepend',{||GRUPOS->nrdepend - 1})
  ENDI
  IF !excl_rela
   IF !EMPTY(ALIAS())
    REPL flag_excl WITH '*'
   ENDI
  ENDI
 #else
  IF !EMPTY(ALIAS())
   REPL lancto_ WITH date()
  ENDI
  IF ehtitular=[S]
   REPL GRUPOS->titular WITH [   ]
  ENDI
  IF vivofalec=[V]
   REPL GRUPOS->particv WITH GRUPOS->particv - 1
  ENDI
  IF vivofalec=[F]
   REPL GRUPOS->particf WITH GRUPOS->particf - 1
  ENDI
  IF grau=[8]
   REPL GRUPOS->nrdepend WITH GRUPOS->nrdepend - 1
  ENDI
  IF !excl_rela
   IF !EMPTY(ALIAS())
    REPL flag_excl WITH '*'
   ENDI
  ENDI
 #endi

 IF !EMPTY(ALIAS())
  DELE
 ENDI
 IF op_menu!=PROJECOES .AND. op_menu!=TEL_EXTRA
  REIMPTEL()
 ENDI
ELSEIF tp_mov=INCLUI .OR. tp_mov=RECUPERA .OR. tp_mov=FORM_DIRETA
 IF (op_menu=INCLUSAO .AND. LASTKEY()!=K_ESC) .OR. op_menu!=INCLUSAO
  IF tp_mov=RECUPERA .AND. op_menu!=INCLUSAO .AND. (GRUPOS->(DELE()))
   msg="|"+sistema[EVAL(qualsis,"GRUPOS"),O_MENU]
   ALERTA(2)
   DBOX("Registro exclu¡do em:"+msg+"|*",,,,,"IMPOSS¡VEL RECUPERAR!")
  ELSE
    IF op_menu=INCLUSAO
     lancto_=date()
    ELSE
     REPL lancto_ WITH date()
    ENDI

   #ifdef COM_REDE
    IF ehtitular=[S]
     REPBLO('GRUPOS->titular',{||grau+STRZERO(seq,2)})
    ENDI
    IF vivofalec=[V]
     REPBLO('GRUPOS->particv',{||GRUPOS->particv + 1})
    ENDI
    IF vivofalec=[F]
     REPBLO('GRUPOS->particf',{||GRUPOS->particf + 1})
    ENDI
    IF grau=[8]
     REPBLO('GRUPOS->nrdepend',{||GRUPOS->nrdepend + 1})
    ENDI
    IF !excl_rela
     IF op_menu=INCLUSAO
      flag_excl=' '
     ELSE
      REPL flag_excl WITH ' '
     ENDI
    ENDI
   #else
    IF op_menu=INCLUSAO
     lancto_=date()
    ELSE
     REPL lancto_ WITH date()
    ENDI
    IF ehtitular=[S]
     REPL GRUPOS->titular WITH grau+STRZERO(seq,2)
    ENDI
    IF vivofalec=[V]
     REPL GRUPOS->particv WITH GRUPOS->particv + 1
    ENDI
    IF vivofalec=[F]
     REPL GRUPOS->particf WITH GRUPOS->particf + 1
    ENDI
    IF grau=[8]
     REPL GRUPOS->nrdepend WITH GRUPOS->nrdepend + 1
    ENDI
    IF !excl_rela
     IF op_menu=INCLUSAO
      flag_excl=' '
     ELSE
      REPL flag_excl WITH ' '
     ENDI
    ENDI
   #endi

   IF op_menu!=INCLUSAO
    RECA
   ENDI
   IF (tp_mov=INCLUI .OR. tp_mov=RECUPERA) .AND. op_menu!=PROJECOES .AND. op_menu!=TEL_EXTRA
    REIMPTEL()
   ENDI
  ENDI
 ENDI
ENDI
RETU

* \\ Final de GRUPOS.PRG
€
 COB_01F9[–Ñ  COB_01F9CODEC_ETEXTENDCODE	_SYMSTARTSYMSTARTSYMBOLSSYMBOLS_SYMENDSYMENDNULLBEGDATA_DATADATA_SYMPBDATA_SYMPDATA_SYMPEDATA_CONSTCONST_MSGMSG_BEGBSSBEGBSS_BSSBSS_ENDBSSENDBSSDGROUPGAS-Pro v4.0
007016017067001002020001009000176001
 Codigo..........:      Fun‡„o:
 Nome............:
 Endere‡o........:
 Bairro..........:
 Cidade..........:
 Telefone........:
 CPF.............:
 Observa‡„o......:            Percentual.:
 Supervisor......:
[Ÿ]
Inclus„o~~26006
Manuten‡„o~~27007
Consulta~~28008
[Ÿ]
 11 
 1 
C¢digo

 1 
[Ÿ]
Cobradores/Vendedores
Cobradores/Vendedores







005
























 0 











 0 
 1 
-1 
-1 
 0 
-1 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
cobrador
C
E
!!!
 3 
 3 
 1 
 20 
 0 
Cobrador

!EMPT(cobrador)
Necess rio informar COBRADOR

Informe um c¢digo para o cobrador.
COB_01F9()
 0 
 0 


funcao
C
E
!
 1 
 1 
 1 
 33 
 0 
Fun‡„o

funcao $ [CVS]
FUN€ŽO n„o aceit vel

Informe se ‚ um Cobrador ou Vendedor|
MTAB([Cobrador|Vendedor|Supervisor],[FUN€ŽO])
 0 
 0 


nome
C
E
 
 30 
 30 
 2 
 20 
 0 
Nome do Cobrador

!EMPT(nome)
Necess rio informar NOME DO COBRADOR



 0 
 0 


endereco
C
E
 
 30 
 30 
 3 
 20 
 0 
Endere‡o

 




 0 
 0 


bairro
C
E
 
 20 
 20 
 4 
 20 
 0 
Bairro

 




 0 
 0 


cidade
C
E
 
 25 
 25 
 5 
 20 
 0 
Cidade

 




 0 
 0 


telefone
C
E
 
 14 
 14 
 6 
 20 
 0 
Telefone

 




 0 
 0 


cpf
C
E
@R 999.999.999-99
 11 
 14 
 7 
 20 
 0 
CPF

VDV2(cpf).OR.EMPT(cpf)
CPF n„o aceit vel



 0 
 0 


obs
M
E

 10 
 35 
 8 
 20 
 0 
Observa‡Æo

 




 0 
 0 


percent
N
E
999.9
 5 
 5 
 8 
 44 
 1 
Percentual

!(percent<0).AND.!(percent>100)
PERCENTUAL n„o aceit vel

Informe o percentual de comiss„o

 0 
 0 


superv
C
E
!!!
 3 
 3 
 9 
 20 
 0 
Supervisor

 


Digite o c¢digo do SUPERVISOR deste cobrador

 0 
 0 


 1 
Fun‡„o
SUBSTR([Cobrador  |Vendedor  |Supervisor],AT(funcao,[Cobrador  |Vendedor  |Supervisor]),10)

 1 
 35 
 10 

 0 
 0 
 0 
 0 
procedure v00101f9
/*
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
 \ Empresa.: PresServ Inform tica-Limeira (019)452.6623.
 \ Programa: V00101F9.PRG
 \ Data....: 03-10-95
 \ Sistema.: Controle de Convˆnios
 \ Funcao..: Valida‡„o da variavel GNUMERO, relatorio CON_R001
 \ Analista: Ademilson Pedro Bom
 \ Criacao.: Programado manualmente pelo analista
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/

#include "ADRbig.ch"    // inicializa constantes manifestas

//PARAMETROS('pnumero',gnumero)

  IF !PTAB(PADR(SUBSTR(M->ide_maq,2),4)+[GUI],[IMPPAR],1)
   ord_=LEN(sistema[EVAL(qualsis,"IMPPAR"),O_CHAVE])
   FAZ_LANC("IMPPAR",[ ])
   REPL IMPPAR->idmaq WITH PADR(SUBSTR(M->ide_maq,2),4),;
	IMPPAR->base WITH [GUI]
  ENDI
   #ifdef COM_REDE
    IMPPAR->(DBUNLOCK())                           // libera o registro
   #endi

   IF PTAB(PADR(SUBSTR(M->ide_maq,2),4)+[GUI],[IMPPAR],1)
    REPBLO('IMPPAR->docto',{||gnumero})
   ENDI

RETU .T.      // <- deve retornar um valor L¢GICO

* \\ Final de V00101F9.PRG
€
 GUI_08F9C–Ñ  GUI_08F9CODEC_ETEXTENDCODE	_SYMSTARTSYMSTARTSYMBOLSSYMBOLS_SYMENDSYMENDNULLBEGDATA_DATADATA_SYMPBDATA_SYMPDATA_SYMPEDATA_CONSTCONST_MSGMSG_BEGBSSBEGBSS_BSSBSS_ENDBSSENDBSSDGROUP˜ @Ý=˜ H  ˜ h  ë˜ `Ð 	˜ h  
ã˜ h  ß˜ H  û˜ H  ÷˜ H ë˜ H  ï˜ H  ë˜ (  ˜ H  GAS-Pro v4.0
008016019067001003023001011001176001
 Grupo:    Circular:
 Emiss„o....:              Mˆs Refer:

 Lan‡ado em.:           Usu rio.:
 Impresso em:           com    processos.
 Mensagem...:


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 Emitidos:       Pagos:       Cancelados:
[Ÿ]
Inclus„o~~26006
Manuten‡„o~~27007
Consulta~~28008
[Ÿ]
 15 
 1 
Grupo/Circular

 1 
 2 
[Ÿ]
Circulares
Circulares







005
























 0 











 0 
 1 
-1 
-1 
 0 
-1 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
grupo
C
E
!!
 2 
 2 
 1 
 8 
 0 
Grupo

PTAB(grupo,'ARQGRUP',1).and.PTAB(ARQGRUP->classe,'CLASSES',1)
GRUPO ou Classe lan‡ada no Grupo|n„o existe na tabela.

Informe o grupo

 0 
 0 


circ
C
E
999
 3 
 3 
 1 
 21 
 0 
Circular
nivelop=3
 

STRZERO(VAL(ARQGRUP->proxcirc),3)
Informe o n£mero da CIRCULAR a emitir.
STRZERO(VAL(ARQGRUP->proxcirc),3)
 0 
 0 


procpend
N
V
99
 2 
 2 
 5 
 29 
 0 
Procpend






 0 
 0 


emissao_
D
E
@D
 8 
 10 
 2 
 15 
 0 
Emiss„o

!EMPT(emissao_)
Necess rio informar EMISSŽO
DATE()
Data da Emiss„o da Circular

 0 
 0 


mesref
C
E
@R 99/99
 4 
 5 
 2 
 39 
 0 
Mˆs Ref.

MMAA(mesref)
MES REF. n„o aceit vel
SUBSTR(DTOC(emissao_),4,2)+RIGHT(DTOC(emissao_),2)
Entre com o mˆs de referˆncia desta circular.

 0 
 0 


valor
N
E
@E 999,999.99
 9 
 10 
 3 
 21 
 2 
Valor

valor>0
VALOR n„o aceit vel



 0 
 0 


menscirc
C
E
 
 60 
 35 
 6 
 15 
 0 
Mensagem

 


Entre com uma mensagem exclusiva … ‚sta circular.

 0 
 0 


menscirc1
C
E
 
 35 
 35 
 7 
 15 
 0 
Mensagem

 


Entre com uma mensagem exclusiva … ‚sta circular.

 0 
 0 


menscirc2
C
E
 
 35 
 35 
 8 
 15 
 0 
Mensagem

 


Entre com uma mensagem exclusiva … ‚sta circular.

 0 
 0 


emitidos
N
I
999999
 6 
 6 
 10 
 11 
 0 
Emitidos






 0 
 0 


pagos
N
I
999999
 6 
 6 
 10 
 24 
 0 
Pagos






 0 
 0 


cancelados
N
I
999999
 6 
 6 
 10 
 42 
 0 
Cancelados






 0 
 0 


lancto_
D
V
@D
 8 
 10 
 4 
 15 
 0 
Lancamento






 0 
 0 


funcionar
C
V
 
 10 
 10 
 4 
 35 
 0 
Usu rio






 0 
 0 


impress_
D
V
@D
 8 
 10 
 5 
 15 
 0 
Impress„o






 0 
 0 


 1 
Descri‡„o
IIF(CLASSES->prior=[S],[Valor por mˆs......:],IIF(ARQGRUP->maxproc>ARQGRUP->acumproc,[Valor p/atendimento:],[Valor da circular.:]))

 3 
 2 
 18 

 0 
 0 
 0 
 0 
Application Internal Error - X:\hbranch\bpastor\recrip\161212\adrbig.EXE
Terminated at: 2016.12.12 17:08:41
Unrecoverable error 6005: Exception error:

    Exception Code:C0000005
    Exception Address:000A0000
    EAX:00750C70  EBX:00750C7C  ECX:08000000  EDX:00000208
    ESI:00000001  EDI:00000000  EBP:0022F8AC
    CS:EIP:001B:000A0000  SS:ESP:0023:0022F70C
    DS:0023  ES:0023  FS:003B  GS:0000
    Flags:00010246
    CS:EIP:
    SS:ESP: 004FBBA6 00750C7C 00000002 00000005 0022F8AC 00000000 00000001 00000001 00412867 0000002C 00000000 0000000A 0022F85C 005077C0 007507B4 0022F754

    C stack:
    EIP:     EBP:       Frame: OldEBP, RetAddr, Params...


Modules:
0x00400000 0x0024A000 X:\hbranch\bpastor\recrip\161212\adrbig.EXE
0x77630000 0x0013C000 C:\Windows\SYSTEM32\ntdll.dll
0x77780000 0x000D4000 C:\Windows\system32\kernel32.dll
0x75980000 0x0004A000 C:\Windows\system32\KERNELBASE.dll
0x77000000 0x000A0000 C:\Windows\system32\ADVAPI32.DLL
0x77580000 0x000AC000 C:\Windows\system32\msvcrt.dll
0x76030000 0x00019000 C:\Windows\SYSTEM32\sechost.dll
0x761C0000 0x000A1000 C:\Windows\system32\RPCRT4.dll
0x75CF0000 0x000C9000 C:\Windows\system32\USER32.dll
0x76120000 0x0004E000 C:\Windows\system32\GDI32.dll
0x76170000 0x0000A000 C:\Windows\system32\LPK.dll
0x77380000 0x0009D000 C:\Windows\system32\USP10.dll
0x76050000 0x0001F000 C:\Windows\system32\IMM32.DLL
0x75F60000 0x000CC000 C:\Windows\system32\MSCTF.dll

Called from DBUSEAREA(0)
Called from USEARQ(0) in adr_func.prg
Called from PEGA_SENHA(0) in ADRBIG.prg
Called from MAIN(0) in ADRBIG.prg
------------------------------------------------------------------------
procedure r02002f9
/*
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
 \ Empresa.: PresServ Inform tica-Limeira (019)452.6623
 \ Programa: R02002F9.PRG
 \ Data....: 22-09-97
 \ Sistema.: Administradora - RECEP€„O
 \ Funcao..: DECLARACAO do relat¢rio ADM_R020
 \ Analista: Ademilson Pedro Bom
 \ Criacao.: Programado manualmente pelo analista
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/

#include "adrbig.ch"    // inicializa constantes manifestas
li_aux:=[]
li_aux+=[     O Contratante (ou representante legal) responsabiliza-se pelas ]
li_aux+=[declara‡”es aqui prestadas e est  CIENTE de que qualquer informa‡„o FALSA ]
li_aux+=[importar  em responsabilidade criminal, nos termos do Artigo 299 do C¢digo ]
li_aux+=[Penal. Outrossim declara que tamb‚m est  ciente de que cada funeral d  o ]
li_aux+=[direito de REQUERER somente uma vez a referida Restitui‡„o de Despesas Funerais, ]
li_aux+=[e que n„o poder  existir nenhum outro requerimento feito com ]
li_aux+=[rela‡„o a este falecimento, nem por este contratante e nem por seus ]
li_aux+=[familiares, nem neste e nem em outro CONTRATO ]
li_aux+=[desta Organiza‡„o. Por fim, declara ainda que, se constatada a inexatid„o ]
li_aux+=[ou fraude nas informa‡”es aqui prestadas, al‚m de obrigar-se … devolu‡„o ]
li_aux+=[das importƒncias recebidas INDEVIDAMENTE, sujeitar-se-   s penalidades ]
li_aux+=[previstas no artigo 171 do C¢digo Penal.]

RETU M->li_aux      // <- deve retornar um valor qualquer

* \\ Final de R02002F9.PRG
GAS-Pro v4.0
009005022078001002005001011000176001
Hist ³ Descri‡„o de Hist¢rico                   ³D/C³ C/C ³R/D³ C¢digo
ÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÅÄÄÄÄÄÅÄÄÄÅÄÄÄÄÄÄÄÄ
     ³                                          ³   ³     ³   ³
     ³                                          ³   ³     ³   ³
     ³                                          ³   ³     ³   ³
     ³                                          ³   ³     ³   ³
     ³                                          ³   ³     ³   ³
     ³                                          ³   ³     ³   ³
     ³                                          ³   ³     ³   ³
     ³                                          ³   ³     ³   ³
     ³                                          ³   ³     ³   ³
     ³                                          ³   ³     ³   ³
[Ÿ]
Inclus„o~~26006
Manuten‡„o~~27007
Consulta~~28008
[Ÿ]
 6 
 2 
Por C¢digo

 1 
[Ÿ]
C¢digo Estruturado

 6 
[Ÿ]
Hist¢rico Padr„o
Hist¢rico Padr„o

origem=[ADM]
Registro utilizado por outro Sistema
orimgem=[ADM]
Registro mantido por outro sistema


005
























 0 











 0 
 1 
-1 
-1 
-1 
-1 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
historico
C
E
999
 3 
 3 
 3 
 2 
 0 
Hist

!EMPT(HISTORICO)
Este ‚ um campo de preenchimento obrigat¢rio.

Entre com um c¢digo para identificar| este hist¢rico.

 0 
 1 


descricao
C
E
 
 40 
 40 
 3 
 8 
 0 
Descri‡„o de Hist¢rico
!EMPTY(historico)
!EMPT(DESCRICAO)
Informe uma DESCRI€ŽO para este c¢digo.

Entre com a identifica‡ao do Hist¢rico.|Ex.:Cheque, Dep¢sito, Pgto de Duplic., etc...

 0 
 0 


tipo
C
E
!
 1 
 1 
 3 
 51 
 0 
D/C
!EMPTY(historico)
EMPTY(TIPO).OR.tipo$[DC]
 necess rio informar se TIPO ‚ D‚bito ou Cr‚dito.|D p/Pagamentos e C para recebimentos.

Este hist¢rico ‚ um D‚bito ou Cr‚dito|Se for D‚b., reduzir  no saldo da conta de|lan‡amento e acrescido na de baixa.
MTAB('D‚bito|Cr‚dito',[TIPO])
 0 
 0 


origem
C
E
!!!
 3 
 3 
 3 
 55 
 0 
C/C

 


Informe o prefixo do sistema que|gerou o lan‡amento|O Centro de Custo
MTAB([ADMinistradora|FUNer ria|CONvenio|ESToque|FINanceiro|VIAtura],[ORIGEM])
 0 
 0 


recdesp
C
E
!
 1 
 1 
 3 
 61 
 0 
R/D

recdesp $ [RDT]
Receita/Despesa n„o aceit vel

 Receita ou Despesa
MTAB([Receita|Despesa|Transferˆncia],[R/D])
 0 
 0 


codigo
C
E
@!
 6 
 6 
 3 
 65 
 0 
C¢digo

 


Informe o c¢digo estruturado|para os lan‡amentos com |este hist¢rico.

 0 
 0 


 0 
 0 
 0 
 2 
PRCESSOS
1
 13 
1=3 //

 0 



processo
C



categ
C



saiu
C



grup
C



num
C



grau
C



seq
N



seg
C



ends
C



cids
C



fal
C



sep
C



dfal
D



TAXAS
1
 13 
1=3

 0 



codigo
C



tipo
C



circ
C



emissao_
D



valor
N



pgto_
D



valorpg
N



cobrador
C



forma
C



baixa_
D



por
C



stat
C



filial
C



 0 
procedure dci03f9
/*
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
 \ Empresa.: PresServ Inform tica-Limeira (019)452.6623
 \ Programa: DCI03F9.PRG
 \ Data....: 29-08-97
 \ Sistema.: Administradora - RECEP€„O
 \ Funcao..: F¢rmula (Tipo do docto) a mostrar na tela de DCI_P001
 \ Analista: Ademilson Pedro Bom
 \ Criacao.: Programado manualmente pelo analista
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/

#include "adrbig.ch"    // inicializa constantes manifestas
PARA tipdoc
PRIVA donex:=[ ]
DO CASE
// ADRBIG - Programa da Recepcao
 CASE tipdoc= [BXR]
  donex:=[Baixa na Recep‡„]
 CASE tipdoc= [OBX]
  donex:=[Outros recebimentos]
 CASE tipdoc= [AFU]
  donex:=[Aux¡lio Funeral]

// ADCBIG - Programa de Credito e Cobran‡a
 CASE tipdoc= [BXF]
  donex:=[Baixa por FCC]

// CONBIG - Programa de Guias de convˆnio
 CASE tipdoc= [GUI]
  donex:=[Guia de Convˆnio]

// FUNBIG - Programa de Funer ria
 CASE tipdoc= [CAD]
  donex:=[Processo de Atendimento]
 CASE tipdoc= [PCO]
  donex:=[Pedido de Coroa]
 CASE tipdoc= [REC]
  donex:=[Recibo de Atendimento]
 CASE tipdoc= [RCO]
  donex:=[Recibo de Coroa]
 CASE tipdoc= [NFI]
  donex:=[Nota Fiscal]
OTHERWISE
 donex:=[N„o cadastrado]
ENDCASE

RETU       // <- deve retornar um valor qualquer

* \\ Final de DCI03F9.PRG
procedure contab
? "Programa para transferencia de arquivos"
? 
? "Informe sua senha para iniciar o programa"
cl= row()
senha="      "
set console off

@ cl,10 get senha
read
set console on
if senha#"123456"
 retu
endif
? " Abrindo arquivo de recebimentos"
use f:\vip4\arquivos\bxrec shared
? " Reorganizando arquivo"
set inde to f:\vip4\indices\bxr_serv
? " Criando arquivo tempor rio"
copy to f:\vip41\bxrtmp
use f:\vip41\arquivos\bxrec
? " Fazendo c¢pia de seguranca"
copy to bxrold
? " Acrescentando arquivo temporario"
appe from f:\vip41\bxrtmp
set uniq on
? " Verificando as duplicidades"
inde on ano+numero to bxrec
copy to f:\vip41\bxrok
use f:\vip41\bxrok
? " Reposicionando o arquivo correto"
copy to f:\vip41\arquivos\bxrec
? " Procedimento de finaliza‡Æo"
BLINKER INCREMENTAL OFF
BLINKER OVERLAY UMB ON
BLINKER OVERLAY PAGEFRAME ON
BLINKER CACHE EMS 50%
BLINKER CACHE XMS 50%
BLINKER OVE OPS 60
BLINKER EXECUTABLE CLIPPER F200
BLINKER MESSAGE NOBLINK


MAP S,A
OUTPUT adrbig
STACK 10240


FI ADrBIG
fi sixuk
fi smt
fi sixcdx
fi sixtools
LIB GASPRO52

beginarea
FI BXR_07F9
FI BXR_06F9
FI BXR_02F9
FI BXR_01F9
FI BXREC
FI ALE_01F9
FI ALENDER
FI OBX_07F9
FI OBX_01F9
FI OBXEC
FI GRU_01F9
FI GRU_02F9
FI GRUPOS
FI CTAINSC
FI CTXAS
FI TAX_02F9
FI INS_01F9
FI INS_02F9
FI GUI_07F9
FI GUI_06F9
FI GUI_08F9
FI GUI_02F9
FI GUIAS
FI MFILIAL
FI ADP_R101
FI ADC_RX76
FI CAD_04F9
FI KINSCF9
FI AFUNER
FI R02001F9
FI R02002F9
FI ADM_R020
FI V02001F9
FI V02002F9
FI R02901F9
FI ADR_R029
FI RX2001F9
FI RX2002F9
FI ADM_RX20
FI RX2901F9
FI ADR_RX29
FI ADM_R029
FI ADM_R026
FI ADM_R021
FI DCI_P001
FI DCI01F9
FI DCI03F9
FI DCI04F9
FI ADM_RS18
FI V01801F9
FI ADM_R023
FI V02301F9
FI ADM_R022
FI R03001F9
FI ADM_R039
FI IMP_01F9
FI IMPPAR
FI MEDICOS
FI TESPEC
FI JUROS
FI TFILIAIS
FI ARQGRUP
FI REGIAO
FI COB_01F9
FI COBRADOR
FI CLASSES
FI CIRCULAR
FI PRCESSOS
FI FNCS
FI HISTORIC
FI CSTSEG
FI MEN_01F9
FI MENSAG
FI ORDPGRC
FI PAR_ADM
FI ADR_ESTR
FI ADR_ATRI
FI ADR_ATR1
FI ADR_ATR2
FI ADR_MENU
FI ADR_MANU
FI CON_RX01
FI ABOUT
endarea
FI ADR_PROC
FI ADR_FUNC
FI ADR_FUN2
FI ADR_OUTR

@CL520MID.LNK
@SIX3.LNK

procedure r07701f9
/*
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
 \ Empresa.: PresServ Inform tica-Limeira (019)452.6623
 \ Programa: R07701F9.PRG
 \ Data....: 26-12-97
 \ Sistema.: Administradora -CRD/COBRAN€A
 \ Funcao..: Express„o de filtro do relat¢rio ADC_R077.PRG
 \ Analista: Ademilson Pedro Bom
 \ Criacao.: Programado manualmente pelo analista
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/

#include "adRbig.ch"    // inicializa constantes manifestas
donex:=(M->pag=[S].AND.TAXAS->valorpg>0)
donex:=donex.OR.(M->pend=[S].AND.TAXAS->valorpg=0)
//donex:=donex.AND.(EMPT(M->veni_).OR.TAXAS->emissao_>=M->veni_)
donex:=donex.AND.(EMPT(M->venf_).OR.TAXAS->emissao_<=M->venf_)

RETU M->donex       // <- deve retornar um valor L¢GICO

* \\ Final de R07701F9.PRG
procedure gui_08f9
/*
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
 \ Empresa.: PresServ Inform tica - Limeira (019)452.6623
 \ Programa: GUI_08F9.PRG
 \ Data....: 23-05-98
 \ Sistema.: Administradora - RECEP€„O
 \ Funcao..: Fun‡„o de preenchimento do campo m‚dico, arquivo GUIAS
 \ Analista: Ademilson Pedro Bom
 \ Criacao.: Programado manualmente pelo analista
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/

#include "adrbig.ch"    // inicializa constantes manifestas

//LOCAL reg_dbf:=POINTER_DBF()

PRIVA respx:=SPACE(10),nomx:=space(35)
PTAB([],[MEDICOS],1,.t.)
IF EMPT(medico).and.op_menu=INCLUSAO
 nomx=DBOX("Nome",,,,,"Informe o nome a procurar",nomx,"@!")
 IF PTAB(alltrim(nomx),[MEDICOS],2)
  medico:=MEDICOS->codbenefic
 ELSEIF PTAB(alltrim(nomx),[MEDICOS],3)
  medico:=MEDICOS->codbenefic
 ENDI
 Codbenefic=MEDICO
 Codbenefic:=VDBF(6,3,20,77,'MEDICOS',{'LEFT(oldespec,20)','nome','endereco','cidade','codbenefic','fonesdiv','fonecom1'},3,'codbenefic',[])
 MEDICO=Codbenefic
 IF LASTKEY()=K_ESC             // se teclou ESC
	medico=space(10)
//	POINTER_DBF(reg_dbf)
	RETU .f.
 ENDI
ELSE
 retur .t.
ENDI
respx:=medico
//dbox([>]+respx+[<])
//POINTER_DBF(reg_dbf)

retu PTAB(respx,[MEDICOS],1)  // <- deve retornar um valor qualquer

* \\ Final de GUI_02F9.PRG
GAS-Pro v3.0
011003022079083001150001012000176001
[Ÿ]
 5 
CPRCIRC
Processos (2¦ via)
grupo+circ
grupo+circ+DTOS(dfal)

011









 0 
 0 
 0 
 48 
 1 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
-1 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
Processo
processo
 
 9 
C
 1 
 42 


          










Contrato
num

 5 
C
 1 
 31 


          










Falecido
fal

 35 
C
 1 
 55 


          










Ends
ALLTRIM(ends)+'-'+ALLTRIM(cids)
@!
 40 
C
 1 
 92 


          










Data
dfal
@D
 8 
D
 1 
 150 


          










 9 
Nome da empresa
nemp

 0 
 0 
 32 

T¡tulo aplica‡„o
nsis

 0 
 0 
 25 

Data do sistema
DTOC(DATE())

 0 
 0 
 8 

Nome do mˆs
NMES(DATE())

 0 
 0 
 8 

Dia da semana
NSEM(DATE())

 0 
 0 
 7 

N£mero da p gina
TRAN(pg_,'9999')

 0 
 0 
 4 

C¢digo relat¢rio
"ADM_R019"

 0 
 0 
 8 

T¡tulo a definir
titrel

 0 
 0 
 30 

Hora da emiss„o
hora_rel_

 0 
 0 
 5 

 0 
 0 
 0 
 0 
procedure r04201f9
/*
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
 \ Empresa.: PresServ Inform tica-Limeira (019)452.6623
 \ Programa: R04201F9.PRG
 \ Data....: 22-06-97
 \ Sistema.: Administradora - PLANO
 \ Funcao..: qualif do relat¢rio ADM_R042
 \ Analista: Ademilson Pedro Bom
 \ Criacao.: Programado manualmente pelo analista
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/

#include "adpbig.ch"    // inicializa constantes manifestas

DO CASE
CASE INSCRITS->grau = [1]
 RETU [Titular]
CASE INSCRITS->grau = [2]
 RETU [Pai]
CASE INSCRITS->grau = [3]
 RETU [Mae]
CASE INSCRITS->grau = [4]
 RETU [Sogro]
CASE INSCRITS->grau = [5]
 RETU [Sogra]
CASE INSCRITS->grau = [6]
 RETU [Conjuge]
CASE INSCRITS->grau = [7]
 RETU [Filho]
CASE INSCRITS->grau = [8]
 RETU [Depend.]
ENDC
RETU []    // <- deve retornar um valor qualquer

* \\ Final de R04201F9.PRG
procedure bxross
/*
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
 \ Empresa.: PresServ Inform tica -Limeira (019)452.6623
 \ Programa: BXREC.PRG
 \ Data....: 12-04-98
 \ Sistema.: Administradora - RECEP€„O
 \ Funcao..: Gerenciador do subsistema de recebimento de taxas
 \ Analista: Ademilson Pedro Bom
 \ Criacao.: GAS-Pro v3.0 
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/

#include "adrbig.ch"    // inicializa constantes manifestas

PARA lin_menu,col_menu
PRIV op_sis, tela_fundo:=SAVESCREEN(0,0,MAXROW(),79)
op_sis=EVAL(qualsis,"BXREC")
IF nivelop<sistema[op_sis,O_OUTROS,O_NIVEL]        // se usuario nao tem permissao,
 ALERTA()                                          // entao, beep, beep, beep
 DBOX(msg_auto,,,3)                                // lamentamos e
 RETU                                              // retornamos ao menu
ENDI
cn:=fgrep :=.f.

#ifdef COM_LOCK
 IF LEN(pr_ok)>0                                   // se a protecao acusou
  ? pr_ok                                          // erro, avisa e
  QUIT                                             // encerra a aplicacao
 ENDI
#endi

t_fundo=SAVESCREEN(0,0,MAXROW(),79)                // salva tela do fundo
op_cad=1
DO WHIL op_cad!=0
 criterio=""
 RESTSCREEN(,0,MAXROW(),79,t_fundo)                // restaura tela do fundo
 cod_sos=5 ; cn=.f.
 CLEA TYPEAHEAD                                    // limpa o buffer do teclado
 fgrep=.f.
 SET KEY K_F3 TO                                   // retira das teclas F3 e F4 as
 SET KEY K_F4 TO                                   // funcoes de repeticao e confirmacao
 msg="Inclus„o|"+;
     "Manuten‡„o|"+;
     "Consulta"
 op_cad=DBOX(msg,lin_menu,col_menu,E_MENU,NAO_APAGA,MAIUSC(sistema[op_sis,O_MENU]),,,op_cad)
 IF op_cad!=0                                      // se escolheu uma opcao
  Tela_fundo=SAVESCREEN(0,0,MAXROW(),79)           // salva a tela para ROLATELA()
  SELE A                                           // e abre o arquivo e seus indices

  #ifdef COM_REDE
   IF !USEARQ(sistema[op_sis,O_ARQUI],.f.,20,1)    // se falhou a abertura do
    RETU                                           // arquivo volta ao menu anterior
   ENDI
  #else
   USEARQ(sistema[op_sis,O_ARQUI])
  #endi

  SET KEY K_F9 TO veoutros                         // habilita consulta em outros arquivos
 ENDI
 DO CASE
  CASE op_cad=01                                   // inclus„o
   op_menu=INCLUSAO
   IF AT("D",exrot[op_sis])=0                      // se usuario pode fazer inclusao
    BXR_INCL()                                     // neste arquivo chama prg de inclusao
   ELSE                                            // caso contrario vamos avisar que
    ALERTA()                                       // ele nao tem permissao para isto
    DBOX(msg_auto,,,3)
   ENDI

  CASE op_cad=02                                   // manuten‡„o
   op_menu=ALTERACAO
   cod_sos=7
   EDIT()

  CASE op_cad=03                                   // consulta
   op_menu=PROJECOES
   cod_sos=8
   EDITA(3,3,MAXROW()-2,77)

 ENDC
 SET KEY K_F9 TO                                   // F9 nao mais consultara outros arquivos
 CLOS ALL                                          // fecha todos arquivos abertos
ENDD
RETU

PROC BXR_incl     // inclusao no arquivo BXREC
LOCAL getlist:={},cabem:=1,rep:=ARRAY(FCOU()),ult_reg:=RECN(),dbfseq_,;
      ctl_r, ctl_c, ctl_w, t_f3_, t_f4_, dele_atu:=SET(_SET_DELETED,.f.)
PRIV op_menu:=INCLUSAO, sq_atual_, tem_borda, criterio:="", cpord:=""
FOR i=1 TO FCOU()                                  // cria/declara privadas as
 msg=FIEL(i)                                       // variaveis de memoria com
 PRIV &msg.                                        // o mesmo nome dos campos
NEXT                                               // do arquivo
AFILL(rep,"")
t_f3_=SETKEY(K_F3,{||rep()})                       // repeticao reg anterior
t_f4_=SETKEY(K_F4,{||conf()})                      // confirma campos com ENTER
ctl_w=SETKEY(K_CTRL_W,{||nadafaz()})               // enganando o CA-Clipper...
ctl_c=SETKEY(K_CTRL_C,{||nadafaz()})
ctl_r=SETKEY(K_CTRL_R,{||nadafaz()})

#ifdef COM_REDE
 BXR_CRIA_SEQ()                                    // cria dbf de controle de cp sequenciais
 FOR i=1 TO FCOU()                                 // cria/declara privadas as
  msg="sq_"+FIEL(i)                                // variaveis de memoria com
  PRIV &msg.                                       // o mesmo nome dos campos
 NEXT                                              // do arquivo com estensao _seq
#endi

DO WHIL cabem>0
 cod_sos=6
 rola_t=.f.                                        // flag se quer rolar a tela
 SELE BXREC
 GO BOTT                                           // forca o
 SKIP                                              // final do arquivo
 
 /*
    cria variaveis de memoria identicas as de arquivo, para inclusao
    de registros
 */
 FOR i=1 TO FCOU()
  msg=FIEL(i)
  M->&msg.=IF(fgrep.AND.!EMPT(rep[1]),rep[i],&msg.)
 NEXT
 DISPBEGIN()                                       // apresenta a tela de uma vez so
 BXR_TELA()
 INFOSIS()                                         // exibe informacao no rodape' da tela
 DISPEND()
 BXR_GERA_SEQ()
 cabem=DISKSPACE(IF(LEN(drvdbf)<2.OR.drvdbf="\",0,ASC(drvdbf)-64))
 cabem=INT((cabem-2048)/BXREC->(RECSIZE()))
 IF cabem<1                                        // mais nenhum!!!
  ALERTA()
  msg="Verifique ESPA€O EM DISCO, "+usuario
  DBOX(msg,,,,,"INCLUSŽO INTERROMPIDA!")           // vamos parar por aqui!
  EXIT
 ENDI
 M->ano=LPAD(RIGHT(DTOC(DATE()),2),02,[0])
 SELE 0                                            // torna visiveis variaveis de memoria
 BXR_GET1(INCLUI)                                  // recebe campos
 SELE BXREC
 IF LASTKEY()=K_ESC                                // se cancelou
  cabem=0
  LOOP
 ENDI

 #ifdef COM_REDE
  GO BOTT                                          // vamos bloquear o final do
  SKIP                                             // arq para que nehum outro
  BLOREG(0,.5)                                     // usuario possa incluir
 #endi

 APPEND BLANK                                      // inclui reg em branco no dbf
 FOR i=1 TO FCOU()                                 // para cada campo,
  msg=FIEL(i)                                      // salva o conteudo
  rep[i]=M->&msg.                                  // para repetir
  REPL &msg. WITH rep[i]                           // enche o campo do arquivo
 NEXT

 #ifdef COM_REDE
  UNLOCK                                           // libera o registro e
  COMMIT                                           // forca gravacao
 #else
  IF RECC()-INT(RECC()/20)*20=0                    // a cada 20 registros
   COMMIT                                          // digitados forca gravacao
  ENDI
 #endi

 ult_reg=RECN()                                    // ultimo registro digitado
 BXR_REL(ult_reg)                               // imprime relat apos inclusao
ENDD

#ifdef COM_REDE
 BXR_ANT_SEQ()                                     // restaura sequencial anterior
 SELE BXREC
#endi

GO ult_reg                                         // para o ultimo reg digitado
SETKEY(K_F3,t_f3_)                                 // restaura teclas de funcoes
SETKEY(K_F4,t_f4_)
SET(_SET_DELETED,dele_atu)                            // ecluidos visiveis/invisiveis
SETKEY(K_CTRL_W,ctl_w)
SETKEY(K_CTRL_C,ctl_c)
SETKEY(K_CTRL_R,ctl_r)
RETU

PROC BXR_REL(ult_reg)  // imprime relatorio apos inclusao
op_=1
msg_t="TAXAS (RECEP€ŽO)"
msg="Autentica‡„o|Recibo"
op_=DBOX(msg,,,E_MENU,,msg_t,,,2)  // quer emitir outra copia?
if op_ = 2
 DO WHIL .t.
  msg_t="RECEBIMENTOS"
  SAVE SCREEN                     // salva a tela

  #ifdef COM_REDE
    tps=TP_SAIDA(,,.t.)            // escolhe a impressora
    IF LASTKEY()=K_ESC             // se teclou ESC
     EXIT                          // cai fora...
    ENDI
    IF tps=2 .OR. PREPIMP(msg_t)   // se nao vai para video conf impressora pronta
     ADR_R067(tps,0,ult_reg)
  #else
   IF PREPIMP(msg_t)              // confima preparacao da impressora
    ADM_R067(0,0,ult_reg)
  #endi

   REST SCREEN                    // restaura tela
   msg="Prosseguir|Outra c¢pia"
   op_=DBOX(msg,,,E_MENU,,msg_t)  // quer emitir outra copia?
   IF op_=2
    LOOP                          // nao quer...
   ENDI
  ENDI
  EXIT
 ENDD
ELSEIF op_ = 1

 DO WHIL .t.
  msg_t="TAXAS (RECEP€ŽO)"
  SAVE SCREEN                     // salva a tela

  #ifdef COM_REDE
    tps:=1

   IF tps=2 .OR. 1=1 //PREPIMP(msg_t)   // se nao vai para video conf impressora pronta
    op_=2
    msg="Fita|Autenticar|Sair"
    op_=DBOX(msg,,,E_MENU,,msg_t,,,2)  // quer emitir outra copia?
    if op_=1.or.op_=2
     arq_=drvporta                                    // porta de saida configurada
     SET PRINTER TO (arq_)                             // redireciona saida
     SET DEVI TO PRIN                                   // inicia a impressao

     IMPCTL(drvpcom)

     cl:=PROW()
/*
     IF ORDPGRC->nrdoctos=1.AND.op_<2
      cl+=2
      @ cl,000 SAY [CAIXA: ]+TRAN(numop,"999999")	      // N§ O.P.
      @ cl,014 SAY TRAN(ORDPGRC->lancto_,"@D")               // Emitido em
      cl+=1
      @ cl,000 SAY [Oper.: ]+ORDPGRC->por
      cl+=1
      @ cl,000 SAY [Saldo: ]+TRAN(ORDPGRC->valortotal-valorpg,"@E 999,999.99")
      cl+=1
     ENDI
*/
     @ cl,000 SAY TRAN(ORDPGRC->nrdoctos,"9999")               // Emitido em
     @ cl,005 SAY TRAN(DATE(),"@D")               // Emitido em
     @ cl,013 SAY LEFT(TIME(),5)               // Emitido em
 //    @ cl,018 SAY TRAN(numero,"999999")             // Numero
     @ cl,018 SAY TRAN(codigo,"999999")             // Codigo
     @ cl,025 SAY TRAN(tipo,"!")                    // Tipo
     @ cl,026 SAY TRAN(circ,"999")                  // Circular
     @ cl,029 SAY TRAN(valorpg,"@E 99,999.99")     // Valor pago
 //    @ cl,046 SAY TRAN(numop,"999999")              // N§ O.P.
 //    @ cl,053 SAY M->usuario              // N§ O.P.

     IMPCTL(drvtcom)                                    // retira comprimido
     SET PRINTER TO (drvporta)                          // fecha arquivo gerado (se houver)
     SET DEVI TO SCRE                                   // direciona saida p/ video
    endi
   ENDI

  #endi

   REST SCREEN                    // restaura tela
   IF op_=2
    LOOP                          // nao quer...
   ENDI
   if op_=1
    SET PRINTER TO (arq_)                             // redireciona saida
    SET DEVI TO PRIN                                   // inicia a impressao
    cl+=1
    @ cl,000 SAY []
    SET PRINTER TO (drvporta)                          // fecha arquivo gerado (se houver)
    SET DEVI TO SCRE                                   // direciona saida p/ video
   endi
  EXIT
 ENDD
endi


RETU


#ifdef COM_REDE
 PROC BXR_ANT_SEQ(est_seq)     // restaura sequencial anterior
 SELE BXR_SEQ     // seleciona arquivo de controle de sequencial
 BLOARQ(0,.5)     // esta estacao foi a ultima a incluir?
 IF sq_atual_ == numero
  REPL numero WITH sq_numero
  REPL intlan WITH sq_intlan
 ENDI
 UNLOCK           // libera DBF para outros usuarios
 COMMIT           // atualiza cps sequenciais no disco
 RETU
#endi


PROC BXR_CRIA_SEQ   // cria dbf de controle de campos sequenciais
LOCAL dbfseq_:=drvdbf+"BXR_seq" // arq temporario
SELE 0                          // seleciona area vazia
IF !FILE(dbfseq_+".dbf")        // se o dbf nao existe
 DBCREATE(dbfseq_,{;            // vamos criar a sua estrutura
                    {"numero"    ,"C",  6, 0},;
                    {"intlan"    ,"C",  8, 0};
                  };
 )
ENDI
USEARQ(dbfseq_,.f.,,,.f.)       // abre arquivo de cps sequencial
IF RECC()=0                     // se o dbf foi criado agora
 BLOARQ(0,.5)                   // inclui um registro que tera
 APPEND BLANK                   // os ultomos cps sequenciais
 SELE BXREC
 IF RECC()>0                    // se o DBF nao estiver
  SET ORDER TO 0                // vazio, entao enche DBF seq
  GO BOTT                       // com o ultimo reg digitado
  REPL BXR_SEQ->numero WITH numero
  REPL BXR_SEQ->intlan WITH intlan
  SET ORDER TO 1                // retorna ao indice principal
 ENDI
 SELE BXR_SEQ                   // seleciona arq de sequencias
 UNLOCK                         // libera DBF para outros usuarios
 COMMIT                         // atualiza cps sequenciais no disco
ENDI
RETURN

PROC BXR_GERA_SEQ()

#ifdef COM_REDE
 LOCAL ar_:=SELEC()
#else
 LOCAL reg_:=RECNO(),ord_ind:=INDEXORD()
#endi


#ifdef COM_REDE
 SELE BXR_SEQ
 BLOARQ(0,.5)
 sq_numero=BXR_SEQ->numero
 sq_intlan=BXR_SEQ->intlan
#else
 SET ORDER TO 0
 GO BOTT
#endi

M->numero=LPAD(STR(VAL(numero)+1),06,[0])
M->intlan=LPAD(STR(VAL(intlan)+1),08,[0])

#ifdef COM_REDE
 BXR_GRAVA_SEQ()
 sq_atual_=BXR_SEQ->numero
 UNLOCK                                            // libera o registro
 COMMIT
 SELE (ar_)
#else
 DBSETORDER(ord_ind)
 GO reg_
#endi

RETU

PROC BXR_GRAVA_SEQ
REPL numero WITH M->numero
REPL intlan WITH M->intlan
RETU

PROC BXR_tela     // tela do arquivo BXREC
tem_borda=.t.
l_s=Sistema[op_sis,O_TELA,O_LS]           // coordenadas da tela
c_s=Sistema[op_sis,O_TELA,O_CS]
l_i=Sistema[op_sis,O_TELA,O_LI]
c_i=Sistema[op_sis,O_TELA,O_CI]
SETCOLOR(drvtittel)
vr_memo=NOVAPOSI(@l_s,@c_s,@l_i,@c_i)     // pega posicao atual da tela
CAIXA(mold,l_s,c_s,l_i,c_i)               // monta caixa da tela
i=LEN(sistema[op_sis,O_MENS])/2
@ l_s,c_s-1+(c_i-c_s+1)/2-i SAY " "+MAIUSC(sistema[op_sis,O_MENS])+" "
SETCOLOR(drvcortel)
@ l_s+01,c_s+1 SAY " Numero:   -      -                 (                                )"
@ l_s+02,c_s+1 SAY "ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ"
@ l_s+03,c_s+1 SAY " Inscri‡„o:"
@ l_s+05,c_s+1 SAY "ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ"
@ l_s+06,c_s+1 SAY " D‚bito:    N§:        Valor:               Pago com:"
@ l_s+07,c_s+1 SAY "                                            Troco...:"
@ l_s+08,c_s+1 SAY "ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ"
RETU

PROC BXR_gets     // mostra variaveis do arquivo BXREC
LOCAL getlist := {}, ord_, chv_, ar_get1:=ALIAS()
BXR_TELA()
SETCOLOR(drvcortel+","+drvcorget+",,,"+corcampo)
PTAB(CODIGO,'GRUPOS',1)
PTAB(IIF(EMPT(M->USUARIO),PADR(M->CONTAREC+IDE_MAQ,10,' '),PADR(M->USUARIO,10,' '))+M->HISTRCREC+[       ],'ORDPGRC',2)
PTAB(PADR(SUBSTR(M->IDE_MAQ,2),4)+[BXR],[IMPPAR],1)
CRIT("",,"4")
@ l_s+01 ,c_s+10 GET  ano;
                 PICT sistema[op_sis,O_CAMPO,01,O_MASC]

@ l_s+01 ,c_s+13 GET  numero;
                 PICT sistema[op_sis,O_CAMPO,02,O_MASC]

@ l_s+03 ,c_s+13 GET  codigo;
                 PICT sistema[op_sis,O_CAMPO,03,O_MASC]
                 CRIT(sistema[op_sis,O_CAMPO,03,O_CRIT],,"1|2")

@ l_s+06 ,c_s+10 GET  tipo;
                 PICT sistema[op_sis,O_CAMPO,04,O_MASC]

@ l_s+06 ,c_s+17 GET  circ;
		 PICT sistema[op_sis,O_CAMPO,05,O_MASC]

@ l_s+06 ,c_s+31 GET  valorpg;
                 PICT sistema[op_sis,O_CAMPO,06,O_MASC]

@ l_s+06 ,c_s+55 GET  valoraux;
                 PICT sistema[op_sis,O_CAMPO,07,O_MASC]
                 CRIT(sistema[op_sis,O_CAMPO,07,O_CRIT],,"3")

@ l_s+01 ,c_s+49 GET  emitido_;
                 PICT sistema[op_sis,O_CAMPO,08,O_MASC]

@ l_s+01 ,c_s+38 GET  por

@ l_s+01 ,c_s+64 GET  numop;
                 PICT sistema[op_sis,O_CAMPO,11,O_MASC]

CLEAR GETS
RETU

PROC BXR_get1     // capta variaveis do arquivo BXREC
LOCAL getlist := {}, ord_, chv_, ar_get1:=ALIAS()
PRIV  blk_bxrec:=.t.
PARA tp_mov
IF tp_mov=INCLUI
 DO WHILE .t.
  rola_t=.f.
  SET KEY K_ALT_F8 TO ROLATELA
  SETCOLOR(drvcortel+","+drvcorget+",,,"+corcampo)
  @ l_s+01 ,c_s+10 GET ano;
                   PICT sistema[op_sis,O_CAMPO,01,O_MASC]
  @ l_s+01 ,c_s+13 GET numero;
                   PICT sistema[op_sis,O_CAMPO,02,O_MASC]
  @ l_s+01 ,c_s+49 GET emitido_;
                   PICT sistema[op_sis,O_CAMPO,08,O_MASC]
  @ l_s+01 ,c_s+38 GET por
  @ l_s+01 ,c_s+64 GET numop;
                   PICT sistema[op_sis,O_CAMPO,11,O_MASC]
  CLEA GETS
  CRIT("",,"4")
  @ l_s+03 ,c_s+13 GET  codigo;
                   PICT sistema[op_sis,O_CAMPO,03,O_MASC]
                   DEFINICAO 3
                   MOSTRA sistema[op_sis,O_FORMULA,1]
                   MOSTRA sistema[op_sis,O_FORMULA,2]

  @ l_s+06 ,c_s+10 GET  tipo;
                   PICT sistema[op_sis,O_CAMPO,04,O_MASC]
                   DEFINICAO 4

  @ l_s+06 ,c_s+17 GET  circ;
                   PICT sistema[op_sis,O_CAMPO,05,O_MASC]
                   DEFINICAO 5

  @ l_s+06 ,c_s+31 GET  valorpg;
                   PICT sistema[op_sis,O_CAMPO,06,O_MASC]
                   DEFINICAO 6

  @ l_s+06 ,c_s+55 GET  valoraux;
                   PICT sistema[op_sis,O_CAMPO,07,O_MASC]
                   DEFINICAO 7
		   MOSTRA sistema[op_sis,O_FORMULA,3]

  READ
  SET KEY K_ALT_F8 TO
  IF rola_t
   ROLATELA()
   LOOP
  ENDI
  IF LASTKEY()!=K_ESC .AND. drvincl .AND. op_menu=INCLUSAO
   IF !CONFINCL()
    LOOP
   ENDI
  ENDI
  EXIT
 ENDD
ENDI
PTAB(CODIGO,'GRUPOS',1)
PTAB(CODIGO,'TAXAS',1)
PTAB(CODIGO+TIPO+CIRC,'TAXAS',1)
PTAB(IIF(EMPT(M->USUARIO),PADR(M->CONTAREC+IDE_MAQ,10,' '),PADR(M->USUARIO,10,' '))+M->HISTRCREC+[       ],'ORDPGRC',2)
PTAB(PADR(SUBSTR(M->IDE_MAQ,2),4)+[BXR],[IMPPAR],1)
IF tp_mov=EXCLUI .OR. tp_mov=FORM_INVERSA

 #ifdef COM_REDE
  IF PTAB(numop,'ORDPGRC',1)
   REPBLO('ORDPGRC->valortotal',{||ORDPGRC->valortotal -valorpg})
   REPBLO('ORDPGRC->nrdoctos',{||ORDPGRC->nrdoctos - 1})
  ENDI
  IF !EMPT(valorpg)
   REPBLO('TAXAS->pgto_',{||CTOD('  /  /  ')})
   REPBLO('TAXAS->forma',{||[ ]})
   REPBLO('TAXAS->baixa_',{||CTOD('  /  /  ')})
   REPBLO('TAXAS->stat',{||[ ]})
   REPBLO('TAXAS->valorpg',{||0})
  ENDI
 #else
  IF PTAB(numop,'ORDPGRC',1)
   REPL ORDPGRC->valortotal WITH ORDPGRC->valortotal -valorpg
   REPL ORDPGRC->nrdoctos WITH ORDPGRC->nrdoctos - 1
  ENDI
  IF !EMPT(valorpg)
   REPL TAXAS->pgto_ WITH CTOD('  /  /  ')
   REPL TAXAS->forma WITH [ ]
   REPL TAXAS->baixa_ WITH CTOD('  /  /  ')
   REPL TAXAS->stat WITH [ ]
   REPL TAXAS->valorpg WITH 0
  ENDI
 #endi

 IF 1=3
  IF !EMPTY(ORDPGRC->codlan)
   TIRA_LANC("ORDPGRC",LEFT(ORDPGRC->codlan,16),.f.)
  ENDI
 ENDI
 IF 1=3
  IF !EMPTY(IMPPAR->codlan)
   TIRA_LANC("IMPPAR",LEFT(IMPPAR->codlan,16))
  ENDI
 ENDI
 DELE
ELSEIF tp_mov=INCLUI .OR. tp_mov=RECUPERA .OR. tp_mov=FORM_DIRETA
 IF (op_menu=INCLUSAO .AND. LASTKEY()!=K_ESC) .OR. op_menu!=INCLUSAO
  IF !PTAB(IIF(EMPT(M->usuario),PADR(M->contarec+ide_maq,10,' '),PADR(M->usuario,10,' '))+M->histrcrec+[       ],'ORDPGRC',2)
   ord_=LEN(sistema[EVAL(qualsis,"ORDPGRC"),O_CHAVE])
   chv_="BXR-"+intlan+"-001"
   PTAB(chv_,"ORDPGRC",ord_)
   FAZ_LANC("ORDPGRC",chv_,.t.)
   REPL ORDPGRC->origem WITH [ADM],;
        ORDPGRC->lancto_ WITH DATE(),;
        ORDPGRC->por WITH M->usuario,;
        ORDPGRC->numconta WITH IIF(EMPT(M->usuario),PADR(M->contarec+ide_maq,10,' '),PADR(M->usuario,10,' ')),;
        ORDPGRC->historico WITH M->histrcrec,;
        ORDPGRC->debcred WITH [C],;
	ORDPGRC->valortotal WITH 0,;
        ORDPGRC->vencto_ WITH DATE(),;
	ORDPGRC->documento WITH [FCC/Taxas],;
        ORDPGRC->complement WITH [FCC/Taxas pagas na Recep‡„o]

   #ifdef COM_REDE
    ORDPGRC->(DBUNLOCK())                          // libera o registro
   #endi

  ENDI
  IF !PTAB(PADR(SUBSTR(M->ide_maq,2),4)+[BXR],[IMPPAR],1)
   ord_=LEN(sistema[EVAL(qualsis,"IMPPAR"),O_CHAVE])
   chv_="BXR-"+intlan+"-002"
   PTAB(chv_,"IMPPAR",ord_)
   FAZ_LANC("IMPPAR",chv_)
   REPL IMPPAR->idmaq WITH PADR(SUBSTR(M->ide_maq,2),4),;
        IMPPAR->base WITH [BXR]

   #ifdef COM_REDE
    IMPPAR->(DBUNLOCK())                           // libera o registro
   #endi

  ENDI
   IF EMPT(numop)
    IF op_menu=INCLUSAO
     numop=ORDPGRC->numop
    ELSE
     REPL numop WITH ORDPGRC->numop
    ENDI
   ENDI

  #ifdef COM_REDE
   IF PTAB(numop,'ORDPGRC',1)
    REPBLO('ORDPGRC->valortotal',{||ORDPGRC->valortotal +valorpg})
    REPBLO('ORDPGRC->nrdoctos',{||ORDPGRC->nrdoctos + 1})
   ENDI
   IF !EMPT(valorpg)
    REPBLO('TAXAS->pgto_',{||DATE()})
    REPBLO('TAXAS->forma',{||[P]})
    REPBLO('TAXAS->baixa_',{||DATE()})
    REPBLO('TAXAS->por',{||M->usuario})
    REPBLO('TAXAS->stat',{||[6]})
    REPBLO('TAXAS->valorpg',{||valorpg})
   ENDI
   IF op_menu=INCLUSAO
    emitido_=DATE()
   ELSE
    REPL emitido_ WITH DATE()
   ENDI
   IF op_menu=INCLUSAO
    por=M->usuario
   ELSE
    REPL por WITH M->usuario
   ENDI
   IF op_menu=INCLUSAO
    hemit=TIME()
   ELSE
    REPL hemit WITH TIME()
   ENDI
   IF op_menu=INCLUSAO
    filial=M->p_filial
   ELSE
    REPL filial WITH M->p_filial
   ENDI
   IF PTAB(PADR(SUBSTR(M->ide_maq,2),4)+[BXR],[IMPPAR],1)
    REPBLO('IMPPAR->docto',{||ano+numero})
   ENDI
  #else
   IF EMPT(numop)
    IF op_menu=INCLUSAO
     numop=ORDPGRC->numop
    ELSE
     REPL numop WITH ORDPGRC->numop
    ENDI
   ENDI
   IF PTAB(numop,'ORDPGRC',1)
    REPL ORDPGRC->valortotal WITH ORDPGRC->valortotal +valorpg
    REPL ORDPGRC->nrdoctos WITH ORDPGRC->nrdoctos + 1
   ENDI
   IF !EMPT(valorpg)
    REPL TAXAS->pgto_ WITH DATE()
    REPL TAXAS->forma WITH [P]
    REPL TAXAS->baixa_ WITH DATE()
    REPL TAXAS->por WITH M->usuario
    REPL TAXAS->stat WITH [6]
    REPL TAXAS->valorpg WITH valorpg
   ENDI
   IF op_menu=INCLUSAO
    emitido_=DATE()
   ELSE
    REPL emitido_ WITH DATE()
   ENDI
   IF op_menu=INCLUSAO
    por=M->usuario
   ELSE
    REPL por WITH M->usuario
   ENDI
   IF op_menu=INCLUSAO
    hemit=TIME()
   ELSE
    REPL hemit WITH TIME()
   ENDI
   IF op_menu=INCLUSAO
    filial=M->p_filial
   ELSE
    REPL filial WITH M->p_filial
   ENDI
   IF PTAB(PADR(SUBSTR(M->ide_maq,2),4)+[BXR],[IMPPAR],1)
    REPL IMPPAR->docto WITH ano+numero
   ENDI
  #endi

  IF op_menu!=INCLUSAO
   RECA
  ENDI
 ENDI
ENDI
RETU

* \\ Final de BXREC.PRG
procedure adm_r026
/*
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
 \ Empresa.: PresServ Inform tica - Limeira (019)452.6623
 \ Programa: ADM_R026.PRG
 \ Data....: 04-11-03
 \ Sistema.: Administradora - RECEP€„O
 \ Funcao..: Capa de Processo
 \ Analista: Ademilson Pedro Bom
 \ Criacao.: GAS-Pro v4.0n
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/

#include "adrbig.ch"    // inicializa constantes manifestas

PRIV dele_atu, cur_atual, getlist:={}
PARA lin_menu, col_menu
PRIV  tem_borda:=.t., op_menu:=VAR_COMPL, l_s:=10, c_s:=20, l_i:=13, c_i:=61, tela_fundo:=SAVESCREEN(0,0,MAXROW(),79)
nucop=1
SETCOLOR(drvtittel)
vr_memo=NOVAPOSI(@l_s,@c_s,@l_i,@c_i)     // pega posicao atual da tela
CAIXA(mold,l_s,c_s,l_i,c_i)               // monta caixa da tela
@ l_s,c_s+10 SAY " IMPRESSŽO AUX.FUNERAL "
SETCOLOR(drvcortel)
@ l_s+01,c_s+1 SAY " Processo:"
@ l_s+02,c_s+1 SAY " Confirme:"
PRIV rproc:=SPAC(11)                               // Processo
PRIV confirme:=SPAC(1)                             // Confirme
DO WHILE .t.
 rola_t=.f.
 cod_sos=56
 SET KEY K_ALT_F8 TO ROLATELA
 SETCOLOR(drvcortel+","+drvcorget+",,,"+corcampo)
 @ l_s+01 ,c_s+12 GET  rproc;
                  PICT "@R 99999/9999-99";
                  VALI CRIT("!EMPT(RPROC).AND.PTAB(M->rproc,[AFUNER],1)~Campo utilizado para localiza‡„o dos documentos.|Tecle F8 para busca em tabela")
                  DEFAULT "IIF(PTAB(PADR(SUBSTR(M->ide_maq,2),4)+[AFU],[IMPPAR],1),ALLTRIM(IMPPAR->docto),[])"
                  AJUDA "Digite neste campo o n£mero de|identifica‡„o do processo"
                  CMDF8 "VDBF(6,12,20,77,'AFUNER',{'processo','proc2','categ','contrato','falecido'},1,'V02001F9()',[])"

 @ l_s+02 ,c_s+12 GET  confirme;
                  PICT "!";
                  VALI CRIT("confirme='S'.AND.V02002F9()~CONFIRME n„o aceit vel|Digite S para confirmar|ou|Tecle ESC para cancelar")
                  AJUDA "Digite S para confirmar|ou|tecle ESC para cancelar"

 READ
 SET KEY K_ALT_F8 TO
 IF rola_t
  ROLATELA(.f.)
  LOOP
 ENDI
 IF LASTKEY()=K_ESC                                // se quer cancelar
  RETU                                             // retorna
 ENDI

 #ifdef COM_REDE
  IF !USEARQ("AFUNER",.f.,10,1)                    // se falhou a abertura do arq
   RETU                                            // volta ao menu anterior
  ENDI
 #else
  USEARQ("AFUNER")                                 // abre o dbf e seus indices
 #endi

 PTAB(contrato,"GRUPOS",1,.t.)                     // abre arquivo p/ o relacionamento
 PTAB(funcresp,"FNCS",1,.t.)
 PTAB(GRUPOS->tipcont,"CLASSES",1,.t.)
 SET RELA TO contrato INTO GRUPOS,;                // relacionamento dos arquivos
          TO funcresp INTO FNCS,;
          TO GRUPOS->tipcont INTO CLASSES
 titrel:=criterio := ""                            // inicializa variaveis
 cpord=""
 chv_rela:=chv_1:=chv_2 := ""
 tps:=op_x:=ccop := 1
 fil_ini=""
 IF !opcoes_rel(lin_menu,col_menu,6,11,fil_ini)    // nao quis configurar...
  CLOS ALL                                         // fecha arquivos e
  LOOP                                             // volta ao menu
 ENDI
 IF tps=2                                          // se vai para arquivo/video
  arq_=ARQGER()                                    // entao pega nome do arquivo
  IF EMPTY(arq_)                                   // se cancelou ou nao informou
   LOOP                                            // retorna
  ENDI
 ELSE
  arq_=drvporta                                    // porta de saida configurada
 ENDI
 IF "4WIN"$UPPER(drvmarca) // nome da configuracao/marca impressora
    arq_:=drvdbf+"WIN"+ide_maq
    tps:=3                                          // se vai para arquivo/video
 ENDIF
 SET PRINTER TO (arq_)                             // redireciona saida
 EXIT
ENDD
cur_atual=SETCURSOR(0)
IF !EMPTY(drvtapg)                                 // existe configuracao de tam pag?
 op_=AT("NNN",drvtapg)                             // se o codigo que altera
 IF op_=0                                          // o tamanho da pagina
  msg="Configura‡„o do tamanho da p gina!"         // foi informado errado
  DBOX(msg,,,,,"ERRO!")                            // avisa
  CLOSE ALL                                        // fecha todos arquivos abertos
  RETU                                             // e cai fora...
 ENDI                                              // codigo para setar/resetar tam pag
 lpp_050=LEFT(drvtapg,op_-1)+"050"+SUBS(drvtapg,op_+3)
 lpp_066=LEFT(drvtapg,op_-1)+"066"+SUBS(drvtapg,op_+3)
ELSE
 lpp_050:=lpp_066 :=""                             // nao ira mudara o tamanho da pag
ENDI
dele_atu:=SET(_SET_DELETED,.t.)                    // os excluidos nao servem...
POE_GAUGE("[ESC] Interrompe","AGUARDE...","Emitidos:")
SET DEVI TO PRIN                                   // inicia a impressao
maxli=65                                           // maximo de linhas no relatorio
IMPCTL(lpp_050)                                    // seta pagina com 50 linhas
IMPCTL(drvpde8)                                    // ativa 8 lpp
IF tps=2
 IMPCTL("' '+CHR(8)")
ENDI
BEGIN SEQUENCE
 DO WHIL ccop<=nucop                               // imprime qde copias pedida
  pg_=1; cl=50000
  INI_ARQ()                                        // acha 1o. reg valido do arquivo
  IF EOF()
   EXIT
  ENDI
  ccop++                                           // incrementa contador de copias
  DO WHIL !EOF().AND.POE_GAUGE()
   IF IN_KEY()=K_ESC                               // se quer cancelar
    IF canc()                                      // pede confirmacao
     BREAK                                         // confirmou...
    ENDI
   ENDI
   IF PTAB(PADR(SUBSTR(M->ide_maq,2),4)+[AFU],[IMPPAR],1).and.processo+proc2+filial+categ=ALLTRIM(IMPPAR->docto)// se atender a condicao...
    REL_CAB(3)                                     // soma cl/imprime cabecalho
    @ cl,060 SAY TRAN(processo+proc2+filial,"@R 99999/99/!!")// N£mero Processo
    REL_CAB(12)                                    // soma cl/imprime cabecalho
    @ cl,011 SAY TRAN(falecido,"@!")               // Nome do falecido
    REL_CAB(2)                                     // soma cl/imprime cabecalho
    @ cl,011 SAY ALLTRIM(ruares)+[ ]+ALLTRIM(baires)+'-'+ALLTRIM(munres)// endereco (falecido)
    REL_CAB(2)                                     // soma cl/imprime cabecalho
    @ cl,019 SAY TRAN(falecto_,"@D")               // Data falcto.
    @ cl,056 SAY TRAN(horafal,"99:99")             // Hora Falcto.
    REL_CAB(2)                                     // soma cl/imprime cabecalho
    @ cl,019 SAY TRAN(ALLTRIM(ruafal),"@!")        // Rua Falecimento
    REL_CAB(4)                                     // soma cl/imprime cabecalho
    @ cl,012 SAY TRAN(nomedec,"@!")                // Declarante
    REL_CAB(2)                                     // soma cl/imprime cabecalho
    @ cl,012 SAY ALLTRIM(ruadec)                   // endereco (declarante)
    @ cl,056 SAY fonedec                           // fone declarante
    REL_CAB(11)                                    // soma cl/imprime cabecalho
    @ cl,012 SAY CLASSES->descricao                // tipo de plano
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,025 SAY IIF(categ=[PD],[Plano c/Difer. ],IIF(categ=[PL],[Atend.Plano],[Auxilio Funeral  ]))// Categoria
    REL_CAB(3)                                     // soma cl/imprime cabecalho
    @ cl,012 SAY FNCS->nome                        // Motorista respons vel
    @ cl,050 SAY TRAN(contrato,"@R 999.999999")           // CONTRATO
    @ cl,066 SAY IIF(CLASSES->prior=[S],M->mgrupvip,GRUPOS->grupo)// GRUPO
    REL_CAB(13)                                    // soma cl/imprime cabecalho
    @ cl,015 SAY TRAN(cemitsep,"@!")               // Cemit‚rio Sepultamento
    REL_CAB(2)                                     // soma cl/imprime cabecalho
    @ cl,021 SAY horasepult                        // hora sepultamento
    IF !EMPT(sepult_)                              // pode imprimir?
     @ cl,058 SAY DTOC(sepult_)                    // data sepultamento
    ENDI
    SKIP                                           // pega proximo registro
    cl=50000                                       // forca salto de pagina
   ELSE                                            // se nao atende condicao
    SKIP                                           // pega proximo registro
   ENDI
  ENDD
 ENDD ccop
 EJEC                                              // salta pagina
END SEQUENCE
SETCURSOR(cur_atual)
IMPCTL(drvtde8)                                    // ativa 6 lpp
IMPCTL(lpp_066)                                    // seta pagina com 66 linhas
SET PRINTER TO (drvporta)                          // fecha arquivo gerado (se houver)
SET DEVI TO SCRE                                   // direciona saida p/ video
IF tps=2                                           // se vai para arquivo/video
 BROWSE_REL(arq_,2,3,MAXROW()-2,78)
ENDI          // mostra o arquivo gravado
GRELA(6)                                           // grava variacao do relatorio
SELE AFUNER                                        // seleciona arquivo
SET RELA TO                                        // retira os relacionamentos
SET(_SET_DELETED,dele_atu)                         // os excluidos serao vistos
RETU

STATIC PROC REL_CAB(qt)                            // cabecalho do relatorio
IF qt>0                                            // se parametro maior que 0
 cl=cl+qt                                          // soma no contador de linhas
ENDI
IF cl>maxli .OR. qt=0                              // quebra de pagina
 cl=qt+5 ; pg_++
ENDI
RETU

* \\ Final de ADM_R026.PRG
/*
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
 \ Empresa.: PresServ Inform tica - Limeira (019)452.6623
 \ Programa: ADR_ATR1.PRG
 \ Data....: 29-06-98
 \ Sistema.: Administradora - RECEP€„O
 \ Funcao..: Define atributos dos arquivos (sistema[])
 \ Analista: Ademilson Pedro Bom
 \ Criacao.: GAS-Pro v3.0 
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/

#include "adrbig.ch"    // inicializa constantes manifestas


sistema[09]={;
            "Lan‡amento Aux.Funeral",;                      // opcao do menu
            "Aux¡lio Funeral",;                             // titulo do sistema
            {"processo+proc2+filial+categ","falecido+processo","ruafal"},;// chaves do arquivo
            {"Processo","Nome Falecido","Data e Local Fal."},;// titulo dos indices para consulta
            {"01020305","1201","20"},;                          // ordem campos chaves
            "AFUNER",;                                      // nome do DBF
            {"AFUNER1","AFUNER2","AFUNER3"},;               // nomes dos NTX
            {},;                                            // nome dos dbf's relacionados
            {},;                                            // campos de relacionamento
            {1,1,3,1,22,78},;                               // num telas/tela atual/coordenadas
            {1,.t.},;                                       // nivel acesso/tp chave
            {},;                                            // campos do arquivo
            {},;                                            // formula mostradas
            {"nivelop>1","Permitido apenas a usu rios cadastrados|com n¡vel de Manuten‡„o ou Maior"},;// condicao de exclusao de registros
            {"nivelop>1","Permitido apenas a usu rios cadastrados|com n¡vel de Manuten‡„o ou Maior"},;// condicao de alteracao de registros
            {"nivelop>1","Permitido apenas a usu rios cadastrados|com n¡vel de Manuten‡„o ou Maior"};// condicao de recupercao de registros
           }

AADD(sistema[09,O_CAMPO],{;            // AFUNER
     /* mascara       */    "99999",;
     /* titulo        */    "Processo",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(PROCESSO)~Este ‚ um campo obrigat¢rio!|Ele ‚ usado como chave principal|para localiza‡„o dos documentos.",;
     /* help do campo */    "Digite neste campo o n£mero de|identifica‡„o do processo";
                         };
)
AADD(sistema[09,O_CAMPO],{;            // AFUNER
     /* mascara       */    "99",;
     /* titulo        */    "Ano",;
     /* cmd especial  */    "",;
     /* default       */    "RIGHT(DTOC(DATE()),2)",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(proc2)~Necess rio informar ANO",;
     /* help do campo */    "Informe o ano correspondente ao processo.";
                         };
)
AADD(sistema[09,O_CAMPO],{;            // AFUNER
     /* mascara       */    "@!",;
     /* titulo        */    "Filial",;
     /* cmd especial  */    "MTAB([LI-Limeira|AM-Americana|GU-Gullo|AT-Limeirense AT|SU-Sumar‚],[FILIAL])",;
     /* default       */    "M->p_filial",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(filial)~Necess rio informar FILIAL",;
     /* help do campo */    "Informe o c¢digo da filial|tecle F8 para ajuda";
                         };
)
AADD(sistema[09,O_CAMPO],{;            // AFUNER
     /* mascara       */    "@D",;
     /* titulo        */    "Data ocorrˆncia",;
     /* cmd especial  */    "",;
     /* default       */    "DATE()",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPTY(ocorr_)~DATA OCORRENCIA n„o pode estar vazia",;
     /* help do campo */    "Entre com a Data de Ocorrˆncia";
                         };
)
AADD(sistema[09,O_CAMPO],{;            // AFUNER
     /* mascara       */    "!!",;
     /* titulo        */    "Categoria",;
     /* cmd especial  */    "MTAB([PL=Plano|PD=Plano c/Diferen‡a|AF=Auxilio],[CATEGORIA])",;
     /* default       */    "[AF]",;
     /* pre-validacao */    "",;
     /* validacao     */    "categ $ [PL|PD|AF]~CATEGORIA n„o aceit vel",;
     /* help do campo */    "Preencha com:|PL para Plano,| PD p/Diferen‡a ou |AX para Aux.Funeral";
                         };
)
AADD(sistema[09,O_CAMPO],{;            // AFUNER
     /* mascara       */    "999999",;
     /* titulo        */    "Contrato",;
     /* cmd especial  */    "VDBF(6,3,20,77,'GRUPOS',{'codigo','grupo','nome','endereco'},1,'codigo',[])",;
     /* default       */    "[     ]",;
     /* pre-validacao */    "",;
     /* validacao     */    "(afu_07f9(contrato).AND.CAD_04F9(op_menu).AND.(PTAB(contrato,'TAXAS',1).OR.PTAB(GRUPOS->grupo,'ARQGRUP',1).OR.1=1)).OR.nivelop=3~CONTRATO n„o existe em arquivo de tabela",;
     /* help do campo */    "Informe o n£mero do contrato";
                         };
)
AADD(sistema[09,O_CAMPO],{;            // AFUNER
     /* mascara       */    "",;
     /* titulo        */    "Parentesco",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    "Informe o grau de parentesco deste com o falecido.";
                         };
)
AADD(sistema[09,O_CAMPO],{;            // AFUNER
     /* mascara       */    "@!",;
     /* titulo        */    "Nome",;
     /* cmd especial  */    "",;
     /* default       */    "GRUPOS->nome",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(nomedec)~Necess rio informar NOME",;
     /* help do campo */    "Entre com o nome do declarante";
                         };
)
AADD(sistema[09,O_CAMPO],{;            // AFUNER
     /* mascara       */    "@!",;
     /* titulo        */    "Rua Declarante",;
     /* cmd especial  */    "",;
     /* default       */    "GRUPOS->endereco",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    "Entre com o endere‡o do respons vel";
                         };
)
AADD(sistema[09,O_CAMPO],{;            // AFUNER
     /* mascara       */    "@!",;
     /* titulo        */    "Fone",;
     /* cmd especial  */    "",;
     /* default       */    "GRUPOS->telefone",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    "Informe o n£mero do Telefone para contato|com o respons vel pela solicita‡„o do A.F.";
                         };
)
AADD(sistema[09,O_CAMPO],{;            // AFUNER
     /* mascara       */    "",;
     /* titulo        */    "Falecido",;
     /* cmd especial  */    "VDBF(6,3,20,77,'INSCRITS',{'codigo','grau','seq','nome','tcarencia'},1,'kinscf9()',[])",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "PTAB(codigofal,'INSCRITS',1).OR.EMPT(codigofal)~Necess rio informar C¢digo do FALECIDO ou|Tecle F8 para consulta.",;
     /* help do campo */    "Entre com o c¢digo do falecido";
                         };
)
AADD(sistema[09,O_CAMPO],{;            // AFUNER
     /* mascara       */    "",;
     /* titulo        */    "Nome do falecido",;
     /* cmd especial  */    "afu_06f9()",;
     /* default       */    "IIF(PTAB(codigofal,'INSCRITS',1),INSCRITS->nome,[])",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(falecido).and.afu_01f9(falecido)~Necess rio informar NOME DO FALECIDO",;
     /* help do campo */    "Entre com o nome do falecido";
                         };
)
AADD(sistema[09,O_CAMPO],{;            // AFUNER
     /* mascara       */    "",;
     /* titulo        */    "Rua Residˆncia",;
     /* cmd especial  */    "",;
     /* default       */    "GRUPOS->endereco",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    "Entre com o endere‡o de residˆncia do Falecido";
                         };
)
AADD(sistema[09,O_CAMPO],{;            // AFUNER
     /* mascara       */    "",;
     /* titulo        */    "Bairro Residˆncia",;
     /* cmd especial  */    "",;
     /* default       */    "GRUPOS->bairro",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    "Entre com o bairro de residˆncia";
                         };
)
AADD(sistema[09,O_CAMPO],{;            // AFUNER
     /* mascara       */    "",;
     /* titulo        */    "Munic¡pio de residˆncia",;
     /* cmd especial  */    "",;
     /* default       */    "GRUPOS->cidade",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    "Entre com o nome do Munic¡pio de residˆncia";
                         };
)
AADD(sistema[09,O_CAMPO],{;            // AFUNER
     /* mascara       */    "!!",;
     /* titulo        */    "UF Residˆncia",;
     /* cmd especial  */    "",;
     /* default       */    "GRUPOS->uf",;
     /* pre-validacao */    "",;
     /* validacao     */    "EMPTY(ESTRES).OR.VUF(ESTRES)~ESTADO RESIDENCIA N„o aceit vel",;
     /* help do campo */    "Entre com o estado de Residˆncia";
                         };
)
AADD(sistema[09,O_CAMPO],{;            // AFUNER
     /* mascara       */    "@D",;
     /* titulo        */    "Nascimento",;
     /* cmd especial  */    "",;
     /* default       */    "IIF(PTAB(codigofal,'INSCRITS',1),INSCRITS->nascto_,CTOD([  /  /  ]))",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    "Informe a data de nascimento do falecido.";
                         };
)
AADD(sistema[09,O_CAMPO],{;            // AFUNER
     /* mascara       */    "@D",;
     /* titulo        */    "Data falcto.",;
     /* cmd especial  */    "afu_03f9()",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "falecto_<=DATE().and.afu_01f9(falecto_)~Informe uma data v lida para falecimento|Verifique a data do sistema.",;
     /* help do campo */    "Entre com a data de falecimento";
                         };
)
AADD(sistema[09,O_CAMPO],{;            // AFUNER
     /* mascara       */    "99:99",;
     /* titulo        */    "Hora Falcto.",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "!EMPTY(falecto_)",;
     /* validacao     */    "VHORA(horafal+':00')~HORA FALCTO. n„o aceit vel|Digite uma hora correta",;
     /* help do campo */    "";
                         };
)
AADD(sistema[09,O_CAMPO],{;            // AFUNER
     /* mascara       */    "",;
     /* titulo        */    "Rua Falecimento",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    "Entre com o endere‡o (Rua) onde|ocorreu o falecimento";
                         };
)
AADD(sistema[09,O_CAMPO],{;            // AFUNER
     /* mascara       */    "",;
     /* titulo        */    "Munic¡pio de falecimento",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    "Entre com o nome do munic¡pio";
                         };
)
AADD(sistema[09,O_CAMPO],{;            // AFUNER
     /* mascara       */    "!!",;
     /* titulo        */    "UF falecto",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "EMPTY(ESTFAL) .OR.VUF(ESTFAL)~ESTADO FALECIMENTO N„o aceit vel",;
     /* help do campo */    "Entre com o Estado onde ocorreu o falecimento";
                         };
)
AADD(sistema[09,O_CAMPO],{;            // AFUNER
     /* mascara       */    "@D",;
     /* titulo        */    "Data Sepultamento",;
     /* cmd especial  */    "",;
     /* default       */    "DATE()",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    "Informe a data do sepultamento";
                         };
)
AADD(sistema[09,O_CAMPO],{;            // AFUNER
     /* mascara       */    "99:99",;
     /* titulo        */    "Hora sepult.",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "VHORA(horasepult+':00')~HORA SEPULT. n„o aceit vel|digite uma hora correta",;
     /* help do campo */    "Informe a hora do sepultamento";
                         };
)
AADD(sistema[09,O_CAMPO],{;            // AFUNER
     /* mascara       */    "",;
     /* titulo        */    "Cemit‚rio Sepultamento",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    "Entre com o n£mero do cemit‚rio de sepultamento";
                         };
)
AADD(sistema[09,O_CAMPO],{;            // AFUNER
     /* mascara       */    "999",;
     /* titulo        */    "Func.Respons vel",;
     /* cmd especial  */    "VDBF(6,15,20,77,'FNCS',{'codigo','nome','profiss'},1,'codigo',[])",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "PTAB(funcresp,'FNCS',1).OR.EMPTY(funcresp)~Funcion rio n„o existe na tabela",;
     /* help do campo */    "Informe o funcion rio far |o registro ou F8 para consulta em tabela";
                         };
)
AADD(sistema[09,O_CAMPO],{;            // AFUNER
     /* mascara       */    "@D",;
     /* titulo        */    "Proc.pagto em",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    "Processar pagamento em...";
                         };
)
AADD(sistema[09,O_CAMPO],{;            // AFUNER
     /* mascara       */    "99999999999.99",;
     /* titulo        */    "Valor Auxilio",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    "Informe o valor do Auxilio Funeral";
                         };
)
AADD(sistema[09,O_CAMPO],{;            // AFUNER
     /* mascara       */    "@D",;
     /* titulo        */    "Pago em",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    "";
                         };
)
AADD(sistema[09,O_CAMPO],{;            // AFUNER
     /* mascara       */    "99999999",;
     /* titulo        */    "Num.Lan‡amento",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[09,O_FORMULA],{;          // AFUNER - Contratante
     /* form mostrar  */    "LEFT(TRAN(IIF(PTAB(contrato,'GRUPOS',1),GRUPOS->nome,[]),[]),30)",;
     /* lin da formula*/    3,;
     /* col da formula*/    22;
                         };
)
AADD(sistema[09,O_FORMULA],{;          // AFUNER - Endere‡o Contr.
     /* form mostrar  */    "LEFT(TRAN(IIF(PTAB(contrato,'GRUPOS',1),GRUPOS->endereco,[]),[]),35)",;
     /* lin da formula*/    4,;
     /* col da formula*/    28;
                         };
)
AADD(sistema[09,O_FORMULA],{;          // AFUNER - Func.Resp.
     /* form mostrar  */    "LEFT(TRAN(IIF(PTAB(funcresp,[FNCS]),FNCS->nome,[ ]),[]),30)",;
     /* lin da formula*/    16,;
     /* col da formula*/    32;
                         };
)
AADD(sistema[09,O_FORMULA],{;          // AFUNER - Categoria
     /* form mostrar  */    "LEFT(TRAN(IIF(categ=[PD],[Plano c/Difer. ],IIF(categ=[PL],[Atend.Plano],[Auxilio Funeral  ])),[]),18)",;
     /* lin da formula*/    1,;
     /* col da formula*/    56;
                         };
)
AADD(sistema[09,O_FORMULA],{;          // AFUNER - Filial
     /* form mostrar  */    "LEFT(TRAN(filial,[@!]),02)",;
     /* lin da formula*/    1,;
     /* col da formula*/    23;
                         };
)
AADD(sistema[09,O_FORMULA],{;          // AFUNER - Seguro?
     /* form mostrar  */    "LEFT(TRAN(IIF(PTAB(contrato,'GRUPOS',1),GRUPOS->nome,[]),[]),30)",;
     /* lin da formula*/    3,;
     /* col da formula*/    22;
                         };
)


sistema[10]={;
            "Taxas a Imprimir",;                            // opcao do menu
            "Taxas a Imprimir",;                            // titulo do sistema
            {"codigo+tipo+circ"},;                          // chaves do arquivo
            {"Contrato e Circ."},;                          // titulo dos indices para consulta
            {"010203"},;                                    // ordem campos chaves
            "TX2VIA",;                                      // nome do DBF
            {"TX2VIA1"},;                                   // nomes dos NTX
            {},;                                            // nome dos dbf's relacionados
            {},;                                            // campos de relacionamento
            {1,1,8,13,19,71,3,8},;                          // num telas/tela atual/coordenadas/inicio scroll/qtde scroll
            {0,.t.},;                                       // nivel acesso/tp chave
            {},;                                            // campos do arquivo
            {},;                                            // formula mostradas
            {"",""},;                                       // condicao de exclusao de registros
            {"",""},;                                       // condicao de alteracao de registros
            {"",""};                                        // condicao de recupercao de registros
           }

AADD(sistema[10,O_CAMPO],{;            // TX2VIA
     /* mascara       */    "999999",;
     /* titulo        */    "Codigo",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "PTAB(codigo,'GRUPOS',1)~Necess rio informar CODIGO",;
     /* help do campo */    "Informe o n£mero do contrato";
                         };
)
AADD(sistema[10,O_CAMPO],{;            // TX2VIA
     /* mascara       */    "!",;
     /* titulo        */    "Tipo",;
     /* cmd especial  */    "MTAB([1=J¢ia|2=Taxa|3=Carnˆ|6=J¢ia+Seguro|7=Taxa+Seguro|8=Carnˆ+Seguro],[TIPO])",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "tipo $ [123678]~TIPO n„o aceit vel",;
     /* help do campo */    "Qual o tipo de Taxa a Emitir";
                         };
)
AADD(sistema[10,O_CAMPO],{;            // TX2VIA
     /* mascara       */    "999",;
     /* titulo        */    "Circular",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "PTAB(codigo+tipo+circ,'TAXAS',1).OR.PTAB(codigo+SUBSTR('678  123',VAL(tipo),1)+circ,[TAXAS],1)~N£mero inv lido|Taxa n„o existe em contas a receber",;
     /* help do campo */    "N£mero da Circular|Mantido pela emissao de recibos";
                         };
)
AADD(sistema[10,O_FORMULA],{;          // TX2VIA - Nome
     /* form mostrar  */    "LEFT(TRAN(GRUPOS->nome,[@!]),35)",;
     /* lin da formula*/    {||l_a},;
     /* col da formula*/    17;
                         };
)
AADD(sistema[10,O_FORMULA],{;          // TX2VIA - paga
     /* form mostrar  */    "LEFT(TRAN(IIF(TAXAS->valorpg>0,[Paga],[    ]),[]),04)",;
     /* lin da formula*/    {||l_a},;
     /* col da formula*/    53;
                         };
)


sistema[11]={;
            "Documento … Imprimir",;                        // opcao do menu
            "Documento … Imprimir",;                        // titulo do sistema
            {"idmaq+base","codlan"},;                       // chaves do arquivo
            {"Esta‡„o","Cod.Lanc"},;                        // titulo dos indices para consulta
            {"0102","04"},;                                 // ordem campos chaves
            "IMPPAR",;                                      // nome do DBF
            {"IMPPAR1","IMPPAR2"},;                         // nomes dos NTX
            {},;                                            // nome dos dbf's relacionados
            {},;                                            // campos de relacionamento
            {1,1,8,8,19,72,3,8},;                           // num telas/tela atual/coordenadas/inicio scroll/qtde scroll
            {1,.t.},;                                       // nivel acesso/tp chave
            {},;                                            // campos do arquivo
            {},;                                            // formula mostradas
            {"",""},;                                       // condicao de exclusao de registros
            {"",""},;                                       // condicao de alteracao de registros
            {"",""};                                        // condicao de recupercao de registros
           }

AADD(sistema[11,O_CAMPO],{;            // IMPPAR
     /* mascara       */    "@!",;
     /* titulo        */    "Esta‡„o",;
     /* cmd especial  */    "M->ide_maq",;
     /* default       */    "PADR(SUBSTR(M->ide_maq,2),4)",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(idmaq)~Necess rio informar Esta‡„o|Tecle F8",;
     /* help do campo */    "Informe o nome da esta‡„o|tecle F8 para preencher autom tico";
                         };
)
AADD(sistema[11,O_CAMPO],{;            // IMPPAR
     /* mascara       */    "@!",;
     /* titulo        */    "Base",;
     /* cmd especial  */    "MTAB([AFU-Aux.funeral|BXR-Baixa Recep‡„o|OBX-Outros Receb.],[BASE])",;
     /* default       */    "[BXR]",;
     /* pre-validacao */    "",;
     /* validacao     */    "base $ [AFU|BXR|OBX]~BASE n„o aceit vel,tecle F8",;
     /* help do campo */    "Informe a Base de Dados|tecle F8 para busca em tabela";
                         };
)
AADD(sistema[11,O_CAMPO],{;            // IMPPAR
     /* mascara       */    "",;
     /* titulo        */    "Documento",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    "Digite neste campo o n£mero de|identifica‡„o do documento|(N„o utilize barras nem tra‡os)";
                         };
)
AADD(sistema[11,O_CAMPO],{;            // IMPPAR
     /* mascara       */    "!!!-99999999-999-999",;
     /* titulo        */    "Cod.Lan‡amento",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[11,O_FORMULA],{;          // IMPPAR - processo falec.
     /* form mostrar  */    "LEFT(TRAN(IMP_01F9(),[]),35)",;
     /* lin da formula*/    {||l_a},;
     /* col da formula*/    28;
                         };
)


sistema[12]={;
            "Credenciados",;                                // opcao do menu
            "Cadastro de Credenciados",;                    // titulo do sistema
            {"crm","nome","especialid+cidade+nome"},;       // chaves do arquivo
            {"CRM","M‚dico","Especialidade"},;              // titulo dos indices para consulta
            {"01","03","070503"},;                          // ordem campos chaves
            "MEDICOS",;                                     // nome do DBF
            {"MEDICOS1","MEDICOS2","MEDICOS3"},;            // nomes dos NTX
            {},;                                            // nome dos dbf's relacionados
            {},;                                            // campos de relacionamento
            {1,1,8,12,21,70},;                              // num telas/tela atual/coordenadas
            {1,.t.},;                                       // nivel acesso/tp chave
            {},;                                            // campos do arquivo
            {},;                                            // formula mostradas
            {"",""},;                                       // condicao de exclusao de registros
            {"",""},;                                       // condicao de alteracao de registros
            {"",""};                                        // condicao de recupercao de registros
           }

AADD(sistema[12,O_CAMPO],{;            // MEDICOS
     /* mascara       */    "@!",;
     /* titulo        */    "C¢digo",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "V",;
     /* help do campo */    "";
                         };
)
AADD(sistema[12,O_CAMPO],{;            // MEDICOS
     /* mascara       */    "!",;
     /* titulo        */    "Situa‡„o",;
     /* cmd especial  */    "MTAB([Sim, est  atendendo|N„o est  atendendo],[SITUA€ŽO])",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "status $ [SN ]~SITUA€ŽO n„o aceit vel",;
     /* help do campo */    "Informe se est  ou n„o ativo.";
                         };
)
AADD(sistema[12,O_CAMPO],{;            // MEDICOS
     /* mascara       */    "",;
     /* titulo        */    "Nome",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(nome)~Necess rio informar NOME",;
     /* help do campo */    "Informe o nome do M‚dico";
                         };
)
AADD(sistema[12,O_CAMPO],{;            // MEDICOS
     /* mascara       */    "",;
     /* titulo        */    "Endere‡o",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    "";
                         };
)
AADD(sistema[12,O_CAMPO],{;            // MEDICOS
     /* mascara       */    "@!",;
     /* titulo        */    "Cidade",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    "";
                         };
)
AADD(sistema[12,O_CAMPO],{;            // MEDICOS
     /* mascara       */    "",;
     /* titulo        */    "Telefone",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    "";
                         };
)
AADD(sistema[12,O_CAMPO],{;            // MEDICOS
     /* mascara       */    "@!",;
     /* titulo        */    "Especialidade",;
     /* cmd especial  */    "VDBF(6,44,20,77,'TESPEC',{'especialid'},1,'especialid',[])",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    "Informe a Especialidade|ou|Categoria Profissional|do Credenciado.|Tecle F8 para consulta em tabela";
                         };
)
AADD(sistema[12,O_CAMPO],{;            // MEDICOS
     /* mascara       */    "@R 999.999.999-99",;
     /* titulo        */    "CPF",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "VDV2(cpf).OR. EMPT(cpf)~CPF n„o aceit vel",;
     /* help do campo */    "Informe o Cadastro de Pessoa F¡sica (CPF)";
                         };
)
AADD(sistema[12,O_CAMPO],{;            // MEDICOS
     /* mascara       */    "",;
     /* titulo        */    "CRM",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    "Informe o CRM do M‚dico";
                         };
)
AADD(sistema[12,O_CAMPO],{;            // MEDICOS
     /* mascara       */    "@S40",;
     /* titulo        */    "Mensagem",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    "Entre com uma mensagem espec¡fica a ser|impressa nas guias deste.";
                         };
)
AADD(sistema[12,O_CAMPO],{;            // MEDICOS
     /* mascara       */    "99",;
     /* titulo        */    "Institui‡„o",;
     /* cmd especial  */    "",;
     /* default       */    "0",;
     /* pre-validacao */    "",;
     /* validacao     */    "V",;
     /* help do campo */    "";
                         };
)
AADD(sistema[12,O_CAMPO],{;            // MEDICOS
     /* mascara       */    "@D",;
     /* titulo        */    "Cadastro",;
     /* cmd especial  */    "",;
     /* default       */    "DATE()",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    "";
                         };
)
AADD(sistema[12,O_CAMPO],{;            // MEDICOS
     /* mascara       */    "",;
     /* titulo        */    "Contrato",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    "Entre com o n£mero do contrato que |regulamenta o convˆnio deste.";
                         };
)
AADD(sistema[12,O_CAMPO],{;            // MEDICOS
     /* mascara       */    "@E 99,999,999.99",;
     /* titulo        */    "Valor Particular",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "!(valorpart<0)~VALOR PARTICULAR n„o aceit vel",;
     /* help do campo */    "Entre com o valor cobrado sem desconto";
                         };
)
AADD(sistema[12,O_CAMPO],{;            // MEDICOS
     /* mascara       */    "99",;
     /* titulo        */    "Porcent1",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "!(porcent1<0)~PORCENTAGEM deve ser maior que ZEROS",;
     /* help do campo */    "Informe a porcentagem de desconto.";
                         };
)
AADD(sistema[12,O_CAMPO],{;            // MEDICOS
     /* mascara       */    "@E 99,999,999.99",;
     /* titulo        */    "Ult.valor",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "!(ultvalor<0)~ULT.VALOR n„o aceit vel",;
     /* help do campo */    "Este ‚ o £ltimo valor para consulta cadastrado.";
                         };
)
AADD(sistema[12,O_CAMPO],{;            // MEDICOS
     /* mascara       */    "@D",;
     /* titulo        */    "Data",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    "Data do £ltimo valor, (v lido a partir de...)";
                         };
)
AADD(sistema[12,O_CAMPO],{;            // MEDICOS
     /* mascara       */    "!",;
     /* titulo        */    "Receber",;
     /* cmd especial  */    "MTAB([Sim, receber no momento da Emiss„o da Guia|N„o, o acerto ser  feito no consult¢rio],[RECEBER])",;
     /* default       */    "[N]",;
     /* pre-validacao */    "",;
     /* validacao     */    "receber $ [SN]~Digite S ou N",;
     /* help do campo */    "Digite S para receber no momento da consulta|ou N para acerto no consult¢rio.";
                         };
)
AADD(sistema[12,O_CAMPO],{;            // MEDICOS
     /* mascara       */    "@!",;
     /* titulo        */    "Conta",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "receber=[S]",;
     /* validacao     */    "!EMPT(numconta)~Campo obrigat¢rio!|Identifique a Conta/Cadastro com um n£mero | ou nome qualquer.",;
     /* help do campo */    "Entre com a Conta que receber  os lan‡amentos|deste M‚dico, certifique-se da inexistˆncia|de duplicidades no Sist.Financeiro";
                         };
)
AADD(sistema[12,O_CAMPO],{;            // MEDICOS
     /* mascara       */    "99",;
     /* titulo        */    "Validade Guia",;
     /* cmd especial  */    "VDBF(6,13,20,77,'CLASSES',('classcod','descricao','vljoia'),1,'classcod')",;
     /* default       */    "[30]",;
     /* pre-validacao */    "",;
		 /* validacao     */    "!EMPT(VAL(tipcont))~Informe o prazo de validade das|guias de encaminhamento deste.",;
     /* help do campo */    "Informe o prazo de validade|para as guias de encaminhamento|a este credenciado.";
                         };
)
AADD(sistema[12,O_CAMPO],{;            // MEDICOS
     /* mascara       */    "@E 99,999,999.99",;
     /* titulo        */    "Valor",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "!(valoremp<0)~VALOR n„o aceit vel",;
     /* help do campo */    "Informe o valor retido na Empresa";
                         };
)
AADD(sistema[12,O_CAMPO],{;            // MEDICOS
     /* mascara       */    "99999999",;
     /* titulo        */    "Num.Lan‡amento",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[12,O_FORMULA],{;          // MEDICOS - porc.desconto
     /* form mostrar  */    "LEFT(TRAN(STR(ultvalor/valorpart*100,6,2),[]),06)",;
     /* lin da formula*/    0,;
     /* col da formula*/    0;
                         };
)


sistema[13]={;
            "Especialidades",;                              // opcao do menu
            "Especialidades",;                              // titulo do sistema
            {"especialid","codlan"},;                       // chaves do arquivo
            {"Por Especialidade","Cod.Lanc"},;              // titulo dos indices para consulta
            {"01","02"},;                                   // ordem campos chaves
            "TESPEC",;                                      // nome do DBF
            {"TESPEC1","TESPEC2"},;                         // nomes dos NTX
            {},;                                            // nome dos dbf's relacionados
            {},;                                            // campos de relacionamento
            {1,1,8,20,21,61,3,10},;                         // num telas/tela atual/coordenadas/inicio scroll/qtde scroll
            {1,.t.},;                                       // nivel acesso/tp chave
            {},;                                            // campos do arquivo
            {},;                                            // formula mostradas
            {"",""},;                                       // condicao de exclusao de registros
            {"",""},;                                       // condicao de alteracao de registros
            {"",""};                                        // condicao de recupercao de registros
           }

AADD(sistema[13,O_CAMPO],{;            // TESPEC
     /* mascara       */    "@!",;
     /* titulo        */    "Especialidade",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(especialid)~Necess rio informar ESPECIALIDADE",;
     /* help do campo */    "Informe a|Especialidade/Categoria Profissional.";
                         };
)
AADD(sistema[13,O_CAMPO],{;            // TESPEC
     /* mascara       */    "!!!-99999999-999-999",;
     /* titulo        */    "Cod.Lan‡amento",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)


sistema[14]={;
            "Parƒmetro de Juros",;                          // opcao do menu
            "Parƒmetro de Juros",;                          // titulo do sistema
            {"tipo"},;                                      // chaves do arquivo
            {"Tipo"},;                                      // titulo dos indices para consulta
            {"01"},;                                        // ordem campos chaves
            "JUROS",;                                       // nome do DBF
            {"JUROS1"},;                                    // nomes dos NTX
            {},;                                            // nome dos dbf's relacionados
            {},;                                            // campos de relacionamento
            {1,1,8,17,17,66,4,5},;                          // num telas/tela atual/coordenadas/inicio scroll/qtde scroll
            {3,.t.},;                                       // nivel acesso/tp chave
            {},;                                            // campos do arquivo
            {},;                                            // formula mostradas
            {"",""},;                                       // condicao de exclusao de registros
            {"",""},;                                       // condicao de alteracao de registros
            {"",""};                                        // condicao de recupercao de registros
           }

AADD(sistema[14,O_CAMPO],{;            // JUROS
     /* mascara       */    "9",;
     /* titulo        */    "Tipo",;
     /* cmd especial  */    "MTAB([1=J¢ia |2=Taxa |3=Carnˆ|4=Acerto],[TIPO])",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(tipo)~TIPO n„o aceit vel|Deve ser n£mero positivo",;
     /* help do campo */    "Qual o tipo de lan‡amento";
                         };
)
AADD(sistema[14,O_CAMPO],{;            // JUROS
     /* mascara       */    "99.99",;
     /* titulo        */    "Multa %",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "multa>=0~MULTA % n„o aceit vel",;
     /* help do campo */    "Informe a porcentagem de multa";
                         };
)
AADD(sistema[14,O_CAMPO],{;            // JUROS
     /* mascara       */    "999",;
     /* titulo        */    "Carˆncia",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "mltcaren>=0~CARENCIA n„o aceit vel",;
     /* help do campo */    "Informe a carˆncia para a |aplica‡„o da multa|em dias.";
                         };
)
AADD(sistema[14,O_CAMPO],{;            // JUROS
     /* mascara       */    "9.999",;
     /* titulo        */    "Juros %",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "juros>=0~JUROS % n„o aceit vel|deve ser maior ou igual a zeros|(Juros Di rios)",;
     /* help do campo */    "Informe a porcentagem do Juros di rios";
                         };
)
AADD(sistema[14,O_CAMPO],{;            // JUROS
     /* mascara       */    "999",;
     /* titulo        */    "Carˆncia",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "jrscaren>=0~CARENCIA n„o aceit vel|deve ser maior ou igual a zeros",;
     /* help do campo */    "Informe a carˆncia para a |aplica‡„o do juros|em dias.";
                         };
)


sistema[15]={;
            "Filiais",;                                     // opcao do menu
            "Filiais",;                                     // titulo do sistema
            {"codigo"},;                                    // chaves do arquivo
            {"C¢digo"},;                                    // titulo dos indices para consulta
            {"01"},;                                        // ordem campos chaves
            "TFILIAIS",;                                    // nome do DBF
            {"TFILIAI1"},;                                  // nomes dos NTX
            {},;                                            // nome dos dbf's relacionados
            {},;                                            // campos de relacionamento
            {1,1,8,8,16,74},;                               // num telas/tela atual/coordenadas
            {1,.t.},;                                       // nivel acesso/tp chave
            {},;                                            // campos do arquivo
            {},;                                            // formula mostradas
            {"nivelop>1","Permitido apenas a usu rios cadastrados|com n¡vel de Manuten‡„o ou Maior"},;// condicao de exclusao de registros
            {"nivelop>1","Permitido apenas a usu rios cadastrados|com n¡vel de Manuten‡„o ou Maior"},;// condicao de alteracao de registros
            {"nivelop>1","Permitido apenas a usu rios cadastrados|com n¡vel de Manuten‡„o ou Maior"};// condicao de recupercao de registros
           }

AADD(sistema[15,O_CAMPO],{;            // TFILIAIS
     /* mascara       */    "@!",;
     /* titulo        */    "C¢digo",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(codigo)~Necess rio informar C¢DIGO",;
     /* help do campo */    "Informe o c¢digo da filial";
                         };
)
AADD(sistema[15,O_CAMPO],{;            // TFILIAIS
     /* mascara       */    "",;
     /* titulo        */    "Abreviatura",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(abrev)~Necess rio informar ABREVIATURA",;
     /* help do campo */    "Dˆ um nome abreviado para a filial|Ser  utilizada para identifica‡Æo nas telas";
                         };
)
AADD(sistema[15,O_CAMPO],{;            // TFILIAIS
     /* mascara       */    "@!",;
     /* titulo        */    "Nome",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(nome)~Necess rio informar NOME",;
     /* help do campo */    "Entre com o nome da filial";
                         };
)
AADD(sistema[15,O_CAMPO],{;            // TFILIAIS
     /* mascara       */    "@!",;
     /* titulo        */    "Endereco",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    "";
                         };
)
AADD(sistema[15,O_CAMPO],{;            // TFILIAIS
     /* mascara       */    "@!",;
     /* titulo        */    "Cidade",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    "";
                         };
)
AADD(sistema[15,O_CAMPO],{;            // TFILIAIS
     /* mascara       */    "@S35",;
     /* titulo        */    "Ref",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    "";
                         };
)
AADD(sistema[15,O_CAMPO],{;            // TFILIAIS
     /* mascara       */    "@!",;
     /* titulo        */    "Contato",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(contato)~Necess rio informar CONTATO",;
     /* help do campo */    "";
                         };
)


sistema[16]={;
            "Grupos",;                                      // opcao do menu
            "Grupos",;                                      // titulo do sistema
            {"grup"},;                                      // chaves do arquivo
            {"Grupo"},;                                     // titulo dos indices para consulta
            {"01"},;                                        // ordem campos chaves
            "ARQGRUP",;                                     // nome do DBF
            {"ARQGRUP1"},;                                  // nomes dos NTX
            {"FCGRUPO"},;                                   // nome dos dbf's relacionados
            {},;                                            // campos de relacionamento
            {1,1,4,15,22,62},;                              // num telas/tela atual/coordenadas
            {1,.t.},;                                       // nivel acesso/tp chave
            {},;                                            // campos do arquivo
            {},;                                            // formula mostradas
            {"",""},;                                       // condicao de exclusao de registros
            {"",""},;                                       // condicao de alteracao de registros
            {"",""};                                        // condicao de recupercao de registros
           }

AADD(sistema[16,O_CAMPO],{;            // ARQGRUP
     /* mascara       */    "!!",;
     /* titulo        */    "Grupo",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(grup)~Necess rio informar GRUPO",;
     /* help do campo */    "Entre com o c¢digo do Grupo";
                         };
)
AADD(sistema[16,O_CAMPO],{;            // ARQGRUP
     /* mascara       */    "99",;
     /* titulo        */    "Classe",;
     /* cmd especial  */    "VDBF(6,38,20,77,'CLASSES',{'classcod','descricao','contrat'},1,'classcod',[])",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "PTAB(classe,'CLASSES',1)~CLASSE n„o existe na tabela",;
     /* help do campo */    "Informe a categoria dos planos deste grupo.|Para grupo VIP, digite 00";
                         };
)
AADD(sistema[16,O_CAMPO],{;            // ARQGRUP
     /* mascara       */    "999999",;
     /* titulo        */    "Nr.Inicial",;
     /* cmd especial  */    "",;
     /* default       */    "IF(classe=[00],[000001],STRZERO(VAL(M->lastcodigo)+1,6))",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    "";
                         };
)
AADD(sistema[16,O_CAMPO],{;            // ARQGRUP
     /* mascara       */    "999999",;
     /* titulo        */    "Nr.Final",;
     /* cmd especial  */    "",;
     /* default       */    "IIF(classe=[00],[999999],STRZERO(VAL(inicio)+CLASSES->contrat-1,6))",;
     /* pre-validacao */    "",;
     /* validacao     */    "VAL(final)>VAL(inicio)~NR.FINAL n„o aceit vel",;
     /* help do campo */    "";
                         };
)
AADD(sistema[16,O_CAMPO],{;            // ARQGRUP
     /* mascara       */    "99",;
     /* titulo        */    "N§.Processos",;
     /* cmd especial  */    "",;
     /* default       */    "INT((1+VAL(final)-VAL(inicio))/50)",;
     /* pre-validacao */    "!(CLASSES->prior=[S])",;
     /* validacao     */    "!(acumproc<0)~N§.PROCESSOS n„o aceit vel",;
     /* help do campo */    "Informe quantos processos s„o nescess rios|para se emitir recibos.";
                         };
)
AADD(sistema[16,O_CAMPO],{;            // ARQGRUP
     /* mascara       */    "99",;
     /* titulo        */    "N§.Processos",;
     /* cmd especial  */    "",;
     /* default       */    "acumproc",;
     /* pre-validacao */    "!(CLASSES->prior=[S])",;
     /* validacao     */    "maxproc>=acumproc~N§.PROCESSOS n„o aceit vel|Informe o n£mero m ximo de processos |a se incluir na circular",;
     /* help do campo */    "Informe o n£mero m ximo de processos|para se emitir na cobran‡a.";
                         };
)
AADD(sistema[16,O_CAMPO],{;            // ARQGRUP
     /* mascara       */    "!",;
     /* titulo        */    "Comp.AdmissXAtend.",;
     /* cmd especial  */    "",;
     /* default       */    "[S]",;
     /* pre-validacao */    "acumproc<maxproc",;
     /* validacao     */    "cpadmiss$[SN]~Digite S ou N|S, n„o ser„o incluidos atendimentos|efetuados antes da admiss„o do contrato.",;
     /* help do campo */    "Se digitar S, n„o ser„o incluidos atendimentos|efetuados antes da admiss„o do contrato|quando da 1¦Cobran‡a.";
                         };
)
AADD(sistema[16,O_CAMPO],{;            // ARQGRUP
     /* mascara       */    "999",;
     /* titulo        */    "Periodicidade",;
     /* cmd especial  */    "",;
     /* default       */    "IIF(CLASSES->prior=[S],30,INT((VAL(final)-VAL(inicio)+1)*90/500))",;
     /* pre-validacao */    "",;
     /* validacao     */    "!(periodic<0)~PERIODICIDADE n„o aceit vel",;
     /* help do campo */    "Informe o intervalo m¡nimo em dias entre circulares.";
                         };
)
AADD(sistema[16,O_CAMPO],{;            // ARQGRUP
     /* mascara       */    "999",;
     /* titulo        */    "Remido",;
     /* cmd especial  */    "",;
     /* default       */    "acumproc*5",;
     /* pre-validacao */    "",;
     /* validacao     */    "!(qtdremir<0)~REMIDO n„o aceit vel",;
     /* help do campo */    "Entre com o n§ de taxas nescess rias para que|o processo fique remido.";
                         };
)
AADD(sistema[16,O_CAMPO],{;            // ARQGRUP
     /* mascara       */    "!",;
     /* titulo        */    "P/Atend.",;
     /* cmd especial  */    "",;
     /* default       */    "[S]",;
     /* pre-validacao */    "",;
     /* validacao     */    "poratend$[SN]~Digite|S para deixar de ser remido na utiliza‡„o|ou|N para continuar remido.",;
     /* help do campo */    "Digite S para considerar uma quantidade|a ser paga por atendimento efetuado|ou N para considerar quantidade total.";
                         };
)
AADD(sistema[16,O_CAMPO],{;            // ARQGRUP
     /* mascara       */    "999",;
     /* titulo        */    "Ultcirc",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[16,O_CAMPO],{;            // ARQGRUP
     /* mascara       */    "@D",;
     /* titulo        */    "Emissao",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[16,O_CAMPO],{;            // ARQGRUP
     /* mascara       */    "999",;
     /* titulo        */    "Processos",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[16,O_CAMPO],{;            // ARQGRUP
     /* mascara       */    "999999",;
     /* titulo        */    "Contratos",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[16,O_CAMPO],{;            // ARQGRUP
     /* mascara       */    "999999",;
     /* titulo        */    "Partic.",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[16,O_CAMPO],{;            // ARQGRUP
     /* mascara       */    "999",;
     /* titulo        */    "N§Proxima Circ.",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "nivelop=3",;
     /* validacao     */    "proxcirc>=ultcirc.OR.proxcirc=[000]~A Pr¢xima circular deve ser maior|ou igual a| £ltima emitida ou zeros p/ n„o emitir.",;
     /* help do campo */    "Entre com o n£mero da pr¢xima circular ou|zeros se n„o for emitir.";
                         };
)
AADD(sistema[16,O_FORMULA],{;          // ARQGRUP - Classe/Categor.
     /* form mostrar  */    "LEFT(TRAN(CLASSES->descricao,[]),25)",;
     /* lin da formula*/    2,;
     /* col da formula*/    17;
                         };
)
AADD(sistema[16,O_FORMULA],{;          // ARQGRUP - Ultcirc
     /* form mostrar  */    "LEFT(TRAN(ultcirc,[999]),03)",;
     /* lin da formula*/    13,;
     /* col da formula*/    19;
                         };
)
AADD(sistema[16,O_FORMULA],{;          // ARQGRUP - Emissao
     /* form mostrar  */    "LEFT(TRAN(emissao_,[@D]),08)",;
     /* lin da formula*/    13,;
     /* col da formula*/    33;
                         };
)
AADD(sistema[16,O_FORMULA],{;          // ARQGRUP - Processos
     /* form mostrar  */    "LEFT(TRAN(procpend,[999]),03)",;
     /* lin da formula*/    15,;
     /* col da formula*/    10;
                         };
)
AADD(sistema[16,O_FORMULA],{;          // ARQGRUP - Contratos
     /* form mostrar  */    "LEFT(TRAN(contrat,[999999]),06)",;
     /* lin da formula*/    14,;
     /* col da formula*/    2;
                         };
)
AADD(sistema[16,O_FORMULA],{;          // ARQGRUP - Partic.
     /* form mostrar  */    "LEFT(TRAN(partic,[999999]),06)",;
     /* lin da formula*/    14,;
     /* col da formula*/    27;
                         };
)


sistema[17]={;
            "Cobran‡as",;                                   // opcao do menu
            "Cobran‡as",;                                   // titulo do sistema
            {"grup+mesref"},;                               // chaves do arquivo
            {"C¢digo/Cobrador"},;                           // titulo dos indices para consulta
            {"0102"},;                                      // ordem campos chaves
            "FCGRUPO",;                                     // nome do DBF
            {"FCGRUPO1"},;                                  // nomes dos NTX
            {},;                                            // nome dos dbf's relacionados
            {"ARQGRUP->grup"},;                             // campos de relacionamento
            {1,1,15,3,23,77,2,6},;                          // num telas/tela atual/coordenadas/inicio scroll/qtde scroll
            {1,.t.},;                                       // nivel acesso/tp chave
            {},;                                            // campos do arquivo
            {},;                                            // formula mostradas
            {"",""},;                                       // condicao de exclusao de registros
            {"",""},;                                       // condicao de alteracao de registros
            {"",""};                                        // condicao de recupercao de registros
           }

AADD(sistema[17,O_CAMPO],{;            // FCGRUPO
     /* mascara       */    "!!",;
     /* titulo        */    "Grupo",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[17,O_CAMPO],{;            // FCGRUPO
     /* mascara       */    "@R 99/99",;
     /* titulo        */    "Mes",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "MMAA(mesref).AND.!EMPT(mesref)~MES n„o aceit vel",;
     /* help do campo */    "Informe o mes da cobran‡a.";
                         };
)
AADD(sistema[17,O_CAMPO],{;            // FCGRUPO
     /* mascara       */    "999999",;
     /* titulo        */    "Qtdemit",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[17,O_CAMPO],{;            // FCGRUPO
     /* mascara       */    "999999",;
     /* titulo        */    "Qtdbaixa",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[17,O_CAMPO],{;            // FCGRUPO
     /* mascara       */    "999999",;
     /* titulo        */    "Qtdret",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[17,O_CAMPO],{;            // FCGRUPO
     /* mascara       */    "@E 999,999.99",;
     /* titulo        */    "Valor",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[17,O_CAMPO],{;            // FCGRUPO
     /* mascara       */    "@E 999,999.99",;
     /* titulo        */    "Valor",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[17,O_CAMPO],{;            // FCGRUPO
     /* mascara       */    "@E 999,999.99",;
     /* titulo        */    "Valor",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[17,O_CAMPO],{;            // FCGRUPO
     /* mascara       */    "!",;
     /* titulo        */    "Flag",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[17,O_FORMULA],{;          // FCGRUPO - Total Entregue
     /* form mostrar  */    "LEFT(TRAN(vlentr,[@E 999,999.99]),10)",;
     /* lin da formula*/    {||l_a},;
     /* col da formula*/    13;
                         };
)
AADD(sistema[17,O_FORMULA],{;          // FCGRUPO - Total recebido
     /* form mostrar  */    "LEFT(TRAN(vlreceb,[@E 999,999.99]),10)",;
     /* lin da formula*/    {||l_a},;
     /* col da formula*/    30;
                         };
)
AADD(sistema[17,O_FORMULA],{;          // FCGRUPO - Total retorno
     /* form mostrar  */    "LEFT(TRAN(vlretorn,[@E 999,999.99]),10)",;
     /* lin da formula*/    {||l_a},;
     /* col da formula*/    47;
                         };
)
AADD(sistema[17,O_FORMULA],{;          // FCGRUPO - Qtdemit
     /* form mostrar  */    "LEFT(TRAN(qtdemit,[999999]),06)",;
     /* lin da formula*/    {||l_a},;
     /* col da formula*/    7;
                         };
)
AADD(sistema[17,O_FORMULA],{;          // FCGRUPO - Qtdbaixa
     /* form mostrar  */    "LEFT(TRAN(qtdpaga,[999999]),06)",;
     /* lin da formula*/    {||l_a},;
     /* col da formula*/    24;
                         };
)
AADD(sistema[17,O_FORMULA],{;          // FCGRUPO - Qtdret
     /* form mostrar  */    "LEFT(TRAN(qtdret,[999999]),06)",;
     /* lin da formula*/    {||l_a},;
     /* col da formula*/    41;
                         };
)
AADD(sistema[17,O_FORMULA],{;          // FCGRUPO - Qtd.Pendente
     /* form mostrar  */    "LEFT(TRAN(qtdemit-qtdpaga-qtdret,[99999]),05)",;
     /* lin da formula*/    {||l_a},;
     /* col da formula*/    58;
                         };
)
AADD(sistema[17,O_FORMULA],{;          // FCGRUPO - Valor pend.
     /* form mostrar  */    "LEFT(TRAN(vlentr-vlreceb-vlretorn,[@E 999,999.99]),10)",;
     /* lin da formula*/    {||l_a},;
     /* col da formula*/    63;
                         };
)


sistema[18]={;
            "Taxas a processar",;                           // opcao do menu
            "Taxas a processar",;                           // titulo do sistema
            {"codigo+tipo+circ"},;                          // chaves do arquivo
            {"Contrato/Circular"},;                         // titulo dos indices para consulta
            {"010203"},;                                    // ordem campos chaves
            "TXPROC",;                                      // nome do DBF
            {"TXPROC1"},;                                   // nomes dos NTX
            {},;                                            // nome dos dbf's relacionados
            {},;                                            // campos de relacionamento
            {1,1,13,1,23,79,3,7},;                          // num telas/tela atual/coordenadas/inicio scroll/qtde scroll
            {0,.t.},;                                       // nivel acesso/tp chave
            {},;                                            // campos do arquivo
            {},;                                            // formula mostradas
            {"",""},;                                       // condicao de exclusao de registros
            {"",""},;                                       // condicao de alteracao de registros
            {"",""};                                        // condicao de recupercao de registros
           }

AADD(sistema[18,O_CAMPO],{;            // TXPROC
     /* mascara       */    "999999",;
     /* titulo        */    "Codigo",;
     /* cmd especial  */    "VDBF(6,31,20,77,'GRUPOS',{'codigo','nome'},4,'codigo')",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "PTAB(codigo,'GRUPOS',1)~CODIGO n„o aceit vel|Tecle F8 para consulta",;
     /* help do campo */    "Entre com o n£mero do contrato|Tecle F8 para consulta";
                         };
)
AADD(sistema[18,O_CAMPO],{;            // TXPROC
     /* mascara       */    "!",;
     /* titulo        */    "Tipo",;
     /* cmd especial  */    "MTAB([1=J¢ia |2=Taxa |3=Carnˆ|6=J¢ia+Seguro|7=Taxa+Seguro|8=Carnˆ+Seguro],[TIPO])",;
     /* default       */    "",;
     /* pre-validacao */    "nivelop=3",;
     /* validacao     */    "tipo $ [1236789]~TIPO n„o aceit vel",;
     /* help do campo */    "Qual o tipo de lan‡amento";
                         };
)
AADD(sistema[18,O_CAMPO],{;            // TXPROC
     /* mascara       */    "999",;
     /* titulo        */    "Circular",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(circ)~Necess rio informar CIRCULAR v lida",;
     /* help do campo */    "Informe o n£mero da circular a consultar";
                         };
)
AADD(sistema[18,O_CAMPO],{;            // TXPROC
     /* mascara       */    "@D",;
     /* titulo        */    "Emissao",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(emissao_)~Necess rio informar EMISSAO v lida",;
     /* help do campo */    "Data da Emiss„o da Circular|Mantido pela emissao do recibo";
                         };
)
AADD(sistema[18,O_CAMPO],{;            // TXPROC
     /* mascara       */    "@E 999,999.99",;
     /* titulo        */    "Valor",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "valor>0~VALOR n„o aceit vel",;
     /* help do campo */    "";
                         };
)
AADD(sistema[18,O_CAMPO],{;            // TXPROC
     /* mascara       */    "@D",;
     /* titulo        */    "Pagamento",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "nivelop=3",;
     /* validacao     */    "",;
     /* help do campo */    "Informe a data de pagamento/Baixa";
                         };
)
AADD(sistema[18,O_CAMPO],{;            // TXPROC
     /* mascara       */    "@E 999,999.99",;
     /* titulo        */    "Valor pago",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "nivelop=3",;
     /* validacao     */    "!(valorpg<0)~VALOR PAGO n„o aceit vel",;
     /* help do campo */    "Informe o valor pago/baixado";
                         };
)
AADD(sistema[18,O_CAMPO],{;            // TXPROC
     /* mascara       */    "!!!",;
     /* titulo        */    "Cobrador",;
     /* cmd especial  */    "VDBF(6,3,20,77,'COBRADOR',{'cobrador','funcao','nome','cidade','telefone'},1,'cobrador',[])",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "PTAB(cobrador,'COBRADOR',1)~Problemas encontrados no arquivo Cobrador ou |Circular do grupo n„o cadastrada para|este cobrador.",;
     /* help do campo */    "Informe o Cobrador que recebeu este.";
                         };
)
AADD(sistema[18,O_CAMPO],{;            // TXPROC
     /* mascara       */    "!",;
     /* titulo        */    "Forma",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "nivelop=3",;
     /* validacao     */    "forma$[PR ]~FORMA n„o aceit vel",;
     /* help do campo */    "Esta lan‡amento foi Pago ou Cancelado|Deixe sem preencher se ainda em aberto";
                         };
)
AADD(sistema[18,O_CAMPO],{;            // TXPROC
     /* mascara       */    "@D",;
     /* titulo        */    "Baixa_",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[18,O_CAMPO],{;            // TXPROC
     /* mascara       */    "",;
     /* titulo        */    "Por",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[18,O_CAMPO],{;            // TXPROC
     /* mascara       */    "9",;
     /* titulo        */    "Status",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[18,O_CAMPO],{;            // TXPROC
     /* mascara       */    "@!",;
     /* titulo        */    "Filial",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[18,O_CAMPO],{;            // TXPROC
     /* mascara       */    "!",;
     /* titulo        */    "AtP",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[18,O_CAMPO],{;            // TXPROC
     /* mascara       */    "!",;
     /* titulo        */    "AtC",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[18,O_CAMPO],{;            // TXPROC
     /* mascara       */    "!",;
     /* titulo        */    "AtR",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[18,O_FORMULA],{;          // TXPROC - Status
     /* form mostrar  */    "LEFT(TRAN(IIF(PTAB(codigo+tipo+circ,'TAXAS',1),TAX_02F9(),[ ]),[]),08)",;
     /* lin da formula*/    {||l_a},;
     /* col da formula*/    66;
                         };
)
AADD(sistema[18,O_FORMULA],{;          // TXPROC - Por
     /* form mostrar  */    "LEFT(TRAN(LEFT(por,9),[]),09)",;
     /* lin da formula*/    {||l_a},;
     /* col da formula*/    56;
                         };
)
AADD(sistema[18,O_FORMULA],{;          // TXPROC - ATPCR
     /* form mostrar  */    "LEFT(TRAN(ATP+ATC+ATR,[!!!]),03)",;
     /* lin da formula*/    {||l_a},;
     /* col da formula*/    75;
                         };
)


sistema[19]={;
            "Regi”es",;                                     // opcao do menu
            "Regi”es",;                                     // titulo do sistema
            {"codigo","regiao"},;                           // chaves do arquivo
            {"p/C¢digo","Nome"},;                           // titulo dos indices para consulta
            {"01","02"},;                                   // ordem campos chaves
            "REGIAO",;                                      // nome do DBF
            {"REGIAO1","REGIAO2"},;                         // nomes dos NTX
            {},;                                            // nome dos dbf's relacionados
            {},;                                            // campos de relacionamento
            {1,1,8,14,15,67,3,4},;                          // num telas/tela atual/coordenadas/inicio scroll/qtde scroll
            {1,.t.},;                                       // nivel acesso/tp chave
            {},;                                            // campos do arquivo
            {},;                                            // formula mostradas
            {"nivelop>1","Permitido apenas a usu rios cadastrados|com n¡vel de Manuten‡„o ou Maior"},;// condicao de exclusao de registros
            {"nivelop>1","Permitido apenas a usu rios cadastrados|com n¡vel de Manuten‡„o ou Maior"},;// condicao de alteracao de registros
            {"nivelop>1","Permitido apenas a usu rios cadastrados|com n¡vel de Manuten‡„o ou Maior"};// condicao de recupercao de registros
           }

AADD(sistema[19,O_CAMPO],{;            // REGIAO
     /* mascara       */    "999",;
     /* titulo        */    "C¢digo",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "V",;
     /* help do campo */    "";
                         };
)
AADD(sistema[19,O_CAMPO],{;            // REGIAO
     /* mascara       */    "",;
     /* titulo        */    "Descri‡„o",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(regiao)~Necess rio informar a REGIAO",;
     /* help do campo */    "Informe o nome do bairro, distrito ou regi„o";
                         };
)
AADD(sistema[19,O_CAMPO],{;            // REGIAO
     /* mascara       */    "!!!",;
     /* titulo        */    "Cobrador",;
     /* cmd especial  */    "VDBF(6,11,20,77,'COBRADOR',{'cobrador','nome','cidade'},1,'cobrador')",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "PTAB(cobrador,'COBRADOR',1).OR.EMPT(cobrador)~Necess rio informar COBRADOR",;
     /* help do campo */    "Informe o c¢digo do cobrador.|F8 consulta em tabela.";
                         };
)


sistema[20]={;
            "Cobradores/Vendedores",;                       // opcao do menu
            "Cobradores/Vendedores",;                       // titulo do sistema
            {"cobrador"},;                                  // chaves do arquivo
            {"C¢digo"},;                                    // titulo dos indices para consulta
            {"01"},;                                        // ordem campos chaves
            "COBRADOR",;                                    // nome do DBF
            {"COBRADO1"},;                                  // nomes dos NTX
            {"PCBRAD","FCCOB"},;                            // nome dos dbf's relacionados
            {},;                                            // campos de relacionamento
            {1,1,6,15,16,66},;                              // num telas/tela atual/coordenadas
            {1,.t.},;                                       // nivel acesso/tp chave
            {},;                                            // campos do arquivo
            {},;                                            // formula mostradas
            {"",""},;                                       // condicao de exclusao de registros
            {"",""},;                                       // condicao de alteracao de registros
            {"",""};                                        // condicao de recupercao de registros
           }

AADD(sistema[20,O_CAMPO],{;            // COBRADOR
     /* mascara       */    "!!!",;
     /* titulo        */    "Cobrador",;
     /* cmd especial  */    "COB_01F9()",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(cobrador)~Necess rio informar COBRADOR",;
     /* help do campo */    "Informe um c¢digo para o cobrador.";
                         };
)
AADD(sistema[20,O_CAMPO],{;            // COBRADOR
     /* mascara       */    "!",;
     /* titulo        */    "Fun‡„o",;
     /* cmd especial  */    "MTAB([Cobrador|Vendedor|Supervisor],[FUN€ŽO])",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "funcao $ [CVS]~FUN€ŽO n„o aceit vel",;
     /* help do campo */    "Informe se ‚ um Cobrador ou Vendedor|";
                         };
)
AADD(sistema[20,O_CAMPO],{;            // COBRADOR
     /* mascara       */    "",;
     /* titulo        */    "Nome do Cobrador",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(nome)~Necess rio informar NOME DO COBRADOR",;
     /* help do campo */    "";
                         };
)
AADD(sistema[20,O_CAMPO],{;            // COBRADOR
     /* mascara       */    "",;
     /* titulo        */    "Endere‡o",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    "";
                         };
)
AADD(sistema[20,O_CAMPO],{;            // COBRADOR
     /* mascara       */    "",;
     /* titulo        */    "Bairro",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    "";
                         };
)
AADD(sistema[20,O_CAMPO],{;            // COBRADOR
     /* mascara       */    "",;
     /* titulo        */    "Cidade",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    "";
                         };
)
AADD(sistema[20,O_CAMPO],{;            // COBRADOR
     /* mascara       */    "",;
     /* titulo        */    "Telefone",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    "";
                         };
)
AADD(sistema[20,O_CAMPO],{;            // COBRADOR
     /* mascara       */    "@R 999.999.999-99",;
     /* titulo        */    "CPF",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "VDV2(cpf).OR.EMPT(cpf)~CPF n„o aceit vel",;
     /* help do campo */    "";
                         };
)
AADD(sistema[20,O_CAMPO],{;            // COBRADOR
     /* mascara       */    "@S35",;
     /* titulo        */    "Observa‡Æo",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    "";
                         };
)
AADD(sistema[20,O_CAMPO],{;            // COBRADOR
     /* mascara       */    "999.9",;
     /* titulo        */    "Percentual",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "!(percent<0).AND.!(percent>100)~PERCENTUAL n„o aceit vel",;
     /* help do campo */    "Informe o percentual de comiss„o";
                         };
)
AADD(sistema[20,O_CAMPO],{;            // COBRADOR
     /* mascara       */    "!!!",;
     /* titulo        */    "Supervisor",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    "Digite o c¢digo do SUPERVISOR deste cobrador";
                         };
)
AADD(sistema[20,O_FORMULA],{;          // COBRADOR - Fun‡„o
     /* form mostrar  */    "LEFT(TRAN(SUBSTR([Cobrador  |Vendedor  |Supervisor],AT(funcao,[Cobrador  |Vendedor  |Supervisor]),10),[]),10)",;
     /* lin da formula*/    1,;
     /* col da formula*/    35;
                         };
)


sistema[21]={;
            "Parcelas do Vendedor",;                        // opcao do menu
            "Parcelas do Vendedor",;                        // titulo do sistema
            {"cobrador+tipo+circ"},;                        // chaves do arquivo
            {"C¢digo/Cobrador"},;                           // titulo dos indices para consulta
            {"010203"},;                                    // ordem campos chaves
            "PCBRAD",;                                      // nome do DBF
            {"PCBRAD1"},;                                   // nomes dos NTX
            {},;                                            // nome dos dbf's relacionados
            {"COBRADOR->cobrador"},;                        // campos de relacionamento
            {1,1,15,13,22,67,3,4},;                         // num telas/tela atual/coordenadas/inicio scroll/qtde scroll
            {1,.t.},;                                       // nivel acesso/tp chave
            {},;                                            // campos do arquivo
            {},;                                            // formula mostradas
            {"",""},;                                       // condicao de exclusao de registros
            {"",""},;                                       // condicao de alteracao de registros
            {"",""};                                        // condicao de recupercao de registros
           }

AADD(sistema[21,O_CAMPO],{;            // PCBRAD
     /* mascara       */    "!!!",;
     /* titulo        */    "Cobrador",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[21,O_CAMPO],{;            // PCBRAD
     /* mascara       */    "9",;
     /* titulo        */    "Tipo",;
     /* cmd especial  */    "MTAB([1=J¢ia|2=Taxa|3=Carnˆ|6=J¢ia+Seguro|7=Taxa+Seguro|8=Carnˆ+Seguro],[TIPO])",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    "Qual o tipo de lan‡amento";
                         };
)
AADD(sistema[21,O_CAMPO],{;            // PCBRAD
     /* mascara       */    "999",;
     /* titulo        */    "Circular",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "circ>[000]~Necess rio informar CIRCULAR",;
     /* help do campo */    "N£mero da Circular|Mantido pela emissao de recibos";
                         };
)
AADD(sistema[21,O_CAMPO],{;            // PCBRAD
     /* mascara       */    "!",;
     /* titulo        */    "Seg",;
     /* cmd especial  */    "MTAB([Sim, pode ser lan‡ado a parcela do seguro|N„o, acumule o seguro para a pr¢xima taxa.],[SEG])",;
     /* default       */    "[N]",;
     /* pre-validacao */    "",;
     /* validacao     */    "seg $ [SN]~SEG n„o aceit vel",;
     /* help do campo */    "Inclui o valor do seguro nesta taxa?|Digite S se o cobrador/vendedor repassar|o valor do seguro p/a Empresa";
                         };
)
AADD(sistema[21,O_CAMPO],{;            // PCBRAD
     /* mascara       */    "999.99",;
     /* titulo        */    "Comiss„o %",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "pcomiss>=0.and.pcomiss<=100~COMISSŽO % n„o aceit vel",;
     /* help do campo */    "Informe a % de comiss„o|ou zeros para informar|um valor fixo";
                         };
)
AADD(sistema[21,O_CAMPO],{;            // PCBRAD
     /* mascara       */    "@E 999,999.99",;
     /* titulo        */    "Valor",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "pcomiss=0",;
     /* validacao     */    "vlcomiss>=0~VALOR n„o aceit vel",;
     /* help do campo */    "Informe o valor fixo de comiss„o";
                         };
)
AADD(sistema[21,O_CAMPO],{;            // PCBRAD
     /* mascara       */    "!",;
     /* titulo        */    "Flag",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)

* \\ Final de ADR_ATR1.PRG
procedure tfiliais
/*
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
 \ Empresa.: PresServ Inform tica - Limeira (019)452.6623
 \ Programa: TFILIAIS.PRG
 \ Data....: 04-11-03
 \ Sistema.: Administradora - RECEP€„O
 \ Funcao..: Gerenciador do subsistema de filiais
 \ Analista: Ademilson Pedro Bom
 \ Criacao.: GAS-Pro v4.0n
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/
#include "adrbig.ch"    // inicializa constantes manifestas

PARA lin_menu,col_menu
PRIV op_sis, tela_fundo:=SAVESCREEN(0,0,MAXROW(),79), l_s, c_s, l_i, c_i, l_a

op_sis=EVAL(qualsis,"TFILIAIS")
IF nivelop<sistema[op_sis,O_OUTROS,O_NIVEL]        // se usuario nao tem permissao,
 ALERTA()                                          // entao, beep, beep, beep
 DBOX(msg_auto,,,3)                                // lamentamos e
 RETU                                              // retornamos ao menu
ENDI
cn:=fgrep :=.f.

#ifdef COM_LOCK
 IF LEN(pr_ok)>0                                   // se a protecao acusou
  ? pr_ok                                          // erro, avisa e
  QUIT                                             // encerra a aplicacao
 ENDI
#endi

t_fundo=SAVESCREEN(0,0,MAXROW(),79)                // salva tela do fundo
op_cad=1
DO WHIL op_cad!=0
 criterio=""
 RESTSCREEN(0,0,MAXROW(),79,t_fundo)               // restaura tela do fundo
 cod_sos=5 ; cn=.f.
 CLEA TYPEAHEAD                                    // limpa o buffer do teclado
 fgrep=.f.
 SET KEY K_F3 TO                                   // retira das teclas F3 e F4 as
 SET KEY K_F4 TO                                   // funcoes de repeticao e confirmacao
 msg="Inclus„o~1|"+;
     "Manuten‡„o~2|"+;
     "Consulta~3"
 op_cad=DBOX(msg,lin_menu,col_menu,E_MENU,NAO_APAGA,MAIUSC(sistema[op_sis,O_MENU]),,,op_cad)
 IF op_cad!=0                                      // se escolheu uma opcao
  Tela_fundo=SAVESCREEN(0,0,MAXROW(),79)           // salva a tela para ROLATELA()
  PARAMETROS(dbfparam)
  SELE A                                           // e abre o arquivo e seus indices

  #ifdef COM_REDE
   IF !USEARQ(sistema[op_sis,O_ARQUI,O_NOME],.f.,20,1)
                                                   // se falhou a abertura do
    RETU                                           // arquivo volta ao menu anterior
   ENDI
  #else
   USEARQ(sistema[op_sis,O_ARQUI,O_NOME])
  #endi

  SET KEY K_F9 TO veoutros                         // habilita consulta em outros arquivos
 ENDI
 DO CASE
  CASE op_cad=01                                   // inclus„o
   op_menu=INCLUSAO
   IF AT("D",exrot[op_sis])=0                      // se usuario pode fazer inclusao
    TFI_INCL()                                     // neste arquivo chama prg de inclusao
   ELSE                                            // caso contrario vamos avisar que
    ALERTA()                                       // ele nao tem permissao para isto
    DBOX(msg_auto,,,3)
   ENDI

  CASE op_cad=02                                   // manuten‡„o
   op_menu=ALTERACAO
   cod_sos=7
   EDIT()

  CASE op_cad=03                                   // consulta
   op_menu=PROJECOES
   cod_sos=8
   EDITA(03,03,MAXROW()-2,77)

 ENDC
 SET KEY K_F9 TO                                   // F9 nao mais consultara outros arquivos
 CLOS ALL                                          // fecha todos arquivos abertos
ENDD
RETU

PROC TFI_incl(reg_cop)  // inclusao no arquivo TFILIAIS
LOCAL getlist:={}, cabem:=1, rep:=ARRAY(FCOU()), ult_reg:=RECN(), cond_incl_,;
      ctl_r, ctl_c, ctl_w, t_f3_, t_f4_, dele_atu:=SET(_SET_DELETED,.f.)
PRIV op_menu:=INCLUSAO, tem_borda, criterio:="", cpord:=""
cond_incl_={||nivelop>1}                           // condicao de inclusao de registros
IF !EVAL(cond_incl_)                               // se nao pode incluir
 ALERTA(2)                                         // avisa o motivo
 DBOX("Permitido apenas a usu rios cadastrados|com n¡vel de Manuten‡„o ou Maior",,,4,,"ATEN€ŽO, "+usuario)
 RETU                                              // e retorna
ENDI
FOR i=1 TO FCOU()                                  // cria/declara privadas as
 msg=FIEL(i)                                       // variaveis de memoria com
 PRIV &msg.                                        // o mesmo nome dos campos
NEXT                                               // do arquivo
IF reg_cop!=NIL                                    // quer repetir todo o reg atual
 FOR i=1 TO FCOU()                                 // para cada campo,
  msg=FIEL(i)                                      // salva o conteudo
  rep[i]=&msg.                                     // para repetir
 NEXT
ELSE
 AFILL(rep,"")                                     // eche com valor vazio
ENDI
t_f3_=SETKEY(K_F3,{||rep()})                       // repeticao reg anterior
t_f4_=SETKEY(K_F4,{||conf()})                      // confirma campos com ENTER
ctl_w=SETKEY(K_CTRL_W,{||nadafaz()})               // enganando o CA-Clipper...
ctl_c=SETKEY(K_CTRL_C,{||nadafaz()})
ctl_r=SETKEY(K_CTRL_R,{||nadafaz()})
DO WHIL cabem>0
 cod_sos=6
 rola_t=.f.                                        // flag se quer rolar a tela
 SELE TFILIAIS
 GO BOTT                                           // forca o
 SKIP                                              // final do arquivo
 
 /*
    cria variaveis de memoria identicas as de arquivo, para inclusao
    de registros
 */
 FOR i=1 TO FCOU()
  msg=FIEL(i)
  M->&msg.=IF((fgrep .OR. reg_cop!=NIL).AND.!EMPT(rep[1]),rep[i],&msg.)
 NEXT
 DISPBEGIN()                                       // apresenta a tela de uma vez so
 TFI_TELA()
 INFOSIS(.t.)                                      // exibe informacao no rodape' da tela
 DISPEND()
 IF !EVAL(cond_incl_)
  EXIT
 ENDI
 cabem=DISKSPACE(;
          IF(;
             LEN(sistema[op_sis,O_ARQUI,O_DIR_DBF])<2.OR.sistema[op_sis,O_ARQUI,O_DIR_DBF]="\",;
             0,;
             ASC(sistema[op_sis,O_ARQUI,O_DIR_DBF])-64;
          );
       )
 cabem=INT((cabem-2048)/TFILIAIS->(RECSIZE()))
 IF cabem<1                                        // mais nenhum!!!
  ALERTA()
  msg="Verifique ESPA€O EM DISCO, "+usuario
  DBOX(msg,,,,,"INCLUSŽO INTERROMPIDA!")           // vamos parar por aqui!
  EXIT
 ENDI
 SELE 0                                            // torna visiveis variaveis de memoria
 SETCOLOR(drvcortel+","+drvcorget+",,,"+corcampo)
 SET KEY K_ALT_F8 TO ROLATELA
 
 /*
    recebe chaves do arquivo de indice basico
 */
 @ l_s+01 ,c_s+15 GET  codigo;
                  PICT sistema[op_sis,O_CAMPO,01,O_MASC]
                  DEFINICAO 1

 READ
 SET KEY K_ALT_F8 TO
 IF rola_t
  ROLATELA()
  LOOP
 ENDI
 SELE TFILIAIS
 IF LASTKEY()=K_ESC                                // cancelou ou chave em branco
  cabem=0                                          // prepara saida da inclusao
  LOOP                                             // volta p/ menu de cadastramento
 ENDI
 SEEK M->codigo
 aprov_reg_=(FOUND().AND.DELE().AND.!drvvisivel)   // vai aproveitar o registro?
 IF FOUND() .AND. !aprov_reg_                      // pesquisou e achou!
  op_menu=ALTERACAO                                // seta flag de ateracao
  DISPBEGIN()
  TFI_GETS()                                       // mostra conteudo do registro
  INFOSIS(.f.)                                     // exibe informacao no rodape' da tela
  DISPEND()
  ALERTA()
  msg="Consultar/alterar|Retornar … inclus„o"      // pergunta se deseja
  op_=DBOX(msg,,,E_MENU,,"REGISTRO J EXISTE")     // alterar o registro
  IF op_ =1                                        // caso afirmativo
   EDIT()                                          // deixa alterar
  ENDI
  op_menu=INCLUSAO
  LOOP                                             // volta para inclusao
 ENDI
 SELE 0
 TFI_GET1(INCLUI)                                  // recebe campos
 SELE TFILIAIS
 IF LASTKEY()=K_ESC                                // se cancelou
  ALERTA()                                         // avisa que o registro
  DBOX("Registro n„o inclu¡do!",18,,1)             // nao foi incluido, e volta
  LOOP
 ENDI

 #ifdef COM_REDE
  GO BOTT                                          // vamos bloquear o final do
  SKIP                                             // arq para que nehum outro
  BLOREG(0,.5)                                     // usuario possa incluir
  SEEK M->codigo                                   // se registro foi incluido
  aprov_reg_=(FOUND().AND.DELE().AND.!drvvisivel)  // vai aproveitar o registro?
  IF FOUND() .AND. !aprov_reg_                     // por outro usuario, entao
   BLOREG(0,.5)
   FOR i=1 TO FCOU()
    msg=FIEL(i)
    rep[i]=&msg.
    REPL &msg. WITH M->&msg.
   NEXT
   TFI_GET1(FORM_INVERSA)                          // executa formula inversa
   RECA
   FOR i=1 TO FCOU()
    msg=FIEL(i)
    REPL &msg. WITH rep[i]
   NEXT
   ALERTA(4)                                       // beep 4 vezes
   msg="Registro acabou de ser|inclu¡do por outro usu rio!"
   DBOX(msg,,,,,"ATEN€ŽO!")                        // avisa
   SELE TFILIAIS
   UNLOCK                                          // libera o registro
   LOOP                                            // e recebe chave novamente
  ENDI
 #endi

 IF aprov_reg_                                     // se vai aproveitar reg excluido

  #ifdef COM_REDE
   BLOREG(0,.5)
  #endi

  RECA                                             // excluido, vamos recupera-lo
 ELSE                                              // caso contrario
  APPEND BLANK                                     // inclui reg em branco no dbf
 ENDI
 FOR i=1 TO FCOU()                                 // para cada campo,
  msg=FIEL(i)                                      // salva o conteudo
  rep[i]=M->&msg.                                  // para repetir
  REPL &msg. WITH rep[i]                           // enche o campo do arquivo
 NEXT

 #ifdef COM_REDE
  UNLOCK                                           // libera o registro e
  COMMIT                                           // forca gravacao
 #else
  IF RECC()-INT(RECC()/20)*20=0                    // a cada 20 registros
   COMMIT                                          // digitados forca gravacao
  ENDI
 #endi

 ult_reg=RECN()                                    // ultimo registro digitado
 IF reg_cop!=NIL                                   // estava na consulta e quis rep o campo
  EXIT                                             // cai fora...
 ENDI
ENDD
GO ult_reg                                         // para o ultimo reg digitado
SETKEY(K_F3,t_f3_)                                 // restaura teclas de funcoes
SETKEY(K_F4,t_f4_)
SET(_SET_DELETED,dele_atu)                            // ecluidos visiveis/invisiveis
SETKEY(K_CTRL_W,ctl_w)
SETKEY(K_CTRL_C,ctl_c)
SETKEY(K_CTRL_R,ctl_r)
RETU


PROC TFI_tela     // tela do arquivo TFILIAIS
tem_borda=.t.
l_s=Sistema[op_sis,O_TELA,O_LS]           // coordenadas da tela
c_s=Sistema[op_sis,O_TELA,O_CS]
l_i=Sistema[op_sis,O_TELA,O_LI]
c_i=Sistema[op_sis,O_TELA,O_CI]
SETCOLOR(drvtittel)
vr_memo=NOVAPOSI(@l_s,@c_s,@l_i,@c_i)     // pega posicao atual da tela
CAIXA(mold,l_s,c_s,l_i,c_i)               // monta caixa da tela
i=LEN(sistema[op_sis,O_MENS])/2
@ l_s,c_s-1+(c_i-c_s+1)/2-i SAY " "+MAIUSC(sistema[op_sis,O_MENS])+" "
SETCOLOR(drvcortel)
@ l_s+01,c_s+1 SAY " C¢digo.....:             Abreviatura:"
@ l_s+02,c_s+1 SAY " Nome.......:"
@ l_s+03,c_s+1 SAY " Endereco...:"
@ l_s+04,c_s+1 SAY " Cidade.....:"
@ l_s+05,c_s+1 SAY " Ref........:"
@ l_s+06,c_s+1 SAY " Contato....:"
RETU

PROC TFI_gets     // mostra variaveis do arquivo TFILIAIS
LOCAL getlist := {}, t_f7_
TFI_TELA()
SETCOLOR(drvcortel+","+drvcorget+",,,"+corcampo)
@ l_s+01 ,c_s+15 GET  codigo;
                 PICT sistema[op_sis,O_CAMPO,01,O_MASC]

@ l_s+01 ,c_s+40 GET  abrev

@ l_s+02 ,c_s+15 GET  nome;
                 PICT sistema[op_sis,O_CAMPO,03,O_MASC]

@ l_s+03 ,c_s+15 GET  endereco;
                 PICT sistema[op_sis,O_CAMPO,04,O_MASC]

@ l_s+04 ,c_s+15 GET  cidade;
                 PICT sistema[op_sis,O_CAMPO,05,O_MASC]

@ l_s+05 ,c_s+15 SAY "{M} "

@ l_s+06 ,c_s+15 GET  contato;
                 PICT sistema[op_sis,O_CAMPO,07,O_MASC]

CLEAR GETS
RETU

PROC TFI_get1(tp_mov)     // capta variaveis do arquivo TFILIAIS
LOCAL getlist := {}, t_f7_
PRIV  blk_tfiliais:=.t.

IF tp_mov=INCLUI
 DO WHILE .t.
  rola_t=.f.
  memo06:="{F7}"
  t_f7_=SETKEY(K_F7,{||TFI_memo()})
  SET KEY K_ALT_F8 TO ROLATELA
  SETCOLOR(drvcortel+","+drvcorget+",,,"+corcampo)
  @ l_s+01 ,c_s+40 GET  abrev
                   DEFINICAO 2

  @ l_s+02 ,c_s+15 GET  nome;
                   PICT sistema[op_sis,O_CAMPO,03,O_MASC]
                   DEFINICAO 3

  @ l_s+03 ,c_s+15 GET  endereco;
                   PICT sistema[op_sis,O_CAMPO,04,O_MASC]
                   DEFINICAO 4

  @ l_s+04 ,c_s+15 GET  cidade;
                   PICT sistema[op_sis,O_CAMPO,05,O_MASC]
                   DEFINICAO 5

  @ l_s+05 ,c_s+15 GET  memo06;
                   PICT "@!"
                   DEFINICAO 6

  @ l_s+06 ,c_s+15 GET  contato;
                   PICT sistema[op_sis,O_CAMPO,07,O_MASC]
                   DEFINICAO 7

  READ
  SETKEY(K_F7,t_f7_)
  SET KEY K_ALT_F8 TO
  IF rola_t
   ROLATELA()
   LOOP
  ENDI
  IF LASTKEY()!=K_ESC .AND. drvincl .AND. op_menu=INCLUSAO
   IF !CONFINCL()
    LOOP
   ENDI
  ENDI
  EXIT
 ENDD
ENDI
IF tp_mov=EXCLUI .OR. tp_mov=FORM_INVERSA
 DELE
ELSEIF tp_mov=INCLUI .OR. tp_mov=RECUPERA .OR. tp_mov=FORM_DIRETA
 IF op_menu!=INCLUSAO
  RECA
 ENDI
ENDI
RETU

PROC TFI_MEMO
IF READVAR()="MEMO06"
 EDIMEMO("ref",sistema[op_sis,O_CAMPO,06,O_TITU],14,2,23,38)
ENDI
RETU

* \\ Final de TFILIAIS.PRG
€
 DCI_P001^–Ñ  DCI_P001CODEC_ETEXTENDCODE	_SYMSTARTSYMSTARTSYMBOLSSYMBOLS_SYMENDSYMENDNULLBEGDATA_DATADATA_SYMPBDATA_SYMPDATA_SYMPEDATA_CONSTCONST_MSGMSG_BEGBSSBEGBSS_BSSBSS_ENDBSSENDBSSDGROUP˜ @˜ H  ˜ h  ë˜ `P	›˜ h  
ã˜ h  ß˜ H  û˜ H  ÷˜ H ë˜ H  ï˜ H  ë˜ (  ˜ H  GAS-Pro v4.0
002003024079001036002016023000142001







                                  RECIBO

                                                      Processo

   Nome do Contratante:

   Endere‡o:

     Cidade               Estado  Documento de Identidade Estado Civil


     Contrato    Grupo            Admiss„o                 Processo



    Nome do falecido....:
    Endere‡o do falecido:
    Inscrito neste contrato na qualidade de
    Data do Falecimento.:           Hor rio do Falecimento:

    Cidade do Falecimento Estado   Local do falecimento


    Cemit‚rio onde foi sepultado        Hora do sepultamento



    Datado em       de                    de           , conforme processo
  administrativo n£mero         .



 PROCESSAR
PAGAMENTO EM



                     ------------------------------------------
                     Ass.:
                           RG:
[Ÿ]
 28 
AFUNER
Recibo Modelo 2


PTAB(PADR(SUBSTR(M->ide_maq,2),4)+[AFU],[IMPPAR],1).and.processo+proc2+filial+categ=ALLTRIM(IMPPAR->docto)
011

























 0 
 1 










 0 
 1 
 0 
 66 
 0 
 9 
 3 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
-1 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
Nome do contratante
IIF(PTAB(contrato+GRUPOS->titular,'INSCRITS',1),INSCRITS->nome,GRUPOS->nome)
@!
 35 
C
 12 
 25 


û         










Nr.Processo
processo+proc2
@R 99999/99
 8 
C
 10 
 64 


û         










Processo
processo+proc2
@R 99999/99
 8 
C
 36 
 25 


          










Endereco contratante
GRUPOS->endereco
@!
 40 
C
 14 
 14 


û         










cidade contratante
GRUPOS->cidade
@!
 20 
C
 17 
 6 


û         










Estado Contratante
[  ]
!!
 2 
C
 17 
 29 


          










Doc
GRUPOS->rg

 14 
C
 17 
 38 


û         










Est.Civil contratante
subst(tbestciv,AT(GRUPOS->estcivil,tbestciv),10)
@!
 11 
C
 17 
 60 


û         










contrato numero
contrato

 6 
C
 20 
 7 


û         










grupo
GRUPOS->grupo

 2 
C
 20 
 19 


û         










data admissao
GRUPOS->admissao

 8 
C
 20 
 35 


û         










pedido
Rx2901F9()

 70 
M
 21 
 3 


    û     










nome do falecido
falecido
@!
 35 
C
 23 
 27 


û         










Endereco falecido
ALLTRIM(ruares)+[, ]+ALLTRIM(baires)
@!
 40 
C
 24 
 27 


û         










Cidade Falecimento
municfal

 20 
C
 29 
 5 


û         










UF falecimento
estfal
!!
 2 
C
 29 
 29 


û         










local falecimento
ALLTRIM(ruafal)

 35 
C
 29 
 36 


û         










Cemit‚rio sepultamento
cemitsep

 30 
C
 32 
 5 


û         










Hora sepultamento
horasepult
99:99
 5 
C
 32 
 47 


û         










Inscrito na qualidade de
grauparcon

 15 
C
 25 
 45 


û         










Data falcto.
falecto_
@D
 8 
D
 26 
 27 


          










Hora Falcto.
horafal
99:99
 5 
C
 26 
 61 


          










Proc.pagto em
procpagto_
@D
 8 
D
 42 
 3 


û         










Ident1
M->setup1

 40 
C
 6 
 22 


          










Categoria
IIF(categ=[PD],[Plano c/Difer. ],IIF(categ=[PL],[Atend.Plano],[Rest.Desp.Funerais]))

 18 
C
 1 
 2 


          










Nome
GRUPOS->nome

 35 
C
 46 
 28 


û         










R.G.
GRUPOS->rg
@!
 20 
C
 47 
 32 


          










DATA
IMPAC(RTRIM(M->p_cidade)+[, ]+LEFT(DTOC(DATE()),2)+[ de ]+NMES(MONTH(DATE()))+ [ de ]+LEFT(DTOS(DATE()),4))

 50 
C
 38 
 26 


          










 9 
Nome da empresa
nemp

 0 
 0 
 32 

T¡tulo aplica‡„o
nsis

 0 
 0 
 25 

Data do sistema
DTOC(DATE())

 0 
 0 
 8 

Nome do mˆs
NMES(DATE())

 0 
 0 
 8 

Dia da semana
NSEM(DATE())

 0 
 0 
 7 

N£mero da p gina
TRAN(pg_,'9999')

 0 
 0 
 4 

C¢digo relat¢rio
"ADR_RX29"

 0 
 0 
 8 

T¡tulo a definir
titrel

 0 
 0 
 30 

Hora da emiss„o
hora_rel_

 0 
 0 
 5 

 0 
 0 
 0 
 2 
GRUPOS
 1 
contrato



INSCRITS
 1 
contrato



GAS-Pro v4.0
010010019073001001001001011000176001
 N£mero..:                              (                   )
 Condi‡„o:
 Mensagem:
[Ÿ]
Inclus„o~~26006
Manuten‡„o~~27007
Consulta~~28008
[Ÿ]
 5 
 1 
Sequencia

 1 
[Ÿ]
Mensagem p/Contrato
Mensagem p/Contrato







005
























 0 











 0 
 1 
-1 
-1 
 0 
-1 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
seq
C
E
999999
 6 
 6 
 1 
 12 
 0 
Sequˆncia

!EMPT(seq)
Necess rio informar SEQUENCIA

Informe o n£mero sequencial|os menores ser„o apresentados antes

 0 
 1 


filtro
C
E
 
 210 
 50 
 2 
 12 
 0 
Crit‚rio

TYPE(filtro)#[UI] .OR. VALTYPE(&filtro)=[L]
Informe uma express„o v lida
MEN_01F9()
Informe o crit‚rio de filtragem|para exibi‡„o da mensagem.
MEN_01F9()
 0 
 0 


mens1
M
E

 10 
 50 
 3 
 12 
 0 
Menssagem

!EMPT(mens1)
Informe a mensagem a apresentar,|tecle F7 para entrar e sair do campo

Informe a mensagem que ser  apresentada |na tela quando for satisfeita a condi‡„o informada

 0 
 0 


lancto_
D
I
@D
 8 
 10 
 0 
 0 
 0 
Lan‡amento






 0 
 0 


por
C
I
 
 10 
 10 
 0 
 0 
 0 
Por






 0 
 0 


 7 
Lan‡amento
lancto_
@D
 1 
 42 
 8 

mensagem1
MEMOLINE(MENSAG->mens1,50,1)

 4 
 12 
 50 

MENSAGEM 2
MEMOLINE(MENSAG->mens1,50,2)

 5 
 12 
 50 

MENSAGEM 3
MEMOLINE(MENSAG->mens1,50,3)

 6 
 12 
 50 

MENSAGEM 4
MEMOLINE(MENSAG->mens1,50,4)

 7 
 12 
 50 

MENSAGEM 5
MEMOLINE(MENSAG->mens1,50,5)

 8 
 12 
 50 

Por
por

 1 
 51 
 10 

 2 
MENSAG
por
M->usuario

EMPT(lancto_)


MENSAG
lancto_
DATE()

EMPT(lancto_)


 0 
 0 
 0 
/*
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
 \ Empresa.: PresServ Inform tica-Limeira (019)452.6623
 \ Programa: ADR_RX29.PRG
 \ Data....: 22-09-97
 \ Sistema.: Administradora - RECEP€„O
 \ Funcao..: Recibo Aux.Funeral 1
 \ Analista: Ademilson Pedro Bom
 \ Criacao.: GAS-Pro v3.0 
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/

#include "adrbig.ch"    // inicializa constantes manifestas

LOCAL dele_atu, getlist:={}, so_um_reg, sit_dbf:=POINTER_DBF()
PARA  lin_menu, col_menu, imp_reg
PRIV  tem_borda:=.t., op_menu:=VAR_COMPL, l_s:=10, c_s:=20, l_i:=13, c_i:=61, tela_fundo:=SAVESCREEN(0,0,MAXROW(),79)
nucop=1
so_um_reg=(PCOU()>2)
IF !so_um_reg                             // vai receber a variaveis?
 SETCOLOR(drvtittel)
 vr_memo=NOVAPOSI(@l_s,@c_s,@l_i,@c_i)    // pega posicao atual da tela
 CAIXA(mold,l_s,c_s,l_i,c_i)              // monta caixa da tela
 @ l_s,c_s+10 SAY " RECIBO AUX.FUNERAL 1 "
 SETCOLOR(drvcortel)
 @ l_s+01,c_s+1 SAY " Processo:"
 @ l_s+02,c_s+1 SAY " Confirme:"
ENDI
rproc=SPAC(11)                                     // Processo
confirme=SPAC(1)                                   // Confirme
DO WHILE .t.
 rola_t=.f.
 cod_sos=56
 IF !so_um_reg
  SET KEY K_ALT_F8 TO ROLATELA
  SETCOLOR(drvcortel+","+drvcorget+",,,"+corcampo)
  @ l_s+01 ,c_s+12 GET  rproc;
                   PICT "@R 99999/9999-99";
                   VALI CRIT("!EMPT(RPROC).AND.PTAB(rproc,[AFUNER],1)~Campo utilizado para localiza‡„o dos documentos.|Tecle F8 para busca em tabela")
                   DEFAULT "IIF(PTAB(PADR(SUBSTR(M->ide_maq,2),4)+[AFU],[IMPPAR],1),ALLTRIM(IMPPAR->docto),[])"
                   AJUDA "Digite neste campo o n£mero de|identifica‡„o do processo"
                   CMDF8 "VDBF(6,12,20,77,'AFUNER',{'processo','proc2','categ','contrato','falecido'},1,'V02001F9()',[])"

  @ l_s+02 ,c_s+12 GET  confirme;
                   PICT "!";
                   VALI CRIT("confirme='S'.AND.V02002F9()~CONFIRME n„o aceit vel|Digite S para confirmar|ou|Tecle ESC para cancelar")
                   AJUDA "Digite S para confirmar|ou|tecle ESC para cancelar"

  READ
  SET KEY K_ALT_F8 TO
  IF rola_t
   ROLATELA(.f.)
   LOOP
  ENDI
  IF LASTKEY()=K_ESC                               // se quer cancelar
   RETU                                            // retorna
  ENDI
 ENDI

 #ifdef COM_REDE
  IF !USEARQ("AFUNER",.f.,10,1)                    // se falhou a abertura do arq
   RETU                                            // volta ao menu anterior
  ENDI
 #else
  USEARQ("AFUNER")                                 // abre o dbf e seus indices
 #endi

 PTAB(contrato,"GRUPOS",1,.t.)                     // abre arquivo p/ o relacionamento
 PTAB(contrato,"INSCRITS",1,.t.)
 SET RELA TO contrato INTO GRUPOS,;                // relacionamento dos arquivos
          TO contrato INTO INSCRITS
 titrel:=criterio:=cpord := ""                     // inicializa variaveis
 titrel:=chv_rela:=chv_1:=chv_2 := ""
 tps:=op_x:=ccop := 1
 arq_=drvporta                                     // porta de saida configurada
 IF !so_um_reg
  IF !opcoes_rel(lin_menu,col_menu,4,11)           // nao quis configurar...
   CLOS ALL                                        // fecha arquivos e
   LOOP                                            // volta ao menu
  ENDI

 #ifdef COM_REDE

  ELSE

   tps=lin_menu

 #endi

 ENDI
 IF tps=2                                          // se vai para arquivo/video
  arq_=ARQGER()                                    // entao pega nome do arquivo
  IF EMPTY(arq_)                                   // se cancelou ou nao informou
   LOOP                                            // retorna
  ENDI
 ELSE
  arq_=drvporta                                    // porta de saida configurada
 ENDI
 IF "4WIN"$UPPER(drvmarca) // nome da configuracao/marca impressora
    arq_:=drvdbf+"WIN"+ide_maq
    tps:=3                                          // se vai para arquivo/video
 ENDIF
 SET PRINTER TO (arq_)                             // redireciona saida
 EXIT
ENDD
DBOX("[ESC] Interrompe",15,,,NAO_APAGA)
dele_atu:=SET(_SET_DELETED,.t.)                    // os excluidos nao servem...
SET DEVI TO PRIN                                   // inicia a impressao
maxli=62                                           // maximo de linhas no relatorio
BEGIN SEQUENCE
 DO WHIL ccop<=nucop                               // imprime qde copias pedida
  pg_=1; cl=999
  IF so_um_reg
   GO imp_reg
  ELSE
   INI_ARQ()                                       // acha 1o. reg valido do arquivo
   IF PTAB(PADR(SUBSTR(M->ide_maq,2),4)+[AFU],[IMPPAR],1)
    PTAB(LEFT(IMPPAR->docto,11),'AFUNER',1)
   ENDI
  ENDI
  ccop++                                           // incrementa contador de copias
  DO WHIL !EOF().AND.(!so_um_reg.OR.imp_reg=RECN())
   #ifdef COM_TUTOR
    IF IN_KEY()=K_ESC                              // se quer cancelar
   #else
    IF INKEY()=K_ESC                               // se quer cancelar
   #endi
    IF canc()                                      // pede confirmacao
     BREAK                                         // confirmou...
    ENDI
   ENDI
   IF (PTAB(PADR(SUBSTR(M->ide_maq,2),4)+[AFU],[IMPPAR],1).and.processo+proc2+filial+categ=ALLTRIM(IMPPAR->docto)) .OR. so_um_reg// se atender a condicao...
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,054 SAY "Processo"
    IMPCTL(drvpenf)
    @ cl,063 SAY TRAN(processo+proc2+filial,"@R 99999/99/!!")// Nr.Processo
    IMPCTL(drvtenf)
    REL_CAB(2)                                     // soma cl/imprime cabecalho
    @ cl,003 SAY "Nome do Contratante:"
    IMPCTL(drvpenf)
    @ cl,024 SAY TRAN(IIF(PTAB(contrato+GRUPOS->titular,'INSCRITS',1),INSCRITS->nome,GRUPOS->nome),"@!")// Nome do contratante
    IMPCTL(drvtenf)
    REL_CAB(2)                                     // soma cl/imprime cabecalho
    IMPAC("Endere‡o:",cl,003)
    IMPCTL(drvpenf)
    @ cl,013 SAY TRAN(GRUPOS->endereco,"@!")       // Endereco contratante
    IMPCTL(drvtenf)
    REL_CAB(2)                                     // soma cl/imprime cabecalho
    @ cl,005 SAY "Cidade               Estado  Documento de Identidade Estado Civil"
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    IMPCTL(drvpenf)
    @ cl,005 SAY TRAN(GRUPOS->cidade,"@!")         // cidade contratante
    IMPCTL(drvtenf)
    @ cl,028 SAY TRAN([  ],"!!")                   // Estado Contratante
    IMPCTL(drvpenf)
    @ cl,037 SAY GRUPOS->rg                        // Doc
    IMPCTL(drvtenf)
    IMPCTL(drvpenf)
    @ cl,059 SAY TRAN(subst(tbestciv,AT(GRUPOS->estcivil,tbestciv),10),"@!")// Est.Civil contratante
    IMPCTL(drvtenf)
    REL_CAB(2)                                     // soma cl/imprime cabecalho
    IMPAC("Contrato    Grupo            Admiss„o                 Processo",cl,005)
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    IMPCTL(drvpenf)
    @ cl,005 SAY contrato                          // contrato numero
    IMPCTL(drvtenf)
    IMPCTL(drvpenf)
    @ cl,018 SAY GRUPOS->grupo                     // grupo
    IMPCTL(drvtenf)
    IMPCTL(drvpenf)
    @ cl,034 SAY GRUPOS->admissao                  // data admissao
    IMPCTL(drvtenf)
    REL_CAB(3)                                     // soma cl/imprime cabecalho
    IMPMEMO(Rx2901F9(),70,1,cl,002,.t.)            // pedido (memo)
    qli_m=MLCOUNT(Rx2901F9(),70)-1                 // quantas linhas a imprimir?
    li_m=0
    DO WHIL .t.                                    // imprime linhas do memo
     li_m++
     IF li_m>qli_m                                 // fim do memo
      EXIT
     ENDI
     REL_CAB(1)                                    // soma cl/imprime cabecalho
     IMPMEMO(Rx2901F9(),70,1+li_m,cl,002,.t.)      // imprime...
     #ifdef COM_TUTOR
      IF IN_KEY()=K_ESC                            // se quer cancelar
     #else
      IF INKEY()=K_ESC                             // se quer cancelar
     #endi
      IF canc()                                    // pede confirmacao
       BREAK                                       // confirmou...
      ENDI
     ENDI
    ENDD
    REL_CAB(2)                                     // soma cl/imprime cabecalho
    @ cl,004 SAY "Nome do falecido....:"
    IMPCTL(drvpenf)
    @ cl,026 SAY TRAN(falecido,"@!")               // nome do falecido
    IMPCTL(drvtenf)
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    IMPAC("Endere‡o do falecido:",cl,004)
    IMPCTL(drvpenf)
    @ cl,026 SAY TRAN(ALLTRIM(ruares)+[, ]+ALLTRIM(baires),"@!")// Endereco falecido
    IMPCTL(drvtenf)
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,004 SAY "Inscrito neste contrato na qualidade de"
    IMPCTL(drvpenf)
    @ cl,044 SAY grauparcon                        // Inscrito na qualidade de
    IMPCTL(drvtenf)
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,004 SAY "Data do Falecimento.:"
    @ cl,026 SAY TRAN(falecto_,"@D")               // Data falcto.
    IMPAC("Hor rio do Falecimento:",cl,036)
    @ cl,060 SAY TRAN(horafal,"99:99")             // Hora Falcto.
    REL_CAB(2)                                     // soma cl/imprime cabecalho
    @ cl,004 SAY "Cidade do Falecimento Estado   Local do falecimento"
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    IMPCTL(drvpenf)
    @ cl,004 SAY municfal                          // Cidade Falecimento
    IMPCTL(drvtenf)
    IMPCTL(drvpenf)
    @ cl,028 SAY TRAN(estfal,"!!")                 // UF falecimento
    IMPCTL(drvtenf)
    IMPCTL(drvpenf)
    @ cl,035 SAY ALLTRIM(ruafal)                   // local falecimento
    IMPCTL(drvtenf)
    REL_CAB(2)                                     // soma cl/imprime cabecalho
    IMPAC("Cemit‚rio onde foi sepultado        Hora do sepultamento",cl,004)
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    IMPCTL(drvpenf)
    @ cl,004 SAY cemitsep                          // Cemit‚rio sepultamento
    IMPCTL(drvtenf)
    IMPCTL(drvpenf)
    @ cl,046 SAY TRAN(horasepult,"99:99")          // Hora sepultamento
    IMPCTL(drvtenf)
    REL_CAB(3)                                     // soma cl/imprime cabecalho
    @ cl,004 SAY "Datado em       de                    de           , conforme processo"
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    IMPAC("administrativo n£mero",cl,002)
    @ cl,024 SAY TRAN(processo+proc2+filial,"@R 99999/99/!!")// Processo
    @ cl,032 SAY "."
    REL_CAB(2)                                     // soma cl/imprime cabecalho
    @ cl,025 SAY IMPAC(RTRIM(M->p_cidade)+[, ]+LEFT(DTOC(DATE()),2)+[ de ]+NMES(MONTH(DATE()))+ [ de ]+LEFT(DTOS(DATE()),4))// DATA
    REL_CAB(2)                                     // soma cl/imprime cabecalho
    @ cl,001 SAY "PROCESSAR"
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY "PAGAMENTO EM"
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    IMPCTL(drvpenf)
    @ cl,002 SAY TRAN(procpagto_,"@D")             // Proc.pagto em
    IMPCTL(drvtenf)
    REL_CAB(3)                                     // soma cl/imprime cabecalho
    @ cl,021 SAY REPL("-",42)
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,021 SAY "Ass.:"
    IMPCTL(drvpenf)
    @ cl,027 SAY GRUPOS->nome                      // Nome
    IMPCTL(drvtenf)
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,027 SAY "RG:"
    @ cl,031 SAY TRAN(GRUPOS->rg,"@!")             // R.G.
    SKIP                                           // pega proximo registro
    cl=999                                         // forca salto de pagina
   ELSE                                            // se nao atende condicao
    SKIP                                           // pega proximo registro
   ENDI
   EXIT
  ENDD
 ENDD ccop
END SEQUENCE
SET PRINTER TO (drvporta)                          // fecha arquivo gerado (se houver)
SET DEVI TO SCRE                                   // direciona saida p/ video
IF tps=2                                           // se vai para arquivo/video
 BROWSE_REL(arq_,2,3,MAXROW()-2,78)
ENDI                                               // mostra o arquivo gravado
GRELA(4)                                           // grava variacao do relatorio
SELE AFUNER                                        // salta pagina
SET RELA TO                                        // retira os relacionamentos
SET(_SET_DELETED,dele_atu)                         // os excluidos serao vistos
IF so_um_reg
 POINTER_DBF(sit_dbf)
ENDI
RETU

STATIC PROC REL_CAB(qt)                            // cabecalho do relatorio
IF qt>0                                            // se parametro maior que 0
 cl=cl+qt                                          // soma no contador de linhas
ENDI
IF cl>maxli .OR. qt=0                              // quebra de pagina
 @ 0,001 SAY IIF(categ=[PD],[Plano c/Difer. ],IIF(categ=[PL],[Atend.Plano],[Rest.Desp.Funerais]))// Categoria
 @ 5,021 SAY M->setup1                             // Ident1
 @ 7,034 SAY "RECIBO"
 cl=qt+8 ; pg_++
ENDI
RETU

* \\ Final de ADR_RX29.PRG
€	 MEDICOSl–V MEDICOSCODEMED_INCLCODE
MED_ANT_SECODE
MED_CRIA_SCODE
MED_GERA_SCODE
MED_GRAVA_CODEMED_TELACODEMED_GETSCODEMED_GET1CODEMED_MEMOCODEC_ETEXTENDCODE	_SYMSTARTSYMSTARTSYMBOLSSYMBOLS_SYMENDSYMENDNULLBEGDATA_DATADATA_SYMPBDATA_SYMPDATA_SYMPEDATA_CONSTCONST_MSGMSG_BEGBSSBEGBSS_BSSBSS_ENDBSSENDBSSDGROUPV˜ @õ$˜ @w˜˜ @| —˜ @E	É˜ @Ó 
8˜ @2 Õ˜ @â˜ @A·˜ @)Æ˜ @<º˜ H  ë˜ h  Ç˜ ` €	 MFILIALr–H MFILIALCODEMFI_INCLCODE
MFI_ANT_SECODE
MFI_CRIA_SCODE
MFI_GERA_SCODE
MFI_GRAVA_CODEMFI_TELACODEMFI_GETSCODEMFI_GET1CODEC_ETEXTENDCODE	_SYMSTARTSYMSTARTSYMBOLSSYMBOLS_SYMENDSYMENDNULLBEGDATA_DATADATA_SYMPBDATA_SYMPDATA_SYMPEDATA_CONSTCONST_MSGMSG_BEGBSSBEGBSS_BSSBSS_ENDBSSENDBSSDGROUPÄ˜ @¾[˜ @Ú9˜ @s  ˜ @'	ç˜ @« 
`˜ @) Þ˜ @K¶˜ @p˜ @¥Q˜ H  ï˜ h  Ë˜ `ðØ˜ h  €
 R07702F9–Ñ  R07702F9CODEC_ETEXTENDCODE	_SYMSTARTSYMSTARTSYMBOLSSYMBOLS_SYMENDSYMENDNULLBEGDATA_DATADATA_SYMPBDATA_SYMPDATA_SYMPEDATA_CONSTCONST_MSGMSG_BEGBSSBEGBSS_BSSBSS_ENDBSSENDBSSDGROUP\˜ @å 6˜ H  ˜ h  ë˜ `ð 	ÿ˜ h  
ã˜ h  ß˜ H  û˜ H  ÷˜ H ë˜ H  ï˜ H  ë˜ (  ˜ H  GAS-Pro v4.0
014001024080001003051001017001165001
N§                            Emissao       Valor  ³ Pagto    Valor Pago Stat
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
                                                   ³
                                                   ³
                                                   ³
                                                   ³
                                                   ³
                                                   ³
                                                   ³
[Ÿ]
Manuten‡„o~~27007
Consulta~~28008
[Ÿ]
 14 
 2 
Contrato

 1 
 2 
[Ÿ]
Cobranca

 2 
[Ÿ]
Cadastro de Taxas
Taxas







005




































-1 
 0 
-1 
-1 
-1 
-1 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
codigo
C
I
@!
 9 
 9 
 0 
 0 
 0 
Codigo






-1 
 0 


cobranca
C
E
@!
 18 
 18 
 3 
 11 
 0 
Cobranca

 




 0 
 0 


tipo
C
I
!
 1 
 1 
 0 
 0 
 0 
Tipo






 0 
 0 


circ
C
I
999
 3 
 3 
 0 
 0 
 0 
Circular






 0 
 0 


emissao_
D
E
@D
 8 
 10 
 3 
 30 
 0 
Emissao

!EMPT(emissao_)
Necess rio informar EMISSAO v lida

Data da Emiss„o da Circular|Mantido pela emissao do recibo

 0 
 0 


valor
N
E
@E 999,999.99
 9 
 10 
 3 
 41 
 2 
Valor

valor>0
VALOR n„o aceit vel



 0 
 0 


pgto_
D
E
@D
 8 
 10 
 3 
 53 
 0 
Pagamento
nivelop=3
 


Informe a data de pagamento/Baixa

 0 
 0 


valorpg
N
E
@E 999,999.99
 9 
 10 
 3 
 64 
 2 
Valor pago
nivelop=3
!(valorpg<0)
VALOR PAGO n„o aceit vel

Informe o valor pago/baixado

 0 
 0 


cobrador
C
E
!!!
 3 
 3 
 0 
 0 
 0 
Cobrador

PTAB(cobrador,'COBRADOR',1).AND.(PTAB(cobrador+M->mmesref,'FCCOB',1).OR.1=1)
Problemas encontrados no arquivo Cobrador ou |Circular do grupo n„o cadastrada para|este cobrador.
GRUPOS->cobrador
Informe o Cobrador que recebeu este.
VDBF(6,3,20,77,'COBRADOR',{'cobrador','funcao','nome','cidade','telefone'},1,'cobrador',[])
 0 
 0 


forma
C
E
!
 1 
 1 
 0 
 0 
 0 
Forma

forma$[PR ]
FORMA n„o aceit vel

Esta lan‡amento foi Pago ou Cancelado|Deixe sem preencher se ainda em aberto

 0 
 0 


baixa_
D
I
@D
 8 
 10 
 0 
 0 
 0 
Baixa_






 0 
 0 


por
C
I
 
 10 
 10 
 0 
 0 
 0 
Por






 0 
 0 


stat
C
E
9
 1 
 1 
 0 
 0 
 0 
Status

stat $ [12679]
STATUS n„o aceit vel

Informe a situa‡„o deste recibo|Tecle F8 para busca em tabela
MTAB([1=Gerada|2=Impressa|6=Pg Recep‡„o|7=Bx.p/FCC|9=Bx.Plano],[STATUS])
 0 
 0 


filial
C
I
@!
 2 
 2 
 0 
 0 
 0 
Filial






 0 
 0 


 2 
Status
LEFT(TAX_02F9(),3)

 3 
 75 
 3 

numero
substr(codigo,11)

 3 
 1 
 8 

 3 
GRUPOS
qtcircs
GRUPOS->qtcircs + 1
GRUPOS->qtcircs - 1
!tipo='1'


GRUPOS
qtcircpg
GRUPOS->qtcircpg + 1
GRUPOS->qtcircpg - 1
!tipo='1'.AND.valorpg>0


GRUPOS
ultcirc
circ

!tipo='1'.AND.circ>GRUPOS->ultcirc


 0 
 0 
 0 
procedure classes
/*
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
 \ Empresa.: PresServ Inform tica - Limeira (019)452.6623
 \ Programa: CLASSES.PRG
 \ Data....: 04-11-03
 \ Sistema.: Administradora - RECEP€„O
 \ Funcao..: Gerenciador do subsistema de categoria dos planos
 \ Analista: Ademilson Pedro Bom
 \ Criacao.: GAS-Pro v4.0n
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/
#include "adrbig.ch"    // inicializa constantes manifestas

PARA lin_menu,col_menu
PRIV op_sis, tela_fundo:=SAVESCREEN(0,0,MAXROW(),79), l_s, c_s, l_i, c_i, l_a

op_sis=EVAL(qualsis,"CLASSES")
IF nivelop<sistema[op_sis,O_OUTROS,O_NIVEL]        // se usuario nao tem permissao,
 ALERTA()                                          // entao, beep, beep, beep
 DBOX(msg_auto,,,3)                                // lamentamos e
 RETU                                              // retornamos ao menu
ENDI
cn:=fgrep :=.f.

#ifdef COM_LOCK
 IF LEN(pr_ok)>0                                   // se a protecao acusou
  ? pr_ok                                          // erro, avisa e
  QUIT                                             // encerra a aplicacao
 ENDI
#endi

t_fundo=SAVESCREEN(0,0,MAXROW(),79)                // salva tela do fundo
op_cad=1
DO WHIL op_cad!=0
 criterio=""
 RESTSCREEN(0,0,MAXROW(),79,t_fundo)               // restaura tela do fundo
 cod_sos=5 ; cn=.f.
 CLEA TYPEAHEAD                                    // limpa o buffer do teclado
 fgrep=.f.
 SET KEY K_F3 TO                                   // retira das teclas F3 e F4 as
 SET KEY K_F4 TO                                   // funcoes de repeticao e confirmacao
 msg="Inclus„o~1|"+;
     "Manuten‡„o~2|"+;
     "Consulta~3"
 op_cad=DBOX(msg,lin_menu,col_menu,E_MENU,NAO_APAGA,MAIUSC(sistema[op_sis,O_MENU]),,,op_cad)
 IF op_cad!=0                                      // se escolheu uma opcao
  Tela_fundo=SAVESCREEN(0,0,MAXROW(),79)           // salva a tela para ROLATELA()
  PARAMETROS(dbfparam)
  SELE A                                           // e abre o arquivo e seus indices

  #ifdef COM_REDE
   IF !USEARQ(sistema[op_sis,O_ARQUI,O_NOME],.f.,20,1)
                                                   // se falhou a abertura do
    RETU                                           // arquivo volta ao menu anterior
   ENDI
  #else
   USEARQ(sistema[op_sis,O_ARQUI,O_NOME])
  #endi

  SET KEY K_F9 TO veoutros                         // habilita consulta em outros arquivos
 ENDI
 DO CASE
  CASE op_cad=01                                   // inclus„o
   op_menu=INCLUSAO
   IF AT("D",exrot[op_sis])=0                      // se usuario pode fazer inclusao
    CLA_INCL()                                     // neste arquivo chama prg de inclusao
   ELSE                                            // caso contrario vamos avisar que
    ALERTA()                                       // ele nao tem permissao para isto
    DBOX(msg_auto,,,3)
   ENDI

  CASE op_cad=02                                   // manuten‡„o
   op_menu=ALTERACAO
   cod_sos=7
   EDIT()

  CASE op_cad=03                                   // consulta
   op_menu=PROJECOES
   cod_sos=8
   EDITA(03,03,MAXROW()-2,77)

 ENDC
 SET KEY K_F9 TO                                   // F9 nao mais consultara outros arquivos
 CLOS ALL                                          // fecha todos arquivos abertos
ENDD
RETU

PROC CLA_incl(reg_cop)  // inclusao no arquivo CLASSES
LOCAL getlist:={},cabem:=1,rep:=ARRAY(FCOU()),ult_reg:=RECN(),dbfseq_,;
      ctl_r, ctl_c, ctl_w, t_f3_, t_f4_, dele_atu:=SET(_SET_DELETED,.f.)
PRIV op_menu:=INCLUSAO, sq_atual_, tem_borda, criterio:="", cpord:=""
FOR i=1 TO FCOU()                                  // cria/declara privadas as
 msg=FIEL(i)                                       // variaveis de memoria com
 PRIV &msg.                                        // o mesmo nome dos campos
NEXT                                               // do arquivo
IF reg_cop!=NIL                                    // quer repetir todo o reg atual
 FOR i=1 TO FCOU()                                 // para cada campo,
  msg=FIEL(i)                                      // salva o conteudo
  rep[i]=&msg.                                     // para repetir
 NEXT
ELSE
 AFILL(rep,"")                                     // eche com valor vazio
ENDI
t_f3_=SETKEY(K_F3,{||rep()})                       // repeticao reg anterior
t_f4_=SETKEY(K_F4,{||conf()})                      // confirma campos com ENTER
ctl_w=SETKEY(K_CTRL_W,{||nadafaz()})               // enganando o CA-Clipper...
ctl_c=SETKEY(K_CTRL_C,{||nadafaz()})
ctl_r=SETKEY(K_CTRL_R,{||nadafaz()})

#ifdef COM_REDE
 CLA_CRIA_SEQ()                                    // cria dbf de controle de cp sequenciais
 FOR i=1 TO FCOU()                                 // cria/declara privadas as
  msg="sq_"+FIEL(i)                                // variaveis de memoria com
  PRIV &msg.                                       // o mesmo nome dos campos
 NEXT                                              // do arquivo com extensao _seq
#endi

DO WHIL cabem>0
 cod_sos=6
 rola_t=.f.                                        // flag se quer rolar a tela
 SELE CLASSES
 GO BOTT                                           // forca o
 SKIP                                              // final do arquivo
 
 /*
    cria variaveis de memoria identicas as de arquivo, para inclusao
    de registros
 */
 FOR i=1 TO FCOU()
  msg=FIEL(i)
  M->&msg.=IF((fgrep .OR. reg_cop!=NIL).AND.!EMPT(rep[1]),rep[i],&msg.)
 NEXT
 DISPBEGIN()                                       // apresenta a tela de uma vez so
 CLA_TELA()
 INFOSIS(.t.)                                      // exibe informacao no rodape' da tela
 DISPEND()
 CLA_GERA_SEQ()
 cabem=DISKSPACE(;
          IF(;
             LEN(sistema[op_sis,O_ARQUI,O_DIR_DBF])<2.OR.sistema[op_sis,O_ARQUI,O_DIR_DBF]="\",;
             0,;
             ASC(sistema[op_sis,O_ARQUI,O_DIR_DBF])-64;
          );
       )
 cabem=INT((cabem-2048)/CLASSES->(RECSIZE()))
 IF cabem<1                                        // mais nenhum!!!
  ALERTA()
  msg="Verifique ESPA€O EM DISCO, "+usuario
  DBOX(msg,,,,,"INCLUSŽO INTERROMPIDA!")           // vamos parar por aqui!
  EXIT
 ENDI
 SELE 0                                            // torna visiveis variaveis de memoria
 SETCOLOR(drvcortel+","+drvcorget+",,,"+corcampo)
 SET KEY K_ALT_F8 TO ROLATELA
 
 /*
    recebe chaves do arquivo de indice basico
 */
 @ l_s+01 ,c_s+16 GET  classcod;
                  PICT sistema[op_sis,O_CAMPO,01,O_MASC]
                  DEFINICAO 1

 READ
 SET KEY K_ALT_F8 TO
 IF rola_t
  ROLATELA()

  #ifdef COM_REDE
   CLA_ANT_SEQ()                                   // decrementa sequencial
  #endi

  LOOP
 ENDI
 SELE CLASSES
 IF LASTKEY()=K_ESC                                // cancelou ou chave em branco
  cabem=0                                          // prepara saida da inclusao
  LOOP                                             // volta p/ menu de cadastramento
 ENDI
 SEEK M->classcod
 aprov_reg_=(FOUND().AND.DELE().AND.!drvvisivel)   // vai aproveitar o registro?
 IF FOUND() .AND. !aprov_reg_                      // pesquisou e achou!
  op_menu=ALTERACAO                                // seta flag de ateracao

  #ifdef COM_REDE
   CLA_ANT_SEQ()                                   // decrementa sequencial
   SELE CLASSES
  #endi

  DISPBEGIN()
  CLA_GETS()                                       // mostra conteudo do registro
  INFOSIS(.f.)                                     // exibe informacao no rodape' da tela
  DISPEND()
  ALERTA()
  msg="Consultar/alterar|Retornar … inclus„o"      // pergunta se deseja
  op_=DBOX(msg,,,E_MENU,,"REGISTRO J EXISTE")     // alterar o registro
  IF op_ =1                                        // caso afirmativo
   EDIT()                                          // deixa alterar
  ENDI
  op_menu=INCLUSAO
  LOOP                                             // volta para inclusao
 ENDI
 SELE 0
 CLA_GET1(INCLUI)                                  // recebe campos
 SELE CLASSES
 IF LASTKEY()=K_ESC                                // se cancelou

  #ifdef COM_REDE
   CLA_ANT_SEQ()                                   // decrementa sequencial
  #endi

  ALERTA()                                         // avisa que o registro
  DBOX("Registro n„o inclu¡do!",18,,1)             // nao foi incluido, e volta
  LOOP
 ENDI

 #ifdef COM_REDE
  GO BOTT                                          // vamos bloquear o final do
  SKIP                                             // arq para que nehum outro
  BLOREG(0,.5)                                     // usuario possa incluir
  SEEK M->classcod                                 // se registro foi incluido
  aprov_reg_=(FOUND().AND.DELE().AND.!drvvisivel)  // vai aproveitar o registro?
  IF FOUND() .AND. !aprov_reg_                     // por outro usuario, entao
   BLOREG(0,.5)
   FOR i=1 TO FCOU()
    msg=FIEL(i)
    rep[i]=&msg.
    REPL &msg. WITH M->&msg.
   NEXT
   CLA_GET1(FORM_INVERSA)                          // executa formula inversa
   RECA
   FOR i=1 TO FCOU()
    msg=FIEL(i)
    REPL &msg. WITH rep[i]
   NEXT
   ALERTA(4)                                       // beep 4 vezes
   msg="Registro acabou de ser|inclu¡do por outro usu rio!"
   DBOX(msg,,,,,"ATEN€ŽO!")                        // avisa
   SELE CLASSES
   UNLOCK                                          // libera o registro
   LOOP                                            // e recebe chave novamente
  ENDI
 #endi

 IF aprov_reg_                                     // se vai aproveitar reg excluido

  #ifdef COM_REDE
   BLOREG(0,.5)
  #endi

  RECA                                             // excluido, vamos recupera-lo
 ELSE                                              // caso contrario
  APPEND BLANK                                     // inclui reg em branco no dbf
 ENDI
 FOR i=1 TO FCOU()                                 // para cada campo,
  msg=FIEL(i)                                      // salva o conteudo
  rep[i]=M->&msg.                                  // para repetir
  REPL &msg. WITH rep[i]                           // enche o campo do arquivo
 NEXT

 #ifdef COM_REDE
  UNLOCK                                           // libera o registro e
  COMMIT                                           // forca gravacao
 #else
  IF RECC()-INT(RECC()/20)*20=0                    // a cada 20 registros
   COMMIT                                          // digitados forca gravacao
  ENDI
 #endi

 ult_reg=RECN()                                    // ultimo registro digitado
 IF reg_cop!=NIL                                   // estava na consulta e quis rep o campo
  sq_atual_=NIL
  EXIT                                             // cai fora...
 ENDI
ENDD

#ifdef COM_REDE
 CLA_ANT_SEQ()                                     // restaura sequencial anterior
 SELE CLASSES
#endi

GO ult_reg                                         // para o ultimo reg digitado
SETKEY(K_F3,t_f3_)                                 // restaura teclas de funcoes
SETKEY(K_F4,t_f4_)
SET(_SET_DELETED,dele_atu)                            // ecluidos visiveis/invisiveis
SETKEY(K_CTRL_W,ctl_w)
SETKEY(K_CTRL_C,ctl_c)
SETKEY(K_CTRL_R,ctl_r)
RETU



#ifdef COM_REDE
 PROC CLA_ANT_SEQ(est_seq)     // restaura sequencial anterior
 SELE CLA_SEQ     // seleciona arquivo de controle de sequencial
 BLOARQ(0,.5)     // esta estacao foi a ultima a incluir?
 IF sq_atual_ == classcod
  REPL classcod WITH sq_classcod
 ENDI
 UNLOCK           // libera DBF para outros usuarios
 COMMIT           // atualiza cps sequenciais no disco
 RETU
#endi


PROC CLA_CRIA_SEQ   // cria dbf de controle de campos sequenciais
LOCAL dbfseq_:=sistema[op_sis,O_ARQUI,O_DIR_DBF]+"CLA_seq" // arq temporario
SELE 0                          // seleciona area vazia
IF !FILE(dbfseq_+".dbf")        // se o dbf nao existe
 DBCREATE(dbfseq_,{;            // vamos criar a sua estrutura
                    {"classcod"  ,"C",  2, 0};
                  };
 )
ENDI
USEARQ(dbfseq_,.f.,,,.f.)       // abre arquivo de cps sequencial
IF RECC()=0                     // se o dbf foi criado agora
 BLOARQ(0,.5)                   // inclui um registro que tera
 APPEND BLANK                   // os ultomos cps sequenciais
 SELE CLASSES
 IF RECC()>0                    // se o DBF nao estiver
  SET ORDER TO 0                // vazio, entao enche DBF seq
  GO BOTT                       // com o ultimo reg digitado
  REPL CLA_SEQ->classcod WITH classcod
  DBSETORDER(1)                 // retorna ao indice principal
 ENDI
 SELE CLA_SEQ                   // seleciona arq de sequencias
 UNLOCK                         // libera DBF para outros usuarios
 COMMIT                         // atualiza cps sequenciais no disco
ENDI
RETURN

PROC CLA_GERA_SEQ()

#ifdef COM_REDE
 LOCAL ar_:=SELEC()
#else
 LOCAL reg_:=RECNO(),ord_ind:=INDEXORD()
#endi


#ifdef COM_REDE
 SELE CLA_SEQ
 BLOARQ(0,.5)
 sq_classcod=CLA_SEQ->classcod
#else
 DBSETORDER(0)
 GO BOTT
#endi

M->classcod=LPAD(STR(VAL(classcod)+1),02,[0])

#ifdef COM_REDE
 CLA_GRAVA_SEQ()
 sq_atual_=CLA_SEQ->classcod
 UNLOCK                                            // libera o registro
 COMMIT
 SELE (ar_)
#else
 DBSETORDER(ord_ind)
 GO reg_
#endi

RETU

PROC CLA_GRAVA_SEQ
REPL classcod WITH M->classcod
RETU

PROC CLA_tela     // tela do arquivo CLASSES
tem_borda=.t.
l_s=Sistema[op_sis,O_TELA,O_LS]           // coordenadas da tela
c_s=Sistema[op_sis,O_TELA,O_CS]
l_i=Sistema[op_sis,O_TELA,O_LI]
c_i=Sistema[op_sis,O_TELA,O_CI]
SETCOLOR(drvtittel)
vr_memo=NOVAPOSI(@l_s,@c_s,@l_i,@c_i)     // pega posicao atual da tela
CAIXA(mold,l_s,c_s,l_i,c_i)               // monta caixa da tela
i=LEN(sistema[op_sis,O_MENS])/2
@ l_s,c_s-1+(c_i-c_s+1)/2-i SAY " "+MAIUSC(sistema[op_sis,O_MENS])+" "
SETCOLOR(drvcortel)
@ l_s+01,c_s+1 SAY " C¢digo......:"
@ l_s+02,c_s+1 SAY " Descri‡„o...:"
@ l_s+03,c_s+1 SAY " N§ Contratos:"
@ l_s+04,c_s+1 SAY "ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ"
@ l_s+05,c_s+1 SAY " A cobran‡a ‚ por per¡odo?:"
@ l_s+06,c_s+1 SAY " (Digite N se a cobran‡a sair por n§ de atendimentos)"
@ l_s+07,c_s+1 SAY " (Digite S se a cobran‡a sair a cada n meses.)"
@ l_s+08,c_s+1 SAY "ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ"
@ l_s+09,c_s+1 SAY " Valor J¢ia..:             (      )"
@ l_s+10,c_s+1 SAY "               N§Parcelas:     (1¦ a gerar:   )"
@ l_s+11,c_s+1 SAY " Valor Mensal:             (      )"
@ l_s+12,c_s+1 SAY " p/Dependente:             (      )"
@ l_s+13,c_s+1 SAY " Validade do contrato (em meses)....:"
@ l_s+14,c_s+1 SAY " Renova‡„o autom tica no vencimento.:"
@ l_s+15,c_s+1 SAY "                      na utiliza‡„o.:"
@ l_s+16,c_s+1 SAY " Valor total dos servi‡os oferecidos:"
RETU

PROC CLA_gets     // mostra variaveis do arquivo CLASSES
LOCAL getlist := {}
CLA_TELA()
SETCOLOR(drvcortel+","+drvcorget+",,,"+corcampo)
CRIT("",,"1")
@ l_s+01 ,c_s+16 GET  classcod;
                 PICT sistema[op_sis,O_CAMPO,01,O_MASC]

@ l_s+02 ,c_s+16 GET  descricao;
                 PICT sistema[op_sis,O_CAMPO,02,O_MASC]

@ l_s+03 ,c_s+16 GET  contrat;
                 PICT sistema[op_sis,O_CAMPO,03,O_MASC]

@ l_s+05 ,c_s+29 GET  prior;
                 PICT sistema[op_sis,O_CAMPO,04,O_MASC]

@ l_s+09 ,c_s+16 GET  vljoia;
                 PICT sistema[op_sis,O_CAMPO,05,O_MASC]
                 CRIT(sistema[op_sis,O_CAMPO,05,O_CRIT],,"2")

@ l_s+10 ,c_s+28 GET  nrparc;
                 PICT sistema[op_sis,O_CAMPO,06,O_MASC]

@ l_s+10 ,c_s+45 GET  parcger;
                 PICT sistema[op_sis,O_CAMPO,07,O_MASC]

@ l_s+11 ,c_s+16 GET  vlmensal;
                 PICT sistema[op_sis,O_CAMPO,08,O_MASC]
                 CRIT(sistema[op_sis,O_CAMPO,08,O_CRIT],,"3")

@ l_s+12 ,c_s+16 GET  vldepend;
                 PICT sistema[op_sis,O_CAMPO,09,O_MASC]
                 CRIT(sistema[op_sis,O_CAMPO,09,O_CRIT],,"4")

@ l_s+13 ,c_s+39 GET  nrmesval;
                 PICT sistema[op_sis,O_CAMPO,10,O_MASC]

@ l_s+14 ,c_s+39 GET  renvenc;
                 PICT sistema[op_sis,O_CAMPO,11,O_MASC]

@ l_s+15 ,c_s+39 GET  renuso;
                 PICT sistema[op_sis,O_CAMPO,12,O_MASC]

CLEAR GETS
RETU

PROC CLA_get1(tp_mov)     // capta variaveis do arquivo CLASSES
LOCAL getlist := {}
PRIV  blk_classes:=.t.

IF tp_mov=INCLUI
 DO WHILE .t.
  rola_t=.f.
  SET KEY K_ALT_F8 TO ROLATELA
  SETCOLOR(drvcortel+","+drvcorget+",,,"+corcampo)
  CRIT("",,"1")
  @ l_s+02 ,c_s+16 GET  descricao;
                   PICT sistema[op_sis,O_CAMPO,02,O_MASC]
                   DEFINICAO 2

  @ l_s+03 ,c_s+16 GET  contrat;
                   PICT sistema[op_sis,O_CAMPO,03,O_MASC]
                   DEFINICAO 3

  @ l_s+05 ,c_s+29 GET  prior;
                   PICT sistema[op_sis,O_CAMPO,04,O_MASC]
                   DEFINICAO 4

  @ l_s+09 ,c_s+16 GET  vljoia;
                   PICT sistema[op_sis,O_CAMPO,05,O_MASC]
                   DEFINICAO 5
                   MOSTRA sistema[op_sis,O_FORMULA,2]

  @ l_s+10 ,c_s+28 GET  nrparc;
                   PICT sistema[op_sis,O_CAMPO,06,O_MASC]
                   DEFINICAO 6

  @ l_s+10 ,c_s+45 GET  parcger;
                   PICT sistema[op_sis,O_CAMPO,07,O_MASC]
                   DEFINICAO 7

  @ l_s+11 ,c_s+16 GET  vlmensal;
                   PICT sistema[op_sis,O_CAMPO,08,O_MASC]
                   DEFINICAO 8
                   MOSTRA sistema[op_sis,O_FORMULA,3]

  @ l_s+12 ,c_s+16 GET  vldepend;
                   PICT sistema[op_sis,O_CAMPO,09,O_MASC]
                   DEFINICAO 9
                   MOSTRA sistema[op_sis,O_FORMULA,4]

  @ l_s+13 ,c_s+39 GET  nrmesval;
                   PICT sistema[op_sis,O_CAMPO,10,O_MASC]
                   DEFINICAO 10

  @ l_s+14 ,c_s+39 GET  renvenc;
                   PICT sistema[op_sis,O_CAMPO,11,O_MASC]
                   DEFINICAO 11

  @ l_s+15 ,c_s+39 GET  renuso;
                   PICT sistema[op_sis,O_CAMPO,12,O_MASC]
                   DEFINICAO 12

  READ
  SET KEY K_ALT_F8 TO
  IF rola_t
   ROLATELA()
   LOOP
  ENDI
  IF LASTKEY()!=K_ESC .AND. drvincl .AND. op_menu=INCLUSAO
   IF !CONFINCL()
    LOOP
   ENDI
  ENDI
  EXIT
 ENDD
ENDI
IF tp_mov=EXCLUI .OR. tp_mov=FORM_INVERSA
 DELE
ELSEIF tp_mov=INCLUI .OR. tp_mov=RECUPERA .OR. tp_mov=FORM_DIRETA
 IF op_menu!=INCLUSAO
  RECA
 ENDI
ENDI
RETU

* \\ Final de CLASSES.PRG
procedure regiao
/*
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
 \ Empresa.: PresServ Inform tica - Limeira (019)452.6623
 \ Programa: REGIAO.PRG
 \ Data....: 04-11-03
 \ Sistema.: Administradora - RECEP€„O
 \ Funcao..: Gerenciador do subsistema de regi”es
 \ Analista: Ademilson Pedro Bom
 \ Criacao.: GAS-Pro v4.0n
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/
#include "adrbig.ch"    // inicializa constantes manifestas

PARA lin_menu,col_menu
PRIV op_sis, tela_fundo:=SAVESCREEN(0,0,MAXROW(),79), l_s, c_s, l_i, c_i, l_a

op_sis=EVAL(qualsis,"REGIAO")
IF nivelop<sistema[op_sis,O_OUTROS,O_NIVEL]        // se usuario nao tem permissao,
 ALERTA()                                          // entao, beep, beep, beep
 DBOX(msg_auto,,,3)                                // lamentamos e
 RETU                                              // retornamos ao menu
ENDI
cn:=fgrep :=.f.

#ifdef COM_LOCK
 IF LEN(pr_ok)>0                                   // se a protecao acusou
  ? pr_ok                                          // erro, avisa e
  QUIT                                             // encerra a aplicacao
 ENDI
#endi

t_fundo=SAVESCREEN(0,0,MAXROW(),79)                // salva tela do fundo
op_cad=1
DO WHIL op_cad!=0
 criterio=""
 RESTSCREEN(0,0,MAXROW(),79,t_fundo)               // restaura tela do fundo
 cod_sos=5 ; cn=.f.
 CLEA TYPEAHEAD                                    // limpa o buffer do teclado
 fgrep=.f.
 SET KEY K_F3 TO                                   // retira das teclas F3 e F4 as
 SET KEY K_F4 TO                                   // funcoes de repeticao e confirmacao
 msg="Inclus„o~1|"+;                               // menu do subsistema
     "Manuten‡„o~2|"+;
     "Consulta~3"
 op_cad=DBOX(msg,lin_menu,col_menu,E_MENU,NAO_APAGA,MAIUSC(sistema[op_sis,O_MENU]),,,op_cad)
 IF op_cad!=0                                      // se escolheu uma opcao
  Tela_fundo=SAVESCREEN(0,0,MAXROW(),79)           // salva a tela para ROLATELA()
  PARAMETROS(dbfparam)
  SELE A                                           // e abre o arquivo e seus indices

  #ifdef COM_REDE
   IF !USEARQ(sistema[op_sis,O_ARQUI,O_NOME],.f.,20,1)
                                                   // se falhou a abertura do
    RETU                                           // arquivo volta ao menu anterior
   ENDI
  #else
   USEARQ(sistema[op_sis,O_ARQUI,O_NOME])
  #endi

  SET KEY K_F9 TO veoutros                         // habilita consulta em outros arquivos
 ENDI
 DO CASE
  CASE op_cad=01                                   // inclus„o
   op_menu=INCLUSAO
   IF AT("D",exrot[op_sis])=0                      // se usuario pode fazer inclusao
    REG_INCL()                                     // neste arquivo chama prg de inclusao
   ELSE                                            // caso contrario vamos avisar que
    ALERTA()                                       // ele nao tem permissao para isto
    DBOX(msg_auto,,,3)
   ENDI

  CASE op_cad=02                                   // manuten‡„o
   op_menu=ALTERACAO
   cod_sos=7
   EDIT()

  CASE op_cad=03                                   // consulta
   op_menu=PROJECOES
   cod_sos=8
   EDITA(05,17,MAXROW()-4,63)

 ENDC
 SET KEY K_F9 TO                                   // F9 nao mais consultara outros arquivos
 CLOS ALL                                          // fecha todos arquivos abertos
ENDD
RETU

PROC REG_incl(reg_cop)  // inclusao no arquivo REGIAO
LOCAL getlist:={},cabem:=1,rep:=ARRAY(FCOU()),ult_reg:=RECN(),cond_incl_,dbfseq_,;
      ctl_r, ctl_c, t_f3_, t_f4_, l_max, dele_atu:=SET(_SET_DELETED,.f.)
PRIV op_menu:=INCLUSAO, sq_atual_, tem_borda, criterio:="", cpord:="", l_a
cond_incl_={||nivelop>1}                           // condicao de inclusao de registros
IF !EVAL(cond_incl_)                               // se nao pode incluir
 ALERTA(2)                                         // avisa o motivo
 DBOX("Permitido apenas a usu rios cadastrados|com n¡vel de Manuten‡„o ou Maior",,,4,,"ATEN€ŽO, "+usuario)
 RETU                                              // e retorna
ENDI
FOR i=1 TO FCOU()                                  // cria/declara privadas as
 msg=FIEL(i)                                       // variaveis de memoria com
 PRIV &msg.                                        // o mesmo nome dos campos
NEXT                                               // do arquivo
IF reg_cop!=NIL                                    // quer repetir todo o reg atual
 FOR i=1 TO FCOU()                                 // para cada campo,
  msg=FIEL(i)                                      // salva o conteudo
  rep[i]=&msg.                                     // para repetir
 NEXT
ELSE
 AFILL(rep,"")                                     // eche com valor vazio
ENDI
t_f3_=SETKEY(K_F3,{||rep()})                       // repeticao reg anterior
t_f4_=SETKEY(K_F4,{||conf()})                      // confirma campos com ENTER
ctl_w=SETKEY(K_CTRL_W,{||nadafaz()})               // enganando o CA-Clipper...
ctl_c=SETKEY(K_CTRL_C,{||nadafaz()})
ctl_r=SETKEY(K_CTRL_R,{||nadafaz()})

#ifdef COM_REDE
 REG_CRIA_SEQ()                                    // cria dbf de controle de cp sequenciais
 FOR i=1 TO FCOU()                                 // cria/declara privadas as
  msg="sq_"+FIEL(i)                                // variaveis de memoria com
  PRIV &msg.                                       // o mesmo nome dos campos
 NEXT                                              // do arquivo com extensao _seq
#endi

DISPBEGIN()                                        // monta tela na pagina de traz
REG_TELA()                                         // imp tela para inclusao
INFOSIS(.t.)                                       // exibe informacao no rodape' da tela
l_a=Sistema[op_sis,O_TELA,O_SCROLL]
DISPEND()                                          // apresenta tela de uma vez so
DO WHIL cabem>0
 cod_sos=6
 rola_t=.f.                                        // flag se quer rolar a tela
 SELE REGIAO
 GO BOTT                                           // forca o
 SKIP                                              // final do arquivo
 
 /*
    cria variaveis de memoria identicas as de arquivo, para inclusao
    de registros
 */
 FOR i=1 TO FCOU()
  msg=FIEL(i)
  M->&msg.=IF((fgrep .OR. reg_cop!=NIL).AND.!EMPT(rep[1]),rep[i],&msg.)
 NEXT
 REG_GERA_SEQ()
 IF !EVAL(cond_incl_)
  EXIT
 ENDI
 cabem=DISKSPACE(;
          IF(;
             LEN(sistema[op_sis,O_ARQUI,O_DIR_DBF])<2.OR.sistema[op_sis,O_ARQUI,O_DIR_DBF]="\",;
             0,;
             ASC(sistema[op_sis,O_ARQUI,O_DIR_DBF])-64;
          );
       )
 cabem=INT((cabem-2048)/REGIAO->(RECSIZE()))
 IF cabem<1                                        // mais nenhum!!!
  ALERTA()
  msg="Verifique ESPA€O EM DISCO, "+usuario
  DBOX(msg,,,,,"INCLUSŽO INTERROMPIDA!")           // vamos parar por aqui!
  EXIT
 ENDI
 SELE 0                                            // torna visiveis variaveis de memoria
 REG_GET1(INCLUI)                                  // recebe campos
 SELE REGIAO
 IF LASTKEY()=K_ESC                                // se cancelou
  cabem=0                                          // prepara saida da inclusao
  LOOP
 ENDI

 #ifdef COM_REDE
  GO BOTT                                          // vamos bloquear o final do
  SKIP                                             // arq para que nehum outro
  BLOREG(0,.5)                                     // usuario possa incluir
 #endi

 APPEND BLANK                                      // inclui reg em branco no dbf
 FOR i=1 TO FCOU()                                 // para cada campo,
  msg=FIEL(i)                                      // salva o conteudo
  rep[i]=M->&msg.                                  // para repetir
  REPL &msg. WITH rep[i]                           // enche o campo do arquivo
 NEXT

 #ifdef COM_REDE
  UNLOCK                                           // libera o registro e
  COMMIT                                           // forca gravacao
 #else
  IF RECC()-INT(RECC()/20)*20=0                    // a cada 20 registros
   COMMIT                                          // digitados forca gravacao
  ENDI
 #endi

 ult_reg=RECN()                                    // ultimo registro digitado
 l_max=l_s+Sistema[op_sis,O_TELA,O_SCROLL]+Sistema[op_sis,O_TELA,O_QTDE]
 IF l_s+l_a+1<l_max                                // se nao atingiu o fim da tela
  l_a++                                            // digita na proxima linha
 ELSE                                              // se nao rola a campos para cima
  SCROLL(l_s+Sistema[op_sis,O_TELA,O_SCROLL],c_s+02,l_max-1,c_s+04,1)
  SCROLL(l_s+Sistema[op_sis,O_TELA,O_SCROLL],c_s+11,l_max-1,c_s+40,1)
  SCROLL(l_s+Sistema[op_sis,O_TELA,O_SCROLL],c_s+44,l_max-1,c_s+46,1)
 ENDI
 IF reg_cop!=NIL                                   // estava na consulta e quis rep o campo
  sq_atual_=NIL
  EXIT                                             // cai fora...
 ENDI
ENDD

#ifdef COM_REDE
 REG_ANT_SEQ()                                     // restaura sequencial anterior
 SELE REGIAO
#endi

GO ult_reg                                         // para o ultimo reg digitado
SETKEY(K_F3,t_f3_)                                 // restaura teclas de funcoes
SETKEY(K_F4,t_f4_)
SET(_SET_DELETED,dele_atu)                            // ecluidos visiveis/invisiveis
SETKEY(K_CTRL_W,ctl_w)
SETKEY(K_CTRL_C,ctl_c)
SETKEY(K_CTRL_R,ctl_r)
RETU



#ifdef COM_REDE
 PROC REG_ANT_SEQ(est_seq)     // restaura sequencial anterior
 SELE REG_SEQ     // seleciona arquivo de controle de sequencial
 BLOARQ(0,.5)     // esta estacao foi a ultima a incluir?
 IF sq_atual_ == codigo
  REPL codigo WITH sq_codigo
 ENDI
 UNLOCK           // libera DBF para outros usuarios
 COMMIT           // atualiza cps sequenciais no disco
 RETU
#endi


PROC REG_CRIA_SEQ   // cria dbf de controle de campos sequenciais
LOCAL dbfseq_:=sistema[op_sis,O_ARQUI,O_DIR_DBF]+"REG_seq" // arq temporario
SELE 0                          // seleciona area vazia
IF !FILE(dbfseq_+".dbf")        // se o dbf nao existe
 DBCREATE(dbfseq_,{;            // vamos criar a sua estrutura
                    {"codigo"    ,"C",  3, 0};
                  };
 )
ENDI
USEARQ(dbfseq_,.f.,,,.f.)       // abre arquivo de cps sequencial
IF RECC()=0                     // se o dbf foi criado agora
 BLOARQ(0,.5)                   // inclui um registro que tera
 APPEND BLANK                   // os ultomos cps sequenciais
 SELE REGIAO
 IF RECC()>0                    // se o DBF nao estiver
  SET ORDER TO 0                // vazio, entao enche DBF seq
  GO BOTT                       // com o ultimo reg digitado
  REPL REG_SEQ->codigo WITH codigo
  DBSETORDER(1)                 // retorna ao indice principal
 ENDI
 SELE REG_SEQ                   // seleciona arq de sequencias
 UNLOCK                         // libera DBF para outros usuarios
 COMMIT                         // atualiza cps sequenciais no disco
ENDI
RETURN

PROC REG_GERA_SEQ()

#ifdef COM_REDE
 LOCAL ar_:=SELEC()
#else
 LOCAL reg_:=RECNO(),ord_ind:=INDEXORD()
#endi


#ifdef COM_REDE
 SELE REG_SEQ
 BLOARQ(0,.5)
 sq_codigo=REG_SEQ->codigo
#else
 DBSETORDER(0)
 GO BOTT
#endi

M->codigo=LPAD(STR(VAL(codigo)+1),03,[0])

#ifdef COM_REDE
 REG_GRAVA_SEQ()
 sq_atual_=REG_SEQ->codigo
 UNLOCK                                            // libera o registro
 COMMIT
 SELE (ar_)
#else
 DBSETORDER(ord_ind)
 GO reg_
#endi

RETU

PROC REG_GRAVA_SEQ
REPL codigo WITH M->codigo
RETU

PROC REG_tela     // tela do arquivo REGIAO
tem_borda=.t.
l_s=Sistema[op_sis,O_TELA,O_LS]           // coordenadas da tela
c_s=Sistema[op_sis,O_TELA,O_CS]
l_i=Sistema[op_sis,O_TELA,O_LI]
c_i=Sistema[op_sis,O_TELA,O_CI]
SETCOLOR(drvtittel)
vr_memo=NOVAPOSI(@l_s,@c_s,@l_i,@c_i)     // pega posicao atual da tela
CAIXA(mold,l_s,c_s,l_i,c_i)               // monta caixa da tela
i=LEN(sistema[op_sis,O_MENS])/2
@ l_s,c_s-1+(c_i-c_s+1)/2-i SAY " "+MAIUSC(sistema[op_sis,O_MENS])+" "
SETCOLOR(drvcortel)
@ l_s+01,c_s+1 SAY " C¢digo ³ Descri‡„o                      ³ Cobrador"
@ l_s+02,c_s+1 SAY "ÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄ"
@ l_s+03,c_s+1 SAY "        ³                                ³"
@ l_s+04,c_s+1 SAY "        ³                                ³"
@ l_s+05,c_s+1 SAY "        ³                                ³"
@ l_s+06,c_s+1 SAY "        ³                                ³"
RETU

PROC REG_gets     // mostra variaveis do arquivo REGIAO
LOCAL getlist := {}, l_max, reg_atual:=RECNO()
PRIV  l_a:=Sistema[op_sis,O_TELA,O_SCROLL]
REG_TELA()
l_max=l_s+Sistema[op_sis,O_TELA,O_SCROLL]+Sistema[op_sis,O_TELA,O_QTDE]
SETCOLOR(drvcortel+","+drvcorget+",,,"+corcampo)
DO WHILE !EOF() .AND. l_s+l_a<l_max
 @ l_s+l_a,c_s+02 GET  codigo;
                  PICT sistema[op_sis,O_CAMPO,01,O_MASC]

 @ l_s+l_a,c_s+11 GET  regiao

 @ l_s+l_a,c_s+44 GET  cobrador;
                  PICT sistema[op_sis,O_CAMPO,03,O_MASC]

 SETCOLOR(drvcortel+","+drvcortel+",,,"+drvcortel)
 l_a++
 SKIP
ENDD
GO reg_atual
SETCOLOR(drvcortel+","+drvcorget+",,,"+corcampo)
CLEAR GETS
RETU

PROC REG_get1(tp_mov)     // capta variaveis do arquivo REGIAO
LOCAL getlist := {}
PRIV  blk_regiao:=.t.

IF tp_mov=INCLUI
 IF TYPE("l_a")!="N"
  l_a=Sistema[op_sis,O_TELA,O_SCROLL]
 ENDI
 DO WHILE .t.
  rola_t=.f.
  SET KEY K_ALT_F8 TO ROLATELA
  SETCOLOR(drvcortel+","+drvcorget+",,,"+corcampo)
  @ l_s+l_a,c_s+02 GET codigo;
                   PICT sistema[op_sis,O_CAMPO,01,O_MASC]
  CLEA GETS
  @ l_s+l_a,c_s+11 GET  regiao
                   DEFINICAO 2

  @ l_s+l_a,c_s+44 GET  cobrador;
                   PICT sistema[op_sis,O_CAMPO,03,O_MASC]
                   DEFINICAO 3

  READ
  SET KEY K_ALT_F8 TO
  IF rola_t
   ROLATELA()
   LOOP
  ENDI
  IF LASTKEY()!=K_ESC .AND. drvincl .AND. op_menu=INCLUSAO
   IF !CONFINCL()
    LOOP
   ENDI
  ENDI
  EXIT
 ENDD
ENDI
PTAB(COBRADOR,'COBRADOR',1)
IF tp_mov=EXCLUI .OR. tp_mov=FORM_INVERSA
 IF !EMPTY(ALIAS())
  DELE
 ENDI
ELSEIF tp_mov=INCLUI .OR. tp_mov=RECUPERA .OR. tp_mov=FORM_DIRETA
 IF (op_menu=INCLUSAO .AND. LASTKEY()!=K_ESC) .OR. op_menu!=INCLUSAO
  IF op_menu!=INCLUSAO
   RECA
  ENDI
 ENDI
ENDI
RETU

* \\ Final de REGIAO.PRG
procedure accaixa

sele b
use ordpgrc
inde on numop to bb

sele a
use bxrec
go top
do while .not. eof()
 mnumop=numop
 sele b
 seek mnumop
 if eof()
	appe blank
	REPL ORDPGRC->origem WITH [ADM],;
				ORDPGRC->lancto_ WITH DATE(),;
				ORDPGRC->por WITH a->por,;
				ORDPGRC->numconta WITH IIF(EMPT(M->usuario),PADR(M->contarec+ide_maq,10,' '),PADR(M->usuario,10,' ')),;
        ORDPGRC->historico WITH M->histrcfcc,;
        ORDPGRC->debcred WITH [C],;
        ORDPGRC->valortotal WITH 0,;
        ORDPGRC->vencto_ WITH DATE(),;
        ORDPGRC->documento WITH [FCC/Taxas],;
        ORDPGRC->complement WITH [FCC/Taxas pagas na Recep‡„o]

   #ifdef COM_REDE
    ORDPGRC->(DBUNLOCK())                          // libera o registro
   #endi

  ENDI
  IF !PTAB(PADR(SUBSTR(M->ide_maq,2),4)+[BXR],[IMPPAR],1)
   ord_=LEN(sistema[EVAL(qualsis,"IMPPAR"),O_CHAVE])
   chv_="BXR-"+intlan+"-002"
   PTAB(chv_,"IMPPAR",ord_)
   FAZ_LANC("IMPPAR",chv_)
   REPL IMPPAR->idmaq WITH PADR(SUBSTR(M->ide_maq,2),4),;
        IMPPAR->base WITH [BXR]

   #ifdef COM_REDE
    IMPPAR->(DBUNLOCK())                           // libera o registro
   #endi

  ENDI
   IF EMPT(numop)
    IF op_menu=INCLUSAO
     numop=ORDPGRC->numop
    ELSE
     REPL numop WITH ORDPGRC->numop
    ENDI
   ENDI

  #ifdef COM_REDE
	 IF PTAB(numop,'ORDPGRC',1)
    REPBLO('ORDPGRC->nrdoctos',{||ORDPGRC->nrdoctos + 1})
   ENDI
   IF !EMPT(valorpg)
    REPBLO('TAXAS->pgto_',{||DATE()})
    REPBLO('TAXAS->forma',{||[P]})
    REPBLO('TAXAS->baixa_',{||DATE()})
    REPBLO('TAXAS->por',{||M->usuario})
    REPBLO('TAXAS->stat',{||[6]})
    REPBLO('TAXAS->valorpg',{||valorpg})
   ENDI
   IF op_menu=INCLUSAO
    emitido_=DATE()
    por=M->usuario
    filial=M->p_filial
   ELSE
    REPL emitido_ WITH DATE()
    REPL por WITH M->usuario
    REPL filial WITH M->p_filial
   ENDI
   IF EMPT(numop).AND.PTAB(IIF(EMPT(M->usuario),PADR(M->contarec+ide_maq,10,' '),PADR(M->usuario,10,' '))+M->histrcfcc+[       ],'ORDPGRC',2)
    REPBLO('ORDPGRC->valortotal',{||ORDPGRC->valortotal+valorpg})
   ENDI
   IF !EMPT(numop).AND.PTAB(numop,'ORDPGRC',1)
    REPBLO('ORDPGRC->valortotal',{||ORDPGRC->valortotal +valorpg})












                 ###   ####   #   #  #####  #   #  #####   ####  #####  ####    ###   ####    ###   ####    ###   
                #   #  #   #  ## ##    #    ##  #    #    #        #    #   #  #   #  #   #  #   #  #   #  #   #  
                #####  #   #  # # #    #    # # #    #     ###     #    ####   #####  #   #  #   #  ####   #####  
                #   #  #   #  #   #    #    #  ##    #        #    #    #  #   #   #  #   #  #   #  #  #   #   #  
                #   #  ####   #   #  #####  #   #  #####  ####     #    #   #  #   #  ####    ###   #   #  #   #  


                                                                    
                                                                    
                                                             #####  
                                                                    
                                                                    


                                     ####   #####   ####  #####  ####    ####   ###    ###   
                                     #   #  #      #      #      #   #  #      #   #  #   #  
                                     ####   ###    #      ###    ####   #      #####  #   #  
                                     #  #   #      #      #      #      #      #   #  #   #  
                                     #   #  #####   ####  #####  #       ####  #   #   ###   


                                                                    
                                                                    
                                                             #####  
                                                                    
                                                                    


                                 #   #   ###   #   #  #   #   ###   #          ####    ###   
                                 ## ##  #   #  ##  #  #   #  #   #  #          #   #  #   #  
                                 # # #  #####  # # #  #   #  #####  #          #   #  #   #  
                                 #   #  #   #  #  ##  #   #  #   #  #          #   #  #   #  
                                 #   #  #   #  #   #   ###   #   #  #####      ####    ###   


                                         #   #   ####  #   #   ###   ####   #####   ###   
                                         #   #  #      #   #  #   #  #   #    #    #   #  
                                         #   #   ###   #   #  #####  ####     #    #   #  
                                         #   #      #  #   #  #   #  #  #     #    #   #  
                                          ###   ####    ###   #   #  #   #  #####   ###   


                        INDuSTRIA DE URNAS BIGNOTTO LTDA                    

                                                           Novembro/1997

                              Ademilson Pedro Bom                           
                              Analista/projetista                           

    Industria de Urnas Bignotto Ltda                                 PAG   2
    Administradora - RECEPCaO
    ------------------------------------------------------------------------

    Industria de Urnas Bignotto Ltda                                 PAG   3
    Administradora - RECEPCaO
    ------------------------------------------------------------------------

    CONFIGURACAO DOS DIREToRIOS DE TRABALHO
    
        Sempre que e  acionada,  esta aplicacao verifica a   existencia,  no
    drive atual, do arquivo de nome ADR_TEMP.SYS.   Este arquivo  contem  as
    especificacoes do drive e diretorio onde estarao os  arquivos de dados e
    de indices manipulados pelo sistema.  Quando o mesmo  nao  e encontrado,
    o sistema faz  uma pausa e pede que o  operador  indique os drives  e/ou
    diretorios para armazenar os seguintes arquivos:
    
        . ARQUIVOS DE DADOS
    
          No diretorio  informado para arquivos de dados, a aplicacao  arma-
          zenara os arquivos com extensoes DBF (dados) e DBT (texto).
    
        . ARQUIVOS DE INDICES
    
          Cada arquivo de dados pode ter  um ou mais  arquivos de indices  a
          ele associados. Tambem, nos processos de  filtragem  e  ordenacao,
          durante  a operacao da aplicacao, sao criados  outros arquivos  de
          indices de carater temporario. No diretorio informado  para  indi-
          ces, a aplicacao colocara esses arquivos, que tem extensao NTX.
    
        . ARQUIVOS DE APOIO A APLICACAO
    
          ERROS.DBF -    As informacoes sobre os erros que porventura venham
          a ocorrer durante a operacao da aplicacao, estao armazenadas em um
          arquivo especial de nome ERROS.DBF.   Este arquivo, criptografado,
          contem nao somente as causas dos erros, como tambem as suas possi-
          veis solucoes.
    
          PRINTERS.DBF - Este arquivo  contem as informacoes das  configura-
          coes das impressoras mais comuns.   Caso este arquivo nao seja en-
          contrado no diretorio configurado, sera criado um novo com somente
          uma impressora (default).
    
          VGALIB.FTS -   Contem as fontes de caracteres para serem usadas em
          video padrao VGA, configuradas posteriormente na aplicacao,  atra-
          ves de menu.
    
        E importante lembrar que,  sempre que a aplicacao  nao localizar  os
    arquivos de que necessita, fara a criacao de novos arquivos vazios, apos
    confirmacao.
    
    Industria de Urnas Bignotto Ltda                                 PAG   4
    Administradora - RECEPCaO
    ------------------------------------------------------------------------












                                   dirtrab.t                                    













    
    
        A possibilidade de configuracao permite que se   compatibilize  esta
    aplicacao com a configuracao existente no equipamento disponivel.
    
        Existe ainda a possibilidade de alterar essas configuracoes, a qual-
    quer  momento, atraves do menu de "Processamento de apoio" desta aplica-
    cao.
    
        E importante lembrar que,  quando a aplicacao e ativada e nao conse-
    guir localizar os arquivos de dados necessarios, efetua a criacao de no-
    vos arquivos, vazios, para serem utilizados.  Antes  de cria-los, porem,
    o programa  solicita  uma  confirmacao do operador, atraves de menu.
    
    Industria de Urnas Bignotto Ltda                                 PAG   5
    Administradora - RECEPCaO
    ------------------------------------------------------------------------

    ENTRADA DA SENHA DE ACESSO
    
        A solicitacao  da  senha  de acesso tem a finalidade de impedir  que
    pessoas nao autorizadas acessem as informacoes manipuladas pela  aplica-
    cao. Ao ser solicitado, o operador devera digitar a sua senha de acesso,
    a partir da tela a seguir:
    











                                    senha.t                                     













    
    
        Ao digitar a senha, o operador podera pressionar [ESC] para  recome-
    car a digitacao, no caso de ter cometido algum erro na informacao.
    
        Se esta for a primeira vez que a aplicacao esta sendo executada,   a
    senha existente e a palavra formada  pelas tres primeiras letras do nome
    do programa executavel. Neste caso, ao acessar  a  aplicacao,  selecione
    "Processamento de apoio", faca os  credenciamentos dos operadores e des-
    credencie  este  nome que acabou de ser utilizado.
    
    Industria de Urnas Bignotto Ltda                                 PAG   6
    Administradora - RECEPCaO
    ------------------------------------------------------------------------

    MENU GERAL DO SISTEMA
    
        Apos confirmar a data atual, sera  apresentada ao  operador  o  MENU
    GERAL, a partir do qual serao selecionadas todas as funcoes  e processa-
    mentos disponiveis na aplicacao.
    











                                    menug.t                                     













    
    
        Todas as operacoes da aplicacao podem  ser selecionadas por meio das
    setas cursoras do teclado do micro, movendo-se  a  barra ate a opcao de-
    sejada e pressionando em seguida a tecla ENTER.  Pode-se tambem selecio-
    nar quaisquer das opcoes, pressionando a sua letra inicial.
    
        As teclas de funcao abaixo poderao ser usadas conforme segue:
    
        EM QUALQUER SITUACAO
    
                F1 - Mostra texto de ajuda especifica ao contexto;
    
            ALT-F2 - Permite entrada de comando do DOS;
    
                F5 - Ativa o pop-calendario do mes atual;
    
                F6 - Ativa a pop-calculadora;
    
            ALT-F8 - Permite  mudar  a posicao  na tela, das janelas, menus,
                     caixas de  dialogo,  etc.,  atraves das setas cursoras.
                     Ao pressionar a tecla ENTER, o  operador  estara  acei-
    Industria de Urnas Bignotto Ltda                                 PAG   7
    Administradora - RECEPCaO
    ------------------------------------------------------------------------

                     tando a nova  posicao da janela. Esta operacao e valida
                     inclusive para as janelas temporizadas, ou seja, as que
                     desaparecem da tela apos  alguns momentos, sem a inter-
                     ferencia do operador;
    
        SOMENTE NA DIGITACAO DE REGISTROS
    
                F3 - Liga/desliga a repeticao automatica do registro que foi
                     digitado anteriormente;
    
                F4 - Liga/desliga confirmacao (no fim do campos);
    
                F8 - executa, para alguns campos, um comando especifico  que
                     tenha sido definido.
    
    
                F9 - Permite que as informacoes de outros arquivos da  apli-
                     cacao sejam consultadas,  modificadas,  adicionadas   e
                     ainda, trazidas automaticamente para o arquivo de dados
                     corrente. Se a aplicacao manipular somente  um  arquivo
                     de dados, os registros desse arquivo poderao ser vistos
                     na janela de  consulta.
    
            ALT-F1 - Podera ser utilizada para ligar e desligar a ajuda ati-
                     va. Com esta ajuda ligada, sempre que o cursor parar em
                     um determinado campo, uma janela contendo texto de aju-
                     da se abre automaticamente para  orientar a entrada  de
                     dados para aquele campo.
    
        SUPORTE A MOUSE
    
        Dentro da aplicacao, o funcionamento do mouse  tem as seguintes  ca-
        racteristicas:
    
                a. o botao da  ESQUERDA serve  para selecionar opcoes,  cam-
                   pos e arrastar objetos (janelas) atraves da tela.
    
                b. o botao do MEIO, se o mouse conectado o possuir, nao  tem
                   qualquer finalidade na operacao da aplicacao;
    
                c. em qualquer situacao, o botao da DIREITA funciona como se
                   a tecla ESC tiver sido pressionada, servindo para  cance-
                   lar, retornar telas ou abandonar operacoes;
    
    
        Para selecionar uma  opcao dentro de um menu, basta "clicar" o mouse
        sobre a opcao desejada e a barra  em reverso e posicionada na  opcao
        escolhida.    Um segundo click sobre a barra em reverso  selecionara
        definitivamente a opcao.
    
        Para cancelar  e retornar a tela ou menu anterior, basta "clicar"  o
        botao da direita, independentemente de onde o  cursor do mouse esti-
        ver posicionado.
    Industria de Urnas Bignotto Ltda                                 PAG   8
    Administradora - RECEPCaO
    ------------------------------------------------------------------------

    
        Para mudar uma janela de posicao, pressionar o botao da esquerda so-
        bre uma das opcoes  (que nao estiver em reverso,  pois provocaria  a
        sua selecao) e reter pressionado durante meio segundo.      A partir
        deste tempo, pode-se arrastar o mouse, mantendo o botao pressionado,
        e escolher o local desejado para fixar a janela, o que e feito pres-
        sionando-se o botao da direita.
    
        Sempre que a quantidade de opcoes em um menu nao puderem ser  exibi-
        das ao mesmo tempo na janela, uma barra de rolagem e criada  automa-
        ticamente na borda direita da janela mostrando a posicao relativa  a
        quantidade total de opcoes.    Aparecem tambem nas partes superior e
        inferior desta barra de rolagem duas setas que podem  ser "clicadas"
        com o mouse para provocar a rolagem das opcoes.
    
    Industria de Urnas Bignotto Ltda                                 PAG   9
    Administradora - RECEPCaO
    ------------------------------------------------------------------------

    MANUTENCAO DAS INFORMACOES
    
        A manutencao dos arquivos de dados dos  subsistemas e  feita atraves
    de um menu intermediario, com tres opcoes:
    
    
        INCLUSAO DE NOVOS REGISTROS
    
        Selecione esta opcao sempre que desejar inserir mais informacoes  em
        um determinado subsistema.
    
    
        MANUTENCAO
    
        Ativando esta opcao, o usuario tera acesso a rotinas de consulta aos
        dados cadastrados,  podendo  alterar qualquer informacao,  bem  como
        apagar e recuperar registros do arquivo. Podera tambem fazer proces-
        samentos de alteracoes globais, que atingem registros agrupados  por
        um  determinado criterio de selecao estabelecido.
    
    
        CONSULTA (TELA PAGINADA)
    
        Apresenta uma tela  do tipo "view", com os campos do arquivo dispos-
        tos horizontalmente na forma colunar, permitindo ao operador uma vi-
        sao mais abrangente dos dados, alem da montagem  de  consultas,  com
        insercao e apagamento de colunas,  com funcoes de pesquisa,  altera-
        cao, exclusao, inclusao e filtragem de registros.
    Industria de Urnas Bignotto Ltda                                 PAG  10
    Administradora - RECEPCaO
    ------------------------------------------------------------------------

    ENTRADA DE DADOS
    











                                   entrada.t                                    













    
    
        A inclusao de  novas informacoes no cadastro esta  assistida por ro-
    tinas especiais que objetivam principalmente a facilidade de  operacao e
    a integridade dos dados cadastrados. Existem alguns aspectos interessan-
    tes para se conhecer:
    
        . A cada 20 registros digitados, o arquivo de dados sofre um proces-
          samento especial (sem que o operador perceba), que garante a inte-
          gridade dos dados digitados. Assim, por exemplo, se apos um  tempo
          muito longo de digitacao, ocorrer  alguma falha de energia,  o ma-
          ximo de perda que podera ocorrer sao  os vinte  ultimos  registros
          digitados.
    
        . Enquanto o operador estiver  digitando  informacoes no arquivo,  a
          aplicacao esta constantemente  gerenciando o espaco  disponivel no
          disco. Caso nao caibam mais registros no arquivo, o programa  avi-
          sara o operador e voltara ao menu.
    
        . Atraves da tecla F3 o operador podera ativar a repeticao automati-
          ca do registro anteriormente digitado. Esta funcao e especialmente
          util nos casos de digitacoes de informacoes que podem estar  repe-
          tidas em diversos registros  como,  por exemplo,  cidade,  estado,
          etc. Uma vez que os dados estejam presentes na tela, basta  que  o
          operador pressione ENTER para aproveitar essas informacoes. Quando
          esta funcao nao for mais desejada,  basta  pressionar  novamente a
    Industria de Urnas Bignotto Ltda                                 PAG  11
    Administradora - RECEPCaO
    ------------------------------------------------------------------------

          tecla F3.
    
        . A tecla F4 serve para ligar e desligar o  estado de confirmacao da
          informacao digitada. Normalmente, quando se digita informacoes ate
          o final do campo, o  cursor  passa  automaticamente para o proximo
          campo, dispensando o uso da tecla ENTER.  Se nao for desejada esta
          facilidade, basta pressionar a tecla F4.
    
        . A tecla F8 podera conter um comando especial, para alguns  campos,
          definido pelo projetista da aplicacao.
    
        . A tecla F9, se estiver aparecendo na tela, permite o acesso a  ou-
          tros arquivos da aplicacao, se existirem.   O acionamento da tecla
          F9 ativa a rotina  que apresenta a tela paginada da aplicacao, que
          oferece  um  grande leque de operacoes sobre os arquivos de dados.
          Esta  tela  e  a  mesma  utilizada  pela  opcao  "Consulta  e  faz
          projecoes", do menu principal da aplicacao.   Se a aplicacao mani-
          pular somente um arquivo de dados, este arquivo  sera mostrado  na
          janela.  Se tiver mais de um arquivo, sera apresentado um  menu, a
          partir do qual o operador podera selecionar o arquivo desejado.
    
        Durante a digitacao de informacoes, diversas teclas tem funcoes  es-
    peciais para a "navegacao" do cursor, bem como para acessar recursos  de
    edicao:
    
         ^E/.   move o cursor para o campo anterior
         ^X/.   move o cursor para o campo seguinte
         ^D/->  move o cursor uma posicao a direita
         ^S/<-  move o cursor uma posicao a esquerda
         ^F     move o cursor para o inicio da proxima palavra
         ^A     move o cursor para o inicio da palavra anterior
         ^T     apaga a palavra a direita do cursor
         ^Y     apaga o conteudo do campo, a partir do cursor
         ^V/INS liga/desliga modo de insercao
         ^U     restaura o conteudo do campo, descartando o que foi digitado
         ESC    abandona digitacao, sem gravar
    
    Industria de Urnas Bignotto Ltda                                 PAG  12
    Administradora - RECEPCaO
    ------------------------------------------------------------------------

    ALTERACAO/EXCLUSAO DE REGISTROS
    
    
        Sempre que e ativada, esta opcao coloca  na tela o primeiro registro
    do arquivo, segundo a ordem estabelecida pela chave do arquivo de  indi-
    ce. As teclas ^PGUP e ^PGDN  servem  para  exibir  o primeiro e o ultimo
    registro, respectivamente.
    
    
        TECLA F9
    
        A  tecla F9 permite o acesso a  outros  arquivos da  aplicacao, caso
    existam.  Se a aplicacao tiver somente um arquivo de  dados,  este  sera
    exibido na tela. Se houver mais de um arquivo, sera apresentado um menu,
    a  partir  do  qual  o  operador  podera  selecionar o arquivo desejado.
    O acionamento da tecla F9 ativa a rotina que  apresenta a tela  paginada
    da aplicacao, que oferece um grande leque de operacoes sobre os arquivos
    de dados.   Esta tela e a mesma utilizada  na opcao "Consulta", do  menu
    principal da aplicacao.
    
    
        TECLA F10
    
        Pressionando-se a tecla F10, um menu de comandos aparecera para per-
    mitir diversas operacoes sobre o arquivo de dados. As opcoes deste menu,
    que aparecem detalhadas a seguir,  podem ser acessadas diretamente pelas
    suas letras iniciais, de modo que, quando o operador estiver  acostumado
    com o  sistema, nao mais precisara fazer uso da tecla F10.
    
        TECLA TAB / F8
    
        A tecla TAB provoca a mudanca de tela ativa, ou seja, a tela que fi-
    ca disponivel no momento para manutencao. A tecla F8 tem o funcionamento
    identico a tecla TAB exceto se existirem mais de um arquivo subordinado.
    Neste caso, a tecla F8 faz surgir um menu de onde podera ser selecionada
    a tela que se deseja tornar ativa para manutencao.
    
    
        MOUSE
    
        Para editar um campo do registro na tela, pode-se  "clicar"  direta-
    mente sobre um campo para seleciona-lo para edicao.   Ao digitar  infor-
    macoes  dentro dos campos, o  botao direito do  mouse podera tambem  ser
    utilizado para cancelar a edicao ("get").  Sempre que existir setas  im-
    pressas nas bordas das janelas, bem como PGUP, PGDN, TOPO ou FIM o mouse
    pode ser utilizado para fazer a rolagem de registros para a frente e pa-
    ra tras, dependendo da seta que for "clicada".
    
    Industria de Urnas Bignotto Ltda                                 PAG  13
    Administradora - RECEPCaO
    ------------------------------------------------------------------------












                                    altera.t                                    













    
    
    
          PROCURA (acesso indexado)
    
          Permite a colocacao na tela,  de qualquer um dos registros do  ar-
          quivo, para ser consultado ou alterado. Esta procura e sempre fei-
          ta atraves  das chaves de acesso de cada um dos conjuntos  de pes-
          quisa  estabelecidos para  a  aplicacao.  Se  houver  mais  de  um
          conjunto de pesquisa,  um  menu  sera apresentado  ao operador, de
          onde podera escolher a  pesquisa desejada.
    
    
          SEGUINTE (acesso sequencial crescente)
    
          Permite avancar os registros sequencialmente, um a um, ate  que  o
          final do arquivo seja atingido.  Enquanto os registros sao acessa-
          dos, estes vao sendo exibidos na tela.  Esta opcao pode tambem ser
          acionada  pressionando-se a tecla de seta direita.
    
    
          ANTERIOR (acesso sequencial descrescente)
    
          Tem  funcionamento identico a opcao anterior, sendo que os  regis-
          tros sao retrocedidos ate que o inicio do  arquivo seja  atingido.
          Esta opcao pode tambem ser acionada pressionando-se a tecla de se-
          ta esquerda.
    
    Industria de Urnas Bignotto Ltda                                 PAG  14
    Administradora - RECEPCaO
    ------------------------------------------------------------------------

    
          DIGITA
    
          Esta opcao permite a entrada de informacoes no cadastro, sem a ne-
          cessidade de voltar ao menu de inclusao. Basta selecionar esta op-
          cao e iniciar a digitacao de dados.
    
    
          MODIFICA
    
          Permite alterar as informacoes do registro  que  estiver  presente
          na tela,  exceto conteudos de campos-chaves,  caso a chave seja do
          tipo primaria.  Convem lembrar que as novas  informacoes inseridas
          estao  sujeitas as mesmas validacoes (criticas) estabelecidas para
          a digitacao  de registros.
    
    
          EXCLUI
    
          Marca para apagamento o registro presente na tela,  apos confirma-
          cao do usuario. Ao abandonar a operacao de "Alteracao/exclusao  de
          registros", o operador podera selecionar  "Processamento de apoio"
          e apagar definitivamente os registros marcados. Conforme o ambien-
          te da aplicacao estiver configurado, uma  confirmacao  podera  ser
          solicitada ao  usuario, antes do processo de marcacao do registro.
    
    
          RECUPERA
    
          Desmarca um registro que ja tenha sido marcado para  ser  apagado.
          Esta opcao permite a correcao de enganos cometidos  pelo  operador
          na  marcacao de registros para apagamento.
    
    
          FILTRA
    
          Permite o estabelecimento de um criterio para a selecao dos regis-
          tros que serao acessados pela consulta.  Para elaborar uma filtra-
          gem, o primeiro passo e definir uma condicao comum para agrupar os
          registros que estarao disponiveis na consulta.    Esta definicao e
          feita atraves do processo  de filtragem, que  sera detalhado  mais
          adiante, no  capitulo intitulado "Consulta".
    
    
          ORDENA
    
          Permite o estabelecimento de uma nova ordem de aparecimento de re-
          gistros, durante o processo de consulta.  O processo de  ordenacao
          esta detalhado no capitulo a seguir,  intitulado  "Consulta  e faz
          projecoes".
    
    
          GLOBAL
    Industria de Urnas Bignotto Ltda                                 PAG  15
    Administradora - RECEPCaO
    ------------------------------------------------------------------------

    
          Esta  opcao  serve  para  desencadear  certas rotinas que  atingem
          global ou parcialmente o arquivo. Com a sua utilizacao, e possivel
          alterar, apagar ou recuperar um  grupo de registros  que  atenda a
          uma  determinada condicao.  No caso de alteracao global,  diversos
          campos podem ser  selecionados para serem processados com formulas
          definidas pelo usuario da aplicacao.   Ao selecionar esta opcao, o
          usuario  e  lembrado  pelo  sistema  de  que  a  execucao de copia
          "backup" pode ser uma boa ideia.   De fato,  como o  processamento
          global atinge  registros agrupados por  um criterio de selecao, um
          estabelecimento indevido desse criterio podera modificar indevida-
          mente certos registros. Neste caso, uma copia de seguranca  podera
          ser util para restabelecer a situacao anterior.
    











                                    opglob.t                                    













    
    
          Deste menu pode-se escolher o tipo de processo a ser feito em  de-
          terminado grupo de registros, podendo ser um apagamento, uma recu-
          peracao ou modificacao de campos.
    
          E  importante observar que,  os registros atingidos pelo processa-
          mento global sao os que  foram selecionados pelo processo de  fil-
          tragem (selecao de registros) e que estao fazendo parte da consul-
          ta.  Se  nao  existir  um processo  previo de filtragem,  TODOS os
          registros do arquivo sofrerao o processamento global.
    
    
          Processamento global com confirmacao ou sem confirmacao
    Industria de Urnas Bignotto Ltda                                 PAG  16
    Administradora - RECEPCaO
    ------------------------------------------------------------------------

    











                                   confnao.t                                    













    
    
          A partir desta tela, deve-se escolher uma das duas opcoes disponi-
          veis.   Na primeira delas,  antes de efetuar o processo, o sistema
          mostrara ao operador cada  registro a  ser  processado,  dando-lhe
          a oportunidade de confirmar o processo.   Na segunda opcao, o sis-
          tema efetuara os processos automaticamente, sem confirmacao.
    
          Se o  processo global  escolhido foi "Modificar", existe um  passo
          intermediario, que e a definicao dos campos do arquivo que deverao
          ser modificados e quais as formulas a utilizar nas modificacoes.
    
          Um processo  global de modificacao pode ser  feito simultaneamente
          em diversos campos do arquivo, cada um, segundo uma formula  espe-
          cifica a ser estabelecida.    Para informar um processo de modifi-
          cacao global, siga as seguintes etapas:
    
    
                1a. etapa da modificacao global
    
                A  primeira  etapa  consiste em selecionar o campo que  deve
                sofrer o processo de alteracao, a partir do seguinte menu:
    
    Industria de Urnas Bignotto Ltda                                 PAG  17
    Administradora - RECEPCaO
    ------------------------------------------------------------------------












                                    cpglob.t                                    













    
    
                Importante  observar  que os campos envolvidos  na  chave de
                acesso, bem  como os campos do tipo "memo" (texto) nao podem
                ser modificados, sendo por isso, recusados.
    
                2a. Etapa da modificacao global
    
                A segunda  etapa consiste  no  estabelecimento  da formula a
                ser utilizada para o  processo de  alteracao  do campo sele-
                cionado.   Nesta  operacao,  deve-se ter o cuidado de entrar
                com expressoes  validas para a linguagem Clipper.  Neste mo-
                mento, atraves da tecla F10, pode-se visualizar os campos do
                arquivo corrente. Os nomes entre parenteses sao os nomes dos
                campos identificados internamente dentro do arquivo,  e  sao
                os que deverao ser mencionados nas expressoes a serem utili-
                zadas.  Se preferir, o usuario pode pressionar ENTER e levar
                este nome para dentro da expressao que estiver sendo digita-
                da, na posicao do cursor.
    
                Informada  a  formula para  modificacao do campo,  o sistema
                apresenta novamente o menu de campos do arquivo.  Se desejar
                modificar outro campo,  o procedimento e o mesmo,  caso con-
                trario, basta pressionar ESC e prosseguir com a operacao.
    
                Se nao existir mais campos para modificar,  basta pressionar
                ESC e prosseguir com a operacao.
    Industria de Urnas Bignotto Ltda                                 PAG  18
    Administradora - RECEPCaO
    ------------------------------------------------------------------------

    CONSULTA (TELA PAGINADA)
    
        Esta opcao,  proporciona ao usuario a  manipulacao total do arquivo,
    a partir  de  uma tela  cheia,   na qual  os registros sao  apresentados
    agrupadamente,  com  os  campos  mostrados  dentro de colunas  que podem
    estar contidas em varias janelas horizontais.
    
        Na tela "Consulta" o usuario tem poderosos  recursos para  manipular
    os dados cadastrados,  desde a definicao de consultas ate a montagem  de
    relatorios.
    
        Ao ser ativada esta opcao, o sistema verifica se  existe alguma con-
    sulta gravada previamente em disco.    Existindo, monta um menu contendo
    todas as consultas encontradas.
    











                                   menucons.t                                   













    
    
        A partir deste menu, pode-se  selecionar uma nova  consulta ou qual-
    quer outra que tenha sido previamente definida e gravada.
    
        Se nao existir consulta gravada,  ou,  apos selecionar uma opcao  do
    menu, a aplicacao apresentara a tela a seguir:
    
    Industria de Urnas Bignotto Ltda                                 PAG  19
    Administradora - RECEPCaO
    ------------------------------------------------------------------------












                                      tp.t                                      













    
    
        Antes da abordagem dos diversos  recursos existentes, faz-se  neces-
    sario conhecer as teclas utilizadas para a navegacao ou movimentacao.
    
        . setas (para cima e para baixo)  movimentam o  cursor  atraves  dos
          registros do arquivo, um de cada vez.
    
        . setas  (direita/esquerda), movem  o cursor horizontalmente,  campo
          a campo, provocando a  rolagem da tela, caso existam mais campos a
          serem mostrados.
    
        . PGUP e PGDN, servem para  passar paginas, isto e,  mostrar o grupo
          de registros seguinte (ou anterior conforme o caso).
    
        . CTRL+PGUP e CTRL+PGDN, posicionam  o cursor no  primeiro e  ultimo
          registro do arquivo, respectivamente.
    
        . CTRL+HOME e CTRL+END,  posicionam  o  cursor na primeira  e ultima
          coluna, respectivamente.
    
        . Tecla TAB serve para mudar  a direcao que o cursor  assume a  cada
          vez que a tecla ENTER e pressionada.  Esta tecla pode ser acionada
          mesmo durante as  alteracoes dos conteudos  dos campos, sendo bas-
          tante util para se modificar os campos de um mesmo registro (hori-
          zontal)  ou  para  modificar um  mesmo campo em diversos registros
          (vertical).
    
    Industria de Urnas Bignotto Ltda                                 PAG  20
    Administradora - RECEPCaO
    ------------------------------------------------------------------------

        . Tecla F9, quando estiver aparecendo  na tela, permite  abrir outro
          arquivo  para ser consultado,  ou serve para transferir o conteudo
          de um campo para outros arquivos,  onde  estiverem sendo digitados
          registros.
    
        . A tecla ALT-F10, quando acionada, serve para alterar  o estado  de
          apresentar ou nao os registros que estao marcados como apagados no
          arquivo de dados.
    
        . ALT-Z, serve  para ampliar a janela da consulta, passando a utili-
          zar toda  a area disponivel  da tela  (horizontal e verticalmente)
          para a apresentacao da consulta.
    
        . Mouse.  Para editar um campo do registro na tela, pode-se "clicar"
          diretamente sobre o mesmo.      Um segundo clique sobre a barra em
          reverso posicionara o cursor dentro do campo, entrando no modo  de
          alteracao.  Ao digitar informacoes dentro dos campos, o botao  di-
          reito do mouse podera tambem ser  utilizado para cancelar a edicao
          ("get").   Sempre que existir setas impressas nas bordas das jane-
          las, bem como PGUP, PGDN, TOPO ou FIM o  mouse pode ser  utilizado
          para fazer a rolagem de registros para  a frente e para atras, de-
          pendendo da seta que for clicada.
    
        Alem dos controles acima existem ainda outras opcoes acessadas atra-
        ves de menu ativado pela tecla F10, ou  atraves da  1. letra de cada
        uma de suas opcoes.
    











                                    tpmenu.t                                    













    
    Industria de Urnas Bignotto Ltda                                 PAG  21
    Administradora - RECEPCaO
    ------------------------------------------------------------------------

    
        . P   posiciona o cursor sobre qualquer um dos registros do  arquivo,
              para ser consultado ou alterado.  Esta pesquisa  e sempre feita
              atraves  das  chaves de acesso de cada um dos conjuntos de pes-
              quisa estabelecidos  para a aplicacao.     Caso haja mais de um
              conjunto  de  pesquisa,  um menu  sera  apresentado,  podendo o
              operador escolher o conjunto de pesquisa desejado.
    
        . F   aciona a  rotina de filtragem que permite a selecao ou  agrupa-
              mento dos registros  que farao parte da consulta,  ou seja, uma
              vez estabelecida  uma filtragem, somente os registros que aten-
              dam a uma determinada condicao  aparecerao dentro  da janela de
              consulta.
    
              Existem dois modos de se executar a filtragem dos registros:
    
              1. CRITERIO LIVRE - no qual e permitido ao operador entrar li-
                 vremente com  uma expressao contendo funcoes  da  linguagem
                 Clipper.  Esta  maneira de filtrar registros pode ser sele-
                 cionada acionando-se a primeira opcao do menu de filtragem.
                 E IMPORTANTE observar que, para fazer uso deste  metodo,  o
                 operador DEVERA CONHECER  a  sintaxe  da linguagem Clipper,
                 para  que  nao ocorram erros durante a execucao (sem conse-
                 quencias). Por isso, em algumas ocasioes, dependendo do ni-
                 vel de acesso do usuario, esta  opcao podera nao estar  fi-
                 gurando no menu.
    











                                   crilivre.t                                   













    
    Industria de Urnas Bignotto Ltda                                 PAG  22
    Administradora - RECEPCaO
    ------------------------------------------------------------------------

    
              2. FILTRAGEM POR MENU - atraves de menu proprio, de onde pode-
                 rao ser montados ate 3 criterios, na seguinte ordem:
    
                 CAMPOS DO ARQUIVO
                 selecionar o campo objeto  da filtragem,  ou seja,  o campo
                 que ira ser comparado com os demais parametros a serem for-
                 necidos;
    
                 OPERADORES RELACIONAIS
                 selecionar um dos operadores:
    
                      diferente de
                      menor que
                      menor ou igual
                      maior que
                      maior ou igual
                      contem
                      nao contem
    
                 SEGUNDO OPERANDO
                 informar  o segundo operando,  que representa  a informacao
                 que sera comparada pelo sistema, para saber  se o  registro
                 sera ou nao considerado. (nao usar aspas)
    
                 OPERADOR LoGICO
                 Se desejar um segundo criterio de filtragem, basta selecio-
                 nar o operador logico  (E / OU)  e  continuar a montagem do
                 criterio de selecao.  Quando terminar a montagem do  crite-
                 rio, basta selecionar "OK!".
    
        . D   permite a digitacao (inclusao)  de novos registros  dentro  do
              arquivo de dados corrente. Esta operacao  esta sujeita as mes-
              mas validacoes (criticas) estabelecidas para a inclusao normal
              de registros no arquivo de dados,  sendo bastante util para se
              inserir registros em tabelas (outros arquivos onde informacoes
              digitadas sao validadas).
    
        . M   permite a  alteracao das informacoes contidas no campo  onde o
              cursor estiver posicionado. A alteracao de campos esta sujeita
              as  mesmas validacoes estabelecidas para a digitacao de regis-
              tros.
    
        . E   marca para  exclusao, o registro que estiver sendo acessado no
              momento.    A exclusao definitiva do registro so e feita atra-
              ves  das  rotinas de "Processamento de apoio ao sistema". Con-
              forme o ambiente da aplicacao esteja configurado, uma  confir-
              macao  podera ser solicitada ao usuario, antes  do processo de
              marcacao do  registro.
    
        . R   recupera  (retira a marcacao ) o registro  marcado pela  opcao
              anterior.
    
    Industria de Urnas Bignotto Ltda                                 PAG  23
    Administradora - RECEPCaO
    ------------------------------------------------------------------------

        . V   mostra  a  tela  de digitacao do arquivo corrente, com os res-
              pectivos conteudos de campos, apenas para consulta.  Se houver
              mais de uma tela, o operador podera utilizar as teclas PGUP  e
              PGDN para exibi-las.
    
        . N   possibilita que uma nova coluna seja criada e inserida na con-
              sulta.  Ao ativar este comando, o operador podera entrar com o
              titulo da nova  coluna, o conteudo da  mesma, bem  como a res-
              pectiva mascara.  O conteudo dessas colunas pode se constituir
              de campos  de outros  arquivos, formulas  diversas  envolvendo
              campos, etc.
    
              CRIACAO DE NOVA COLUNA NA CONSULTA
              Para  inserir  uma  nova  coluna na janela de consulta,  basta
              responder algumas perguntas feitas pela aplicacao:
    
                TiTULO DA NOVA COLUNA
                Essa informacao servira para intitular a nova  coluna a  ser
                criada na consulta. Forneca uma informacao que possa identi-
                ficar o conteudo da nova coluna a ser criada.    Se  desejar
                criar coluna contendo um campo  de outro  arquivo de  dados,
                basta pressionar F10, escolher  o arquivo desejado e o campo
                desse arquivo  para ser mostrado na nova coluna.
    
    
                EXPRESSAO CONTEuDO
                Informe  uma  expressao para conteudo  da nova coluna.   Sao
                validas expressoes da  linguagem  Clipper  bem como nomes de
                campos.   Para obter o nome do campo do arquivo, pressione a
                tecla  F10  e um menu com os nomes dos campos do arquivo  em
                uso aparecera.
    
    
                COM A MASCARA
                A  mascara  e  um gabarito segundo  o qual as expressoes sao
                mostradas. Alguns exemplos de mascaras:
    
                !!!          o ponto  de exclamacao  faz  com que o caracter
                             mostrado  naquela  posicao  apareca  sempre  em
                             maiusculo;
    
                @!           todos  os  caracteres  dentro  do  campo  serao
                             transformados para maiusculo;
    
                99999999     somente digitos  numericos na  mesma quantidade
                             de "9" existentes serao mostrados;
    
                @R 999-9999  @R  na  mascara  faz  com  que  barras, pontos,
                             hifens ou virgulas sejam apresentados nas posi-
                             coes, mesmo que nao existam no conteudo do cam-
                             po;
    
                @E 9,999.99  o @E faz com que a virgula seja permutada  pelo
    Industria de Urnas Bignotto Ltda                                 PAG  24
    Administradora - RECEPCaO
    ------------------------------------------------------------------------

                             ponto na separacao das casas decimais, ajustan-
                             do-se ao formato numerico utilizado no Brasil.
    
        . A   permite  retirar da consulta,  a  coluna onde o cursor estiver
              posicionado.
    
        . I   possibilita a impressao,  em papel,  da  consulta selecionada.
              Todos os campos numericos sao automaticamente totalizados.  Se
              houver  mais de uma  janela aberta  (atraves da tecla J), e  a
              mesma estiver relacionada (arquivos sincronizados), os  regis-
              tros dessa segunda tela tambem serao impressos.
    
        . O   ordena os registros constantes da  consulta, ou seja, possibi-
              lita a apresentacao  da consulta  com  ordenacoes  por  outros
              campos  do arquivo  ou  por qualquer  coluna  que  tenha  sido
              criada.  Mesmo que o arquivo tenha sido ordenado, as pesquisas
              ao arquivo continuam  a existir em funcao dos campos definidos
              nos conjuntos de pesquisa.    Se existir mais de um arquivo de
              indice, esses serao apresentados em um menu para que possa ser
              selecionado um  deles, senao,  selecione  "* OUTRA ORDEM *"  e
              crie seu proprio criterio de ordenacao.
    











                                    ordena.t                                    













    
    
              A partir  desta tela,  o operador podera selecionar os  campos
              que determinarao a classificacao da tela  paginada.    A ordem
              pode ser estabelecida  em  funcao de mais  de um campo, porem,
              campos do  tipo "memo", se existir, nao serao selecionaveis.
    Industria de Urnas Bignotto Ltda                                 PAG  25
    Administradora - RECEPCaO
    ------------------------------------------------------------------------

    
              A exemplo do processo de filtragem, existe tambem a possibili-
              dade de se estabelecer uma ordenacao "livre". No entanto, para
              usar este recurso, o usuario podera necessitar do conhecimento
              de algumas funcoes do Clipper.
    
              Pode-se  ainda, apos a escolha de cada um dos campos, determi-
              nar se a ordenacao  por aquele campo obedecera  a ordem  cres-
              cente ou  decrescente.
    
    
        . Q   quantifica os registros que atendam a  uma determinada  condi-
              cao definida pelo operador.   A condicao e sempre estabelecida
              atraves do processo de filtragem, explicado anteriormente nes-
              te  capitulo.   Estabelecida a  condicao,  a aplicacao  fara a
              contagem dos  registros, apresentando o resultado final em uma
              janela na  parte inferior da tela:
    











                                    quant.t                                     













    
    
        . L   localiza determinado registro no arquivo, por pesquisa sequen-
              cial.  A localizacao de registros pode ser feita por argumento
              ou por uma condicao atendida.
    
    Industria de Urnas Bignotto Ltda                                 PAG  26
    Administradora - RECEPCaO
    ------------------------------------------------------------------------












                                    local.t                                     













    
    
                 Por argumento
    
                 Na pesquisa por argumento,  o sistema solicita ao usuario a
                 informacao  do argumento a ser pesquisado e procedera  con-
                 forme a seguir:
    
                    Se o campo for do tipo "caracter" ou "memo", tentara lo-
                    calizar  o primeiro  registro do arquivo que  CONTENHA o
                    argumento informado, em qualquer posicao do campo. Neste
                    caso,  se  a mascara desse campo for diferente  de  "@!"
                    (tudo maiusculo) o usuario podera escolher ainda,  atra-
                    ves  da pergunta  "A=a?", se a pesquisa  sera feita  com
                    "ignore case",  ou seja,  se   caracteres  maiusculos ou
                    minusculos  devem  ser  tratados  igualmente,  durante a
                    pesquisa.
    
                    Se o  campo for do tipo  "numerico" ou "data", o sistema
                    tentara  localizar o  primeiro  registro que  tenha como
                    conteudo do campo selecionado, o argumento informado.
    
    
                 Por condicao atendida
    
                 Na localizacao por uma condicao,  o usuario podera  estabe-
                 lecer uma condicao  qualquer, utilizando o processo de fil-
                 tragem  ja descrito  neste  capitulo,  e  o sistema tentara
    Industria de Urnas Bignotto Ltda                                 PAG  27
    Administradora - RECEPCaO
    ------------------------------------------------------------------------

                 localizar o  primeiro registro que atenda a essa condicao.
    
        . S   continua  uma  pesquisa  sequencial ao arquivo,  encontrando o
              proximo registro, que satisfaca a condicao ou argumento de lo-
              calizacao estabelecido pelo processo anterior (L).   Por  essa
              razao, esta opcao podera nao  estar  figurando no menu,  o que
              acontecera somente quando a opcao "L"  tiver sido ativada pelo
              menos uma vez.
    
        . G   possibilita o processamento global dos registros que  aparecem
              na consulta.  Este processamento pode ser feito para modifica-
              coes de campos, apagamento e recuperacao de registros.  A mon-
              tagem de um processamento global ja foi descrita neste manual,
              no capitulo intitulado "Alteracao/exclusao de registros".
    
        . C   "congela" ou fixa as colunas que estao a  esquerda do  cursor,
              mantendo-as na tela,  mesmo que  as setas  esquerda  e direita
              sejam utilizadas para "rolagem" horizontal  da  tela.   Quando
              colunas sao "congeladas", uma barra vertical  mais larga  apa-
              rece para  delimitar as areas que podem  e nao podem ser rola-
              das. Quando desejar "descongelar" colunas,  posicione o cursor
              na   primeira  coluna   da  janela  e  pressione  novamente  a
              tecla "C".
    
        . T   permite alterar o  tamanho ou largura de uma coluna de conteu-
              do.  Ao pressionar a tecla "T", deve-se entrar com a nova lar-
              gura a ser assumida para a coluna  onde esta o cursor ou barra
              reversa.
    
        . J   abre nova janela de  consulta ou,  se  ja existirem duas, per-
              mite a troca de janela de operacao.    Esta opcao e muito util
              para a visualizacao de dois  arquivos ao mesmo tempo, relacio-
              nados entre si, atraves de um determinado campo.    Para abrir
              uma segunda janela, o operador  seleciona atraves  de menu,  o
              arquivo que sera aberto na mesma e o indice utilizado para re-
              lacionamento.    No caso de relacionamento, deve ser informado
              ainda o(s) campo(s) do  primeiro arquivo a ser  utilizado para
              sincronizar o segundo arquivo.
    
        . X   exporta  os dados constantes da  consulta para outras  aplica-
              coes, nos seguintes formatos:
    
                 FORMATO TXT
                 Neste formato, normalmente usado por processadores  de tex-
                 to,  os dados  sao delimitados por aspas  e outro  caracter
                 qualquer  (geralmente virgula).  Se for escolhido este for-
                 mato, o  operador podera  informar  o delimitador  desejado
                 para satisfazer o  seu processador de texto.
    
                 EX.: "JOAO PEDRO","AV PASSOS,25","572-1111"
    
                 FORMATO SDF
                 Neste formato  (Standard Data Format  ou  Formato Padrao de
    Industria de Urnas Bignotto Ltda                                 PAG  28
    Administradora - RECEPCaO
    ------------------------------------------------------------------------

                 Dados) as informacoes sao gravadas sem delimitadores, sendo
                 identificados apenas pelos seus tamanhos.       E util para
                 transferir dados para serem manipulados por outras  lingua-
                 gens.
    
                 EX.: JOAO PEDROAV PASSOS,255721111
    
                 FORMATO DBF
                 Este  e o mesmo  formato que  se encontra  nos arquivos  de
                 dados. Esta opcao e util para se criar sub-conjuntos de ar-
                 quivo de dados manipulados pela aplicacao.
    
        . Z   permite a apuracao de  um total para a  coluna do cursor, para
              todos os registros contidos na consulta. Naturalmente se apli-
              ca somente para conteudos do tipo numericos.
    
        Em ambiente de REDE LOCAL, existem ainda duas teclas (+)  e (-) que
        servem para adiantar ou atrasar, em 5 segundos,  o tempo de atuali-
        zacao da tela de consulta, ou seja, o tempo utilizado pela  aplica-
        cao  para fazer o "refresh" da tela, de modo que os registros digi-
        tados ou atualizados pelos outros usuarios da rede possam  aparecer
        na sua tela de consulta. Este tempo e ajustado inicialmente para 25
        segundos.
    
        Com o tempo de utilizacao, o operador memorizara as opcoes existen-
        tes, nao precisando mais pressionar "F10" para ver o menu,  podendo
        apertar diretamente a letra inicial da opcao desejada.
    
        Ao abandonar as operacoes  em  "Consulta",  o usuario podera  gravar
        em disco esta consulta, identificando-a atraves de uma frase com ate
        58 caracteres.   Sempre que desejar  novamente esta mesma  consulta,
        basta selecionar esta frase atraves do menu de consultas, que apare-
        ce sempre que uma nova consulta e solicitada.
    
    Industria de Urnas Bignotto Ltda                                 PAG  29
    Administradora - RECEPCaO
    ------------------------------------------------------------------------












                                   gdbedit.t                                    













    
    
    Industria de Urnas Bignotto Ltda                                 PAG  30
    Administradora - RECEPCaO
    ------------------------------------------------------------------------

    EXTRACAO DE INFORMACoES
    
    
          Selecionada uma opcao de relatorio, a tela seguinte aparecera:
    











                                    opcrel.t                                    













    
    
          As opcoes disponiveis sao:
    
    
             PROSSEGUIR
    
             Selecionar esta opcao quando desejar iniciar a emissao do rela-
             torio que tiver sido selecionado.
    
    
             SAiDA
    
             Por esta opcao pode-se selecionar o dispositivo onde sera  emi-
             tido o relatorio. E apresentado um menu de onde pode  ser sele-
             cionada a impressora/porta de saida desejada. Outra opcao cons-
             tante neste menu e a emissao do relatorio em arquivo/video. En-
             tretanto, deve-se ter o cuidado  de configurar  primeiramente a
             impressora para uma eventual impressao posterior do relatorio.
    
    
             FILTRAR
    
    Industria de Urnas Bignotto Ltda                                 PAG  31
    Administradora - RECEPCaO
    ------------------------------------------------------------------------

             Esta opcao possibilita o agrupamento dos registros a serem con-
             siderados no relatorio, atraves do processo de filtragem expli-
             cado  anteriormente no topico "Consulta".
    
    
             CoPIAS
    
             Selecionada esta opcao,  a  aplicacao  solicita a informacao do
             numero de vezes  (originais)  que o relatorio deve ser emitido.
             Esta opcao so sera selecionavel quando o direcionamento (saida)
             do relatorio estiver ajustado para a impressora.
    
    
             ORDENAR
    
             Esta  opcao  permite ao  operador  determinar  uma ordem para a
             emissao,  em funcao de qualquer um dos campos do arquivo utili-
             zado.   O  processo  de  ordenacao  ja foi  explicado no topico
             "Consulta".
    
    
             TiTULO
    
             Permite  a entrada  de  um titulo para constar no cabecalho  do
             relatorio que esta para ser emitido.
    
    
          Apos emitir um relatorio, e possivel gravar as suas especificacoes
          em disco para que,   em uma futura emissao,  possa ser  ativado  a
          partir de um menu, a exemplo do que e feito com  as consultas fei-
          tas  atraves da opcao "Consultas", descritas neste manual.
    
    
    
    Industria de Urnas Bignotto Ltda                                 PAG  32
    Administradora - RECEPCaO
    ------------------------------------------------------------------------

    PROCESSAMENTO DE APOIO
    
        A opcao "Processamento de apoio" tem a finalidade principal de auxi-
    liar o usuario na administracao da aplicacao.   A partir  deste  modulo,
    podera fazer copias de seguranca,  recuperar  dados,  indexar  arquivos,
    eliminar definitivamente os registros dos arquivos, dentre outros.  Alem
    disso, diversas configuracoes podem ser feitas dentro deste modulo, para
    adaptar a aplicacao ao equipamento ou mudar o seu comportamento.
    











                                    apoio.t                                     













    
    
       BACKUP
    
       Esta opcao permite que o usuario copie  as  suas bases de  dados para
       disquetes ou subdiretorios, para assegurar a integridade das informa-
       coes manipuladas pela aplicacao.
    
       O sistema mostrara um menu para a selecao da letra do drive para  ser
       utilizado para as copias, onde ja devera ter um disquete  previamente
       formatado.
    
    Industria de Urnas Bignotto Ltda                                 PAG  33
    Administradora - RECEPCaO
    ------------------------------------------------------------------------












                                     back.t                                     













    
    
       Quando o sistema detectar que nao ha espaco suficiente no disco  para
       gravar arquivos, este solicitara a colocacao de mais  disquetes,  ate
       que todos os arquivos tenham sido copiados.    Portanto, se o usuario
       perceber que suas bases de dados ocupam espacos consideraveis, devera
       preparar previamente os disquetes devidamente formatados para receber
       a copia.
    
       Os disquetes utilizados na  criacao das  copias "backup" deverao  ser
       utilizados na mesma ordem, quando se desejar fazer a  restauracao dos
       arquivos. Para isto, o sistema grava em cada disquete um pequeno  ar-
       quivo de controle, para impedir a iversao de disquetes.
    
    
       RESTAURA BACKUP
    
       Esta opcao permite que o usuario recupere as suas bases  de dados,  a
       partir das copias de seguranca que  gerou na opcao anterior se,  por-
       ventura, os arquivos atuais foram perdidos ou danificados.
    
       Selecionada esta opcao, o sistema mostrara um menu de onde devera ser
       selecionado o drive a ser  utilizado para  a colocacao  dos disquetes
       que serao solicitados, durante o processo de restauracao.
    
    
       RECONSTRoI iNDICES
    
    Industria de Urnas Bignotto Ltda                                 PAG  34
    Administradora - RECEPCaO
    ------------------------------------------------------------------------

       Esta  opcao permite  que o usuario reconstrua os indices dos seus ar-
       quivos,  quando estes apresentarem  problemas  ocasionados geralmente
       por quedas  ou  "picos"  de energia.     Um sintoma  seguro de que um
       arquivo de indice nao esta funcionando bem,  e quando  se procura du-
       rante uma consulta um  registro sabidamente existente no arquivo e  a
       aplicacao nao consegue localiza-lo. Se notar algo semelhante, o usua-
       rio devera ativar esta opcao.
    
       Quando selecionada, esta opcao mostra uma janela com o nome das bases
       de dados disponiveis para indexacao de onde o usuario podera selecio-
       nar qual dos arquivos sera indexado.  Nesse momento o sistema emitira
       a mensagem "Classificando", enquanto efetua a indexacao.
    
    
       ELIMINA REGISTROS APAGADOS
    
       Esta opcao possibilita que o usuario efetue a eliminacao fisica e de-
       finitiva dos registros marcados para apagamento  durante as operacoes
       de consulta e alteracao.
    
       Quando selecionada, mostrara uma janela com o nome das bases de dados
       que  estao disponiveis para eliminacao de registros apagados, de onde
       o  usuario podera  selecionar com  qual base de dados deseja  operar.
       Nesse instante,  o sistema emitira a  mensagem  de advertencia que  a
       operacao podera ser demorada.  De fato, dependendo do tamanho da base
       de dados, a operacao podera demorar um pouco, razao pela qual o usua-
       rio deve escolher  o momento mais propicio para acionar esta opcao.
    
    
       Ve RELATORIO GRAVADO
    
    
       CONFIGURA AMBIENTE
    
       O usuario podera, atraves dessa tela, mudar o comportamento e aspecto
       da aplicacao:
    
    Industria de Urnas Bignotto Ltda                                 PAG  35
    Administradora - RECEPCaO
    ------------------------------------------------------------------------












                                   configs.t                                    













    
    
          MARCA DA IMPRESSORA
    
          Se,  por alguma razao,  a impressora conectada ao  micro  precisar
          ser substituida  por outra  de  caracteristicas  diferentes,  esta
          opcao podera ser utilizada para reconfigurar a nova impressora sem
          a necessidade de alteracoes nos programas fontes da aplicacao.
    
          Ao ser acionada esta opcao, a aplicacao apresenta um menu com  al-
          gumas impressoras mais comuns, para serem selecionadas.  Este menu
          permite  acrescentar  novas impressoras (tecla INS)  ou apagar im-
          pressoras existentes (tecla DEL).   Atraves da tecla ENTER pode-se
          selecionar e editar os codigos dessa impressora. Esses codigos de-
          vem estar de acordo com o especificado no manual do fabricante  da
          impressora.
    
    Industria de Urnas Bignotto Ltda                                 PAG  36
    Administradora - RECEPCaO
    ------------------------------------------------------------------------












                                   rconfimp.t                                   













    
    
          PANO DE FUNDO
    
          Selecione  atraves do menu  o caracter a ser utilizado para preen-
          cher a tela inicial da aplicacao,  sobre a qual  irao aparecer  as
          diversas  janelas de menu, mensagens e caixas de dialogo.
    
    
          FONTE DE CARACTERES
    
          Selecione o nome da fonte de caracteres para  carregar na  memoria
          do video. Selecionada uma fonte, todos os caracteres mostrados  na
          tela mudarao automaticamente.
    
    
          ESQUEMAS DE CORES
    
          Permite selecionar um novo esquema de cor  (frente/fundo)  para os
          seguintes objetos:
    
             Pano de fundo
    
             Caracter utilizado para preencher a  tela inicial da aplicacao,
             sobre a qual aparecem as diversas janelas de menu, mensagens  e
             caixas de dialogo.
    
             Janelas
    Industria de Urnas Bignotto Ltda                                 PAG  37
    Administradora - RECEPCaO
    ------------------------------------------------------------------------

    
             Retangulos onde aparecem as mensagens fixas da aplicacao.  Este
             esquema e tambem utilizado para apresentar a primeira janela da
             opcao "Consulta".
    
             Caixas de dialogo
    
             Janelas onde  as  informacoes solicitadas pela aplicacao  serao
             digitadas pelo operador.   Constam de um titulo,  mensagem   ao
             operador e um campo onde sao digitadas as informacoes solicita-
             das.  Este esquema  e  tambem utilizado para apresentar o cabe-
             calho e  rodape da tela da opcao "Consulta".
    
             Avisos e erros
    
             Janelas onde aparecem as mensagens de erros ou avisos ao opera-
             dor, durante a operacao da aplicacao.
    
             Menus e campos
    
             Janelas de menus de  onde sao  selecionadas as opcoes de opera-
             cao, bem como os campos onde sao digitadas as informacoes.
    
             Tela de digitacao
    
             Tela onde sao digitados os dados que  irao  para os arquivos de
             dados (linhas 6 a 21).   Este  esquema e tambem  utilizado para
             apresentar a segunda janela (quando houver) da opcao  "Consulta
             e faz projecoes".
    
             Tela de digitacao nao ativa
    
             Tela onde nao estao sendo digitados dados, no  caso de  existir
             outros arquivos relacionados.
    
             Tela de ajuda
    
             Tela onde e apresentado o texto de ajuda "on-line", sempre  que
             a tecla F1 e acionada.
    
    Industria de Urnas Bignotto Ltda                                 PAG  38
    Administradora - RECEPCaO
    ------------------------------------------------------------------------












                                   confcor.t                                    













    
    
          Para configurar um esquema de cor, proceda conforme a seguir:
    
             1. atraves do menu, selecione o esquema desejado;
    
             2. movimente  as  setas  (cima,  baixo, esquerda  e  direita) e
                observe o efeito na janela exemplo  intitulada  "EXEMPLO  DO
                ESQUEMA SELECIONADO". Observe que, as setas cima/baixo alte-
                ram a cor da  frente e as setas esquerda/direita  alteram  a
                cor do fundo. Utilize ainda a tecla CTRL simultaneamente com
                as setas esquerda/direita para mudar os titulos dos menus.
    
             3. Pressione a tecla ENTER quando a cor  do  exemplo estiver de
                acordo com o pretendido.
    
    
          DIREToRIO DE TRABALHO
    
          Esta opcao  permite a troca de diretorios onde irao residir os ar-
          quivos de dados e de indices manipulados pela aplicacao.     Neste
          caso, se o novo diretorio informado contiver arquivos  compativeis
          com a  aplicacao, estes serao utilizados e manipulados. Esta faci-
          lidade e bastante util quando se trabalha com dados  de  areas  ou
          empresas separadamente.
    
    
          CONFIRMA EM CAMPOS
    Industria de Urnas Bignotto Ltda                                 PAG  39
    Administradora - RECEPCaO
    ------------------------------------------------------------------------

    
          Ao operar o sistema, sempre que o  usuario estiver digitando algo,
          como por exemplo, incluindo registros, informando  nomes de arqui-
          vos, etc.,  quando o cursor chega ao final do campo,  a informacao
          nele digitada e aceita automaticamente, sem a necessidade de pres-
          sionar a tecla ENTER.
    
          Atraves dessa opcao, o usuario podera ligar  e desligar este efei-
          to, com abrangencia para toda a operacao do sistema.   Neste caso,
          se a  opcao "Confirma em campos" estiver assinalada, o usuario te-
          ra de apertar a tecla "ENTER" sempre que estiver entrando com  in-
          formacoes na aplicacao.
    
    
          CONFIRMA EXCLUSoES
    
          Durante  as  operacoes de alteracao de registros,  ao pressionar a
          tecla "E",  o  registro atualmente acessado e marcado para ser ex-
          cluido do arquivo de dados.    Se esta opcao estiver assinalada, o
          usuario tera de confirmar a exclusao do registro,  caso contrario,
          o registro sera  excluido automaticamente.
    
    
          CONFIRMA INCLUSOES
    
          Define se, apos a digitacao de um registro, uma tela sera apresen-
          tada solicitando uma confirmacao para a inclusao ou nao  do regis-
          tro no arquivo de dados.
    
    
          EXCLUIDOS VISIVEIS
    
          Define se os registros marcados para exclusao deverao ser  mostra-
          dos nas consultas.  Se esta opcao estiver marcada, esses registros
          poderao ser visualizados, caso contrario, ficarao ocultos.
    
    
          EFEITOS SONOROS
    
          Os efeitos sonoros  emitidos durante  a operacao da  aplicacao, na
          apresentacao de mensagens, etc, podem ser ligados  ou desligados a
          partir desta opcao.
    
    
          AJUDA ATIVA
    
          Quando a ajuda de campo estiver ativa, toda vez que estiver  digi-
          tando informacoes nos arquivos de dados um texto de ajuda  (se ti-
          ver sido preparado) aparecera em uma janela perto do  campo em di-
          gitacao, para orientar a entrada de dados.   Se esta opcao estiver
          desligada, esta ajuda nao aparecera.  A tecla ALT-F1 pode ser uti-
          lizada como "hot-key" para ligar e desligar esta opcao, de  dentro
          do proprio campo em digitacao.
    Industria de Urnas Bignotto Ltda                                 PAG  40
    Administradora - RECEPCaO
    ------------------------------------------------------------------------

    
    
          LIGA/DESLIGA MOUSE
    
          Serve para ligar e desligar a operacao da aplicacao com a utiliza-
          cao do mouse. Se estiver desligada, somente o teclado estara  dis-
          ponivel para operacao.
    
    
          SENSIBILIDADE DO MOUSE
    
          Para configurar a sensibilidade do mouse, basta "clicar"  sobre as
          setas esquerda e direita para mudar os valores da sensibilidade de
          movimento vertical e horizontal.    Quanto maior os valores, menor
          a sensibilidade, ou seja, o mouse necessita ser arrastado um espa-
          co maior para movimentar o cursor.
    
        Uma vez feitas as configuracoes, estas serao gravadas e mantidas pa-
        ra serem utilizadas em outras ocasioes.
    
    
    
       PLANO DE SENHAS
    
       Esta aplicacao esta provida de um plano de  senhas com 3 niveis  para
    cercear o acesso de operadores a qualquer de seus modulos. O usuario que
    tiver nivel de acesso 3 (gerencia), nao tera restricoes  dentro do  sis-
    tema, podendo inclusive credenciar operadores, descredenciar outros, mu-
    dar niveis de acesso e listar os operadores credenciados.
    
    Industria de Urnas Bignotto Ltda                                 PAG  41
    Administradora - RECEPCaO
    ------------------------------------------------------------------------












                                   masenhas.t                                   













    
    
       Atraves desta tela, os seguintes comandos estao disponiveis:
    
    
       . FILTRAGEM, serve para a selecao de registros a serem colocados nes-
         ta tela de consulta.
    
       . DIGITACAO, serve para o credenciamento de novos operadores no  Sis-
         tema.    Basta que seja informado o seu  nome, nivel de  acesso e a
         senha que usara para acessar a aplicacao.
    
       . MODIFICA, serve para modificar  as informacoes  existentes para  os
         operadores credenciados.
    
       . EXCLUI, serve para descredenciar um operador.    E a retirada de um
         operador da lista  de pessoas que podem acessar o Sistema.  Um ope-
         rador pode ser descredenciado, por um operador que tenha nivel  ge-
         rencia, mesmo que este desconheca a senha de acesso do operador.
    
       . RECUPERA, permite desfazer o processo anterior,  isto e,  recuperar
         as informacoes de um operador, caso seja necessario.
    
       . APAGA COLUNA DO CURSOR, serve para retirar desta tela, a coluna on-
         de o cursor esta posicionado.
    
       . IMPRIME A CONSULTA, serve para enviar para a impressora ou disco, o
         conteudo desta consulta.
    Industria de Urnas Bignotto Ltda                                 PAG  42
    Administradora - RECEPCaO
    ------------------------------------------------------------------------

    
       . ORDENA OS REGISTROS, permite a reordenacao dos registros, em funcao
         de determinado campo escolhido.
    
       . QUANTIFICA REGISTROS, serve para contar quantos registros estao fa-
         zendo parte desta consulta.
    
       . LOCALIZA permite a localizacao rapida de um determinado registro de
         operador.
    
       . CONGELA/DESCONGELA  colunas, permite  fixar na tela  as  colunas  a
         esquerda  do  cursor (inclusive)  preservando-as  de serem  roladas
         quando as setas forem utilizadas para a rolagem horizontal.
    
       . TAMANHO, permite alterar o tamanho da coluna onde o cursor esta es-
         tacionado.
    
    
       Alem dos niveis globais, o sistema permite um cerceamento mais apura-
       do, a nivel de rotina, por arquivo da aplicacao,  proporcionando  uma
       flexibilidade muito grande.  Isto significa que e possivel credenciar
       dois usuarios na aplicacao com mesmo nivel, porem com permissoes  di-
       ferentes para as rotinas que acessam cada arquivo de dados. O contro-
       le de rotinas e feito da seguinte maneira:      ao credenciar um novo
       usuario, alem do nivel global de acesso, pode-se informar um conjunto
       de caracteres para cada  um dos arquivos do sistema,  que  controla a
       edicao do arquivo.   Este conjunto sera vinculado a senha deste usua-
       rio. Cada caracter componente deste conjunto corresponde a  letra  da
       opcao da rotina que o  usuario credenciado  NAO PODERA ACESSAR,  PARA
       AQUELE ARQUIVO. Essas rotinas sao:
    
                       P. Procura           F. Filtragem       
                       D. Digitacao         M. Modifica        
                       E. Exclui            R. Recupera        
                       V. Ve global         N. Nova coluna     
                       A. Apaga coluna      I. Imprime consulta
                       O. Ordena            Q. Quantifica      
                       L. Localiza          G. Global          
                       C. Congela colunas   T. Tamanho         
                       J. abre nova Janela  X. eXporta dados   
                       Z. totaliZa coluna
    
       Assim, um usuario credenciado na aplicacao ao qual tenha sido  vincu-
       lado o conjunto de caracteres "DEOFNZ" para  um determinado  arquivo,
       nao tem acesso as rotinas que comecam com essas  letras nos  menus de
       opcoes que manipulam  este arquivo,  ou seja, nao Digita, nao Exclui,
       nao Ordena, nao Filtra, nao abre Novas colunas nem totaliZa  colunas,
       no arquivo  especifico, embora em outros  arquivos, possa  ter acesso
       pleno.
    
    Industria de Urnas Bignotto Ltda                                 PAG   1
    Administradora - RECEPCaO
    ------------------------------------------------------------------------

                                * I N D I C E *                                 

             ASSUNTO                                          PAG
             ----------------------------------------------------
             CONFIGURA€ŽO DOS DIRET¢RIOS DE TRABALHO..........  3
             ENTRADA DA SENHA DE ACESSO.......................  5
             MENU GERAL DO SISTEMA............................  6
             MANUTEN€ŽO DAS INFORMA€™ES.......................  9
             ENTRADA DE DADOS................................. 10
             ALTERA€ŽO/EXCLUSŽO DE REGISTROS.................. 12
             CONSULTA (TELA PAGINADA)......................... 18
             EXTRA€ŽO DE INFORMA€”ES.......................... 30
             PROCESSAMENTO DE APOIO........................... 32
procedure adr_r068
/*
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
 \ Empresa.: PresServ Inform tica - Limeira (019)452.6623
 \ Programa: ADR_R068.PRG
 \ Data....: 21-01-99
 \ Sistema.: Administradora - RECEP€„O
 \ Funcao..: Resumo de Recebimento
 \ Analista: Ademilson Pedro Bom
 \ Criacao.: GAS-Pro v3.0 
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/

#include "adrbig.ch"    // inicializa constantes manifestas

LOCAL dele_atu, getlist:={},lindet:=[]
PARA  lin_menu, col_menu
PRIV  tem_borda:=.t., op_menu:=VAR_COMPL, l_s:=9, c_s:=20, l_i:=15, c_i:=61, tela_fundo:=SAVESCREEN(0,0,MAXROW(),79)
nucop=1
SETCOLOR(drvtittel)
vr_memo=NOVAPOSI(@l_s,@c_s,@l_i,@c_i)     // pega posicao atual da tela
CAIXA(mold,l_s,c_s,l_i,c_i)               // monta caixa da tela
@ l_s,c_s+10 SAY " RESUMO DE RECEBIMENTO "
SETCOLOR(drvcortel)
@ l_s+01,c_s+1 SAY " De:......:"
@ l_s+02,c_s+1 SAY " At‚:.....:"
@ l_s+03,c_s+1 SAY " Analitico:"
@ l_s+04,c_s+1 SAY " Filtragem:"
@ l_s+05,c_s+1 SAY " Confirme.:"
rde=CTOD('')                                       // De:
rate=CTOD('')                                      // At‚:
analit=SPAC(1)                                     // Analitico
rfiltr=space(50)
confirme=SPAC(1)                                   // Confirme
DO WHILE .t.
 rola_t=.f.
 cod_sos=56
 SET KEY K_ALT_F8 TO ROLATELA
 SETCOLOR(drvcortel+","+drvcorget+",,,"+corcampo)
 @ l_s+01 ,c_s+13 GET  rde;
                  PICT "@D";
                  VALI CRIT("!EMPT(rde)~Necess rio informar a data inicial a considerar")
                  DEFAULT "DATE()-DAY(DATE())+1"
                  AJUDA "Informe a data inicial a considerar"

 @ l_s+02 ,c_s+13 GET  rate;
                  PICT "@D";
                  VALI CRIT("!EMPT(rate)~Necess rio informar AT:")
                  DEFAULT "DATE()"
                  AJUDA "Informe a data final a considerar"

 @ l_s+03 ,c_s+13 GET  analit;
                  PICT "!";
                  VALI CRIT("analit$[SN]~ANALITICO n„o aceit vel|Digite S ou N")
                  DEFAULT "[N]"
                  AJUDA "Digite [S] para anal¡tico|ou N para totais"

 @ l_s+04 ,c_s+13 GET  rfiltr;
                  PICT "@KS20!"
                  AJUDA "Digite a condicao nescessaria|no contrato para ser impresso|Deixe sem preencher para todos"
                  DEFAULT "MEN_01F9()"

 @ l_s+05 ,c_s+13 GET  confirme;
                  PICT "!";
                  VALI CRIT("confirme= 'S'~CONFIRME n„o aceit vel|Digite S ou Tecle ESC")
                  AJUDA "Digite S para confirmar |ou|Tecle ESC para cancelar"

 READ
 SET KEY K_ALT_F8 TO
 IF rola_t
  ROLATELA(.f.)
  LOOP
 ENDI
 IF LASTKEY()=K_ESC                                // se quer cancelar
  RETU                                             // retorna
 ENDI

 #ifdef COM_REDE
  IF !USEARQ("BXREC",.f.,10,1)                     // se falhou a abertura do arq
   RETU                                            // volta ao menu anterior
  ENDI
 #else
  USEARQ("BXREC")                                  // abre o dbf e seus indices
 #endi

 IF !EMPT(rfiltr)
  PTAB(codigo,[GRUPOS],1)
  SET RELA TO codigo INTO grupos
 ENDI

 titrel:=criterio := ""                            // inicializa variaveis
 cpord="DTOS(emitido_)+codigo"
 titrel:=chv_rela:=chv_1:=chv_2 := ""
 tps:=op_x:=ccop := 1
 IF !opcoes_rel(lin_menu,col_menu,23,11)           // nao quis configurar...
  CLOS ALL                                         // fecha arquivos e
  LOOP                                             // volta ao menu
 ENDI
 IF tps=2                                          // se vai para arquivo/video
  arq_=ARQGER()                                    // entao pega nome do arquivo
  IF EMPTY(arq_)                                   // se cancelou ou nao informou
   LOOP                                            // retorna
  ENDI
 ELSE
  arq_=drvporta                                    // porta de saida configurada
 ENDI
 SET PRINTER TO (arq_)                             // redireciona saida
 EXIT
ENDD
rcond=LEFT(rfiltr,AT("~",rfiltr)-1)               // condicao de validacao
DBOX("[ESC] Interrompe",15,,,NAO_APAGA)
dele_atu:=SET(_SET_DELETED,.t.)                    // os excluidos nao servem...
SET DEVI TO PRIN                                   // inicia a impressao
maxli=62                                           // maximo de linhas no relatorio
BEGIN SEQUENCE
 DO WHIL ccop<=nucop                               // imprime qde copias pedida
  pg_=1; cl=999
  INI_ARQ()                                        // acha 1o. reg valido do arquivo
  ccop++                                           // incrementa contador de copias
  tot040004 := 0                                   // inicializa variaves de totais
  qqu040=0                                         // contador de registros
  DO WHIL !EOF()
   #ifdef COM_TUTOR
    IF IN_KEY()=K_ESC                              // se quer cancelar
   #else
    IF INKEY()=K_ESC                               // se quer cancelar
   #endi
    IF canc()                                      // pede confirmacao
     BREAK                                         // confirmou...
    ENDI
   ENDI
   IF emitido_>=M->rde.and.emitido_<=M->rate       // se atender a condicao...

    IF !EMPT(rcond) // Se pediu filtragem do contrato, verifica...
     SELE GRUPOS
     IF !(&rcond.)    // Se nao for verdadeiro, tchau ...
      SELE BXREC
      SKIP
      LOOP
     ENDI
    ENDI
    SELE BXREC
    IF analit = [S]
     REL_CAB(2)                                     // soma cl/imprime cabecalho
     @ cl,000 SAY [Dia: ]+DTOC(emitido_)                  // titulo da quebra
     REL_CAB(1)                                     // soma cl/imprime cabecalho
    ELSE
     lindet:=[Dia: ]+DTOC(emitido_)
    ENDI
    qb04001=emitido_                               // campo para agrupar 1a quebra
    st04001004 := 0                                // inicializa sub-totais
    qqu04001=0                                     // contador de registros
    DO WHIL !EOF() .AND. emitido_=qb04001
     #ifdef COM_TUTOR
      IF IN_KEY()=K_ESC                            // se quer cancelar
     #else
      IF INKEY()=K_ESC                             // se quer cancelar
     #endi
      IF canc()                                    // pede confirmacao
       BREAK                                       // confirmou...
      ENDI
     ENDI
     IF emitido_>=M->rde.and.emitido_<=M->rate     // se atender a condicao...

    IF !EMPT(rcond) // Se pediu filtragem do contrato, verifica...
     SELE GRUPOS
     IF !(&rcond.)    // Se nao for verdadeiro, tchau ...
      SELE BXREC
      SKIP
      LOOP
     ENDI
    ENDI
    SELE BXREC

      IF ANALIT=[S]
       lindet+=TRAN(numero,"999999")+[ ]+;
               TRAN(codigo,"999999")+[ ]+;
               tipo+[-]+circ+[ ]+;
               TRAN(valorpg,"@E 9,999.99")+[ | ]   // Valor pago
       IF LEN(lindet)>110
        REL_CAB(1)                                   // soma cl/imprime cabecalho
        IMPCTL(drvpcom)
        @ cl,000 SAY lindet           // Numero
        IMPCTL(drvtcom)
        lindet:=[]
       ENDI
      ENDI
      st04001004+=valorpg
      tot040004+=valorpg
      qqu04001++                                   // soma contadores de registros
      qqu040++                                     // soma contadores de registros
      SKIP                                         // pega proximo registro
     ELSE                                          // se nao atende condicao
      SKIP                                         // pega proximo registro
     ENDI
    ENDD

    IF LEN(lindet)>0
     REL_CAB(1)                                   // soma cl/imprime cabecalho
     IMPCTL(drvpcom)
     @ cl,000 SAY lindet           // Numero
     IMPCTL(drvtcom)
     lindet:=[]
    ENDI

    IF analit = [S]
     @ ++cl,020 SAY REPL('-',10)
     cl++
    ENDI
    @ cl,020 SAY TRAN(qqu04001,"@E 999,999")
    @ cl,030 SAY TRAN(st04001004,"@E 999,999.99")// sub-tot Valor pago
   ELSE                                            // se nao atende condicao
    SKIP                                           // pega proximo registro
   ENDI
  ENDD
  IF cl+3>maxli                                    // se cabecalho do arq filho
   REL_CAB(0)                                      // nao cabe nesta pagina
  ENDI                                             // salta para a proxima pagina
  @ ++cl,020 SAY REPL('-',10)
  @ ++cl,020 SAY [R$ ]+LTRIM(TRAN(tot040004,"@E 999,999.99"))+[ em ]+;
    LTRIM(TRAN(qqu040,"@E 999,999"))+[ recebimentos]+;
    [ entre ]+DTOC(M->rde)+[ e ]+DTOC(M->rate)+[.]
 ENDD ccop
 EJEC                                              // salta pagina
END SEQUENCE
SET PRINTER TO (drvporta)                          // fecha arquivo gerado (se houver)
SET DEVI TO SCRE                                   // direciona saida p/ video
IF tps=2                                           // se vai para arquivo/video
 BROWSE_REL(arq_,2,3,MAXROW()-2,78)
ENDI                                               // mostra o arquivo gravado
GRELA(23)                                          // grava variacao do relatorio
SET(_SET_DELETED,dele_atu)                         // os excluidos serao vistos
RETU

STATIC PROC REL_CAB(qt)                            // cabecalho do relatorio
IF qt>0                                            // se parametro maior que 0
 cl=cl+qt                                          // soma no contador de linhas
ENDI
IF cl>maxli .OR. qt=0                              // quebra de pagina
 IMPAC(nemp,0,000)                                 // nome da empresa
 @ 0,070 SAY "PAG"
 @ 0,074 SAY TRAN(pg_,'9999')                      // n£mero da p gina
 IMPAC(nsis,1,000)                                 // t¡tulo aplica‡„o
 @ 1,070 SAY "ADR_R068"                            // c¢digo relat¢rio
 @ 2,000 SAY "RESUMO DE RECEBIMENTO"
 @ 2,024 SAY IIF(EMPT(rfiltr),titrel,rfiltr)                                // t¡tulo a definir
 @ 2,060 SAY NSEM(DATE())                          // dia da semana
 @ 2,068 SAY DTOC(DATE())                          // data do sistema
 @ 3,000 SAY "Numero Contrato Circ  Valor pago   ("+DTOC(M->rde)+[ e ]+DTOC(M->rate)+[)]
 @ 4,000 SAY REPL("-",78)
 cl=qt+4 ; pg_++
ENDI
RETU

* \\ Final de ADR_R068.PRG
FUNC MEN_01F9()
sit_dbf:=POINTER_DBF()
crit_ant:=criterio
auxiliar=space(210)
PTAB([],[GRUPOS],1,.T.)
SELE GRUPOS
filtra(.F.)
auxiliar=criterio+[~TRUE]
criterio :=crit_ant
POINTER_DBF(sit_dbf)
RETU auxiliar       // <- deve retornar um valor qualquer

* \\ Final de MEN_01F9.PRG
procedure adr_atr3
/*
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
 \ Empresa.: Ind£stria de Urnas Bignotto Ltda
 \ Programa: ADR_ATR3.PRG
 \ Data....: 01-05-98
 \ Sistema.: Administradora - RECEP€„O
 \ Funcao..: Define atributos dos arquivos (sistema[])
 \ Analista: Ademilson Pedro Bom
 \ Criacao.: GAS-Pro v3.0 
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/

#include "adrbig.ch"    // inicializa constantes manifestas


sistema[33]={;
            "Mensagem p/Contrato",;                         // opcao do menu
            "Mensagem p/Contrato",;                         // titulo do sistema
            {"seq","codigo"},;                              // chaves do arquivo
            {"Sequencia","Contrato"},;                      // titulo dos indices para consulta
            {"01","02"},;                                   // ordem campos chaves
            "MENSAG",;                                      // nome do DBF
            {"MENSAG1","MENSAG2"},;                         // nomes dos NTX
            {},;                                            // nome dos dbf's relacionados
            {},;                                            // campos de relacionamento
            {1,1,9,13,14,67},;                              // num telas/tela atual/coordenadas
            {0,.t.},;                                       // nivel acesso/tp chave
            {},;                                            // campos do arquivo
            {},;                                            // formula mostradas
            {"",""},;                                       // condicao de exclusao de registros
            {"",""},;                                       // condicao de alteracao de registros
            {"",""};                                        // condicao de recupercao de registros
           }

AADD(sistema[33,O_CAMPO],{;            // MENSAG
     /* mascara       */    "999999",;
     /* titulo        */    "Seq",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "V",;
     /* help do campo */    "";
                         };
)
AADD(sistema[33,O_CAMPO],{;            // MENSAG
     /* mascara       */    "999999",;
     /* titulo        */    "Codigo",;
     /* cmd especial  */    "VDBF(6,26,20,77,'GRUPOS',{'grupo','codigo','nome'},1,'codigo')",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "PTAB(codigo,'GRUPOS',1)~Contrato cancelado |ou inexistente",;
     /* help do campo */    "Informe o n£mero do contrato";
                         };
)
AADD(sistema[33,O_CAMPO],{;            // MENSAG
     /* mascara       */    "",;
     /* titulo        */    "Mens1",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(mens1)~Necess rio informar a primeira linha de mensagen|Tecle ESC para cancelar.",;
     /* help do campo */    "Informe a mensagem a imprimir na cobran‡a|Vocˆ tem trˆs linhas com at‚ 80 caracteres.";
                         };
)
AADD(sistema[33,O_CAMPO],{;            // MENSAG
     /* mascara       */    "@D",;
     /* titulo        */    "Lan‡amento",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[33,O_CAMPO],{;            // MENSAG
     /* mascara       */    "",;
     /* titulo        */    "Por",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[33,O_FORMULA],{;          // MENSAG - Nome
     /* form mostrar  */    "LEFT(TRAN(GRUPOS->nome,[]),35)",;
     /* lin da formula*/    2,;
     /* col da formula*/    18;
                         };
)
AADD(sistema[33,O_FORMULA],{;          // MENSAG - Lan‡amento
     /* form mostrar  */    "LEFT(TRAN(lancto_,[@D]),08)",;
     /* lin da formula*/    1,;
     /* col da formula*/    33;
                         };
)
AADD(sistema[33,O_FORMULA],{;          // MENSAG - Por
     /* form mostrar  */    "LEFT(TRAN(por,[]),10)",;
     /* lin da formula*/    1,;
     /* col da formula*/    42;
                         };
)


sistema[34]={;
            "Pgtos / Recebtos",;                            // opcao do menu
            "Ordens Pgto/Recto",;                           // titulo do sistema
            {"numop","numconta+historico+DTOS(fechto_)","codlan"},;// chaves do arquivo
            {"p/N£mero","p/Conta","Cod.Lanc"},;             // titulo dos indices para consulta
            {"01","050613","19"},;                          // ordem campos chaves
            "ORDPGRC",;                                     // nome do DBF
            {"ORDPGRC1","ORDPGRC2","ORDPGRC3"},;            // nomes dos NTX
            {},;                                            // nome dos dbf's relacionados
            {},;                                            // campos de relacionamento
            {1,1,7,12,20,71},;                              // num telas/tela atual/coordenadas
            {3,.t.},;                                       // nivel acesso/tp chave
            {},;                                            // campos do arquivo
            {},;                                            // formula mostradas
            {"",""},;                                       // condicao de exclusao de registros
            {"",""},;                                       // condicao de alteracao de registros
            {"",""};                                        // condicao de recupercao de registros
           }

AADD(sistema[34,O_CAMPO],{;            // ORDPGRC
     /* mascara       */    "999999",;
     /* titulo        */    "N§ O.P.",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(numop)~Necess rio informar N§ O.P.",;
     /* help do campo */    "";
                         };
)
AADD(sistema[34,O_CAMPO],{;            // ORDPGRC
     /* mascara       */    "!!!",;
     /* titulo        */    "Origem",;
     /* cmd especial  */    "MTAB([ADMinistradora|FUNer ria|CONvenio|ESToque|FINanceiro|VIAtura],[ORIGEM])",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "origem $ [ADM|FUN|CON|EST|FIN|VIA]~ORIGEM n„o aceit vel",;
     /* help do campo */    "Informe o prefixo do sistema que|gerou o lan‡amento";
                         };
)
AADD(sistema[34,O_CAMPO],{;            // ORDPGRC
     /* mascara       */    "@D",;
     /* titulo        */    "Lancto_",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "V",;
     /* help do campo */    "";
                         };
)
AADD(sistema[34,O_CAMPO],{;            // ORDPGRC
     /* mascara       */    "",;
     /* titulo        */    "Por",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "V",;
     /* help do campo */    "";
                         };
)
AADD(sistema[34,O_CAMPO],{;            // ORDPGRC
     /* mascara       */    "@!",;
     /* titulo        */    "Conta",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(numconta)~Campo obrigat¢rio!|Identifique a Conta/Cadastro com um n£mero | ou nome qualquer.",;
     /* help do campo */    "Informe a conta que receber  este lan‡amento.";
                         };
)
AADD(sistema[34,O_CAMPO],{;            // ORDPGRC
     /* mascara       */    "999",;
     /* titulo        */    "Hist¢rico",;
     /* cmd especial  */    "VDBF(6,24,20,77,'HISTORIC',{'historico','descricao','tipo'},1,'historico',[HISTORIC->origem$']+origem+[   '])",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "EMPT(historico).OR.PTAB(historico,'HISTORIC',1)~HIST¢RICO n„o existe na tabela",;
     /* help do campo */    "Informe o hist¢rico do lan‡amento.";
                         };
)
AADD(sistema[34,O_CAMPO],{;            // ORDPGRC
     /* mascara       */    "!",;
     /* titulo        */    "D‚b/Cr‚d",;
     /* cmd especial  */    "MTAB([D‚bito|Cr‚dito],[DB/CRD])",;
     /* default       */    "HISTORIC->tipo",;
     /* pre-validacao */    "",;
     /* validacao     */    "debcred$[CD]~Necess rio informar DB/CRD",;
     /* help do campo */    "Se for um documento a pagar ser  D, sen„o C";
                         };
)
AADD(sistema[34,O_CAMPO],{;            // ORDPGRC
     /* mascara       */    "99999999.99",;
     /* titulo        */    "Valor Lan‡amento",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "!(VALORtotal<0.00)~VALOR TOTAL DO LAN€AMENTO| deve ser positivo ou zeros",;
     /* help do campo */    "Entre com o valor total do documento,|se valor = zero, ser  apenas agendado.";
                         };
)
AADD(sistema[34,O_CAMPO],{;            // ORDPGRC
     /* mascara       */    "@D",;
     /* titulo        */    "Vencto",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(vencto_)~Necess rio informar VENCTO",;
     /* help do campo */    "Entre com a data do vencimento deste.";
                         };
)
AADD(sistema[34,O_CAMPO],{;            // ORDPGRC
     /* mascara       */    "@!",;
     /* titulo        */    "Documento",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPTY(documento)~Digite algo para identificar o documento",;
     /* help do campo */    "Entre com o n£mero do documento";
                         };
)
AADD(sistema[34,O_CAMPO],{;            // ORDPGRC
     /* mascara       */    "99999",;
     /* titulo        */    "N§Doctos",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "!(nrdoctos<0)~N§DOCTOS n„o aceit vel",;
     /* help do campo */    "";
                         };
)
AADD(sistema[34,O_CAMPO],{;            // ORDPGRC
     /* mascara       */    "@!",;
     /* titulo        */    "Complemento de Hist¢rico",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(complement)~Entre com uma informa‡„o que diferencie este|lan‡amento de outros com mesmo hist¢rico.",;
     /* help do campo */    "";
                         };
)
AADD(sistema[34,O_CAMPO],{;            // ORDPGRC
     /* mascara       */    "@D",;
     /* titulo        */    "Fechto",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "V",;
     /* help do campo */    "";
                         };
)
AADD(sistema[34,O_CAMPO],{;            // ORDPGRC
     /* mascara       */    "",;
     /* titulo        */    "Fechpor",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "V",;
     /* help do campo */    "";
                         };
)
AADD(sistema[34,O_CAMPO],{;            // ORDPGRC
     /* mascara       */    "@D",;
     /* titulo        */    "Autorizado em",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "V",;
     /* help do campo */    "";
                         };
)
AADD(sistema[34,O_CAMPO],{;            // ORDPGRC
     /* mascara       */    "",;
     /* titulo        */    "Autorizado",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "V",;
     /* help do campo */    "";
                         };
)
AADD(sistema[34,O_CAMPO],{;            // ORDPGRC
     /* mascara       */    "9999999",;
     /* titulo        */    "Lan‡amento N§",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "V",;
     /* help do campo */    "";
                         };
)
AADD(sistema[34,O_CAMPO],{;            // ORDPGRC
     /* mascara       */    "99999999",;
     /* titulo        */    "Num.Lan‡amento",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[34,O_CAMPO],{;            // ORDPGRC
     /* mascara       */    "!!!-99999999-999-999",;
     /* titulo        */    "Cod.Lan‡amento",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[34,O_FORMULA],{;          // ORDPGRC - Descri‡„o de Hi
     /* form mostrar  */    "LEFT(TRAN(HISTORIC->descricao,[]),40)",;
     /* lin da formula*/    5,;
     /* col da formula*/    17;
                         };
)


sistema[35]={;
            "Parƒmetros",;                                  // opcao do menu
            "Parƒmetros do sistema",;                       // titulo do sistema
            {},;                                            // chaves do arquivo
            {},;                                            // titulo dos indices para consulta
            {},;                                            // ordem campos chaves
            "PAR_ADM",;                                     // nome do DBF
            {},;                                            // nomes dos NTX
            {},;                                            // nome dos dbf's relacionados
            {},;                                            // campos de relacionamento
            {1,1,2,8,23,71},;                               // num telas/tela atual/coordenadas
            {2,.f.},;                                       // nivel acesso/tp chave
            {},;                                            // campos do arquivo
            {},;                                            // formula mostradas
            {"",""},;                                       // condicao de exclusao de registros
            {"",""},;                                       // condicao de alteracao de registros
            {"",""};                                        // condicao de recupercao de registros
           }

AADD(sistema[35,O_CAMPO],{;            // PAR_ADM
     /* mascara       */    "!!",;
     /* titulo        */    "Grupo",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "V",;
     /* help do campo */    "";
                         };
)
AADD(sistema[35,O_CAMPO],{;            // PAR_ADM
     /* mascara       */    "@!",;
     /* titulo        */    "C¢digo",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    "Informe o c¢digo da filial";
                         };
)
AADD(sistema[35,O_CAMPO],{;            // PAR_ADM
     /* mascara       */    "999999",;
     /* titulo        */    "Codigo",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "V",;
     /* help do campo */    "";
                         };
)
AADD(sistema[35,O_CAMPO],{;            // PAR_ADM
     /* mascara       */    "9",;
     /* titulo        */    "Inscr.",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "V",;
     /* help do campo */    "";
                         };
)
AADD(sistema[35,O_CAMPO],{;            // PAR_ADM
     /* mascara       */    "99",;
     /* titulo        */    "Seq",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "V",;
     /* help do campo */    "";
                         };
)
AADD(sistema[35,O_CAMPO],{;            // PAR_ADM
     /* mascara       */    "!",;
     /* titulo        */    "Verificar Pagas?",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[35,O_CAMPO],{;            // PAR_ADM
     /* mascara       */    "!",;
     /* titulo        */    "Repetir lan‡amento?",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[35,O_CAMPO],{;            // PAR_ADM
     /* mascara       */    "999999",;
     /* titulo        */    "Maior Contrato",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[35,O_CAMPO],{;            // PAR_ADM
     /* mascara       */    "999999",;
     /* titulo        */    "N£mero",;
     /* cmd especial  */    "",;
     /* default       */    "000000",;
     /* pre-validacao */    "",;
     /* validacao     */    "V",;
     /* help do campo */    "";
                         };
)
AADD(sistema[35,O_CAMPO],{;            // PAR_ADM
     /* mascara       */    "999999",;
     /* titulo        */    "Nrreint",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "V",;
     /* help do campo */    "";
                         };
)
AADD(sistema[35,O_CAMPO],{;            // PAR_ADM
     /* mascara       */    "@!",;
     /* titulo        */    "Conta Recepcao",;
     /* cmd especial  */    "",;
     /* default       */    "[RECEP]",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(contarec)~Necess rio informar CONTA RECEPCAO p/recebimentos",;
     /* help do campo */    "Informe a Conta que receber |os lan‡amentos da recep‡„o.";
                         };
)
AADD(sistema[35,O_CAMPO],{;            // PAR_ADM
     /* mascara       */    "@!",;
     /* titulo        */    "Conta Pagamento",;
     /* cmd especial  */    "",;
     /* default       */    "[RECEP]",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(contapag)~Necess rio informar CONTA RECEPCAO p/Pagamentos",;
     /* help do campo */    "Informe a Conta que pagar |os lan‡amentos da recep‡„o.";
                         };
)
AADD(sistema[35,O_CAMPO],{;            // PAR_ADM
     /* mascara       */    "999",;
     /* titulo        */    "Hist¢rico",;
     /* cmd especial  */    "VDBF(6,24,20,77,'HISTORIC',{'historico','descricao','tipo'},1,'historico',[HISTORIC->origem$'ADM   '])",;
     /* default       */    "[001]",;
     /* pre-validacao */    "",;
     /* validacao     */    "histrcfcc=[000].OR. PTAB(histrcfcc,'HISTORIC',1)~HIST¢RICO n„o existe na tabela",;
     /* help do campo */    "Informe o hist¢rico do lan‡amento de|recebimento de FCC.";
                         };
)
AADD(sistema[35,O_CAMPO],{;            // PAR_ADM
     /* mascara       */    "999",;
     /* titulo        */    "Hist¢rico",;
     /* cmd especial  */    "VDBF(6,24,20,77,'HISTORIC',{'historico','descricao','tipo'},1,'historico',[HISTORIC->origem$'ADM   '])",;
     /* default       */    "[002]",;
     /* pre-validacao */    "",;
     /* validacao     */    "histrcrec=[000].OR. PTAB(histrcrec,'HISTORIC',1)~HIST¢RICO n„o existe na tabela",;
     /* help do campo */    "Informe o hist¢rico do lan‡amento|para taxas recebidas na Recep‡„o.";
                         };
)
AADD(sistema[35,O_CAMPO],{;            // PAR_ADM
     /* mascara       */    "999",;
     /* titulo        */    "Hist¢rico",;
     /* cmd especial  */    "VDBF(6,24,20,77,'HISTORIC',{'historico','descricao','tipo'},1,'historico',[HISTORIC->origem$'ADM   '])",;
     /* default       */    "[004]",;
     /* pre-validacao */    "",;
     /* validacao     */    "histrccar=[000].OR. PTAB(histrccar,'HISTORIC',1)~HIST¢RICO n„o existe na tabela",;
     /* help do campo */    "Informe o hist¢rico do lan‡amento|para parcelas recebidas na Recep‡„o.";
                         };
)
AADD(sistema[35,O_CAMPO],{;            // PAR_ADM
     /* mascara       */    "999",;
     /* titulo        */    "Hist¢rico",;
     /* cmd especial  */    "VDBF(6,24,20,77,'HISTORIC',{'historico','descricao','tipo'},1,'historico',[HISTORIC->origem$'ADM   '])",;
     /* default       */    "[003]",;
     /* pre-validacao */    "",;
     /* validacao     */    "histpg=[000].OR. PTAB(histpg,'HISTORIC',1)~HIST¢RICO n„o existe na tabela",;
     /* help do campo */    "Informe o hist¢rico|para lan‡amento de pagamentos.";
                         };
)
AADD(sistema[35,O_CAMPO],{;            // PAR_ADM
     /* mascara       */    "@R 99-999999",;
     /* titulo        */    "N§ Recibo",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(nrauxrec)~Necess rio informar N§ RECIBO",;
     /* help do campo */    "Informe o n£mero do recibo a imprimir.|no formato AA-NNNNNN|onde: AA=Ano, N=n£mero";
                         };
)
AADD(sistema[35,O_CAMPO],{;            // PAR_ADM
     /* mascara       */    "999999",;
     /* titulo        */    "Codigo",;
     /* cmd especial  */    "VDBF(6,26,20,77,'GRUPOS',{'grupo','codigo','nome'},1,'codigo',[situacao=1])",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "PTAB(mcodigo,'GRUPOS',1).AND.PTAB(mcodigo,'TAXAS',1).OR.mcodigo=[00000]~C¢digo inv lido ou sem Taxas pendentes",;
     /* help do campo */    "Informe o n£mero do contrato";
                         };
)
AADD(sistema[35,O_CAMPO],{;            // PAR_ADM
     /* mascara       */    "!",;
     /* titulo        */    "Tipo",;
     /* cmd especial  */    "MTAB([1=J¢ia|2=Taxa|3=Carnˆ|6=J¢ia+Seguro|7=Taxa+Seguro|8=Carnˆ+Seguro],[TIPO])",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "mtipo $ [123678]~TIPO n„o aceit vel",;
     /* help do campo */    "Qual o tipo de lan‡amento";
                         };
)
AADD(sistema[35,O_CAMPO],{;            // PAR_ADM
     /* mascara       */    "999",;
     /* titulo        */    "Circular",;
     /* cmd especial  */    "VDBF(6,22,20,77,'TAXAS',{'codigo','circ','emissao_','valor','valorpg','forma'},1,'circ',[])",;
     /* default       */    "",;
     /* pre-validacao */    "!(mcodigo=[00000])",;
     /* validacao     */    "PTAB(mcodigo+mcirc,'TAXAS',1).AND.PTAB(GRUPOS->grupo+mcirc,'CIRCULAR',1)~Necess rio informar CIRCULAR existente",;
     /* help do campo */    "N£mero da Circular|Mantido pela emissao de recibos";
                         };
)
AADD(sistema[35,O_CAMPO],{;            // PAR_ADM
     /* mascara       */    "!!",;
     /* titulo        */    "Grup",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "EMPT(mgrupvip).OR.PTAB(mgrupvip,'ARQGRUP',1)~GRUP n„o existe na tabela",;
     /* help do campo */    "Entre com o c¢digo do Grupo que ser  utilizado|como controle dos contratos VIPs.";
                         };
)
AADD(sistema[35,O_CAMPO],{;            // PAR_ADM
     /* mascara       */    "!",;
     /* titulo        */    "Combarra",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "combarra$'SN '~COMBARRA n„o aceit vel|Digite S ou N",;
     /* help do campo */    "Informe se os recibos devem ser impressos|com o c¢digo de barras";
                         };
)
AADD(sistema[35,O_CAMPO],{;            // PAR_ADM
     /* mascara       */    "!",;
     /* titulo        */    "Com Inscritos",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "cinscr$'SN '~Digite S ou N",;
     /* help do campo */    "Informe se os Inscritos estÆo cadastrados";
                         };
)
AADD(sistema[35,O_CAMPO],{;            // PAR_ADM
     /* mascara       */    "!",;
     /* titulo        */    "Com Recibo",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "comfalec$'SN '~Digite S para imprimir recibos| ou| N para utilizar autenticac„o.",;
     /* help do campo */    "Informe se a recep‡Æo utiliza recibo|ou|autentica‡Æo";
                         };
)
AADD(sistema[35,O_CAMPO],{;            // PAR_ADM
     /* mascara       */    "99999",;
     /* titulo        */    "Processo",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[35,O_CAMPO],{;            // PAR_ADM
     /* mascara       */    "99",;
     /* titulo        */    "Ano",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[35,O_CAMPO],{;            // PAR_ADM
     /* mascara       */    "!!",;
     /* titulo        */    "Mproc3",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[35,O_CAMPO],{;            // PAR_ADM
     /* mascara       */    "99999",;
     /* titulo        */    "N£mero",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[35,O_CAMPO],{;            // PAR_ADM
     /* mascara       */    "@R 99999/99/!!",;
     /* titulo        */    "Procimp",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[35,O_CAMPO],{;            // PAR_ADM
     /* mascara       */    "@E 999,999.99",;
     /* titulo        */    "Valor",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[35,O_CAMPO],{;            // PAR_ADM
     /* mascara       */    "!!",;
     /* titulo        */    "Cobrador",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[35,O_CAMPO],{;            // PAR_ADM
     /* mascara       */    "@R 99/99",;
     /* titulo        */    "Mˆs Ref.",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[35,O_CAMPO],{;            // PAR_ADM
     /* mascara       */    "",;
     /* titulo        */    "Pnumfcc",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[35,O_CAMPO],{;            // PAR_ADM
     /* mascara       */    "@!",;
     /* titulo        */    "Munic¡pio",;
     /* cmd especial  */    "",;
     /* default       */    "[LIMEIRA]",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(p_cidade)~Necess rio informar MUNIC¡PIO",;
     /* help do campo */    "Entre com o nome do Munic¡pio";
                         };
)
AADD(sistema[35,O_CAMPO],{;            // PAR_ADM
     /* mascara       */    "!",;
     /* titulo        */    "Recibo Padr„o",;
     /* cmd especial  */    "MTAB([S-Recibos em pap‚l branco|N-Recibos pr‚-impressos],[RECIBO PADRŽO])",;
     /* default       */    "[S]",;
     /* pre-validacao */    "",;
     /* validacao     */    "(p_recp$[SN ])~RECIBO PADRŽO n„o aceit vel|Digite S, N ou deixe sem preencher.",;
     /* help do campo */    "Digite S para utilizar o modelo|Padronizado de recibos (formul rio branco)|ou N para recibos personalizados";
                         };
)
AADD(sistema[35,O_CAMPO],{;            // PAR_ADM
     /* mascara       */    "",;
     /* titulo        */    "Ident1",;
     /* cmd especial  */    "",;
     /* default       */    "[BIGNOTTO IND.DE URNAS LTDA]",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(setup1)~Digite o nome da Empresa|Ser  utilizado em relat¢rios",;
     /* help do campo */    "Informe o nome da Empresa";
                         };
)
AADD(sistema[35,O_CAMPO],{;            // PAR_ADM
     /* mascara       */    "@R 99.999.999/9999-99",;
     /* titulo        */    "CGC",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "VCGC(cgcsetup).or.EMPT(cgcsetup)~Necess rio informar CGC",;
     /* help do campo */    "";
                         };
)
AADD(sistema[35,O_CAMPO],{;            // PAR_ADM
     /* mascara       */    "",;
     /* titulo        */    "Ident2",;
     /* cmd especial  */    "Informe o endere‡o da Empresa",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(setup2)~Digite o endere‡o,|ser  a 2¦ linha de cabe‡alho|de alguns relat¢rios",;
     /* help do campo */    "Digite o endere‡o.";
                         };
)
AADD(sistema[35,O_CAMPO],{;            // PAR_ADM
     /* mascara       */    "",;
     /* titulo        */    "Setup3",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    "Informe a 3¦ linha de cabe‡alho.|Ex.: Telefone, Fax, etc...";
                         };
)
AADD(sistema[35,O_FORMULA],{;          // PAR_ADM - Desc.Pgto.
     /* form mostrar  */    "LEFT(TRAN(IIF(PTAB(histpg,'HISTORIC',1),HISTORIC->descricao,SPACE(40)),[]),40)",;
     /* lin da formula*/    5,;
     /* col da formula*/    22;
                         };
)
AADD(sistema[35,O_FORMULA],{;          // PAR_ADM - Desc.Recebto
     /* form mostrar  */    "LEFT(TRAN(IIF(PTAB(histrcrec,'HISTORIC',1),HISTORIC->descricao,SPACE(40)),[]),40)",;
		 /* lin da formula*/    4,;
		 /* col da formula*/    22;
												 };
)
AADD(sistema[35,O_FORMULA],{;          // PAR_ADM - Desc.Receb.FCC
		 /* form mostrar  */    "LEFT(TRAN(IIF(PTAB(histrcfcc,'HISTORIC',1),HISTORIC->descricao,SPACE(40)),[]),40)",;
		 /* lin da formula*/    3,;
		 /* col da formula*/    22;
												 };
)
AADD(sistema[35,O_FORMULA],{;          // PAR_ADM - Descri‡„o de Hi
		 /* form mostrar  */    "LEFT(TRAN(IIF(PTAB(histrccar,'HISTORIC',1),HISTORIC->descricao,SPACE(40)),[]),40)",;
		 /* lin da formula*/    2,;
     /* col da formula*/    22;
                         };
)


sistema[36]={;
            "Senhas",;                                      // opcao do menu
            "Usu rios do sistema",;                         // titulo do sistema
            {"pass"},;                                      // chaves do arquivo
            {""},;                                          // titulo dos indices para consulta
            {"02"},;                                        // ordem dos campos chvs
            "ADRPW",;                                       // nome do DBF
            {ntxpw},;                                       // nome do NTX
            {},;                                            // nome dos DBF relacionados
            {},;                                            // campos de relacionamento
            {1,1,11,19,17,51},;                             // qde telas, tela atual, coordenadas
            {3,.t.},;                                       // nivel acesso/tp chave
            {},; // campos  { mascara, titulo, when, critica }
            {},;// fromula { mascara, titulo, formula, linha, coluna }
            {"",""},;      // condicao de exclusao de registros
            {"",""},;      // condicao de alteracao de registros
            {"",""};       // condicao de recuperacao de registros
           }

msg="DIGITE INICIAIS DAS ROTINAS CERCEADAS AO USURIO|"+;
    "P. Procura    F. Filtragem    D. Digita‡„o     ÿ|"+;
    "M. Modifica   E. Exclui       R. Recupera      ÿ|"+;
    "V. Vˆ global  N. Nova coluna  A. Apaga coluna  ÿ|"+;
    "I. Imprime    O. Ordena       Q. Quantifica    ÿ|"+;
    "L. Localiza   G. Global       C. Congela Colunas|"+;
    "T. Tamanho    J. nova Janela ÿX. eXporta       ÿ|"+;
    "Z. totaliZa                                    ÿ|"
AADD(sistema[36,O_CAMPO],{;            // SENHAS
     /* mascara       */    "",;
     /* titulo        */    "Pass",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[36,O_CAMPO],{;            // SENHAS
     /* mascara       */    "@!",;
     /* titulo        */    "Usu rio",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPTY(nome)~Necess rio informar NOME",;
     /* help do campo */    "";
                         };
)
AADD(sistema[36,O_CAMPO],{;            // SENHAS
     /* mascara       */    "9",;
     /* titulo        */    "Nivel",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "MTAB([1. Opera‡„o ÿ|2. Manuten‡„o|3. Gerˆncia ÿ],[N¡VEL DE ACESSO])",;
     /* validacao     */    "nace$[123]~N¡VEL DE ACESSO inv lido",;
     /* help do campo */    "";
                         };
)
AADD(sistema[36,O_CAMPO],{;            // SENHAS
     /* mascara       */    "@A@!",;
     /* titulo        */    "Recebimento de Taxas",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    msg;
                         };
)
AADD(sistema[36,O_CAMPO],{;            // SENHAS
     /* mascara       */    "@A@!",;
     /* titulo        */    "Consulta Contrato",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    msg;
                         };
)
AADD(sistema[36,O_CAMPO],{;            // SENHAS
     /* mascara       */    "@A@!",;
     /* titulo        */    "Taxas",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    msg;
                         };
)
AADD(sistema[36,O_CAMPO],{;            // SENHAS
     /* mascara       */    "@A@!",;
     /* titulo        */    "Endere‡os",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    msg;
                         };
)
AADD(sistema[36,O_CAMPO],{;            // SENHAS
     /* mascara       */    "@A@!",;
     /* titulo        */    "Outros Recebimentos",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    msg;
                         };
)
AADD(sistema[36,O_CAMPO],{;            // SENHAS
     /* mascara       */    "@A@!",;
     /* titulo        */    "Lan‡amento Aux.Funeral",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    msg;
                         };
)
AADD(sistema[36,O_CAMPO],{;            // SENHAS
     /* mascara       */    "@A@!",;
     /* titulo        */    "Taxas a Imprimir",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    msg;
                         };
)
AADD(sistema[36,O_CAMPO],{;            // SENHAS
     /* mascara       */    "@A@!",;
     /* titulo        */    "Documento … Imprimir",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    msg;
                         };
)
AADD(sistema[36,O_CAMPO],{;            // SENHAS
     /* mascara       */    "@A@!",;
     /* titulo        */    "Parƒmetro de Juros",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    msg;
                         };
)
AADD(sistema[36,O_CAMPO],{;            // SENHAS
     /* mascara       */    "@A@!",;
     /* titulo        */    "Filiais",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    msg;
                         };
)
AADD(sistema[36,O_CAMPO],{;            // SENHAS
     /* mascara       */    "@A@!",;
     /* titulo        */    "Grupos",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    msg;
                         };
)
AADD(sistema[36,O_CAMPO],{;            // SENHAS
     /* mascara       */    "@A@!",;
     /* titulo        */    "Cobran‡as",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    msg;
                         };
)
AADD(sistema[36,O_CAMPO],{;            // SENHAS
     /* mascara       */    "@A@!",;
     /* titulo        */    "Contratos",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    msg;
                         };
)
AADD(sistema[36,O_CAMPO],{;            // SENHAS
     /* mascara       */    "@A@!",;
     /* titulo        */    "Outros Endere‡os",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    msg;
                         };
)
AADD(sistema[36,O_CAMPO],{;            // SENHAS
     /* mascara       */    "@A@!",;
     /* titulo        */    "Inscritos",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    msg;
                         };
)
AADD(sistema[36,O_CAMPO],{;            // SENHAS
     /* mascara       */    "@A@!",;
     /* titulo        */    "Taxas a processar",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    msg;
                         };
)
AADD(sistema[36,O_CAMPO],{;            // SENHAS
     /* mascara       */    "@A@!",;
     /* titulo        */    "Regi”es",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    msg;
                         };
)
AADD(sistema[36,O_CAMPO],{;            // SENHAS
     /* mascara       */    "@A@!",;
     /* titulo        */    "Cobradores/Vendedores",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    msg;
                         };
)
AADD(sistema[36,O_CAMPO],{;            // SENHAS
     /* mascara       */    "@A@!",;
     /* titulo        */    "Parcelas do Vendedor",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    msg;
                         };
)
AADD(sistema[36,O_CAMPO],{;            // SENHAS
     /* mascara       */    "@A@!",;
     /* titulo        */    "Cobran‡as",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    msg;
                         };
)
AADD(sistema[36,O_CAMPO],{;            // SENHAS
     /* mascara       */    "@A@!",;
     /* titulo        */    "Categoria dos Planos",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    msg;
                         };
)
AADD(sistema[36,O_CAMPO],{;            // SENHAS
     /* mascara       */    "@A@!",;
     /* titulo        */    "Produtos p/Categoria",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    msg;
                         };
)
AADD(sistema[36,O_CAMPO],{;            // SENHAS
     /* mascara       */    "@A@!",;
     /* titulo        */    "Circulares",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    msg;
                         };
)
AADD(sistema[36,O_CAMPO],{;            // SENHAS
     /* mascara       */    "@A@!",;
     /* titulo        */    "Processos da Circular",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    msg;
                         };
)
AADD(sistema[36,O_CAMPO],{;            // SENHAS
     /* mascara       */    "@A@!",;
     /* titulo        */    "Processos",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    msg;
                         };
)
AADD(sistema[36,O_CAMPO],{;            // SENHAS
     /* mascara       */    "@A@!",;
     /* titulo        */    "Funcion rios",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    msg;
                         };
)
AADD(sistema[36,O_CAMPO],{;            // SENHAS
     /* mascara       */    "@A@!",;
     /* titulo        */    "Segurados",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    msg;
                         };
)
AADD(sistema[36,O_CAMPO],{;            // SENHAS
     /* mascara       */    "@A@!",;
     /* titulo        */    "Inscritos no Seguro",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    msg;
                         };
)
AADD(sistema[36,O_CAMPO],{;            // SENHAS
     /* mascara       */    "@A@!",;
     /* titulo        */    "Sinistros",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    msg;
                         };
)
AADD(sistema[36,O_CAMPO],{;            // SENHAS
     /* mascara       */    "@A@!",;
     /* titulo        */    "Controle de Sinistro",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    msg;
                         };
)
AADD(sistema[36,O_CAMPO],{;            // SENHAS
     /* mascara       */    "@A@!",;
     /* titulo        */    "Hist¢rico Padr„o",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    msg;
                         };
)
AADD(sistema[36,O_CAMPO],{;            // SENHAS
     /* mascara       */    "@A@!",;
     /* titulo        */    "Custos Adicionais",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    msg;
                         };
)
AADD(sistema[36,O_CAMPO],{;            // SENHAS
     /* mascara       */    "@A@!",;
     /* titulo        */    "Mensagem p/Contrato",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    msg;
                         };
)
AADD(sistema[36,O_CAMPO],{;            // SENHAS
     /* mascara       */    "@A@!",;
     /* titulo        */    "Pgtos / Recebtos",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    msg;
                         };
)
AADD(sistema[36,O_CAMPO],{;            // SENHAS
     /* mascara       */    "@A@!",;
     /* titulo        */    "Parƒmetros",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    msg;
                         };
)

* \\ Final de ADR_ATR3.PRG
/*
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
 \ Empresa.: PresServ Inform tica - Limeira (019)452.6623
 \ Programa: ADC_RX76.PRG
 \ Data....: 14-09-98
 \ Sistema.: Administradora - PLANO
 \ Funcao..: Ficha de Acerto
 \ Analista: Ademilson Pedro Bom
 \ Criacao.: GAS-Pro v3.0
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/

#include "adrbig.ch"    // inicializa constantes manifestas

LOCAL dele_atu, getlist:={}, so_um_reg, sit_dbf:=POINTER_DBF()
PARA  lin_menu, col_menu, imp_reg
PRIV  tem_borda:=.t., op_menu:=VAR_COMPL, l_s:=10, c_s:=15, l_i:=18, c_i:=65, tela_fundo:=SAVESCREEN(0,0,MAXROW(),79)
nucop=1
so_um_reg=(PCOU()>2)
IF !so_um_reg                             // vai receber a variaveis?
 SETCOLOR(drvtittel)
 vr_memo=NOVAPOSI(@l_s,@c_s,@l_i,@c_i)     // pega posicao atual da tela
 CAIXA(mold,l_s,c_s,l_i,c_i)               // monta caixa da tela
 @ l_s,c_s+14 SAY " CONTRATOS & COBRAN€AS "
 SETCOLOR(drvcortel)
 @ l_s+01,c_s+1 SAY " Situacao....:"
 @ l_s+02,c_s+1 SAY " Contratos de:                  at‚:"
 @ l_s+03,c_s+1 SAY " Vencimentos de:                at‚:"
 @ l_s+04,c_s+1 SAY " Imprimir as cobran‡as j  pagas?"
 @ l_s+05,c_s+1 SAY " Imprimir as cobran‡as vencidas?"
 @ l_s+06,c_s+1 SAY " M¡nimo de pendentes a listar..:"
 @ l_s+07,c_s+1 SAY "                     Confirme?"
ENDI
cods=[0123456789]
codi=SPAC(9)                                       // Codigo
codf=SPAC(9)                                       // Codigo
veni_=CTOD('')                                     // Venc.Inicial
venf_=DATE() //CTOD('')                                     // Venc.Final
pag=[S] //SPAC(1)                                        // Pagas?
pend=[S] //SPAC(1)                                       // Pendentes?
rpend=0                                            // Nrpend
confirme=[S] //SPAC(1)                                   // Confirme
DO WHILE .t.
 rola_t=.f.
 cod_sos=56
 IF !so_um_reg
  SET KEY K_ALT_F8 TO ROLATELA
  SETCOLOR(drvcortel+","+drvcorget+",,,"+corcampo)
/*
  @ l_s+01 ,c_s+22 GET  cods;
									PICT "9"
*/
  @ l_s+02 ,c_s+22 GET  codi;
									PICT "999999999";
									VALI CRIT("PTAB(codi,'GRUPOS',1).OR.VAL(codi)=0~Necess rio informar CODIGO existente")
									AJUDA "Informe o n£mero do contrato"
									CMDF8 "VDBF(6,26,20,77,'GRUPOS',{'grupo','codigo','nome'},1,'codigo')"
/*
 @ l_s+02 ,c_s+41 GET  codf;
									PICT "999999";
									VALI CRIT("(PTAB(codf,'GRUPOS',1).AND.codf>=codi).OR.VAL(codf)=0~Necess rio informar CODIGO existente")
									AJUDA "Informe o n£mero do contrato"
									CMDF8 "VDBF(6,26,20,77,'GRUPOS',{'grupo','codigo','nome'},1,'codigo')"

 @ l_s+03 ,c_s+21 GET  veni_;
									PICT "@D"
									AJUDA "Informe o primeiro vencimento a considerar"

 @ l_s+03 ,c_s+40 GET  venf_;
									PICT "@D"
									AJUDA "Informe o £ltimo vencimento a considerar"

 @ l_s+04 ,c_s+34 GET  pag;
									PICT "!";
									VALI CRIT("pag$([SN])~PAGAS? n„o aceit vel|Digite S ou N")
									DEFAULT "[N]"
									AJUDA "Digite S para listar as cobran‡as pagas."

 @ l_s+05 ,c_s+34 GET  pend;
									PICT "!";
									VALI CRIT("pend$([SN])~PENDENTES? n„o aceit vel|Digite S ou N")
									DEFAULT "[S]"
									AJUDA "Digite S para listar as cobran‡as pendentes"

 @ l_s+06 ,c_s+34 GET  rpend;
									PICT "99";
									VALI CRIT("rpend>0~NRPEND n„o aceit vel")
									DEFAULT "3"
									AJUDA "Informe o n£mero m¡nimo de taxas|pendentes para listar"

 @ l_s+07 ,c_s+32 GET  confirme;
                  PICT "!";
                  VALI CRIT("confirme='S'~CONFIRME n„o aceit vel")
                  AJUDA "Digite S para confirmar|ou|tecle ESC para cancelar"
*/
  READ
  SET KEY K_ALT_F8 TO
  IF rola_t
   ROLATELA(.f.)
   LOOP
  ENDI
  IF LASTKEY()=K_ESC                                // se quer cancelar
   RETU                                             // retorna
  ENDI
 ENDI

 #ifdef COM_REDE
  CLOSE GRUPOS
  IF !USEARQ("GRUPOS",.f.,10,1)                    // se falhou a abertura do arq
	 RETU                                            // volta ao menu anterior
	ENDI
 #else
  USEARQ("GRUPOS")                                 // abre o dbf e seus indices
 #endi

 PTAB(codigo,"ECOB",1,.t.)                         // abre arquivo p/ o relacionamento
 SET RELA TO codigo INTO ECOB                      // relacionamento dos arquivos
 titrel:=criterio:=cpord := ""                     // inicializa variaveis
 titrel:=chv_rela:=chv_1:=chv_2 := ""
 tps:=op_x:=ccop := 1
 arq_=drvporta                                     // porta de saida configurada
 IF !so_um_reg
  IF !opcoes_rel(lin_menu,col_menu,52,11)           // nao quis configurar...
   CLOS ALL                                         // fecha arquivos e
   LOOP                                             // volta ao menu
  ENDI

 #ifdef COM_REDE

  ELSE

   tps=lin_menu

 #endi

 ENDI
 IF tps=2                                          // se vai para arquivo/video
  arq_=ARQGER()                                    // entao pega nome do arquivo
  IF EMPTY(arq_)                                   // se cancelou ou nao informou
   LOOP                                            // retorna
  ENDI
 ELSE
  arq_=drvporta                                    // porta de saida configurada
 ENDI
 IF "4WIN"$UPPER(drvmarca) // nome da configuracao/marca impressora
   arq_:=drvdbf+"WIN"+ide_maq
   tps:=3                                         // se vai para arquivo/video
 ENDIF
 SET PRINTER TO (arq_)                             // redireciona saida
 EXIT
ENDD
criterio_=criterio                                 // salva criterio e ordenacao
cpord_=cpord                                       // definidos se huver
criterio=""

#ifdef COM_REDE
 IF !USEARQ("TAXAS",.f.,10,1)                      // se falhou a abertura do arq
  RETU                                             // volta ao menu anterior
 ENDI
#else
 USEARQ("TAXAS")                                   // abre o dbf e seus indices
#endi

cpord="codigo"
INDTMP()
criterio=criterio_                                 // restabelece criterio e
cpord=cpord_                                       // ordenacao definidos
codf:=codi
veni:=CTOD([01/01/1970])
#ifdef COM_REDE
 IF !USEARQ("INSCRITS",.f.,10,1)                   // se falhou a abertura do arq
	RETU                                             // volta ao menu anterior
 ENDI
#else
 USEARQ("INSCRITS")                                // abre o dbf e seus indices
#endi

cpord="codigo"
INDTMP()
criterio=criterio_                                 // restabelece criterio e
cpord=cpord_                                       // ordenacao definidos

SELE GRUPOS
DBOX("[ESC] Interrompe",15,,,NAO_APAGA)
dele_atu:=SET(_SET_DELETED,.t.)                    // os excluidos nao servem...
SET DEVI TO PRIN                                   // inicia a impressao
maxli=62                                           // maximo de linhas no relatorio
BEGIN SEQUENCE
 DO WHIL ccop<=nucop                               // imprime qde copias pedida
	pg_=1; cl=999
	IF so_um_reg
	 GO imp_reg
	ELSE
	 INI_ARQ()                                       // acha 1o. reg valido do arquivo
	ENDI
	ccop++                                           // incrementa contador de copias
	DO WHIL !EOF().AND.(!so_um_reg.OR.imp_reg=RECN())
	 #ifdef COM_TUTOR
		IF IN_KEY()=K_ESC                              // se quer cancelar
	 #else
		IF INKEY()=K_ESC                               // se quer cancelar
	 #endi
		IF canc()                                      // pede confirmacao
		 BREAK                                         // confirmou...
		ENDI
	 ENDI
   IF codigo > M->codi
    GO BOTT
    SKIP
    LOOP
   ENDI
	 IF (codigo>=M->codi.AND.(M->codf=[000000000].OR.codigo<=M->codf));
    .OR. so_um_reg                  // se atender a condicao...
    IF !(so_um_reg.OR.(GRUPOS->situacao$M->cods))
     SKIP
     LOOP
    ENDI
    PTAB(GRUPOS->tipcont,[CLASSES],1)
		REL_CAB(1)                                     // soma cl/imprime cabecalho
		 IMPCTL(drvpenf)
		@ cl,000 SAY TRAN(codigo,"999999999")            // Codigo
		@ cl,006 SAY "-"
		@ cl,007 SAY TRAN(grupo,"!!")                  // Grupo
		@ cl,010 SAY nome                              // Nome
		 IMPCTL(drvTenf)
    IF !EMPT(telefone+contato)
		 @ cl,046 SAY LEFT(ALLTRIM(telefone)+[/]+alltrim(contato),33)// Telefone
    ENDI
		REL_CAB(2)                                     // soma cl/imprime cabecalho
		@ cl,010 SAY TRAN(endereco,"@!")               // Endere‡o
		REL_CAB(1)                                     // soma cl/imprime cabecalho
		@ cl,010 SAY TRAN(ALLTRIM(bairro)+[ ]+ALLTRIM(cidade)+[, ]+uf+[ - CEP:]+TRAN(cep,"@R 99999-999"),"@!")// Cidade
		subtt=0                                        // variavel temporaria
		@ cl,067 SAY "Vend/Reg/Cob"
		REL_CAB(1)                                     // soma cl/imprime cabecalho
		IMPAC("Admiss„o:",cl,010)
		@ cl,020 SAY TRAN(admissao,"@D")               // Admiss„o
		@ cl,032 SAY "SaiTxa:"
		@ cl,040 SAY TRAN(saitxa,"@R 99/99")           // Saitxa
		@ cl,047 SAY "Dia Pgto:"
		@ cl,057 SAY TRAN(diapgto,"99")                // Dia Pgto.
		@ cl,068 SAY vendedor+[/]+regiao+[/]+cobrador  // Vend/Cob/Reg
		REL_CAB(1)                                     // soma cl/imprime cabecalho
		@ cl,010 SAY [Cir.Inic.]+circinic+[   Ultima: ]+ultcirc+;
                 [   Quant.: ]+STR(qtcircs,3)+[   Nr.funerais: ]+str(funerais,3)
		REL_CAB(1)                                     // soma cl/imprime cabecalho
		@ cl,010 SAY [Categoria: ]+GRUPOS->tipcont+[ ]+CLASSES->descricao
		IF !ECOB->(EOF())
		 SELE ECOB
		 REL_CAB(1)                                     // soma cl/imprime cabecalho
		 IF ECOB->tipo=[T]
			@ cl,002 SAY [Endereco de trabalho]
		 ELSEIF ECOB->tipo=[R]
			@ cl,002 SAY [Endereco de residencia]
		 ELSE
			@ cl,002 SAY [Outro endereco  ]
		 ENDI
		 REL_CAB(1)                                     // soma cl/imprime cabecalho
		 @ cl,010 SAY TRAN(endereco,"@!")+[ ]+telefone  // Endere‡o
		 REL_CAB(1)                                     // soma cl/imprime cabecalho
		 @ cl,010 SAY TRAN(ALLTRIM(bairro)+[ ]+ALLTRIM(cidade)+[, ]+uf+[ - CEP:]+TRAN(cep,"@R 99999-999"),"@!")// Cidade
		 SELE GRUPOS
		ENDI
	 chv088=codigo
	 SELE INSCRITS
	 SEEK chv088
	 IF FOUND()
		 cl+=1                                         // soma contador de linha
		 @ cl,002 SAY REPL("-",77)
		 cl+=1                                         // soma contador de linha
		 IMPAC("Inscritos no contrato                      Observa‡„o",cl,002)
		 cl+=1                                         // soma contador de linha
//		 @ cl,002 SAY "=====  =================================== ========== ======================="
		DO WHIL ! EOF() .AND. chv088=codigo //LEFT(&(INDEXKEY(0)),LEN(chv088))
		 #ifdef COM_TUTOR
			IF IN_KEY()=K_ESC                            // se quer cancelar
		 #else
			IF INKEY()=K_ESC                             // se quer cancelar
		 #endi
			IF canc()                                    // pede confirmacao
			 BREAK                                       // confirmou...
			ENDI
		 ENDI
		 REL_CAB(1)                                    // soma cl/imprime cabecalho
		 DO CASE
		 CASE grau=[1]
			@ cl,002 SAY [Tit  ]                          // Inscr.
		 CASE grau=[2]
			@ cl,002 SAY [Pai  ]                          // Inscr.
		 CASE grau=[3]
			@ cl,002 SAY [Mae  ]                          // Inscr.
		 CASE grau=[4]
			@ cl,002 SAY [Sogro]                          // Inscr.
		 CASE grau=[5]
			@ cl,002 SAY [Sogra]                          // Inscr.
		 CASE grau=[6]
			@ cl,002 SAY [Espos]                          // Inscr.
		 CASE grau=[7]
			@ cl,002 SAY [Filh ]                          // Inscr.
		 CASE grau=[8]
			@ cl,002 SAY [Depen]                          // Inscr.
		 ENDC
//		 @ cl,002 SAY grau+'-'+STR(seq,2)              // Inscr.
		 @ cl,009 SAY nome                             // Nome
//		 @ cl,045 SAY TRAN(nascto_,"@D")               // Nascto
		 IF !EMPT(falecto_)
			@ cl,045 SAY [Falec. em ]+TRAN(falecto_,"@D")              // Falecto.
		  @ cl,066 SAY TRAN(tipo,"!!!")                 // Tipo
		  @ cl,070 SAY TRAN(procnr,"@R 99999/99")       // N§Processo
		 ENDI
		 SKIP                                          // pega proximo registro
		ENDD
	 ENDI
	 SELE GRUPOS                                     // volta ao arquivo pai

		tot091004 := 0                                 // inicializa variaves de totais
		chv091=codigo
		SELE TAXAS
		SEEK chv091
		vlatras:=vlemdia:=0
		IF FOUND()
		 // Corrigir o valor antes de listar
		 DO WHILE !EOF().AND.TAXAS->codigo==GRUPOS->codigo
			IF EMPT(TAXAS->valorpg)
			 IF TAXAS->emissao_< DATE()
				vlatras+=R07702F9()
			 ELSE
				vlemdia+=TAXAS->valor
			 ENDI
			ENDI

			SKIP
		 ENDD
		 // De volta ao inicio
		 SELE TAXAS
		 SEEK chv091

		 IF cl+3>maxli                                 // se cabecalho do arq filho
			REL_CAB(0)                                   // nao cabe nesta pagina
		 ENDI                                          // salta para a proxima pagina
		 cl+=2                                         // soma contador de linha
		 @ cl,002 SAY REPL("-",77)
		 cl+=1                                         // soma contador de linha
		 IMPAC("Cobran‡as do contrato ",cl,002)
		 cl+=1                                         // soma contador de linha
		 IMPAC("Circular Vencimento    Valor       Observa‡„o",cl,002)
		 IMPCTL(drvpenf)
     IF codigo>=[010600001].AND.codigo<[010800000]
      @ cl,50 SAY [*Valor em atraso: ]+TRAN(vlatras,"@E 9,999.99")   // Valor
     ELSE
      @ cl,50 SAY [*Valor do debito: ]+TRAN(vlatras+vlemdia,"@E 9,999.99")   // Valor
     ENDI
		 IMPCTL(drvtenf)
		 cl+=1                                         // soma contador de linha
//		 @ cl,002 SAY "======== ========== ========== =============================="
		 qqu091=0                                      // contador de registros
     addcl=0
		 DO WHIL ! EOF() .AND. chv091=codigo //LEFT(&(INDEXKEY(0)),LEN(chv091))
			#ifdef COM_TUTOR
			 IF IN_KEY()=K_ESC                           // se quer cancelar
			#else
			 IF INKEY()=K_ESC                            // se quer cancelar
			#endi
			 IF canc()                                   // pede confirmacao
				BREAK                                      // confirmou...
			 ENDI
			ENDI
			IF R07701F9()                                // se atender a condicao...
			 IF addcl=0
        REL_CAB(1)                                  // soma cl/imprime cabecalho
       ENDI

//			 IF R07701F9()                               // pode imprimir?
				IF TYPE("omt091001")!="C" .OR. omt091001!=tipo// imp se dif do anterior
//				 @ cl,003 SAY TRAN(tipo,"!")               // Tipo
				 omt091001=tipo                            // imp se dif do anterior
				ENDI
//			 ENDI
			 @ cl,002+addcl SAY IIF(emissao_<DATE(),[*],[ ])
			 @ cl,003+addcl SAY TRAN(tipo,"!")               // Tipo
			 @ cl,004+addcl SAY "-"
			 @ cl,005+addcl SAY TRAN(circ,"999")               // Circular
			 @ cl,009+addcl SAY TRAN(emissao_,"@D")            // Emissao
			 vlpend=R07702F9()                           // variavel temporaria
			 tot091004+=vlpend
			 @ cl,020+addcl SAY TRAN(vlpend,"@E 9,999.99")   // Valor
			 vlpg=valorpg                                // variavel temporaria
			 subtt=subtt+vlpend-vlpg                     // variavel temporaria
			 IF !EMPT(valorpg)                             // pode imprimir?
				@ cl,029+addcl SAY [Pg.]+LEFT(dtoc(pgto_),6)+;     // Obs.
                     RIGHT(dtoc(pgto_),2)
			 ENDI
       IF addcl=0
        addcl=40
       ELSE
        addcl=0
       ENDI
			 qqu091++                                    // soma contadores de registros
			 SKIP                                        // pega proximo registro
			ELSE                                         // se nao atende condicao
			 SKIP                                        // pega proximo registro
			ENDI
		 ENDD
		 IF cl+3>maxli                                 // se cabecalho do arq filho
			REL_CAB(0)                                   // nao cabe nesta pagina
		 ENDI                                          // salta para a proxima pagina
/*
		 @ ++cl,022 SAY REPL('-',10)
		 @ ++cl,022 SAY TRAN(subtt,"@E 999,999.99")// total Valor
		 @ cl,003 SAY "*** Quantidade "+TRAN(qqu091,"999")
*/
		 cl+=2
		 @ ++cl,002 SAY [OBS.: ]
     @ cl,002 say GET_MSG()
		 cl+=3                                    // soma cl/imprime cabecalho
		 @ cl,02 SAY [Data: ___ / ___ / ___]//
		 cl+=3
		 @ cl,002 SAY [________________________________]
		 @ cl,040 SAY [________________________________]
		 cl++
		 @ cl,002 SAY [Representante]
		 @ cl,040 SAY [Contratante]
		 cl+=2
		 @ ++cl,002 SAY [Valor para continuidade: ]+TRAN(subtt,"@E 999,999.99")// total Valor
		 @ ++cl,002 SAY [Valor para cancelamento: ]
		 @ ++cl,002 SAY [Calculo efetuado por...: ]

     cl+=2                                         // soma contador de linha

    ENDI
    SELE GRUPOS                                    // volta ao arquivo pai
    SKIP                                           // pega proximo registro
    cl=999                                         // forca salto de pagina
   ELSE                                            // se nao atende condicao
    SKIP                                           // pega proximo registro
   ENDI
  ENDD
 ENDD ccop
 EJEC                                              // salta pagina
END SEQUENCE
SET PRINTER TO (drvporta)                          // fecha arquivo gerado (se houver)
SET DEVI TO SCRE                                   // direciona saida p/ video
IF tps=2                                           // se vai para arquivo/video
 BROWSE_REL(arq_,2,3,MAXROW()-2,78)
ENDI                                               // mostra o arquivo gravado
GRELA(52)                                          // grava variacao do relatorio
SELE GRUPOS                                        // salta pagina
SET RELA TO                                        // retira os relacionamentos
SET(_SET_DELETED,dele_atu)                         // os excluidos serao vistos
IF so_um_reg
 POINTER_DBF(sit_dbf)
ENDI
RETU

STATIC PROC REL_CAB(qt)                            // cabecalho do relatorio
IF qt>0                                            // se parametro maior que 0
 cl=cl+qt                                          // soma no contador de linhas
ENDI
IF cl>maxli .OR. qt=0                              // quebra de pagina
 IMPCTL(drvtcom)
 @ 0,000 SAY M->nemp                                // nome da empresa
 @ 0,071 SAY "PAG"
 @ 0,075 SAY TRAN(pg_,'9999')                      // n£mero da p gina
 IMPAC(nsis,1,000)                                 // t¡tulo aplica‡„o
 @ 1,071 SAY "ADC_RX76"                            // c¢digo relat¢rio
 IMPAC("FICHA DE ACERTOS",2,000)
 @ 2,024 SAY titrel                                // t¡tulo a definir
 @ 2,060 SAY NSEM(DATE())                          // dia da semana
 @ 2,069 SAY DTOC(DATE())                          // data do sistema
 @ 3,000 SAY "Contrato  Nome                               "+IIF(!EMPT(telefone+contato)," Telefone/ Contato"," ")
 @ 4,000 SAY REPL("-",79)
 cl=qt+4 ; pg_++
ENDI
RETU

* \\ Final de ADC_RX76.PRG

FUNC get_msg
msg:=[]
ctlmax:=IIF(GRUPOS->codigo=[020],60,10)
for ctmsg=1 to ctlmax
 IF ctlmax=10
  msgaux:=MEMOLINE(GRUPOS->obs,55,ctmsg)
 ELSE
  msgaux:=MEMOLINE(GRUPOS->obs,55,ctmsg)
 ENDI
 IF !EMPT(msgaux)
  msg+=msgaux
 ENDI
next
IF !EMPT(msg)
 msg+=chr(10)+chr(13)+[:============]
ENDI
PTAB([],[MENSAG])
SELE MENSAG
msg2add:=[]
msg2prt:=.f.
DO WHILE ! EOF()
 SELE GRUPOS
 cond=LEFT(MENSAG->filtro,AT("~",MENSAG->filtro)-1)               // condicao de validacao
 OP_=0
 MSGAUX:=[MENSAGEM]
 alerta()
 msg2prt:=.f.
 msg2add:=[]
 IF (&cond.)                                 // se condicao nao satisfeita,
  nrlin:=mlcount(MENSAG->mens1,50)
  FOR OP_ = 1 TO nrlin
   msgAUX:=MEMOLINE(MENSAG->mens1,50,OP_)
   msg2add+=msgAUX
   IF [ATEN]$msgAUX
    msg2prt:=.t.
   ENDIF
  NEXT
 ENDI
 IF msg2prt
  msg+=msg2add+chr(10)+chr(13)+[:============]
 ENDI
 SELE MENSAG
 SKIP
ENDD

RETU msg

FUNC R07701F9
donex:=(M->pag=[S].AND.TAXAS->valorpg>0)
donex:=donex.OR.(M->pend=[S].AND.TAXAS->valorpg=0)
//donex:=donex.AND.(EMPT(M->veni_).OR.TAXAS->emissao_>=M->veni_)
donex:=donex.AND.(EMPT(M->venf_).OR.TAXAS->emissao_<=M->venf_)

RETU M->donex       // <- deve retornar um valor L¢GICO

* \\ Final de R07701F9.PRG

FUNC R07702F9
PRIVA vladd:=0
IF TAXAS->emissao_< DATE()
 jrok:=PTAB(tipo,'JUROS',1)
 nrd:=(DATE() - TAXAS->emissao_)
 IF jrok .AND. (nrd > JUROS->mltcaren)
  vladd+=TAXAS->valor*JUROS->multa/100
 ENDI
 IF jrok .AND. (nrd > JUROS->jrscaren)
  vladd+=TAXAS->valor*JUROS->juros/100*nrd
 ENDI
ENDI

RETU IIF(EMPT(TAXAS->valorpg),TAXAS->valor+M->vladd,TAXAS->valorpg)

* \\ Final de R07702F9.PRG
GAS-Pro v4.0
002003024079001010001001012000176001
                                                                      PAG

Relacao dos funerais efetuados (cartinha)
------------------------------------------------------------------------------
Grupo:        Circular:        Emissao:
[Ÿ]
 8 
CIRCULAR
Cartinha

grupo
grupo=M->rgrupo.AND.circ=M->rcirc
011

























 0 
 1 










-1 
 1 
 0 
 66 
 1 
 4 
 2 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
-1 
 0 
-1 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
Grupo
M->rgrupo
!!
 2 
C
 5 
 8 


          










Circular
M->rcirc
999
 3 
C
 5 
 25 


          










Emiss„o
emissao_
@D
 10 
D
 5 
 41 


          










Mens1
M->rmens1
@!
 70 
C
 6 
 1 


          










Mens2
M->rmens2
@!
 70 
C
 7 
 1 


          










Mens3
M->rmens3
@!
 70 
C
 8 
 1 


          










Mens4
M->rmens4
@!
 70 
C
 9 
 1 


          










Mens5
M->rmens5
@!
 70 
C
 10 
 1 


          










 9 
Nome da empresa
nemp

 1 
 1 
 44 

T¡tulo aplica‡„o
nsis

 2 
 1 
 25 

Data do sistema
DTOC(DATE())

 3 
 69 
 10 

Nome do mˆs
NMES(DATE())

 0 
 0 
 8 

Dia da semana
NSEM(DATE())

 3 
 61 
 7 

N£mero da p gina
TRAN(pg_,'9999')

 1 
 75 
 4 

C¢digo relat¢rio
"ADP_R101"

 2 
 71 
 8 

T¡tulo a definir
titrel

 2 
 28 
 30 

Hora da emiss„o
hora_rel_

 0 
 0 
 5 

 0 
 1 
M->rdata+[ Grupo: ]+grup+[ Circ: ]+saiu
  û ûû    
grup+saiu


 0 
 0 
GAS-Pro v3.0
011021014062001001019001012000176001
 Processo:
 Confirme:
[Ÿ]
[Ÿ]
 2 
 0 
Recibo Aux.Funeral 1
Recibo Aux.Funeral 1







056







 0 
 0 
-1 
-1 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
rproc
C
E
@R 99999/9999-99
 11 
 13 
 1 
 12 
 0 
Processo

!EMPT(RPROC).AND.PTAB(rproc,[AFUNER],1)
Campo utilizado para localiza‡„o dos documentos.|Tecle F8 para busca em tabela
IIF(PTAB(PADR(SUBSTR(M->ide_maq,2),4)+[AFU],[IMPPAR],1),ALLTRIM(IMPPAR->docto),[])
Digite neste campo o n£mero de|identifica‡„o do processo
VDBF(6,12,20,77,'AFUNER',{'processo','proc2','categ','contrato','falecido'},1,'V02001F9()',[])
 0 
 0 


confirme
C
E
!
 1 
 1 
 2 
 12 
 0 
Confirme

confirme='S'.AND.V02002F9()
CONFIRME n„o aceit vel|Digite S para confirmar|ou|Tecle ESC para cancelar

Digite S para confirmar|ou|tecle ESC para cancelar

 0 
 0 


 0 
 0 
 0 
 0 
 0 
procedure adm_r020
/*
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
 \ Empresa.: PresServ Inform tica-Limeira (019)452.6623
 \ Programa: ADM_R020.PRG
 \ Data....: 22-09-97
 \ Sistema.: Administradora - RECEP€„O
 \ Funcao..: Impress„o Aux.Funeral 1
 \ Analista: Ademilson Pedro Bom
 \ Criacao.: GAS-Pro v3.0 
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/

#include "adrbig.ch"    // inicializa constantes manifestas

LOCAL dele_atu, getlist:={}, so_um_reg, sit_dbf:=POINTER_DBF()
PARA  lin_menu, col_menu, imp_reg
PRIV  tem_borda:=.t., op_menu:=VAR_COMPL, l_s:=10, c_s:=20, l_i:=13, c_i:=61, tela_fundo:=SAVESCREEN(0,0,MAXROW(),79)
nucop=1
so_um_reg=(PCOU()>2)
IF !so_um_reg                             // vai receber a variaveis?
 SETCOLOR(drvtittel)
 vr_memo=NOVAPOSI(@l_s,@c_s,@l_i,@c_i)    // pega posicao atual da tela
 CAIXA(mold,l_s,c_s,l_i,c_i)              // monta caixa da tela
 @ l_s,c_s+10 SAY " IMPRESSŽO AUX.FUNERAL "
 SETCOLOR(drvcortel)
 @ l_s+01,c_s+1 SAY " Processo:"
 @ l_s+02,c_s+1 SAY " Confirme:"
ENDI
rproc=SPAC(11)                                     // Processo
confirme=SPAC(1)                                   // Confirme
DO WHILE .t.
 rola_t=.f.
 cod_sos=56
 IF !so_um_reg
  SET KEY K_ALT_F8 TO ROLATELA
  SETCOLOR(drvcortel+","+drvcorget+",,,"+corcampo)
  @ l_s+01 ,c_s+12 GET  rproc;
                   PICT "@R 99999/9999-99";
                   VALI CRIT("!EMPT(RPROC).AND.PTAB(rproc,[AFUNER],1)~Campo utilizado para localiza‡„o dos documentos.|Tecle F8 para busca em tabela")
                   DEFAULT "IIF(PTAB(PADR(SUBSTR(M->ide_maq,2),4)+[AFU],[IMPPAR],1),ALLTRIM(IMPPAR->docto),[])"
                   AJUDA "Digite neste campo o n£mero de|identifica‡„o do processo"
                   CMDF8 "VDBF(6,12,20,77,'AFUNER',{'processo','proc2','categ','contrato','falecido'},1,'V02001F9()',[])"

  @ l_s+02 ,c_s+12 GET  confirme;
                   PICT "!";
                   VALI CRIT("confirme='S'.AND.V02002F9()~CONFIRME n„o aceit vel|Digite S para confirmar|ou|Tecle ESC para cancelar")
                   AJUDA "Digite S para confirmar|ou|tecle ESC para cancelar"

  READ
  SET KEY K_ALT_F8 TO
  IF rola_t
   ROLATELA(.f.)
   LOOP
  ENDI
  IF LASTKEY()=K_ESC                               // se quer cancelar
   RETU                                            // retorna
  ENDI
 ENDI

 #ifdef COM_REDE
  IF !USEARQ("AFUNER",.f.,10,1)                    // se falhou a abertura do arq
   RETU                                            // volta ao menu anterior
  ENDI
 #else
  USEARQ("AFUNER")                                 // abre o dbf e seus indices
 #endi

 PTAB(contrato,"GRUPOS",1,.t.)                     // abre arquivo p/ o relacionamento
 PTAB(contrato,"INSCRITS",1,.t.)
 SET RELA TO contrato INTO GRUPOS,;                // relacionamento dos arquivos
          TO contrato INTO INSCRITS
 titrel:=criterio:=cpord := ""                     // inicializa variaveis
 titrel:=chv_rela:=chv_1:=chv_2 := ""
 tps:=op_x:=ccop := 1
 arq_=drvporta                                     // porta de saida configurada
 IF !so_um_reg
  IF !opcoes_rel(lin_menu,col_menu,1,11)           // nao quis configurar...
   CLOS ALL                                        // fecha arquivos e
   LOOP                                            // volta ao menu
  ENDI

 #ifdef COM_REDE

  ELSE

   tps=lin_menu

 #endi

 ENDI
 IF tps=2                                          // se vai para arquivo/video
  arq_=ARQGER()                                    // entao pega nome do arquivo
  IF EMPTY(arq_)                                   // se cancelou ou nao informou
   LOOP                                            // retorna
  ENDI
 ELSE
  arq_=drvporta                                    // porta de saida configurada
 ENDI
 IF "4WIN"$UPPER(drvmarca) // nome da configuracao/marca impressora
    arq_:=drvdbf+"WIN"+ide_maq
    tps:=3                                          // se vai para arquivo/video
 ENDIF
 SET PRINTER TO (arq_)                             // redireciona saida
 EXIT
ENDD
DBOX("[ESC] Interrompe",15,,,NAO_APAGA)
dele_atu:=SET(_SET_DELETED,.t.)                    // os excluidos nao servem...
SET DEVI TO PRIN                                   // inicia a impressao
maxli=62                                           // maximo de linhas no relatorio
BEGIN SEQUENCE
 DO WHIL ccop<=nucop                               // imprime qde copias pedida
  pg_=1; cl=999
  IF so_um_reg
   GO imp_reg
  ELSE
   INI_ARQ()                                       // acha 1o. reg valido do arquivo
   IF PTAB(PADR(SUBSTR(M->ide_maq,2),4)+[AFU],[IMPPAR],1)
    PTAB(LEFT(IMPPAR->docto,11),'AFUNER',1)
   ENDI
  ENDI
  ccop++                                           // incrementa contador de copias
  DO WHIL !EOF().AND.(!so_um_reg.OR.imp_reg=RECN())
   #ifdef COM_TUTOR
    IF IN_KEY()=K_ESC                              // se quer cancelar
   #else
    IF INKEY()=K_ESC                               // se quer cancelar
   #endi
    IF canc()                                      // pede confirmacao
     BREAK                                         // confirmou...
    ENDI
   ENDI
   IF (PTAB(PADR(SUBSTR(M->ide_maq,2),4)+[AFU],[IMPPAR],1).and.processo+proc2+filial+categ=ALLTRIM(IMPPAR->docto)) .OR. so_um_reg// se atender a condicao...
    PTAB(contrato+[1 0],[INSCRITS])
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,049 SAY "N§ do Processo"
    IMPCTL(drvpenf)
    @ cl,064 SAY TRAN(processo+proc2+filial,"@R 99999/99/!!")// Nr.Processo
    IMPCTL(drvtenf)
    REL_CAB(2)                                     // soma cl/imprime cabecalho
    @ cl,001 SAY "Contratante:"
    IMPCTL(drvpenf)
    @ cl,014 SAY TRAN(GRUPOS->nome,"@!")// Nome do contratante
    IMPCTL(drvtenf)
    @ cl,053 SAY "Docto:"
    @ cl,060 SAY GRUPOS->rg// rg contratante
    REL_CAB(2)                                     // soma cl/imprime cabecalho
    IMPAC("Endere‡o...:",cl,001)
    @ cl,014 SAY TRAN(xDECRIPT(GRUPOS->endereco),"@!")       // Endereco contratante
    @ cl,055 SAY TRAN(xDECRIPT(GRUPOS->cidade),"@!")         // cidade contratante
//    @ cl,076 SAY TRAN(GRUPOS->estado,"!!")// Estado Contratante
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,001 SAY "Contrato...:"
    IMPCTL(drvpenf)
    @ cl,014 SAY GRUPOS->grupo                     // grupo
    IMPCTL(drvtenf)
    @ cl,017 SAY contrato                          // contrato numero
    IMPAC("Admiss:",cl,028)
    @ cl,036 SAY GRUPOS->admissao                  // data admissao
    @ cl,047 SAY "Est.Civil:"
    @ cl,058 SAY TRAN(IIF(INSCRITS->(EOF()),[ ],subst(tbestciv,AT(INSCRITS->estcivil,tbestciv),10)),"@!")// Est.Civil contratante
    REL_CAB(3)                                     // soma cl/imprime cabecalho
    IMPAC("Vem mui respeitosamente a presen‡a de V.S., atrav‚s deste,",cl,013)
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,001 SAY "requerer que se digne autorizar o pagamento da cota denominada AUXILIO"
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    IMPAC("FUNERAL, conforme cl usulas contratuais no valor abaixo  especificado,",cl,001)
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    IMPAC("e tamb‚m afirmar que estou ciente quanto as minhas responsabilidades na",cl,001)
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    IMPAC("cobertura deste Aux¡lio recebido.",cl,001)
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,001 SAY "Valor em Reais....R$"
    IMPCTL(drvpenf)
    @ cl,021 SAY ALLTRIM(TRAN(vlauxilio,'@E 99,999,999.99'))// Valor
    IMPCTL(drvtenf)
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,003 SAY [(]+SUBSTR(EXT(vlauxilio),1,AT('/',EXT(vlauxilio))-1)+[)]// Valor extenso
    REL_CAB(2)                                     // soma cl/imprime cabecalho
    @ cl,020 SAY "D A D O S   D O   F A L E C I D O"
    REL_CAB(2)                                     // soma cl/imprime cabecalho
    @ cl,004 SAY "Nome do falecido.......:"
    IMPCTL(drvpenf)
    @ cl,029 SAY TRAN(falecido,"@!")               // nome do falecido
    IMPCTL(drvtenf)
    REL_CAB(2)                                     // soma cl/imprime cabecalho
    @ cl,004 SAY "End. do falecido.......:"
    @ cl,029 SAY TRAN(ALLTRIM(ruares)+[, ]+ALLTRIM(baires),"@!")// Endereco falecido
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,004 SAY "Cidade.................:"
    @ cl,029 SAY municfal                          // Cidade Falecimento
    @ cl,056 SAY "Estado:"
    @ cl,064 SAY TRAN(estfal,"!!")                 // UF falecimento
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,004 SAY "Local do Falecimento...:"
    @ cl,029 SAY ALLTRIM(ruafal)                   // local falecimento
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    IMPAC("Cemit‚rio de sepulta/to:",cl,004)
    @ cl,029 SAY cemitsep                          // Cemit‚rio sepultamento
    @ cl,064 SAY "Horas:"
    @ cl,071 SAY TRAN(horasepult,"99:99")          // Hora sepultamento
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,004 SAY "Inscrito Contrato como.:"
    @ cl,029 SAY grauparcon                        // Inscrito na qualidade de
    @ cl,047 SAY "Faleceu em"
    @ cl,058 SAY DTOC(falecto_)+[, ]+horafal +[ hs]// obs.:
    REL_CAB(2)                                     // soma cl/imprime cabecalho
    @ cl,016 SAY "D O C U M E N T O S   A P R E S E N T A D O S"
    REL_CAB(2)                                     // soma cl/imprime cabecalho
    IMPAC("1§.Certid„o de Nascimento ou Casamento do Falecido...:",cl,004)
    @ cl,059 SAY [S] //TRAN(doc1,"!")                    // Cert.nasc.
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    IMPAC("2§.Certid„o de ¢bito do Falecido.....................:",cl,004)
    @ cl,059 SAY [S] //TRAN(doc2,"!")                    // Cert.¢bito
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,004 SAY "3§.Nota Fiscal da Empresa que executou o Funeral.....:"
    @ cl,059 SAY [S] //TRAN(doc3,"!")                    // Nota Fiscal
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,004 SAY "4§.Recibo da Empresa que executou o Funeral..........:"
    @ cl,059 SAY [N] //TRAN(doc4,"!")                    // Recibo
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,004 SAY "5§.Taxa de Sepultamento ou Recibo da Prefeitura......:"
    @ cl,059 SAY [N] //TRAN(doc5,"!")                    // Taxa Sepult.
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY "" //chr(15)                           // comprimir
    IMPCTL(drvpcom)
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    IMPAC("DECLARA€ŽO - Declaro que me responsabilizo pelas declara‡”es aqui prestadas, CIENTE de que qualquer declara‡„o FALSA importa",cl,000)
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    IMPAC("em responsabilidade criminal, nos termos do Artigo 299 do C¢digo Penal, declarando ainda que, se constatada a inexatid„o  das",cl,000)
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    IMPAC("declara‡”es prestadas do compromisso ora assumido, al‚m de  obrigar a devolu‡„o compuls¢ria da importƒncia recebida indevidamente,",cl,000)
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    IMPAC("sujeitar-me-ei  s penalidades previstas no artigo 171 do C¢digo Penal.",cl,000)
    @ cl,071 SAY "" //chr(18)                           // normal
    IMPCTL(drvtcom)
    @ cl,076 SAY "Data:"
    @ cl,082 SAY TRAN(DATE(),"@D")                 // data
    REL_CAB(2)                                     // soma cl/imprime cabecalho
    IMPCTL(drvpenf)
    @ cl,000 SAY [PROCESSAR PAGAMENTO EM : ]+ DTOC(procpagto_)// processar pgto em
    IMPCTL(drvtenf)
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,042 SAY REPL("-",30)
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,042 SAY "Ass. do Requerente declarante"
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY REPL("-",72)
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    IMPEXP(cl,000,[R E C I B O],24)                // R E C I B O
    REL_CAB(2)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY R02BP1F9()                        // recibo
    REL_CAB(2)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY "Data:"
    @ cl,006 SAY TRAN(DATE(),"@D")                 // data
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,042 SAY REPL("-",30)
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,042 SAY "Ass. do Requerente declarante"
    SKIP                                           // pega proximo registro
    cl=999                                         // forca salto de pagina
   ELSE                                            // se nao atende condicao
    SKIP                                           // pega proximo registro
   ENDI
   EJEC
   EXIT
  ENDD
 ENDD ccop
END SEQUENCE
SET PRINTER TO (drvporta)                          // fecha arquivo gerado (se houver)
SET DEVI TO SCRE                                   // direciona saida p/ video
IF tps=2                                           // se vai para arquivo/video
 BROWSE_REL(arq_,2,3,MAXROW()-2,78)
ENDI                                               // mostra o arquivo gravado
GRELA(1)                                           // grava variacao do relatorio
SELE AFUNER                                        // salta pagina
SET RELA TO                                        // retira os relacionamentos
SET(_SET_DELETED,dele_atu)                         // os excluidos serao vistos
IF so_um_reg
 POINTER_DBF(sit_dbf)
ENDI
RETU

STATIC PROC REL_CAB(qt)                            // cabecalho do relatorio
IF qt>0                                            // se parametro maior que 0
 cl=cl+qt                                          // soma no contador de linhas
ENDI
IF cl>maxli .OR. qt=0                              // quebra de pagina
 @ 1,001 SAY TRAN(setup1,"@!")                     // Administradora
 @ 2,000 SAY REPL("-",72)
 @ 3,004 SAY "R E Q U E R I M E N T O   D E   A U X I L I O   F U N E R A L"

 nucop:=1

 @ 3,067 SAY STR(ccop-1,1)+[¦ Via]  // ccop contˆn o n£mero da via + 1.
 @ 4,000 SAY REPL("-",72)
 cl=qt+4 ; pg_++
ENDI
RETU

* \\ Final de ADM_R020.PRG
FUNC R02BP1F9()
 LOCAL ar_db:=ALIAS(), ultreg, ord_ind
 LOCAL tit:=[Sra.], tit1:=[a]
 LOCAL li_:=PROW(), co_:=PCOL(), nrdec_:=[]

 li_aux:=space(1024)
 li_aux:=[Recebi da ]+ALLTRIM(M->setup1)+;
  [, a importƒncia supra de R$]+ALLTRIM(TRAN(vlauxilio,[@E 999,999.99]))+;
  [ (]+LEFT(EXT(vlauxilio),AT([/],EXT(vlauxilio))-1)+[)]
 li_aux+=[ referente ao AUXILIO FUNERAL por ocasi„o do falecimento acima mencionado ]+;
  [ conforme requerimento anexo.]
 li_aux+=CHR(13)+CHR(10)+[Para clareza legal, firmo o presente, da qual dou f‚.]
 li_m:=-1
 qli_m:=MLCOUNT(li_aux,70)-1                  // quantas linhas a imprimir?
 DO WHIL .t.                                     // imprime linhas do memo
  li_m++
  cl++
  IF li_m>qli_m                                  // fim do memo
   EXIT
  ENDI
  IMPMEMO(li_aux,70,1+li_m,cl,005,.t.)       // imprime...
  IF INKEY()=K_ESC                               // se quer cancelar
   IF canc()                                     // pede confirmacao
    BREAK                                        // confirmou...
   ENDI
  ENDI
 ENDD
 cl:=56
RETU [ ]       // <- deve retornar um valor qualquer
   bm                    MARCA t"Q%C  æ{ {(  xm% % .ð{PORTA t"Q%C  æ{ {(  xm% % .ð{PADRAO "Q%C  æ{ {(  xm% % .ð{TAPG O "Q%C  æ{( {(  xm% % .ð{PCOM O "Q%C  æ{( {(  xm% % .ð{TCOM O "Q%C  æ{( {(  xm% % .ð{PC20 O "Q%C  æ{( {(  xm% % .ð{TC20 O "Q%C  æ{( {(  xm% % .ð{PELI O "Q%C  æ{( {(  xm% % .ð{TELI O "Q%C  æ{( {(  xm% % .ð{PENF O "Q%C  æ{( {(  xm% % .ð{TENF O "Q%C  æ{( {(  xm% % .ð{PEXP O "Q%C  æ{( {(  xm% % .ð{TEXP O "Q%C  æ{( {(  xm% % .ð{PDE8 O "Q%C  æ{( {(  xm% % .ð{TDE8 O "Q%C  æ{( {(  xm% % .ð{LAND O "Q%C  æ{( {(  xm% % .ð{PORT O "Q%C  æ{( {(  xm% % .ð{  Padr„o IBM     LPT11CHR(27)+'C'+CHR(NNN)                    CHR(15)                                 CHR(18)                                 CHR(30)+'5'                             CHR(30)+'0'                             CHR(30)+'2'                             CHR(30)+'0'                             CHR(27)+'E'                             CHR(27)+'F'                             CHR(27)+'W'+CHR(1)                      CHR(27)+'W'+CHR(0)                      CHR(27)+'0'                             CHR(27)+'2'                                                                                                             procedure ctxas
/*
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
 \ Empresa.: PresServ Inform tica - Limeira (019)452.6623
 \ Programa: CTXAS.PRG
 \ Data....: 12-11-03
 \ Sistema.: Administradora - RECEP€„O
 \ Funcao..: Consulta Taxas
 \ Analista: Ademilson Pedro Bom
 \ Criacao.: GAS-Pro v4.0n
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/
#include "adrbig.ch"    // inicializa constantes manifestas

PRIV t_, i_, col_cp, col_ti, cps_rela
PRIV  prefixo_dbf:="CTX", op_sis:=EVAL(qualsis,"TAXAS")
                                                   // arquivo a consultar
op_menu=PROJECOES                                  // flag consulta e faz projecoes
SELE 0

#ifdef COM_REDE
 IF !USEARQ("TAXAS",.f.,10,1)                      // se falhou a abertura do arq
  RETU                                             // volta ao menu anterior
 ENDI
#else
 USEARQ("TAXAS")                                   // abre o dbf e seus indices
#endi

PTAB(codigo,"GRUPOS",1,.t.)                        // abre arquivo p/ o relacionamento
SET RELA TO codigo INTO GRUPOS                     // relacionamento dos arquivos
col_cp={;                                          // conteudo das colunas
          "codigo",;
          "tipo",;
          "circ",;
          "emissao_",;
          "valor",;
          "pgto_",;
          "valorpg",;
          "cobrador",;
          "forma";
       }
col_ti={;                                          // titulo das colunas
          "Codigo",;
          "Tipo",;
          "Circular",;
          "Emissao",;
          "Valor",;
          "Pagamento",;
          "Valor pago",;
          "Cobrador",;
          "Forma";
       }
GO TOP                                             // vai p/ inicio do arquivo
FOR i_=1 TO LEN(sistema[op_sis,O_CPRELA])          // libera os campos invisiveis
 sistema[op_sis,O_CAMPO,i_,O_CRIT]="V"             // que fazem a ligacao dos DBFs
NEXT                                               // para serem vistos na consulta
cod_sos=8
EDITA(03,03,MAXROW()-2,77,"V",col_cp,col_ti)
FOR i_=1 TO LEN(sistema[op_sis,O_CPRELA])          // e retorna com o atributo
 sistema[op_sis,O_CAMPO,i_,O_CRIT]="I"             // de invisivel nos campos da
NEXT                                               // ligacao pai-filho
SELE TAXAS                                         // seleciona arquivo
SET RELA TO                                        // retira os relacionamentos
RETU                                               // volta para o menu anterior

* \\ Final de CTXAS.PRG
procedure fncs
/*
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
 \ Empresa.: PresServ Inform tica - Limeira (019)452.6623
 \ Programa: FNCS.PRG
 \ Data....: 04-11-03
 \ Sistema.: Administradora - RECEP€„O
 \ Funcao..: Gerenciador do subsistema de funcion rios
 \ Analista: Ademilson Pedro Bom
 \ Criacao.: GAS-Pro v4.0n
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/
#include "adrbig.ch"    // inicializa constantes manifestas

PARA lin_menu,col_menu
PRIV op_sis, tela_fundo:=SAVESCREEN(0,0,MAXROW(),79), l_s, c_s, l_i, c_i, l_a

op_sis=EVAL(qualsis,"FNCS")
IF nivelop<sistema[op_sis,O_OUTROS,O_NIVEL]        // se usuario nao tem permissao,
 ALERTA()                                          // entao, beep, beep, beep
 DBOX(msg_auto,,,3)                                // lamentamos e
 RETU                                              // retornamos ao menu
ENDI
cn:=fgrep :=.f.

#ifdef COM_LOCK
 IF LEN(pr_ok)>0                                   // se a protecao acusou
  ? pr_ok                                          // erro, avisa e
  QUIT                                             // encerra a aplicacao
 ENDI
#endi

t_fundo=SAVESCREEN(0,0,MAXROW(),79)                // salva tela do fundo
op_cad=1
DO WHIL op_cad!=0
 criterio=""
 RESTSCREEN(0,0,MAXROW(),79,t_fundo)               // restaura tela do fundo
 cod_sos=5 ; cn=.f.
 CLEA TYPEAHEAD                                    // limpa o buffer do teclado
 fgrep=.f.
 SET KEY K_F3 TO                                   // retira das teclas F3 e F4 as
 SET KEY K_F4 TO                                   // funcoes de repeticao e confirmacao
 msg="Inclus„o~1|"+;
     "Manuten‡„o~2|"+;
     "Consulta~3"
 op_cad=DBOX(msg,lin_menu,col_menu,E_MENU,NAO_APAGA,MAIUSC(sistema[op_sis,O_MENU]),,,op_cad)
 IF op_cad!=0                                      // se escolheu uma opcao
  Tela_fundo=SAVESCREEN(0,0,MAXROW(),79)           // salva a tela para ROLATELA()
  PARAMETROS(dbfparam)
  SELE A                                           // e abre o arquivo e seus indices

  #ifdef COM_REDE
   IF !USEARQ(sistema[op_sis,O_ARQUI,O_NOME],.f.,20,1)
                                                   // se falhou a abertura do
    RETU                                           // arquivo volta ao menu anterior
   ENDI
  #else
   USEARQ(sistema[op_sis,O_ARQUI,O_NOME])
  #endi

  SET KEY K_F9 TO veoutros                         // habilita consulta em outros arquivos
 ENDI
 DO CASE
  CASE op_cad=01                                   // inclus„o
   op_menu=INCLUSAO
   IF AT("D",exrot[op_sis])=0                      // se usuario pode fazer inclusao
    FNC_INCL()                                     // neste arquivo chama prg de inclusao
   ELSE                                            // caso contrario vamos avisar que
    ALERTA()                                       // ele nao tem permissao para isto
    DBOX(msg_auto,,,3)
   ENDI

  CASE op_cad=02                                   // manuten‡„o
   op_menu=ALTERACAO
   cod_sos=7
   EDIT()

  CASE op_cad=03                                   // consulta
   op_menu=PROJECOES
   cod_sos=8
   EDITA(03,03,MAXROW()-2,77)

 ENDC
 SET KEY K_F9 TO                                   // F9 nao mais consultara outros arquivos
 CLOS ALL                                          // fecha todos arquivos abertos
ENDD
RETU

PROC FNC_incl(reg_cop)  // inclusao no arquivo FNCS
LOCAL getlist:={},cabem:=1,rep:=ARRAY(FCOU()),ult_reg:=RECN(),cond_incl_,dbfseq_,;
      ctl_r, ctl_c, ctl_w, t_f3_, t_f4_, dele_atu:=SET(_SET_DELETED,.f.)
PRIV op_menu:=INCLUSAO, sq_atual_, tem_borda, criterio:="", cpord:=""
cond_incl_={||nivelop>1}                           // condicao de inclusao de registros
IF !EVAL(cond_incl_)                               // se nao pode incluir
 ALERTA(2)                                         // avisa o motivo
 DBOX("Permitido apenas para usu rio cadastrado|com n¡vel de Manuten‡„o ou Gerˆncia",,,4,,"ATEN€ŽO, "+usuario)
 RETU                                              // e retorna
ENDI
FOR i=1 TO FCOU()                                  // cria/declara privadas as
 msg=FIEL(i)                                       // variaveis de memoria com
 PRIV &msg.                                        // o mesmo nome dos campos
NEXT                                               // do arquivo
IF reg_cop!=NIL                                    // quer repetir todo o reg atual
 FOR i=1 TO FCOU()                                 // para cada campo,
  msg=FIEL(i)                                      // salva o conteudo
  rep[i]=&msg.                                     // para repetir
 NEXT
ELSE
 AFILL(rep,"")                                     // eche com valor vazio
ENDI
t_f3_=SETKEY(K_F3,{||rep()})                       // repeticao reg anterior
t_f4_=SETKEY(K_F4,{||conf()})                      // confirma campos com ENTER
ctl_w=SETKEY(K_CTRL_W,{||nadafaz()})               // enganando o CA-Clipper...
ctl_c=SETKEY(K_CTRL_C,{||nadafaz()})
ctl_r=SETKEY(K_CTRL_R,{||nadafaz()})

#ifdef COM_REDE
 FNC_CRIA_SEQ()                                    // cria dbf de controle de cp sequenciais
 FOR i=1 TO FCOU()                                 // cria/declara privadas as
  msg="sq_"+FIEL(i)                                // variaveis de memoria com
  PRIV &msg.                                       // o mesmo nome dos campos
 NEXT                                              // do arquivo com extensao _seq
#endi

DO WHIL cabem>0
 cod_sos=6
 rola_t=.f.                                        // flag se quer rolar a tela
 SELE FNCS
 GO BOTT                                           // forca o
 SKIP                                              // final do arquivo
 
 /*
    cria variaveis de memoria identicas as de arquivo, para inclusao
    de registros
 */
 FOR i=1 TO FCOU()
  msg=FIEL(i)
  M->&msg.=IF((fgrep .OR. reg_cop!=NIL).AND.!EMPT(rep[1]),rep[i],&msg.)
 NEXT
 DISPBEGIN()                                       // apresenta a tela de uma vez so
 FNC_TELA()
 INFOSIS(.t.)                                      // exibe informacao no rodape' da tela
 DISPEND()
 FNC_GERA_SEQ()
 IF !EVAL(cond_incl_)
  EXIT
 ENDI
 cabem=DISKSPACE(;
          IF(;
             LEN(sistema[op_sis,O_ARQUI,O_DIR_DBF])<2.OR.sistema[op_sis,O_ARQUI,O_DIR_DBF]="\",;
             0,;
             ASC(sistema[op_sis,O_ARQUI,O_DIR_DBF])-64;
          );
       )
 cabem=INT((cabem-2048)/FNCS->(RECSIZE()))
 IF cabem<1                                        // mais nenhum!!!
  ALERTA()
  msg="Verifique ESPA€O EM DISCO, "+usuario
  DBOX(msg,,,,,"INCLUSŽO INTERROMPIDA!")           // vamos parar por aqui!
  EXIT
 ENDI
 SELE 0                                            // torna visiveis variaveis de memoria
 SETCOLOR(drvcortel+","+drvcorget+",,,"+corcampo)
 SET KEY K_ALT_F8 TO ROLATELA
 
 /*
    recebe chaves do arquivo de indice basico
 */
 @ l_s+01 ,c_s+12 GET  codigo
                  DEFINICAO 1

 READ
 SET KEY K_ALT_F8 TO
 IF rola_t
  ROLATELA()

  #ifdef COM_REDE
   FNC_ANT_SEQ()                                   // decrementa sequencial
  #endi

  LOOP
 ENDI
 SELE FNCS
 IF LASTKEY()=K_ESC                                // cancelou ou chave em branco
  cabem=0                                          // prepara saida da inclusao
  LOOP                                             // volta p/ menu de cadastramento
 ENDI
 SEEK M->codigo
 aprov_reg_=(FOUND().AND.DELE().AND.!drvvisivel)   // vai aproveitar o registro?
 IF FOUND() .AND. !aprov_reg_                      // pesquisou e achou!
  op_menu=ALTERACAO                                // seta flag de ateracao

  #ifdef COM_REDE
   FNC_ANT_SEQ()                                   // decrementa sequencial
   SELE FNCS
  #endi

  DISPBEGIN()
  FNC_GETS()                                       // mostra conteudo do registro
  INFOSIS(.f.)                                     // exibe informacao no rodape' da tela
  DISPEND()
  ALERTA()
  msg="Consultar/alterar|Retornar … inclus„o"      // pergunta se deseja
  op_=DBOX(msg,,,E_MENU,,"REGISTRO J EXISTE")     // alterar o registro
  IF op_ =1                                        // caso afirmativo
   EDIT()                                          // deixa alterar
  ENDI
  op_menu=INCLUSAO
  LOOP                                             // volta para inclusao
 ENDI
 SELE 0
 FNC_GET1(INCLUI)                                  // recebe campos
 SELE FNCS
 IF LASTKEY()=K_ESC                                // se cancelou

  #ifdef COM_REDE
   FNC_ANT_SEQ()                                   // decrementa sequencial
  #endi

  ALERTA()                                         // avisa que o registro
  DBOX("Registro n„o inclu¡do!",18,,1)             // nao foi incluido, e volta
  LOOP
 ENDI

 #ifdef COM_REDE
  GO BOTT                                          // vamos bloquear o final do
  SKIP                                             // arq para que nehum outro
  BLOREG(0,.5)                                     // usuario possa incluir
  SEEK M->codigo                                   // se registro foi incluido
  aprov_reg_=(FOUND().AND.DELE().AND.!drvvisivel)  // vai aproveitar o registro?
  IF FOUND() .AND. !aprov_reg_                     // por outro usuario, entao
   BLOREG(0,.5)
   FOR i=1 TO FCOU()
    msg=FIEL(i)
    rep[i]=&msg.
    REPL &msg. WITH M->&msg.
   NEXT
   FNC_GET1(FORM_INVERSA)                          // executa formula inversa
   RECA
   FOR i=1 TO FCOU()
    msg=FIEL(i)
    REPL &msg. WITH rep[i]
   NEXT
   ALERTA(4)                                       // beep 4 vezes
   msg="Registro acabou de ser|inclu¡do por outro usu rio!"
   DBOX(msg,,,,,"ATEN€ŽO!")                        // avisa
   SELE FNCS
   UNLOCK                                          // libera o registro
   LOOP                                            // e recebe chave novamente
  ENDI
 #endi

 IF aprov_reg_                                     // se vai aproveitar reg excluido

  #ifdef COM_REDE
   BLOREG(0,.5)
  #endi

  RECA                                             // excluido, vamos recupera-lo
 ELSE                                              // caso contrario
  APPEND BLANK                                     // inclui reg em branco no dbf
 ENDI
 FOR i=1 TO FCOU()                                 // para cada campo,
  msg=FIEL(i)                                      // salva o conteudo
  rep[i]=M->&msg.                                  // para repetir
  REPL &msg. WITH rep[i]                           // enche o campo do arquivo
 NEXT

 #ifdef COM_REDE
  UNLOCK                                           // libera o registro e
  COMMIT                                           // forca gravacao
 #else
  IF RECC()-INT(RECC()/20)*20=0                    // a cada 20 registros
   COMMIT                                          // digitados forca gravacao
  ENDI
 #endi

 ult_reg=RECN()                                    // ultimo registro digitado
 IF reg_cop!=NIL                                   // estava na consulta e quis rep o campo
  sq_atual_=NIL
  EXIT                                             // cai fora...
 ENDI
ENDD

#ifdef COM_REDE
 FNC_ANT_SEQ()                                     // restaura sequencial anterior
 SELE FNCS
#endi

GO ult_reg                                         // para o ultimo reg digitado
SETKEY(K_F3,t_f3_)                                 // restaura teclas de funcoes
SETKEY(K_F4,t_f4_)
SET(_SET_DELETED,dele_atu)                            // ecluidos visiveis/invisiveis
SETKEY(K_CTRL_W,ctl_w)
SETKEY(K_CTRL_C,ctl_c)
SETKEY(K_CTRL_R,ctl_r)
RETU



#ifdef COM_REDE
 PROC FNC_ANT_SEQ(est_seq)     // restaura sequencial anterior
 SELE FNC_SEQ     // seleciona arquivo de controle de sequencial
 BLOARQ(0,.5)     // esta estacao foi a ultima a incluir?
 IF sq_atual_ == codigo
  REPL codigo WITH sq_codigo
 ENDI
 UNLOCK           // libera DBF para outros usuarios
 COMMIT           // atualiza cps sequenciais no disco
 RETU
#endi


PROC FNC_CRIA_SEQ   // cria dbf de controle de campos sequenciais
LOCAL dbfseq_:=sistema[op_sis,O_ARQUI,O_DIR_DBF]+"FNC_seq" // arq temporario
SELE 0                          // seleciona area vazia
IF !FILE(dbfseq_+".dbf")        // se o dbf nao existe
 DBCREATE(dbfseq_,{;            // vamos criar a sua estrutura
                    {"codigo"    ,"C",  3, 0};
                  };
 )
ENDI
USEARQ(dbfseq_,.f.,,,.f.)       // abre arquivo de cps sequencial
IF RECC()=0                     // se o dbf foi criado agora
 BLOARQ(0,.5)                   // inclui um registro que tera
 APPEND BLANK                   // os ultomos cps sequenciais
 SELE FNCS
 IF RECC()>0                    // se o DBF nao estiver
  SET ORDER TO 0                // vazio, entao enche DBF seq
  GO BOTT                       // com o ultimo reg digitado
  REPL FNC_SEQ->codigo WITH codigo
  DBSETORDER(1)                 // retorna ao indice principal
 ENDI
 SELE FNC_SEQ                   // seleciona arq de sequencias
 UNLOCK                         // libera DBF para outros usuarios
 COMMIT                         // atualiza cps sequenciais no disco
ENDI
RETURN

PROC FNC_GERA_SEQ()

#ifdef COM_REDE
 LOCAL ar_:=SELEC()
#else
 LOCAL reg_:=RECNO(),ord_ind:=INDEXORD()
#endi


#ifdef COM_REDE
 SELE FNC_SEQ
 BLOARQ(0,.5)
 sq_codigo=FNC_SEQ->codigo
#else
 DBSETORDER(0)
 GO BOTT
#endi

M->codigo=PADR(ALLTRIM(STR(VAL(codigo)+1)),3)

#ifdef COM_REDE
 FNC_GRAVA_SEQ()
 sq_atual_=FNC_SEQ->codigo
 UNLOCK                                            // libera o registro
 COMMIT
 SELE (ar_)
#else
 DBSETORDER(ord_ind)
 GO reg_
#endi

RETU

PROC FNC_GRAVA_SEQ
REPL codigo WITH M->codigo
RETU

PROC FNC_tela     // tela do arquivo FNCS
tem_borda=.t.
l_s=Sistema[op_sis,O_TELA,O_LS]           // coordenadas da tela
c_s=Sistema[op_sis,O_TELA,O_CS]
l_i=Sistema[op_sis,O_TELA,O_LI]
c_i=Sistema[op_sis,O_TELA,O_CI]
SETCOLOR(drvtittel)
vr_memo=NOVAPOSI(@l_s,@c_s,@l_i,@c_i)     // pega posicao atual da tela
CAIXA(mold,l_s,c_s,l_i,c_i)               // monta caixa da tela
i=LEN(sistema[op_sis,O_MENS])/2
@ l_s,c_s-1+(c_i-c_s+1)/2-i SAY " "+MAIUSC(sistema[op_sis,O_MENS])+" "
SETCOLOR(drvcortel)
@ l_s+01,c_s+1 SAY " C¢digo..:       Nome..:"
@ l_s+02,c_s+1 SAY " Fun‡„o..:                     Nacionalidade:"
@ l_s+03,c_s+1 SAY " E.Civil.:                     Nascimento...:"
@ l_s+04,c_s+1 SAY " Endere‡o:"
@ l_s+05,c_s+1 SAY " Bairro..:"
@ l_s+06,c_s+1 SAY " Cidade..:"
@ l_s+07,c_s+1 SAY " CPF.....:                     Telefone.....:"
@ l_s+08,c_s+1 SAY " Comiss„o:      %"
RETU

PROC FNC_gets     // mostra variaveis do arquivo FNCS
LOCAL getlist := {}, t_f7_
FNC_TELA()
SETCOLOR(drvcortel+","+drvcorget+",,,"+corcampo)
@ l_s+01 ,c_s+12 GET  codigo

@ l_s+01 ,c_s+26 GET  nome;
                 PICT sistema[op_sis,O_CAMPO,02,O_MASC]

@ l_s+02 ,c_s+12 GET  profiss;
                 PICT sistema[op_sis,O_CAMPO,03,O_MASC]

@ l_s+02 ,c_s+47 GET  nacional;
                 PICT sistema[op_sis,O_CAMPO,04,O_MASC]

@ l_s+03 ,c_s+12 GET  estciv;
                 PICT sistema[op_sis,O_CAMPO,05,O_MASC]
                 CRIT(sistema[op_sis,O_CAMPO,05,O_CRIT],,"1")

@ l_s+03 ,c_s+47 GET  nascto_;
                 PICT sistema[op_sis,O_CAMPO,06,O_MASC]

@ l_s+04 ,c_s+12 GET  endereco;
                 PICT sistema[op_sis,O_CAMPO,07,O_MASC]

@ l_s+05 ,c_s+12 GET  bairro;
                 PICT sistema[op_sis,O_CAMPO,08,O_MASC]

@ l_s+06 ,c_s+12 GET  cidade;
                 PICT sistema[op_sis,O_CAMPO,09,O_MASC]

@ l_s+07 ,c_s+12 GET  cpf;
                 PICT sistema[op_sis,O_CAMPO,10,O_MASC]

@ l_s+07 ,c_s+47 GET  telefone

@ l_s+08 ,c_s+12 GET  percent;
                 PICT sistema[op_sis,O_CAMPO,12,O_MASC]

CLEAR GETS
RETU

PROC FNC_get1(tp_mov)     // capta variaveis do arquivo FNCS
LOCAL getlist := {}, t_f7_
PRIV  blk_fncs:=.t.

IF tp_mov=INCLUI
 DO WHILE .t.
  rola_t=.f.
  memo13:="{F7}"
  t_f7_=SETKEY(K_F7,{||FNC_memo()})
  SET KEY K_ALT_F8 TO ROLATELA
  SETCOLOR(drvcortel+","+drvcorget+",,,"+corcampo)
  @ l_s+01 ,c_s+26 GET  nome;
                   PICT sistema[op_sis,O_CAMPO,02,O_MASC]
                   DEFINICAO 2

  @ l_s+02 ,c_s+12 GET  profiss;
                   PICT sistema[op_sis,O_CAMPO,03,O_MASC]
                   DEFINICAO 3

  @ l_s+02 ,c_s+47 GET  nacional;
                   PICT sistema[op_sis,O_CAMPO,04,O_MASC]
                   DEFINICAO 4

  @ l_s+03 ,c_s+12 GET  estciv;
                   PICT sistema[op_sis,O_CAMPO,05,O_MASC]
                   DEFINICAO 5
                   MOSTRA sistema[op_sis,O_FORMULA,1]

  @ l_s+03 ,c_s+47 GET  nascto_;
                   PICT sistema[op_sis,O_CAMPO,06,O_MASC]
                   DEFINICAO 6

  @ l_s+04 ,c_s+12 GET  endereco;
                   PICT sistema[op_sis,O_CAMPO,07,O_MASC]
                   DEFINICAO 7

  @ l_s+05 ,c_s+12 GET  bairro;
                   PICT sistema[op_sis,O_CAMPO,08,O_MASC]
                   DEFINICAO 8

  @ l_s+06 ,c_s+12 GET  cidade;
                   PICT sistema[op_sis,O_CAMPO,09,O_MASC]
                   DEFINICAO 9

  @ l_s+07 ,c_s+12 GET  cpf;
                   PICT sistema[op_sis,O_CAMPO,10,O_MASC]
                   DEFINICAO 10

  @ l_s+07 ,c_s+47 GET  telefone
                   DEFINICAO 11

  @ l_s+08 ,c_s+12 GET  percent;
                   PICT sistema[op_sis,O_CAMPO,12,O_MASC]
                   DEFINICAO 12

  READ
  SETKEY(K_F7,t_f7_)
  SET KEY K_ALT_F8 TO
  IF rola_t
   ROLATELA()
   LOOP
  ENDI
  IF LASTKEY()!=K_ESC .AND. drvincl .AND. op_menu=INCLUSAO
   IF !CONFINCL()
    LOOP
   ENDI
  ENDI
  EXIT
 ENDD
ENDI
IF tp_mov=EXCLUI .OR. tp_mov=FORM_INVERSA
 DELE
ELSEIF tp_mov=INCLUI .OR. tp_mov=RECUPERA .OR. tp_mov=FORM_DIRETA
 IF op_menu!=INCLUSAO
  RECA
 ENDI
ENDI
RETU

PROC FNC_MEMO
IF READVAR()="MEMO13"
 EDIMEMO("obs",sistema[op_sis,O_CAMPO,13,O_TITU],14,2,23,38)
ENDI
RETU

* \\ Final de FNCS.PRG
procedure mensag
/*
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
 \ Empresa.: PresServ Inform tica - Limeira (019)452.6623
 \ Programa: MENSAG.PRG
 \ Data....: 04-11-03
 \ Sistema.: Administradora - RECEP€„O
 \ Funcao..: Gerenciador do subsistema de mensagem p/contrato
 \ Analista: Ademilson Pedro Bom
 \ Criacao.: GAS-Pro v4.0n
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/

#include "adrbig.ch"    // inicializa constantes manifestas

PARA lin_menu,col_menu
PRIV op_sis, tela_fundo:=SAVESCREEN(0,0,MAXROW(),79), l_s, c_s, l_i, c_i, l_a

op_sis=EVAL(qualsis,"MENSAG")
IF nivelop<sistema[op_sis,O_OUTROS,O_NIVEL]        // se usuario nao tem permissao,
 ALERTA()                                          // entao, beep, beep, beep
 DBOX(msg_auto,,,3)                                // lamentamos e
 RETU                                              // retornamos ao menu
ENDI
cn:=fgrep :=.f.

#ifdef COM_LOCK
 IF LEN(pr_ok)>0                                   // se a protecao acusou
  ? pr_ok                                          // erro, avisa e
  QUIT                                             // encerra a aplicacao
 ENDI
#endi

t_fundo=SAVESCREEN(0,0,MAXROW(),79)                // salva tela do fundo
op_cad=1
DO WHIL op_cad!=0
 criterio=""
 RESTSCREEN(0,0,MAXROW(),79,t_fundo)               // restaura tela do fundo
 cod_sos=5 ; cn=.f.
 CLEA TYPEAHEAD                                    // limpa o buffer do teclado
 fgrep=.f.
 SET KEY K_F3 TO                                   // retira das teclas F3 e F4 as
 SET KEY K_F4 TO                                   // funcoes de repeticao e confirmacao
 msg="Inclus„o~1|"+;                               // menu do subsistema
     "Manuten‡„o~2|"+;
     "Consulta~3"
 op_cad=DBOX(msg,lin_menu,col_menu,E_MENU,NAO_APAGA,MAIUSC(sistema[op_sis,O_MENU]),,,op_cad)
 IF op_cad!=0                                      // se escolheu uma opcao
  Tela_fundo=SAVESCREEN(0,0,MAXROW(),79)           // salva a tela para ROLATELA()
  PARAMETROS(dbfparam)
  SELE A                                           // e abre o arquivo e seus indices

  #ifdef COM_REDE
   IF !USEARQ(sistema[op_sis,O_ARQUI,O_NOME],.f.,20,1)
                                                   // se falhou a abertura do
    RETU                                           // arquivo volta ao menu anterior
   ENDI
  #else
   USEARQ(sistema[op_sis,O_ARQUI,O_NOME])
  #endi

  SET KEY K_F9 TO veoutros                         // habilita consulta em outros arquivos
 ENDI
 DO CASE
  CASE op_cad=01                                   // inclus„o
   op_menu=INCLUSAO
   IF AT("D",exrot[op_sis])=0                      // se usuario pode fazer inclusao
    MEN_INCL()                                     // neste arquivo chama prg de inclusao
   ELSE                                            // caso contrario vamos avisar que
    ALERTA()                                       // ele nao tem permissao para isto
    DBOX(msg_auto,,,3)
   ENDI

  CASE op_cad=02                                   // manuten‡„o
   op_menu=ALTERACAO
   cod_sos=7
   EDIT()

  CASE op_cad=03                                   // consulta
   op_menu=PROJECOES
   cod_sos=8
   EDITA(03,03,MAXROW()-2,77)

 ENDC
 SET KEY K_F9 TO                                   // F9 nao mais consultara outros arquivos
 CLOS ALL                                          // fecha todos arquivos abertos
ENDD
RETU

PROC MEN_incl(reg_cop)  // inclusao no arquivo MENSAG
LOCAL getlist:={},cabem:=1,rep:=ARRAY(FCOU()),ult_reg:=RECN(),dbfseq_,;
      ctl_r, ctl_c, ctl_w, t_f3_, t_f4_, dele_atu:=SET(_SET_DELETED,.f.)
PRIV op_menu:=INCLUSAO, sq_atual_, tem_borda, criterio:="", cpord:=""
FOR i=1 TO FCOU()                                  // cria/declara privadas as
 msg=FIEL(i)                                       // variaveis de memoria com
 PRIV &msg.                                        // o mesmo nome dos campos
NEXT                                               // do arquivo
IF reg_cop!=NIL                                    // quer repetir todo o reg atual
 FOR i=1 TO FCOU()                                 // para cada campo,
  msg=FIEL(i)                                      // salva o conteudo
  rep[i]=&msg.                                     // para repetir
 NEXT
ELSE
 AFILL(rep,"")                                     // eche com valor vazio
ENDI
t_f3_=SETKEY(K_F3,{||rep()})                       // repeticao reg anterior
t_f4_=SETKEY(K_F4,{||conf()})                      // confirma campos com ENTER
ctl_w=SETKEY(K_CTRL_W,{||nadafaz()})               // enganando o CA-Clipper...
ctl_c=SETKEY(K_CTRL_C,{||nadafaz()})
ctl_r=SETKEY(K_CTRL_R,{||nadafaz()})

#ifdef COM_REDE
 MEN_CRIA_SEQ()                                    // cria dbf de controle de cp sequenciais
 FOR i=1 TO FCOU()                                 // cria/declara privadas as
  msg="sq_"+FIEL(i)                                // variaveis de memoria com
  PRIV &msg.                                       // o mesmo nome dos campos
 NEXT                                              // do arquivo com extensao _seq
#endi

DO WHIL cabem>0
 cod_sos=6
 rola_t=.f.                                        // flag se quer rolar a tela
 SELE MENSAG
 GO BOTT                                           // forca o
 SKIP                                              // final do arquivo
 
 /*
    cria variaveis de memoria identicas as de arquivo, para inclusao
    de registros
 */
 FOR i=1 TO FCOU()
  msg=FIEL(i)
  M->&msg.=IF((fgrep .OR. reg_cop!=NIL).AND.!EMPT(rep[1]),rep[i],&msg.)
 NEXT
 DISPBEGIN()                                       // apresenta a tela de uma vez so
 MEN_TELA()
 INFOSIS(.t.)                                      // exibe informacao no rodape' da tela
 DISPEND()
 MEN_GERA_SEQ()
 cabem=DISKSPACE(;
          IF(;
             LEN(sistema[op_sis,O_ARQUI,O_DIR_DBF])<2.OR.sistema[op_sis,O_ARQUI,O_DIR_DBF]="\",;
             0,;
             ASC(sistema[op_sis,O_ARQUI,O_DIR_DBF])-64;
          );
       )
 cabem=INT((cabem-2048)/MENSAG->(RECSIZE()))
 IF cabem<1                                        // mais nenhum!!!
  ALERTA()
  msg="Verifique ESPA€O EM DISCO, "+usuario
  DBOX(msg,,,,,"INCLUSŽO INTERROMPIDA!")           // vamos parar por aqui!
  EXIT
 ENDI
 SELE 0                                            // torna visiveis variaveis de memoria
 SETCOLOR(drvcortel+","+drvcorget+",,,"+corcampo)
 SET KEY K_ALT_F8 TO ROLATELA
 
 /*
    recebe chaves do arquivo de indice basico
 */
 @ l_s+01 ,c_s+12 GET  seq;
                  PICT sistema[op_sis,O_CAMPO,01,O_MASC]
                  DEFINICAO 1

 READ
 SET KEY K_ALT_F8 TO
 IF rola_t
  ROLATELA()

  #ifdef COM_REDE
   MEN_ANT_SEQ()                                   // decrementa sequencial
  #endi

  LOOP
 ENDI
 SELE MENSAG
 IF LASTKEY()=K_ESC                                // cancelou ou chave em branco
  cabem=0                                          // prepara saida da inclusao
  LOOP                                             // volta p/ menu de cadastramento
 ENDI
 SEEK M->seq
 aprov_reg_=(FOUND().AND.DELE().AND.!drvvisivel)   // vai aproveitar o registro?
 IF FOUND() .AND. !aprov_reg_                      // pesquisou e achou!
  op_menu=ALTERACAO                                // seta flag de ateracao

  #ifdef COM_REDE
   MEN_ANT_SEQ()                                   // decrementa sequencial
   SELE MENSAG
  #endi

  DISPBEGIN()
  MEN_GETS()                                       // mostra conteudo do registro
  INFOSIS(.f.)                                     // exibe informacao no rodape' da tela
  DISPEND()
  ALERTA()
  msg="Consultar/alterar|Retornar … inclus„o"      // pergunta se deseja
  op_=DBOX(msg,,,E_MENU,,"REGISTRO J EXISTE")     // alterar o registro
  IF op_ =1                                        // caso afirmativo
   EDIT()                                          // deixa alterar
  ENDI
  op_menu=INCLUSAO
  LOOP                                             // volta para inclusao
 ENDI
 SELE 0
 MEN_GET1(INCLUI)                                  // recebe campos
 SELE MENSAG
 IF LASTKEY()=K_ESC                                // se cancelou

  #ifdef COM_REDE
   MEN_ANT_SEQ()                                   // decrementa sequencial
  #endi

  ALERTA()                                         // avisa que o registro
  DBOX("Registro n„o inclu¡do!",18,,1)             // nao foi incluido, e volta
  LOOP
 ENDI

 #ifdef COM_REDE
  GO BOTT                                          // vamos bloquear o final do
  SKIP                                             // arq para que nehum outro
  BLOREG(0,.5)                                     // usuario possa incluir
  SEEK M->seq                                      // se registro foi incluido
  aprov_reg_=(FOUND().AND.DELE().AND.!drvvisivel)  // vai aproveitar o registro?
  IF FOUND() .AND. !aprov_reg_                     // por outro usuario, entao
   BLOREG(0,.5)
   FOR i=1 TO FCOU()
    msg=FIEL(i)
    rep[i]=&msg.
    REPL &msg. WITH M->&msg.
   NEXT
   MEN_GET1(FORM_INVERSA)                          // executa formula inversa
   RECA
   FOR i=1 TO FCOU()
    msg=FIEL(i)
    REPL &msg. WITH rep[i]
   NEXT
   ALERTA(4)                                       // beep 4 vezes
   msg="Registro acabou de ser|inclu¡do por outro usu rio!"
   DBOX(msg,,,,,"ATEN€ŽO!")                        // avisa
   SELE MENSAG
   UNLOCK                                          // libera o registro
   LOOP                                            // e recebe chave novamente
  ENDI
 #endi

 IF aprov_reg_                                     // se vai aproveitar reg excluido

  #ifdef COM_REDE
   BLOREG(0,.5)
  #endi

  RECA                                             // excluido, vamos recupera-lo
 ELSE                                              // caso contrario
  APPEND BLANK                                     // inclui reg em branco no dbf
 ENDI
 FOR i=1 TO FCOU()                                 // para cada campo,
  msg=FIEL(i)                                      // salva o conteudo
  rep[i]=M->&msg.                                  // para repetir
  REPL &msg. WITH rep[i]                           // enche o campo do arquivo
 NEXT

 #ifdef COM_REDE
  UNLOCK                                           // libera o registro e
  COMMIT                                           // forca gravacao
 #else
  IF RECC()-INT(RECC()/20)*20=0                    // a cada 20 registros
   COMMIT                                          // digitados forca gravacao
  ENDI
 #endi

 ult_reg=RECN()                                    // ultimo registro digitado
 IF reg_cop!=NIL                                   // estava na consulta e quis rep o campo
  sq_atual_=NIL
  EXIT                                             // cai fora...
 ENDI
ENDD

#ifdef COM_REDE
 MEN_ANT_SEQ()                                     // restaura sequencial anterior
 SELE MENSAG
#endi

GO ult_reg                                         // para o ultimo reg digitado
SETKEY(K_F3,t_f3_)                                 // restaura teclas de funcoes
SETKEY(K_F4,t_f4_)
SET(_SET_DELETED,dele_atu)                            // ecluidos visiveis/invisiveis
SETKEY(K_CTRL_W,ctl_w)
SETKEY(K_CTRL_C,ctl_c)
SETKEY(K_CTRL_R,ctl_r)
RETU



#ifdef COM_REDE
 PROC MEN_ANT_SEQ(est_seq)     // restaura sequencial anterior
 SELE MEN_SEQ     // seleciona arquivo de controle de sequencial
 BLOARQ(0,.5)     // esta estacao foi a ultima a incluir?
 IF sq_atual_ == seq
  REPL seq WITH sq_seq
 ENDI
 UNLOCK           // libera DBF para outros usuarios
 COMMIT           // atualiza cps sequenciais no disco
 RETU
#endi


PROC MEN_CRIA_SEQ   // cria dbf de controle de campos sequenciais
LOCAL dbfseq_:=sistema[op_sis,O_ARQUI,O_DIR_DBF]+"MEN_seq" // arq temporario
SELE 0                          // seleciona area vazia
IF !FILE(dbfseq_+".dbf")        // se o dbf nao existe
 DBCREATE(dbfseq_,{;            // vamos criar a sua estrutura
                    {"seq"       ,"C",  6, 0};
                  };
 )
ENDI
USEARQ(dbfseq_,.f.,,,.f.)       // abre arquivo de cps sequencial
IF RECC()=0                     // se o dbf foi criado agora
 BLOARQ(0,.5)                   // inclui um registro que tera
 APPEND BLANK                   // os ultomos cps sequenciais
 SELE MENSAG
 IF RECC()>0                    // se o DBF nao estiver
  SET ORDER TO 0                // vazio, entao enche DBF seq
  GO BOTT                       // com o ultimo reg digitado
  REPL MEN_SEQ->seq WITH seq
  DBSETORDER(1)                 // retorna ao indice principal
 ENDI
 SELE MEN_SEQ                   // seleciona arq de sequencias
 UNLOCK                         // libera DBF para outros usuarios
 COMMIT                         // atualiza cps sequenciais no disco
ENDI
RETURN

PROC MEN_GERA_SEQ()

#ifdef COM_REDE
 LOCAL ar_:=SELEC()
#else
 LOCAL reg_:=RECNO(),ord_ind:=INDEXORD()
#endi


#ifdef COM_REDE
 SELE MEN_SEQ
 BLOARQ(0,.5)
 sq_seq=MEN_SEQ->seq
#else
 DBSETORDER(0)
 GO BOTT
#endi

M->seq=LPAD(STR(VAL(seq)+1),06,[0])

#ifdef COM_REDE
 MEN_GRAVA_SEQ()
 sq_atual_=MEN_SEQ->seq
 UNLOCK                                            // libera o registro
 COMMIT
 SELE (ar_)
#else
 DBSETORDER(ord_ind)
 GO reg_
#endi

RETU

PROC MEN_GRAVA_SEQ
REPL seq WITH M->seq
RETU

PROC MEN_tela     // tela do arquivo MENSAG
tem_borda=.t.
l_s=Sistema[op_sis,O_TELA,O_LS]           // coordenadas da tela
c_s=Sistema[op_sis,O_TELA,O_CS]
l_i=Sistema[op_sis,O_TELA,O_LI]
c_i=Sistema[op_sis,O_TELA,O_CI]
SETCOLOR(drvtittel)
vr_memo=NOVAPOSI(@l_s,@c_s,@l_i,@c_i)     // pega posicao atual da tela
CAIXA(mold,l_s,c_s,l_i,c_i)               // monta caixa da tela
i=LEN(sistema[op_sis,O_MENS])/2
@ l_s,c_s-1+(c_i-c_s+1)/2-i SAY " "+MAIUSC(sistema[op_sis,O_MENS])+" "
SETCOLOR(drvcortel)
@ l_s+01,c_s+1 SAY " N£mero..:                           (                      )"
@ l_s+02,c_s+1 SAY " Condi‡„o:"
@ l_s+03,c_s+1 SAY " Mensagem:"
RETU

PROC MEN_gets     // mostra variaveis do arquivo MENSAG
LOCAL getlist := {}, t_f7_
MEN_TELA()
SETCOLOR(drvcortel+","+drvcorget+",,,"+corcampo)
CRIT("",,"1|7")
@ l_s+01 ,c_s+12 GET  seq;
                 PICT sistema[op_sis,O_CAMPO,01,O_MASC]

@ l_s+02 ,c_s+12 GET  filtro;
                 PICT sistema[op_sis,O_CAMPO,02,O_MASC]

@ l_s+03 ,c_s+12 SAY "{M} "

CRIT("",,"2|3|4|5|6")
CLEAR GETS
RETU

PROC MEN_get1(tp_mov)     // capta variaveis do arquivo MENSAG
LOCAL getlist := {}, t_f7_
PRIV  blk_mensag:=.t.

IF tp_mov=INCLUI
 DO WHILE .t.
  rola_t=.f.
  memo03:="{F7}"
  t_f7_=SETKEY(K_F7,{||MEN_memo()})
  SET KEY K_ALT_F8 TO ROLATELA
  SETCOLOR(drvcortel+","+drvcorget+",,,"+corcampo)
  CRIT("",,"1|7")
  @ l_s+02 ,c_s+12 GET  filtro;
                   PICT sistema[op_sis,O_CAMPO,02,O_MASC]
                   DEFINICAO 2

  @ l_s+03 ,c_s+12 GET  memo03;
                   PICT "@!"
                   DEFINICAO 3

  READ
  SETKEY(K_F7,t_f7_)
  SET KEY K_ALT_F8 TO
  IF rola_t
   ROLATELA()
   LOOP
  ENDI
  IF LASTKEY()!=K_ESC .AND. drvincl .AND. op_menu=INCLUSAO
   IF !CONFINCL()
    LOOP
   ENDI
  ENDI
  EXIT
 ENDD
ENDI
IF tp_mov=EXCLUI .OR. tp_mov=FORM_INVERSA
 IF !EMPTY(ALIAS())
  DELE
 ENDI
ELSEIF tp_mov=INCLUI .OR. tp_mov=RECUPERA .OR. tp_mov=FORM_DIRETA
 IF (op_menu=INCLUSAO .AND. LASTKEY()!=K_ESC) .OR. op_menu!=INCLUSAO
   IF EMPT(lancto_)
    IF op_menu=INCLUSAO
     por=M->usuario
    ELSE
     REPL por WITH M->usuario
    ENDI
   ENDI
   IF EMPT(lancto_)
    IF op_menu=INCLUSAO
     lancto_=DATE()
    ELSE
     REPL lancto_ WITH DATE()
    ENDI
   ENDI
  IF op_menu!=INCLUSAO
   RECA
  ENDI
 ENDI
ENDI
RETU

PROC MEN_MEMO
IF READVAR()="MEMO03"
 EDIMEMO("mens1",sistema[op_sis,O_CAMPO,03,O_TITU],14,2,23,53)
ENDI
RETU

* \\ Final de MENSAG.PRG
procedure con_p003
/*
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
 \ Empresa.: PresServ Inform tica - Limeira (019)452.6623
 \ Programa: CON_P003.PRG
 \ Data....: 31-12-98
 \ Sistema.: Controle de Convˆnios
 \ Funcao..: Contagem
 \ Analista: Ademilson Pedro Bom
 \ Criacao.: GAS-Pro v3.0
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/

#include "adrbig.ch"    // inicializa constantes manifestas

LOCAL dele_atu, getlist:={}
PARA  lin_menu, col_menu
PRIV  tem_borda:=.t., op_menu:=VAR_COMPL, l_s:=8, c_s:=17, l_i:=16, c_i:=66, tela_fundo:=SAVESCREEN(0,0,MAXROW(),79)
nucop=1
SETCOLOR(drvtittel)
vr_memo=NOVAPOSI(@l_s,@c_s,@l_i,@c_i)     // pega posicao atual da tela
CAIXA(mold,l_s,c_s,l_i,c_i)               // monta caixa da tela
@ l_s,c_s+21 SAY " RANKING "
SETCOLOR(drvcortel)
@ l_s+01,c_s+1 SAY " Contrato.: De:            At‚:"
@ l_s+02,c_s+1 SAY " Per¡odo..: De:            At‚:"
@ l_s+03,c_s+1 SAY " Regi„o...: "
@ l_s+04,c_s+1 SAY " Confirme:"
rde=CTOD('')                                       // De:
rate=CTOD('')                                      // At‚:
rregiao:=[000]
rcodi:=rcodf:=[      ]
confirme=SPAC(1)                                   // Confirme
DO WHILE .t.
 rola_t=.f.
 cod_sos=56
 SET KEY K_ALT_F8 TO ROLATELA
 SETCOLOR(drvcortel+","+drvcorget+",,,"+corcampo)
 @ l_s+01 ,c_s+17 GET  rcodi;
                  PICT "999999";
                  VALI CRIT("!EMPT(rcodi)~Informe o numero do menor contrato a considerar")

 @ l_s+01 ,c_s+33 GET  rcodf;
                  PICT "999999";
                  VALI CRIT("!EMPT(rcodf)~Informe o numero do maior contrato a considerar")

 @ l_s+02 ,c_s+17 GET  rde;
                  PICT "@D";
                  VALI CRIT("!EMPT(rde)~Necess rio informar a data inicial a considerar")
                  DEFAULT "DATE()-DAY(DATE())+1"
                  AJUDA "Informe a data inicial a considerar"

 @ l_s+02 ,c_s+33 GET  rate;
                  PICT "@D";
                  VALI CRIT("!EMPT(rate)~Necess rio informar AT:")
                  DEFAULT "DATE()"
                  AJUDA "Informe a data final a considerar"

 @ l_s+03 ,c_s+17 GET  rregiao;
                  PICT "999";
                  VALI CRIT("!EMPT(rregiao)~Informe a regi„o a considerar")

 @ l_s+04 ,c_s+12 GET  confirme;
                  PICT "!";
                  VALI CRIT("confirme= 'S'~CONFIRME n„o aceit vel|Digite S ou Tecle ESC")
                  AJUDA "Digite S para confirmar |ou|Tecle ESC para cancelar"

 READ
 SET KEY K_ALT_F8 TO
 IF rola_t
  ROLATELA(.f.)
  LOOP
 ENDI
 IF LASTKEY()=K_ESC                                // se quer cancelar
  RETU                                             // retorna
 ENDI
 EXIT
ENDD
cod_sos=1
msgt="CONTAGEM"
//ALERTA()
op_=1 //DBOX("Prosseguir|Cancelar opera‡„o",,,E_MENU,,msgt)
IF op_=1
// DBOX("Processando registros",,,,NAO_APAGA,"AGUARDE!")
 dele_atu:=SET(_SET_DELETED,.t.)                   // os excluidos nao servem...

 #ifdef COM_REDE
  IF !USEARQ("MEDICOS",.t.,10,1)                   // se falhou a abertura do arq
   RETU                                            // volta ao menu anterior
  ENDI
 #else
  USEARQ("MEDICOS")                                // abre o dbf e seus indices
 #endi

 criterio:=cpord := ""                             // inicializa variaveis
 chv_rela:=chv_1:=chv_2 := ""
 SELE MEDICOS                                      // processamentos apos emissao
 INI_ARQ()                                         // acha 1o. reg valido do arquivo
 DO WHIL !EOF()

  #ifdef COM_REDE
   REPBLO('MEDICOS->numconta',{||[ ]})
  #else
   REPL MEDICOS->numconta WITH [          ]
  #endi

  SKIP                                             // pega proximo registro
 ENDD

 #ifdef COM_REDE
  IF !USEARQ("GUIAS",.F.,10,1)                     // se falhou a abertura do arq
   RETU                                            // volta ao menu anterior
  ENDI
 #else
  USEARQ("GUIAS")                                  // abre o dbf e seus indices
 #endi

 PTAB(medico,"MEDICOS",1,.t.)                      // abre arquivo p/ o relacionamento
 PTAB(contrato,"GRUPOS",1,.t.)                      // abre arquivo p/ o relacionamento
 SET RELA TO medico INTO MEDICOS                   // relacionamento dos arquivos
 criterio:=cpord := ""                             // inicializa variaveis
 chv_rela:=chv_1:=chv_2 := ""
 SELE GUIAS                                        // processamentos apos emissao
 go top
 skip -1
 odometer(reccount(),18,15)
 INI_ARQ()                                         // acha 1o. reg valido do arquivo
 DO WHIL !EOF() .and. odometer()
  IF M->rcodi>[000000].and.contrato<M->rcodi
   SKIP
   LOOP
  ENDI
  IF M->rcodf>[000000].and.contrato>M->rcodf
   SKIP
   LOOP
  ENDI

  PTAB(contrato,"GRUPOS",1,.t.)                      // abre arquivo p/ o relacionamento
  IF M->rregiao>[000].and.GRUPOS->regiao#M->rregiao
   SKIP
   LOOP
  ENDI
  IF emissao_>=M->rde.and.emissao_<=M->rate        // se atender a condicao...
   SELE MEDICOS
   RLOCK()
   #ifdef COM_REDE
    REPBLO('MEDICOS->numconta',{||STR(VAL(MEDICOS->numconta)+1,6)})
   #else
    REPL MEDICOS->numconta WITH STR(VAL(MEDICOS->numconta)+1,6)
   #endi

   SELE GUIAS
   SKIP                                            // pega proximo registro
  ELSE                                             // se nao atende condicao
   SKIP                                            // pega proximo registro
  ENDI
 ENDD
 SELE GUIAS                                        // salta pagina
 SET RELA TO                                       // retira os relacionamentos
 SET(_SET_DELETED,dele_atu)                        // os excluidos serao vistos
 ALERTA(2)
// DBOX("Processo terminado com sucesso!",,,,,msgt)
ENDI
CLOSE ALL                                          // fecha todos os arquivos e
RETU                                               // volta para o menu anterior

* \\ Final de CON_P003.PRG
procedure ins_02f9
/*
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
 \ Empresa.: PresServ Inform tica-Limeira (019)452.6623
 \ Programa: INS_02F9.PRG
 \ Data....: 31-03-97
 \ Sistema.: Administradora - PLANO
 \ Funcao..: Valida‡„o do campo NASCTO_, arquivo INSCRITS
 \ Analista: Ademilson Pedro Bom
 \ Criacao.: Programado manualmente pelo analista
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/

#include "adRbig.ch"    // inicializa constantes manifestas

PRIV idmes
idmes := (YEAR(DATE()) - YEAR(nascto_))*12
idmes += (MONTH(DATE()) - MONTH(nascto_))
IF op_menu=1.AND.idmes > (18*12) .AND. INSCRITS->grau>'6'
 DBOX([Inscrito com ]+STR(INT(idmes/12),2)+[ anos completos])
ENDI

RETU .T.       // <- deve retornar um valor L¢GICO


* \\ Final de INS_02F9.PRG
procedure par_adm
/*
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
 \ Empresa.: PresServ Inform tica - Limeira (019)452.6623
 \ Programa: PAR_ADM.PRG
 \ Data....: 04-11-03
 \ Sistema.: Administradora - RECEP€„O
 \ Funcao..: Gerenciador do subsistema de parƒmetros
 \ Analista: Ademilson Pedro Bom
 \ Criacao.: GAS-Pro v4.0n
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/
#include "adrbig.ch"    // inicializa constantes manifestas

PARA lin_menu,col_menu
PRIV op_sis, tela_fundo:=SAVESCREEN(0,0,MAXROW(),79), l_s, c_s, l_i, c_i, l_a

op_sis=EVAL(qualsis,"PAR_ADM")
IF nivelop<sistema[op_sis,O_OUTROS,O_NIVEL]        // se usuario nao tem permissao,
 ALERTA()                                          // entao, beep, beep, beep
 DBOX(msg_auto,,,3)                                // lamentamos e
 RETU                                              // retornamos ao menu
ENDI

#ifdef COM_LOCK
 IF LEN(pr_ok)>0                                   // se a protecao acusou
  ? pr_ok                                          // erro, avisa e
  QUIT                                             // encerra a aplicacao
 ENDI
#endi

SELE A

#ifdef COM_REDE
 IF !USEARQ(sistema[op_sis,O_ARQUI,O_NOME],.t.,20,1,.f.)
                                                   // se falhou a abertura do
  RETU                                             // arquivo volta ao menu anterior
 ENDI
#else
 USEARQ(sistema[op_sis,O_ARQUI,O_NOME],,,,.f.)
#endi

SET KEY K_F9 TO veoutros                           // habilita consulta em outros arquivos
ctl_w=SETKEY(K_CTRL_W,{||nadafaz()})               // enganando o CA-Clipper...
ctl_c=SETKEY(K_CTRL_C,{||nadafaz()})
ctl_r=SETKEY(K_CTRL_R,{||nadafaz()})
op_menu=ALTERACAO                                  // parametro e' como se fosse alteracao
cod_sos=54
rola_t=.f.                                         // flag se quer rolar a tela
SELE PAR_ADM
DISPBEGIN()                                        // monta tela na pagina de traz
PAR_TELA()
PAR_GETS()
INFOSIS(.t.)                                       // exibe informacao no rodape' da tela
DISPEND()
PAR_GET1(INCLUI)
SELE PAR_ADM
FOR i=1 TO FCOU()                                  // atualiza variaveis publicas
 msg=FIEL(i)                                       // do arquivo de parametros
 M->&msg.=&msg.
NEXT
SET KEY K_F9 TO                                    // desativa tecla F9 (veoutros)
SETKEY(K_CTRL_W,ctl_w)
SETKEY(K_CTRL_C,ctl_c)
SETKEY(K_CTRL_R,ctl_r)
RETU


PROC PAR_tela     // tela do arquivo PAR_ADM
tem_borda=.t.
l_s=Sistema[op_sis,O_TELA,O_LS]           // coordenadas da tela
c_s=Sistema[op_sis,O_TELA,O_CS]
l_i=Sistema[op_sis,O_TELA,O_LI]
c_i=Sistema[op_sis,O_TELA,O_CI]
SETCOLOR(drvtittel)
vr_memo=NOVAPOSI(@l_s,@c_s,@l_i,@c_i)     // pega posicao atual da tela
CAIXA(mold,l_s,c_s,l_i,c_i)               // monta caixa da tela
i=LEN(sistema[op_sis,O_MENS])/2
@ l_s,c_s-1+(c_i-c_s+1)/2-i SAY " "+MAIUSC(sistema[op_sis,O_MENS])+" "
SETCOLOR(drvcortel)
@ l_s+01,c_s+1 SAY " Conta Recebto.:         Conta Pagto.:"
@ l_s+02,c_s+1 SAY " H.Abertura Cx.:"
@ l_s+03,c_s+1 SAY " H.Recebimentos:"
@ l_s+04,c_s+1 SAY " H.Outros Receb:"
@ l_s+05,c_s+1 SAY " Hist.Pagamento:"
@ l_s+06,c_s+1 SAY "       ÄÄÄÄÄÄÄÄÄÄ Dados do £ltimo lan‡amento ÄÄÄÄÄÄÄÄÄÄ"
@ l_s+07,c_s+1 SAY " Grupo.:    Filial:     C¢digo:        Inscr:    Seq:"
@ l_s+08,c_s+1 SAY "       ÄÄÄÄÄÄÄÄÄÄÄÄÄ Dados de uso interno ÄÄÄÄÄÄÄÄÄÄÄÄÄ"
@ l_s+09,c_s+1 SAY " Cancelamentos:           Reintegra‡”es:"
@ l_s+10,c_s+1 SAY " Recibo 2¦ Via:           Contr.        Tipo   Circ"
@ l_s+11,c_s+1 SAY " C¢digo de Grupo para o VIP:"
@ l_s+12,c_s+1 SAY " Imprime recibo com c¢digo barra?"
@ l_s+13,c_s+1 SAY " Os Inscritos est„o cadastrados?"
@ l_s+14,c_s+1 SAY " Imprime os recibos da recep‡„o c/Falecidos?"
@ l_s+15,c_s+1 SAY " Cidade:"
@ l_s+16,c_s+1 SAY " Usar como padr„o recibos em formul rio branco?"
@ l_s+17,c_s+1 SAY "       ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ Dados da Empresa ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ"
@ l_s+18,c_s+1 SAY "                                         CGC"
RETU

PROC PAR_gets     // mostra variaveis do arquivo PAR_ADM
LOCAL getlist := {}
PAR_TELA()
SETCOLOR(drvcortel+","+drvcorget+",,,"+corcampo)
PTAB(HISTRCCAR,'HISTORIC',1)
@ l_s+07 ,c_s+10 GET  pgrupo;
                 PICT sistema[op_sis,O_CAMPO,01,O_MASC]

@ l_s+07 ,c_s+21 GET  p_filial;
                 PICT sistema[op_sis,O_CAMPO,02,O_MASC]

@ l_s+07 ,c_s+33 GET  pcontrato;
                 PICT sistema[op_sis,O_CAMPO,03,O_MASC]

@ l_s+07 ,c_s+47 GET  pgrau;
                 PICT sistema[op_sis,O_CAMPO,04,O_MASC]

@ l_s+07 ,c_s+55 GET  pseq;
                 PICT sistema[op_sis,O_CAMPO,05,O_MASC]

@ l_s+09 ,c_s+17 GET  nrcanc;
                 PICT sistema[op_sis,O_CAMPO,09,O_MASC]

@ l_s+09 ,c_s+42 GET  nrreint;
                 PICT sistema[op_sis,O_CAMPO,10,O_MASC]

@ l_s+01 ,c_s+18 GET  contarec;
                 PICT sistema[op_sis,O_CAMPO,11,O_MASC]

@ l_s+01 ,c_s+41 GET  contapag;
                 PICT sistema[op_sis,O_CAMPO,12,O_MASC]

@ l_s+02 ,c_s+18 GET  histrccar;
                 PICT sistema[op_sis,O_CAMPO,13,O_MASC]
                 CRIT(sistema[op_sis,O_CAMPO,13,O_CRIT],,"4")

@ l_s+03 ,c_s+18 GET  histrcfcc;
                 PICT sistema[op_sis,O_CAMPO,14,O_MASC]
                 CRIT(sistema[op_sis,O_CAMPO,14,O_CRIT],,"3")

@ l_s+04 ,c_s+18 GET  histrcrec;
                 PICT sistema[op_sis,O_CAMPO,15,O_MASC]
                 CRIT(sistema[op_sis,O_CAMPO,15,O_CRIT],,"2")

@ l_s+05 ,c_s+18 GET  histpg;
                 PICT sistema[op_sis,O_CAMPO,16,O_MASC]
                 CRIT(sistema[op_sis,O_CAMPO,16,O_CRIT],,"1")

@ l_s+10 ,c_s+17 GET  nrauxrec;
                 PICT sistema[op_sis,O_CAMPO,17,O_MASC]

@ l_s+10 ,c_s+34 GET  mcodigo;
                 PICT sistema[op_sis,O_CAMPO,18,O_MASC]

@ l_s+10 ,c_s+46 GET  mtipo;
                 PICT sistema[op_sis,O_CAMPO,19,O_MASC]

@ l_s+10 ,c_s+53 GET  mcirc;
                 PICT sistema[op_sis,O_CAMPO,20,O_MASC]

@ l_s+11 ,c_s+30 GET  mgrupvip;
                 PICT sistema[op_sis,O_CAMPO,21,O_MASC]

@ l_s+12 ,c_s+35 GET  combarra;
                 PICT sistema[op_sis,O_CAMPO,22,O_MASC]

@ l_s+13 ,c_s+34 GET  cinscr;
                 PICT sistema[op_sis,O_CAMPO,23,O_MASC]

@ l_s+14 ,c_s+46 GET  comfalec;
                 PICT sistema[op_sis,O_CAMPO,24,O_MASC]

@ l_s+15 ,c_s+10 GET  p_cidade;
                 PICT sistema[op_sis,O_CAMPO,34,O_MASC]

@ l_s+16 ,c_s+49 GET  p_recp;
                 PICT sistema[op_sis,O_CAMPO,35,O_MASC]

@ l_s+18 ,c_s+01 GET  setup1

@ l_s+18 ,c_s+45 GET  cgcsetup;
                 PICT sistema[op_sis,O_CAMPO,37,O_MASC]

@ l_s+19 ,c_s+09 GET  setup2

@ l_s+20 ,c_s+09 GET  setup3

CLEAR GETS
RETU

PROC PAR_get1(tp_mov)     // capta variaveis do arquivo PAR_ADM
LOCAL getlist := {}
PRIV  blk_par_adm:=.t.

IF tp_mov=INCLUI
 DO WHILE .t.
  rola_t=.f.
  SET KEY K_ALT_F8 TO ROLATELA
  SETCOLOR(drvcortel+","+drvcorget+",,,"+corcampo)
  @ l_s+07 ,c_s+21 GET  p_filial;
                   PICT sistema[op_sis,O_CAMPO,02,O_MASC]
                   DEFINICAO 2

  @ l_s+01 ,c_s+18 GET  contarec;
                   PICT sistema[op_sis,O_CAMPO,11,O_MASC]
                   DEFINICAO 11

  @ l_s+01 ,c_s+41 GET  contapag;
                   PICT sistema[op_sis,O_CAMPO,12,O_MASC]
                   DEFINICAO 12

  @ l_s+02 ,c_s+18 GET  histrccar;
                   PICT sistema[op_sis,O_CAMPO,13,O_MASC]
                   DEFINICAO 13
                   MOSTRA sistema[op_sis,O_FORMULA,4]

  @ l_s+03 ,c_s+18 GET  histrcfcc;
                   PICT sistema[op_sis,O_CAMPO,14,O_MASC]
                   DEFINICAO 14
                   MOSTRA sistema[op_sis,O_FORMULA,3]

  @ l_s+04 ,c_s+18 GET  histrcrec;
                   PICT sistema[op_sis,O_CAMPO,15,O_MASC]
                   DEFINICAO 15
                   MOSTRA sistema[op_sis,O_FORMULA,2]

  @ l_s+05 ,c_s+18 GET  histpg;
                   PICT sistema[op_sis,O_CAMPO,16,O_MASC]
                   DEFINICAO 16
                   MOSTRA sistema[op_sis,O_FORMULA,1]

  @ l_s+10 ,c_s+17 GET  nrauxrec;
                   PICT sistema[op_sis,O_CAMPO,17,O_MASC]
                   DEFINICAO 17

  @ l_s+10 ,c_s+34 GET  mcodigo;
                   PICT sistema[op_sis,O_CAMPO,18,O_MASC]
                   DEFINICAO 18

  @ l_s+10 ,c_s+46 GET  mtipo;
                   PICT sistema[op_sis,O_CAMPO,19,O_MASC]
                   DEFINICAO 19

  @ l_s+10 ,c_s+53 GET  mcirc;
                   PICT sistema[op_sis,O_CAMPO,20,O_MASC]
                   DEFINICAO 20

  @ l_s+11 ,c_s+30 GET  mgrupvip;
                   PICT sistema[op_sis,O_CAMPO,21,O_MASC]
                   DEFINICAO 21

  @ l_s+12 ,c_s+35 GET  combarra;
                   PICT sistema[op_sis,O_CAMPO,22,O_MASC]
                   DEFINICAO 22

  @ l_s+13 ,c_s+34 GET  cinscr;
                   PICT sistema[op_sis,O_CAMPO,23,O_MASC]
                   DEFINICAO 23

  @ l_s+14 ,c_s+46 GET  comfalec;
                   PICT sistema[op_sis,O_CAMPO,24,O_MASC]
                   DEFINICAO 24

  @ l_s+15 ,c_s+10 GET  p_cidade;
                   PICT sistema[op_sis,O_CAMPO,34,O_MASC]
                   DEFINICAO 34

  @ l_s+16 ,c_s+49 GET  p_recp;
                   PICT sistema[op_sis,O_CAMPO,35,O_MASC]
                   DEFINICAO 35

  @ l_s+18 ,c_s+01 GET  setup1
                   DEFINICAO 36

  @ l_s+18 ,c_s+45 GET  cgcsetup;
                   PICT sistema[op_sis,O_CAMPO,37,O_MASC]
                   DEFINICAO 37

  @ l_s+19 ,c_s+09 GET  setup2
                   DEFINICAO 38

  @ l_s+20 ,c_s+09 GET  setup3
                   DEFINICAO 39

  READ
  SET KEY K_ALT_F8 TO
  IF rola_t
   ROLATELA()
   LOOP
  ENDI
  EXIT
 ENDD
ENDI
RETU

* \\ Final de PAR_ADM.PRG
BLINKER INCREMENTAL OFF
BLINKER OVERLAY UMB ON
BLINKER OVERLAY PAGEFRAME ON
BLINKER CACHE EMS 50%
BLINKER CACHE XMS 50%
BLINKER OVE OPS 60
BLINKER EXECUTABLE CLIPPER F200
BLINKER MESSAGE NOBLINK

MAP S,A
STACK 12168

FI BX_BXREC
fi dbt
fi sixuk
fi sixcdx
fi sixtools
FI ryofilt

@CL520MID.LNK
@SIX3.LNK
procedure r00101f9
/*
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
 \ Empresa.: PresServ Inform tica - Limeira (019)452.6623
 \ Programa: R00101F9.PRG
 \ Data....: 15-10-03
 \ Sistema.: Administradora - RECEP€„O
 \ Funcao..: importante do relat¢rio CON_R001
 \ Analista: Ademilson Pedro Bom
 \ Criacao.: Programado manualmente pelo analista
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/

#include "adrbig.ch"    // inicializa constantes manifestas

/*
   -------------------------------------------------------------------
   Se abrir outros arquivos salve situacao anterior e restaure ao sair
   como no exemplo abaixo:
     LOCAL reg_dbf:=POINTER_DBF()
     ...        ...        ...        ...
     POINTER_DBF(reg_dbf)
     RETU
   -------------------------------------------------------------------
*/
msgaux:=[IMPORTANTE: Esta guia tem a finalidade principal de encaminhamento em consultas e exames.]
msgaux+=[Nao dando o direito a cirurgias, internacoes, entre outros]
RETU       // <- deve retornar um valor qualquer

* \\ Final de R00101F9.PRG
procedure adm_r022
/*
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
 \ Empresa.: PresServ Inform tica - Limeira (019)452.6623
 \ Programa: ADM_R022.PRG
 \ Data....: 04-11-03
 \ Sistema.: Administradora - RECEP€„O
 \ Funcao..: Endere‡os Alterados
 \ Analista: Ademilson Pedro Bom
 \ Criacao.: GAS-Pro v4.0n
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/

#include "adrbig.ch"    // inicializa constantes manifestas

PRIV dele_atu, cur_atual, getlist:={}
PARA lin_menu, col_menu
PRIV  tem_borda:=.t., op_menu:=VAR_COMPL, l_s:=10, c_s:=26, l_i:=14, c_i:=56, tela_fundo:=SAVESCREEN(0,0,MAXROW(),79)
nucop=1
IF nivelop < 2                                     // se usuario nao tem
 DBOX("Emiss„o negada, "+usuario,20)               // permissao, avisa
 RETU                                              // e retorna
ENDI
SETCOLOR(drvtittel)
vr_memo=NOVAPOSI(@l_s,@c_s,@l_i,@c_i)     // pega posicao atual da tela
CAIXA(mold,l_s,c_s,l_i,c_i)               // monta caixa da tela
@ l_s,c_s+5 SAY " ENDERE€OS ALTERADOS "
SETCOLOR(drvcortel)
@ l_s+01,c_s+1 SAY " Usu rio........:"
@ l_s+02,c_s+1 SAY " Lan‡to. inicial:"
@ l_s+03,c_s+1 SAY " Lan‡to. final..:"
PRIV musuario:=SPAC(10)                            // Usuario
PRIV emisini_:=CTOD('')                            // Lan‡to. inicial
PRIV emisfim_:=CTOD('')                            // Lan‡to. final
DO WHILE .t.
 rola_t=.f.
 cod_sos=56
 SET KEY K_ALT_F8 TO ROLATELA
 SETCOLOR(drvcortel+","+drvcorget+",,,"+corcampo)
 @ l_s+01 ,c_s+19 GET  musuario;
                  PICT "@!"
                  DEFAULT "M->usuario"
                  AJUDA "Informe o usu rio a listar|ou deixe sem preencher para listar todos."
                  CMDF8 "M->usuario"

 @ l_s+02 ,c_s+19 GET  emisini_;
                  PICT "@D";
                  VALI CRIT("!EMPT(emisini_).and. emisini_<=DATE()~Necess rio informar Lan‡to. inicial correta")
                  DEFAULT "DATE() - DAY(DATE()) + 1"
                  AJUDA "Informe a data inicial"

 @ l_s+03 ,c_s+19 GET  emisfim_;
                  PICT "@D";
                  VALI CRIT("!EMPT(emisfim_).and.emisfim_>=emisini_.and.emisfim_<=DATE()~Necess rio informar Lan‡to. final correta")
                  DEFAULT "DATE()"
                  AJUDA "Informe a data final"

 READ
 SET KEY K_ALT_F8 TO
 IF rola_t
  ROLATELA(.f.)
  LOOP
 ENDI
 IF LASTKEY()=K_ESC                                // se quer cancelar
  RETU                                             // retorna
 ENDI

 #ifdef COM_REDE
  IF !USEARQ("ALENDER",.f.,10,1)                   // se falhou a abertura do arq
   RETU                                            // volta ao menu anterior
  ENDI
 #else
  USEARQ("ALENDER")                                // abre o dbf e seus indices
 #endi

 PTAB(codigo,"GRUPOS",1,.t.)                       // abre arquivo p/ o relacionamento
 SET RELA TO codigo INTO GRUPOS                    // relacionamento dos arquivos
 titrel:=criterio := ""                            // inicializa variaveis
 cpord=""
 chv_rela:=chv_1:=chv_2 := ""
 tps:=op_x:=ccop := 1
 fil_ini=""
 IF !opcoes_rel(lin_menu,col_menu,11,11,fil_ini)   // nao quis configurar...
  CLOS ALL                                         // fecha arquivos e
  LOOP                                             // volta ao menu
 ENDI
 IF tps=2                                          // se vai para arquivo/video
  arq_=ARQGER()                                    // entao pega nome do arquivo
  IF EMPTY(arq_)                                   // se cancelou ou nao informou
   LOOP                                            // retorna
  ENDI
 ELSE
  arq_=drvporta                                    // porta de saida configurada
 ENDI
 IF "4WIN"$UPPER(drvmarca) // nome da configuracao/marca impressora
    arq_:=drvdbf+"WIN"+ide_maq
    tps:=3                                          // se vai para arquivo/video
 ENDIF
 SET PRINTER TO (arq_)                             // redireciona saida
 EXIT
ENDD
cur_atual=SETCURSOR(0)
dele_atu:=SET(_SET_DELETED,.t.)                    // os excluidos nao servem...
POE_GAUGE("[ESC] Interrompe","AGUARDE...","Emitidos:")
SET DEVI TO PRIN                                   // inicia a impressao
maxli=63                                           // maximo de linhas no relatorio
BEGIN SEQUENCE
 DO WHIL ccop<=nucop                               // imprime qde copias pedida
  pg_=1; cl=50000
  INI_ARQ()                                        // acha 1o. reg valido do arquivo
  IF EOF()
   EXIT
  ENDI
  ccop++                                           // incrementa contador de copias
  DO WHIL !EOF().AND.POE_GAUGE()
   IF IN_KEY()=K_ESC                               // se quer cancelar
    IF canc()                                      // pede confirmacao
     BREAK                                         // confirmou...
    ENDI
   ENDI
   IF EMPT(emitido_).AND.(EMPT(M->musuario).OR.por=M->musuario).AND.data_>=M->emisini_.AND.data_<=M->emisfim_// se atender a condicao...
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,042 SAY "³"
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY "Alterar"
    IMPCTL(drvpenf)
    IMPEXP(cl,008,dgrupo+'-'+codigo,18)            // Codigo
    IMPCTL(drvtenf)
    @ cl,028 SAY "DE:           ³ PARA:        ("
    @ cl,058 SAY por                               // Por
    @ cl,069 SAY TRAN(data_,"@D")                  // Data_
    @ cl,077 SAY ")"
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY "Ender.."
    @ cl,007 SAY dendereco                         // Endere‡o
    @ cl,042 SAY "³"
    @ cl,044 SAY endereco                          // Endere‡o
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY "Bairro."
    @ cl,007 SAY dbairro                           // Bairro
    @ cl,042 SAY "³"
    @ cl,044 SAY bairro                            // Bairro
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY "Cidade."
    @ cl,007 SAY dcidade                           // Cidade
    @ cl,033 SAY TRAN(dcep,"@R 99999-999")         // CEP
    @ cl,042 SAY "³"
    @ cl,044 SAY cidade                            // Cidade
    @ cl,070 SAY TRAN(cep,"@R 99999-999")          // CEP
    SKIP                                           // pega proximo registro
   ELSE                                            // se nao atende condicao
    SKIP                                           // pega proximo registro
   ENDI
  ENDD
 ENDD ccop
END SEQUENCE
SETCURSOR(cur_atual)
SET PRINTER TO (drvporta)                          // fecha arquivo gerado (se houver)
SET DEVI TO SCRE                                   // direciona saida p/ video
IF tps=2                                           // se vai para arquivo/video
 BROWSE_REL(arq_,2,3,MAXROW()-2,78)
ENDI          // mostra o arquivo gravado
GRELA(11)                                          // grava variacao do relatorio
msgp="PROCESSAMENTOS DO RELAT¢RIO|ENDERE€OS ALTERADOS"
POE_GAUGE("Processando registros","AGUARDE!","Feitos:")
SET(_SET_DELETED,.t.)                              // os excluidos nao servem...
SELE ALENDER                                       // processamentos apos emissao
INI_ARQ()                                          // acha 1o. reg valido do arquivo
DO WHIL !EOF().AND.POE_GAUGE()
 IF EMPT(emitido_).AND.(EMPT(M->musuario).OR.por=M->musuario).AND.data_>=M->emisini_.AND.data_<=M->emisfim_// se atender a condicao...

  #ifdef COM_REDE
   IF PTAB(codigo,'GRUPOS',1)
    REPBLO('GRUPOS->endereco',{||endereco})
   ENDI
   REPBLO('GRUPOS->bairro',{||bairro})
   REPBLO('GRUPOS->cidade',{||cidade})
   REPBLO('GRUPOS->cep',{||cep})
   REPBLO('GRUPOS->cobrador',{||cobrador})
   REPBLO('GRUPOS->ender_',{||DATE()})
   REPBLO('GRUPOS->ultend',{||M->usuario})
   REPBLO('ALENDER->emitido_',{||DATE()})
  #else
   IF PTAB(codigo,'GRUPOS',1)
    REPL GRUPOS->endereco WITH endereco
   ENDI
   REPL GRUPOS->bairro WITH bairro
   REPL GRUPOS->cidade WITH cidade
   REPL GRUPOS->cep WITH cep
   REPL GRUPOS->cobrador WITH cobrador
   REPL GRUPOS->ender_ WITH DATE()
   REPL GRUPOS->ultend WITH M->usuario
   REPL ALENDER->emitido_ WITH DATE()
  #endi

  SKIP                                             // pega proximo registro
 ELSE                                              // se nao atende condicao
  SKIP                                             // pega proximo registro
 ENDI
ENDD
ALERTA(2)
DBOX("Processo terminado com sucesso!",,,,,msgp)
SELE ALENDER                                       // seleciona arquivo
SET RELA TO                                        // retira os relacionamentos
SET(_SET_DELETED,dele_atu)                         // os excluidos serao vistos
RETU

STATIC PROC REL_CAB(qt)                            // cabecalho do relatorio
IF qt>0                                            // se parametro maior que 0
 cl=cl+qt                                          // soma no contador de linhas
ENDI
IF cl>maxli .OR. qt=0                              // quebra de pagina
 IMPAC(nemp,0,000)                                 // nome da empresa
 @ 0,070 SAY "PAG"
 @ 0,074 SAY TRAN(pg_,'9999')                      // n£mero da p gina
 IMPAC(nsis,1,000)                                 // t¡tulo aplica‡„o
 @ 1,070 SAY "ADM_R022"                            // c¢digo relat¢rio
 @ 2,000 SAY titrel                                // t¡tulo a definir
 IMPAC("ALTERA€ŽO DE ENDERE€OS",2,032)
 @ 2,062 SAY NSEM(DATE())                          // dia da semana
 @ 2,070 SAY DTOC(DATE())                          // data do sistema
 @ 3,000 SAY REPL("-",78)
 cl=qt+3 ; pg_++
ENDI
RETU

* \\ Final de ADM_R022.PRG
GAS-Pro v4.0
012021015062001001011001013000176001
 N£mero:
[Ÿ]
[Ÿ]
 1 
 0 
Emiss„o de Guias
Emiss„o de Guias







056




































 0 
 0 
-1 
-1 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
gnumero
C
E
@R 99-99999
 7 
 8 
 1 
 10 
 0 
N£mero

PTAB(gnumero,'GUIAS',1).AND.V00101F9()
N£MERO n„o existe na tabela
IF(PTAB(PADR(SUBSTR(M->ide_maq,2),4)+[GUI],[IMPPAR],1),IMPPAR->docto,[])
Emitir a guia de n£mero?
VDBF(6,8,20,77,'GUIAS',{'numero','grupo','codigo','grau','seq','nome'},1,'numero')
 0 
 0 


 1 
Nome
GUIAS->nome
@!
 2 
 5 
 35 

 0 
 0 
 0 
 0 
€	 ALENDERu–H ALENDERCODEALE_INCLCODE
ALE_ANT_SECODE
ALE_CRIA_SCODE
ALE_GERA_SCODE
ALE_GRAVA_CODEALE_TELACODEALE_GETSCODEALE_GET1CODEC_ETEXTENDCODE	_SYMSTARTSYMSTARTSYMBOLSSYMBOLS_SYMENDSYMENDNULLBEGDATA_DATADATA_SYMPBDATA_SYMPDATA_SYMPEDATA_CONSTCONST_MSGMSG_BEGBSSBEGBSS_BSSBSS_ENDBSSENDBSSDGROUP˜ @õ$˜ @Ž„˜ @s  ˜ @)	å˜ @Þ 
-˜ @) Þ˜ @Z§˜ @Â9˜ @.Å˜ H  ï˜ h  Ë˜ `Ðø˜ h  
cd \PEDRO\prjnwv4\admbp\rec
bc
procedure adr_manu
/*
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
 \ Empresa.: PresServ Inform tica - Limeira (019)452.6623
 \ Programa: ADR_MANU.PRG
 \ Data....: 22-01-08
 \ Sistema.: Administradora - RECEP€„O
 \ Funcao..: Menu geral de auxilio da aplica‡„o
 \ Analista: Ademilson Pedro Bom
 \ Criacao.: GAS-Pro v4.0o
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/

#include "adrbig.ch"    // inicializa constantes manifestas

opc_01=1
v01=SAVESCREEN(0,0,MAXROW(),79)
arqx_:=M->arq_sos
arq_sos=direxe+"ADRBIG.TXT"  // nome do arquivo de ajud
menu02:=[]
contx:=0
IF FILE(arq_sos)
 txtini:=MEMOREAD(arq_sos) // texto
 nLines:=MLCOUNT(M->txtini,56)
 FOR nCurrLine = 1 TO nLines
  Lineaux:=MEMOLINE(txtini, 56, nCurrLine)
  IF LineAux=[\0]
   LineAux:=SUBSTR(LineAux,6,RAT([ -],LineAux)-3)+[~]+SUBSTR(LineAux,3,2)
   menu02+=LineAux+[|]
  ENDI
 NEXT
 opc_02=1
 v02=SAVESCREEN(0,0,MAXROW(),79)
 DO WHIL opc_02!=0
  RESTSCREEN(0,0,MAXROW(),79,v02)
  msgt="PROCEDIMENTOS"
  ROLAPOP(1)
  opc_02=DBOX(menu02,1,2,E_MENU,NAO_APAGA,msgt,,,opc_02)
  ROLAPOP()
  IF !EMPT(opc_02)
   txt_cut1:=SUBSTR(txtini,AT([\0]+strzero(opc_02,2),txtini)+56)
   txt_cut1:=LEFT(txt_cut1,AT([\0],txt_cut1))

   cod_sos:=opc_02
   HELP_PROC()
  ENDIF
 ENDD
ENDI
M->arq_sos:=arqx_
RESTSCREEN(0,0,MAXROW(),79,v01)
RETU

PROC HELP_PROC    // Apresenta ajuda on-line
LOCAL tela_, txt, ctr, t, cor_, qdlin_, linf_, estr_db, pg_up, pg_dn,;
      tec_f3, tec_f4, tec_f9, tec_f8
SETKEY(K_F1,NIL)                                     // evita recursividade
pg_up =SETKEY(K_PGUP,NIL)                            // desabilita PgUp,
pg_dn =SETKEY(K_PGDN,NIL)                            // PgDn,
tec_f3=SETKEY(K_F3,NIL)                              // F3,
tec_f4=SETKEY(K_F4,NIL)                              // F4,
tec_f9=SETKEY(K_F9,NIL)                              // F9 e
tec_f8=SETKEY(K_ALT_F8,NIL)                          // ALT-F8
tela_=SAVESCREEN(0,0,MAXROW(),79)                    // salva a tela por baixo e
cor_=SETCOLOR(drvtithlp)                             // o esquema de cor vigente
 txt=txt_cut1
 qdlin_=MLCOUNT(txt,56)                              // qde linhas
 maxlt_ =MAXROW()
 linf_ =IF(qdlin_>maxlt_-7,maxlt_-3,qdlin_+3)        // calcula linha inferior
 CAIXA(mold,2,10,linf_,69,392)                       // monta janela
 ctr=IF(qdlin_>maxlt_-6," "+CHR(K_CTRL_X)+" "+;      // monta teclas de controle
        CHR(K_CTRL_Y)+" PgUp PgDn","")+" ESC "       // disponiveis na janela
 @ linf_,(80-LEN(ctr))/2 SAY ctr                     // mostra teclas de controle
 SETCOLOR(drvcorhlp)

 #ifdef COM_TUTOR
  MEMOEDIT(txt,3,12,linf_-1,68,.f.,"mHelp")          // mostra o bloco de ajuda
 #else
  MEMOEDIT(txt,3,12,linf_-1,68,.f.)                  // mostra o bloco de ajuda
 #endi

SETCOLOR(cor_)
RESTSCREEN(0,0,MAXROW(),79,tela_)
SETKEY(K_PGUP,pg_up)                                 // habilita teclas PgUp,
SETKEY(K_PGDN,pg_dn)                                 // PgDn,
SETKEY(K_F3,tec_f3)                                  // F3,
SETKEY(K_F4,tec_f4)                                  // F4,
SETKEY(K_F9,tec_f9)                                  // F9 e
SETKEY(K_ALT_F8,tec_f8)                              // ALT-F8
SET KEY K_F1 TO help                                 // habilita F1
RETU

func mkinx
para filetxt
 txtini:=MEMOREAD(filetxt) // texto
 nLines:=MLCOUNT(M->txtini,56)
 posinx:=0
 FOR nCurrLine = 1 TO nLines
  Lineaux:=MEMOLINE(txtini, 56, nCurrLine)
  posinx+=LEN(lineaux)
  IF LineAux=[\0]
   LineAux:=SUBSTR(LineAux,6,RAT([ -],LineAux)-3)+[~]+SUBSTR(LineAux,3,2)
   menu02+=strzero(posinx+2,8)
  ENDI
 NEXT
 menu02+=repl([0],1920-len(menu02))
// memowrite([adrbig.inx],menu02)
retu
/*
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
 \ Empresa.: Ind£stria de Urnas Bignotto Ltda
 \ Programa: ADM_R041.PRG
 \ Data....: 03-03-98
 \ Sistema.: Administradora - PLANO
 \ Funcao..: Contrato Bom Pastor
 \ Analista: Ademilson Pedro Bom
 \ Criacao.: GAS-Pro v3.0
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/

#include "adpbig.ch"    // inicializa constantes manifestas

LOCAL dele_atu, getlist:={}, so_um_reg, sit_dbf:=POINTER_DBF()
PARA  lin_menu, col_menu, imp_reg
PRIV  tem_borda:=.t., op_menu:=VAR_COMPL, l_s:=8, c_s:=11, l_i:=15, c_i:=66, tela_fundo:=SAVESCREEN(0,0,MAXROW(),79)
nucop=1
so_um_reg=(PCOU()>2)
IF !so_um_reg                             // vai receber a variaveis?
 SETCOLOR(drvtittel)
 vr_memo=NOVAPOSI(@l_s,@c_s,@l_i,@c_i)    // pega posicao atual da tela
 CAIXA(mold,l_s,c_s,l_i,c_i)              // monta caixa da tela
 @ l_s,c_s+18 SAY " IMPRESSŽO CONTRATO "
 SETCOLOR(drvcortel)
 @ l_s+01,c_s+1 SAY " Imprimir os contratos do n§ :        at‚ o n§"
 @ l_s+02,c_s+1 SAY "          os lan‡ados entre..:           e"
 @ l_s+04,c_s+1 SAY "                   Reimpress„o?:"
 @ l_s+05,c_s+1 SAY "                    Confirme...:"
ENDI
rcodin=SPAC(6)                                     // Codigo
rcodfi=SPAC(6)                                     // Codigo
rlanc1_=CTOD('')                                   // Lan‡.Inic.
rlanc2_=CTOD('')                                   // Lan‡.Final
rreimp=[S] //PAC(1)                                     // Reimprimir?
confirme=SPAC(1)                                   // Confirme
DO WHILE .t.
 rola_t=.f.
 cod_sos=56
 IF !so_um_reg
	SET KEY K_ALT_F8 TO ROLATELA
	SETCOLOR(drvcortel+","+drvcorget+",,,"+corcampo)
	@ l_s+01 ,c_s+32 GET  rcodin;
									 PICT "999999";
									 VALI CRIT("PTAB(rcodin,'GRUPOS',1)~CODIGO n„o aceit vel")
									 AJUDA "Entre com o n£mero do |primeiro contrato a imprimir"
									 CMDF8 "VDBF(6,20,20,77,'GRUPOS',{'codigo','nome','admissao'},1,'codigo',[])"

	@ l_s+01 ,c_s+48 GET  rcodfi;
									 PICT "999999";
									 VALI CRIT("PTAB(rcodfi,'GRUPOS',1)~CODIGO n„o aceit vel")
									 AJUDA "Entre com o n£mero do |£ltimo contrato a imprimir"
									 CMDF8 "VDBF(6,20,20,77,'GRUPOS',{'codigo','nome','admissao'},1,'codigo',[])"
/*
	@ l_s+02 ,c_s+32 GET  rlanc1_;
									 PICT "@D";
									 VALI CRIT("!EMPT(Rlanc1_)~Deve ser informada uma data v lida.")
									 DEFAULT "DATE()"
									 AJUDA "Listar os contratos lan‡ados| a partir de qual data."

	@ l_s+02 ,c_s+45 GET  rlanc2_;
									 PICT "@D";
									 VALI CRIT("!EMPT(Rlanc2_)~Deve ser informada uma data v lida.")
									 DEFAULT "DATE()"
									 AJUDA "Listar os contratos lan‡ados| at‚ quel data."

	@ l_s+04 ,c_s+34 GET  rreimp;
									 PICT "!";
			 VALI CRIT("rreimp$[SN ]~Necess rio informar REIMPRIMIR?|Digite S ou N")
									 DEFAULT "[N]"
									 AJUDA "Digite S para imprimir| inclusive os j  impressos."
*/
	@ l_s+05 ,c_s+34 GET  confirme;
									 PICT "!";
									 VALI CRIT("confirme='S'~CONFIRME n„o aceit vel|Digite S ou tecle ESC para cancelar")
									 AJUDA "Digite S para imprimir o contrato|ou |Tecle ESC para cancelar"

	READ
	SET KEY K_ALT_F8 TO
	IF rola_t
	 ROLATELA(.f.)
   LOOP
  ENDI
  IF LASTKEY()=K_ESC                               // se quer cancelar
   RETU                                            // retorna
  ENDI
 ENDI

 #ifdef COM_REDE
  CLOSE GRUPOS
  IF !USEARQ("GRUPOS",.f.,10,1)                    // se falhou a abertura do arq
   RETU                                            // volta ao menu anterior
  ENDI
 #else
	USEARQ("GRUPOS")                                 // abre o dbf e seus indices
 #endi

 PTAB(codigo,"ECOB",1,.t.)                         // abre arquivo p/ o relacionamento
 SET RELA TO codigo INTO ECOB                      // relacionamento dos arquivos
 titrel:=criterio:=cpord := ""                     // inicializa variaveis
 titrel:=chv_rela:=chv_1:=chv_2 := ""
 tps:=op_x:=ccop := 1
 arq_=drvporta                                     // porta de saida configurada
 IF !so_um_reg
  IF !opcoes_rel(lin_menu,col_menu,17,11)          // nao quis configurar...
   CLOS ALL                                        // fecha arquivos e
   LOOP                                            // volta ao menu
  ENDI

 #ifdef COM_REDE

  ELSE

   tps=lin_menu

 #endi

 ENDI
 IF tps=2                                          // se vai para arquivo/video
  arq_=ARQGER()                                    // entao pega nome do arquivo
  IF EMPTY(arq_)                                   // se cancelou ou nao informou
   LOOP                                            // retorna
  ENDI
 ELSE
  arq_=drvporta                                    // porta de saida configurada
 ENDI
 SET PRINTER TO (arq_)                             // redireciona saida
 EXIT
ENDD
criterio_=criterio                                 // salva criterio e ordenacao
cpord_=cpord                                       // definidos se huver
criterio=""

#ifdef COM_REDE
 IF !USEARQ("INSCRITS",.f.,10,1)                   // se falhou a abertura do arq
	RETU                                             // volta ao menu anterior
 ENDI
#else
 USEARQ("INSCRITS")                                // abre o dbf e seus indices
#endi

cpord="codigo+grau+STR(seq,02,00)"
INDTMP()
criterio=criterio_                                 // restabelece criterio e
cpord=cpord_                                       // ordenacao definidos
confirme=[S]
SELE GRUPOS
IF !EMPTY(drvtapg)                                 // existe configuracao de tam pag?
 op_=AT("NNN",drvtapg)                             // se o codigo que altera
 IF op_=0                                          // o tamanho da pagina
	msg="Configura‡„o do tamanho da p gina!"         // foi informado errado
	DBOX(msg,,,,,"ERRO!")                            // avisa
	CLOSE ALL                                        // fecha todos arquivos abertos
	RETU                                             // e cai fora...
 ENDI                                              // codigo para setar/resetar tam pag
 lpp_018=LEFT(drvtapg,op_-1)+"088"+SUBS(drvtapg,op_+3)
 lpp_066=LEFT(drvtapg,op_-1)+"066"+SUBS(drvtapg,op_+3)
ELSE
 lpp_018:=lpp_066 :=""                             // nao ira mudara o tamanho da pag
ENDI
DBOX("[ESC] Interrompe",15,,,NAO_APAGA)
dele_atu:=SET(_SET_DELETED,.t.)                    // os excluidos nao servem...
SET DEVI TO PRIN                                   // inicia a impressao
maxli=84                                           // maximo de linhas no relatorio
SET MARG TO 1                                      // ajusta a margem esquerda
IMPCTL(drvpde8)                                    // ativa 8 lpp
IMPCTL(lpp_018)                                    // seta pagina com 18 linhas
IF tps=2
 IMPCTL("' '+CHR(8)")
ENDI
BEGIN SEQUENCE
 DO WHIL ccop<=nucop                               // imprime qde copias pedida
	pg_=1; cl=999
	IF so_um_reg
	 GO imp_reg
	ELSE
	 INI_ARQ()                                       // acha 1o. reg valido do arquivo
	ENDI
	IF !EMPT(VAL(M->rcodin))
	 seek M->rcodin
	ENDI
	ccop++                                           // incrementa contador de copias
	DO WHIL !EOF().AND.(!so_um_reg.OR.imp_reg=RECN())
	 #ifdef COM_TUTOR
		IF IN_KEY()=K_ESC                              // se quer cancelar
	 #else
		IF INKEY()=K_ESC                               // se quer cancelar
	 #endi
		IF canc()                                      // pede confirmacao
		 BREAK                                         // confirmou...
		ENDI
	 ENDI
	 IF (R04101F9()) .OR. so_um_reg                  // se atender a condicao...
		confirme=[S]
		REL_CAB(1)                                     // soma cl/imprime cabecalho
//		IF M->comnumero=[S]
		 IMPCTL(drvpenf)
		 @ cl,053 SAY GRUPO                             // Grupo
		 @ cl,059 SAY codigo                            // Codigo
		 IMPCTL(drvtenf)
//    ENDI
    IF CODIGO>[050000]
     REL_CAB(5)
    ELSE
		 REL_CAB(7)                                     // soma cl/imprime cabecalho
    ENDI
		IMPCTL(drvpenf)
		@ cl,013 SAY nome                              // Nome
		IMPCTL(drvtenf)
		REL_CAB(3)                                     // soma cl/imprime cabecalho
		@ cl,019 SAY TRAN(nascto_,"@D")                // Nascto
		@ cl,030 SAY TRAN([ ],"@!")                    // Naturalidade
		@ cl,058 SAY TRAN(uf,"!!")                     // UF
		REL_CAB(2)                                     // soma cl/imprime cabecalho
		@ cl,012 SAY TRAN(rg,"@!")                     // R.G.
		@ cl,039 SAY TRAN(cpf,"@R 999.999.999-99")     // CPF
		REL_CAB(3)                                     // soma cl/imprime cabecalho
		@ cl,012 SAY endereco                          // Endere‡o
		@ cl,048 SAY TRAN(telefone,"@!")               // Telefone
		REL_CAB(2)                                     // soma cl/imprime cabecalho
		@ cl,011 SAY bairro                            // Bairro
		@ cl,037 SAY cidade                            // Cidade
		REL_CAB(2)                                     // soma cl/imprime cabecalho
    @ cl,011 SAY TRAN(cep,"@R 99999-999")          // CEP
    @ cl,025 SAY LOWER(IIF(!EMPT(estcivil),SUBS(tbestciv,AT(estcivil,tbestciv),11),[]))// est.civil
    REL_CAB(6)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY "."
    chv032=codigo
    SELE INSCRITS
    SEEK chv032
    IF FOUND()
     IF cl+2>maxli                                 // se cabecalho do arq filho
      REL_CAB(0)                                   // nao cabe nesta pagina
     ENDI                                          // salta para a proxima pagina
     cl+=1                                         // soma contador de linha
     @ cl,013 SAY CHR(27)+'3'+chr(15)              // Habilita 216/20
     IF codigo<[050000]
      CL+=2
     ENDI
     IMPINSAUX:=[]
     DO WHIL ! EOF() .AND. chv032=codigo //LEFT(&(INDEXKEY(0)),LEN(chv032))
      #ifdef COM_TUTOR
       IF IN_KEY()=K_ESC                           // se quer cancelar
      #else
       IF INKEY()=K_ESC                            // se quer cancelar
      #endi
       IF canc()                                   // pede confirmacao
        BREAK                                      // confirmou...
       ENDI
      ENDI
      IF grau>'1'                                  // se atender a condicao...
       IF grau="8"
        IF !([8]$IMPINSAUX)
         cl:=IIF(codigo>[050000],79,89)
         ultgrau:=4
			   IMPINSAUX+=[8]
        ELSE
         ultgrau+=4
        ENDI
       ELSEIF grau="7"
        IF !([7]$IMPINSAUX)
	       ultgrau:=IIF(codigo>[050000],25,24)
			   IMPINSAUX+=[7]
        ELSE
         ultgrau+=4
        ENDI
       ELSE
        ultgrau:=(VAL(grau)-1)*4
       ENDI

//       REL_CAB(3)                                  // soma cl/imprime cabecalho
       @ cl+ultgrau,014 SAY ALLTRIM(nome)    // Nome
       IF grau<'6'.and.vivofalec='V'               // pode imprimir?
	      @ cl+ultgrau,051 SAY 'X'                           // tab1
       ENDI
       IF grau<'6'.and.vivofalec='F'               // pode imprimir?
        @ cl+ultgrau,056 SAY ' X'
       ENDI
       IF grau>'5'                                 // pode imprimir?
        @ cl+ultgrau,056 SAY LEFT(DTOC(nascto_),2)+'  '+SUBSTR(DTOC(nascto_),4,2)+'  '+RIGHT(DTOC(nascto_),2)+;// tab2
        [ ] +IIF(vivofalec=[F],[F],[ ])
			 ENDI
			 SKIP                                        // pega proximo registro
			ELSE                                         // se nao atende condicao
			 SKIP                                        // pega proximo registro
			ENDI
		 ENDD
//     cl+=1                                         // soma contador de linha
		ENDI

		SELE GRUPOS                                    // volta ao arquivo pai
		SKIP                                           // pega proximo registro
		cl=999                                         // forca salto de pagina
	 ELSE                                            // se nao atende condicao
		SKIP                                           // pega proximo registro
	 ENDI
	 IF !EMPT(VAL(M->rcodfi)).AND.codigo>M->rcodfi
		EXIT
	 ENDI
	ENDD
 ENDD ccop
 EJEC                                              // salta pagina
END SEQUENCE
IMPCTL(lpp_066)                                    // seta pagina com 66 linhas
SET MARG TO                                        // ajusta a margem esquerda
SET PRINTER TO (drvporta)                          // fecha arquivo gerado (se houver)
SET DEVI TO SCRE                                   // direciona saida p/ video
IF tps=2                                           // se vai para arquivo/video
 BROWSE_REL(arq_,2,3,MAXROW()-2,78)
ENDI                                               // mostra o arquivo gravado
GRELA(17)                                          // grava variacao do relatorio
SELE GRUPOS                                        // salta pagina
SET RELA TO                                        // retira os relacionamentos
SET(_SET_DELETED,dele_atu)                         // os excluidos serao vistos
IF so_um_reg
 POINTER_DBF(sit_dbf)
ENDI
RETU

STATIC PROC REL_CAB(qt)                            // cabecalho do relatorio
IF qt>0                                            // se parametro maior que 0
 cl=cl+qt                                          // soma no contador de linhas
ENDI
IF cl>maxli .OR. qt=0                              // quebra de pagina
 cl=qt+IIF(codigo>'050000',4,07) ; pg_++
ENDI
RETU

* \\ Final de ADM_R041.PRG
stat proc r04101f9
DO CASE
CASE (codigo<M->rcodin.AND.!(M->rcodin='000000')) // Contrato menor que
 RETU .f.                                        // o pedido.
CASE (codigo>M->rcodfi.AND.!(M->rcodfi='000000')) // contrato maior.
 RETU .f.
CASE (GRUPOS->ender_<M->rlanc1_.AND.!EMPT(M->rlanc1_)) //Lan‡ado antes
 RETU .f.
CASE (GRUPOS->ender_>M->rlanc2_.AND.!EMPT(M->rlanc2_)) //Lan‡ado depois
 RETU .f.
CASE M->rreimp=[S] // Se j  foi impresso, imprimir novamente.
 RETU .t.
ENDCASE
RETU EMPT(GRUPOS->ultimp_)    //S¢ quero os n„o impressos

* \\ Final de R04101F9.PRG
procedure adm_rs18
/*
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
 \ Empresa.: PresServ Inform tica - Limeira (019)452.6623
 \ Programa: ADM_RS18.PRG
 \ Data....: 04-11-03
 \ Sistema.: Administradora - RECEP€„O
 \ Funcao..: Recibos (2¦via)
 \ Analista: Ademilson Pedro Bom
 \ Criacao.: GAS-Pro v4.0n
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/

#include "adrbig.ch"    // inicializa constantes manifestas

PRIV dele_atu, cur_atual, getlist:={}, so_um_reg, sit_dbf
PARA lin_menu, col_menu, imp_reg
PRIV  tem_borda:=.t., op_menu:=VAR_COMPL, l_s:=10, c_s:=20, l_i:=14, c_i:=61, tela_fundo:=SAVESCREEN(0,0,MAXROW(),79)
nucop=1
so_um_reg=(PCOUNT()>2)
IF !so_um_reg                             // vai receber a variaveis?
 IF nivelop < 2                                    // se usuario nao tem
  DBOX("Emiss„o negada, "+usuario,20)              // permissao, avisa
  RETU                                             // e retorna
 ENDI
 SETCOLOR(drvtittel)
 vr_memo=NOVAPOSI(@l_s,@c_s,@l_i,@c_i)    // pega posicao atual da tela
 CAIXA(mold,l_s,c_s,l_i,c_i)              // monta caixa da tela
 @ l_s,c_s+10 SAY " RECIBO SEM FALECIDOS "
 SETCOLOR(drvcortel)
 @ l_s+01,c_s+1 SAY " Numero..:   -"
 @ l_s+03,c_s+1 SAY " Confirme:"
ENDI
PRIV rnumero:=SPAC(8)                              // Numero
PRIV confirme:=SPAC(1)                             // Confirme
DO WHILE .t.
 rola_t=.f.
 cod_sos=56
 IF !so_um_reg
  SET KEY K_ALT_F8 TO ROLATELA
  SETCOLOR(drvcortel+","+drvcorget+",,,"+corcampo)
  @ l_s+01 ,c_s+15 GET  rnumero;
                   PICT "99999999";
                   VALI CRIT("!EMPT(rnumero)~Necess rio informar NUMERO")
                   DEFAULT "IF(PTAB(PADR(SUBSTR(M->ide_maq,2),4)+[BXR],[IMPPAR],1),IMPPAR->docto,[])"
                   AJUDA "Informe o n£mero do recibo"
		   CMDF8 "VDBF(6,3,20,77,'BXREC',{'numero','codigo','cobranca','valorpg','emitido_','por'},1,'numero',[])"

  @ l_s+03 ,c_s+12 GET  confirme;
                   PICT "!";
                   VALI CRIT("confirme='S'.AND.V01801F9()~CONFIRME n„o aceit vel|Digite S para confirmar|ou|Tecle ESC para cancelar")
                   AJUDA "Digite S para confirmar|ou|tecle ESC para cancelar"

  READ
  SET KEY K_ALT_F8 TO
  IF rola_t
   ROLATELA(.f.)
   LOOP
  ENDI
  IF LASTKEY()=K_ESC                               // se quer cancelar
   RETU                                            // retorna
  ENDI
 ENDI

 #ifdef COM_REDE
  IF !USEARQ("BXREC",.f.,10,1)                     // se falhou a abertura do arq
   RETU                                            // volta ao menu anterior
  ENDI
 #else
  USEARQ("BXREC")                                  // abre o dbf e seus indices
 #endi

 PTAB(codigo,"GRUPOS",1,.t.)                       // abre arquivo p/ o relacionamento
 PTAB(cobranca,"TAXAS",1,.t.)
 PTAB(GRUPOS->grupo,"ARQGRUP",1,.t.)
 PTAB(TAXAS->cobrador,"COBRADOR",1,.t.)
 PTAB(GRUPOS->regiao,"REGIAO",1,.t.)
 PTAB(GRUPOS->tipcont,"CLASSES",1,.t.)
 SET RELA TO codigo INTO GRUPOS,;                  // relacionamento dos arquivos
	  TO cobranca INTO TAXAS,;
          TO GRUPOS->grupo INTO ARQGRUP,;
          TO TAXAS->cobrador INTO COBRADOR,;
          TO GRUPOS->regiao INTO REGIAO,;
          TO GRUPOS->tipcont INTO CLASSES
 titrel:=criterio := ""                            // inicializa variaveis
 cpord=""
 chv_rela:=chv_1:=chv_2 := ""
 tps:=op_x:=ccop := 1
 arq_=drvporta                                     // porta de saida configurada
 IF !so_um_reg
  fil_ini=""
  IF !opcoes_rel(lin_menu,col_menu,10,11,fil_ini)  // nao quis configurar...
   CLOS ALL                                        // fecha arquivos e
   LOOP                                            // volta ao menu
  ENDI

 #ifdef COM_REDE

  ELSE

   tps=lin_menu

 #endi

 ENDI
 IF tps=2                                          // se vai para arquivo/video
  arq_=ARQGER()                                    // entao pega nome do arquivo
  IF EMPTY(arq_)                                   // se cancelou ou nao informou
   LOOP                                            // retorna
  ENDI
 ELSE
  arq_=drvporta                                    // porta de saida configurada
 ENDI
 IF "4WIN"$UPPER(drvmarca) // nome da configuracao/marca impressora
    arq_:=drvdbf+"WIN"+ide_maq
    tps:=3                                          // se vai para arquivo/video
 ENDIF
 SET PRINTER TO (arq_)                             // redireciona saida
 EXIT
ENDD
cur_atual=SETCURSOR(0)
IF !EMPTY(drvtapg)                                 // existe configuracao de tam pag?
 op_=AT("NNN",drvtapg)                             // se o codigo que altera
 IF op_=0                                          // o tamanho da pagina
  msg="Configura‡„o do tamanho da p gina!"         // foi informado errado
  DBOX(msg,,,,,"ERRO!")                            // avisa
  CLOSE ALL                                        // fecha todos arquivos abertos
  RETU                                             // e cai fora...
 ENDI                                              // codigo para setar/resetar tam pag
 lpp_033=LEFT(drvtapg,op_-1)+"033"+SUBS(drvtapg,op_+3)
 lpp_066=LEFT(drvtapg,op_-1)+"066"+SUBS(drvtapg,op_+3)
ELSE
 lpp_033:=lpp_066 :=""                             // nao ira mudara o tamanho da pag
ENDI
dele_atu:=SET(_SET_DELETED,.t.)                    // os excluidos nao servem...
POE_GAUGE("[ESC] Interrompe","AGUARDE...","Emitidos:")
SET DEVI TO PRIN                                   // inicia a impressao
maxli=32                                           // maximo de linhas no relatorio
IMPCTL(lpp_033)                                    // seta pagina com 33 linhas
SET MARG TO 1                                      // ajusta a margem esquerda
IF tps=2
 IMPCTL("' '+CHR(8)")
ENDI
BEGIN SEQUENCE
 DO WHIL ccop<=nucop                               // imprime qde copias pedida
  pg_=1; cl=50000
  IF so_um_reg
   GO imp_reg
  ELSE
   INI_ARQ()                                       // acha 1o. reg valido do arquivo
   IF PTAB(PADR(SUBSTR(M->ide_maq,2),4)+[BXR],[IMPPAR],1)
    PTAB(LEFT(IMPPAR->docto,8),'BXREC',1)
   ENDI
  ENDI
  IF EOF()
   EXIT
  ENDI
  ccop++                                           // incrementa contador de copias
  DO WHIL !EOF().AND.(!so_um_reg.OR.imp_reg=RECN()).AND.POE_GAUGE()
   IF IN_KEY()=K_ESC                               // se quer cancelar
    IF canc()                                      // pede confirmacao
     BREAK                                         // confirmou...
    ENDI
   ENDI
   IF (PTAB(PADR(SUBSTR(M->ide_maq,2),4)+[BXR],[IMPPAR],1).AND.numero=LEFT(IMPPAR->docto,8)) .OR. so_um_reg// se atender a condicao...
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY TRAN(numero,"@R 99-999999")       // N§ Recibo
    IMPAC("Cobran‡a:",cl,014)
    IMPCTL(drvpenf)
    @ cl,026 SAY TRAN(cobranca,[@R 999.999999-9-99999])   // Ref.:
    IMPCTL(drvtenf)
    @ cl,046 SAY "Vencimento:"
    @ cl,058 SAY TRAN(TAXAS->emissao_,"@D")               // data 1
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,012 SAY TRAN(CLASSES->descricao,"@!")     // Descri‡„o 1
    @ cl,050 SAY "Valor.:"
    IMPCTL(drvpenf)
    @ cl,058 SAY TRAN(valorpg,"@E 999,999.99")     // Valor
    IMPCTL(drvtenf)
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY "Contrato..:"
    IMPCTL(drvpenf)
    @ cl,012 SAY GRUPOS->grupo +[  ]+TRAN(codigo,[@R 999.999999])        // Grupo 1
    IMPCTL(drvtenf)
    @ cl,050 SAY "Data..:"
    @ cl,058 SAY TRAN(emitido_,"@D")               // data 1
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY "Nome......:"
    IMPCTL(drvpenf)
    @ cl,012 SAY GRUPOS->nome                      // Nome
    IMPCTL(drvtenf)
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    IMPAC("Endere‡o..:",cl,000)
    @ cl,012 SAY xDECRIPT(GRUPOS->endereco)                  // Endere‡o
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY "Bairro....:"
    @ cl,012 SAY xDECRIPT(GRUPOS->bairro)                    // Bairro
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY "Cid./Cobr.:"
    @ cl,012 SAY xDECRIPT(GRUPOS->cidade)+[ ] +GRUPOS->cobrador// Cidade
    @ cl,052 SAY REPL("Ä",19)
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,052 SAY "Op:"
    @ cl,056 SAY LEFT(por,1)+LOWER(SUBSTR(por,2))  // operador
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY "Valor:"
    @ cl,007 SAY chr(15)+'('+SUBSTR(EXT(valorpg),1,AT('/',EXT(valorpg))-1)+')'+chr(18)// Valor Ext
    REL_CAB(2)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY REPL("Ä",71)
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    IMPEXP(cl,000,LEFT(M->setup1,35),70)           // 2 Ident1
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY M->setup2                         // 2 Ident 2
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY REPL("-",71)
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY TRAN(numero,"@R 99-999999")       // N§ Recibo
    IMPAC("Cobran‡a:",cl,014)
    IMPCTL(drvpenf)
    @ cl,025 SAY cobranca                          // Ref.:
    IMPCTL(drvtenf)
    @ cl,046 SAY "Vencimento:"
    @ cl,058 SAY TRAN(TAXAS->emissao_,"@D")               // data 1
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,012 SAY TRAN(CLASSES->descricao,"@!")     // Descri‡„o 2
    @ cl,050 SAY "Valor.:"
    IMPCTL(drvpenf)
    @ cl,058 SAY TRAN(valorpg,"@E 999,999.99")     // Valor pago
    IMPCTL(drvtenf)
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY "Contrato..:"
    IMPCTL(drvpenf)
    @ cl,012 SAY GRUPOS->grupo +[  ]+TRAN(codigo,[@R 999.999999])  // Grupo
    IMPCTL(drvtenf)
    @ cl,050 SAY "Data..:"
    @ cl,058 SAY TRAN(emitido_,"@D")               // Emitido em
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY "Nome......:"
    IMPCTL(drvpenf)
    @ cl,012 SAY GRUPOS->nome                      // Nome
    IMPCTL(drvtenf)
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    IMPAC("Endere‡o..:",cl,000)
    @ cl,012 SAY xDECRIPT(GRUPOS->endereco)                  // Endere‡o
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY "Bairro....:"
    @ cl,012 SAY xDECRIPT(GRUPOS->bairro)                    // Bairro
    @ cl,052 SAY REPL("Ä",19)
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY "Cid./Cobr.:"
    @ cl,012 SAY xDECRIPT(GRUPOS->cidade)+[ ] +GRUPOS->cobrador// Cidade
    @ cl,052 SAY "Op:"
    @ cl,056 SAY LEFT(por,1)+LOWER(SUBSTR(por,2))  // Operador
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY "Valor:"
    @ cl,007 SAY chr(15)+'('+SUBSTR(EXT(valorpg),1,AT('/',EXT(valorpg))-1)+')'+chr(18)// Valor Ext
    REL_CAB(2)                                     // soma cl/imprime cabecalho
//    @ cl,000 say [>]+cobranca+[<]
    @ cl,000 SAY ""
    CODBARRAS({{left(cobranca,13)+[0],4,25,9},{ALLTRIM(str(valorpg,10,2)),3,20,47}},10,6)
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY ""
    CODBARRAS({{left(cobranca,13)+[0],4,25,9},{ALLTRIM(str(valorpg,10,2)),3,20,47}},10,6)

    REL_CAB(1)                                     // soma cl/imprime cabecalho
//    @ cl,000 SAY ""
//    CODBARRAS({{strzero(valorpg,10,2),3,20,39}},10,6)
    SKIP                                           // pega proximo registro
    cl=50000                                       // forca salto de pagina
   ELSE                                            // se nao atende condicao
    SKIP                                           // pega proximo registro
   ENDI
  ENDD
 ENDD ccop
 EJEC                                              // salta pagina
END SEQUENCE
SETCURSOR(cur_atual)
SET MARG TO                                        // coloca margem esquerda = 0
IMPCTL(lpp_066)                                    // seta pagina com 66 linhas
SET PRINTER TO (drvporta)                          // fecha arquivo gerado (se houver)
SET DEVI TO SCRE                                   // direciona saida p/ video
IF tps=2                                           // se vai para arquivo/video
 BROWSE_REL(arq_,2,3,MAXROW()-2,78)
ENDI          // mostra o arquivo gravado
GRELA(10)                                          // grava variacao do relatorio
SELE BXREC                                         // seleciona arquivo
SET RELA TO                                        // retira os relacionamentos
SET(_SET_DELETED,dele_atu)                         // os excluidos serao vistos
IF so_um_reg
 POINTER_DBF(sit_dbf)
ENDI
RETU

STATIC PROC REL_CAB(qt)                            // cabecalho do relatorio
IF qt>0                                            // se parametro maior que 0
 cl=cl+qt                                          // soma no contador de linhas
ENDI
IF cl>maxli .OR. qt=0                              // quebra de pagina
 IMPEXP(0,000,LEFT(M->setup1,35),70)               // Ident1
 @ 1,000 SAY M->setup2                             // Ident2
 @ 2,000 SAY REPL("-",71)
 cl=qt+2 ; pg_++
ENDI
RETU

* \\ Final de ADM_RS18.PRG
GAS-Pro v3.0
002004005078001002038001004000004001
                                                            ,
[Ÿ]
[Ÿ]
 39 
 0 









003







 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
pgrupo
C
V
!!
 2 
 2 
 0 
 0 
 0 
Grupo






 0 
 0 


p_filial
C
E
@!
 2 
 2 
 0 
 0 
 0 
C¢digo






 0 
 0 


pcontrato
C
V
999999
 6 
 6 
 0 
 0 
 0 
Codigo






 0 
 0 


pgrau
C
V
9
 1 
 1 
 0 
 0 
 0 
Inscr.






 0 
 0 


pseq
N
V
99
 2 
 2 
 0 
 0 
 0 
Seq






 0 
 0 


pverpag
C
I
!
 1 
 1 
 0 
 0 
 0 
Verificar Pagas?






 0 
 0 


preplanc
C
I
!
 1 
 1 
 0 
 0 
 0 
Repetir lan‡amento?






 0 
 0 


lastcodigo
C
I
999999
 6 
 6 
 0 
 0 
 0 
Maior Contrato






 0 
 0 


nrcanc
N
V
999999
 6 
 6 
 0 
 0 
 0 
N£mero






 0 
 0 


nrreint
N
V
999999
 6 
 6 
 0 
 0 
 0 
Nrreint






 0 
 0 


contarec
C
E
@!
 5 
 5 
 0 
 0 
 0 
Conta Recepcao






 0 
 0 


contapag
C
E
@!
 5 
 5 
 0 
 0 
 0 
Conta Pagamento






 0 
 0 


histrccar
C
E
999
 3 
 3 
 0 
 0 
 0 
Hist¢rico






 0 
 0 


histrcfcc
C
E
999
 3 
 3 
 0 
 0 
 0 
Hist¢rico






 0 
 0 


histrcrec
C
E
999
 3 
 3 
 0 
 0 
 0 
Hist¢rico






 0 
 0 


histpg
C
E
999
 3 
 3 
 0 
 0 
 0 
Hist¢rico






 0 
 0 


nrauxrec
C
E
@R 99-999999
 8 
 9 
 0 
 0 
 0 
N§ Recibo






 0 
 0 


mcodigo
C
E
999999
 6 
 6 
 0 
 0 
 0 
Codigo






 0 
 0 


mtipo
C
E
!
 1 
 1 
 0 
 0 
 0 
Tipo






 0 
 0 


mcirc
C
E
999
 3 
 3 
 0 
 0 
 0 
Circular






 0 
 0 


mgrupvip
C
E
!!
 2 
 2 
 0 
 0 
 0 
Grup






 0 
 0 


combarra
C
E
!
 1 
 1 
 0 
 0 
 0 
Combarra






 0 
 0 


cinscr
C
E
!
 1 
 1 
 0 
 0 
 0 
Com Inscritos






 0 
 0 


comfalec
C
E
!
 1 
 1 
 0 
 0 
 0 
Com Falecido






 0 
 0 


mproc1
C
I
99999
 5 
 5 
 0 
 0 
 0 
Processo






 0 
 0 


mproc2
C
I
99
 2 
 2 
 0 
 0 
 0 
Ano






 0 
 0 


mproc3
C
I
!!
 2 
 2 
 0 
 0 
 0 
Mproc3






 0 
 0 


impnrrec
C
I
99999
 5 
 5 
 0 
 0 
 0 
N£mero






 0 
 0 


procimp
C
I
@R 99999/99/!!
 9 
 8 
 0 
 0 
 0 
Procimp






 0 
 0 


pvalor
N
I
@E 999,999.99
 9 
 10 
 0 
 0 
 2 
Valor






 0 
 0 


pcob
C
I
!!!
 3 
 2 
 0 
 0 
 0 
Cobrador






 0 
 0 


mmesref
C
I
@R 99/99
 4 
 5 
 0 
 0 
 0 
Mˆs Ref.






 0 
 0 


pnumfcc
C
I
 
 8 
 8 
 0 
 0 
 0 
Pnumfcc






 0 
 0 


p_cidade
C
E
@!
 25 
 25 
 0 
 0 
 0 
Munic¡pio






 0 
 0 


p_recp
C
E
!
 1 
 1 
 0 
 0 
 0 
Recibo Padr„o






 0 
 0 


setup1
C
E
 
 40 
 40 
 0 
 0 
 0 
Ident1






 0 
 0 


cgcsetup
C
E
@R 99.999.999/9999-99
 14 
 18 
 0 
 0 
 0 
CGC






 0 
 0 


setup2
C
E
 
 50 
 50 
 0 
 0 
 0 
Ident2






 0 
 0 


setup3
C
E
 
 50 
 50 
 0 
 0 
 0 
Setup3






 0 
 0 


 6 
Nome da empresa
nemp

 1 
 2 
 44 

T¡tulo aplica‡„o
nsis

 2 
 2 
 25 

Data do sistema
DATE()

 1 
 63 
 10 

Nome do mˆs
NMES(DATE())

 0 
 0 
 8 

Dia da semana
NSEM(DATE())

 1 
 54 
 7 

Diret¢rio atual
drvdbf

 2 
 50 
 23 

 0 
 0 
 0 
 0 
/*
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
 \ Empresa.: PresServ Inform tica - Limeira (019)452.6623
 \ Programa: R07702F9.PRG
 \ Data....: 23-05-98
 \ Sistema.: Administradora -CRD/COBRAN€A
 \ Funcao..: Valor do relat¢rio ADC_R077
 \ Analista: Ademilson Pedro Bom
 \ Criacao.: Programado manualmente pelo analista
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/

#include "adPbig.ch"    // inicializa constantes manifestas
PRIVA vladd:=0
IF TAXAS->emissao_< DATE()
 jrok:=PTAB(tipo,'JUROS',1)
 nrd:=(DATE() - TAXAS->emissao_)
 IF jrok .AND. (nrd > JUROS->mltcaren)
  vladd+=TAXAS->valor*JUROS->multa/100
 ENDI
 IF jrok .AND. (nrd > JUROS->jrscaren)
  vladd+=TAXAS->valor*JUROS->juros/100*nrd
 ENDI
ENDI

RETU IIF(EMPT(TAXAS->valorpg),TAXAS->valor+M->vladd,TAXAS->valorpg)

* \\ Final de R07702F9.PRG
procedure adr_r029
/*
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
 \ Empresa.: PresServ Inform tica-Limeira (019)452.6623
 \ Programa: ADR_R029.PRG
 \ Data....: 22-09-97
 \ Sistema.: Administradora - RECEP€„O
 \ Funcao..: Recibo Aux.Funeral 1
 \ Analista: Ademilson Pedro Bom
 \ Criacao.: GAS-Pro v3.0 
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/

#include "adrbig.ch"    // inicializa constantes manifestas

LOCAL dele_atu, getlist:={}, so_um_reg, sit_dbf:=POINTER_DBF()
PARA  lin_menu, col_menu, imp_reg
PRIV  tem_borda:=.t., op_menu:=VAR_COMPL, l_s:=10, c_s:=20, l_i:=13, c_i:=61, tela_fundo:=SAVESCREEN(0,0,MAXROW(),79)
nucop=1
so_um_reg=(PCOU()>2)
IF !so_um_reg                             // vai receber a variaveis?
 SETCOLOR(drvtittel)
 vr_memo=NOVAPOSI(@l_s,@c_s,@l_i,@c_i)    // pega posicao atual da tela
 CAIXA(mold,l_s,c_s,l_i,c_i)              // monta caixa da tela
 @ l_s,c_s+10 SAY " RECIBO AUX.FUNERAL 1 "
 SETCOLOR(drvcortel)
 @ l_s+01,c_s+1 SAY " Processo:"
 @ l_s+02,c_s+1 SAY " Confirme:"
ENDI
rproc=SPAC(11)                                     // Processo
confirme=SPAC(1)                                   // Confirme
DO WHILE .t.
 rola_t=.f.
 cod_sos=56
 IF !so_um_reg
  SET KEY K_ALT_F8 TO ROLATELA
  SETCOLOR(drvcortel+","+drvcorget+",,,"+corcampo)
  @ l_s+01 ,c_s+12 GET  rproc;
                   PICT "@R 99999/9999-99";
                   VALI CRIT("!EMPT(RPROC).AND.PTAB(rproc,[AFUNER],1)~Campo utilizado para localiza‡„o dos documentos.|Tecle F8 para busca em tabela")
                   DEFAULT "IIF(PTAB(PADR(SUBSTR(M->ide_maq,2),4)+[AFU],[IMPPAR],1),ALLTRIM(IMPPAR->docto),[])"
                   AJUDA "Digite neste campo o n£mero de|identifica‡„o do processo"
                   CMDF8 "VDBF(6,12,20,77,'AFUNER',{'processo','proc2','categ','contrato','falecido'},1,'V02001F9()',[])"

  @ l_s+02 ,c_s+12 GET  confirme;
                   PICT "!";
                   VALI CRIT("confirme='S'.AND.V02002F9()~CONFIRME n„o aceit vel|Digite S para confirmar|ou|Tecle ESC para cancelar")
                   AJUDA "Digite S para confirmar|ou|tecle ESC para cancelar"

  READ
  SET KEY K_ALT_F8 TO
  IF rola_t
   ROLATELA(.f.)
   LOOP
  ENDI
  IF LASTKEY()=K_ESC                               // se quer cancelar
   RETU                                            // retorna
  ENDI
 ENDI

 #ifdef COM_REDE
  IF !USEARQ("AFUNER",.f.,10,1)                    // se falhou a abertura do arq
   RETU                                            // volta ao menu anterior
  ENDI
 #else
  USEARQ("AFUNER")                                 // abre o dbf e seus indices
 #endi

 PTAB(contrato,"GRUPOS",1,.t.)                     // abre arquivo p/ o relacionamento
 PTAB(contrato,"INSCRITS",1,.t.)
 SET RELA TO contrato INTO GRUPOS,;                // relacionamento dos arquivos
          TO contrato INTO INSCRITS
 titrel:=criterio:=cpord := ""                     // inicializa variaveis
 titrel:=chv_rela:=chv_1:=chv_2 := ""
 tps:=op_x:=ccop := 1
 arq_=drvporta                                     // porta de saida configurada
 IF !so_um_reg
  IF !opcoes_rel(lin_menu,col_menu,2,11)           // nao quis configurar...
   CLOS ALL                                        // fecha arquivos e
   LOOP                                            // volta ao menu
  ENDI

 #ifdef COM_REDE

  ELSE

   tps=lin_menu

 #endi

 ENDI
 IF tps=2                                          // se vai para arquivo/video
  arq_=ARQGER()                                    // entao pega nome do arquivo
  IF EMPTY(arq_)                                   // se cancelou ou nao informou
   LOOP                                            // retorna
  ENDI
 ELSE
  arq_=drvporta                                    // porta de saida configurada
 ENDI
 IF "4WIN"$UPPER(drvmarca) // nome da configuracao/marca impressora
    arq_:=drvdbf+"WIN"+ide_maq
    tps:=3                                          // se vai para arquivo/video
 ENDIF
 SET PRINTER TO (arq_)                             // redireciona saida
 EXIT
ENDD
IF !EMPTY(drvtapg)                                 // existe configuracao de tam pag?
 op_=AT("NNN",drvtapg)                             // se o codigo que altera
 IF op_=0                                          // o tamanho da pagina
  msg="Configura‡„o do tamanho da p gina!"         // foi informado errado
  DBOX(msg,,,,,"ERRO!")                            // avisa
  CLOSE ALL                                        // fecha todos arquivos abertos
  RETU                                             // e cai fora...
 ENDI                                              // codigo para setar/resetar tam pag
 lpp_033=LEFT(drvtapg,op_-1)+"036"+SUBS(drvtapg,op_+3)
 lpp_066=LEFT(drvtapg,op_-1)+"066"+SUBS(drvtapg,op_+3)
ELSE
 lpp_033:=lpp_066 :=""                             // nao ira mudara o tamanho da pag
ENDI
DBOX("[ESC] Interrompe",15,,,NAO_APAGA)
dele_atu:=SET(_SET_DELETED,.t.)                    // os excluidos nao servem...
SET DEVI TO PRIN                                   // inicia a impressao
maxli=36                                           // maximo de linhas no relatorio
IMPCTL(lpp_033)                                    // seta pagina com 33 linhas
SET MARG TO 1                                      // ajusta a margem esquerda
IF tps=2
 IMPCTL("' '+CHR(8)")
ENDI
BEGIN SEQUENCE
 DO WHIL ccop<=nucop                               // imprime qde copias pedida
  pg_=1; cl=999
  IF so_um_reg
   GO imp_reg
  ELSE
   INI_ARQ()                                       // acha 1o. reg valido do arquivo
   IF PTAB(PADR(SUBSTR(M->ide_maq,2),4)+[AFU],[IMPPAR],1)
    PTAB(LEFT(IMPPAR->docto,11),'AFUNER',1)
   ENDI
  ENDI
  ccop++                                           // incrementa contador de copias
  DO WHIL !EOF().AND.(!so_um_reg.OR.imp_reg=RECN())
   #ifdef COM_TUTOR
    IF IN_KEY()=K_ESC                              // se quer cancelar
   #else
    IF INKEY()=K_ESC                               // se quer cancelar
   #endi
    IF canc()                                      // pede confirmacao
     BREAK                                         // confirmou...
    ENDI
   ENDI
   IF (PTAB(PADR(SUBSTR(M->ide_maq,2),4)+[AFU],[IMPPAR],1).and.processo+proc2+filial+categ=ALLTRIM(IMPPAR->docto)) .OR. so_um_reg// se atender a condicao...
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,054 SAY "Processo"
    IMPCTL(drvpenf)
    @ cl,063 SAY TRAN(processo+proc2+filial,"@R 99999/99/!!")// Nr.Processo
    IMPCTL(drvtenf)
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,003 SAY "Nome do Contratante:"
    IMPCTL(drvpenf)
    @ cl,024 SAY TRAN(IIF(PTAB(contrato+GRUPOS->titular,'INSCRITS',1),INSCRITS->nome,GRUPOS->nome),"@!")// Nome do contratante
    IMPCTL(drvtenf)
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    IMPAC("Endere‡o:",cl,003)
    IMPCTL(drvpenf)
    @ cl,013 SAY TRAN(xDECRIPT(GRUPOS->endereco),"@!")       // Endereco contratante
    IMPCTL(drvtenf)
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,005 SAY "Cidade               Estado  Documento de Identidade Estado Civil"
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    IMPCTL(drvpenf)
    @ cl,005 SAY TRAN(xDECRIPT(GRUPOS->cidade),"@!")         // cidade contratante
    IMPCTL(drvtenf)
    @ cl,028 SAY TRAN([  ],"!!")                   // Estado Contratante
    IMPCTL(drvpenf)
    @ cl,037 SAY GRUPOS->rg                        // Doc
    IMPCTL(drvtenf)
    if !EMPT(GRUPOS->estcivil)
     IMPCTL(drvpenf)
     @ cl,059 SAY TRAN(subst(tbestciv,AT(GRUPOS->estcivil,tbestciv),10),"@!")// Est.Civil contratante
     IMPCTL(drvtenf)
    endi
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    IMPAC("Contrato    Grupo            Admiss„o                 Processo",cl,005)
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    IMPCTL(drvpenf)
    @ cl,005 SAY contrato                          // contrato numero
    IMPCTL(drvtenf)
    IMPCTL(drvpenf)
    @ cl,018 SAY GRUPOS->grupo                     // grupo
    IMPCTL(drvtenf)
    IMPCTL(drvpenf)
    @ cl,034 SAY GRUPOS->admissao                  // data admissao
    IMPCTL(drvtenf)
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    IMPMEMO(R02901F9(),70,1,cl,002,.t.)            // pedido (memo)
    qli_m=MLCOUNT(R02901F9(),70)-1                 // quantas linhas a imprimir?
    li_m=0
    DO WHIL .t.                                    // imprime linhas do memo
     li_m++
     IF li_m>qli_m                                 // fim do memo
      EXIT
     ENDI
     REL_CAB(1)                                    // soma cl/imprime cabecalho
     IMPMEMO(R02901F9(),70,1+li_m,cl,002,(li_m<qli_m))      // imprime...
     #ifdef COM_TUTOR
      IF IN_KEY()=K_ESC                            // se quer cancelar
     #else
      IF INKEY()=K_ESC                             // se quer cancelar
     #endi
      IF canc()                                    // pede confirmacao
       BREAK                                       // confirmou...
      ENDI
     ENDI
    ENDD
    REL_CAB(2)                                     // soma cl/imprime cabecalho
    @ cl,004 SAY "Nome do falecido....:"
    IMPCTL(drvpenf)
    @ cl,026 SAY TRAN(falecido,"@!")               // nome do falecido
    IMPCTL(drvtenf)
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    IMPAC("Endere‡o do falecido:",cl,004)
    IMPCTL(drvpenf)
    @ cl,026 SAY TRAN(ALLTRIM(ruares)+[, ]+ALLTRIM(baires),"@!")// Endereco falecido
    IMPCTL(drvtenf)
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,004 SAY "Inscrito neste contrato na qualidade de"
    IMPCTL(drvpenf)
    @ cl,044 SAY grauparcon                        // Inscrito na qualidade de
    IMPCTL(drvtenf)
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,004 SAY "Data do Falecimento.:"
    @ cl,026 SAY TRAN(falecto_,"@D")               // Data falcto.
    IMPAC("Hor rio do Falecimento:",cl,036)
    @ cl,060 SAY TRAN(horafal,"99:99")             // Hora Falcto.
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,004 SAY "Cidade do Falecimento Estado   Local do falecimento"
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    IMPCTL(drvpenf)
    @ cl,004 SAY municfal                          // Cidade Falecimento
    IMPCTL(drvtenf)
    IMPCTL(drvpenf)
    @ cl,028 SAY TRAN(estfal,"!!")                 // UF falecimento
    IMPCTL(drvtenf)
    IMPCTL(drvpenf)
    @ cl,035 SAY ALLTRIM(ruafal)                   // local falecimento
    IMPCTL(drvtenf)
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    IMPAC("Cemit‚rio onde foi sepultado        Hora do sepultamento",cl,004)
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    IMPCTL(drvpenf)
    @ cl,004 SAY cemitsep                          // Cemit‚rio sepultamento
    IMPCTL(drvtenf)
    IMPCTL(drvpenf)
    @ cl,046 SAY TRAN(horasepult,"99:99")          // Hora sepultamento
    IMPCTL(drvtenf)
    REL_CAB(2)                                     // soma cl/imprime cabecalho
    @ cl,002 SAY "Datado em       de                    de           , conforme processo"
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    IMPAC("administrativo n£mero",cl,002)
    @ cl,024 SAY TRAN(processo+proc2+filial,"@R 99999/99/!!")// Processo
    @ cl,035 SAY "."
    REL_CAB(2)                                     // soma cl/imprime cabecalho
    @ cl,001 SAY "PROCESSAR"
    @ cl,025 SAY IMPAC(RTRIM(M->p_cidade)+[, ]+LEFT(DTOC(DATE()),2)+[ de ]+NMES(MONTH(DATE()))+ [ de ]+LEFT(DTOS(DATE()),4))// DATA
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY "PAGAMENTO EM"
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    IMPCTL(drvpenf)
    @ cl,002 SAY TRAN(procpagto_,"@D")             // Proc.pagto em
    IMPCTL(drvtenf)
//    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,021 SAY REPL("-",42)
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,021 SAY "Ass.:"
    IMPCTL(drvpenf)
    @ cl,027 SAY GRUPOS->nome                      // Nome
    IMPCTL(drvtenf)
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,027 SAY "RG:"
    @ cl,031 SAY TRAN(GRUPOS->rg,"@!")             // R.G.
/*
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY REPL("-",74)
*/
    SKIP                                           // pega proximo registro
    cl=999                                         // forca salto de pagina
   ELSE                                            // se nao atende condicao
    SKIP                                           // pega proximo registro
   ENDI
   EJEC
   EXIT
  ENDD
 ENDD ccop
END SEQUENCE
SET MARG TO                                        // coloca margem esquerda = 0
IMPCTL(lpp_066)                                    // seta pagina com 66 linhas
SET PRINTER TO (drvporta)                          // fecha arquivo gerado (se houver)
SET DEVI TO SCRE                                   // direciona saida p/ video
IF tps=2                                           // se vai para arquivo/video
 BROWSE_REL(arq_,2,3,MAXROW()-2,78)
ENDI                                               // mostra o arquivo gravado
GRELA(2)                                           // grava variacao do relatorio
SELE AFUNER                                        // salta pagina
SET RELA TO                                        // retira os relacionamentos
SET(_SET_DELETED,dele_atu)                         // os excluidos serao vistos
IF so_um_reg
 POINTER_DBF(sit_dbf)
ENDI
RETU

STATIC PROC REL_CAB(qt)                            // cabecalho do relatorio
IF qt>0                                            // se parametro maior que 0
 cl=cl+qt                                          // soma no contador de linhas
ENDI
IF cl>maxli .OR. qt=0                              // quebra de pagina
 @ 0,015 SAY REPL("-",60)
 @ 0,001 SAY IIF(categ=[PD],[Plano c/Difer. ],IIF(categ=[PL],[Atend.Plano],[Rest.Desp.Funerais]))// Categoria
 @ 1,002 SAY M->setup1                             // Ident1
    IMPCTL(drvpenf)
    IMPCTL(drvpexp)
 @ 3,028 SAY "RECIBO"
    IMPCTL(drvtenf)
    IMPCTL(drvtexp)
 cl=qt+3 ; pg_++
ENDI
RETU

* \\ Final de ADR_R029.PRG
procedure gui_07f9
/*
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
 \ Empresa.: PresServ Inform tica - Limeira (019)452.6623
 \ Programa: GUI_07F9.PRG
 \ Data....: 23-05-98
 \ Sistema.: Administradora - RECEP€„O
 \ Funcao..: Fun‡„o de busca do inscrito, arquivo GUIAS
 \ Analista: Ademilson Pedro Bom
 \ Criacao.: Programado manualmente pelo analista
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/

#include "adrbig.ch"    // inicializa constantes manifestas
LOCAL reg_dbf
PTAB([],[GRUPOS],1,.t.)
IF !(op_menu=INCLUSAO)
 retu .t.
ENDI
PARA cod_igo
reg_dbf:=POINTER_DBF()
PRIVA respx,nomx:=space(35)
codigo:=contrato:=cod_igo
nome:=space(35)
IF EMPT(VAL(contrato)) //=[000000]
 nomx=DBOX("Nome",,,,,"Informe o nome a procurar",nomx,"@!")

 IF PTAB(alltrim(nomx),[GRUPOS],2,.t.)
	codigo:=contrato:=GRUPOS->codigo
	codigo:=VDBF(6,3,20,77,'GRUPOS',{'nome','codigo','xDECRIPT(endereco)','tcarencia'},2,'codigo')
	nome:=GRUPOS->nome
  contrato:=M->codigo


 ELSEIF PTAB(alltrim(nomx),[INSCRITS],2,.t.)
	codigo:=contrato:=INSCRITS->codigo //+INSCRITS->grau+STR(INSCRITS->seq,2)
  nome:=alltrim(inscrits->nome)
	codigo:=VDBF(6,3,20,77,'INSCRITS',{'nome','codigo','grau','tcarencia'},2,'codigo')
	nome:=INSCRITS->nome
  codigo:=contrato:=IIF(codigo=NIL,[         ],left(codigo,9))

 ENDI

 IF LASTKEY()=K_ESC             // se teclou ESC
	codigo:=contrato:=[         ]
	POINTER_DBF(reg_dbf)
	RETU .f.
 ENDI
ELSEIF LEN(ALLTRIM(contrato))<9.AND.!EMPT(COntrato)
 msg_ins:=cod_msg:=[]
 nopc:=1
 tem10:=ptab('010'+strzero(VAL(contrato),6),[GRUPOS],1)
 IF tem10
  cod_msg+=GRUPOS->codigo
 	msg_ins+=GRUPOS->codigo+' '+GRUPOS->nome//+' '+GRUPOS->endereco+' '//+DTOC(GRUPOS->tcarencia)
 ENDI

 tem20:=ptab('020'+strzero(VAL(contrato),6),[GRUPOS],1)
 IF tem20
  IF tem10
   msg_ins+=[|]
  ENDI
  cod_msg+=GRUPOS->codigo
 	msg_ins+=GRUPOS->codigo+' '+GRUPOS->nome//+' '+GRUPOS->endereco//+' '+DTOC(GRUPOS->tcarencia)
 ENDI
 if len(cod_msg) > 9
  msg_:=[Escolha o contrato|Codigo Nome                           Endereco]
  nopc:=DBOX(msg_ins,,,E_MENU,,msg_,,,nopc)
 endi
 codigo:=SUBSTR(cod_msg,((nopc-1)*10)+1,10)


ENDI
respx:=contrato:=codigo

IF PTAB(respx,[GRUPOS],1)
 titular:=GRUPOS->nome
ENDI

POINTER_DBF(reg_dbf)

retu PTAB(respx,[GRUPOS])	 // <- deve retornar um valor qualquer

* \\ Final de GUI_02F9.PRG
€
 ADR_FUN2–õ ADR_FUN2CODECANCCODEROLATELACODEPEGAPAICODEMENURELACODEQUALRELACODE
OPCOES_RELCODETP_SAIDACODE
TRANSCAMPOCODEARQGERCODEPREPIMPCODECONFINCLCODECONFEXCLCODECONFALTCODEROLAPOPCODEPEGADIRCODETRATADIRCODECRIADRVCODERCLACODECOMPACTACODE	CONFCORESCODECONFPRNCODE	IMP_MARCACODE
IMP_PADRAOCODE	IMP_PORTACODE	POE_GAUGECODE
POINTER_DBCODEVDBFCODE
MOUSETECLACODECLICK_EMCODEPWU_INCLCODEPWU_TELACODEPWU_GETSCODEPWU_GET1CODE
TROCASENHACODECRIADBFCODEIMPEXPCODEIMPCTLCODEIMPMEMOCODEMANUREFCODESTATICS$CODEC_ETEXTENDCODE	_SYMSTARTSYMSTARTSYMBOLSSYMBOLS_SYMENDSYMENDNULLBEGDATA_DATADATA_SYMPBDATA_SYMPDATA_SYMPEDATA_CONSTCONST_MSGMSG_BEGBSSBEGBSS_BSSBSS_ENDBSSENDBSSDGROUP´˜ @c:
cd \vip5
copy adrbig.exe adrold.exe /y
arj e c:\adrbp -y
€
 ADC_RX760– ADC_RX76CODEREL_CABCODEGET_MSGCODER07701F9CODER07702F9CODEC_ETEXTENDCODE	_SYMSTARTSYMSTARTSYMBOLSSYMBOLS_SYMENDSYMENDNULLBEGDATA_DATADATA_SYMPBDATA_SYMPDATA_SYMPEDATA_CONSTCONST_MSGMSG_BEGBSSBEGBSS_BSSBSS_ENDBSSENDBSSDGROUPO˜ @CÁ˜ @µa˜ @IÈ˜ @y 	–˜ @å 
&˜ H  ÿ˜ h  Û˜ `ð
å˜ h  Ó˜ h  Ï˜ H  ë˜ H  ç˜ H procedure juros
/*
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
 \ Empresa.: PresServ Inform tica - Limeira (019)452.6623
 \ Programa: JUROS.PRG
 \ Data....: 04-11-03
 \ Sistema.: Administradora - RECEP€„O
 \ Funcao..: Gerenciador do subsistema de parƒmetro de juros
 \ Analista: Ademilson Pedro Bom
 \ Criacao.: GAS-Pro v4.0n
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/
#include "adrbig.ch"    // inicializa constantes manifestas

PARA lin_menu,col_menu
PRIV op_sis, tela_fundo:=SAVESCREEN(0,0,MAXROW(),79), l_s, c_s, l_i, c_i, l_a

op_sis=EVAL(qualsis,"JUROS")
IF nivelop<sistema[op_sis,O_OUTROS,O_NIVEL]        // se usuario nao tem permissao,
 ALERTA()                                          // entao, beep, beep, beep
 DBOX(msg_auto,,,3)                                // lamentamos e
 RETU                                              // retornamos ao menu
ENDI
cn:=fgrep :=.f.

#ifdef COM_LOCK
 IF LEN(pr_ok)>0                                   // se a protecao acusou
  ? pr_ok                                          // erro, avisa e
  QUIT                                             // encerra a aplicacao
 ENDI
#endi

t_fundo=SAVESCREEN(0,0,MAXROW(),79)                // salva tela do fundo
op_cad=1
DO WHIL op_cad!=0
 criterio=""
 RESTSCREEN(0,0,MAXROW(),79,t_fundo)               // restaura tela do fundo
 cod_sos=5 ; cn=.f.
 CLEA TYPEAHEAD                                    // limpa o buffer do teclado
 fgrep=.f.
 SET KEY K_F3 TO                                   // retira das teclas F3 e F4 as
 SET KEY K_F4 TO                                   // funcoes de repeticao e confirmacao
 msg="Inclus„o~1|"+;
     "Manuten‡„o~2|"+;
     "Consulta~3"
 op_cad=DBOX(msg,lin_menu,col_menu,E_MENU,NAO_APAGA,MAIUSC(sistema[op_sis,O_MENU]),,,op_cad)
 IF op_cad!=0                                      // se escolheu uma opcao
  Tela_fundo=SAVESCREEN(0,0,MAXROW(),79)           // salva a tela para ROLATELA()
  PARAMETROS(dbfparam)
  SELE A                                           // e abre o arquivo e seus indices

  #ifdef COM_REDE
   IF !USEARQ(sistema[op_sis,O_ARQUI,O_NOME],.f.,20,1)
                                                   // se falhou a abertura do
    RETU                                           // arquivo volta ao menu anterior
   ENDI
  #else
   USEARQ(sistema[op_sis,O_ARQUI,O_NOME])
  #endi

  SET KEY K_F9 TO veoutros                         // habilita consulta em outros arquivos
 ENDI
 DO CASE
  CASE op_cad=01                                   // inclus„o
   op_menu=INCLUSAO
   IF AT("D",exrot[op_sis])=0                      // se usuario pode fazer inclusao
    JUR_INCL()                                     // neste arquivo chama prg de inclusao
   ELSE                                            // caso contrario vamos avisar que
    ALERTA()                                       // ele nao tem permissao para isto
    DBOX(msg_auto,,,3)
   ENDI

  CASE op_cad=02                                   // manuten‡„o
   op_menu=ALTERACAO
   cod_sos=7
   EDIT()

  CASE op_cad=03                                   // consulta
   op_menu=PROJECOES
   cod_sos=8
   EDITA(05,23,MAXROW()-4,56)

 ENDC
 SET KEY K_F9 TO                                   // F9 nao mais consultara outros arquivos
 CLOS ALL                                          // fecha todos arquivos abertos
ENDD
RETU

PROC JUR_incl(reg_cop)  // inclusao no arquivo JUROS
LOCAL getlist:={}, cabem:=1, rep:=ARRAY(FCOU()), ult_reg:=RECN(),;
      ctl_r, ctl_c, t_f3_, t_f4_, l_max, dele_atu:=SET(_SET_DELETED,.f.)
PRIV op_menu:=INCLUSAO, tem_borda, criterio:="", cpord:="", l_a
FOR i=1 TO FCOU()                                  // cria/declara privadas as
 msg=FIEL(i)                                       // variaveis de memoria com
 PRIV &msg.                                        // o mesmo nome dos campos
NEXT                                               // do arquivo
IF reg_cop!=NIL                                    // quer repetir todo o reg atual
 FOR i=1 TO FCOU()                                 // para cada campo,
  msg=FIEL(i)                                      // salva o conteudo
  rep[i]=&msg.                                     // para repetir
 NEXT
ELSE
 AFILL(rep,"")                                     // eche com valor vazio
ENDI
t_f3_=SETKEY(K_F3,{||rep()})                       // repeticao reg anterior
t_f4_=SETKEY(K_F4,{||conf()})                      // confirma campos com ENTER
ctl_w=SETKEY(K_CTRL_W,{||nadafaz()})               // enganando o CA-Clipper...
ctl_c=SETKEY(K_CTRL_C,{||nadafaz()})
ctl_r=SETKEY(K_CTRL_R,{||nadafaz()})
DISPBEGIN()                                        // monta tela na pagina de traz
JUR_TELA()                                         // imp tela para inclusao
INFOSIS(.t.)                                       // exibe informacao no rodape' da tela
l_a=Sistema[op_sis,O_TELA,O_SCROLL]
DISPEND()                                          // apresenta tela de uma vez so
DO WHIL cabem>0
 cod_sos=6
 rola_t=.f.                                        // flag se quer rolar a tela
 SELE JUROS
 GO BOTT                                           // forca o
 SKIP                                              // final do arquivo
 
 /*
    cria variaveis de memoria identicas as de arquivo, para inclusao
    de registros
 */
 FOR i=1 TO FCOU()
  msg=FIEL(i)
  M->&msg.=IF((fgrep .OR. reg_cop!=NIL).AND.!EMPT(rep[1]),rep[i],&msg.)
 NEXT
 cabem=DISKSPACE(;
          IF(;
             LEN(sistema[op_sis,O_ARQUI,O_DIR_DBF])<2.OR.sistema[op_sis,O_ARQUI,O_DIR_DBF]="\",;
             0,;
             ASC(sistema[op_sis,O_ARQUI,O_DIR_DBF])-64;
          );
       )
 cabem=INT((cabem-2048)/JUROS->(RECSIZE()))
 IF cabem<1                                        // mais nenhum!!!
  ALERTA()
  msg="Verifique ESPA€O EM DISCO, "+usuario
  DBOX(msg,,,,,"INCLUSŽO INTERROMPIDA!")           // vamos parar por aqui!
  EXIT
 ENDI
 SELE 0                                            // torna visiveis variaveis de memoria
 SETCOLOR(drvcortel+","+drvcorget+",,,"+corcampo)
 SET KEY K_ALT_F8 TO ROLATELA
 
 /*
    recebe chaves do arquivo de indice basico
 */
 @ l_s+l_a,c_s+02 GET  tipo;
                  PICT sistema[op_sis,O_CAMPO,01,O_MASC]
                  DEFINICAO 1

 READ
 SET KEY K_ALT_F8 TO
 IF rola_t
  ROLATELA()
  LOOP
 ENDI
 SELE JUROS
 IF LASTKEY()=K_ESC                                // cancelou ou chave em branco
  cabem=0                                          // prepara saida da inclusao
  LOOP                                             // volta p/ menu de cadastramento
 ENDI
 SEEK M->tipo
 aprov_reg_=(FOUND().AND.DELE().AND.!drvvisivel)   // vai aproveitar o registro?
 IF FOUND() .AND. !aprov_reg_                      // pesquisou e achou!
  l_a=Sistema[op_sis,O_TELA,O_SCROLL]
  op_menu=ALTERACAO                                // seta flag de ateracao
  DISPBEGIN()
  JUR_GETS()                                       // mostra conteudo do registro
  INFOSIS(.f.)                                     // exibe informacao no rodape' da tela
  DISPEND()
  ALERTA()
  msg="Consultar/alterar|Retornar … inclus„o"      // pergunta se deseja
  op_=DBOX(msg,,,E_MENU,,"REGISTRO J EXISTE")     // alterar o registro
  IF op_ =1                                        // caso afirmativo
   EDIT()                                          // deixa alterar
  ENDI
  op_menu=INCLUSAO
  DISPBEGIN()
  JUR_TELA()
  INFOSIS(.t.)                                     // exibe informacao no rodape' da tela
  DISPEND()
  LOOP                                             // volta para inclusao
 ENDI
 SELE 0
 JUR_GET1(INCLUI)                                  // recebe campos
 SELE JUROS
 IF LASTKEY()=K_ESC                                // se cancelou
  ALERTA()                                         // avisa que o registro
  DBOX("Registro n„o inclu¡do!",18,,1)             // nao foi incluido, e volta
  LOOP
 ENDI

 #ifdef COM_REDE
  GO BOTT                                          // vamos bloquear o final do
  SKIP                                             // arq para que nehum outro
  BLOREG(0,.5)                                     // usuario possa incluir
  SEEK M->tipo                                     // se registro foi incluido
  aprov_reg_=(FOUND().AND.DELE().AND.!drvvisivel)  // vai aproveitar o registro?
  IF FOUND() .AND. !aprov_reg_                     // por outro usuario, entao
   BLOREG(0,.5)
   FOR i=1 TO FCOU()
    msg=FIEL(i)
    rep[i]=&msg.
    REPL &msg. WITH M->&msg.
   NEXT
   JUR_GET1(FORM_INVERSA)                          // executa formula inversa
   RECA
   FOR i=1 TO FCOU()
    msg=FIEL(i)
    REPL &msg. WITH rep[i]
   NEXT
   ALERTA(4)                                       // beep 4 vezes
   msg="Registro acabou de ser|inclu¡do por outro usu rio!"
   DBOX(msg,,,,,"ATEN€ŽO!")                        // avisa
   SELE JUROS
   UNLOCK                                          // libera o registro
   LOOP                                            // e recebe chave novamente
  ENDI
 #endi

 IF aprov_reg_                                     // se vai aproveitar reg excluido

  #ifdef COM_REDE
   BLOREG(0,.5)
  #endi

  RECA                                             // excluido, vamos recupera-lo
 ELSE                                              // caso contrario
  APPEND BLANK                                     // inclui reg em branco no dbf
 ENDI
 FOR i=1 TO FCOU()                                 // para cada campo,
  msg=FIEL(i)                                      // salva o conteudo
  rep[i]=M->&msg.                                  // para repetir
  REPL &msg. WITH rep[i]                           // enche o campo do arquivo
 NEXT

 #ifdef COM_REDE
  UNLOCK                                           // libera o registro e
  COMMIT                                           // forca gravacao
 #else
  IF RECC()-INT(RECC()/20)*20=0                    // a cada 20 registros
   COMMIT                                          // digitados forca gravacao
  ENDI
 #endi

 ult_reg=RECN()                                    // ultimo registro digitado
 l_max=l_s+Sistema[op_sis,O_TELA,O_SCROLL]+Sistema[op_sis,O_TELA,O_QTDE]
 IF l_s+l_a+1<l_max                                // se nao atingiu o fim da tela
  l_a++                                            // digita na proxima linha
 ELSE                                              // se nao rola a campos para cima
  SCROLL(l_s+Sistema[op_sis,O_TELA,O_SCROLL],c_s+02,l_max-1,c_s+02,1)
  SCROLL(l_s+Sistema[op_sis,O_TELA,O_SCROLL],c_s+09,l_max-1,c_s+13,1)
  SCROLL(l_s+Sistema[op_sis,O_TELA,O_SCROLL],c_s+20,l_max-1,c_s+22,1)
  SCROLL(l_s+Sistema[op_sis,O_TELA,O_SCROLL],c_s+29,l_max-1,c_s+33,1)
  SCROLL(l_s+Sistema[op_sis,O_TELA,O_SCROLL],c_s+41,l_max-1,c_s+43,1)
 ENDI
 IF reg_cop!=NIL                                   // estava na consulta e quis rep o campo
  EXIT                                             // cai fora...
 ENDI
ENDD
GO ult_reg                                         // para o ultimo reg digitado
SETKEY(K_F3,t_f3_)                                 // restaura teclas de funcoes
SETKEY(K_F4,t_f4_)
SET(_SET_DELETED,dele_atu)                            // ecluidos visiveis/invisiveis
SETKEY(K_CTRL_W,ctl_w)
SETKEY(K_CTRL_C,ctl_c)
SETKEY(K_CTRL_R,ctl_r)
RETU


PROC JUR_tela     // tela do arquivo JUROS
tem_borda=.t.
l_s=Sistema[op_sis,O_TELA,O_LS]           // coordenadas da tela
c_s=Sistema[op_sis,O_TELA,O_CS]
l_i=Sistema[op_sis,O_TELA,O_LI]
c_i=Sistema[op_sis,O_TELA,O_CI]
SETCOLOR(drvtittel)
vr_memo=NOVAPOSI(@l_s,@c_s,@l_i,@c_i)     // pega posicao atual da tela
CAIXA(mold,l_s,c_s,l_i,c_i)               // monta caixa da tela
i=LEN(sistema[op_sis,O_MENS])/2
@ l_s,c_s-1+(c_i-c_s+1)/2-i SAY " "+MAIUSC(sistema[op_sis,O_MENS])+" "
SETCOLOR(drvcortel)
@ l_s+01,c_s+1 SAY " Taxa ³    M U L T A      ³    J U R O S"
@ l_s+02,c_s+1 SAY " Tipo ³  %       Carˆncia ³   %      Carˆncia"
@ l_s+03,c_s+1 SAY "ÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ"
@ l_s+04,c_s+1 SAY "      ³                   ³"
@ l_s+05,c_s+1 SAY "      ³                   ³"
@ l_s+06,c_s+1 SAY "      ³                   ³"
@ l_s+07,c_s+1 SAY "      ³                   ³"
@ l_s+08,c_s+1 SAY "      ³                   ³"
RETU

PROC JUR_gets     // mostra variaveis do arquivo JUROS
LOCAL getlist := {}, l_max, reg_atual:=RECNO()
PRIV  l_a:=Sistema[op_sis,O_TELA,O_SCROLL]
JUR_TELA()
l_max=l_s+Sistema[op_sis,O_TELA,O_SCROLL]+Sistema[op_sis,O_TELA,O_QTDE]
SETCOLOR(drvcortel+","+drvcorget+",,,"+corcampo)
DO WHILE !EOF() .AND. l_s+l_a<l_max
 @ l_s+l_a,c_s+02 GET  tipo;
                  PICT sistema[op_sis,O_CAMPO,01,O_MASC]

 @ l_s+l_a,c_s+09 GET  multa;
                  PICT sistema[op_sis,O_CAMPO,02,O_MASC]

 @ l_s+l_a,c_s+20 GET  mltcaren;
                  PICT sistema[op_sis,O_CAMPO,03,O_MASC]

 @ l_s+l_a,c_s+29 GET  juros;
                  PICT sistema[op_sis,O_CAMPO,04,O_MASC]

 @ l_s+l_a,c_s+41 GET  jrscaren;
                  PICT sistema[op_sis,O_CAMPO,05,O_MASC]

 SETCOLOR(drvcortel+","+drvcortel+",,,"+drvcortel)
 l_a++
 SKIP
ENDD
GO reg_atual
SETCOLOR(drvcortel+","+drvcorget+",,,"+corcampo)
CLEAR GETS
RETU

PROC JUR_get1(tp_mov)     // capta variaveis do arquivo JUROS
LOCAL getlist := {}
PRIV  blk_juros:=.t.

IF tp_mov=INCLUI
 IF TYPE("l_a")!="N"
  l_a=Sistema[op_sis,O_TELA,O_SCROLL]
 ENDI
 DO WHILE .t.
  rola_t=.f.
  SET KEY K_ALT_F8 TO ROLATELA
  SETCOLOR(drvcortel+","+drvcorget+",,,"+corcampo)
  @ l_s+l_a,c_s+09 GET  multa;
                   PICT sistema[op_sis,O_CAMPO,02,O_MASC]
                   DEFINICAO 2

  @ l_s+l_a,c_s+20 GET  mltcaren;
                   PICT sistema[op_sis,O_CAMPO,03,O_MASC]
                   DEFINICAO 3

  @ l_s+l_a,c_s+29 GET  juros;
                   PICT sistema[op_sis,O_CAMPO,04,O_MASC]
                   DEFINICAO 4

  @ l_s+l_a,c_s+41 GET  jrscaren;
                   PICT sistema[op_sis,O_CAMPO,05,O_MASC]
                   DEFINICAO 5

  READ
  SET KEY K_ALT_F8 TO
  IF rola_t
   ROLATELA()
   LOOP
  ENDI
  IF LASTKEY()!=K_ESC .AND. drvincl .AND. op_menu=INCLUSAO
   IF !CONFINCL()
    LOOP
   ENDI
  ENDI
  EXIT
 ENDD
ENDI
IF tp_mov=EXCLUI .OR. tp_mov=FORM_INVERSA
 DELE
ELSEIF tp_mov=INCLUI .OR. tp_mov=RECUPERA .OR. tp_mov=FORM_DIRETA
 IF op_menu!=INCLUSAO
  RECA
 ENDI
ENDI
RETU

* \\ Final de JUROS.PRG
/*
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
 \ Empresa.: PresServ Inform tica - Limeira (019)452.6623
 \ Programa: MENSAG.PRG
 \ Data....: 04-11-03
 \ Sistema.: Administradora - RECEP€„O
 \ Funcao..: Gerenciador do subsistema de mensagem p/contrato
 \ Analista: Ademilson Pedro Bom
 \ Criacao.: GAS-Pro v4.0n
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/
#include "adrbig.ch"    // inicializa constantes manifestas

PARA lin_menu,col_menu
PRIV op_sis, tela_fundo:=SAVESCREEN(0,0,MAXROW(),79), l_s, c_s, l_i, c_i, l_a

op_sis=EVAL(qualsis,"MENSAG")
IF nivelop<sistema[op_sis,O_OUTROS,O_NIVEL]        // se usuario nao tem permissao,
 ALERTA()                                          // entao, beep, beep, beep
 DBOX(msg_auto,,,3)                                // lamentamos e
 RETU                                              // retornamos ao menu
ENDI
cn:=fgrep :=.f.

#ifdef COM_LOCK
 IF LEN(pr_ok)>0                                   // se a protecao acusou
  ? pr_ok                                          // erro, avisa e
  QUIT                                             // encerra a aplicacao
 ENDI
#endi

t_fundo=SAVESCREEN(0,0,MAXROW(),79)                // salva tela do fundo
op_cad=1
DO WHIL op_cad!=0
 criterio=""
 RESTSCREEN(0,0,MAXROW(),79,t_fundo)               // restaura tela do fundo
 cod_sos=5 ; cn=.f.
 CLEA TYPEAHEAD                                    // limpa o buffer do teclado
 fgrep=.f.
 SET KEY K_F3 TO                                   // retira das teclas F3 e F4 as
 SET KEY K_F4 TO                                   // funcoes de repeticao e confirmacao
 msg="Inclus„o~1|"+;                               // menu do subsistema
     "Manuten‡„o~2|"+;
     "Consulta~3"
 op_cad=DBOX(msg,lin_menu,col_menu,E_MENU,NAO_APAGA,MAIUSC(sistema[op_sis,O_MENU]),,,op_cad)
 IF op_cad!=0                                      // se escolheu uma opcao
  Tela_fundo=SAVESCREEN(0,0,MAXROW(),79)           // salva a tela para ROLATELA()
  PARAMETROS(dbfparam)
  SELE A                                           // e abre o arquivo e seus indices

  #ifdef COM_REDE
   IF !USEARQ(sistema[op_sis,O_ARQUI,O_NOME],.f.,20,1)
                                                   // se falhou a abertura do
    RETU                                           // arquivo volta ao menu anterior
   ENDI
  #else
   USEARQ(sistema[op_sis,O_ARQUI,O_NOME])
  #endi

  SET KEY K_F9 TO veoutros                         // habilita consulta em outros arquivos
 ENDI
 DO CASE
  CASE op_cad=01                                   // inclus„o
   op_menu=INCLUSAO
   IF AT("D",exrot[op_sis])=0                      // se usuario pode fazer inclusao
    MEN_INCL()                                     // neste arquivo chama prg de inclusao
   ELSE                                            // caso contrario vamos avisar que
    ALERTA()                                       // ele nao tem permissao para isto
    DBOX(msg_auto,,,3)
   ENDI

  CASE op_cad=02                                   // manuten‡„o
   op_menu=ALTERACAO
   cod_sos=7
   EDIT()

  CASE op_cad=03                                   // consulta
   op_menu=PROJECOES
   cod_sos=8
   EDITA(03,03,MAXROW()-2,77)

 ENDC
 SET KEY K_F9 TO                                   // F9 nao mais consultara outros arquivos
 CLOS ALL                                          // fecha todos arquivos abertos
ENDD
RETU

PROC MEN_incl(reg_cop)  // inclusao no arquivo MENSAG
LOCAL getlist:={},cabem:=1,rep:=ARRAY(FCOU()),ult_reg:=RECN(),dbfseq_,;
      ctl_r, ctl_c, ctl_w, t_f3_, t_f4_, dele_atu:=SET(_SET_DELETED,.f.)
PRIV op_menu:=INCLUSAO, sq_atual_, tem_borda, criterio:="", cpord:=""
FOR i=1 TO FCOU()                                  // cria/declara privadas as
 msg=FIEL(i)                                       // variaveis de memoria com
 PRIV &msg.                                        // o mesmo nome dos campos
NEXT                                               // do arquivo
IF reg_cop!=NIL                                    // quer repetir todo o reg atual
 FOR i=1 TO FCOU()                                 // para cada campo,
  msg=FIEL(i)                                      // salva o conteudo
  rep[i]=&msg.                                     // para repetir
 NEXT
ELSE
 AFILL(rep,"")                                     // eche com valor vazio
ENDI
t_f3_=SETKEY(K_F3,{||rep()})                       // repeticao reg anterior
t_f4_=SETKEY(K_F4,{||conf()})                      // confirma campos com ENTER
ctl_w=SETKEY(K_CTRL_W,{||nadafaz()})               // enganando o CA-Clipper...
ctl_c=SETKEY(K_CTRL_C,{||nadafaz()})
ctl_r=SETKEY(K_CTRL_R,{||nadafaz()})

#ifdef COM_REDE
 MEN_CRIA_SEQ()                                    // cria dbf de controle de cp sequenciais
 FOR i=1 TO FCOU()                                 // cria/declara privadas as
  msg="sq_"+FIEL(i)                                // variaveis de memoria com
  PRIV &msg.                                       // o mesmo nome dos campos
 NEXT                                              // do arquivo com extensao _seq
#endi

DO WHIL cabem>0
 cod_sos=6
 rola_t=.f.                                        // flag se quer rolar a tela
 SELE MENSAG
 GO BOTT                                           // forca o
 SKIP                                              // final do arquivo
 
 /*
    cria variaveis de memoria identicas as de arquivo, para inclusao
    de registros
 */
 FOR i=1 TO FCOU()
  msg=FIEL(i)
  M->&msg.=IF((fgrep .OR. reg_cop!=NIL).AND.!EMPT(rep[1]),rep[i],&msg.)
 NEXT
 DISPBEGIN()                                       // apresenta a tela de uma vez so
 MEN_TELA()
 INFOSIS(.t.)                                      // exibe informacao no rodape' da tela
 DISPEND()
 MEN_GERA_SEQ()
 cabem=DISKSPACE(;
          IF(;
             LEN(sistema[op_sis,O_ARQUI,O_DIR_DBF])<2.OR.sistema[op_sis,O_ARQUI,O_DIR_DBF]="\",;
             0,;
             ASC(sistema[op_sis,O_ARQUI,O_DIR_DBF])-64;
          );
       )
 cabem=INT((cabem-2048)/MENSAG->(RECSIZE()))
 IF cabem<1                                        // mais nenhum!!!
  ALERTA()
  msg="Verifique ESPA€O EM DISCO, "+usuario
  DBOX(msg,,,,,"INCLUSŽO INTERROMPIDA!")           // vamos parar por aqui!
  EXIT
 ENDI
 SELE 0                                            // torna visiveis variaveis de memoria
 SETCOLOR(drvcortel+","+drvcorget+",,,"+corcampo)
 SET KEY K_ALT_F8 TO ROLATELA
 
 /*
    recebe chaves do arquivo de indice basico
 */
 @ l_s+01 ,c_s+12 GET  seq;
                  PICT sistema[op_sis,O_CAMPO,01,O_MASC]
                  DEFINICAO 1

 READ
 SET KEY K_ALT_F8 TO
 IF rola_t
  ROLATELA()

  #ifdef COM_REDE
   MEN_ANT_SEQ()                                   // decrementa sequencial
  #endi

  LOOP
 ENDI
 SELE MENSAG
 IF LASTKEY()=K_ESC                                // cancelou ou chave em branco
  cabem=0                                          // prepara saida da inclusao
  LOOP                                             // volta p/ menu de cadastramento
 ENDI
 SEEK M->seq
 aprov_reg_=(FOUND().AND.DELE().AND.!drvvisivel)   // vai aproveitar o registro?
 IF FOUND() .AND. !aprov_reg_                      // pesquisou e achou!
  op_menu=ALTERACAO                                // seta flag de ateracao

  #ifdef COM_REDE
   MEN_ANT_SEQ()                                   // decrementa sequencial
   SELE MENSAG
  #endi

  DISPBEGIN()
  MEN_GETS()                                       // mostra conteudo do registro
  INFOSIS(.f.)                                     // exibe informacao no rodape' da tela
  DISPEND()
  ALERTA()
  msg="Consultar/alterar|Retornar … inclus„o"      // pergunta se deseja
  op_=DBOX(msg,,,E_MENU,,"REGISTRO J EXISTE")     // alterar o registro
  IF op_ =1                                        // caso afirmativo
   EDIT()                                          // deixa alterar
  ENDI
  op_menu=INCLUSAO
  LOOP                                             // volta para inclusao
 ENDI
 SELE 0
 MEN_GET1(INCLUI)                                  // recebe campos
 SELE MENSAG
 IF LASTKEY()=K_ESC                                // se cancelou

  #ifdef COM_REDE
   MEN_ANT_SEQ()                                   // decrementa sequencial
  #endi

  ALERTA()                                         // avisa que o registro
  DBOX("Registro n„o inclu¡do!",18,,1)             // nao foi incluido, e volta
  LOOP
 ENDI

 #ifdef COM_REDE
  GO BOTT                                          // vamos bloquear o final do
  SKIP                                             // arq para que nehum outro
  BLOREG(0,.5)                                     // usuario possa incluir
  SEEK M->seq                                      // se registro foi incluido
  aprov_reg_=(FOUND().AND.DELE().AND.!drvvisivel)  // vai aproveitar o registro?
  IF FOUND() .AND. !aprov_reg_                     // por outro usuario, entao
   BLOREG(0,.5)
   FOR i=1 TO FCOU()
    msg=FIEL(i)
    rep[i]=&msg.
    REPL &msg. WITH M->&msg.
   NEXT
   MEN_GET1(FORM_INVERSA)                          // executa formula inversa
   RECA
   FOR i=1 TO FCOU()
    msg=FIEL(i)
    REPL &msg. WITH rep[i]
   NEXT
   ALERTA(4)                                       // beep 4 vezes
   msg="Registro acabou de ser|inclu¡do por outro usu rio!"
   DBOX(msg,,,,,"ATEN€ŽO!")                        // avisa
   SELE MENSAG
   UNLOCK                                          // libera o registro
   LOOP                                            // e recebe chave novamente
  ENDI
 #endi

 IF aprov_reg_                                     // se vai aproveitar reg excluido

  #ifdef COM_REDE
   BLOREG(0,.5)
  #endi

  RECA                                             // excluido, vamos recupera-lo
 ELSE                                              // caso contrario
  APPEND BLANK                                     // inclui reg em branco no dbf
 ENDI
 FOR i=1 TO FCOU()                                 // para cada campo,
  msg=FIEL(i)                                      // salva o conteudo
  rep[i]=M->&msg.                                  // para repetir
  REPL &msg. WITH rep[i]                           // enche o campo do arquivo
 NEXT

 #ifdef COM_REDE
  UNLOCK                                           // libera o registro e
  COMMIT                                           // forca gravacao
 #else
  IF RECC()-INT(RECC()/20)*20=0                    // a cada 20 registros
   COMMIT                                          // digitados forca gravacao
  ENDI
 #endi

 ult_reg=RECN()                                    // ultimo registro digitado
 IF reg_cop!=NIL                                   // estava na consulta e quis rep o campo
  sq_atual_=NIL
  EXIT                                             // cai fora...
 ENDI
ENDD

#ifdef COM_REDE
 MEN_ANT_SEQ()                                     // restaura sequencial anterior
 SELE MENSAG
#endi

GO ult_reg                                         // para o ultimo reg digitado
SETKEY(K_F3,t_f3_)                                 // restaura teclas de funcoes
SETKEY(K_F4,t_f4_)
SET(_SET_DELETED,dele_atu)                            // ecluidos visiveis/invisiveis
SETKEY(K_CTRL_W,ctl_w)
SETKEY(K_CTRL_C,ctl_c)
SETKEY(K_CTRL_R,ctl_r)
RETU



#ifdef COM_REDE
 PROC MEN_ANT_SEQ(est_seq)     // restaura sequencial anterior
 SELE MEN_SEQ     // seleciona arquivo de controle de sequencial
 BLOARQ(0,.5)     // esta estacao foi a ultima a incluir?
 IF sq_atual_ == seq
  REPL seq WITH sq_seq
 ENDI
 UNLOCK           // libera DBF para outros usuarios
 COMMIT           // atualiza cps sequenciais no disco
 RETU
#endi


PROC MEN_CRIA_SEQ   // cria dbf de controle de campos sequenciais
LOCAL dbfseq_:=sistema[op_sis,O_ARQUI,O_DIR_DBF]+"MEN_seq" // arq temporario
SELE 0                          // seleciona area vazia
IF !FILE(dbfseq_+".dbf")        // se o dbf nao existe
 DBCREATE(dbfseq_,{;            // vamos criar a sua estrutura
                    {"seq"       ,"C",  6, 0};
                  };
 )
ENDI
USEARQ(dbfseq_,.f.,,,.f.)       // abre arquivo de cps sequencial
IF RECC()=0                     // se o dbf foi criado agora
 BLOARQ(0,.5)                   // inclui um registro que tera
 APPEND BLANK                   // os ultomos cps sequenciais
 SELE MENSAG
 IF RECC()>0                    // se o DBF nao estiver
  SET ORDER TO 0                // vazio, entao enche DBF seq
  GO BOTT                       // com o ultimo reg digitado
  REPL MEN_SEQ->seq WITH seq
  DBSETORDER(1)                 // retorna ao indice principal
 ENDI
 SELE MEN_SEQ                   // seleciona arq de sequencias
 UNLOCK                         // libera DBF para outros usuarios
 COMMIT                         // atualiza cps sequenciais no disco
ENDI
RETURN

PROC MEN_GERA_SEQ()

#ifdef COM_REDE
 LOCAL ar_:=SELEC()
#else
 LOCAL reg_:=RECNO(),ord_ind:=INDEXORD()
#endi


#ifdef COM_REDE
 SELE MEN_SEQ
 BLOARQ(0,.5)
 sq_seq=MEN_SEQ->seq
#else
 DBSETORDER(0)
 GO BOTT
#endi

M->seq=LPAD(STR(VAL(seq)+1),06,[0])

#ifdef COM_REDE
 MEN_GRAVA_SEQ()
 sq_atual_=MEN_SEQ->seq
 UNLOCK                                            // libera o registro
 COMMIT
 SELE (ar_)
#else
 DBSETORDER(ord_ind)
 GO reg_
#endi

RETU

PROC MEN_GRAVA_SEQ
REPL seq WITH M->seq
RETU

PROC MEN_tela     // tela do arquivo MENSAG
tem_borda=.t.
l_s=Sistema[op_sis,O_TELA,O_LS]           // coordenadas da tela
c_s=Sistema[op_sis,O_TELA,O_CS]
l_i=Sistema[op_sis,O_TELA,O_LI]
c_i=Sistema[op_sis,O_TELA,O_CI]
SETCOLOR(drvtittel)
vr_memo=NOVAPOSI(@l_s,@c_s,@l_i,@c_i)     // pega posicao atual da tela
CAIXA(mold,l_s,c_s,l_i,c_i)               // monta caixa da tela
i=LEN(sistema[op_sis,O_MENS])/2
@ l_s,c_s-1+(c_i-c_s+1)/2-i SAY " "+MAIUSC(sistema[op_sis,O_MENS])+" "
SETCOLOR(drvcortel)
@ l_s+01,c_s+1 SAY " N£mero..:                              (                   )"
@ l_s+02,c_s+1 SAY " Condi‡„o:"
@ l_s+03,c_s+1 SAY " Mensagem:"
RETU

PROC MEN_gets     // mostra variaveis do arquivo MENSAG
LOCAL getlist := {}, t_f7_
MEN_TELA()
SETCOLOR(drvcortel+","+drvcorget+",,,"+corcampo)
CRIT("",,"1|7")
@ l_s+01 ,c_s+12 GET  seq;
                 PICT sistema[op_sis,O_CAMPO,01,O_MASC]

@ l_s+02 ,c_s+12 GET  filtro;
                 PICT sistema[op_sis,O_CAMPO,02,O_MASC]

@ l_s+03 ,c_s+12 SAY "{M} "

CRIT("",,"2|3|4|5|6")
CLEAR GETS
RETU

PROC MEN_get1(tp_mov)     // capta variaveis do arquivo MENSAG
LOCAL getlist := {}, t_f7_
PRIV  blk_mensag:=.t.

IF tp_mov=INCLUI
 DO WHILE .t.
  rola_t=.f.
  memo03:="{F7}"
  t_f7_=SETKEY(K_F7,{||MEN_memo()})
  SET KEY K_ALT_F8 TO ROLATELA
  SETCOLOR(drvcortel+","+drvcorget+",,,"+corcampo)
  CRIT("",,"1|7")
  @ l_s+02 ,c_s+12 GET  filtro;
                   PICT sistema[op_sis,O_CAMPO,02,O_MASC]
                   DEFINICAO 2

  @ l_s+03 ,c_s+12 GET  memo03;
                   PICT "@!"
                   DEFINICAO 3

  READ
  SETKEY(K_F7,t_f7_)
  SET KEY K_ALT_F8 TO
  IF rola_t
   ROLATELA()
   LOOP
  ENDI
  IF LASTKEY()!=K_ESC .AND. drvincl .AND. op_menu=INCLUSAO
   IF !CONFINCL()
    LOOP
   ENDI
  ENDI
  EXIT
 ENDD
ENDI
IF tp_mov=EXCLUI .OR. tp_mov=FORM_INVERSA
 IF !EMPTY(ALIAS())
  DELE
 ENDI
ELSEIF tp_mov=INCLUI .OR. tp_mov=RECUPERA .OR. tp_mov=FORM_DIRETA
 IF (op_menu=INCLUSAO .AND. LASTKEY()!=K_ESC) .OR. op_menu!=INCLUSAO
   IF EMPT(lancto_)
    IF op_menu=INCLUSAO
     por=M->usuario
    ELSE
     REPL por WITH M->usuario
    ENDI
   ENDI
   IF EMPT(lancto_)
    IF op_menu=INCLUSAO
     lancto_=DATE()
    ELSE
     REPL lancto_ WITH DATE()
    ENDI
   ENDI
  IF op_menu!=INCLUSAO
   RECA
  ENDI
 ENDI
ENDI
RETU

PROC MEN_MEMO
IF READVAR()="MEMO03"
 EDIMEMO("mens1",sistema[op_sis,O_CAMPO,03,O_TITU],14,2,23,53)
ENDI
RETU

* \\ Final de MENSAG.PRG
/*
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
 \ Empresa.: PresServ Inform tica - Limeira (019)452.6623
 \ Programa: AFUNER.PRG
 \ Data....: 04-11-03
 \ Sistema.: Administradora - RECEP€„O
 \ Funcao..: Gerenciador do subsistema de lan‡amento aux.funeral
 \ Analista: Ademilson Pedro Bom
 \ Criacao.: GAS-Pro v4.0n
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/

#include "adrbig.ch"    // inicializa constantes manifestas

PARA lin_menu,col_menu
PRIV op_sis, tela_fundo:=SAVESCREEN(0,0,MAXROW(),79), l_s, c_s, l_i, c_i, l_a

op_sis=EVAL(qualsis,"AFUNER")
IF nivelop<sistema[op_sis,O_OUTROS,O_NIVEL]        // se usuario nao tem permissao,
 ALERTA()                                          // entao, beep, beep, beep
 DBOX(msg_auto,,,3)                                // lamentamos e
 RETU                                              // retornamos ao menu
ENDI
cn:=fgrep :=.f.

#ifdef COM_LOCK
 IF LEN(pr_ok)>0                                   // se a protecao acusou
  ? pr_ok                                          // erro, avisa e
  QUIT                                             // encerra a aplicacao
 ENDI
#endi

t_fundo=SAVESCREEN(0,0,MAXROW(),79)                // salva tela do fundo
op_cad=1
DO WHIL op_cad!=0
 criterio=""
 RESTSCREEN(0,0,MAXROW(),79,t_fundo)               // restaura tela do fundo
 cod_sos=5 ; cn=.f.
 CLEA TYPEAHEAD                                    // limpa o buffer do teclado
 fgrep=.f.
 SET KEY K_F3 TO                                   // retira das teclas F3 e F4 as
 SET KEY K_F4 TO                                   // funcoes de repeticao e confirmacao
 msg="Inclus„o~1|"+;
     "Manuten‡„o~2|"+;
     "Consulta~3"
 op_cad=DBOX(msg,lin_menu,col_menu,E_MENU,NAO_APAGA,MAIUSC(sistema[op_sis,O_MENU]),,,op_cad)
 IF op_cad!=0                                      // se escolheu uma opcao
  Tela_fundo=SAVESCREEN(0,0,MAXROW(),79)           // salva a tela para ROLATELA()
  PARAMETROS(dbfparam)
  SELE A                                           // e abre o arquivo e seus indices

  #ifdef COM_REDE
   IF !USEARQ(sistema[op_sis,O_ARQUI,O_NOME],.f.,20,1)
                                                   // se falhou a abertura do
    RETU                                           // arquivo volta ao menu anterior
   ENDI
  #else
   USEARQ(sistema[op_sis,O_ARQUI,O_NOME])
  #endi

  SET KEY K_F9 TO veoutros                         // habilita consulta em outros arquivos
 ENDI
 DO CASE
  CASE op_cad=01                                   // inclus„o
   op_menu=INCLUSAO
   IF AT("D",exrot[op_sis])=0                      // se usuario pode fazer inclusao
    AFU_INCL()                                     // neste arquivo chama prg de inclusao
   ELSE                                            // caso contrario vamos avisar que
    ALERTA()                                       // ele nao tem permissao para isto
    DBOX(msg_auto,,,3)
   ENDI

  CASE op_cad=02                                   // manuten‡„o
   op_menu=ALTERACAO
   cod_sos=7
   EDIT()

  CASE op_cad=03                                   // consulta
   op_menu=PROJECOES
   cod_sos=8
   EDITA(03,03,MAXROW()-2,77)

 ENDC
 SET KEY K_F9 TO                                   // F9 nao mais consultara outros arquivos
 CLOS ALL                                          // fecha todos arquivos abertos
ENDD
RETU

PROC AFU_incl(reg_cop)  // inclusao no arquivo AFUNER
LOCAL getlist:={},cabem:=1,rep:=ARRAY(FCOU()),ult_reg:=RECN(),cond_incl_,dbfseq_,;
      ctl_r, ctl_c, ctl_w, t_f3_, t_f4_, dele_atu:=SET(_SET_DELETED,.f.)
PRIV op_menu:=INCLUSAO, sq_atual_, tem_borda, criterio:="", cpord:=""
cond_incl_={||nivelop>1}                           // condicao de inclusao de registros
IF !EVAL(cond_incl_)                               // se nao pode incluir
 ALERTA(2)                                         // avisa o motivo
 DBOX("Permitido apenas a usu rios cadastrados|com n¡vel de Manuten‡„o ou Maior",,,4,,"ATEN€ŽO, "+usuario)
 RETU                                              // e retorna
ENDI
FOR i=1 TO FCOU()                                  // cria/declara privadas as
 msg=FIEL(i)                                       // variaveis de memoria com
 PRIV &msg.                                        // o mesmo nome dos campos
NEXT                                               // do arquivo
IF reg_cop!=NIL                                    // quer repetir todo o reg atual
 FOR i=1 TO FCOU()                                 // para cada campo,
  msg=FIEL(i)                                      // salva o conteudo
  rep[i]=&msg.                                     // para repetir
 NEXT
ELSE
 AFILL(rep,"")                                     // eche com valor vazio
ENDI
t_f3_=SETKEY(K_F3,{||rep()})                       // repeticao reg anterior
t_f4_=SETKEY(K_F4,{||conf()})                      // confirma campos com ENTER
ctl_w=SETKEY(K_CTRL_W,{||nadafaz()})               // enganando o CA-Clipper...
ctl_c=SETKEY(K_CTRL_C,{||nadafaz()})
ctl_r=SETKEY(K_CTRL_R,{||nadafaz()})

#ifdef COM_REDE
 AFU_CRIA_SEQ()                                    // cria dbf de controle de cp sequenciais
 FOR i=1 TO FCOU()                                 // cria/declara privadas as
  msg="sq_"+FIEL(i)                                // variaveis de memoria com
  PRIV &msg.                                       // o mesmo nome dos campos
 NEXT                                              // do arquivo com extensao _seq
#endi

DO WHIL cabem>0
 cod_sos=6
 rola_t=.f.                                        // flag se quer rolar a tela
 SELE AFUNER
 GO BOTT                                           // forca o
 SKIP                                              // final do arquivo
 
 /*
    cria variaveis de memoria identicas as de arquivo, para inclusao
    de registros
 */
 FOR i=1 TO FCOU()
  msg=FIEL(i)
  M->&msg.=IF((fgrep .OR. reg_cop!=NIL).AND.!EMPT(rep[1]),rep[i],&msg.)
 NEXT
 DISPBEGIN()                                       // apresenta a tela de uma vez so
 AFU_TELA()
 INFOSIS(.t.)                                      // exibe informacao no rodape' da tela
 DISPEND()
 AFU_GERA_SEQ()
 IF !EVAL(cond_incl_)
  EXIT
 ENDI
 cabem=DISKSPACE(;
          IF(;
             LEN(sistema[op_sis,O_ARQUI,O_DIR_DBF])<2.OR.sistema[op_sis,O_ARQUI,O_DIR_DBF]="\",;
             0,;
             ASC(sistema[op_sis,O_ARQUI,O_DIR_DBF])-64;
          );
       )
 cabem=INT((cabem-2048)/AFUNER->(RECSIZE()))
 IF cabem<1                                        // mais nenhum!!!
  ALERTA()
  msg="Verifique ESPA€O EM DISCO, "+usuario
  DBOX(msg,,,,,"INCLUSŽO INTERROMPIDA!")           // vamos parar por aqui!
  EXIT
 ENDI
 SELE 0                                            // torna visiveis variaveis de memoria
 SETCOLOR(drvcortel+","+drvcorget+",,,"+corcampo)
 SET KEY K_ALT_F8 TO ROLATELA
 
 /*
    recebe chaves do arquivo de indice basico
 */
 @ l_s+01 ,c_s+14 GET  processo;
                  PICT sistema[op_sis,O_CAMPO,01,O_MASC]
                  DEFINICAO 1

 @ l_s+01 ,c_s+20 GET  proc2;
                  PICT sistema[op_sis,O_CAMPO,02,O_MASC]
                  DEFINICAO 2

 READ
 SET KEY K_ALT_F8 TO
 IF rola_t
  ROLATELA()

  #ifdef COM_REDE
   AFU_ANT_SEQ()                                   // decrementa sequencial
  #endi

  LOOP
 ENDI
 SELE AFUNER
 IF LASTKEY()=K_ESC                                // cancelou ou chave em branco
  cabem=0                                          // prepara saida da inclusao
  LOOP                                             // volta p/ menu de cadastramento
 ENDI
 SEEK M->processo+M->proc2
 aprov_reg_=(FOUND().AND.DELE().AND.!drvvisivel)   // vai aproveitar o registro?
 IF FOUND() .AND. !aprov_reg_                      // pesquisou e achou!
  op_menu=ALTERACAO                                // seta flag de ateracao

  #ifdef COM_REDE
   AFU_ANT_SEQ()                                   // decrementa sequencial
   SELE AFUNER
  #endi

  DISPBEGIN()
  AFU_GETS()                                       // mostra conteudo do registro
  INFOSIS(.f.)                                     // exibe informacao no rodape' da tela
  DISPEND()
  ALERTA()
  msg="Consultar/alterar|Retornar … inclus„o"      // pergunta se deseja
  op_=DBOX(msg,,,E_MENU,,"REGISTRO J EXISTE")     // alterar o registro
  IF op_ =1                                        // caso afirmativo
   EDIT()                                          // deixa alterar
  ENDI
  op_menu=INCLUSAO
  LOOP                                             // volta para inclusao
 ENDI
 SELE 0
 AFU_GET1(INCLUI)                                  // recebe campos
 SELE AFUNER
 IF LASTKEY()=K_ESC                                // se cancelou

  #ifdef COM_REDE
   AFU_ANT_SEQ()                                   // decrementa sequencial
  #endi

  ALERTA()                                         // avisa que o registro
  DBOX("Registro n„o inclu¡do!",18,,1)             // nao foi incluido, e volta
  LOOP
 ENDI

 #ifdef COM_REDE
  GO BOTT                                          // vamos bloquear o final do
  SKIP                                             // arq para que nehum outro
  BLOREG(0,.5)                                     // usuario possa incluir
  SEEK M->processo+M->proc2                        // se registro foi incluido
  aprov_reg_=(FOUND().AND.DELE().AND.!drvvisivel)  // vai aproveitar o registro?
  IF FOUND() .AND. !aprov_reg_                     // por outro usuario, entao
   BLOREG(0,.5)
   FOR i=1 TO FCOU()
    msg=FIEL(i)
    rep[i]=&msg.
    REPL &msg. WITH M->&msg.
   NEXT
   AFU_GET1(FORM_INVERSA)                          // executa formula inversa
   RECA
   FOR i=1 TO FCOU()
    msg=FIEL(i)
    REPL &msg. WITH rep[i]
   NEXT
   ALERTA(4)                                       // beep 4 vezes
   msg="Registro acabou de ser|inclu¡do por outro usu rio!"
   DBOX(msg,,,,,"ATEN€ŽO!")                        // avisa
   SELE AFUNER
   UNLOCK                                          // libera o registro
   LOOP                                            // e recebe chave novamente
  ENDI
 #endi

 IF aprov_reg_                                     // se vai aproveitar reg excluido

  #ifdef COM_REDE
   BLOREG(0,.5)
  #endi

  RECA                                             // excluido, vamos recupera-lo
 ELSE                                              // caso contrario
  APPEND BLANK                                     // inclui reg em branco no dbf
 ENDI
 FOR i=1 TO FCOU()                                 // para cada campo,
  msg=FIEL(i)                                      // salva o conteudo
  rep[i]=M->&msg.                                  // para repetir
  REPL &msg. WITH rep[i]                           // enche o campo do arquivo
 NEXT

 #ifdef COM_REDE
  UNLOCK                                           // libera o registro e
  COMMIT                                           // forca gravacao
 #else
  IF RECC()-INT(RECC()/20)*20=0                    // a cada 20 registros
   COMMIT                                          // digitados forca gravacao
  ENDI
 #endi

 ult_reg=RECN()                                    // ultimo registro digitado
 AFU_REL(ult_reg)                               // imprime relat apos inclusao
 IF reg_cop!=NIL                                   // estava na consulta e quis rep o campo
  sq_atual_=NIL
  EXIT                                             // cai fora...
 ENDI
ENDD

#ifdef COM_REDE
 AFU_ANT_SEQ()                                     // restaura sequencial anterior
 SELE AFUNER
#endi

GO ult_reg                                         // para o ultimo reg digitado
SETKEY(K_F3,t_f3_)                                 // restaura teclas de funcoes
SETKEY(K_F4,t_f4_)
SET(_SET_DELETED,dele_atu)                            // ecluidos visiveis/invisiveis
SETKEY(K_CTRL_W,ctl_w)
SETKEY(K_CTRL_C,ctl_c)
SETKEY(K_CTRL_R,ctl_r)
RETU


PROC AFU_REL(ult_reg)  // imprime relatorio apos inclusao
LOCAL p_imp:=.t., i_ok:=.f., imp_rel:=.f.
DO WHIL .t.
 SAVE SCREEN                     // salva a tela

 #ifdef COM_REDE
  tps=TP_SAIDA(,,.t.)            // escolhe a impressora
  IF LASTKEY()=K_ESC             // se teclou ESC
   EXIT                          // cai fora...
  ENDI
  IF tps=2 .OR. PREPIMP("AUXILIO FUNERAL")   // se nao vai para video conf impressora pronta
   IF categ=[AF]
    ADM_R020(tps,0,ult_reg)
    ADR_R029(tps,0,ult_reg)
   ELSE
    ADM_RX20(tps,0,ult_reg)
    ADR_RX29(tps,0,ult_reg)
   ENDI
   ADM_R029(tps,0,ult_reg)
 #else
  IF PREPIMP("AUXILIO FUNERAL")              // confima preparacao da impressora
   IF categ=[AF]
    ADM_R020(0,0,ult_reg)
    ADR_R029(0,0,ult_reg)
   ELSE
    ADM_RX20(0,0,ult_reg)
    ADR_RX29(0,0,ult_reg)
   ENDI
   ADM_R029(0,0,ult_reg)
 #endi

 REST SCREEN                    // restaura tela
  msg="Prosseguir|Outra c¢pia"
  op_=1 //DBOX(msg,,,E_MENU,,"FIM DE IMPRESSŽO") // quer emitir outra copia?
  IF op_=2
   LOOP                         // nao quer...
  ENDI
 ENDI
 EXIT
ENDD
RETU


#ifdef COM_REDE
 PROC AFU_ANT_SEQ(est_seq)     // restaura sequencial anterior
 SELE AFU_SEQ     // seleciona arquivo de controle de sequencial
 BLOARQ(0,.5)     // esta estacao foi a ultima a incluir?
 IF sq_atual_ == processo
  REPL processo WITH sq_processo
  REPL intlan WITH sq_intlan
 ENDI
 UNLOCK           // libera DBF para outros usuarios
 COMMIT           // atualiza cps sequenciais no disco
 RETU
#endi


PROC AFU_CRIA_SEQ   // cria dbf de controle de campos sequenciais
LOCAL dbfseq_:=sistema[op_sis,O_ARQUI,O_DIR_DBF]+"AFU_seq" // arq temporario
SELE 0                          // seleciona area vazia
IF !FILE(dbfseq_+".dbf")        // se o dbf nao existe
 DBCREATE(dbfseq_,{;            // vamos criar a sua estrutura
                    {"processo"  ,"C",  5, 0},;
                    {"intlan"    ,"C",  8, 0};
                  };
 )
ENDI
USEARQ(dbfseq_,.f.,,,.f.)       // abre arquivo de cps sequencial
IF RECC()=0                     // se o dbf foi criado agora
 BLOARQ(0,.5)                   // inclui um registro que tera
 APPEND BLANK                   // os ultomos cps sequenciais
 SELE AFUNER
 IF RECC()>0                    // se o DBF nao estiver
  SET ORDER TO 0                // vazio, entao enche DBF seq
  GO BOTT                       // com o ultimo reg digitado
  REPL AFU_SEQ->processo WITH processo
  REPL AFU_SEQ->intlan WITH intlan
  DBSETORDER(1)                 // retorna ao indice principal
 ENDI
 SELE AFU_SEQ                   // seleciona arq de sequencias
 UNLOCK                         // libera DBF para outros usuarios
 COMMIT                         // atualiza cps sequenciais no disco
ENDI
RETURN

PROC AFU_GERA_SEQ()

#ifdef COM_REDE
 LOCAL ar_:=SELEC()
#else
 LOCAL reg_:=RECNO(),ord_ind:=INDEXORD()
#endi


#ifdef COM_REDE
 SELE AFU_SEQ
 BLOARQ(0,.5)
 sq_processo=AFU_SEQ->processo
 sq_intlan=AFU_SEQ->intlan
#else
 DBSETORDER(0)
 GO BOTT
#endi

M->processo=LPAD(STR(VAL(processo)+1),05,[0])
M->intlan=LPAD(STR(VAL(intlan)+1),08,[0])

#ifdef COM_REDE
 AFU_GRAVA_SEQ()
 sq_atual_=AFU_SEQ->processo
 UNLOCK                                            // libera o registro
 COMMIT
 SELE (ar_)
#else
 DBSETORDER(ord_ind)
 GO reg_
#endi

RETU

PROC AFU_GRAVA_SEQ
REPL processo WITH M->processo
REPL intlan WITH M->intlan
RETU

PROC AFU_tela     // tela do arquivo AFUNER
tem_borda=.t.
l_s=Sistema[op_sis,O_TELA,O_LS]           // coordenadas da tela
c_s=Sistema[op_sis,O_TELA,O_CS]
l_i=Sistema[op_sis,O_TELA,O_LI]
c_i=Sistema[op_sis,O_TELA,O_CI]
SETCOLOR(drvtittel)
vr_memo=NOVAPOSI(@l_s,@c_s,@l_i,@c_i)     // pega posicao atual da tela
CAIXA(mold,l_s,c_s,l_i,c_i)               // monta caixa da tela
i=LEN(sistema[op_sis,O_MENS])/2
@ l_s,c_s-1+(c_i-c_s+1)/2-i SAY " "+MAIUSC(sistema[op_sis,O_MENS])+" "
SETCOLOR(drvcortel)
@ l_s+01,c_s+1 SAY " Processo..:      /  /    de             Categoria:"
@ l_s+02,c_s+1 SAY " ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ   Dados do Contratante  ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ"
@ l_s+03,c_s+1 SAY " Contrato...:"
@ l_s+04,c_s+1 SAY " Grau.......:"
@ l_s+05,c_s+1 SAY " Respons vel:                                     (Declarante)"
@ l_s+06,c_s+1 SAY " Endere‡o...:                                      Fone:"
@ l_s+07,c_s+1 SAY " ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ   Dados do Falecido   ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ"
@ l_s+08,c_s+1 SAY " Inscrito..:"
@ l_s+09,c_s+1 SAY " Rua...:                                 Bairro:"
@ l_s+10,c_s+1 SAY " Cidade:                           UF:     Dt.Nasc.:"
@ l_s+11,c_s+1 SAY " ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ   Dados do Falecimento   ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ"
@ l_s+12,c_s+1 SAY " Data:            hora:        Endere‡o:"
@ l_s+13,c_s+1 SAY "               Cidade:                           UF:"
@ l_s+14,c_s+1 SAY " Seu sepultamento ser  ..:            hora:"
@ l_s+15,c_s+1 SAY "                Cemit‚rio:"
@ l_s+16,c_s+1 SAY " Funcion rio respons vel.:"
@ l_s+18,c_s+1 SAY " Proc. Pgto em:              Vl.Auxilio:                Pago em"
RETU

PROC AFU_gets     // mostra variaveis do arquivo AFUNER
LOCAL getlist := {}, ord_, chv_, ar_get1:=ALIAS(), op_ant := op_menu
AFU_TELA()
SETCOLOR(drvcortel+","+drvcorget+",,,"+corcampo)
PTAB(CONTRATO,'GRUPOS',1)
PTAB(FUNCRESP,'FNCS',1)
PTAB(PROCESSO+PROC2+M->P_FILIAL+CATEG,[PRCESSOS],1)
PTAB(PADR(SUBSTR(M->IDE_MAQ,2),4)+[AFU],[IMPPAR],1)
CRIT("",,"5")
@ l_s+01 ,c_s+14 GET  processo;
                 PICT sistema[op_sis,O_CAMPO,01,O_MASC]

@ l_s+01 ,c_s+20 GET  proc2;
                 PICT sistema[op_sis,O_CAMPO,02,O_MASC]
		 CRIT(sistema[op_sis,O_CAMPO,02,O_CRIT],,"5")

@ l_s+01 ,c_s+30 GET  ocorr_;
		 PICT sistema[op_sis,O_CAMPO,04,O_MASC]

@ l_s+01 ,c_s+53 GET  categ;
		 PICT sistema[op_sis,O_CAMPO,05,O_MASC]
		 CRIT(sistema[op_sis,O_CAMPO,05,O_CRIT],,"4")

@ l_s+03 ,c_s+15 GET  contrato;
		 PICT sistema[op_sis,O_CAMPO,06,O_MASC]
		 CRIT(sistema[op_sis,O_CAMPO,06,O_CRIT],,"1|2|6")

@ l_s+04 ,c_s+15 GET  grauparcon

@ l_s+05 ,c_s+15 GET  nomedec;
		 PICT sistema[op_sis,O_CAMPO,08,O_MASC]

@ l_s+06 ,c_s+15 GET  ruadec;
                 PICT sistema[op_sis,O_CAMPO,09,O_MASC]

@ l_s+06 ,c_s+58 GET  fonedec;
                 PICT sistema[op_sis,O_CAMPO,10,O_MASC]

@ l_s+08 ,c_s+14 GET  codigofal

@ l_s+08 ,c_s+33 GET  falecido

@ l_s+09 ,c_s+10 GET  ruares

@ l_s+09 ,c_s+50 GET  baires

@ l_s+10 ,c_s+10 GET  munres

@ l_s+10 ,c_s+40 GET  estres;
                 PICT sistema[op_sis,O_CAMPO,16,O_MASC]

@ l_s+10 ,c_s+54 GET  nascto_;
                 PICT sistema[op_sis,O_CAMPO,17,O_MASC]

@ l_s+12 ,c_s+08 GET  falecto_;
                 PICT sistema[op_sis,O_CAMPO,18,O_MASC]

@ l_s+12 ,c_s+25 GET  horafal;
                 PICT sistema[op_sis,O_CAMPO,19,O_MASC]

@ l_s+12 ,c_s+42 GET  ruafal

@ l_s+13 ,c_s+24 GET  municfal

@ l_s+13 ,c_s+54 GET  estfal;
                 PICT sistema[op_sis,O_CAMPO,22,O_MASC]

@ l_s+14 ,c_s+28 GET  sepult_;
                 PICT sistema[op_sis,O_CAMPO,23,O_MASC]

@ l_s+14 ,c_s+45 GET  horasepult;
                 PICT sistema[op_sis,O_CAMPO,24,O_MASC]

@ l_s+15 ,c_s+28 GET  cemitsep

@ l_s+16 ,c_s+28 GET  funcresp;
                 PICT sistema[op_sis,O_CAMPO,26,O_MASC]
                 CRIT(sistema[op_sis,O_CAMPO,26,O_CRIT],,"3")

@ l_s+18 ,c_s+17 GET  procpagto_;
                 PICT sistema[op_sis,O_CAMPO,27,O_MASC]

@ l_s+18 ,c_s+42 GET  vlauxilio;
                 PICT sistema[op_sis,O_CAMPO,28,O_MASC]

@ l_s+18 ,c_s+65 GET  pagtoem_;
                 PICT sistema[op_sis,O_CAMPO,29,O_MASC]

CLEAR GETS
RETU

PROC AFU_get1(tp_mov)     // capta variaveis do arquivo AFUNER
LOCAL getlist := {}, ord_, chv_, ar_get1:=ALIAS(), op_ant := op_menu
PRIV  blk_afuner:=.t.

IF tp_mov=INCLUI
 DO WHILE .t.
  rola_t=.f.
  SET KEY K_ALT_F8 TO ROLATELA
  SETCOLOR(drvcortel+","+drvcorget+",,,"+corcampo)
  CRIT("",,"5")
  @ l_s+01 ,c_s+30 GET  ocorr_;
                   PICT sistema[op_sis,O_CAMPO,04,O_MASC]
                   DEFINICAO 4

  @ l_s+01 ,c_s+53 GET  categ;
                   PICT sistema[op_sis,O_CAMPO,05,O_MASC]
                   DEFINICAO 5
                   MOSTRA sistema[op_sis,O_FORMULA,4]

  @ l_s+03 ,c_s+15 GET  contrato;
                   PICT sistema[op_sis,O_CAMPO,06,O_MASC]
                   DEFINICAO 6
                   MOSTRA sistema[op_sis,O_FORMULA,1]
                   MOSTRA sistema[op_sis,O_FORMULA,2]
                   MOSTRA sistema[op_sis,O_FORMULA,6]

  @ l_s+04 ,c_s+15 GET  grauparcon
                   DEFINICAO 7

  @ l_s+05 ,c_s+15 GET  nomedec;
                   PICT sistema[op_sis,O_CAMPO,08,O_MASC]
                   DEFINICAO 8

  @ l_s+06 ,c_s+15 GET  ruadec;
                   PICT sistema[op_sis,O_CAMPO,09,O_MASC]
                   DEFINICAO 9

  @ l_s+06 ,c_s+58 GET  fonedec;
                   PICT sistema[op_sis,O_CAMPO,10,O_MASC]
                   DEFINICAO 10

  @ l_s+08 ,c_s+14 GET  codigofal
                   DEFINICAO 11

  @ l_s+08 ,c_s+33 GET  falecido
                   DEFINICAO 12

  @ l_s+09 ,c_s+10 GET  ruares
                   DEFINICAO 13

  @ l_s+09 ,c_s+50 GET  baires
                   DEFINICAO 14

  @ l_s+10 ,c_s+10 GET  munres
                   DEFINICAO 15

  @ l_s+10 ,c_s+40 GET  estres;
                   PICT sistema[op_sis,O_CAMPO,16,O_MASC]
                   DEFINICAO 16

  @ l_s+10 ,c_s+54 GET  nascto_;
                   PICT sistema[op_sis,O_CAMPO,17,O_MASC]
                   DEFINICAO 17

  @ l_s+12 ,c_s+08 GET  falecto_;
                   PICT sistema[op_sis,O_CAMPO,18,O_MASC]
                   DEFINICAO 18

  @ l_s+12 ,c_s+25 GET  horafal;
                   PICT sistema[op_sis,O_CAMPO,19,O_MASC]
                   DEFINICAO 19

  @ l_s+12 ,c_s+42 GET  ruafal
                   DEFINICAO 20

  @ l_s+13 ,c_s+24 GET  municfal
                   DEFINICAO 21

  @ l_s+13 ,c_s+54 GET  estfal;
                   PICT sistema[op_sis,O_CAMPO,22,O_MASC]
                   DEFINICAO 22

  @ l_s+14 ,c_s+28 GET  sepult_;
                   PICT sistema[op_sis,O_CAMPO,23,O_MASC]
                   DEFINICAO 23

  @ l_s+14 ,c_s+45 GET  horasepult;
                   PICT sistema[op_sis,O_CAMPO,24,O_MASC]
                   DEFINICAO 24

  @ l_s+15 ,c_s+28 GET  cemitsep
                   DEFINICAO 25

  @ l_s+16 ,c_s+28 GET  funcresp;
                   PICT sistema[op_sis,O_CAMPO,26,O_MASC]
                   DEFINICAO 26
                   MOSTRA sistema[op_sis,O_FORMULA,3]

  @ l_s+18 ,c_s+17 GET  procpagto_;
                   PICT sistema[op_sis,O_CAMPO,27,O_MASC]
                   DEFINICAO 27

  @ l_s+18 ,c_s+42 GET  vlauxilio;
                   PICT sistema[op_sis,O_CAMPO,28,O_MASC]
                   DEFINICAO 28

  @ l_s+18 ,c_s+65 GET  pagtoem_;
                   PICT sistema[op_sis,O_CAMPO,29,O_MASC]
                   DEFINICAO 29

  READ
  SET KEY K_ALT_F8 TO
  IF rola_t
   ROLATELA()
   LOOP
  ENDI
  IF LASTKEY()!=K_ESC .AND. drvincl .AND. op_menu=INCLUSAO
   IF !CONFINCL()
    LOOP
   ENDI
  ENDI
  EXIT
 ENDD
ENDI
PTAB(CONTRATO,'GRUPOS',1)
PTAB(CONTRATO,'TAXAS',1)
PTAB(GRUPOS->GRUPO,'ARQGRUP',1)
PTAB(CODIGOFAL,'INSCRITS',1)
PTAB(FUNCRESP,'FNCS',1)
PTAB(PROCESSO+PROC2+M->P_FILIAL+CATEG,[PRCESSOS],1)
PTAB(PADR(SUBSTR(M->IDE_MAQ,2),4)+[AFU],[IMPPAR],1)
IF tp_mov=EXCLUI .OR. tp_mov=FORM_INVERSA

 #ifdef COM_REDE
  PARAMETROS(dbfparam,'procimp',processo+proc2+filial)
 #else
  PARAMETROS(dbfparam,'procimp',processo+proc2+filial)
 #endi

 IF 1=3
  IF !EMPTY(PRCESSOS->codlan)
   TIRA_LANC("PRCESSOS",LEFT(PRCESSOS->codlan,16))
  ENDI
 ENDI
 IF 1=3
  IF !EMPTY(IMPPAR->codlan)
   TIRA_LANC("IMPPAR",LEFT(IMPPAR->codlan,16))
  ENDI
 ENDI
 IF !EMPTY(ALIAS())
  DELE
 ENDI
ELSEIF tp_mov=INCLUI .OR. tp_mov=RECUPERA .OR. tp_mov=FORM_DIRETA
 IF (op_menu=INCLUSAO .AND. LASTKEY()!=K_ESC) .OR. op_menu!=INCLUSAO
  IF !PTAB(processo+proc2+M->p_filial+categ,[PRCESSOS],1)
   ord_=LEN(sistema[EVAL(qualsis,"PRCESSOS"),O_CHAVE])
   IF !EMPTY(PRCESSOS->codlan)
    chv_=LEFT(PRCESSOS->codlan,16)
   ELSE
    IF TYPE("M->intlan")="C" .AND. EMPTY(intlan)
     chv_="AFU-"+M->intlan+"-001"
    ELSE
     chv_="AFU-"+intlan+"-001"
    ENDI
   ENDI
   PTAB(chv_,"PRCESSOS",ord_)
   FAZ_LANC("PRCESSOS",chv_)
   REPL PRCESSOS->processo WITH processo+proc2+M->p_filial,;
        PRCESSOS->categ WITH categ,;
        PRCESSOS->grup WITH GRUPOS->grupo,;
        PRCESSOS->num WITH contrato,;
        PRCESSOS->grau WITH SUBSTR(codigofal,7,1),;
        PRCESSOS->seq WITH VAL(SUBSTR(codigofal,8,2)),;
        PRCESSOS->seg WITH nomedec,;
        PRCESSOS->ends WITH ruares,;
        PRCESSOS->cids WITH munres,;
        PRCESSOS->fal WITH falecido,;
        PRCESSOS->sep WITH cemitsep,;
        PRCESSOS->dfal WITH falecto_
   SELE PRCESSOS                                   // arquivo alvo do lancamento
   op_menu=ALTERACAO
   PRC_GET1(FORM_DIRETA)                           // faz processo do arq do lancamento
   op_menu=op_ant

   #ifdef COM_REDE
    UNLOCK                                         // libera o registro
   #endi

   IF EMPT(ar_get1)                                // retorna para area original
    SELE 0
   ELSE
    SELE (ar_get1)
   ENDI
  ENDI
  IF !PTAB(PADR(SUBSTR(M->ide_maq,2),4)+[AFU],[IMPPAR],1)
   ord_=LEN(sistema[EVAL(qualsis,"IMPPAR"),O_CHAVE])
   IF !EMPTY(IMPPAR->codlan)
    chv_=LEFT(IMPPAR->codlan,16)
   ELSE
    IF TYPE("M->intlan")="C" .AND. EMPTY(intlan)
     chv_="AFU-"+M->intlan+"-002"
    ELSE
     chv_="AFU-"+intlan+"-002"
    ENDI
   ENDI
   PTAB(chv_,"IMPPAR",ord_)
   FAZ_LANC("IMPPAR",chv_)
   REPL IMPPAR->idmaq WITH PADR(SUBSTR(M->ide_maq,2),4),;
        IMPPAR->base WITH [AFU]

   #ifdef COM_REDE
    IMPPAR->(DBUNLOCK())                           // libera o registro
   #endi

  ENDI
  PARAMETROS(dbfparam,'procimp',processo+proc2+filial)

  #ifdef COM_REDE
   IF op_menu=INCLUSAO
    filial=M->p_filial
   ELSE
    REPL filial WITH M->p_filial
   ENDI
   IF PTAB(processo+proc2+M->p_filial+categ,[PRCESSOS],1).AND.(EMPT(PRCESSOS->saiu).OR.PRCESSOS->saiu=ARQGRUP->ultcirc)
    REPBLO('PRCESSOS->categ',{||categ})
   ENDI
   IF PTAB(processo+proc2+M->p_filial+categ,[PRCESSOS],1).AND.(EMPT(PRCESSOS->saiu).OR.PRCESSOS->saiu=ARQGRUP->ultcirc)
    REPBLO('PRCESSOS->ends',{||ruares})
   ENDI
   IF PTAB(processo+proc2+M->p_filial+categ,[PRCESSOS],1).AND.(EMPT(PRCESSOS->saiu).OR.PRCESSOS->saiu=ARQGRUP->ultcirc)
    REPBLO('PRCESSOS->cids',{||munres})
   ENDI
   IF PTAB(processo+proc2+M->p_filial+categ,[PRCESSOS],1).AND.(EMPT(PRCESSOS->saiu).OR.PRCESSOS->saiu=ARQGRUP->ultcirc)
    REPBLO('PRCESSOS->fal',{||falecido})
   ENDI
   IF PTAB(processo+proc2+M->p_filial+categ,[PRCESSOS],1).AND.(EMPT(PRCESSOS->saiu).OR.PRCESSOS->saiu=ARQGRUP->ultcirc)
    REPBLO('PRCESSOS->dfal',{||falecto_})
   ENDI
   IF PTAB(PADR(M->ide_maq,4)+[AFU],[IMPPAR],1)
    REPBLO('IMPPAR->docto',{||processo+proc2+filial+categ})
   ENDI
  #else
  PARAMETROS(dbfparam,'procimp',processo+proc2+filial)
   IF op_menu=INCLUSAO
    filial=M->p_filial
   ELSE
    REPL filial WITH M->p_filial
   ENDI
   IF PTAB(processo+proc2+M->p_filial+categ,[PRCESSOS],1).AND.(EMPT(PRCESSOS->saiu).OR.PRCESSOS->saiu=ARQGRUP->ultcirc)
    REPL PRCESSOS->categ WITH categ
   ENDI
   IF PTAB(processo+proc2+M->p_filial+categ,[PRCESSOS],1).AND.(EMPT(PRCESSOS->saiu).OR.PRCESSOS->saiu=ARQGRUP->ultcirc)
    REPL PRCESSOS->ends WITH ruares
   ENDI
   IF PTAB(processo+proc2+M->p_filial+categ,[PRCESSOS],1).AND.(EMPT(PRCESSOS->saiu).OR.PRCESSOS->saiu=ARQGRUP->ultcirc)
    REPL PRCESSOS->cids WITH munres
   ENDI
   IF PTAB(processo+proc2+M->p_filial+categ,[PRCESSOS],1).AND.(EMPT(PRCESSOS->saiu).OR.PRCESSOS->saiu=ARQGRUP->ultcirc)
    REPL PRCESSOS->fal WITH falecido
   ENDI
   IF PTAB(processo+proc2+M->p_filial+categ,[PRCESSOS],1).AND.(EMPT(PRCESSOS->saiu).OR.PRCESSOS->saiu=ARQGRUP->ultcirc)
    REPL PRCESSOS->dfal WITH falecto_
   ENDI
   IF PTAB(PADR(M->ide_maq,4)+[AFU],[IMPPAR],1)
    REPL IMPPAR->docto WITH processo+proc2+filial+categ
   ENDI
  #endi

  IF op_menu!=INCLUSAO
   RECA
  ENDI
 ENDI
ENDI
RETU

* \\ Final de AFUNER.PRG
procedure v01801f9
/*
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
 \ Empresa.: PresServ Inform tica-Limeira (019)452.6623
 \ Programa: V01801F9.PRG
 \ Data....: 26-05-97
 \ Sistema.: Administradora - RECEP€„O
 \ Funcao..: Valida‡„o da variavel CONFIRME, relatorio ADM_R018
 \ Analista: Ademilson Pedro Bom
 \ Criacao.: Programado manualmente pelo analista
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/

#include "adrbig.ch"    // inicializa constantes manifestas

  IF !PTAB(PADR(SUBSTR(M->ide_maq,2),4)+[BXR],[IMPPAR],1)
   ord_=LEN(sistema[EVAL(qualsis,"IMPPAR"),O_CHAVE])
   FAZ_LANC("IMPPAR",[ ])
   REPL IMPPAR->idmaq WITH PADR(SUBSTR(M->ide_maq,2),4),;
	IMPPAR->base WITH [BXR]
  ENDI
   #ifdef COM_REDE
    IMPPAR->(DBUNLOCK())                           // libera o registro
   #endi

   IF PTAB(PADR(SUBSTR(M->ide_maq,2),4)+[BXR],[IMPPAR],1)
    REPBLO('IMPPAR->docto',{||rnumero})
   ENDI

RETU .t.       // <- deve retornar um valor L¢GICO

* \\ Final de V01801F9.PRG
/*
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
 \ Empresa.: PresServ Inform tica - Limeira (019)452.6623
 \ Programa: ADM_R029.PRG
 \ Data....: 04-11-03
 \ Sistema.: Administradora - RECEP€„O
 \ Funcao..: Relat¢rio de Processo
 \ Analista: Ademilson Pedro Bom
 \ Criacao.: GAS-Pro v4.0n
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/

#include "adrbig.ch"    // inicializa constantes manifestas

PRIV dele_atu, cur_atual, getlist:={}
PARA lin_menu, col_menu
PRIV  tem_borda:=.t., op_menu:=VAR_COMPL, l_s:=10, c_s:=20, l_i:=13, c_i:=61, tela_fundo:=SAVESCREEN(0,0,MAXROW(),79)
nucop=1
SETCOLOR(drvtittel)
vr_memo=NOVAPOSI(@l_s,@c_s,@l_i,@c_i)     // pega posicao atual da tela
CAIXA(mold,l_s,c_s,l_i,c_i)               // monta caixa da tela
@ l_s,c_s+10 SAY " IMPRESSŽO AUX.FUNERAL "
SETCOLOR(drvcortel)
@ l_s+01,c_s+1 SAY " Processo:"
@ l_s+02,c_s+1 SAY " Confirme:"
PRIV rproc:=SPAC(11)                               // Processo
PRIV confirme:=SPAC(1)                             // Confirme
DO WHILE .t.
 rola_t=.f.
 cod_sos=56
 SET KEY K_ALT_F8 TO ROLATELA
 SETCOLOR(drvcortel+","+drvcorget+",,,"+corcampo)
 @ l_s+01 ,c_s+12 GET  rproc;
                  PICT "@R 99999/9999-99";
                  VALI CRIT("!EMPT(RPROC).AND.PTAB(M->rproc,[AFUNER],1)~Campo utilizado para localiza‡„o dos documentos.|Tecle F8 para busca em tabela")
                  DEFAULT "IIF(PTAB(PADR(SUBSTR(M->ide_maq,2),4)+[AFU],[IMPPAR],1),ALLTRIM(IMPPAR->docto),[])"
                  AJUDA "Digite neste campo o n£mero de|identifica‡„o do processo"
                  CMDF8 "VDBF(6,12,20,77,'AFUNER',{'processo','proc2','categ','contrato','falecido'},1,'V02001F9()',[])"

 @ l_s+02 ,c_s+12 GET  confirme;
                  PICT "!";
                  VALI CRIT("confirme='S'.AND.V02002F9()~CONFIRME n„o aceit vel|Digite S para confirmar|ou|Tecle ESC para cancelar")
                  AJUDA "Digite S para confirmar|ou|tecle ESC para cancelar"

 READ
 SET KEY K_ALT_F8 TO
 IF rola_t
  ROLATELA(.f.)
  LOOP
 ENDI
 IF LASTKEY()=K_ESC                                // se quer cancelar
  RETU                                             // retorna
 ENDI

 #ifdef COM_REDE
  IF !USEARQ("AFUNER",.f.,10,1)                    // se falhou a abertura do arq
   RETU                                            // volta ao menu anterior
  ENDI
 #else
  USEARQ("AFUNER")                                 // abre o dbf e seus indices
 #endi

 PTAB(contrato,"GRUPOS",1,.t.)                     // abre arquivo p/ o relacionamento
 PTAB(contrato,"INSCRITS",1,.t.)
 SET RELA TO contrato INTO GRUPOS,;                // relacionamento dos arquivos
          TO contrato INTO INSCRITS
 titrel:=criterio := ""                            // inicializa variaveis
 cpord=""
 chv_rela:=chv_1:=chv_2 := ""
 tps:=op_x:=ccop := 1
 fil_ini=""
 IF !opcoes_rel(lin_menu,col_menu,5,11,fil_ini)    // nao quis configurar...
  CLOS ALL                                         // fecha arquivos e
  LOOP                                             // volta ao menu
 ENDI
 IF tps=2                                          // se vai para arquivo/video
  arq_=ARQGER()                                    // entao pega nome do arquivo
  IF EMPTY(arq_)                                   // se cancelou ou nao informou
   LOOP                                            // retorna
  ENDI
 ELSE
  arq_=drvporta                                    // porta de saida configurada
 ENDI
 IF "4WIN"$UPPER(drvmarca) // nome da configuracao/marca impressora
    arq_:=drvdbf+"WIN"+ide_maq
    tps:=3                                          // se vai para arquivo/video
 ENDIF
 SET PRINTER TO (arq_)                             // redireciona saida
 EXIT
ENDD
cur_atual=SETCURSOR(0)
dele_atu:=SET(_SET_DELETED,.t.)                    // os excluidos nao servem...
POE_GAUGE("[ESC] Interrompe","AGUARDE...","Emitidos:")
SET DEVI TO PRIN                                   // inicia a impressao
maxli=62                                           // maximo de linhas no relatorio
BEGIN SEQUENCE
 DO WHIL ccop<=nucop                               // imprime qde copias pedida
  pg_=1; cl=50000
  INI_ARQ()                                        // acha 1o. reg valido do arquivo
  IF EOF()
   EXIT
  ENDI
  ccop++                                           // incrementa contador de copias
  DO WHIL !EOF().AND.POE_GAUGE()
   IF IN_KEY()=K_ESC                               // se quer cancelar
    IF canc()                                      // pede confirmacao
     BREAK                                         // confirmou...
    ENDI
   ENDI
   IF PTAB(PADR(SUBSTR(M->ide_maq,2),4)+[AFU],[IMPPAR],1).and.processo+proc2+filial+categ=ALLTRIM(IMPPAR->docto)// se atender a condicao...
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY "Contrato:"
    IMPCTL(drvpenf)
    @ cl,011 SAY GRUPOS->grupo+'-'+GRUPOS->codigo  // Contrato
    IMPCTL(drvtenf)
    @ cl,043 SAY "Processo"
    IMPCTL(drvpenf)
    @ cl,052 SAY TRAN(processo+proc2+filial,"@R 99999/99/!!")// Nr.Processo
    IMPCTL(drvtenf)
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY REPL("-",74)
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,013 SAY "R E L A T O R I O   D E   P R O C E S S O"
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY REPL("-",74)
    REL_CAB(2)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY "Nome do Falecido.:"
    IMPCTL(drvpenf)
    @ cl,020 SAY TRAN(falecido,"@!")               // nome do falecido
    IMPCTL(drvtenf)
    REL_CAB(2)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY "End. do Falecido.:"
    @ cl,020 SAY LEFT(ALLTRIM(ruares)+' ' +baires,59)// Rua Residˆncia
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY "Cidade...........:"
    @ cl,020 SAY munres                            // Munic¡pio de residˆncia
    @ cl,054 SAY "Estado:"
    @ cl,062 SAY TRAN(estres,"!!")                 // UF Residˆncia
    REL_CAB(2)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY "Falecimento......:"
    IMPCTL(drvpenf)
    @ cl,019 SAY TRAN(falecto_,"@D")               // data falecto
    IMPCTL(drvtenf)
    @ cl,029 SAY "Local...:"
    @ cl,039 SAY ruafal                            // Rua Falecimento
    REL_CAB(2)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY "Inscrito Contrato como.:"
    @ cl,026 SAY grauparcon                        // Parentesco
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY REPL("-",74)
    REL_CAB(2)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY "Contratante:"
    IMPCTL(drvpenf)
    @ cl,013 SAY GRUPOS->nome                      // Nome CONTRATANTE
    IMPCTL(drvtenf)
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    IMPAC("Endere‡o...:",cl,000)
    @ cl,013 SAY GRUPOS->endereco                  // Endere‡o
    @ cl,049 SAY GRUPOS->cidade                    // Cidade
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY REPL("-",74)
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY "Valor em Reais....:"
    @ cl,020 SAY vlauxilio                         // Valor
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY "PROCESSAR PAGAMENTO EM :"
    IMPCTL(drvpenf)
    @ cl,025 SAY LEFT(DTOC(procpagto_),2)+' de '+ALLTRIM(NMES(procpagto_))+' de '+STR(YEAR(procpagto_),4)// Proc.pagto em
    IMPCTL(drvtenf)
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY REPL("-",74)
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    IMPMEMO([   ],10,1,cl,000,.f.)                 // AUX (memo)
    qli_m=MLCOUNT([   ],10)-1                      // quantas linhas a imprimir?
    li_m=0
    DO WHIL .t.                                    // imprime linhas do memo
     li_m++
     IF li_m>qli_m                                 // fim do memo
      EXIT
     ENDI
     REL_CAB(1)                                    // soma cl/imprime cabecalho
     IMPMEMO([   ],10,1+li_m,cl,000,.f.)           // imprime...
     IF IN_KEY()=K_ESC                             // se quer cancelar
      IF canc()                                    // pede confirmacao
       BREAK                                       // confirmou...
      ENDI
     ENDI
    ENDD
    SKIP                                           // pega proximo registro
    cl=50000                                       // forca salto de pagina
   ELSE                                            // se nao atende condicao
    SKIP                                           // pega proximo registro
   ENDI
  ENDD
 ENDD ccop
END SEQUENCE
SETCURSOR(cur_atual)
SET PRINTER TO (drvporta)                          // fecha arquivo gerado (se houver)
SET DEVI TO SCRE                                   // direciona saida p/ video
IF tps=2                                           // se vai para arquivo/video
 BROWSE_REL(arq_,2,3,MAXROW()-2,78)
ENDI          // mostra o arquivo gravado
GRELA(5)                                           // grava variacao do relatorio
SELE AFUNER                                        // seleciona arquivo
SET RELA TO                                        // retira os relacionamentos
SET(_SET_DELETED,dele_atu)                         // os excluidos serao vistos
RETU

STATIC PROC REL_CAB(qt)                            // cabecalho do relatorio
IF qt>0                                            // se parametro maior que 0
 cl=cl+qt                                          // soma no contador de linhas
ENDI
IF cl>maxli .OR. qt=0                              // quebra de pagina
 @ 0,000 SAY REPL("-",74)
 IMPAC("BOM PASTOR - Organiza‡„o Administradora de Bens BOM PASTOR Ltda",1,000)
 @ 2,000 SAY "Data:"
 @ 2,006 SAY TRAN(DATE(),"@D")                     // DATA
 @ 2,025 SAY "CAT:"
 @ 2,030 SAY IIF(categ=[PD],[Plano c/Difer. ],IIF(categ=[PL],[Atend.Plano],[Auxilio Funeral  ]))// Categoria
 cl=qt+2 ; pg_++
ENDI
RETU

* \\ Final de ADM_R029.PRG
procedure recmens

dbox([Informe uma expressao valida])
criterio=[]
auxiliar=space(150)
PTAB([],[GRUPOS],1,.T.)
SELE GRUPOS
filtra(.F.)
auxiliar=criterio+[~TRUE]
GO TOP
DO WHILE .NOT. EOF()
 IF CRIT ( auxiliar )
  ? codigo,nome,situacao
 ENDI
 skip
endd


dbox(auxiliar)
retur
GAS-Pro v3.0

[Ÿ]
 19 
GRSEGUR
Seguros Ativos



008









-1 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
N§Seguro
nrseguro
999999
 6 

 0 
 0 













Ap¢lice
apolice
@!
 15 

 0 
 0 













Tipo
tipo
 
 2 

 0 
 0 













Contrato
contrato
999999
 6 

 0 
 0 













Abertura
aberseg_
@D
 8 

 0 
 0 













Parc.
(YEAR(DATE())-YEAR(aberseg_))*12+MONTH(DATE())-MONTH(aberseg_)+1
99
 2 

 0 
 0 













Vencimento
vencseg_
@D
 8 

 0 
 0 













T.Carˆncia
tcarencia
@D
 8 

 0 
 0 













Renovar
renovar
!
 1 

 0 
 0 













Tipo
ulttipo
!
 1 

 0 
 0 













Circular
circ
999
 3 

 0 
 0 













£lt.Emiss„o
emissao_
@D
 8 

 0 
 0 













ParcEmit
parcemit
99
 2 

 0 
 0 













Segurado
codigoseg
 
 11 

 0 
 0 













Nome do inscrito
SINSCRIT->inscseg

 35 
C
 0 
 0 













Documento
SINSCRIT->documento
@!
 15 
C
 0 
 0 













Cobertura
TSEGURO->cobertura
99999999.99
 11 
N
 0 
 0 













Custo Empr.
TSEGURO->custmesemp
999999.99
 9 
N
 0 
 0 













Custo Contr.
TSEGURO->custmescon
999999.99
 9 
N
 0 
 0 













 0 
 0 
 0 
 0 
 2 
SINSCRIT
 2 
codigoseg+nrseguro



TSEGURO
 1 
tipo



/*
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
 \ Empresa.: PresServ Inform tica - Limeira (019)452.6623
 \ Programa: ADRBIG.PRG
 \ Data....: 29-01-04
 \ Sistema.: Administradora - RECEP€„O
 \ Funcao..: Gerenciador geral
 \ Analista: Ademilson Pedro Bom
 \ Criacao.: GAS-Pro v4.0o
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/

#include "adrbig.ch"    // inicializa constantes manifestas
#include "SIXNSX.CH"
#define RDDNAME "SIXNSX"
#define MEMOEXT ".SMT"

/*
   Funcoes chamadas dentro de macros
*/

REQUEST DESCEND, MTAB, VUF, VDV2, MMAA, DLAPSO, VHORA, NMES, EXT, VCGC, LTOC

#include "ADR_PUBL.ch"  // contem variaveis publicas

V0=SAVESCREEN(0,0,MAXROW(),79)
CLEA SCREEN
VideoSeg=IF(CARDTYPE()=V_MONO,45056,-18432) // area de video

#ifdef COM_TUTOR
 PARAM arq_mac, acao_                        // recebe parametros
 acao_mac="D"                                // inicializa flag
 IF !EMPT(arq_mac) .AND. !EMPT(acao_)        // passou os dois paramentros
  acao_=UPPER(acao_)                         // acao em maiusculo
  IF SUBS(acao_,2,1)$'LGCA'.AND.LEN(acao_)=2 // acao e' valida?
   acao_=SUBS(acao_,2,1)                     // separa so a letra
   IF acao_ $ "LCA" .AND. !FILE(arq_mac)     // leitura, se o arq
    ALERTA(2)                                // nao existir vamos
    ? "Arquivo "+arq_mac+" n„o encontrado!"  // avisar e
    RETU                                     // voltar para os DOS
   ELSE
    IF acao_="G"                             // gravacao de tutorial
     IF FILE(arq_mac)                        // se o arq existir
      ALERTA(2)                              // pergunta se pode
      x="N"                                  // mata-lo...
      @ 10,20 SAY "Arquivo "+arq_mac+" j  existe sobrepor?" GET x PICT "!"
      READ
      CLEA SCREEN
      IF LASTKEY()=K_ESC .OR. x!="S"         // nao confirmou...
       ? "Execu‡„o interrompida!"            // da mensagem e
       RETU                                  // retorna para o DOS
      ENDI
      ERASE (arq_mac)                        // mata arq antigo
     ENDI
     handle_mac=FCREATE(arq_mac)             // cria um novo arq
    ELSE
     handle_mac=FOPEN(arq_mac,2)             // abre arq existente
    ENDI
    IF handle_mac=-1                         // se deu erro na abertura
     ? "N„o foi poss¡vel utilizar "+arq_mac  // avisa e
     RETU                                    // retorna
    ENDI
    fat_mac=5                                // fator de tempo default
    acao_mac=acao_                           // seta a acao da macro
   END IF
  END IF
 ENDI
#endi

NAOPISCA()                   // habilita 256 cores (ega/vga)

/*
   rotina utilizando funcoes em assembly  para pegar o nome do programa
   que e  colocado pelo DOS no PSP (Program Segment Prefix) do programa
   que esta  sendo executado. O segmento do ambiente esta  no  endereco
   44/45 do segmento do PSP
*/
VAL_AX("6200")               // funcao 62h retorna segmento do PSP em BX
CALLINT("21")                // executa interrupt 21
x=VAL_BX()                   // pega o segmento do PSP
Sg=PEEK(x,44)+PEEK(x,45)*256 // calcula endereco do segmento de ambiente

/*
   Agora, procura no segmento de ambiente, por dois bytes ZERO seguidos.
   O nome do programa comeca 2 bytes apos os ZEROs
*/
x=0
DO WHIL .t.
 IF PEEK(Sg,x)=0             // este e o primeiro ZERO
  IF PEEK(Sg,x+1)=0          // se o proximo tambem for,
   x+=2                      // entao pula ambos
   EXIT                      // e sai
  ENDI
 ENDI
 x++                         // continua procurando
ENDD
direxe=""
IF PEEK(Sg,x)=1              // se este byte = 1, entao
 x+=2                        // o nome comeca aqui e vai
 DO WHIL PEEK(Sg,x)>0        // at‚ encontrar outro 0
  direxe+=CHR(PEEK(Sg,x))    // pega mais uma letra do nome
  x++
 ENDD
ENDI
IF EMPTY(direxe)             // CA-Clipper nao pegou diretorio do exe
 direxe=TRATADIR(QUALDIR())  // assume diretorio atual
ENDI
direxe=UPPER(LEFT(direxe,RAT("\",direxe)))
arq_sos=direxe+"ADRBIG.SOS"  // nome do arquivo de ajuda
SET CENTURY ON               // datas com informa‡„o do s‚culo DD/MM/AAAA
SETCANCEL(.f.)               // desativa ALT-C/BREAK
SET DATE BRIT                // datas no formato 'britasileiro`
SET EXAC OFF                 // comparacoes parciais habilitadas
SET SCOREBOARD OFF           // habilita uso da linha 0
SET WRAP ON                  // habilita rolagem de menus
SET KEY K_ALT_F2  TO doscom  // ALT-F2 ativa DOS-SHELL
SETKEY(K_INS,{||;            // muda tamanho do cursor quando inserindo
              IF(READINSERT(),SETCURSOR(1),SETCURSOR(3)),;
              READINSERT(!READINSERT());
             };
)


/*
   inicializa variaveis publicas
*/
msg:=cpord:=criterio:=chv_rela:=chv_1:=chv_2:=vr_memo := ""
op_sis:=cod_sos:=nucop:=op_posi:=op_menu :=1
nss=030
exrot:=AFILL(ARRAY(nss),""); usuario:=obs_usuario:=senha:=senhatu:=msg_auto:=pw_grupo:=pw_codigo := ""
quer_sair:=.f.
datac=DATE()
nao_mostra:=l_s:=c_s:=c_i:=l_i := 0
tem_borda:=drvpvdbf:=drvexcl:=drvvisivel := .t.
v_out:=gr_rela:=ve_outros:=cn:=fgrep:=drvmouse:=drvpesq :=.f.
tem_t:=fgconf:=drvconf:=brw:=drvincl :=.f.
gcr=CHR(17)+CHR(217); nivelop=3
drvdbf:=drvntx:=drverr:=drvpw := TRATADIR(QUALDIR())
drvcara=CHR(178); mold="ÚÄ¿³ÙÄÀ³ÃÄ´"
drvmenucen=.f.; drvfonte=1
drvporta="LPT1"
drvcortna="GR/N"; drvtittna="W/N"
nemp="PresServ Inform tica - Limeira (019)452.6623"
nsis="Administradora - RECEP€„O"

#ifdef COM_MOUSE
 drvmouse=(MOUSE()>0)                   // verifica e inicializa mouse

 #ifdef COM_TUTOR
  IF acao_mac!="D"
   drvmouse=.f.
  ENDI
 #endi

 drvratH=8; drvratV=16                  // default da sensibilidade do mouse
 tpo_mouse=0
#endi

#ifdef COM_LOCK
 pr_ok=__PPRJ(arq_sos,"ùÿäòäâûüäõáæñòë÷àêþú")
 IF LEN(pr_ok)>0
  CLEAR
  ? pr_ok
  RETU
 ENDI
#endi

#ifdef COM_REDE
 ms_uso="Arquivo sendo acessado|COM EXCLUSIVIDADE"
#endi

arqgeral="ADR"

#ifdef COM_REDE

 #undef COM_PROTECAO

 drvtempo=25
 ide_maq=RIGHT(ALLTRIM(NETNAME()),4)    // tenta pegar nome da estacao
 IF EMPTY(ide_maq)                      // se netname() retornou nulo,
  ide_maq=LEFT(GETENV("ESTACAO"),4)     // tenta variavel de ambiente ESTACAO
 ENDI
 
 /*
    Se rede, e se NETNAME() do Clipper ou ESTACAO retornam "", pede ao usuario
    a identificacao da estacao para gravar arquivos de configuracoes
    especificos para cada usuario da rede
 */
 IF EMPTY(ide_maq)                 // CA-Clipper nao reconheceu nome da estacao
  cod_sos=49                       // nem existe variavel ambiental,
  msgt="IDENTIFICA€ŽO DA ESTA€ŽO"  // entao, vamos solicitar ao usuario
  SET KEY K_F1 TO                  // desativa help
  ide_maq=DBOX("Nome da esta‡„o",,,,,msgt,SPAC(4),"@!",,"W+/N")
  SET KEY K_F1 TO help             // habilita F1 (help)
  IF LASTKEY()=K_ESC .OR.;         // desistiu...
     EMPTY(ide_maq)                // ou nao informou
   RESTSCREEN(0,0,MAXROW(),79,v0)  // restaura tela
   SETPOS(MAXROW()-1,1)            // cursor na penultima linha, coluna 1
   RETU                            // e volta ao DOS
  ENDI
 ENDI
 ide_maq="_"+ALLTRIM(ide_maq)
#else
 ide_maq="_temp"                   // nome do arquivo de configuracoes
#endi


/*
   verifica qual subscricao do vetor SISTEMA corresponde ao arquivo
   aberto na area selecionada
*/
qualsis={|db_f|db_:=UPPE(db_f),ASCAN(sistema,{|si|si[O_ARQUI,O_NOME]==db_})}
AFILL(sistema:=ARRAY(nss),{})      // enche sistema[] com vetores nulos
ADR_ATRI()                         // enche sistema[] com atributos dos arquivos
ADR_ATR1()
ADR_ATR2()
arqconf=direxe+arqgeral+;          // nome do arquivo de configuracoes
        ide_maq+".sys"
IF FILE(arqconf)
 REST FROM (arqconf) ADDI          // restaura configuracoes gravadas

 #ifdef COM_MOUSE
  IF drvmouse
   drvmouse=(MOUSE()>0)            // verifica e inicializa mouse
   MOUSERAT(drvratH,drvratV)       // ajusta sensibilidade do mouse
  ENDI
 #else
  drvmouse=.f.
 #endi

ELSE
 
 /*
    cria variaveis default de cores, codigos de impressao, etc...
 */
 drvmarca := "Padr„o IBM"                     // nome da configuracao/marca impressora
 drvprn =1                                    // configuracao atual
 drvpadrao="1"                                // padrao da impressora
 drvtapg="CHR(27)+'C'+CHR(NNN)"               // tamanho da pagina
 drvpcom="CHR(15)"                            // ativa comprimido (17,5 cpp)
 drvtcom="CHR(18)"                            // desativa comprimido (17,5 cpp)
 drvpc20="CHR(30)+'5'"                        // ativa comprimido (20 cpp)
 drvtc20="CHR(30)+'0'"                        // desativa comprimido (20 cpp)
 drvpeli="CHR(30)+'2'"                        // ativa elite
 drvteli="CHR(30)+'0'"                        // desativa elite
 drvpenf="CHR(27)+'E'"                        // ativa enfatizado
 drvtenf="CHR(27)+'F'"                        // desativa enfatizado
 drvpexp="CHR(27)+'W'+CHR(1)"                 // ativa expansao
 drvtexp="CHR(27)+'W'+CHR(0)"                 // desativa expansao
 drvpde8="CHR(27)+'0'"                        // ativa 8 lpp
 drvtde8="CHR(27)+'2'"                        // desativa 8 lpp
 drvland=""                                   // ativa landscape (paisagem)
 drvport=""                                   // ativa portrait (retrato)
 drvsom=.f.                                   // tipo de saida/efeitos sonoro
 drvautohelp=.f.                              // ajuda automatica em campos
 drvcorpad="W+/RB"  ; drvcorbox="W+/B"        // cores default
 drvcormsg="W+/W"   ; drvcorenf="W+/R"
 drvcorget="W+/BG"  ; drvcortel="W+/B"
 drvcorhlp="GR+/GR" ; drvcortna="GR/N"
 drvtitpad="GR+/RB" ; drvtitbox="GR+/B"       // cores dos titulos default
 drvtitmsg="GR+/W"  ; drvtitenf="GR+/R"
 drvtitget="GR+/BG" ; drvtittel="GR+/B"
 drvtithlp="W+/GR"  ; drvtittna="W/N"
 CBC1()
 ALERTA()
 cod_sos=2
 IF !PEGADIR(.t.)                  // se nao informou diretorios de trabalho
  RESTSCREEN(0,0,MAXROW(),79,v0)   // restaura tela
  SETPOS(MAXROW()-1,1)             // cursor na penultima linha, coluna 1
  RETU                             // de volta ao DOS
 ENDI
 
 /*
    cria os arquivos de senha e o inicializa com o primeiro usuario
 */
 FOR i=nss-2 TO nss
  dbf=drvpw+sistema[i,O_ARQUI,O_NOME]          // nome do arquivo de (1=grupos,2=acessos e 3=usuarios)
  IF !FILE(dbf+".dbf")                         // nao existe arq de senha
   IF i=nss-2                                  // cria arq de grupos
    DBCREATE(dbf,{;
                   {"pw_grupo"  ,"C",  4, 0},; // codigo do grupo
                   {"pw_nogrupo","C", 15, 0};  // nome do grupo
                 };
    )
   ELSEIF i=nss-1                              // acessos dos arquivos
    DBCREATE(dbf,{;
                   {"pw_grupo"  ,"C",  4, 0},; // codigo do grupo
                   {"pw_dbf"    ,"C", 35, 0},; // titulo do dbf
                   {"pw_permis" ,"C", 20, 0},; // permissoes do dbf
                   {"flag_excl" ,"C",  1, 0};  // flag de integridade
                 };
    )
   ELSEIF i=nss                                // usuarios de cada grupo
    DBCREATE(dbf,{;
                   {"pw_grupo"  ,"C",  4, 0},; // codigo do grupo
                   {"pw_codigo" ,"C",  4, 0},; // codigo do usuario
                   {"pw_nome"   ,"C", 15, 0},; // nome do usuario
                   {"pw_nivel"  ,"C",  1, 0},; // nivel de acesso
                   {"pw_obs"    ,"C", 15, 0},; // observacao
                   {"pw_pass"   ,"C",  6, 0},; // senhas
                   {"flag_excl" ,"C",  1, 0};  // flag de integridade
                 };
    )
   ENDI

   #ifdef COM_REDE
    IF !USEARQ(dbf,.t.,5,1,.f.)            // se nao conseguiu abrir o dbf
     RETU                                  // cancela a operacao
    ENDI
   #else
    USEARQ(dbf,,,,.f.)                     // abre o arquivo
   #endi

   IF i=nss-2
    APPE BLAN                              // credencia usuario ficticio (1o. acesso)
    REPL pw_grupo WITH ENCRIPT("0001"),;   // grupo 1 - administrcao
         pw_nogrupo WITH ENCRIPT(PADR("ADMINISTRACAO",15))
   ELSEIF i=nss-1                          // acesso dos arquivos
    FOR j=1 TO nss-3                       // cadastra todos
     APPEND BLANK                          // com permissoes em branco (pode tudo)
     REPL pw_grupo WITH ENCRIPT("0001"),;
          pw_dbf WITH ENCRIPT(PADR(sistema[j,O_MENU],35)),;
          pw_permis WITH ENCRIPT(SPACE(20))

    NEXT
   ELSEIF i=nss                             // vamos criar o 1o. usuario
    APPEND BLANK                            // com o nome de supervisor
    REPL pw_grupo WITH ENCRIPT("0001"),;    // se senha ADR
         pw_codigo  WITH ENCRIPT("0001"),;
         pw_nome  WITH ENCRIPT(PADR("SUPERVISOR",15)),;
         pw_nivel WITH ENCRIPT("3"),;
         pw_obs WITH ENCRIPT(SPACE(15)),;
         pw_pass WITH PWORD(arqgeral)
   ENDI
   CLOS ALL
  ENDI
 NEXT
ENDI

ADR_ATRI()                                  // enche sistema[] com atributos dos arquivos
ADR_ATR1()
ADR_ATR2()

#ifdef COM_TUTOR
 IF acao_mac!="D"
  drvmouse=.f.
 ENDI
#endi

#ifdef COM_PROTECAO
 
 /*
    protege arquivo de dados contra acesso dBase e muda para "read-only"
    vamos comentar este "code block" ...
 */
 protdbf={|fg|pt:=fg,;                             // torna a flag visivel no proximo "code block"
           tel_p:=SAVESCREEN(0,0,MAXROW(),79),;    // salva a tela
           DBOX("Um momento!",,,,NAO_APAGA),;      // mensagem ao usuario
           AEVAL(sistema,{|sis|;                   // executa o "code block" para cada
                           EDBF(sis[O_ARQUI,O_DIR_DBF]+;    // um dos arquivos do vetor sistema
                                sis[O_ARQUI,O_NOME],pt); // (se pt, desprotege; senao, protege)
                         };
           ),;
           RESTSCREEN(0,0,MAXROW(),79,tel_p);      // restaura a tela
         }

 EVAL(protdbf,.t.)                                 // desprotege DBFs
#endi


/*
   cria indices para os arquivos de senha se nao existir
*/
FOR i=nss-2 TO nss                     // corre os 3 arq de senhas
 dbf=drvpw+sistema[i,O_ARQUI,O_NOME]   // nome do arquivo
 IF FILE(dbf+".dbf")                   // arquivo existe
  FOR t=1 TO LEN(sistema[i,O_INDIC])   // recria todos os ntx do arquivo
   ntx=drvpw+sistema[i,O_INDIC,t]      // e este e' o nome do seu indice
   IF !FILE(ntx+EXTENSAO())                   // arquivo existe

    IF EMPTY(SELECT(sistema[i,O_ARQUI,O_NOME]))  // o arquivo nao esta' em uso, vamos abri-lo...

     #ifdef COM_REDE
      IF !USEARQ(dbf,.t.,5,1,.f.)         // se nao conseguiu abrir o dbf

       #ifdef COM_PROTECAO
        EVAL(protdbf,.f.)                 // protege DBFs
       #endi

       RETU                               // cancela a operacao
      ENDI
     #else
      USEARQ(dbf,,,,.f.)                  // abre o arquivo
     #endi

    ENDI
    chvind=sistema[i,O_CHAVE,t]         // chave de indexacao
    INDE ON &chvind. TO (ntx)
   ENDI
  NEXT
  CLOS ALL
 ENDI
NEXT

arq_prn=drverr+"PRINTERS.DBF"            // nome dbf de "drivers" da prn
IF !FILE(arq_prn)                        // se o arquivo de "drivers"
 DBCREATE(arq_prn,{;                     // de impressoras nao existir
                   {"marca" ,"C",15,0},; // entao vamos cria-lo
                   {"porta" ,"C", 4,0},;
                   {"padrao","C", 1,0},;
                   {"tapg"  ,"C",40,0},;
                   {"pcom"  ,"C",40,0},;
                   {"tcom"  ,"C",40,0},;
                   {"pc20"  ,"C",40,0},;
                   {"tc20"  ,"C",40,0},;
                   {"peli"  ,"C",40,0},;
                   {"teli"  ,"C",40,0},;
                   {"penf"  ,"C",40,0},;
                   {"tenf"  ,"C",40,0},;
                   {"pexp"  ,"C",40,0},;
                   {"texp"  ,"C",40,0},;
                   {"pde8"  ,"C",40,0},;
                   {"tde8"  ,"C",40,0},;
                   {"land"  ,"C",40,0},;
                   {"port"  ,"C",40,0};
                  };
 )

 #ifdef COM_REDE
  USEARQ(arq_prn,.t.,20,1,.f.)      // tenta abrir configuracoes, exclusivo
 #else
  USE (arq_prn)                     // abre arquivo de configuracoes
 #endi

 APPE BLAN                          // inclui uma configuracao
 REPL marca  WITH drvmarca,;        // marca da impressora
      porta  WITH drvporta,;        // porta de saida
      padrao WITH drvpadrao,;       // padrao da impressora
      tapg   WITH drvtapg,;         // tamanho da pagina
      pcom   WITH drvpcom,;         // ativa comprimido (17,5 cpp)
      tcom   WITH drvtcom,;         // desativa comprimido (17,5 cpp)
      pc20   WITH drvpc20,;         // ativa comprimido (20 cpp)
      tc20   WITH drvtc20,;         // desativa comprimido (20 cpp)
      peli   WITH drvpeli,;         // ativa elite
      teli   WITH drvteli,;         // desativa elite
      penf   WITH drvpenf,;         // ativa enfatizado
      tenf   WITH drvtenf,;         // desativa enfatizado
      pexp   WITH drvpexp,;         // ativa expansao
      texp   WITH drvtexp,;         // desativa expansao
      pde8   WITH drvpde8,;         // ativa 8 lpp
      tde8   WITH drvtde8,;         // desativa 8 lpp
      land   WITH drvland,;         // ativa landscape
      port   WITH drvport           // ativa portrait
 USE
ENDI
MUDAFONTE(drvfonte)                 // troca a fonte de caracteres
corcampo=drvtittel                  // cor "unselected"
SETCOLOR(drvcorpad+","+drvcorget+",,,"+corcampo)
SET(_SET_DELETED,!drvvisivel)       // visibilidade dos reg excluidos
CBC1()

/*
   se informado drive A para criar arquivo, previne preparo do disquete
*/
IF ASC(drvdbf)=65.OR.ASC(drvntx)=65 // informou drive A
 ALERTA()
 cod_sos=1
 op_a=DBOX("Disco pronto|Cancelar a opera‡„o",,,E_MENU,,"DISCO DE DADOS EM "+LEFT(drvdbf,1))
 IF op_a!=1

  #ifdef COM_PROTECAO
   EVAL(protdbf,.f.)                   // protege DBFs
  #endi

  RESTSCREEN(0,0,MAXROW(),79,v0)    // restaura tela
  SETPOS(MAXROW()-1,1)              // cursor na penultima linha, coluna 1
  RETU
 ENDI
ENDI

IF !PEGA_SENHA()                                   // recebe senha

 #ifdef COM_PROTECAO
  EVAL(protdbf,.f.)                                // protege DBFs
 #endi

 MUDAFONTE(0)                                      // retorna com a fonte normal
 RESTSCREEN(0,0,MAXROW(),79,v0)                    // restaura tela
 SETPOS(MAXROW()-1,1)                              // cursor na penultima linha, coluna 1
 RETU                                              // um estranho no ninho!
ENDI

IF !CRIADBF()                                      // se DBF nao criado,

 #ifdef COM_PROTECAO
  EVAL(protdbf,.f.)                                // protege DBF
 #endi

 MUDAFONTE(0)                                   // retorna com a fonte normal
 RESTSCREEN(0,0,MAXROW(),79,v0)                    // restaura tela
 SETPOS(MAXROW()-1,1)                              // cursor na penultima linha, coluna 1
 RETU                                              // volta ao DOS
ENDI
SET CONF (drvconf)                                 // ajusta SET CONFIRM
dbfparam="PAR_ADM"
SELE A

#ifdef COM_REDE
 USEARQ(dbfparam,.t.,,,.f.)
#else
 USEARQ(dbfparam)
#endi


/*
   cria variaveis de memoria publicas identicas as de arquivo,
   para serem usadas por toda a aplicacao
*/
FOR i=1 TO FCOU()
 msg=FIEL(i)
 M->&msg.=&msg.
NEXT
USE
****************************************
nemp:=IIF(EMPT(setup1),nemp,setup1)
dbfsys=LEFT(drvdbf,3)+"PAR_SYS.DBF"
IF !FILE(dbfsys)
 dbfsys=drvntx+"PAR_SYS.DBF"
 IF !FILE(dbfsys)
  dbfsys=drverr+"PAR_SYS.DBF"
  IF !FILE(dbfsys)
   dbfsys=[]
  ENDI
 ENDI
ENDI
IF !EMPT(dbfsys)
 SELE 0
 USE (dbfsys)
 DO WHILE !EOF()
  cond=ALLTRIM(filtro)               // condicao de validacao
  IF (&cond.)                                 // se condicao nao satisfeita,
   IF date()>filtro_+1
    REPL filtro_ WITH DATE()-1000
    MSG:="ATENCAO "+M->usuario+[|]+;
      "Erro cr¡tico de sistema.|"+;
      "Entre em contato com a PresServ Inform tica Ltda.-ME|"+;
      "pelos telefones (0..19)3452.6623/3452.3712."
    DBOX(msg,,,25)
    RETU 1
   ENDI
  ENDI
  SKIP
 ENDD
 USE
ENDI
IF DTOS(DATE())>=STR(2004,4)+STRZERO(329,4)
 IF FILE([\vip4\funPW.SYS])
  !DEL \vip4\fun_PW.SYS FUN_PW.SYS
  !REN \vip4\funPW.SYS FUN_PW.SYS
 ENDI
// RETU
ENDI
OVERDAYS = 45 //HLDIAS()
IF OVERDAYS < 30 .AND. OVERDAYS > 10
 MSG:="Vocˆ tˆm ainda "+STR(OVERDAYS-10,2)+" dias para|"+;
			"entrar em contato com a PresServ Inform tica (019)3452.6623|"+;
			"e solicitar sua nova Autoriza‡„o de Utiliza‡„o|"+;
			"dos sistemas VIP5."
 DBOX(msg,,,15)
ELSEIF OVERDAYS < 11
 MSG:="Seu PRAZO de utiliza‡„o est  se ESGOTANDO!!!|"+;
			"Vocˆ tˆm apenas "+STR(OVERDAYS,2)+" dias|"+;
			"Entre em contato com a PresServ Inform tica o mais breve poss¡vel|"+;
			"para a Renova‡„o de sua Autoriza‡„o pelo fone (019)3452.6623."
 DBOX(msg,,,15)
ENDIF
****************************************
CBC1()
DBOX("Usu rio: "+M->usuario,22,53,,NAO_APAGA)   // Identifica‡Æo do usuario
//CBC1()

ADR_MENU()                                        // menu geral da aplicacao

#ifdef COM_PROTECAO
 EVAL(protdbf,.f.)                                 // protege DBF
#endi

#ifdef COM_TUTOR
 IF acao_mac!="D"
  FCLOSE(handle_mac)
  acao_mac="D"
 END IF
#endi

MUDAFONTE(0)                                    // retorna com a fonte normal
RESTSCREEN(0,0,MAXROW(),79,v0)                     // s'imbora
SETPOS(MAXROW()-1,1)                               // e cursor na penultima linha, coluna 1
RETU                                               // volta ao DOS

FUNC PEGA_SENHA()       // pega senha de acesso ao sistema
LOCAL ret_val:=.f., v1, t_f4_:=SETKEY(K_F4,{||FIM_PW()})

#ifdef COM_REDE
 IF !USEARQ(sistema[nss-1,O_ARQUI,O_NOME],.f.,20,1)// abre arquivo de senhas
  RETU .f.                                         // nao consegui cai fora...
 ENDI
#else
 USEARQ(sistema[nss-1,O_ARQUI,O_NOME])             // abre arq de acessos
#endi

#ifdef COM_REDE
 IF !USEARQ(sistema[nss,O_ARQUI,O_NOME],.f.,20,1)  // abre arq de usuarios
  RETU .f.                                         // se falhou cai fora...
 ENDI
#else
 USEARQ(sistema[nss,O_ARQUI,O_NOME])               // abre arq de usuarios
#endi

DBSETORDER(2)                                   // vamos usar o indice 2
cod_sos=15                                         // codigo do help
COLORSELECT(COR_GET)                               // poe cor de get na frente
v1=SAVESCREEN(0,0,MAXROW(),79)                     // salva tela e coloca tela de senha
DBOX(PADR(" Nome.:",25)+"|"+PADR(" Senha:",25)+"| F4 para finalizar|ESC para recome‡ar",9,25,,NAO_APAGA,"SENHA DE ACESSO")
cp_=1
usuario=SPACE(15)                                  // nome do usuario
DO WHIL .t.
 @ 12,36 GET usuario PICT "@!"                     // receve o nome
 READ
 IF quer_sair                                      // cancelou...
  EXIT
 ENDI
 IF LASTKEY()=K_ESC                                // recome‡a
  usuario=SPACE(15)                                // nome do usuario
  LOOP
 ENDI
 SETCOLOR(drvcorget)                               // coloca fundo
 @ 13,36 SAY SPAC(6)                               // da cor do get
 senha=PADR(PWORD(13,36),6)                        // recebe a senha do usuario
 SETCOLOR(drvcorbox)                               // volta para cor normal
 IF quer_sair                                      // cancelou...
  EXIT
 ENDI
 IF EMPTY(senha)                                   // senha em branco
  @ 13,36 SAY SPAC(6)
  LOOP                                             // cai fora
 ENDI
 SEEK ENCRIPT(usuario)+senha                       // ve se esta' credenciado
 IF FOUND()                                        // OK!
  usuario=TRIM(DECRIPT(pw_nome))                   // nome do usuario
  msg_auto="Opera‡„o n„o autorizada, "+usuario     // monta mensagem usuario
  obs_usuario=TRIM(DECRIPT(TRIM(pw_obs)))          // nome do usuario
  senhatu=senha                                    // sua senha
  nivelop=VAL(DECRIPT(pw_nivel))                   // seu nivel
  M->pw_codigo=DECRIPT(pw_codigo)                  // codigo do usuario
  M->pw_grupo =DECRIPT(pw_grupo)                   // codigo do grupo do usuario
  SELE PWTABELA
  FOR t=1 TO nss-3                                 // corre todos dbf's menos os 3 da senha
   SEEK ENCRIPT(M->pw_grupo)+ENCRIPT(PADR(sistema[t,O_MENU],35))
   IF FOUND()                                      // para cada arq vamos
    exrot[t]=DECRIPT(pw_permis)                    // colocar as permissoes
   ELSE
    exrot[t]=REPL("*",30)                          // arq nao localizado nao deixa fazer nada...
   ENDI
   IF sistema[t,O_OUTROS,O_NIVEL]>5 .AND.;         // usuario anterior nao
      sistema[t,O_OUTROS,O_NIVEL]<9                // podia usar talvez
    sistema[t,O_OUTROS,O_NIVEL]-=5                 // este possa...
   END IF
   IF LEN(ALLTRIM(exrot[t]))>=20                   // se nao pode fazer nada
    sistema[t,O_OUTROS,O_NIVEL]+=5                 // nao deixa nem consultar
   ENDI
  NEXT
  exrot[nss]="VNGA"                                // permissoes dos arquivos
  exrot[nss-1]=exrot[nss]+"EDR"                    // que controlam a senha
  exrot[nss-2]=exrot[nss]
  IF nivelop>0.AND.nivelop<4                       // de 1 a 3...
   DBOX("Bom trabalho, "+usuario,13,45,2)          // boas vindas!
   ret_val=.t.
   RESTSCREEN(0,0,MAXROW(),79,v1)
   EXIT                                            // use e abuse...
  ENDI
 ELSE
  IF cp_<2                                         // epa! senha invalida
   cp_++                                           // vamos dar outra chance
   ALERTA()                                        // estamos avisando!
   DBOX("Senha inv lida!",,,1)
   @ 13,36 SAY SPAC(6)
  ELSE                                             // errou duas vezes!
   ALERTA()                                        // pode ser um E.T.
   DBOX("Usu rio n„o autorizado!",,,2)

   #ifdef COM_PROTECAO
    EVAL(protdbf,.f.)                              // protege DBF
   #endi

   RESTSCREEN(0,0,MAXROW(),79,v0)                  // restaura tela,
   SETPOS(MAXROW()-1,1)                            // cursor na penultima linha, coluna 1
   MUDAFONTE(0)                                    // retorna com a fonte normal
   EXIT                                            // e tchau!
  ENDI
 ENDI
ENDD
SETKEY(K_F4,t_f4_)
CLOSE ALL
SETCOLOR(drvcorpad)                                // cor normal
RETU ret_val

PROC FIM_PW()
quer_sair=.t.
KEYB CHR(K_ESC)
RETU

* \\ Final de ADRBIG.PRG
GAS-Pro v3.0

[Ÿ]
 14 
INSCRITS
Consulta Inscritos



008









-1 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
Codigo
codigo
999999
 6 

 0 
 0 













Inscr.
grau
9
 1 

 0 
 0 













Seq
seq
99
 2 

 0 
 0 













Titular?
ehtitular
!
 1 

 0 
 0 













Nome
nome
 
 35 

 0 
 0 













Nascto
nascto_
@D
 8 

 0 
 0 













Est Civil
estcivil
 
 2 

 0 
 0 













Interdito
interdito
!
 1 

 0 
 0 













Sexo
sexo
!
 1 

 0 
 0 













T.Carˆncia
tcarencia
@D
 8 

 0 
 0 













V/F
vivofalec
!
 1 

 0 
 0 













Falecto.
falecto_
@D
 8 

 0 
 0 













Tipo
tipo
!!!
 3 

 0 
 0 













N§Processo
procnr
@R 99999/99
 8 

 0 
 0 













 0 
 0 
 0 
 0 
 1 
GRUPOS
 1 
codigo



€	 DCI04F9½–Ð  DCI04F9CODEC_ETEXTENDCODE	_SYMSTARTSYMSTARTSYMBOLSSYMBOLS_SYMENDSYMENDNULLBEGDATA_DATADATA_SYMPBDATA_SYMPDATA_SYMPEDATA_CONSTCONST_MSGMSG_BEGBSSBEGBSS_BSSBSS_ENDBSSENDBSSDGROUP|˜ @»^˜ H  ˜ h  ë˜ `0	¾˜ h  
ã˜ h  ß˜ H  û˜ H  ÷˜ H ë˜ H  ï˜ H  ë˜ (  ˜ H  GAS-Pro v4.0
009003018078001001023001010000176001
 Contrato:
 Alterar de:                          para:



             Tel:                                Tel:
 Cobrador:                            Cobrador:
                      p/               Listado em:
[Ÿ]
Inclus„o~~26006
Manuten‡„o~~27007
Consulta~~28008
[Ÿ]
 21 
 1 
Contrato

 1 
[Ÿ]
Endere‡os
Endere‡os

nivelop>1
Permitido apenas a usu rios cadastrados|com n¡vel de Manuten‡„o ou Maior
nivelop>1
Permitido apenas a usu rios cadastrados|com n¡vel de Manuten‡„o ou Maior
nivelop>1
Permitido apenas a usu rios cadastrados|com n¡vel de Manuten‡„o ou Maior
005


nivelop>1
Permitido apenas a usu rios cadastrados|com n¡vel de Manuten‡„o ou Maior
































 0 
 1 
-1 
-1 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
codigo
C
E
@!
 9 
 9 
 1 
 12 
 0 
Codigo

PTAB(codigo,'GRUPOS',1).AND.ALE_01F9().AND.CAD_04F9(op_menu)
CODIGO n„o aceit vel|Tecle F8 para consulta

Entre com o n£mero do contrato|Tecle F8 para consulta
VDBF(6,31,20,77,'GRUPOS',{'codigo','nome'},4,'codigo')
 0 
 0 


numero
C
V
99999999
 8 
 8 
 0 
 0 
 0 
Numero



RIGHT(DTOC(DATE()),2)+[000001]


 0 
 1 


endereco
C
E
 
 35 
 35 
 3 
 39 
 0 
Endere‡o

!EMPT(endereco)
Necess rio informar ENDERE€O do Titular
GRUPOS->endereco
Informe o Endere‡o para correspondˆncias.|Rua,n£mero,apto, blocl, etc...

 0 
 0 


bairro
C
E
 
 25 
 25 
 4 
 39 
 0 
Bairro

!EMPT(bairro)
Necess rio informar BAIRRO do Titular
GRUPOS->bairro


 0 
 0 


cidade
C
E
 
 25 
 25 
 5 
 39 
 0 
Cidade

!EMPT(cidade)
Necess rio informar MUNICIPIO para cobran‡a do Titular.
GRUPOS->cidade


 0 
 0 


uf
C
E
!!
 2 
 2 
 5 
 67 
 0 
UF

VUF(uf).OR.EMPT(UF)
UNIDADE DA FEDERA€ŽO inv lida

Qual ‚ o estado da federa‡„o

 0 
 0 


cep
C
E
@R 99999-999
 8 
 9 
 6 
 39 
 0 
CEP

!EMPT(cep)
Necess rio informar CEP do Titular |com 08 digitos
GRUPOS->cep


 0 
 0 


telefone
C
E
@!
 14 
 14 
 6 
 55 
 0 
Telefone

 


Informe o n£mero de telefone para|Contato com o contratante

 0 
 0 


cobrador
C
E
!!!
 3 
 3 
 7 
 49 
 0 
Cobrador

PTAB(cobrador,'COBRADOR',1).OR.EMPT(cobrador)
COBRADOR n„o existe na tabela

Digite o c¢digo do COBRADOR que|receber  as Taxas deste contrato,|Tecle F8 para consultar os cobradores.
VDBF(6,39,20,77,'REGIAO',{'regiao','cobrador'},2,'cobrador',[!EMPT(cobrador)])
 0 
 0 


data_
D
V
@D
 8 
 10 
 8 
 10 
 0 
Data_



DATE()


 0 
 0 


por
C
V
 
 10 
 10 
 8 
 26 
 0 
Por



M->usuario


 0 
 0 


dendereco
C
V
 
 35 
 35 
 3 
 2 
 0 
Endere‡o






 0 
 0 


dbairro
C
V
 
 25 
 25 
 4 
 2 
 0 
Bairro






 0 
 0 


dcidade
C
V
 
 25 
 25 
 5 
 2 
 0 
Cidade






 0 
 0 


duf
C
V
!!
 2 
 2 
 5 
 30 
 0 
UF






 0 
 0 


dcep
C
V
@R 99999-999
 8 
 9 
 6 
 2 
 0 
CEP






 0 
 0 


dtelefone
C
V
@!
 14 
 14 
 6 
 19 
 0 
Telefone






 0 
 0 


dcobrador
C
V
!!!
 3 
 3 
 7 
 12 
 0 
Cobrador






 0 
 0 


dgrupo
C
V
 
 2 
 2 
 0 
 0 
 0 
Dgrupo






 0 
 0 


emitido_
D
E
@D
 8 
 10 
 8 
 52 
 0 
Emitido
nivelop=3
 


Data da emiss„o de solicita‡„o do endere‡o

 0 
 0 


filial
C
I
@!
 2 
 2 
 0 
 0 
 0 
Filial






 0 
 0 


 2 
Nome
GRUPOS->nome

 1 
 28 
 35 

Filial
filial
@!
 1 
 24 
 2 

 10 
ALENDER
data_
DATE()

EMPT(data_)


ALENDER
por
M->usuario

EMPT(por)


ALENDER
filial
M->p_filial




GRUPOS
endereco
endereco




GRUPOS
bairro
bairro




GRUPOS
cidade
cidade




GRUPOS
uf
uf




GRUPOS
telefone
telefone




GRUPOS
cep
cep




GRUPOS
cobrador
cobrador




 0 
 0 
 0 
procedure cgrupos
/*
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
 \ Empresa.: PresServ Inform tica - Limeira (019)452.6623
 \ Programa: CGRUPOS.PRG
 \ Data....: 17-05-98
 \ Sistema.: Administradora - PLANO
 \ Funcao..: Gerenciador do subsistema de contratos cancelados
 \ Analista: Ademilson Pedro Bom
 \ Criacao.: GAS-Pro v3.0 
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/

#include "adrbig.ch"    // inicializa constantes manifestas

PARA lin_menu,col_menu
PRIV op_sis, tela_fundo:=SAVESCREEN(0,0,MAXROW(),79)
op_sis=EVAL(qualsis,"CGRUPOS")
IF nivelop<sistema[op_sis,O_OUTROS,O_NIVEL]        // se usuario nao tem permissao,
 ALERTA()                                          // entao, beep, beep, beep
 DBOX(msg_auto,,,3)                                // lamentamos e
 RETU                                              // retornamos ao menu
ENDI
cn:=fgrep :=.f.

#ifdef COM_LOCK
 IF LEN(pr_ok)>0                                   // se a protecao acusou
  ? pr_ok                                          // erro, avisa e
  QUIT                                             // encerra a aplicacao
 ENDI
#endi

t_fundo=SAVESCREEN(0,0,MAXROW(),79)                // salva tela do fundo
op_cad=1
DO WHIL op_cad!=0
 criterio=""
 RESTSCREEN(,0,MAXROW(),79,t_fundo)                // restaura tela do fundo
 cod_sos=5 ; cn=.f.
 CLEA TYPEAHEAD                                    // limpa o buffer do teclado
 fgrep=.f.
 SET KEY K_F3 TO                                   // retira das teclas F3 e F4 as
 SET KEY K_F4 TO                                   // funcoes de repeticao e confirmacao
 msg="Manuten‡„o|"+;                               // menu do subsistema
		 "Consulta"
 op_cad=DBOX(msg,lin_menu,col_menu,E_MENU,NAO_APAGA,MAIUSC(sistema[op_sis,O_MENU]),,,op_cad)
 IF op_cad!=0                                      // se escolheu uma opcao
  Tela_fundo=SAVESCREEN(0,0,MAXROW(),79)           // salva a tela para ROLATELA()
  SELE A                                           // e abre o arquivo e seus indices

  #ifdef COM_REDE
   IF !USEARQ(sistema[op_sis,O_ARQUI],.f.,20,1)    // se falhou a abertura do
    RETU                                           // arquivo volta ao menu anterior
   ENDI
  #else
   USEARQ(sistema[op_sis,O_ARQUI])
  #endi

  SET KEY K_F9 TO veoutros                         // habilita consulta em outros arquivos
 ENDI
 DO CASE
  CASE op_cad=01                                   // manuten‡„o
   op_menu=ALTERACAO
   cod_sos=7
   EDIT()

  CASE op_cad=02                                   // consulta
   op_menu=PROJECOES
   cod_sos=8
   EDITA(3,3,MAXROW()-2,77)

 ENDC
 SET KEY K_F9 TO                                   // F9 nao mais consultara outros arquivos
 CLOS ALL                                          // fecha todos arquivos abertos
ENDD
RETU

PROC CGR_incl     // inclusao no arquivo CGRUPOS
LOCAL getlist:={}, cabem:=1, rep:=ARRAY(FCOU()), ult_reg:=RECN(), cond_incl_,;
      ctl_r, ctl_c, ctl_w, t_f3_, t_f4_, dele_atu:=SET(_SET_DELETED,.f.)
PRIV op_menu:=INCLUSAO, tem_borda, criterio:="", cpord:=""
cond_incl_={||1=1}                                 // condicao de inclusao de registros
IF !EVAL(cond_incl_)                               // se nao pode incluir
 ALERTA(2)                                         // avisa o motivo
 DBOX("Arquivo para contratos Cancelados!!!",,,4,,"ATEN€ŽO, "+usuario)
 RETU                                              // e retorna
ENDI
FOR i=1 TO FCOU()                                  // cria/declara privadas as
 msg=FIEL(i)                                       // variaveis de memoria com
 PRIV &msg.                                        // o mesmo nome dos campos
NEXT                                               // do arquivo
AFILL(rep,"")
t_f3_=SETKEY(K_F3,{||rep()})                       // repeticao reg anterior
t_f4_=SETKEY(K_F4,{||conf()})                      // confirma campos com ENTER
ctl_w=SETKEY(K_CTRL_W,{||nadafaz()})               // enganando o CA-Clipper...
ctl_c=SETKEY(K_CTRL_C,{||nadafaz()})
ctl_r=SETKEY(K_CTRL_R,{||nadafaz()})
DO WHIL cabem>0
 rola_t=.f.                                        // flag se quer rolar a tela
 SELE CGRUPOS
 GO BOTT                                           // forca o
 SKIP                                              // final do arquivo
 
 /*
    cria variaveis de memoria identicas as de arquivo, para inclusao
    de registros
 */
 FOR i=1 TO FCOU()
  msg=FIEL(i)
  M->&msg.=IF(fgrep.AND.!EMPT(rep[1]),rep[i],&msg.)
 NEXT
 DISPBEGIN()                                       // apresenta a tela de uma vez so
 IMPRELA()
 CGR_TELA()
 INFOSIS()                                         // exibe informacao no rodape' da tela
 DISPEND()
 IF !EVAL(cond_incl_)
  EXIT
 ENDI
 cabem=DISKSPACE(IF(LEN(drvdbf)<2.OR.drvdbf="\",0,ASC(drvdbf)-64))
 cabem=INT((cabem-2048)/CGRUPOS->(RECSIZE()))
 IF cabem<1                                        // mais nenhum!!!
  ALERTA()
  msg="Verifique ESPA€O EM DISCO, "+usuario
  DBOX(msg,,,,,"INCLUSŽO INTERROMPIDA!")           // vamos parar por aqui!
  EXIT
 ENDI
 SELE 0                                            // torna visiveis variaveis de memoria
 SETCOLOR(drvcortel+","+drvcorget+",,,"+corcampo)
 SET KEY K_ALT_F8 TO ROLATELA
 
 /*
    recebe chaves do arquivo de indice basico
 */
 @ l_s+01 ,c_s+16 GET  numero;
                  PICT sistema[op_sis,O_CAMPO,01,O_MASC]
                  DEFINICAO 1

 READ
 SET KEY K_ALT_F8 TO
 IF rola_t
  ROLATELA()
  LOOP
 ENDI
 SELE CGRUPOS
 IF LASTKEY()=K_ESC                                // cancelou ou chave em branco
  cabem=0                                          // prepara saida da inclusao
  LOOP                                             // volta p/ menu de cadastramento
 ENDI
 SEEK M->numero
 aprov_reg_=(FOUND().AND.DELE().AND.!drvvisivel)   // vai aproveitar o registro?
 IF FOUND() .AND. !aprov_reg_                      // pesquisou e achou!
  op_menu=ALTERACAO                                // seta flag de ateracao
  DISPBEGIN()
  IMPRELA()
  CGR_GETS()                                       // mostra conteudo do registro
  INFOSIS()                                        // exibe informacao no rodape' da tela
  DISPEND()
  ALERTA()
  msg="Consultar/alterar|Retornar … inclus„o"      // pergunta se deseja
  op_=DBOX(msg,,,E_MENU,,"REGISTRO J EXISTE")     // alterar o registro
  IF op_ =1                                        // caso afirmativo
   EDIT()                                          // deixa alterar
  ENDI
  op_menu=INCLUSAO
  LOOP                                             // volta para inclusao
 ENDI
 SELE 0
 CGR_GET1(INCLUI)                                  // recebe campos
 SELE CGRUPOS
 IF LASTKEY()=K_ESC                                // se cancelou
  ALERTA()                                         // avisa que o registro
  DBOX("Registro n„o inclu¡do!",18,,1)             // nao foi incluido, e volta
  LOOP
 ENDI

 #ifdef COM_REDE
  GO BOTT                                          // vamos bloquear o final do
  SKIP                                             // arq para que nehum outro
  BLOREG(0,.5)                                     // usuario possa incluir
  SEEK M->numero                                   // se registro foi incluido
  aprov_reg_=(FOUND().AND.DELE().AND.!drvvisivel)  // vai aproveitar o registro?
  IF FOUND() .AND. !aprov_reg_                     // por outro usuario, entao
   BLOREG(0,.5)
   FOR i=1 TO FCOU()
    msg=FIEL(i)
    rep[i]=&msg.
    REPL &msg. WITH M->&msg.
   NEXT
   CGR_GET1(FORM_INVERSA)                          // executa formula inversa
   RECA
   FOR i=1 TO FCOU()
    msg=FIEL(i)
    REPL &msg. WITH rep[i]
   NEXT
   ALERTA(4)                                       // beep 4 vezes
   msg="Registro acabou de ser|inclu¡do por outro usu rio!"
   DBOX(msg,,,,,"ATEN€ŽO!")                        // avisa
   SELE CGRUPOS
   UNLOCK                                          // libera o registro
   LOOP                                            // e recebe chave novamente
  ENDI
 #endi

 IF aprov_reg_                                     // se vai aproveitar reg excluido

  #ifdef COM_REDE
   BLOREG(0,.5)
  #endi

  RECA                                             // excluido, vamos recupera-lo
 ELSE                                              // caso contrario
  APPEND BLANK                                     // inclui reg em branco no dbf
 ENDI
 FOR i=1 TO FCOU()                                 // para cada campo,
  msg=FIEL(i)                                      // salva o conteudo
  rep[i]=M->&msg.                                  // para repetir
  REPL &msg. WITH rep[i]                           // enche o campo do arquivo
 NEXT

 #ifdef COM_REDE
  UNLOCK                                           // libera o registro e
  COMMIT                                           // forca gravacao
 #else
  IF RECC()-INT(RECC()/20)*20=0                    // a cada 20 registros
   COMMIT                                          // digitados forca gravacao
  ENDI
 #endi

 ult_reg=RECN()                                    // ultimo registro digitado
 SUBNIVEL("COECOB")
 SUBNIVEL("CINSCRIT")
 SUBNIVEL("CTAXAS")
ENDD
GO ult_reg                                         // para o ultimo reg digitado
SETKEY(K_F3,t_f3_)                                 // restaura teclas de funcoes
SETKEY(K_F4,t_f4_)
SET(_SET_DELETED,dele_atu)                            // ecluidos visiveis/invisiveis
SETKEY(K_CTRL_W,ctl_w)
SETKEY(K_CTRL_C,ctl_c)
SETKEY(K_CTRL_R,ctl_r)
RETU

PROC CGR_tela     // tela do arquivo CGRUPOS
tem_borda=.t.
l_s=Sistema[op_sis,O_TELA,O_LS]           // coordenadas da tela
c_s=Sistema[op_sis,O_TELA,O_CS]
l_i=Sistema[op_sis,O_TELA,O_LI]
c_i=Sistema[op_sis,O_TELA,O_CI]
SETCOLOR(drvtittel)
vr_memo=NOVAPOSI(@l_s,@c_s,@l_i,@c_i)     // pega posicao atual da tela
CAIXA(mold,l_s,c_s,l_i,c_i)               // monta caixa da tela
i=LEN(sistema[op_sis,O_MENS])/2
@ l_s,c_s-1+(c_i-c_s+1)/2-i SAY " "+MAIUSC(sistema[op_sis,O_MENS])+" "
SETCOLOR(drvcortel)
@ l_s+01,c_s+1 SAY " Cancelamento:         C¢digo:           Motivo:"
@ l_s+02,c_s+1 SAY "ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ"
@ l_s+03,c_s+1 SAY " Reintegra‡„o:         Motivo:"
@ l_s+04,c_s+1 SAY " Sob C¢digo..:"
@ l_s+05,c_s+1 SAY "ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ"
@ l_s+06,c_s+1 SAY "                                                 Situa‡„o:"
@ l_s+07,c_s+1 SAY "  ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ Dados Pessoais ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ"
@ l_s+08,c_s+1 SAY " Nome..:                                     Nasc.:"
@ l_s+09,c_s+1 SAY " ECivil:                  CIC:               RG...:"
@ l_s+10,c_s+1 SAY " Ender.:                                     Bairr:"
@ l_s+11,c_s+1 SAY " Cidade:                                           (        -          )"
@ l_s+12,c_s+1 SAY " Contato                                            Cad. em"
@ l_s+13,c_s+1 SAY " Categor.:                  Carnˆ:              FormaPgto.:"
@ l_s+14,c_s+1 SAY " Admiss„o:             T.Carˆncia:              Sai Taxas.:"
@ l_s+15,c_s+1 SAY " Vendedor:"
@ l_s+16,c_s+1 SAY " Regi„o..:                                      Observa‡„o:"
@ l_s+17,c_s+1 SAY " Cobrador:                                      Renova‡„o.:"
@ l_s+18,c_s+1 SAY " Funerais:       Circ.Inic:       Ult.:       Emit:      Baix:"
@ l_s+19,c_s+1 SAY " Participantes: Vivos:    Falecidos:    Dependentes:"
RETU

PROC CGR_gets     // mostra variaveis do arquivo CGRUPOS
LOCAL getlist := {}, t_f7_
CGR_TELA()
SETCOLOR(drvcortel+","+drvcorget+",,,"+corcampo)
PTAB('',[ARQGRUP],1)
PTAB(TIPCONT,'CLASSES',1)
PTAB(VENDEDOR,'COBRADOR',1)
PTAB(REGIAO,'REGIAO',1)
PTAB(COBRADOR,'COBRADOR',1)
PTAB(GRUPO+ULTCIRC,'CIRCULAR',1)
CRIT("",,"2|3|5|8|9|10|11|12")
@ l_s+01 ,c_s+16 GET  numero;
                 PICT sistema[op_sis,O_CAMPO,01,O_MASC]

@ l_s+01 ,c_s+32 GET  codigo;
                 PICT sistema[op_sis,O_CAMPO,02,O_MASC]

@ l_s+01 ,c_s+50 GET  motivo

@ l_s+02 ,c_s+50 GET  canclto_;
                 PICT sistema[op_sis,O_CAMPO,05,O_MASC]

@ l_s+02 ,c_s+62 GET  cancpor

@ l_s+03 ,c_s+16 GET  reintnum;
                 PICT sistema[op_sis,O_CAMPO,07,O_MASC]

@ l_s+03 ,c_s+32 GET  motreint;
                 PICT sistema[op_sis,O_CAMPO,08,O_MASC]

@ l_s+04 ,c_s+53 GET  reintem_;
                 PICT sistema[op_sis,O_CAMPO,09,O_MASC]

@ l_s+04 ,c_s+62 GET  reintpor

@ l_s+04 ,c_s+16 GET  codreint;
                 PICT sistema[op_sis,O_CAMPO,11,O_MASC]

@ l_s+06 ,c_s+60 GET  situacao;
                 PICT sistema[op_sis,O_CAMPO,12,O_MASC]
                 CRIT(sistema[op_sis,O_CAMPO,12,O_CRIT],,"1")

@ l_s+08 ,c_s+10 GET  nome

@ l_s+08 ,c_s+53 GET  nascto_;
                 PICT sistema[op_sis,O_CAMPO,14,O_MASC]

@ l_s+09 ,c_s+10 GET  estcivil;
                 PICT sistema[op_sis,O_CAMPO,15,O_MASC]
                 CRIT(sistema[op_sis,O_CAMPO,15,O_CRIT],,"7")

@ l_s+09 ,c_s+31 GET  cpf;
                 PICT sistema[op_sis,O_CAMPO,16,O_MASC]

@ l_s+09 ,c_s+53 GET  rg;
                 PICT sistema[op_sis,O_CAMPO,17,O_MASC]

@ l_s+10 ,c_s+10 GET  endereco

@ l_s+10 ,c_s+53 GET  bairro

@ l_s+11 ,c_s+10 GET  cidade

@ l_s+11 ,c_s+36 GET  uf;
                 PICT sistema[op_sis,O_CAMPO,21,O_MASC]

@ l_s+11 ,c_s+39 GET  cep;
                 PICT sistema[op_sis,O_CAMPO,22,O_MASC]

@ l_s+12 ,c_s+10 GET  contato;
                 PICT sistema[op_sis,O_CAMPO,23,O_MASC]

@ l_s+12 ,c_s+36 GET  telefone;
                 PICT sistema[op_sis,O_CAMPO,24,O_MASC]

@ l_s+13 ,c_s+12 GET  tipcont;
                 PICT sistema[op_sis,O_CAMPO,25,O_MASC]

@ l_s+13 ,c_s+36 GET  vlcarne

@ l_s+13 ,c_s+61 GET  formapgto;
                 PICT sistema[op_sis,O_CAMPO,27,O_MASC]

@ l_s+14 ,c_s+12 GET  admissao;
                 PICT sistema[op_sis,O_CAMPO,29,O_MASC]

@ l_s+14 ,c_s+36 GET  tcarencia;
                 PICT sistema[op_sis,O_CAMPO,30,O_MASC]

@ l_s+14 ,c_s+61 GET  saitxa;
                 PICT sistema[op_sis,O_CAMPO,31,O_MASC]

@ l_s+15 ,c_s+12 GET  vendedor;
                 PICT sistema[op_sis,O_CAMPO,32,O_MASC]

@ l_s+16 ,c_s+12 GET  regiao;
                 PICT sistema[op_sis,O_CAMPO,33,O_MASC]
                 CRIT(sistema[op_sis,O_CAMPO,33,O_CRIT],,"6")

@ l_s+17 ,c_s+12 GET  cobrador;
                 PICT sistema[op_sis,O_CAMPO,34,O_MASC]
                 CRIT(sistema[op_sis,O_CAMPO,34,O_CRIT],,"4")

@ l_s+16 ,c_s+61 SAY "{M} "

@ l_s+17 ,c_s+61 GET  renovar;
                 PICT sistema[op_sis,O_CAMPO,36,O_MASC]

@ l_s+18 ,c_s+12 GET  funerais;
                 PICT sistema[op_sis,O_CAMPO,37,O_MASC]

@ l_s+18 ,c_s+29 GET  circinic;
                 PICT sistema[op_sis,O_CAMPO,38,O_MASC]

@ l_s+18 ,c_s+41 GET  ultcirc;
                 PICT sistema[op_sis,O_CAMPO,39,O_MASC]

@ l_s+18 ,c_s+53 GET  qtcircs;
                 PICT sistema[op_sis,O_CAMPO,40,O_MASC]

@ l_s+18 ,c_s+64 GET  qtcircpg;
                 PICT sistema[op_sis,O_CAMPO,41,O_MASC]

CLEAR GETS
RETU

PROC CGR_get1     // capta variaveis do arquivo CGRUPOS
LOCAL getlist := {}, t_f7_
PRIV  blk_cgrupos:=.t.
PARA tp_mov
IF tp_mov=INCLUI
 DO WHILE .t.
  rola_t=.f.
  memo35:="{F7}"
  t_f7_=SETKEY(K_F7,{||CGR_memo()})
  SET KEY K_ALT_F8 TO ROLATELA
  SETCOLOR(drvcortel+","+drvcorget+",,,"+corcampo)
  @ l_s+02 ,c_s+50 GET canclto_;
                   PICT sistema[op_sis,O_CAMPO,05,O_MASC]
  @ l_s+03 ,c_s+16 GET reintnum;
                   PICT sistema[op_sis,O_CAMPO,07,O_MASC]
  @ l_s+03 ,c_s+32 GET motreint;
                   PICT sistema[op_sis,O_CAMPO,08,O_MASC]
  @ l_s+04 ,c_s+53 GET reintem_;
                   PICT sistema[op_sis,O_CAMPO,09,O_MASC]
  @ l_s+04 ,c_s+62 GET reintpor
  @ l_s+04 ,c_s+16 GET codreint;
                   PICT sistema[op_sis,O_CAMPO,11,O_MASC]
  CLEA GETS
  CRIT("",,"2|3|5|8|9|10|11|12")
  @ l_s+01 ,c_s+32 GET  codigo;
                   PICT sistema[op_sis,O_CAMPO,02,O_MASC]
                   DEFINICAO 2

  @ l_s+01 ,c_s+50 GET  motivo
                   DEFINICAO 4

  @ l_s+01 ,c_s+62 GET  cancpor
                   DEFINICAO 6

  @ l_s+06 ,c_s+60 GET  situacao;
                   PICT sistema[op_sis,O_CAMPO,12,O_MASC]
                   DEFINICAO 12
                   MOSTRA sistema[op_sis,O_FORMULA,1]

  @ l_s+08 ,c_s+10 GET  nome
                   DEFINICAO 13

  @ l_s+08 ,c_s+53 GET  nascto_;
                   PICT sistema[op_sis,O_CAMPO,14,O_MASC]
                   DEFINICAO 14

  @ l_s+09 ,c_s+10 GET  estcivil;
                   PICT sistema[op_sis,O_CAMPO,15,O_MASC]
                   DEFINICAO 15
                   MOSTRA sistema[op_sis,O_FORMULA,7]

  @ l_s+09 ,c_s+31 GET  cpf;
                   PICT sistema[op_sis,O_CAMPO,16,O_MASC]
                   DEFINICAO 16

  @ l_s+09 ,c_s+53 GET  rg;
                   PICT sistema[op_sis,O_CAMPO,17,O_MASC]
                   DEFINICAO 17

  @ l_s+10 ,c_s+10 GET  endereco
                   DEFINICAO 18

  @ l_s+10 ,c_s+53 GET  bairro
                   DEFINICAO 19

  @ l_s+11 ,c_s+10 GET  cidade
                   DEFINICAO 20

  @ l_s+11 ,c_s+36 GET  uf;
                   PICT sistema[op_sis,O_CAMPO,21,O_MASC]
                   DEFINICAO 21

  @ l_s+11 ,c_s+39 GET  cep;
                   PICT sistema[op_sis,O_CAMPO,22,O_MASC]
                   DEFINICAO 22

  @ l_s+12 ,c_s+10 GET  contato;
                   PICT sistema[op_sis,O_CAMPO,23,O_MASC]
                   DEFINICAO 23

  @ l_s+12 ,c_s+36 GET  telefone;
                   PICT sistema[op_sis,O_CAMPO,24,O_MASC]
                   DEFINICAO 24

  @ l_s+13 ,c_s+12 GET  tipcont;
                   PICT sistema[op_sis,O_CAMPO,25,O_MASC]
                   DEFINICAO 25

  @ l_s+13 ,c_s+36 GET  vlcarne
                   DEFINICAO 26

  @ l_s+13 ,c_s+61 GET  formapgto;
                   PICT sistema[op_sis,O_CAMPO,27,O_MASC]
                   DEFINICAO 27

  @ l_s+14 ,c_s+12 GET  admissao;
                   PICT sistema[op_sis,O_CAMPO,29,O_MASC]
                   DEFINICAO 29

  @ l_s+14 ,c_s+36 GET  tcarencia;
                   PICT sistema[op_sis,O_CAMPO,30,O_MASC]
                   DEFINICAO 30

  @ l_s+14 ,c_s+61 GET  saitxa;
                   PICT sistema[op_sis,O_CAMPO,31,O_MASC]
                   DEFINICAO 31

  @ l_s+15 ,c_s+12 GET  vendedor;
                   PICT sistema[op_sis,O_CAMPO,32,O_MASC]
                   DEFINICAO 32

  @ l_s+16 ,c_s+12 GET  regiao;
                   PICT sistema[op_sis,O_CAMPO,33,O_MASC]
                   DEFINICAO 33
                   MOSTRA sistema[op_sis,O_FORMULA,6]

  @ l_s+17 ,c_s+12 GET  cobrador;
                   PICT sistema[op_sis,O_CAMPO,34,O_MASC]
                   DEFINICAO 34
                   MOSTRA sistema[op_sis,O_FORMULA,4]

  @ l_s+16 ,c_s+61 GET  memo35;
                   PICT "@!"
                   DEFINICAO 35

  @ l_s+17 ,c_s+61 GET  renovar;
                   PICT sistema[op_sis,O_CAMPO,36,O_MASC]
                   DEFINICAO 36

  @ l_s+18 ,c_s+12 GET  funerais;
                   PICT sistema[op_sis,O_CAMPO,37,O_MASC]
                   DEFINICAO 37

  @ l_s+18 ,c_s+29 GET  circinic;
                   PICT sistema[op_sis,O_CAMPO,38,O_MASC]
                   DEFINICAO 38

  @ l_s+18 ,c_s+41 GET  ultcirc;
                   PICT sistema[op_sis,O_CAMPO,39,O_MASC]
                   DEFINICAO 39

  @ l_s+18 ,c_s+53 GET  qtcircs;
                   PICT sistema[op_sis,O_CAMPO,40,O_MASC]
                   DEFINICAO 40

  @ l_s+18 ,c_s+64 GET  qtcircpg;
                   PICT sistema[op_sis,O_CAMPO,41,O_MASC]
                   DEFINICAO 41

  READ
  SETKEY(K_F7,t_f7_)
  SET KEY K_ALT_F8 TO
  IF rola_t
   ROLATELA()
   LOOP
  ENDI
  IF LASTKEY()!=K_ESC .AND. drvincl .AND. op_menu=INCLUSAO
   IF !CONFINCL()
    LOOP
   ENDI
  ENDI
  EXIT
 ENDD
ENDI
IF tp_mov=EXCLUI .OR. tp_mov=FORM_INVERSA
 INTREF(FORM_INVERSA)
 DELE
ELSEIF tp_mov=INCLUI .OR. tp_mov=RECUPERA .OR. tp_mov=FORM_DIRETA
 IF op_menu!=INCLUSAO
  RECA
  INTREF(FORM_DIRETA)
 ENDI
ENDI
RETU

PROC CGR_MEMO
IF READVAR()="MEMO35"
 EDIMEMO("obs",sistema[op_sis,O_CAMPO,35,O_TITU],4,2,13,37)
ENDI
RETU

PROC COE_incl     // inclusao no arquivo COECOB
LOCAL getlist:={}, cabem:=1, rep:=ARRAY(FCOU()), ult_reg:=RECN(),;
      ctl_r, ctl_c, ctl_w, t_f3_, t_f4_, dele_atu:=SET(_SET_DELETED,.f.)
PRIV op_menu:=INCLUSAO, op_sis, l_s, c_s, l_i, c_i, cod_sos, tem_borda, criterio:="", cpord:=""
op_sis=EVAL(qualsis,"COECOB")
IF AT("D",exrot[op_sis])>0
 RETU
ENDI
FOR i=1 TO FCOU()                                  // cria/declara privadas as
 msg=FIEL(i)                                       // variaveis de memoria com
 PRIV &msg.                                        // o mesmo nome dos campos
NEXT                                               // do arquivo
AFILL(rep,"")
t_f3_=SETKEY(K_F3,{||rep()})                       // repeticao reg anterior
t_f4_=SETKEY(K_F4,{||conf()})                      // confirma campos com ENTER
ctl_w=SETKEY(K_CTRL_W,{||nadafaz()})               // enganando o CA-Clipper...
ctl_c=SETKEY(K_CTRL_C,{||nadafaz()})
ctl_r=SETKEY(K_CTRL_R,{||nadafaz()})
DO WHIL cabem>0
 rola_t=.f.                                        // flag se quer rolar a tela
 SELE COECOB
 GO BOTT                                           // forca o
 SKIP                                              // final do arquivo
 
 /*
    cria variaveis de memoria identicas as de arquivo, para inclusao
    de registros
 */
 FOR i=1 TO FCOU()
  msg=FIEL(i)
  M->&msg.=IF(fgrep.AND.!EMPT(rep[1]),rep[i],&msg.)
 NEXT
 
 /*
    inicializa campos de relacionamentos do com os campos do arquivo
    superior (pai)
 */
 FOR i=1 TO LEN(sistema[op_sis,O_CPRELA])
  msg=FIEL(VAL(SUBS(sistema[op_sis,O_ORDEM,1],i*2-1,2)))
  M->&msg.=&(sistema[op_sis,O_CPRELA,i])
 NEXT
 DISPBEGIN()                                       // apresenta a tela de uma vez so
 COE_TELA()
 INFOSIS()                                         // exibe informacao no rodape' da tela
 DISPEND()
 cabem=DISKSPACE(IF(LEN(drvdbf)<2.OR.drvdbf="\",0,ASC(drvdbf)-64))
 cabem=INT((cabem-2048)/COECOB->(RECSIZE()))
 IF cabem<1                                        // mais nenhum!!!
  ALERTA()
  msg="Verifique ESPA€O EM DISCO, "+usuario
  DBOX(msg,,,,,"INCLUSŽO INTERROMPIDA!")           // vamos parar por aqui!
  EXIT
 ENDI
 SELE 0                                            // torna visiveis variaveis de memoria
 SETCOLOR(drvcortel+","+drvcorget+",,,"+corcampo)
 SET KEY K_ALT_F8 TO ROLATELA
 
 /*
    recebe chaves do arquivo de indice basico
 */
 @ l_s+01 ,c_s+12 GET  tipo;
                  PICT sistema[op_sis,O_CAMPO,02,O_MASC]
                  DEFINICAO 2
                  MOSTRA sistema[op_sis,O_FORMULA,1]

 READ
 SET KEY K_ALT_F8 TO
 IF rola_t
  ROLATELA()
  LOOP
 ENDI
 SELE COECOB
 IF LASTKEY()=K_ESC                                // cancelou ou chave em branco
  cabem=0                                          // prepara saida da inclusao
  LOOP                                             // volta p/ menu de cadastramento
 ENDI
 SEEK M->numero+M->tipo
 aprov_reg_=(FOUND().AND.DELE().AND.!drvvisivel)   // vai aproveitar o registro?
 IF FOUND() .AND. !aprov_reg_                      // pesquisou e achou!
  op_menu=ALTERACAO                                // seta flag de ateracao
  DISPBEGIN()
  COE_GETS()                                       // mostra conteudo do registro
  INFOSIS()                                        // exibe informacao no rodape' da tela
  DISPEND()
  ALERTA()
  msg="Consultar/alterar|Retornar … inclus„o"      // pergunta se deseja
  op_=DBOX(msg,,,E_MENU,,"REGISTRO J EXISTE")     // alterar o registro
  IF op_ =1                                        // caso afirmativo
   EDIT()                                          // deixa alterar
  ENDI
  op_menu=INCLUSAO
  LOOP                                             // volta para inclusao
 ENDI
 SELE 0
 COE_GET1(INCLUI)                                  // recebe campos
 SELE COECOB
 IF LASTKEY()=K_ESC                                // se cancelou
  ALERTA()                                         // avisa que o registro
  DBOX("Registro n„o inclu¡do!",18,,1)             // nao foi incluido, e volta
  LOOP
 ENDI

 #ifdef COM_REDE
  GO BOTT                                          // vamos bloquear o final do
  SKIP                                             // arq para que nehum outro
  BLOREG(0,.5)                                     // usuario possa incluir
  SEEK M->numero+M->tipo                           // se registro foi incluido
  aprov_reg_=(FOUND().AND.DELE().AND.!drvvisivel)  // vai aproveitar o registro?
  IF FOUND() .AND. !aprov_reg_                     // por outro usuario, entao
   BLOREG(0,.5)
   FOR i=1 TO FCOU()
    msg=FIEL(i)
    rep[i]=&msg.
    REPL &msg. WITH M->&msg.
   NEXT
   COE_GET1(FORM_INVERSA)                          // executa formula inversa
   RECA
   FOR i=1 TO FCOU()
    msg=FIEL(i)
    REPL &msg. WITH rep[i]
   NEXT
   ALERTA(4)                                       // beep 4 vezes
   msg="Registro acabou de ser|inclu¡do por outro usu rio!"
   DBOX(msg,,,,,"ATEN€ŽO!")                        // avisa
   SELE COECOB
   UNLOCK                                          // libera o registro
   LOOP                                            // e recebe chave novamente
  ENDI
 #endi

 IF aprov_reg_                                     // se vai aproveitar reg excluido

  #ifdef COM_REDE
   BLOREG(0,.5)
  #endi

  RECA                                             // excluido, vamos recupera-lo
 ELSE                                              // caso contrario
  APPEND BLANK                                     // inclui reg em branco no dbf
 ENDI
 FOR i=1 TO FCOU()                                 // para cada campo,
  msg=FIEL(i)                                      // salva o conteudo
  rep[i]=M->&msg.                                  // para repetir
  REPL &msg. WITH rep[i]                           // enche o campo do arquivo
 NEXT

 #ifdef COM_REDE
  UNLOCK                                           // libera o registro e
  COMMIT                                           // forca gravacao
 #else
  IF RECC()-INT(RECC()/20)*20=0                    // a cada 20 registros
   COMMIT                                          // digitados forca gravacao
  ENDI
 #endi

 ult_reg=RECN()                                    // ultimo registro digitado
ENDD
GO ult_reg                                         // para o ultimo reg digitado
SETKEY(K_F3,t_f3_)                                 // restaura teclas de funcoes
SETKEY(K_F4,t_f4_)
SET(_SET_DELETED,dele_atu)                            // ecluidos visiveis/invisiveis
SETKEY(K_CTRL_W,ctl_w)
SETKEY(K_CTRL_C,ctl_c)
SETKEY(K_CTRL_R,ctl_r)
RETU

PROC COE_tela     // tela do arquivo COECOB
tem_borda=.t.
l_s=Sistema[op_sis,O_TELA,O_LS]           // coordenadas da tela
c_s=Sistema[op_sis,O_TELA,O_CS]
l_i=Sistema[op_sis,O_TELA,O_LI]
c_i=Sistema[op_sis,O_TELA,O_CI]
SETCOLOR(drvtittel)
vr_memo=NOVAPOSI(@l_s,@c_s,@l_i,@c_i)     // pega posicao atual da tela
CAIXA(mold,l_s,c_s,l_i,c_i)               // monta caixa da tela
i=LEN(sistema[op_sis,O_MENS])/2
@ l_s,c_s-1+(c_i-c_s+1)/2-i SAY " "+MAIUSC(sistema[op_sis,O_MENS])+" "
SETCOLOR(drvcortel)
@ l_s+01,c_s+1 SAY " Tipo....:"
@ l_s+02,c_s+1 SAY " Endere‡o:"
@ l_s+03,c_s+1 SAY " Bairro..:"
@ l_s+04,c_s+1 SAY " CEP.....:"
@ l_s+05,c_s+1 SAY " Cidade..:                            Est.:"
@ l_s+06,c_s+1 SAY " Telefone:"
@ l_s+07,c_s+1 SAY " Obs.....:"
RETU

PROC COE_gets     // mostra variaveis do arquivo COECOB
LOCAL getlist := {}
COE_TELA()
SETCOLOR(drvcortel+","+drvcorget+",,,"+corcampo)
@ l_s+01 ,c_s+12 GET  tipo;
                 PICT sistema[op_sis,O_CAMPO,02,O_MASC]
                 CRIT(sistema[op_sis,O_CAMPO,02,O_CRIT],,"1")

@ l_s+02 ,c_s+12 GET  endereco;
                 PICT sistema[op_sis,O_CAMPO,03,O_MASC]

@ l_s+03 ,c_s+12 GET  bairro;
                 PICT sistema[op_sis,O_CAMPO,04,O_MASC]

@ l_s+04 ,c_s+12 GET  cep;
                 PICT sistema[op_sis,O_CAMPO,05,O_MASC]

@ l_s+05 ,c_s+12 GET  cidade;
                 PICT sistema[op_sis,O_CAMPO,06,O_MASC]

@ l_s+05 ,c_s+45 GET  uf;
                 PICT sistema[op_sis,O_CAMPO,07,O_MASC]

@ l_s+06 ,c_s+12 GET  telefone;
                 PICT sistema[op_sis,O_CAMPO,08,O_MASC]

@ l_s+07 ,c_s+12 GET  obs

CLEAR GETS
RETU

PROC COE_get1     // capta variaveis do arquivo COECOB
LOCAL getlist := {}
PRIV  blk_coecob:=.t.
PARA tp_mov, excl_rela
excl_rela=IF(excl_rela=NIL,.f.,excl_rela)
IF tp_mov=INCLUI
 DO WHILE .t.
  rola_t=.f.
  SET KEY K_ALT_F8 TO ROLATELA
  SETCOLOR(drvcortel+","+drvcorget+",,,"+corcampo)
  @ l_s+02 ,c_s+12 GET  endereco;
                   PICT sistema[op_sis,O_CAMPO,03,O_MASC]
                   DEFINICAO 3

  @ l_s+03 ,c_s+12 GET  bairro;
                   PICT sistema[op_sis,O_CAMPO,04,O_MASC]
                   DEFINICAO 4

  @ l_s+04 ,c_s+12 GET  cep;
                   PICT sistema[op_sis,O_CAMPO,05,O_MASC]
                   DEFINICAO 5

  @ l_s+05 ,c_s+12 GET  cidade;
                   PICT sistema[op_sis,O_CAMPO,06,O_MASC]
                   DEFINICAO 6

  @ l_s+05 ,c_s+45 GET  uf;
                   PICT sistema[op_sis,O_CAMPO,07,O_MASC]
                   DEFINICAO 7

  @ l_s+06 ,c_s+12 GET  telefone;
                   PICT sistema[op_sis,O_CAMPO,08,O_MASC]
                   DEFINICAO 8

  @ l_s+07 ,c_s+12 GET  obs
                   DEFINICAO 9

  READ
  SET KEY K_ALT_F8 TO
  IF rola_t
   ROLATELA()
   LOOP
  ENDI
  IF LASTKEY()!=K_ESC .AND. drvincl .AND. op_menu=INCLUSAO
   IF !CONFINCL()
    LOOP
   ENDI
  ENDI
  EXIT
 ENDD
ENDI
IF tp_mov=EXCLUI .OR. tp_mov=FORM_INVERSA

 #ifdef COM_REDE
  IF !excl_rela
   REPL flag_excl WITH '*'
  ENDI
 #else
  IF !excl_rela
   REPL flag_excl WITH '*'
  ENDI
 #endi

 DELE
ELSEIF tp_mov=INCLUI .OR. tp_mov=RECUPERA .OR. tp_mov=FORM_DIRETA
 IF (op_menu=INCLUSAO .AND. LASTKEY()!=K_ESC) .OR. op_menu!=INCLUSAO
  IF tp_mov=RECUPERA .AND. op_menu!=INCLUSAO .AND. (CGRUPOS->(DELE()))
   msg="|"+sistema[EVAL(qualsis,"CGRUPOS"),O_MENU]
   ALERTA(2)
   DBOX("Registro exclu¡do em:"+msg+"|*",,,,,"IMPOSS¡VEL RECUPERAR!")
  ELSE
    IF !excl_rela
     IF op_menu=INCLUSAO
      flag_excl=' '
     ELSE
      REPL flag_excl WITH ' '
     ENDI
    ENDI
   IF op_menu!=INCLUSAO
    RECA
   ENDI
  ENDI
 ENDI
ENDI
RETU

PROC CIN_incl     // inclusao no arquivo CINSCRIT
LOCAL getlist:={}, cabem:=1, rep:=ARRAY(FCOU()), ult_reg:=RECN(), cond_incl_,;
      ctl_r, ctl_c, ctl_w, t_f3_, t_f4_, dele_atu:=SET(_SET_DELETED,.f.)
cond_incl_={||1=3}                                 // condicao de inclusao de registros
IF !EVAL(cond_incl_)                               // se nao pode incluir
 IF op_menu!=INCLUSAO                              // nao inclusao nao tem msg
  ALERTA(2)                                        // avisa o motivo
  DBOX("Contrato Cancelado!!!",,,4,,"ATEN€ŽO, "+usuario)
 ENDI
 RETU                                              // e retorna
ENDI
PRIV op_menu:=INCLUSAO, op_sis, l_s, c_s, l_i, c_i, cod_sos, tem_borda, criterio:="", cpord:=""
op_sis=EVAL(qualsis,"CINSCRIT")
IF AT("D",exrot[op_sis])>0
 RETU
ENDI
FOR i=1 TO FCOU()                                  // cria/declara privadas as
 msg=FIEL(i)                                       // variaveis de memoria com
 PRIV &msg.                                        // o mesmo nome dos campos
NEXT                                               // do arquivo
AFILL(rep,"")
t_f3_=SETKEY(K_F3,{||rep()})                       // repeticao reg anterior
t_f4_=SETKEY(K_F4,{||conf()})                      // confirma campos com ENTER
ctl_w=SETKEY(K_CTRL_W,{||nadafaz()})               // enganando o CA-Clipper...
ctl_c=SETKEY(K_CTRL_C,{||nadafaz()})
ctl_r=SETKEY(K_CTRL_R,{||nadafaz()})
DO WHIL cabem>0
 rola_t=.f.                                        // flag se quer rolar a tela
 SELE CINSCRIT
 GO BOTT                                           // forca o
 SKIP                                              // final do arquivo
 
 /*
    cria variaveis de memoria identicas as de arquivo, para inclusao
    de registros
 */
 FOR i=1 TO FCOU()
  msg=FIEL(i)
  M->&msg.=IF(fgrep.AND.!EMPT(rep[1]),rep[i],&msg.)
 NEXT
 
 /*
    inicializa campos de relacionamentos do com os campos do arquivo
    superior (pai)
 */
 FOR i=1 TO LEN(sistema[op_sis,O_CPRELA])
  msg=FIEL(VAL(SUBS(sistema[op_sis,O_ORDEM,1],i*2-1,2)))
  M->&msg.=&(sistema[op_sis,O_CPRELA,i])
 NEXT
 DISPBEGIN()                                       // apresenta a tela de uma vez so
 CIN_TELA()
 INFOSIS()                                         // exibe informacao no rodape' da tela
 DISPEND()
 IF !EVAL(cond_incl_)
  EXIT
 ENDI
 cabem=DISKSPACE(IF(LEN(drvdbf)<2.OR.drvdbf="\",0,ASC(drvdbf)-64))
 cabem=INT((cabem-2048)/CINSCRIT->(RECSIZE()))
 IF cabem<1                                        // mais nenhum!!!
  ALERTA()
  msg="Verifique ESPA€O EM DISCO, "+usuario
  DBOX(msg,,,,,"INCLUSŽO INTERROMPIDA!")           // vamos parar por aqui!
  EXIT
 ENDI
 SELE 0                                            // torna visiveis variaveis de memoria
 SETCOLOR(drvcortel+","+drvcorget+",,,"+corcampo)
 SET KEY K_ALT_F8 TO ROLATELA
 
 /*
    recebe chaves do arquivo de indice basico
 */
 @ l_s+01 ,c_s+17 GET  codigo;
                  PICT sistema[op_sis,O_CAMPO,02,O_MASC]
                  DEFINICAO 2


 READ
 SET KEY K_ALT_F8 TO
 IF rola_t
  ROLATELA()
  LOOP
 ENDI
 SELE CINSCRIT
 IF LASTKEY()=K_ESC                                // cancelou ou chave em branco
  cabem=0                                          // prepara saida da inclusao
  LOOP                                             // volta p/ menu de cadastramento
 ENDI
 SEEK M->numero+M->codigo //grau+STR(M->seq,02,00)
 aprov_reg_=(FOUND().AND.DELE().AND.!drvvisivel)   // vai aproveitar o registro?
 IF FOUND() .AND. !aprov_reg_                      // pesquisou e achou!
  op_menu=ALTERACAO                                // seta flag de ateracao
  DISPBEGIN()
  CIN_GETS()                                       // mostra conteudo do registro
  INFOSIS()                                        // exibe informacao no rodape' da tela
  DISPEND()
  ALERTA()
  msg="Consultar/alterar|Retornar … inclus„o"      // pergunta se deseja
  op_=DBOX(msg,,,E_MENU,,"REGISTRO J EXISTE")     // alterar o registro
  IF op_ =1                                        // caso afirmativo
   EDIT()                                          // deixa alterar
  ENDI
  op_menu=INCLUSAO
  LOOP                                             // volta para inclusao
 ENDI
 SELE 0
 CIN_GET1(INCLUI)                                  // recebe campos
 SELE CINSCRIT
 IF LASTKEY()=K_ESC                                // se cancelou
  ALERTA()                                         // avisa que o registro
  DBOX("Registro n„o inclu¡do!",18,,1)             // nao foi incluido, e volta
  LOOP
 ENDI

 #ifdef COM_REDE
  GO BOTT                                          // vamos bloquear o final do
  SKIP                                             // arq para que nehum outro
  BLOREG(0,.5)                                     // usuario possa incluir
  SEEK M->numero+M->codigo //rau+STR(M->seq,02,00)         // se registro foi incluido
  aprov_reg_=(FOUND().AND.DELE().AND.!drvvisivel)  // vai aproveitar o registro?
  IF FOUND() .AND. !aprov_reg_                     // por outro usuario, entao
   BLOREG(0,.5)
   FOR i=1 TO FCOU()
    msg=FIEL(i)
    rep[i]=&msg.
    REPL &msg. WITH M->&msg.
   NEXT
   CIN_GET1(FORM_INVERSA)                          // executa formula inversa
   RECA
   FOR i=1 TO FCOU()
    msg=FIEL(i)
    REPL &msg. WITH rep[i]
   NEXT
   ALERTA(4)                                       // beep 4 vezes
   msg="Registro acabou de ser|inclu¡do por outro usu rio!"
   DBOX(msg,,,,,"ATEN€ŽO!")                        // avisa
   SELE CINSCRIT
   UNLOCK                                          // libera o registro
   LOOP                                            // e recebe chave novamente
  ENDI
 #endi

 IF aprov_reg_                                     // se vai aproveitar reg excluido

  #ifdef COM_REDE
   BLOREG(0,.5)
  #endi

  RECA                                             // excluido, vamos recupera-lo
 ELSE                                              // caso contrario
  APPEND BLANK                                     // inclui reg em branco no dbf
 ENDI
 FOR i=1 TO FCOU()                                 // para cada campo,
  msg=FIEL(i)                                      // salva o conteudo
  rep[i]=M->&msg.                                  // para repetir
  REPL &msg. WITH rep[i]                           // enche o campo do arquivo
 NEXT

 #ifdef COM_REDE
  UNLOCK                                           // libera o registro e
  COMMIT                                           // forca gravacao
 #else
  IF RECC()-INT(RECC()/20)*20=0                    // a cada 20 registros
   COMMIT                                          // digitados forca gravacao
  ENDI
 #endi

 ult_reg=RECN()                                    // ultimo registro digitado
ENDD
GO ult_reg                                         // para o ultimo reg digitado
SETKEY(K_F3,t_f3_)                                 // restaura teclas de funcoes
SETKEY(K_F4,t_f4_)
SET(_SET_DELETED,dele_atu)                            // ecluidos visiveis/invisiveis
SETKEY(K_CTRL_W,ctl_w)
SETKEY(K_CTRL_C,ctl_c)
SETKEY(K_CTRL_R,ctl_r)
RETU

PROC CIN_tela     // tela do arquivo CINSCRIT
tem_borda=.t.
l_s=Sistema[op_sis,O_TELA,O_LS]           // coordenadas da tela
c_s=Sistema[op_sis,O_TELA,O_CS]
l_i=Sistema[op_sis,O_TELA,O_LI]
c_i=Sistema[op_sis,O_TELA,O_CI]
SETCOLOR(drvtittel)
vr_memo=NOVAPOSI(@l_s,@c_s,@l_i,@c_i)     // pega posicao atual da tela
CAIXA(mold,l_s,c_s,l_i,c_i)               // monta caixa da tela
i=LEN(sistema[op_sis,O_MENS])/2
@ l_s,c_s-1+(c_i-c_s+1)/2-i SAY " "+MAIUSC(sistema[op_sis,O_MENS])+" "
SETCOLOR(drvcortel)
@ l_s+01,c_s+1 SAY "                                                (                   )"
@ l_s+02,c_s+1 SAY "ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ"
@ l_s+03,c_s+1 SAY " Nome......:                                      Nascimento.:"
@ l_s+04,c_s+1 SAY "                                                  T.Carˆncia.:"
@ l_s+05,c_s+1 SAY " Vivo/Falec:     Falecto..:            Tipo:      N§ Processo:"
RETU

PROC CIN_gets     // mostra variaveis do arquivo CINSCRIT
LOCAL getlist := {}, tl_item_
CIN_TELA()
SETCOLOR(drvcortel+","+drvcorget+",,,"+corcampo)
CRIT("",,"2|3|4")
@ l_s+01 ,c_s+17 GET  grau;
                 PICT sistema[op_sis,O_CAMPO,03,O_MASC]
                 CRIT(sistema[op_sis,O_CAMPO,03,O_CRIT],,"1")

@ l_s+03 ,c_s+14 GET  nome

@ l_s+03 ,c_s+64 GET  nascto_;
                 PICT sistema[op_sis,O_CAMPO,05,O_MASC]

@ l_s+04 ,c_s+64 GET  tcarencia;
                 PICT sistema[op_sis,O_CAMPO,06,O_MASC]

@ l_s+05 ,c_s+14 GET  vivofalec;
                 PICT sistema[op_sis,O_CAMPO,08,O_MASC]

@ l_s+05 ,c_s+29 GET  falecto_;
                 PICT sistema[op_sis,O_CAMPO,09,O_MASC]

@ l_s+05 ,c_s+46 GET  tipo;
                 PICT sistema[op_sis,O_CAMPO,10,O_MASC]

@ l_s+05 ,c_s+64 GET  procnr;
                 PICT sistema[op_sis,O_CAMPO,11,O_MASC]

CLEAR GETS
RETU

PROC CIN_get1     // capta variaveis do arquivo CINSCRIT
LOCAL getlist := {}, tl_item_
PRIV  blk_cinscrit:=.t.
PARA tp_mov, excl_rela
excl_rela=IF(excl_rela=NIL,.f.,excl_rela)
IF tp_mov=INCLUI
 DO WHILE .t.
  rola_t=.f.
  SET KEY K_ALT_F8 TO ROLATELA
  SETCOLOR(drvcortel+","+drvcorget+",,,"+corcampo)
  CRIT("",,"2|3|4")
  @ l_s+01 ,c_s+17 GET  grau;
                   PICT sistema[op_sis,O_CAMPO,03,O_MASC]
                   DEFINICAO 3

  @ l_s+03 ,c_s+14 GET  nome
                   DEFINICAO 4

  @ l_s+03 ,c_s+64 GET  nascto_;
                   PICT sistema[op_sis,O_CAMPO,05,O_MASC]
                   DEFINICAO 5

  @ l_s+04 ,c_s+64 GET  tcarencia;
                   PICT sistema[op_sis,O_CAMPO,06,O_MASC]
                   DEFINICAO 6

  @ l_s+05 ,c_s+14 GET  vivofalec;
                   PICT sistema[op_sis,O_CAMPO,08,O_MASC]
                   DEFINICAO 8

  @ l_s+05 ,c_s+29 GET  falecto_;
                   PICT sistema[op_sis,O_CAMPO,09,O_MASC]
                   DEFINICAO 9

  @ l_s+05 ,c_s+46 GET  tipo;
                   PICT sistema[op_sis,O_CAMPO,10,O_MASC]
                   DEFINICAO 10

  @ l_s+05 ,c_s+64 GET  procnr;
                   PICT sistema[op_sis,O_CAMPO,11,O_MASC]
                   DEFINICAO 11

  READ
  SET KEY K_ALT_F8 TO
  IF rola_t
   ROLATELA()
   LOOP
  ENDI
  IF LASTKEY()!=K_ESC .AND. drvincl .AND. op_menu=INCLUSAO
   IF !CONFINCL()
    LOOP
   ENDI
  ENDI
  EXIT
 ENDD
ENDI
IF tp_mov=EXCLUI .OR. tp_mov=FORM_INVERSA

 #ifdef COM_REDE
  IF !excl_rela
   REPL flag_excl WITH '*'
  ENDI
 #else
  IF !excl_rela
   REPL flag_excl WITH '*'
  ENDI
 #endi

 DELE
 IF op_menu!=PROJECOES
  REIMPTEL()
 ENDI
ELSEIF tp_mov=INCLUI .OR. tp_mov=RECUPERA .OR. tp_mov=FORM_DIRETA
 IF (op_menu=INCLUSAO .AND. LASTKEY()!=K_ESC) .OR. op_menu!=INCLUSAO
  IF tp_mov=RECUPERA .AND. op_menu!=INCLUSAO .AND. (CGRUPOS->(DELE()))
   msg="|"+sistema[EVAL(qualsis,"CGRUPOS"),O_MENU]
   ALERTA(2)
   DBOX("Registro exclu¡do em:"+msg+"|*",,,,,"IMPOSS¡VEL RECUPERAR!")
  ELSE
    IF !excl_rela
     IF op_menu=INCLUSAO
      flag_excl=' '
     ELSE
      REPL flag_excl WITH ' '
     ENDI
    ENDI
   IF op_menu!=INCLUSAO
    RECA
   ENDI
   IF (tp_mov=INCLUI .OR. tp_mov=RECUPERA) .AND. op_menu!=PROJECOES
    REIMPTEL()
   ENDI
  ENDI
 ENDI
ENDI
RETU

PROC CTA_incl     // inclusao no arquivo CTAXAS
LOCAL getlist:={}, cabem:=1, rep:=ARRAY(FCOU()), ult_reg:=RECN(), cond_incl_,;
      ctl_r, ctl_c, t_f3_, t_f4_, l_max, dele_atu:=SET(_SET_DELETED,.f.)
cond_incl_={||1=3}                                 // condicao de inclusao de registros
IF !EVAL(cond_incl_)                               // se nao pode incluir
 IF op_menu!=INCLUSAO                              // nao inclusao nao tem msg
  ALERTA(2)                                        // avisa o motivo
  DBOX("Contrato Cancelado",,,4,,"ATEN€ŽO, "+usuario)
 ENDI
 RETU                                              // e retorna
ENDI
PRIV op_menu:=INCLUSAO, op_sis, l_s, c_s, l_i, c_i, cod_sos, tem_borda, criterio:="", cpord:="", l_a
op_sis=EVAL(qualsis,"CTAXAS")
IF AT("D",exrot[op_sis])>0
 RETU
ENDI
FOR i=1 TO FCOU()                                  // cria/declara privadas as
 msg=FIEL(i)                                       // variaveis de memoria com
 PRIV &msg.                                        // o mesmo nome dos campos
NEXT                                               // do arquivo
AFILL(rep,"")
t_f3_=SETKEY(K_F3,{||rep()})                       // repeticao reg anterior
t_f4_=SETKEY(K_F4,{||conf()})                      // confirma campos com ENTER
ctl_w=SETKEY(K_CTRL_W,{||nadafaz()})               // enganando o CA-Clipper...
ctl_c=SETKEY(K_CTRL_C,{||nadafaz()})
ctl_r=SETKEY(K_CTRL_R,{||nadafaz()})
DISPBEGIN()                                        // monta tela na pagina de traz
IMPRELA()                                          // imp telas do pai
CTA_TELA()                                         // imp tela para inclusao
INFOSIS()                                          // exibe informacao no rodape' da tela
l_a=Sistema[op_sis,O_TELA,O_SCROLL]
DISPEND()                                          // apresenta tela de uma vez so
DO WHIL cabem>0
 rola_t=.f.                                        // flag se quer rolar a tela
 SELE CTAXAS
 GO BOTT                                           // forca o
 SKIP                                              // final do arquivo
 
 /*
    cria variaveis de memoria identicas as de arquivo, para inclusao
    de registros
 */
 FOR i=1 TO FCOU()
  msg=FIEL(i)
  M->&msg.=IF(fgrep.AND.!EMPT(rep[1]),rep[i],&msg.)
 NEXT
 
 /*
    inicializa campos de relacionamentos do com os campos do arquivo
    superior (pai)
 */
 FOR i=1 TO LEN(sistema[op_sis,O_CPRELA])
  msg=FIEL(VAL(SUBS(sistema[op_sis,O_ORDEM,1],i*2-1,2)))
  M->&msg.=&(sistema[op_sis,O_CPRELA,i])
 NEXT
 IF !EVAL(cond_incl_)
  EXIT
 ENDI
 cabem=DISKSPACE(IF(LEN(drvdbf)<2.OR.drvdbf="\",0,ASC(drvdbf)-64))
 cabem=INT((cabem-2048)/CTAXAS->(RECSIZE()))
 IF cabem<1                                        // mais nenhum!!!
  ALERTA()
  msg="Verifique ESPA€O EM DISCO, "+usuario
  DBOX(msg,,,,,"INCLUSŽO INTERROMPIDA!")           // vamos parar por aqui!
  EXIT
 ENDI
 SELE 0                                            // torna visiveis variaveis de memoria
 SETCOLOR(drvcortel+","+drvcorget+",,,"+corcampo)
 SET KEY K_ALT_F8 TO ROLATELA
 
 /*
    recebe chaves do arquivo de indice basico
 */
 @ l_s+l_a,c_s+08 GET  tipo;
                  PICT sistema[op_sis,O_CAMPO,03,O_MASC]
                  DEFINICAO 3

 @ l_s+l_a,c_s+12 GET  circ;
                  PICT sistema[op_sis,O_CAMPO,04,O_MASC]
                  DEFINICAO 4

 READ
 SET KEY K_ALT_F8 TO
 IF rola_t
  ROLATELA()
  LOOP
 ENDI
 SELE CTAXAS
 IF LASTKEY()=K_ESC                                // cancelou ou chave em branco
  cabem=0                                          // prepara saida da inclusao
  LOOP                                             // volta p/ menu de cadastramento
 ENDI
 SEEK M->numero+M->tipo+M->circ
 aprov_reg_=(FOUND().AND.DELE().AND.!drvvisivel)   // vai aproveitar o registro?
 IF FOUND() .AND. !aprov_reg_                      // pesquisou e achou!
  l_a=Sistema[op_sis,O_TELA,O_SCROLL]
  op_menu=ALTERACAO                                // seta flag de ateracao
  DISPBEGIN()
  CTA_GETS()                                       // mostra conteudo do registro
  INFOSIS()                                        // exibe informacao no rodape' da tela
  DISPEND()
  ALERTA()
  msg="Consultar/alterar|Retornar … inclus„o"      // pergunta se deseja
  op_=DBOX(msg,,,E_MENU,,"REGISTRO J EXISTE")     // alterar o registro
  IF op_ =1                                        // caso afirmativo
   EDIT()                                          // deixa alterar
  ENDI
  op_menu=INCLUSAO
  DISPBEGIN()
  CTA_TELA()
  INFOSIS()                                        // exibe informacao no rodape' da tela
  DISPEND()
  LOOP                                             // volta para inclusao
 ENDI
 SELE 0
 CTA_GET1(INCLUI)                                  // recebe campos
 SELE CTAXAS
 IF LASTKEY()=K_ESC                                // se cancelou
  ALERTA()                                         // avisa que o registro
  DBOX("Registro n„o inclu¡do!",18,,1)             // nao foi incluido, e volta
  LOOP
 ENDI

 #ifdef COM_REDE
  GO BOTT                                          // vamos bloquear o final do
  SKIP                                             // arq para que nehum outro
  BLOREG(0,.5)                                     // usuario possa incluir
  SEEK M->numero+M->tipo+M->circ                   // se registro foi incluido
  aprov_reg_=(FOUND().AND.DELE().AND.!drvvisivel)  // vai aproveitar o registro?
  IF FOUND() .AND. !aprov_reg_                     // por outro usuario, entao
   BLOREG(0,.5)
   FOR i=1 TO FCOU()
    msg=FIEL(i)
    rep[i]=&msg.
    REPL &msg. WITH M->&msg.
   NEXT
   CTA_GET1(FORM_INVERSA)                          // executa formula inversa
   RECA
   FOR i=1 TO FCOU()
    msg=FIEL(i)
    REPL &msg. WITH rep[i]
   NEXT
   ALERTA(4)                                       // beep 4 vezes
   msg="Registro acabou de ser|inclu¡do por outro usu rio!"
   DBOX(msg,,,,,"ATEN€ŽO!")                        // avisa
   SELE CTAXAS
   UNLOCK                                          // libera o registro
   LOOP                                            // e recebe chave novamente
  ENDI
 #endi

 IF aprov_reg_                                     // se vai aproveitar reg excluido

  #ifdef COM_REDE
   BLOREG(0,.5)
  #endi

  RECA                                             // excluido, vamos recupera-lo
 ELSE                                              // caso contrario
  APPEND BLANK                                     // inclui reg em branco no dbf
 ENDI
 FOR i=1 TO FCOU()                                 // para cada campo,
  msg=FIEL(i)                                      // salva o conteudo
  rep[i]=M->&msg.                                  // para repetir
  REPL &msg. WITH rep[i]                           // enche o campo do arquivo
 NEXT

 #ifdef COM_REDE
  UNLOCK                                           // libera o registro e
  COMMIT                                           // forca gravacao
 #else
  IF RECC()-INT(RECC()/20)*20=0                    // a cada 20 registros
   COMMIT                                          // digitados forca gravacao
  ENDI
 #endi

 ult_reg=RECN()                                    // ultimo registro digitado
 l_max=l_s+Sistema[op_sis,O_TELA,O_SCROLL]+Sistema[op_sis,O_TELA,O_QTDE]
 IF l_s+l_a+1<l_max                                // se nao atingiu o fim da tela
  l_a++                                            // digita na proxima linha
 ELSE                                              // se nao rola a campos para cima
  SCROLL(l_s+Sistema[op_sis,O_TELA,O_SCROLL],c_s+08,l_max-1,c_s+08,1)
  SCROLL(l_s+Sistema[op_sis,O_TELA,O_SCROLL],c_s+12,l_max-1,c_s+14,1)
  SCROLL(l_s+Sistema[op_sis,O_TELA,O_SCROLL],c_s+16,l_max-1,c_s+25,1)
  SCROLL(l_s+Sistema[op_sis,O_TELA,O_SCROLL],c_s+25,l_max-1,c_s+34,1)
  SCROLL(l_s+Sistema[op_sis,O_TELA,O_SCROLL],c_s+36,l_max-1,c_s+45,1)
  SCROLL(l_s+Sistema[op_sis,O_TELA,O_SCROLL],c_s+45,l_max-1,c_s+54,1)
  SCROLL(l_s+Sistema[op_sis,O_TELA,O_SCROLL],c_s+56,l_max-1,c_s+58,1)
  SCROLL(l_s+Sistema[op_sis,O_TELA,O_SCROLL],c_s+59,l_max-1,c_s+59,1)
  SCROLL(l_s+Sistema[op_sis,O_TELA,O_SCROLL],c_s+72,l_max-1,c_s+72,1)
  SCROLL(l_s+Sistema[op_sis,O_TELA,O_SCROLL],c_s+61,l_max-1,c_s+70,1)
  SCROLL(l_s+Sistema[op_sis,O_TELA,O_SCROLL],c_s+01,l_max-1,c_s+06,1)
 ENDI
ENDD
GO ult_reg                                         // para o ultimo reg digitado
SETKEY(K_F3,t_f3_)                                 // restaura teclas de funcoes
SETKEY(K_F4,t_f4_)
SET(_SET_DELETED,dele_atu)                            // ecluidos visiveis/invisiveis
SETKEY(K_CTRL_W,ctl_w)
SETKEY(K_CTRL_C,ctl_c)
SETKEY(K_CTRL_R,ctl_r)
RETU

PROC CTA_tela     // tela do arquivo CTAXAS
tem_borda=.t.
l_s=Sistema[op_sis,O_TELA,O_LS]           // coordenadas da tela
c_s=Sistema[op_sis,O_TELA,O_CS]
l_i=Sistema[op_sis,O_TELA,O_LI]
c_i=Sistema[op_sis,O_TELA,O_CI]
SETCOLOR(drvtittel)
vr_memo=NOVAPOSI(@l_s,@c_s,@l_i,@c_i)     // pega posicao atual da tela
CAIXA(mold,l_s,c_s,l_i,c_i)               // monta caixa da tela
i=LEN(sistema[op_sis,O_MENS])/2
@ l_s,c_s-1+(c_i-c_s+1)/2-i SAY " "+MAIUSC(sistema[op_sis,O_MENS])+" "
SETCOLOR(drvcortel)
@ l_s+01,c_s+1 SAY "      Tip  N§  Emissao      Valor ³ Pagto   Valor Pago Cb F por       Stat"
@ l_s+02,c_s+1 SAY "ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ"
@ l_s+03,c_s+1 SAY "                                  ³"
@ l_s+04,c_s+1 SAY "                                  ³"
@ l_s+05,c_s+1 SAY "                                  ³"
@ l_s+06,c_s+1 SAY "                                  ³"
@ l_s+07,c_s+1 SAY "                                  ³"
@ l_s+08,c_s+1 SAY "                                  ³"
@ l_s+09,c_s+1 SAY "                                  ³"
RETU

PROC CTA_gets     // mostra variaveis do arquivo CTAXAS
LOCAL getlist := {}, l_max, reg_atual:=RECNO()
PRIV  l_a:=Sistema[op_sis,O_TELA,O_SCROLL]
CTA_TELA()
l_max=l_s+Sistema[op_sis,O_TELA,O_SCROLL]+Sistema[op_sis,O_TELA,O_QTDE]
SETCOLOR(drvcortel+","+drvcorget+",,,"+corcampo)
DO WHILE !EOF() .AND. l_s+l_a<l_max .AND.;
   &(INDEXKEY(0))=IF(EMPT(criterio),"","T")+chv_1
 CRIT("",,"1|2|3")
 @ l_s+l_a,c_s+08 GET  tipo;
                  PICT sistema[op_sis,O_CAMPO,03,O_MASC]

 @ l_s+l_a,c_s+12 GET  circ;
                  PICT sistema[op_sis,O_CAMPO,04,O_MASC]

 @ l_s+l_a,c_s+16 GET  emissao_;
                  PICT sistema[op_sis,O_CAMPO,05,O_MASC]

 @ l_s+l_a,c_s+25 GET  valor;
                  PICT sistema[op_sis,O_CAMPO,06,O_MASC]

 @ l_s+l_a,c_s+36 GET  pgto_;
                  PICT sistema[op_sis,O_CAMPO,07,O_MASC]

 @ l_s+l_a,c_s+45 GET  valorpg;
                  PICT sistema[op_sis,O_CAMPO,08,O_MASC]

 @ l_s+l_a,c_s+56 GET  cobrador;
                  PICT sistema[op_sis,O_CAMPO,09,O_MASC]

 @ l_s+l_a,c_s+59 GET  forma;
                  PICT sistema[op_sis,O_CAMPO,10,O_MASC]

 SETCOLOR(drvcortel+","+drvcortel+",,,"+drvcortel)
 l_a++
 SKIP
ENDD
GO reg_atual
SETCOLOR(drvcortel+","+drvcorget+",,,"+corcampo)
CLEAR GETS
RETU

PROC CTA_get1     // capta variaveis do arquivo CTAXAS
LOCAL getlist := {}
PRIV  blk_ctaxas:=.t.
PARA tp_mov, excl_rela
excl_rela=IF(excl_rela=NIL,.f.,excl_rela)
IF tp_mov=INCLUI
 IF TYPE("l_a")!="N"
  l_a=Sistema[op_sis,O_TELA,O_SCROLL]
 ENDI
 DO WHILE .t.
  rola_t=.f.
  SET KEY K_ALT_F8 TO ROLATELA
  SETCOLOR(drvcortel+","+drvcorget+",,,"+corcampo)
  CRIT("",,"1|2|3")
  @ l_s+l_a,c_s+16 GET  emissao_;
                   PICT sistema[op_sis,O_CAMPO,05,O_MASC]
                   DEFINICAO 5

  @ l_s+l_a,c_s+25 GET  valor;
                   PICT sistema[op_sis,O_CAMPO,06,O_MASC]
                   DEFINICAO 6

  @ l_s+l_a,c_s+36 GET  pgto_;
                   PICT sistema[op_sis,O_CAMPO,07,O_MASC]
                   DEFINICAO 7

  @ l_s+l_a,c_s+45 GET  valorpg;
                   PICT sistema[op_sis,O_CAMPO,08,O_MASC]
                   DEFINICAO 8

  @ l_s+l_a,c_s+56 GET  cobrador;
                   PICT sistema[op_sis,O_CAMPO,09,O_MASC]
                   DEFINICAO 9

  @ l_s+l_a,c_s+59 GET  forma;
                   PICT sistema[op_sis,O_CAMPO,10,O_MASC]
                   DEFINICAO 10

  READ
  SET KEY K_ALT_F8 TO
  IF rola_t
   ROLATELA()
   LOOP
  ENDI
  IF LASTKEY()!=K_ESC .AND. drvincl .AND. op_menu=INCLUSAO
   IF !CONFINCL()
    LOOP
   ENDI
  ENDI
  EXIT
 ENDD
ENDI
PTAB(COBRADOR,'COBRADOR',1)
PTAB(CGRUPOS->GRUPO+CIRC,'CIRCULAR',1)
IF tp_mov=EXCLUI .OR. tp_mov=FORM_INVERSA

 #ifdef COM_REDE
  IF !excl_rela
   REPL flag_excl WITH '*'
  ENDI
 #else
  IF !excl_rela
   REPL flag_excl WITH '*'
  ENDI
 #endi

 DELE
ELSEIF tp_mov=INCLUI .OR. tp_mov=RECUPERA .OR. tp_mov=FORM_DIRETA
 IF (op_menu=INCLUSAO .AND. LASTKEY()!=K_ESC) .OR. op_menu!=INCLUSAO
  IF tp_mov=RECUPERA .AND. op_menu!=INCLUSAO .AND. (CGRUPOS->(DELE()))
   msg="|"+sistema[EVAL(qualsis,"CGRUPOS"),O_MENU]
   ALERTA(2)
   DBOX("Registro exclu¡do em:"+msg+"|*",,,,,"IMPOSS¡VEL RECUPERAR!")
  ELSE
    IF !excl_rela
     IF op_menu=INCLUSAO
      flag_excl=' '
     ELSE
      REPL flag_excl WITH ' '
     ENDI
    ENDI
   IF op_menu!=INCLUSAO
    RECA
   ENDI
  ENDI
 ENDI
ENDI
RETU

* \\ Final de CGRUPOS.PRG

FUNC CGR_02F9()

SELE CGRUPOS
GO BOTT
rcodin:=sTRzero(VAL(numero)+1,6,0)
//POINTER_DBF(reg_dbf)

RETU M->rcodin       // <- deve retornar um valor qualquer
/*
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
 \ Empresa.: Ind£stria de Urnas Bignotto Ltda
 \ Programa: ADP_R044.PRG
 \ Data....: 19-01-97
 \ Sistema.: Administradora - PLANO
 \ Funcao..: Impress„o VIP
 \ Analista: Ademilson Pedro Bom
 \ Criacao.: GAS-Pro v3.0 
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/

#include "adpbig.ch"    // inicializa constantes manifestas

LOCAL dele_atu, getlist:={}
PARA  lin_menu, col_menu
PRIV  tem_borda:=.t., op_menu:=VAR_COMPL, l_s:=11, c_s:=20, l_i:=16, c_i:=61, tela_fundo:=SAVESCREEN(0,0,MAXROW(),79)
nucop=1
SETCOLOR(drvtittel)
vr_memo=NOVAPOSI(@l_s,@c_s,@l_i,@c_i)     // pega posicao atual da tela
CAIXA(mold,l_s,c_s,l_i,c_i)               // monta caixa da tela
@ l_s,c_s+9 SAY " GRUPOS C/TAXAS A EMITIR "
SETCOLOR(drvcortel)
@ l_s+01,c_s+1 SAY " Emiss„o:"
@ l_s+02,c_s+1 SAY " Grupo..:      De:       -"
@ l_s+03,c_s+1 SAY " £ltima Circular.:"
@ l_s+04,c_s+1 SAY " Pr¢xima Circular:        Confirme:"
remissao_=CTOD('')                                 // Emiss„o
rgrupo=SPAC(2)                                     // Grupo
rproxcirc=SPAC(3)                                  // N§Proxima Circ.
confirme=SPAC(1)                                   // Confirme
DO WHILE .t.
 rola_t=.f.
 cod_sos=56
 SET KEY K_ALT_F8 TO ROLATELA
 SETCOLOR(drvcortel+","+drvcorget+",,,"+corcampo)
 @ l_s+01 ,c_s+11 GET  remissao_;
                  PICT "@D";
                  VALI CRIT("!EMPT(Remissao_)~Informe uma data v lida p/ EMISSŽO | data de hoje ou posterior.")
                  DEFAULT "CTOD('05'+SUBSTR(DTOC(DATE()+30),3))"
                  AJUDA "Data da Emiss„o da Circular.| Para atualizar circulares se n„o preenchidas| com antecedˆncia."

 @ l_s+02 ,c_s+11 GET  rgrupo;
                  PICT "!9";
		  VALI CRIT("PTAB(rgrupo,'ARQGRUP',1)~GRUPO n„o existe na tabela")
                  DEFAULT "M->mgrupvip"
                  AJUDA "Entre com o grupo ou |tecle F8 para consulta em tabela"
                  CMDF8 "VDBF(6,33,20,77,'ARQGRUP',{'grup','inicio','final','ultcirc','emissao_','procpend'},1,'grup',[])"
                  MOSTRA {"LEFT(TRAN(ARQGRUP->inicio,[999999]),06)", 2 , 20 }
                  MOSTRA {"LEFT(TRAN(ARQGRUP->final,[999999]),06)", 2 , 27 }
                  MOSTRA {"LEFT(TRAN(ARQGRUP->ultcirc,[999]),03)", 3 , 20 }
                  MOSTRA {"LEFT(TRAN(ARQGRUP->emissao_,[@D]),08)", 3 , 24 }

 @ l_s+04 ,c_s+20 GET  rproxcirc;
                  PICT "999";
                  VALI CRIT("rproxcirc>=ARQGRUP->ultcirc~A Pr¢xima circular deve ser maior|ou igual a £ltima emitida")
                  AJUDA "Entre com o n£mero da pr¢xima circular"
                  CMDF8 "STRZERO(VAL(ARQGRUP->ultcirc)+1,3)"

 @ l_s+04 ,c_s+37 GET  confirme;
                  PICT "!";
                  VALI CRIT("confirme='S'.AND.V03001F9()~CONFIRME n„o aceit vel")
                  AJUDA "Digite S para confirmar|ou|tecle ESC para cancelar"

 READ
 SET KEY K_ALT_F8 TO
 IF rola_t
  ROLATELA(.f.)
  LOOP
 ENDI
 IF LASTKEY()=K_ESC                                // se quer cancelar
  RETU                                             // retorna
 ENDI

 #ifdef COM_REDE
  IF !USEARQ("TAXAS",.t.,10,1)                     // se falhou a abertura do arq
   RETU                                            // volta ao menu anterior
  ENDI
 #else
  USEARQ("TAXAS")                                  // abre o dbf e seus indices
 #endi

 PTAB(M->mgrupvip,'ARQGRUP',1)
 PTAB(codigo,"GRUPOS",1,.t.)                       // abre arquivo p/ o relacionamento
 PTAB(GRUPOS->tipcont,"CLASSES",1,.t.)
 PTAB(cobrador,"COBRADOR",1,.t.)
 PTAB(M->mgrupvip+ARQGRUP->proxcirc,"CIRCULAR",1,.t.)
 PTAB(codigo+circ,"MENSAG",1,.t.)
 PTAB(codigo+[3]+circ,"CSTSEG",3,.t.)
 SET RELA TO codigo INTO GRUPOS,;                  // relacionamento dos arquivos
	  TO GRUPOS->tipcont INTO CLASSES,;
	  TO cobrador INTO COBRADOR,;
	  TO M->mgrupvip+ARQGRUP->proxcirc INTO CIRCULAR,;
	  TO codigo+circ INTO MENSAG,;
	  TO codigo+tipo+circ INTO CSTSEG
 titrel:=criterio:=cpord := ""                     // inicializa variaveis
 titrel:=chv_rela:=chv_1:=chv_2 := ""
 tps:=op_x:=ccop := 1
 IF !opcoes_rel(lin_menu,col_menu,31,11)           // nao quis configurar...
  CLOS ALL                                         // fecha arquivos e
  LOOP                                             // volta ao menu
 ENDI
 IF tps=2                                          // se vai para arquivo/video
  arq_=ARQGER()                                    // entao pega nome do arquivo
  IF EMPTY(arq_)                                   // se cancelou ou nao informou
   LOOP                                            // retorna
  ENDI
 ELSE
  arq_=drvporta                                    // porta de saida configurada
 ENDI
 SET PRINTER TO (arq_)                             // redireciona saida
 EXIT
ENDD
IF !EMPTY(drvtapg)                                 // existe configuracao de tam pag?
 op_=AT("NNN",drvtapg)                             // se o codigo que altera
 IF op_=0                                          // o tamanho da pagina
  msg="Configura‡„o do tamanho da p gina!"         // foi informado errado
  DBOX(msg,,,,,"ERRO!")                            // avisa
  CLOSE ALL                                        // fecha todos arquivos abertos
  RETU                                             // e cai fora...
 ENDI                                              // codigo para setar/resetar tam pag
 lpp_026=LEFT(drvtapg,op_-1)+"026"+SUBS(drvtapg,op_+3)
 lpp_066=LEFT(drvtapg,op_-1)+"066"+SUBS(drvtapg,op_+3)
ELSE
 lpp_026:=lpp_066 :=""                             // nao ira mudara o tamanho da pag
ENDI
DBOX("[ESC] Interrompe",15,,,NAO_APAGA)
dele_atu:=SET(_SET_DELETED,.t.)                    // os excluidos nao servem...
SET DEVI TO PRIN                                   // inicia a impressao
maxli=24                                           // maximo de linhas no relatorio
IMPCTL(lpp_026)                                    // seta pagina com 26 linhas
SET MARG TO 1                                      // ajusta a margem esquerda
IF tps=2
 IMPCTL("' '+CHR(8)")
ENDI
BEGIN SEQUENCE
 DO WHIL ccop<=nucop                               // imprime qde copias pedida
  pg_=1; cl=999
  INI_ARQ()                                        // acha 1o. reg valido do arquivo
  ccop++                                           // incrementa contador de copias
  DO WHIL !EOF()
   #ifdef COM_TUTOR
    IF IN_KEY()=K_ESC                              // se quer cancelar
   #else
    IF INKEY()=K_ESC                               // se quer cancelar
   #endi
    IF canc()                                      // pede confirmacao
     BREAK                                         // confirmou...
    ENDI
   ENDI
   IF emissao_=CIRCULAR->emissao_.AND.CLASSES->prior=[S].AND.valorpg=0.AND.!(tipo$'16')// se atender a condicao...
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,015 SAY "Manut.:"
//    valororig=IIF(!CSTSEG->(EOF()),CSTSEG->vlorig,valor)// variavel temporaria
    valororig=IIF(PTAB(codigo+[3]+circ,'CSTSEG',3),CSTSEG->vlorig,valor)// variavel temporaria

    @ cl,023 SAY TRAN(valororig,"@E 999,999.99")   // Valor Contribuicao
    @ cl,062 SAY "Manut.:"
    @ cl,069 SAY TRAN(valororig,"@E 999,999.99")   // Valor Contribuicao
//    @ cl,069 SAY TRAN(IIF(!CSTSEG->(EOF()),CSTSEG->vlorig,valor),"@E 999,999.99")// Valor Contribuicao 2
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,015 SAY "Seguro:"
    @ cl,023 SAY TRAN(valor-valororig,"@E 999,999.99")// Valor Seguro
    @ cl,062 SAY "Seguro:"
    @ cl,069 SAY TRAN(valor-valororig,"@E 999,999.99")// Valor Seguro 2
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,015 SAY "TOTAL.:"
    @ cl,023 SAY TRAN(valor,"@E 999,999.99")       // Valor Total
    @ cl,062 SAY "TOTAL.:"
    @ cl,069 SAY TRAN(valor,"@E 999,999.99")       // Valor Total 2
    REL_CAB(3)                                     // soma cl/imprime cabecalho
    IMPEXP(cl,000,GRUPOS->codigo,12)               // Codigo
    IMPCTL(drvpenf)
    @ cl,024 SAY [/]+tipo+[/]+circ+[ ]             // compl.codigo 2
    IMPCTL(drvtenf)
    IMPEXP(cl,039,GRUPOS->codigo,12)               // Codigo 2
    IMPCTL(drvpenf)
    @ cl,062 SAY [/]+tipo+[/]+circ+[ ]             // compl.codigo 1
    IMPCTL(drvtenf)
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY "Emiss:"
    @ cl,007 SAY TRAN(emissao_,"@D")               // Emissao
    @ cl,020 SAY "Admiss:"
    @ cl,027 SAY TRAN(GRUPOS->admissao,"@D")       // Admiss„o
    @ cl,039 SAY "Emiss:"
    @ cl,046 SAY TRAN(emissao_,"@D")               // Emissao 2
    @ cl,059 SAY "Admiss:"
    @ cl,066 SAY TRAN(GRUPOS->admissao,"@D")       // Admiss„o 2
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY "Cobrador..:"
    @ cl,011 SAY COBRADOR->cobrador+[ ]+LEFT(COBRADOR->nome,15)// Cobrador
    @ cl,039 SAY "Cobrador..:"
    @ cl,050 SAY COBRADOR->cobrador+[ ]+LEFT(COBRADOR->nome,15)// Cobrador 2
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY ALLTRIM(CLASSES->descricao)+[ ]+IIF(GRUPOS->formapgto<[05],SUBSTR(tbfpgto,(VAL(GRUPOS->formapgto)-1)*13+1,13),GRUPOS->formapgto)// definicao 1
    @ cl,039 SAY ALLTRIM(CLASSES->descricao)+[ ]+IIF(GRUPOS->formapgto<[05],SUBSTR(tbfpgto,(VAL(GRUPOS->formapgto)-1)*13+1,13),GRUPOS->formapgto)// definicao 2
    REL_CAB(2)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY GRUPOS->nome                      // Nome
    @ cl,039 SAY GRUPOS->nome                      // Nome 2
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY GRUPOS->endereco                  // Endere‡o
    @ cl,039 SAY GRUPOS->endereco                  // Endere‡o 2
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY GRUPOS->bairro                    // Bairro
    @ cl,039 SAY GRUPOS->bairro                    // Bairro 2
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY GRUPOS->cep+[ ]+ALLTRIM(GRUPOS->cidade)+[, ]+GRUPOS->uf// Cidade
    @ cl,039 SAY GRUPOS->cep+[ ]+ALLTRIM(GRUPOS->cidade)+[, ]+GRUPOS->uf// Cidade 2
    REL_CAB(2)                                     // soma cl/imprime cabecalho
    @ cl,039 SAY chr(15)+MENSAG->mens1+chr(18)     // Mens1
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,039 SAY chr(15)+MENSAG->mens2+chr(18)     // Mens2
    IF M->combarra=[S]
     CODBARRAS({{codigo+tipo+circ,1,13,19}},10,6)
    ENDI
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,039 SAY chr(15)+IIF(EMPT(MENSAG->mens3),CIRCULAR->menscirc,MENSAG->mens3)+chr(18)// Mens 3
    IF M->combarra=[S]
     CODBARRAS({{codigo+tipo+circ,1,13,19}},10,6)
    ENDI
    SKIP                                           // pega proximo registro
    cl=999                                         // forca salto de pagina
   ELSE                                            // se nao atende condicao
    SKIP                                           // pega proximo registro
   ENDI
  ENDD
 ENDD ccop
 EJEC                                              // salta pagina
END SEQUENCE
SET MARG TO                                        // coloca margem esquerda = 0
IMPCTL(lpp_066)                                    // seta pagina com 66 linhas
SET PRINTER TO (drvporta)                          // fecha arquivo gerado (se houver)
SET DEVI TO SCRE                                   // direciona saida p/ video
IF tps=2                                           // se vai para arquivo/video
 BROWSE_REL(arq_,2,3,MAXROW()-2,78)
ENDI                                               // mostra o arquivo gravado
GRELA(31)                                          // grava variacao do relatorio
msgt="PROCESSAMENTOS DO RELAT¢RIO|IMPRESSŽO VIP"
ALERTA()
op_=DBOX("Prosseguir|Cancelar opera‡„o",,,E_MENU,,msgt)
IF op_=1
 DBOX("Processando registros",,,,NAO_APAGA,"AGUARDE!")
 dele_atu:=SET(_SET_DELETED,.t.)                   // os excluidos nao servem...
 SELE TAXAS                                        // processamentos apos emissao
 INI_ARQ()                                         // acha 1o. reg valido do arquivo
 DO WHIL !EOF()
  IF emissao_=CIRCULAR->emissao_.AND.CLASSES->prior=[S].AND.valorpg=0.AND.!(tipo$'16')// se atender a condicao...

   #ifdef COM_REDE
    IF stat < [2]
     REPBLO('TAXAS->stat',{||[2]})
    ENDI
   #else
    IF stat < [2]
     REPL TAXAS->stat WITH [2]
    ENDI
   #endi

   SKIP                                            // pega proximo registro
  ELSE                                             // se nao atende condicao
   SKIP                                            // pega proximo registro
  ENDI
 ENDD
 ALERTA(2)
 DBOX("Processo terminado com sucesso!",,,,,msgt)
ENDI
SELE TAXAS                                         // salta pagina
SET RELA TO                                        // retira os relacionamentos
SET(_SET_DELETED,dele_atu)                         // os excluidos serao vistos
RETU

STATIC PROC REL_CAB(qt)                            // cabecalho do relatorio
IF qt>0                                            // se parametro maior que 0
 cl=cl+qt                                          // soma no contador de linhas
ENDI
IF cl>maxli .OR. qt=0                              // quebra de pagina
 cl=qt+1 ; pg_++
ENDI
RETU

* \\ Final de ADP_R044.PRG
€
 OBX_07F9@–Ñ  OBX_07F9CODEC_ETEXTENDCODE	_SYMSTARTSYMSTARTSYMBOLSSYMBOLS_SYMENDSYMENDNULLBEGDATA_DATADATA_SYMPBDATA_SYMPDATA_SYMPEDATA_CONSTCONST_MSGMSG_BEGBSSBEGBSS_BSSBSS_ENDBSSENDBSSDGROUPÿ˜ @yŸ˜ H  ˜ h  ë˜ `P	ž˜ h  
ã˜ h  ß˜ H  û˜ H  ÷˜ H ë˜ H  ï˜ H  ë˜ (  ˜ H  /*
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
 \ Empresa.: PresServ Inform tica - Limeira (019)452.6623
 \ Programa: ADPBIG.CH
 \ Data....: 24-05-98
 \ Sistema.: Administradora - PLANO
 \ Funcao..: Inicializa constantes do sistema
 \ Analista: Ademilson Pedro Bom
 \ Criacao.: GAS-Pro v3.0 
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/
#include "inkey.ch"          // constantes de codigos das teclas
#include "Fileio.ch"         // funcoes de leitura/gravacao de arquivo
#include "set.ch"            // constantes da funcao SETKEY()

#define NIV_CRI_LIVRE 2      // define quem podera acessar o criterio livre

#define drvautohelp drvautohel    // evita o erro na autoajuda com o harbour
/*
   As diretivas (#define) a seguir referem-se a configuracao da aplicacao

   COM_MAQCALC  cria "pop calculadora" acionada atraves da tecla F5
   COM_CALE ... cria "pop calendario"  acionado atraves da tecla F6
   COM_PROTECAO protege os arquivos ao acesso interativo dBASE
   COM_REDE ... prepara o sistema para operar em rede (multiusuario)
   COM_MOUSE .. prepara programa para funcionar com mouse (se existir)
   COM_TUTOR .. prepara aplicacao para gravar/ler macro (tutoriais)
   COM_LOCK.... cria protecao contra c¢pia
*/
#define COM_CALE
#define COM_MAQCALC
#define COM_REDE
#define COM_MOUSE
#define COM_TUTOR

/*
   Define variaveis a serem usadas na integridade referencial de
   arquivos subordinados (pai e filhos)
*/
#define INCLUI       0       // inclusao de novos registros
#define EXCLUI       1       // exclusao de registros
#define RECUPERA     2       // recupera registros
#define FORM_INVERSA 3       // exclui registros executando formula inversa
#define FORM_DIRETA  4       // recupera registros executando formula direta
#define POSICIONA    5       // abre/posicionas os arquvios relacionados

/*
   Opcoes atribuidas `a variavel do menu de cadastramento (op_menu)
*/
#define INCLUSAO  1          // inclusao de registros
#define ALTERACAO 2          // alteracao de registros (proc edit)
#define PROJECOES 3          // consulta/tela paginada (funcao edita())
#define VAR_COMPL 4          // tela de variaveis complementares
#define TEL_EXTRA 5          // tela complemetar


/*
   Ativa atributo do esquema de cor corrente
*/
#define COR_PADRAO 0          // cor padrao (drvcorpad)
#define COR_GET    1          // cor do campo/menu (drvcorget)

/*
   tipos de video para funcao cardtype()
*/
#define V_CGA   0            // video cga
#define V_MONO  1            // video mono/hercules
#define V_EGA   2            // video ega
#define V_VGA   3            // video vga

/*
   Define variaveis a serem usadas na funcao DBOX() - 'caixa de dialogo`
*/
#define E_MENU .t.           // monta menu de barra
#define E_POPMENU .f.        // monta menu pop-down
#define NAO_APAGA .f.        // nao apagar janela ao selecionar

/*
   tratamento do mouse
*/
#define ESQUERDO    1        // botao esquerdo
#define DIREITO     2        // botao direito
#define CLICK    -100        // botao esquerdo foi clicado

/*
   Define variaveis usadas para facilitar a identificacao dentro
   do vetos sistema[]
*/
#define O_MENU     1    // titulo reduzido para menus
#define O_MENS     2    // titulo do menu de subsistemas
#define O_CHAVE    3    // chaves do arquivos
#define O_CONSU    4    // titulos para menus dos indices de consulta
#define O_ORDEM    5    // numeros sequenciais dos campos nos arqs indices
#define O_ARQUI    6    // nome do arquivo de dados
#define O_INDIC    7    // nomes dos arquivos indices
#define O_DBRELA   8    // nome dos arquivos relacionados
#define O_CPRELA   9    // campos do relacionamento
#define O_TELA    10    // definicao da tela
#define   O_DEF    1    // numero de telas definidas
#define   O_ATUAL  2    // numero da tela atual
#define   O_LS     3    // linha superior da janela
#define   O_CS     4    // coluna superior da janela
#define   O_LI     5    // linha inferior da janela
#define   O_CI     6    // coluna inferior da janela
#define   O_SCROLL 7    // linha onde comeca o scroll
#define   O_QTDE   8    // quantas linhas vao rolar
#define O_OUTROS  11    // miscelanea
#define   O_NIVEL  1    // nivel de acesso do subsistema
#define   O_TPCHV  2    // tipo de chave primaria/nao primaria
#define O_CAMPO   12    // atributos dos campos do subsistema
#define   O_MASC   1    // mascara do campo
#define   O_TITU   2    // titulo do campo
#define   O_CMD    3    // comando especial (f8)
#define   O_DEFA   4    // default para o campo
#define   O_WHEN   5    // clausula when (pre validacao)
#define   O_CRIT   6    // expressao de validacao (critica)
#define   O_HELP   7    // texto de ajuda on-line do campo
#define O_FORMULA 13    // atributos das formulas do subsistema
#define   O_FORM   1    // formula a mostrar
#define   O_LINHA  2    // linha onde a formula sera' mostrada
#define   O_COLUNA 3    // coluna onde a formula sera' mostrada
#define O_CONDEXC 14    // condicao p/ exclusao de registros
#define O_CONDALT 15    // condicao p/ alteracao de registros
#define O_CONDREC 16    // condicao p/ recuperacao de registros

/*
   Comandos criados para auxiliar o comando GET para receber mais outros
   parametro e armazenar na variavel de instancia "CARGO". Este artificio
   e' usado para guardar o texto de ajuda e o comando a executrar quando
   a techa F8 for pressionada, o valor inicial e as formulas que serao
   mostrada apos a digitacao do campo
*/
#command AJUDA <var>     =>  STORECARGO(<var>,ATAIL(getlist),1)
#command CMDF8 <var>     =>  STORECARGO(<var>,ATAIL(getlist),2)
#command DEFAULT <var>   =>  STORECARGO(<var>,ATAIL(getlist),3)
#command MOSTRA <var>    =>  STORECARGO(<var>,ATAIL(getlist),4)
#command DEFINICAO <cp>  =>  STOREALL(<cp>,ATail(GetList))

#ifdef COM_TUTOR
 #command KEYBOARD <c>                                           ;
                          => if acao_mac="G" .OR. acao_mac="D"   ;
                           ;    __Keyboard( <c> )                ;
                           ; end
#endi

* \\ Final de ADPBIG.ch
Turbo C Context File procedure adr_rx29
/*
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
 \ Empresa.: PresServ Inform tica-Limeira (019)452.6623
 \ Programa: ADR_RX29.PRG
 \ Data....: 22-09-97
 \ Sistema.: Administradora - RECEP€„O
 \ Funcao..: Recibo Aux.Funeral 1
 \ Analista: Ademilson Pedro Bom
 \ Criacao.: GAS-Pro v3.0 
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/

#include "adrbig.ch"    // inicializa constantes manifestas

LOCAL dele_atu, getlist:={}, so_um_reg, sit_dbf:=POINTER_DBF()
PARA  lin_menu, col_menu, imp_reg
PRIV  tem_borda:=.t., op_menu:=VAR_COMPL, l_s:=10, c_s:=20, l_i:=13, c_i:=61, tela_fundo:=SAVESCREEN(0,0,MAXROW(),79)
nucop=1
so_um_reg=(PCOU()>2)
IF !so_um_reg                             // vai receber a variaveis?
 SETCOLOR(drvtittel)
 vr_memo=NOVAPOSI(@l_s,@c_s,@l_i,@c_i)    // pega posicao atual da tela
 CAIXA(mold,l_s,c_s,l_i,c_i)              // monta caixa da tela
 @ l_s,c_s+10 SAY " RECIBO AUX.FUNERAL 1 "
 SETCOLOR(drvcortel)
 @ l_s+01,c_s+1 SAY " Processo:"
 @ l_s+02,c_s+1 SAY " Confirme:"
ENDI
rproc=SPAC(11)                                     // Processo
confirme=SPAC(1)                                   // Confirme
DO WHILE .t.
 rola_t=.f.
 cod_sos=56
 IF !so_um_reg
  SET KEY K_ALT_F8 TO ROLATELA
  SETCOLOR(drvcortel+","+drvcorget+",,,"+corcampo)
  @ l_s+01 ,c_s+12 GET  rproc;
                   PICT "@R 99999/9999-99";
                   VALI CRIT("!EMPT(RPROC).AND.PTAB(rproc,[AFUNER],1)~Campo utilizado para localiza‡„o dos documentos.|Tecle F8 para busca em tabela")
                   DEFAULT "IIF(PTAB(PADR(SUBSTR(M->ide_maq,2),4)+[AFU],[IMPPAR],1),ALLTRIM(IMPPAR->docto),[])"
                   AJUDA "Digite neste campo o n£mero de|identifica‡„o do processo"
                   CMDF8 "VDBF(6,12,20,77,'AFUNER',{'processo','proc2','categ','contrato','falecido'},1,'V02001F9()',[])"

  @ l_s+02 ,c_s+12 GET  confirme;
                   PICT "!";
                   VALI CRIT("confirme='S'.AND.V02002F9()~CONFIRME n„o aceit vel|Digite S para confirmar|ou|Tecle ESC para cancelar")
                   AJUDA "Digite S para confirmar|ou|tecle ESC para cancelar"

  READ
  SET KEY K_ALT_F8 TO
  IF rola_t
   ROLATELA(.f.)
   LOOP
  ENDI
  IF LASTKEY()=K_ESC                               // se quer cancelar
   RETU                                            // retorna
  ENDI
 ENDI

 #ifdef COM_REDE
  IF !USEARQ("AFUNER",.f.,10,1)                    // se falhou a abertura do arq
   RETU                                            // volta ao menu anterior
  ENDI
 #else
  USEARQ("AFUNER")                                 // abre o dbf e seus indices
 #endi

 PTAB(contrato,"GRUPOS",1,.t.)                     // abre arquivo p/ o relacionamento
 PTAB(contrato,"INSCRITS",1,.t.)
 SET RELA TO contrato INTO GRUPOS,;                // relacionamento dos arquivos
          TO contrato INTO INSCRITS
 titrel:=criterio:=cpord := ""                     // inicializa variaveis
 titrel:=chv_rela:=chv_1:=chv_2 := ""
 tps:=op_x:=ccop := 1
 arq_=drvporta                                     // porta de saida configurada
 IF !so_um_reg
  IF !opcoes_rel(lin_menu,col_menu,4,11)           // nao quis configurar...
   CLOS ALL                                        // fecha arquivos e
   LOOP                                            // volta ao menu
  ENDI

 #ifdef COM_REDE

  ELSE

   tps=lin_menu

 #endi

 ENDI
 IF tps=2                                          // se vai para arquivo/video
  arq_=ARQGER()                                    // entao pega nome do arquivo
  IF EMPTY(arq_)                                   // se cancelou ou nao informou
   LOOP                                            // retorna
  ENDI
 ELSE
  arq_=drvporta                                    // porta de saida configurada
 ENDI
 IF "4WIN"$UPPER(drvmarca) // nome da configuracao/marca impressora
    arq_:=drvdbf+"WIN"+ide_maq
    tps:=3                                          // se vai para arquivo/video
 ENDIF
 SET PRINTER TO (arq_)                             // redireciona saida
 EXIT
ENDD
DBOX("[ESC] Interrompe",15,,,NAO_APAGA)
dele_atu:=SET(_SET_DELETED,.t.)                    // os excluidos nao servem...
SET DEVI TO PRIN                                   // inicia a impressao
maxli=62                                           // maximo de linhas no relatorio
BEGIN SEQUENCE
 DO WHIL ccop<=nucop                               // imprime qde copias pedida
  pg_=1; cl=999
  IF so_um_reg
   GO imp_reg
  ELSE
   INI_ARQ()                                       // acha 1o. reg valido do arquivo
   IF PTAB(PADR(SUBSTR(M->ide_maq,2),4)+[AFU],[IMPPAR],1)
    PTAB(LEFT(IMPPAR->docto,11),'AFUNER',1)
   ENDI
  ENDI
  ccop++                                           // incrementa contador de copias
  DO WHIL !EOF().AND.(!so_um_reg.OR.imp_reg=RECN())
   #ifdef COM_TUTOR
    IF IN_KEY()=K_ESC                              // se quer cancelar
   #else
    IF INKEY()=K_ESC                               // se quer cancelar
   #endi
    IF canc()                                      // pede confirmacao
     BREAK                                         // confirmou...
    ENDI
   ENDI
   IF (PTAB(PADR(SUBSTR(M->ide_maq,2),4)+[AFU],[IMPPAR],1).and.processo+proc2+filial+categ=ALLTRIM(IMPPAR->docto)) .OR. so_um_reg// se atender a condicao...
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,054 SAY "Processo"
    IMPCTL(drvpenf)
    @ cl,063 SAY TRAN(processo+proc2+filial,"@R 99999/99/!!")// Nr.Processo
    IMPCTL(drvtenf)
    REL_CAB(2)                                     // soma cl/imprime cabecalho
    @ cl,003 SAY "Nome do Contratante:"
    IMPCTL(drvpenf)
    @ cl,024 SAY TRAN(IIF(PTAB(contrato+GRUPOS->titular,'INSCRITS',1),INSCRITS->nome,GRUPOS->nome),"@!")// Nome do contratante
    IMPCTL(drvtenf)
    REL_CAB(2)                                     // soma cl/imprime cabecalho
    IMPAC("Endere‡o:",cl,003)
    IMPCTL(drvpenf)
    @ cl,013 SAY TRAN(xDECRIPT(GRUPOS->endereco),"@!")       // Endereco contratante
    IMPCTL(drvtenf)
    REL_CAB(2)                                     // soma cl/imprime cabecalho
    @ cl,005 SAY "Cidade               Estado  Documento de Identidade Estado Civil"
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    IMPCTL(drvpenf)
    @ cl,005 SAY TRAN(xDECRIPT(GRUPOS->cidade),"@!")         // cidade contratante
    IMPCTL(drvtenf)
    @ cl,028 SAY TRAN([  ],"!!")                   // Estado Contratante
    IMPCTL(drvpenf)
    @ cl,037 SAY GRUPOS->rg                        // Doc
    IMPCTL(drvtenf)
    IMPCTL(drvpenf)
    @ cl,059 SAY TRAN(subst(tbestciv,AT(GRUPOS->estcivil,tbestciv),10),"@!")// Est.Civil contratante
    IMPCTL(drvtenf)
    REL_CAB(2)                                     // soma cl/imprime cabecalho
    IMPAC("Contrato    Grupo            Admiss„o                 Processo",cl,005)
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    IMPCTL(drvpenf)
    @ cl,005 SAY contrato                          // contrato numero
    IMPCTL(drvtenf)
    IMPCTL(drvpenf)
    @ cl,018 SAY GRUPOS->grupo                     // grupo
    IMPCTL(drvtenf)
    IMPCTL(drvpenf)
    @ cl,034 SAY GRUPOS->admissao                  // data admissao
    IMPCTL(drvtenf)
    REL_CAB(3)                                     // soma cl/imprime cabecalho
    IMPMEMO(Rx2901F9(),70,1,cl,002,.t.)            // pedido (memo)
    qli_m=MLCOUNT(Rx2901F9(),70)-1                 // quantas linhas a imprimir?
    li_m=0
    DO WHIL .t.                                    // imprime linhas do memo
     li_m++
     IF li_m>qli_m                                 // fim do memo
      EXIT
     ENDI
     REL_CAB(1)                                    // soma cl/imprime cabecalho
     IMPMEMO(Rx2901F9(),70,1+li_m,cl,002,.t.)      // imprime...
     #ifdef COM_TUTOR
      IF IN_KEY()=K_ESC                            // se quer cancelar
     #else
      IF INKEY()=K_ESC                             // se quer cancelar
     #endi
      IF canc()                                    // pede confirmacao
       BREAK                                       // confirmou...
      ENDI
     ENDI
    ENDD
    REL_CAB(2)                                     // soma cl/imprime cabecalho
    @ cl,004 SAY "Nome do falecido....:"
    IMPCTL(drvpenf)
    @ cl,026 SAY TRAN(falecido,"@!")               // nome do falecido
    IMPCTL(drvtenf)
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    IMPAC("Endere‡o do falecido:",cl,004)
    IMPCTL(drvpenf)
    @ cl,026 SAY TRAN(ALLTRIM(ruares)+[, ]+ALLTRIM(baires),"@!")// Endereco falecido
    IMPCTL(drvtenf)
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,004 SAY "Inscrito neste contrato na qualidade de"
    IMPCTL(drvpenf)
    @ cl,044 SAY grauparcon                        // Inscrito na qualidade de
    IMPCTL(drvtenf)
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,004 SAY "Data do Falecimento.:"
    @ cl,026 SAY TRAN(falecto_,"@D")               // Data falcto.
    IMPAC("Hor rio do Falecimento:",cl,036)
    @ cl,060 SAY TRAN(horafal,"99:99")             // Hora Falcto.
    REL_CAB(2)                                     // soma cl/imprime cabecalho
    @ cl,004 SAY "Cidade do Falecimento Estado   Local do falecimento"
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    IMPCTL(drvpenf)
    @ cl,004 SAY municfal                          // Cidade Falecimento
    IMPCTL(drvtenf)
    IMPCTL(drvpenf)
    @ cl,028 SAY TRAN(estfal,"!!")                 // UF falecimento
    IMPCTL(drvtenf)
    IMPCTL(drvpenf)
    @ cl,035 SAY ALLTRIM(ruafal)                   // local falecimento
    IMPCTL(drvtenf)
    REL_CAB(2)                                     // soma cl/imprime cabecalho
    IMPAC("Cemit‚rio onde foi sepultado        Hora do sepultamento",cl,004)
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    IMPCTL(drvpenf)
    @ cl,004 SAY cemitsep                          // Cemit‚rio sepultamento
    IMPCTL(drvtenf)
    IMPCTL(drvpenf)
    @ cl,046 SAY TRAN(horasepult,"99:99")          // Hora sepultamento
    IMPCTL(drvtenf)
    REL_CAB(3)                                     // soma cl/imprime cabecalho
    @ cl,004 SAY "Datado em       de                    de           , conforme processo"
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    IMPAC("administrativo n£mero",cl,002)
    @ cl,024 SAY TRAN(processo+proc2+filial,"@R 99999/99/!!")// Processo
    @ cl,032 SAY "."
    REL_CAB(2)                                     // soma cl/imprime cabecalho
    @ cl,025 SAY IMPAC(RTRIM(M->p_cidade)+[, ]+LEFT(DTOC(DATE()),2)+[ de ]+NMES(MONTH(DATE()))+ [ de ]+LEFT(DTOS(DATE()),4))// DATA
    REL_CAB(2)                                     // soma cl/imprime cabecalho
    @ cl,001 SAY "PROCESSAR"
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY "PAGAMENTO EM"
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    IMPCTL(drvpenf)
    @ cl,002 SAY TRAN(procpagto_,"@D")             // Proc.pagto em
    IMPCTL(drvtenf)
    REL_CAB(3)                                     // soma cl/imprime cabecalho
    @ cl,021 SAY REPL("-",42)
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,021 SAY "Ass.:"
    IMPCTL(drvpenf)
    @ cl,027 SAY GRUPOS->nome                      // Nome
    IMPCTL(drvtenf)
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,027 SAY "RG:"
    @ cl,031 SAY TRAN(GRUPOS->rg,"@!")             // R.G.
    SKIP                                           // pega proximo registro
    cl=999                                         // forca salto de pagina
   ELSE                                            // se nao atende condicao
    SKIP                                           // pega proximo registro
   ENDI
   EXIT
  ENDD
 ENDD ccop
END SEQUENCE
SET PRINTER TO (drvporta)                          // fecha arquivo gerado (se houver)
SET DEVI TO SCRE                                   // direciona saida p/ video
IF tps=2                                           // se vai para arquivo/video
 BROWSE_REL(arq_,2,3,MAXROW()-2,78)
ENDI                                               // mostra o arquivo gravado
GRELA(4)                                           // grava variacao do relatorio
SELE AFUNER                                        // salta pagina
SET RELA TO                                        // retira os relacionamentos
SET(_SET_DELETED,dele_atu)                         // os excluidos serao vistos
IF so_um_reg
 POINTER_DBF(sit_dbf)
ENDI
RETU

STATIC PROC REL_CAB(qt)                            // cabecalho do relatorio
IF qt>0                                            // se parametro maior que 0
 cl=cl+qt                                          // soma no contador de linhas
ENDI
IF cl>maxli .OR. qt=0                              // quebra de pagina
 @ 0,001 SAY IIF(categ=[PD],[Plano c/Difer. ],IIF(categ=[PL],[Atend.Plano],[Rest.Desp.Funerais]))// Categoria
 @ 5,021 SAY M->setup1                             // Ident1
 @ 7,034 SAY "RECIBO"
 cl=qt+8 ; pg_++
ENDI
RETU

* \\ Final de ADR_RX29.PRG

ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 NOME DO PROJETO:                           ³ NOME EXECUTVEL:
                                            ³
   Administradora - RECEP€„O                ³   ADRBIG.EXE
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 NOME DO PROCESSO:                          ³ ARQUIVO PRINCIPAL
                                            ³
                                            ³   DCI_P001.DBF
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 DEFINI€ŽO:




ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 OBSERVA€™ES:

GAS-Pro v4.0
004012024063001009043001013001176001
 Numero:
 Contrato:
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ
                                      ³Circulares
                                      ³ Ini
                            Reg.:     ³  £lt
                                      ³
 Admiss„o:            Sai Taxa:       ³
 Funerais:            Cobrador:       ³
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ




ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 Ref.:                       Vl.Pago:
 Pago com..:             Troco:

  emitida em             por
[Ÿ]
Inclus„o~~26006
Manuten‡„o~~27007
Consulta~~28008
[Ÿ]
 10 
 3 
N£mero

 1 
[Ÿ]
Caixa

 8 
 1 
[Ÿ]
Contrato

 2 
[Ÿ]
Outros Recebimentos
Outros Recebimentos

nivelop>1
Permitido apenas a usu rios cadastrados|com n¡vel de Manuten‡„o ou Maior
nivelop=3
Para alterar este documento|chame o gerente de sistema
nivelop>1
Permitido apenas a usu rios cadastrados|com n¡vel de Manuten‡„o ou Maior
005


nivelop>1
Permitido apenas a usu rios cadastrados|com n¡vel de Manuten‡„o ou Maior



002003024079001001001001003000176001




























 0 
 1 
-1 
-1 
 0 
-1 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
numero
C
V
99999999
 8 
 8 
 1 
 12 
 0 
Numero



RIGHT(DTOC(DATE()),2)+[000001]


 0 
 1 


codigo
C
E
@!
 9 
 9 
 2 
 12 
 0 
Codigo

(PTAB(ALLTRIM(codigo),[GRUPOS]).AND.OBX_07F9()).AND.(PTAB(codigo,'TAXAS',1).OR.1=1).AND.CAD_04F9(op_menu)
Contrato inv lido |ou inexistente

Informe o n£mero do contrato
VDBF(6,3,20,77,'GRUPOS',{'codigo','grupo','nome','endereco'},1,'codigo',[])
 0 
 0 


cobranca
C
E
@!
 25 
 20 
 16 
 8 
 0 
Cobranca

!EMPT(cobranca)
Necess rio informar COBRANCA



 0 
 0 


valorpg
N
E
@E 999,999.99
 9 
 10 
 16 
 39 
 2 
Valor pago
!EMPT(cobranca)
valorpg>0
VALOR PAGO n„o aceit vel|Digite o valor recebido

Informe o valor pago ou zeros se for retorno.

 0 
 0 


valoraux
N
E
@E 999,999.99
 9 
 10 
 17 
 14 
 2 
Pago com...

valoraux>=valorpg
VALOR INSUFICIENTE para quitar o d‚bito|A T E N € Ç O

Informe o valor pago

 0 
 0 


emitido_
D
V
@D
 8 
 10 
 19 
 14 
 0 
Emitido em






 0 
 0 


por
C
V
 
 10 
 10 
 19 
 30 
 0 
Por






 0 
 0 


numop
C
V
999999
 6 
 6 
 19 
 44 
 0 
N§ O.P.






 0 
 0 


grupo
C
I
!9
 2 
 2 
 0 
 0 
 0 
Grupo






 0 
 0 


filial
C
I
@!
 2 
 2 
 0 
 0 
 0 
Filial






 0 
 0 


 16 
Nome
GRUPOS->nome

 4 
 2 
 35 

Circ 1 - 4
OBX_01F9()

 11 
 2 
 48 

Ult.Circular
GRUPOS->ultcirc
999
 6 
 47 
 3 

Situa‡„o
IIF(GRUPOS->situacao='2',[CANCELADO],[         ])+[ - Grupo ]+GRUPOS->grupo

 2 
 23 
 22 

Admiss„o
GRUPOS->admissao
@D
 8 
 12 
 10 

Saitxa
GRUPOS->saitxa
@R 99/99
 8 
 33 
 5 

Cobrador
GRUPOS->cobrador
!!
 9 
 33 
 2 

Funerais
GRUPOS->funerais
99
 9 
 12 
 2 

Circ.Inicial
GRUPOS->circinic
999
 5 
 46 
 3 

Endere‡o
GRUPOS->endereco

 5 
 2 
 35 

Bairro
GRUPOS->bairro

 6 
 2 
 25 

Cidade
GRUPOS->cidade

 7 
 2 
 25 

CEP
GRUPOS->cep
@R 99999-999
 7 
 29 
 9 

Regi„o
GRUPOS->regiao
999
 6 
 35 
 3 

troco
valoraux-valorpg
@E 999,999.99
 17 
 33 
 11 

Filial
filial
@!
 1 
 23 
 2 

 8 
OBXEC
numop
ORDPGRC->numop
ORDPGRC->numop
EMPT(numop)


ORDPGRC
nrdoctos
ORDPGRC->nrdoctos + 1
ORDPGRC->nrdoctos - 1
PTAB(numop,'ORDPGRC',1)


OBXEC
emitido_
DATE()




OBXEC
por
M->usuario




OBXEC
filial
M->p_filial




ORDPGRC
valortotal
ORDPGRC->valortotal+valorpg
ORDPGRC->valortotal-valorpg
EMPT(numop).AND.PTAB(IIF(EMPT(M->usuario),PADR(M->contarec+ide_maq,10,' '),PADR(M->usuario,10,' '))+M->histrcrec+[       ],'ORDPGRC',2)


ORDPGRC
valortotal
ORDPGRC->valortotal +valorpg
ORDPGRC->valortotal -valorpg
!EMPT(numop).AND.PTAB(numop,'ORDPGRC',1)


IMPPAR
docto
numero

PTAB(PADR(SUBSTR(M->ide_maq,2),4)+[OBX],[IMPPAR],1)


 0 
 2 
ORDPGRC
1
 17 
!EMPT(valorpg).AND. !PTAB(IIF(EMPT(M->usuario),PADR(M->contarec+ide_maq,10,' '),PADR(M->usuario,10,' '))+M->histrcrec+[       ],'ORDPGRC',2)
1=3
 0 



numop
C



origem
C
[ADM]


lancto_
D
DATE()


por
C
M->usuario


numconta
C
IIF(EMPT(M->usuario),PADR(M->contarec+ide_maq,10,' '),PADR(M->usuario,10,' '))


historico
C
M->histrcrec


debcred
C
[C]


valortotal
N
0


vencto_
D
DATE()


documento
C
[FCC/Taxas]


nrdoctos
N



complement
C
[FCC/Outros recebimentos]


fechto_
D



fechpor
C



autoriz_
D



autorpor
C



numos
C



IMPPAR
1
 3 
!PTAB(PADR(SUBSTR(M->ide_maq,2),4)+[OBX],[IMPPAR],1)
1=3
 0 



idmaq
C
PADR(SUBSTR(M->ide_maq,2),4)


base
C
[OBX]


docto
C



 1 
ADM_R023
 0 
Outros recibos (2¦Via)



procedure circular
/*
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
 \ Empresa.: PresServ Inform tica - Limeira (019)452.6623
 \ Programa: CIRCULAR.PRG
 \ Data....: 04-11-03
 \ Sistema.: Administradora - RECEP€„O
 \ Funcao..: Gerenciador do subsistema de circulares
 \ Analista: Ademilson Pedro Bom
 \ Criacao.: GAS-Pro v4.0n
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/
#include "adrbig.ch"    // inicializa constantes manifestas

PARA lin_menu,col_menu
PRIV op_sis, tela_fundo:=SAVESCREEN(0,0,MAXROW(),79), l_s, c_s, l_i, c_i, l_a

op_sis=EVAL(qualsis,"CIRCULAR")
IF nivelop<sistema[op_sis,O_OUTROS,O_NIVEL]        // se usuario nao tem permissao,
 ALERTA()                                          // entao, beep, beep, beep
 DBOX(msg_auto,,,3)                                // lamentamos e
 RETU                                              // retornamos ao menu
ENDI
cn:=fgrep :=.f.

#ifdef COM_LOCK
 IF LEN(pr_ok)>0                                   // se a protecao acusou
  ? pr_ok                                          // erro, avisa e
  QUIT                                             // encerra a aplicacao
 ENDI
#endi

t_fundo=SAVESCREEN(0,0,MAXROW(),79)                // salva tela do fundo
op_cad=1
DO WHIL op_cad!=0
 criterio=""
 RESTSCREEN(0,0,MAXROW(),79,t_fundo)               // restaura tela do fundo
 cod_sos=5 ; cn=.f.
 CLEA TYPEAHEAD                                    // limpa o buffer do teclado
 fgrep=.f.
 SET KEY K_F3 TO                                   // retira das teclas F3 e F4 as
 SET KEY K_F4 TO                                   // funcoes de repeticao e confirmacao
 msg="Inclus„o~1|"+;
     "Manuten‡„o~2|"+;
     "Consulta~3"
 op_cad=DBOX(msg,lin_menu,col_menu,E_MENU,NAO_APAGA,MAIUSC(sistema[op_sis,O_MENU]),,,op_cad)
 IF op_cad!=0                                      // se escolheu uma opcao
  Tela_fundo=SAVESCREEN(0,0,MAXROW(),79)           // salva a tela para ROLATELA()
  PARAMETROS(dbfparam)
  SELE A                                           // e abre o arquivo e seus indices

  #ifdef COM_REDE
   IF !USEARQ(sistema[op_sis,O_ARQUI,O_NOME],.f.,20,1)
                                                   // se falhou a abertura do
    RETU                                           // arquivo volta ao menu anterior
   ENDI
  #else
   USEARQ(sistema[op_sis,O_ARQUI,O_NOME])
  #endi

  SET KEY K_F9 TO veoutros                         // habilita consulta em outros arquivos
 ENDI
 DO CASE
  CASE op_cad=01                                   // inclus„o
   op_menu=INCLUSAO
   IF AT("D",exrot[op_sis])=0                      // se usuario pode fazer inclusao
    CIR_INCL()                                     // neste arquivo chama prg de inclusao
   ELSE                                            // caso contrario vamos avisar que
    ALERTA()                                       // ele nao tem permissao para isto
    DBOX(msg_auto,,,3)
   ENDI

  CASE op_cad=02                                   // manuten‡„o
   op_menu=ALTERACAO
   cod_sos=7
   EDIT()

  CASE op_cad=03                                   // consulta
   op_menu=PROJECOES
   cod_sos=8
   EDITA(03,03,MAXROW()-2,77)

 ENDC
 SET KEY K_F9 TO                                   // F9 nao mais consultara outros arquivos
 CLOS ALL                                          // fecha todos arquivos abertos
ENDD
RETU

PROC CIR_incl(reg_cop)  // inclusao no arquivo CIRCULAR
LOCAL getlist:={}, cabem:=1, rep:=ARRAY(FCOU()), ult_reg:=RECN(),;
      ctl_r, ctl_c, ctl_w, t_f3_, t_f4_, dele_atu:=SET(_SET_DELETED,.f.)
PRIV op_menu:=INCLUSAO, tem_borda, criterio:="", cpord:=""
FOR i=1 TO FCOU()                                  // cria/declara privadas as
 msg=FIEL(i)                                       // variaveis de memoria com
 PRIV &msg.                                        // o mesmo nome dos campos
NEXT                                               // do arquivo
IF reg_cop!=NIL                                    // quer repetir todo o reg atual
 FOR i=1 TO FCOU()                                 // para cada campo,
  msg=FIEL(i)                                      // salva o conteudo
  rep[i]=&msg.                                     // para repetir
 NEXT
ELSE
 AFILL(rep,"")                                     // eche com valor vazio
ENDI
t_f3_=SETKEY(K_F3,{||rep()})                       // repeticao reg anterior
t_f4_=SETKEY(K_F4,{||conf()})                      // confirma campos com ENTER
ctl_w=SETKEY(K_CTRL_W,{||nadafaz()})               // enganando o CA-Clipper...
ctl_c=SETKEY(K_CTRL_C,{||nadafaz()})
ctl_r=SETKEY(K_CTRL_R,{||nadafaz()})
DO WHIL cabem>0
 cod_sos=6
 rola_t=.f.                                        // flag se quer rolar a tela
 SELE CIRCULAR
 GO BOTT                                           // forca o
 SKIP                                              // final do arquivo
 
 /*
    cria variaveis de memoria identicas as de arquivo, para inclusao
    de registros
 */
 FOR i=1 TO FCOU()
  msg=FIEL(i)
  M->&msg.=IF((fgrep .OR. reg_cop!=NIL).AND.!EMPT(rep[1]),rep[i],&msg.)
 NEXT
 DISPBEGIN()                                       // apresenta a tela de uma vez so
 CIR_GETS()
 IMPRELA()
 CIR_TELA()
 INFOSIS(.t.)                                      // exibe informacao no rodape' da tela
 DISPEND()
 cabem=DISKSPACE(;
          IF(;
             LEN(sistema[op_sis,O_ARQUI,O_DIR_DBF])<2.OR.sistema[op_sis,O_ARQUI,O_DIR_DBF]="\",;
             0,;
             ASC(sistema[op_sis,O_ARQUI,O_DIR_DBF])-64;
          );
       )
 cabem=INT((cabem-2048)/CIRCULAR->(RECSIZE()))
 IF cabem<1                                        // mais nenhum!!!
  ALERTA()
  msg="Verifique ESPA€O EM DISCO, "+usuario
  DBOX(msg,,,,,"INCLUSŽO INTERROMPIDA!")           // vamos parar por aqui!
  EXIT
 ENDI
 SELE 0                                            // torna visiveis variaveis de memoria
 SETCOLOR(drvcortel+","+drvcorget+",,,"+corcampo)
 SET KEY K_ALT_F8 TO ROLATELA
 
 /*
    recebe chaves do arquivo de indice basico
 */
 @ l_s+01 ,c_s+08 GET  grupo;
                  PICT sistema[op_sis,O_CAMPO,01,O_MASC]
                  DEFINICAO 1

 @ l_s+01 ,c_s+21 GET  circ;
                  PICT sistema[op_sis,O_CAMPO,02,O_MASC]
                  DEFINICAO 2

 READ
 SET KEY K_ALT_F8 TO
 IF rola_t
  ROLATELA()
  LOOP
 ENDI
 SELE CIRCULAR
 IF LASTKEY()=K_ESC                                // cancelou ou chave em branco
  cabem=0                                          // prepara saida da inclusao
  LOOP                                             // volta p/ menu de cadastramento
 ENDI
 SEEK M->grupo+M->circ
 aprov_reg_=(FOUND().AND.DELE().AND.!drvvisivel)   // vai aproveitar o registro?
 IF FOUND() .AND. !aprov_reg_                      // pesquisou e achou!
  op_menu=ALTERACAO                                // seta flag de ateracao
  DISPBEGIN()
  CIR_GETS()
  IMPRELA()
  CIR_GETS()                                       // mostra conteudo do registro
  INFOSIS(.f.)                                     // exibe informacao no rodape' da tela
  DISPEND()
  ALERTA()
  msg="Consultar/alterar|Retornar … inclus„o"      // pergunta se deseja
  op_=DBOX(msg,,,E_MENU,,"REGISTRO J EXISTE")     // alterar o registro
  IF op_ =1                                        // caso afirmativo
   EDIT()                                          // deixa alterar
  ENDI
  op_menu=INCLUSAO
  LOOP                                             // volta para inclusao
 ENDI
 SELE 0
 CIR_GET1(INCLUI)                                  // recebe campos
 SELE CIRCULAR
 IF LASTKEY()=K_ESC                                // se cancelou
  ALERTA()                                         // avisa que o registro
  DBOX("Registro n„o inclu¡do!",18,,1)             // nao foi incluido, e volta
  LOOP
 ENDI

 #ifdef COM_REDE
  GO BOTT                                          // vamos bloquear o final do
  SKIP                                             // arq para que nehum outro
  BLOREG(0,.5)                                     // usuario possa incluir
  SEEK M->grupo+M->circ                            // se registro foi incluido
  aprov_reg_=(FOUND().AND.DELE().AND.!drvvisivel)  // vai aproveitar o registro?
  IF FOUND() .AND. !aprov_reg_                     // por outro usuario, entao
   BLOREG(0,.5)
   FOR i=1 TO FCOU()
    msg=FIEL(i)
    rep[i]=&msg.
    REPL &msg. WITH M->&msg.
   NEXT
   CIR_GET1(FORM_INVERSA)                          // executa formula inversa
   RECA
   FOR i=1 TO FCOU()
    msg=FIEL(i)
    REPL &msg. WITH rep[i]
   NEXT
   ALERTA(4)                                       // beep 4 vezes
   msg="Registro acabou de ser|inclu¡do por outro usu rio!"
   DBOX(msg,,,,,"ATEN€ŽO!")                        // avisa
   SELE CIRCULAR
   UNLOCK                                          // libera o registro
   LOOP                                            // e recebe chave novamente
  ENDI
 #endi

 IF aprov_reg_                                     // se vai aproveitar reg excluido

  #ifdef COM_REDE
   BLOREG(0,.5)
  #endi

  RECA                                             // excluido, vamos recupera-lo
 ELSE                                              // caso contrario
  APPEND BLANK                                     // inclui reg em branco no dbf
 ENDI
 FOR i=1 TO FCOU()                                 // para cada campo,
  msg=FIEL(i)                                      // salva o conteudo
  rep[i]=M->&msg.                                  // para repetir
  REPL &msg. WITH rep[i]                           // enche o campo do arquivo
 NEXT

 #ifdef COM_REDE
  UNLOCK                                           // libera o registro e
  COMMIT                                           // forca gravacao
 #else
  IF RECC()-INT(RECC()/20)*20=0                    // a cada 20 registros
   COMMIT                                          // digitados forca gravacao
  ENDI
 #endi

 ult_reg=RECN()                                    // ultimo registro digitado
 IF sistema[EVAL(qualsis,"CPRCIRC"),O_OUTROS,O_NIVEL]<5
  SUBNIVEL("CPRCIRC")
 ENDI
 IF reg_cop!=NIL                                   // estava na consulta e quis rep o campo
  EXIT                                             // cai fora...
 ENDI
ENDD
GO ult_reg                                         // para o ultimo reg digitado
SETKEY(K_F3,t_f3_)                                 // restaura teclas de funcoes
SETKEY(K_F4,t_f4_)
SET(_SET_DELETED,dele_atu)                            // ecluidos visiveis/invisiveis
SETKEY(K_CTRL_W,ctl_w)
SETKEY(K_CTRL_C,ctl_c)
SETKEY(K_CTRL_R,ctl_r)
RETU


PROC CIR_tela     // tela do arquivo CIRCULAR
tem_borda=.t.
l_s=Sistema[op_sis,O_TELA,O_LS]           // coordenadas da tela
c_s=Sistema[op_sis,O_TELA,O_CS]
l_i=Sistema[op_sis,O_TELA,O_LI]
c_i=Sistema[op_sis,O_TELA,O_CI]
SETCOLOR(drvtittel)
vr_memo=NOVAPOSI(@l_s,@c_s,@l_i,@c_i)     // pega posicao atual da tela
CAIXA(mold,l_s,c_s,l_i,c_i)               // monta caixa da tela
i=LEN(sistema[op_sis,O_MENS])/2
@ l_s,c_s-1+(c_i-c_s+1)/2-i SAY " "+MAIUSC(sistema[op_sis,O_MENS])+" "
SETCOLOR(drvcortel)
@ l_s+01,c_s+1 SAY " Grupo:    Circular:"
@ l_s+02,c_s+1 SAY " Emiss„o....:              Mˆs Refer:"
@ l_s+04,c_s+1 SAY " Lan‡ado em.:           Usu rio.:"
@ l_s+05,c_s+1 SAY " Impresso em:           com    processos."
@ l_s+06,c_s+1 SAY " Mensagem...:"
@ l_s+09,c_s+1 SAY "ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ"
@ l_s+10,c_s+1 SAY " Emitidos:       Pagos:       Cancelados:"
RETU

PROC CIR_gets     // mostra variaveis do arquivo CIRCULAR
LOCAL getlist := {}
CIR_TELA()
SETCOLOR(drvcortel+","+drvcorget+",,,"+corcampo)
PTAB(GRUPO,'ARQGRUP',1)
PTAB(ARQGRUP->CLASSE,'CLASSES',1)
@ l_s+01 ,c_s+08 GET  grupo;
                 PICT sistema[op_sis,O_CAMPO,01,O_MASC]

@ l_s+01 ,c_s+21 GET  circ;
                 PICT sistema[op_sis,O_CAMPO,02,O_MASC]

@ l_s+05 ,c_s+29 GET  procpend;
                 PICT sistema[op_sis,O_CAMPO,03,O_MASC]

@ l_s+02 ,c_s+15 GET  emissao_;
                 PICT sistema[op_sis,O_CAMPO,04,O_MASC]

@ l_s+02 ,c_s+39 GET  mesref;
                 PICT sistema[op_sis,O_CAMPO,05,O_MASC]

@ l_s+03 ,c_s+21 GET  valor;
                 PICT sistema[op_sis,O_CAMPO,06,O_MASC]
                 CRIT(sistema[op_sis,O_CAMPO,06,O_CRIT],,"1")

@ l_s+06 ,c_s+15 GET  menscirc;
                 PICT sistema[op_sis,O_CAMPO,07,O_MASC]

@ l_s+07 ,c_s+15 GET  menscirc1

@ l_s+08 ,c_s+15 GET  menscirc2

@ l_s+04 ,c_s+15 GET  lancto_;
                 PICT sistema[op_sis,O_CAMPO,13,O_MASC]

@ l_s+04 ,c_s+35 GET  funcionar

@ l_s+05 ,c_s+15 GET  impress_;
                 PICT sistema[op_sis,O_CAMPO,15,O_MASC]

CLEAR GETS
RETU

PROC CIR_get1(tp_mov)     // capta variaveis do arquivo CIRCULAR
LOCAL getlist := {}
PRIV  blk_circular:=.t.

IF tp_mov=INCLUI
 DO WHILE .t.
  rola_t=.f.
  SET KEY K_ALT_F8 TO ROLATELA
  SETCOLOR(drvcortel+","+drvcorget+",,,"+corcampo)
  @ l_s+05 ,c_s+29 GET procpend;
                   PICT sistema[op_sis,O_CAMPO,03,O_MASC]
  @ l_s+04 ,c_s+15 GET lancto_;
                   PICT sistema[op_sis,O_CAMPO,13,O_MASC]
  @ l_s+04 ,c_s+35 GET funcionar
  @ l_s+05 ,c_s+15 GET impress_;
                   PICT sistema[op_sis,O_CAMPO,15,O_MASC]
  CLEA GETS
  @ l_s+02 ,c_s+15 GET  emissao_;
                   PICT sistema[op_sis,O_CAMPO,04,O_MASC]
                   DEFINICAO 4

  @ l_s+02 ,c_s+39 GET  mesref;
                   PICT sistema[op_sis,O_CAMPO,05,O_MASC]
                   DEFINICAO 5

  @ l_s+03 ,c_s+21 GET  valor;
                   PICT sistema[op_sis,O_CAMPO,06,O_MASC]
                   DEFINICAO 6
                   MOSTRA sistema[op_sis,O_FORMULA,1]

  @ l_s+06 ,c_s+15 GET  menscirc;
                   PICT sistema[op_sis,O_CAMPO,07,O_MASC]
                   DEFINICAO 7

  @ l_s+07 ,c_s+15 GET  menscirc1
                   DEFINICAO 8

  @ l_s+08 ,c_s+15 GET  menscirc2
                   DEFINICAO 9

  READ
  SET KEY K_ALT_F8 TO
  IF rola_t
   ROLATELA()
   LOOP
  ENDI
  IF LASTKEY()!=K_ESC .AND. drvincl .AND. op_menu=INCLUSAO
   IF !CONFINCL()
    LOOP
   ENDI
  ENDI
  EXIT
 ENDD
ENDI
PTAB(GRUPO,'ARQGRUP',1)
PTAB(ARQGRUP->CLASSE,'CLASSES',1)
IF tp_mov=EXCLUI .OR. tp_mov=FORM_INVERSA
 INTREF(FORM_INVERSA)
 IF !EMPTY(ALIAS())
  DELE
 ENDI
ELSEIF tp_mov=INCLUI .OR. tp_mov=RECUPERA .OR. tp_mov=FORM_DIRETA
 IF (op_menu=INCLUSAO .AND. LASTKEY()!=K_ESC) .OR. op_menu!=INCLUSAO
  IF op_menu!=INCLUSAO
   RECA
   INTREF(FORM_DIRETA)
  ENDI
 ENDI
ENDI
RETU

PROC CPR_incl(reg_cop)  // inclusao no arquivo CPRCIRC
LOCAL getlist:={}, cabem:=1, rep:=ARRAY(FCOU()), ult_reg:=RECN(),;
      ctl_r, ctl_c, t_f3_, t_f4_, l_max, dele_atu:=SET(_SET_DELETED,.f.)
PRIV op_menu:=INCLUSAO, op_sis, l_s, c_s, l_i, c_i, cod_sos, tem_borda, criterio:="", cpord:="", l_a
op_sis=EVAL(qualsis,"CPRCIRC")
IF AT("D",exrot[op_sis])>0
 RETU
ENDI
FOR i=1 TO FCOU()                                  // cria/declara privadas as
 msg=FIEL(i)                                       // variaveis de memoria com
 PRIV &msg.                                        // o mesmo nome dos campos
NEXT                                               // do arquivo
IF reg_cop!=NIL                                    // quer repetir todo o reg atual
 FOR i=1 TO FCOU()                                 // para cada campo,
  msg=FIEL(i)                                      // salva o conteudo
  rep[i]=&msg.                                     // para repetir
 NEXT
ELSE
 AFILL(rep,"")                                     // eche com valor vazio
ENDI
t_f3_=SETKEY(K_F3,{||rep()})                       // repeticao reg anterior
t_f4_=SETKEY(K_F4,{||conf()})                      // confirma campos com ENTER
ctl_w=SETKEY(K_CTRL_W,{||nadafaz()})               // enganando o CA-Clipper...
ctl_c=SETKEY(K_CTRL_C,{||nadafaz()})
ctl_r=SETKEY(K_CTRL_R,{||nadafaz()})
DISPBEGIN()                                        // monta tela na pagina de traz
IMPRELA()                                          // imp telas do pai
CPR_TELA()                                         // imp tela para inclusao
INFOSIS(.t.)                                       // exibe informacao no rodape' da tela
l_a=Sistema[op_sis,O_TELA,O_SCROLL]
DISPEND()                                          // apresenta tela de uma vez so
DO WHIL cabem>0
 cod_sos=6
 rola_t=.f.                                        // flag se quer rolar a tela
 SELE CPRCIRC
 GO BOTT                                           // forca o
 SKIP                                              // final do arquivo
 
 /*
    cria variaveis de memoria identicas as de arquivo, para inclusao
    de registros
 */
 FOR i=1 TO FCOU()
  msg=FIEL(i)
  M->&msg.=IF((fgrep .OR. reg_cop!=NIL).AND.!EMPT(rep[1]),rep[i],&msg.)
 NEXT
 
 /*
    inicializa campos de relacionamentos do com os campos do arquivo
    superior (pai)
 */
 FOR i=1 TO LEN(sistema[op_sis,O_CPRELA])
  msg=FIEL(VAL(SUBS(sistema[op_sis,O_ORDEM,1],i*2-1,2)))
  M->&msg.=&(sistema[op_sis,O_CPRELA,i])
 NEXT
 cabem=DISKSPACE(;
          IF(;
             LEN(sistema[op_sis,O_ARQUI,O_DIR_DBF])<2.OR.sistema[op_sis,O_ARQUI,O_DIR_DBF]="\",;
             0,;
             ASC(sistema[op_sis,O_ARQUI,O_DIR_DBF])-64;
          );
       )
 cabem=INT((cabem-2048)/CPRCIRC->(RECSIZE()))
 IF cabem<1                                        // mais nenhum!!!
  ALERTA()
  msg="Verifique ESPA€O EM DISCO, "+usuario
  DBOX(msg,,,,,"INCLUSŽO INTERROMPIDA!")           // vamos parar por aqui!
  EXIT
 ENDI
 SELE 0                                            // torna visiveis variaveis de memoria
 SETCOLOR(drvcortel+","+drvcorget+",,,"+corcampo)
 SET KEY K_ALT_F8 TO ROLATELA
 
 /*
    recebe chaves do arquivo de indice basico
 */
 @ l_s+l_a,c_s+01 GET  processo;
                  PICT sistema[op_sis,O_CAMPO,03,O_MASC]
                  DEFINICAO 3

 READ
 SET KEY K_ALT_F8 TO
 IF rola_t
  ROLATELA()
  LOOP
 ENDI
 SELE CPRCIRC
 IF LASTKEY()=K_ESC                                // cancelou ou chave em branco
  cabem=0                                          // prepara saida da inclusao
  LOOP                                             // volta p/ menu de cadastramento
 ENDI
 SEEK M->grupo+M->circ+M->processo
 aprov_reg_=(FOUND().AND.DELE().AND.!drvvisivel)   // vai aproveitar o registro?
 IF FOUND() .AND. !aprov_reg_                      // pesquisou e achou!
  l_a=Sistema[op_sis,O_TELA,O_SCROLL]
  op_menu=ALTERACAO                                // seta flag de ateracao
  DISPBEGIN()
  CPR_GETS()                                       // mostra conteudo do registro
  INFOSIS(.f.)                                     // exibe informacao no rodape' da tela
  DISPEND()
  ALERTA()
  msg="Consultar/alterar|Retornar … inclus„o"      // pergunta se deseja
  op_=DBOX(msg,,,E_MENU,,"REGISTRO J EXISTE")     // alterar o registro
  IF op_ =1                                        // caso afirmativo
   EDIT()                                          // deixa alterar
  ENDI
  op_menu=INCLUSAO
  DISPBEGIN()
  CPR_TELA()
  INFOSIS(.t.)                                     // exibe informacao no rodape' da tela
  DISPEND()
  LOOP                                             // volta para inclusao
 ENDI
 SELE 0
 CPR_GET1(INCLUI)                                  // recebe campos
 SELE CPRCIRC
 IF LASTKEY()=K_ESC                                // se cancelou
  ALERTA()                                         // avisa que o registro
  DBOX("Registro n„o inclu¡do!",18,,1)             // nao foi incluido, e volta
  LOOP
 ENDI

 #ifdef COM_REDE
  GO BOTT                                          // vamos bloquear o final do
  SKIP                                             // arq para que nehum outro
  BLOREG(0,.5)                                     // usuario possa incluir
  SEEK M->grupo+M->circ+M->processo                // se registro foi incluido
  aprov_reg_=(FOUND().AND.DELE().AND.!drvvisivel)  // vai aproveitar o registro?
  IF FOUND() .AND. !aprov_reg_                     // por outro usuario, entao
   BLOREG(0,.5)
   FOR i=1 TO FCOU()
    msg=FIEL(i)
    rep[i]=&msg.
    REPL &msg. WITH M->&msg.
   NEXT
   CPR_GET1(FORM_INVERSA)                          // executa formula inversa
   RECA
   FOR i=1 TO FCOU()
    msg=FIEL(i)
    REPL &msg. WITH rep[i]
   NEXT
   ALERTA(4)                                       // beep 4 vezes
   msg="Registro acabou de ser|inclu¡do por outro usu rio!"
   DBOX(msg,,,,,"ATEN€ŽO!")                        // avisa
   SELE CPRCIRC
   UNLOCK                                          // libera o registro
   LOOP                                            // e recebe chave novamente
  ENDI
 #endi

 IF aprov_reg_                                     // se vai aproveitar reg excluido

  #ifdef COM_REDE
   BLOREG(0,.5)
  #endi

  RECA                                             // excluido, vamos recupera-lo
 ELSE                                              // caso contrario
  APPEND BLANK                                     // inclui reg em branco no dbf
 ENDI
 FOR i=1 TO FCOU()                                 // para cada campo,
  msg=FIEL(i)                                      // salva o conteudo
  rep[i]=M->&msg.                                  // para repetir
  REPL &msg. WITH rep[i]                           // enche o campo do arquivo
 NEXT

 #ifdef COM_REDE
  UNLOCK                                           // libera o registro e
  COMMIT                                           // forca gravacao
 #else
  IF RECC()-INT(RECC()/20)*20=0                    // a cada 20 registros
   COMMIT                                          // digitados forca gravacao
  ENDI
 #endi

 ult_reg=RECN()                                    // ultimo registro digitado
 l_max=l_s+Sistema[op_sis,O_TELA,O_SCROLL]+Sistema[op_sis,O_TELA,O_QTDE]
 IF l_s+l_a+1<l_max                                // se nao atingiu o fim da tela
  l_a++                                            // digita na proxima linha
 ELSE                                              // se nao rola a campos para cima
  SCROLL(l_s+Sistema[op_sis,O_TELA,O_SCROLL],c_s+01,l_max-1,c_s+11,1)
  SCROLL(l_s+Sistema[op_sis,O_TELA,O_SCROLL],c_s+13,l_max-1,c_s+14,1)
  SCROLL(l_s+Sistema[op_sis,O_TELA,O_SCROLL],c_s+18,l_max-1,c_s+23,1)
  SCROLL(l_s+Sistema[op_sis,O_TELA,O_SCROLL],c_s+27,l_max-1,c_s+61,1)
  SCROLL(l_s+Sistema[op_sis,O_TELA,O_SCROLL],c_s+63,l_max-1,c_s+72,1)
 ENDI
 IF reg_cop!=NIL                                   // estava na consulta e quis rep o campo
  EXIT                                             // cai fora...
 ENDI
ENDD
GO ult_reg                                         // para o ultimo reg digitado
SETKEY(K_F3,t_f3_)                                 // restaura teclas de funcoes
SETKEY(K_F4,t_f4_)
SET(_SET_DELETED,dele_atu)                            // ecluidos visiveis/invisiveis
SETKEY(K_CTRL_W,ctl_w)
SETKEY(K_CTRL_C,ctl_c)
SETKEY(K_CTRL_R,ctl_r)
RETU


PROC CPR_tela     // tela do arquivo CPRCIRC
tem_borda=.t.
l_s=Sistema[op_sis,O_TELA,O_LS]           // coordenadas da tela
c_s=Sistema[op_sis,O_TELA,O_CS]
l_i=Sistema[op_sis,O_TELA,O_LI]
c_i=Sistema[op_sis,O_TELA,O_CI]
SETCOLOR(drvtittel)
vr_memo=NOVAPOSI(@l_s,@c_s,@l_i,@c_i)     // pega posicao atual da tela
CAIXA(mold,l_s,c_s,l_i,c_i)               // monta caixa da tela
i=LEN(sistema[op_sis,O_MENS])/2
@ l_s,c_s-1+(c_i-c_s+1)/2-i SAY " "+MAIUSC(sistema[op_sis,O_MENS])+" "
SETCOLOR(drvcortel)
@ l_s+01,c_s+1 SAY " Processo      ³ Num.   ³ Falecido                            Data"
@ l_s+02,c_s+1 SAY "ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ"
@ l_s+03,c_s+1 SAY "               ³        ³"
@ l_s+04,c_s+1 SAY "               ³        ³"
@ l_s+05,c_s+1 SAY "               ³        ³"
@ l_s+06,c_s+1 SAY "               ³        ³"
RETU

PROC CPR_gets     // mostra variaveis do arquivo CPRCIRC
LOCAL getlist := {}, l_max, reg_atual:=RECNO()
PRIV  l_a:=Sistema[op_sis,O_TELA,O_SCROLL]
CPR_TELA()
l_max=l_s+Sistema[op_sis,O_TELA,O_SCROLL]+Sistema[op_sis,O_TELA,O_QTDE]
SETCOLOR(drvcortel+","+drvcorget+",,,"+corcampo)
DO WHILE !EOF() .AND. l_s+l_a<l_max .AND.;
   &(INDEXKEY(0))=IF(EMPT(criterio),"","T")+chv_1
 @ l_s+l_a,c_s+01 GET  processo;
                  PICT sistema[op_sis,O_CAMPO,03,O_MASC]

 @ l_s+l_a,c_s+13 GET  categ;
                  PICT sistema[op_sis,O_CAMPO,04,O_MASC]

 @ l_s+l_a,c_s+18 GET  num;
                  PICT sistema[op_sis,O_CAMPO,05,O_MASC]

 @ l_s+l_a,c_s+27 GET  fal;
                  PICT sistema[op_sis,O_CAMPO,06,O_MASC]

 @ l_s+l_a,c_s+63 GET  dfal;
                  PICT sistema[op_sis,O_CAMPO,09,O_MASC]

 SETCOLOR(drvcortel+","+drvcortel+",,,"+drvcortel)
 l_a++
 SKIP
ENDD
GO reg_atual
SETCOLOR(drvcortel+","+drvcorget+",,,"+corcampo)
CLEAR GETS
RETU

PROC CPR_get1(tp_mov, excl_rela)     // capta variaveis do arquivo CPRCIRC
LOCAL getlist := {}
PRIV  blk_cprcirc:=.t.
excl_rela=IF(excl_rela=NIL,.f.,excl_rela)
IF tp_mov=INCLUI
 IF TYPE("l_a")!="N"
  l_a=Sistema[op_sis,O_TELA,O_SCROLL]
 ENDI
 DO WHILE .t.
  rola_t=.f.
  SET KEY K_ALT_F8 TO ROLATELA
  SETCOLOR(drvcortel+","+drvcorget+",,,"+corcampo)
  @ l_s+l_a,c_s+13 GET  categ;
                   PICT sistema[op_sis,O_CAMPO,04,O_MASC]
                   DEFINICAO 4

  @ l_s+l_a,c_s+18 GET  num;
                   PICT sistema[op_sis,O_CAMPO,05,O_MASC]
                   DEFINICAO 5

  @ l_s+l_a,c_s+27 GET  fal;
                   PICT sistema[op_sis,O_CAMPO,06,O_MASC]
                   DEFINICAO 6

  @ l_s+l_a,c_s+63 GET  dfal;
                   PICT sistema[op_sis,O_CAMPO,09,O_MASC]
                   DEFINICAO 9

  READ
  SET KEY K_ALT_F8 TO
  IF rola_t
   ROLATELA()
   LOOP
  ENDI
  IF LASTKEY()!=K_ESC .AND. drvincl .AND. op_menu=INCLUSAO
   IF !CONFINCL()
    LOOP
   ENDI
  ENDI
  EXIT
 ENDD
ENDI
PTAB(NUM,'GRUPOS',1)
IF tp_mov=EXCLUI .OR. tp_mov=FORM_INVERSA

 #ifdef COM_REDE
  REPBLO('CIRCULAR->procpend',{||CIRCULAR->procpend - 1})
  IF !excl_rela
   IF !EMPTY(ALIAS())
    REPL flag_excl WITH '*'
   ENDI
  ENDI
 #else
  REPL CIRCULAR->procpend WITH CIRCULAR->procpend - 1
  IF !excl_rela
   IF !EMPTY(ALIAS())
    REPL flag_excl WITH '*'
   ENDI
  ENDI
 #endi

 IF !EMPTY(ALIAS())
  DELE
 ENDI
ELSEIF tp_mov=INCLUI .OR. tp_mov=RECUPERA .OR. tp_mov=FORM_DIRETA
 IF (op_menu=INCLUSAO .AND. LASTKEY()!=K_ESC) .OR. op_menu!=INCLUSAO
  IF tp_mov=RECUPERA .AND. op_menu!=INCLUSAO .AND. (CIRCULAR->(DELE()))
   msg="|"+sistema[EVAL(qualsis,"CIRCULAR"),O_MENU]
   ALERTA(2)
   DBOX("Registro exclu¡do em:"+msg+"|*",,,,,"IMPOSS¡VEL RECUPERAR!")
  ELSE

   #ifdef COM_REDE
    REPBLO('CIRCULAR->procpend',{||CIRCULAR->procpend + 1})
    IF !excl_rela
     IF op_menu=INCLUSAO
      flag_excl=' '
     ELSE
      REPL flag_excl WITH ' '
     ENDI
    ENDI
   #else
    REPL CIRCULAR->procpend WITH CIRCULAR->procpend + 1
    IF !excl_rela
     IF op_menu=INCLUSAO
      flag_excl=' '
     ELSE
      REPL flag_excl WITH ' '
     ENDI
    ENDI
   #endi

   IF op_menu!=INCLUSAO
    RECA
   ENDI
  ENDI
 ENDI
ENDI
RETU

* \\ Final de CIRCULAR.PRG
GAS-Pro v4.0
007016014067001006021001013001176001
 Emiss„o....:           Horas:
 Hist¢rico..:
 Contrato...:
 Complemento:
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 Qtde:       Valor:            Tipo:    Circ:
[Ÿ]
Inclus„o~~26006
Manuten‡„o~~27007
Consulta~~28008
[Ÿ]
 10 
 4 
Ocorrencia

 1 
[Ÿ]
Hist¢rico

 4 
 5 
[Ÿ]
Contrato

 5 
 10 
[Ÿ]
N§Cobran‡a

 10 
 5 
[Ÿ]
Custos Adicionais
Custos Adicionais







005
























 0 











 0 
 1 
-1 
-1 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
emissao_
D
E
@D
 8 
 10 
 1 
 15 
 0 
Emiss„o

!EMPT(emissao_)
Necess rio informar DATA DE EMISSAO v lida
date()
Informe a data da gera‡„o desta cobran‡a
DATE()
 0 
 0 


hora
C
E
99:99
 5 
 5 
 1 
 32 
 0 
Hora

!EMPT(hora)
Necess rio informar HORA
TIME()
Informe a hora|Se necess rio

 0 
 0 


quem
C
V
 
 10 
 10 
 1 
 40 
 0 
Quem



M->usuario


 0 
 0 


historic
C
E
999
 3 
 3 
 2 
 15 
 0 
Hist¢rico

PTAB(historic,'HISTORIC',1)
Este ‚ um campo de preenchimento obrigat¢rio.|Tecle F8 para busca em tabela

Entre com um c¢digo para identificar| a cobran‡a

 0 
 0 


contrato
C
E
999999
 6 
 6 
 3 
 15 
 0 
Contrato

PTAB(contrato,'GRUPOS',1)
Contrato inv lido |ou inexistente

Informe o n£mero do contrato
VDBF(6,26,20,77,'GRUPOS',{'grupo','codigo','nome'},1,'codigo')
 0 
 0 


complement
C
E
@!
 35 
 35 
 4 
 15 
 0 
Complemento

!EMPT(complement)
Entre com uma informa‡„o que diferencie este|lan‡amento de outros com mesmo hist¢rico.

Informe algo para identificar esta cobran‡a

 0 
 0 


qtdade
N
E
99999
 5 
 5 
 6 
 8 
 0 
Qtdade

!(qtdade<0)
Informe uma quantidade v lida (>=0)



 0 
 0 


valor
N
E
999999.99
 9 
 9 
 6 
 21 
 2 
Valor

!(valor=0)
VALOR n„o aceit vel|Deve ser diferente de zeros

Informe o valor do servi‡o

 0 
 0 


tipo
C
E
9
 1 
 1 
 6 
 38 
 0 
Tipo

 


Qual o tipo de lan‡amento
MTAB([1=J¢ia|2=Taxa|3=Carnˆ],[TIPO])
 0 
 0 


circ
C
E
999
 3 
 3 
 6 
 47 
 0 
Circ

(PTAB(contrato+tipo+circ,'TAXAS',1).AND.TAXAS->valorpg=0).or.circ<[001]
Taxa n„o cadastrada,|ou,| j  paga.

Informe o n£mero da circular a consultar

 0 
 0 


 0 
 1 
CSTSEG
quem
M->usuario




 0 
 0 
 0 
/*
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
 \ Empresa.: Ind£stria de Urnas Bignotto Ltda
 \ Programa: CON_R001.PRG
 \ Data....: 26-02-98
 \ Sistema.: Controle de Convˆnios
 \ Funcao..: Emiss„o Guias Modelo 1
 \ Analista: Ademilson Pedro Bom
 \ Criacao.: GAS-Pro v3.0 
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/

#include "adrbig.ch"    // inicializa constantes manifestas

LOCAL dele_atu, getlist:={}, so_um_reg, sit_dbf
PARA  lin_menu, col_menu, imp_reg
PRIV  tem_borda:=.t., op_menu:=VAR_COMPL, l_s:=11, c_s:=20, l_i:=14, c_i:=61, tela_fundo:=SAVESCREEN(0,0,MAXROW(),79)
nucop=1
so_um_reg=(PCOU()>2)
IF !so_um_reg                             // vai receber a variaveis?
 SETCOLOR(drvtittel)
 vr_memo=NOVAPOSI(@l_s,@c_s,@l_i,@c_i)    // pega posicao atual da tela
 CAIXA(mold,l_s,c_s,l_i,c_i)              // monta caixa da tela
 @ l_s,c_s+12 SAY " EMISSŽO DE GUIAS "
 SETCOLOR(drvcortel)
 @ l_s+01,c_s+1 SAY " N£mero:"
ENDI
gnumero=SPAC(7)                                    // N£mero
DO WHILE .t.
 rola_t=.f.
 cod_sos=56
 IF !so_um_reg
  SET KEY K_ALT_F8 TO ROLATELA
  SETCOLOR(drvcortel+","+drvcorget+",,,"+corcampo)
  @ l_s+01 ,c_s+10 GET  gnumero;
                   PICT "@R 99-99999";
                   VALI CRIT("PTAB(gnumero,'GUIAS',1).AND.V00101F9()~N£MERO n„o existe na tabela")
									 AJUDA "Emitir a guia de n£mero?"
									 CMDF8 "VDBF(6,8,20,77,'GUIAS',{'numero','nome'},1,'RETNGUI()')"
                   MOSTRA {"LEFT(TRAN(GUIAS->nome,[@!]),35)", 2 , 5 }

  READ
  SET KEY K_ALT_F8 TO
  IF rola_t
   ROLATELA(.f.)
   LOOP
  ENDI
  IF LASTKEY()=K_ESC                               // se quer cancelar
   RETU                                            // retorna
  ENDI
 ENDI

 #ifdef COM_REDE
  IF !USEARQ("GUIAS",.f.,10,1)                     // se falhou a abertura do arq
   RETU                                            // volta ao menu anterior
  ENDI
 #else
  USEARQ("GUIAS")                                  // abre o dbf e seus indices
 #endi

 PTAB(medico,"MEDICOS",1,.t.)                      // abre arquivo p/ o relacionamento
 SET RELA TO medico INTO MEDICOS                 // relacionamento dos arquivos
 titrel:=criterio:=cpord := ""                     // inicializa variaveis
 titrel:=chv_rela:=chv_1:=chv_2 := ""
 tps:=op_x:=ccop := 1
 arq_=drvporta                                     // porta de saida configurada
 IF !so_um_reg
  IF !opcoes_rel(lin_menu,col_menu,5,11)           // nao quis configurar...
   CLOS ALL                                        // fecha arquivos e
   LOOP                                            // volta ao menu
  ENDI

 #ifdef COM_REDE

  ELSE

   tps=lin_menu

 #endi

 ENDI
 IF tps=2                                          // se vai para arquivo/video
  arq_=ARQGER()                                    // entao pega nome do arquivo
  IF EMPTY(arq_)                                   // se cancelou ou nao informou
   LOOP                                            // retorna
  ENDI
 ELSE
  arq_=drvporta                                    // porta de saida configurada
 ENDI
 SET PRINTER TO (arq_)                             // redireciona saida
 EXIT
ENDD
IF !EMPTY(drvtapg)                                 // existe configuracao de tam pag?
 op_=AT("NNN",drvtapg)                             // se o codigo que altera
 IF op_=0                                          // o tamanho da pagina
  msg="Configura‡„o do tamanho da p gina!"         // foi informado errado
  DBOX(msg,,,,,"ERRO!")                            // avisa
  CLOSE ALL                                        // fecha todos arquivos abertos
  RETU                                             // e cai fora...
 ENDI                                              // codigo para setar/resetar tam pag
 lpp_024=LEFT(drvtapg,op_-1)+"024"+SUBS(drvtapg,op_+3)
 lpp_066=LEFT(drvtapg,op_-1)+"066"+SUBS(drvtapg,op_+3)
ELSE
 lpp_024:=lpp_066 :=""                             // nao ira mudara o tamanho da pag
ENDI
DBOX("[ESC] Interrompe",15,,,NAO_APAGA)
dele_atu:=SET(_SET_DELETED,.t.)                    // os excluidos nao servem...
SET DEVI TO PRIN                                   // inicia a impressao
maxli=22                                           // maximo de linhas no relatorio
IMPCTL(lpp_024)                                    // seta pagina com 24 linhas
SET MARG TO                                       // ajusta a margem esquerda
IF tps=2
 IMPCTL("' '+CHR(8)")
ENDI
BEGIN SEQUENCE
 DO WHIL ccop<=nucop                               // imprime qde copias pedida
	pg_=1; cl=999
	IF so_um_reg
   GO imp_reg
  ELSE
   INI_ARQ()                                       // acha 1o. reg valido do arquivo
  ENDI
  ccop++                                           // incrementa contador de copias
  DO WHIL !EOF().AND.(!so_um_reg.OR.imp_reg=RECN())
   #ifdef COM_TUTOR
    IF IN_KEY()=K_ESC                              // se quer cancelar
	 #else
    IF INKEY()=K_ESC                               // se quer cancelar
   #endi
    IF canc()                                      // pede confirmacao
     BREAK                                         // confirmou...
    ENDI
   ENDI
   IF (PTAB(PADR(SUBSTR(M->ide_maq,2),4)+[GUI],[IMPPAR],1).and.LEFT(IMPPAR->docto,7)=ano+numero) .OR. so_um_reg// se atender a condicao...
    IMPCTL(drvtcom)
		REL_CAB(1)                                     // soma cl/imprime cabecalho
//    @ cl,066 SAY TRAN(ano,"99")                    // Ano
//    @ cl,068 SAY "-"
		@ cl,064 SAY TRAN(numero,"99999")              // N£mero
		REL_CAB(3)                                     // soma cl/imprime cabecalho
		IMPCTL(drvpenf)
		@ cl,004 SAY MEDICOS->nome                     // Nome M‚dico
		IMPCTL(drvtenf)
		@ cl,062 SAY TRAN(medico,"@!")                 // M‚dico Codigo
		REL_CAB(3)                                     // soma cl/imprime cabecalho
		@ cl,004 SAY ALLTRIM(MEDICOS->endereco) // Endere‡o
		REL_CAB(1)                                     // soma cl/imprime cabecalho
		@ cl,004 SAY TRAN(MEDICOS->cidade,"@!")+[ Tel.:]+MEDICOS->telefone				// Cidade
		REL_CAB(3)                                     // soma cl/imprime cabecalho
		IF MEDICOS->valorpart > 0
		 @ cl,006 SAY TRAN(MEDICOS->valorpart,"@E 99,999,999.99")// Valor Particular
		ENDI
		IF MEDICOS->ultvalor > 0
		 IF MEDICOS->VALORPART > 0
			@ cl,026 SAY TRAN(100-(MEDICOS->ultvalor/MEDICOS->valorpart*100),"99")      // Porcent1
			@ cl,031 SAY TRAN(MEDICOS->valorpart-MEDICOS->ultvalor,"@E 99,999,999.99")// Valor Particular
		 ENDI
		 @ cl,054 SAY TRAN(MEDICOS->ultvalor,"@E 99,999,999.99")// Ult.valor
		ENDI
		REL_CAB(1)                                     // soma cl/imprime cabecalho
		@ cl,004 SAY MEDICOS->mensagem
		REL_CAB(2)                                     // soma cl/imprime cabecalho
		@ cl,004 SAY TRAN(titular,"@!")                // Titular
		@ cl,062 SAY TRAN(contrato,"999999")           // N§ Contrato
		REL_CAB(3)                                     // soma cl/imprime cabecalho
		@ cl,004 SAY TRAN(nome,"@!")                   // Nome
		@ cl,051 SAY TRAN(emissao_,"@D")               // Emiss„o
		@ cl,062 SAY TRAN(emissao_+31-DAY(emissao_+31)+DAY(emissao_),"@D")               // Emiss„o
		SKIP                                           // pega proximo registro
		cl=999                                         // forca salto de pagina
	 ELSE                                            // se nao atende condicao
		SKIP                                           // pega proximo registro
	 ENDI
	ENDD
 ENDD ccop
 EJEC                                              // salta pagina
END SEQUENCE
SET MARG TO                                        // coloca margem esquerda = 0
IMPCTL(lpp_066)                                    // seta pagina com 66 linhas
SET PRINTER TO (drvporta)                          // fecha arquivo gerado (se houver)
SET DEVI TO SCRE                                   // direciona saida p/ video
IF tps=2                                           // se vai para arquivo/video
 BROWSE_REL(arq_,2,3,MAXROW()-2,78)
ENDI                                               // mostra o arquivo gravado
GRELA(5)                                           // grava variacao do relatorio
SELE GUIAS                                         // salta pagina
SET RELA TO                                        // retira os relacionamentos
SET(_SET_DELETED,dele_atu)                         // os excluidos serao vistos
IF so_um_reg
 POINTER_DBF(sit_dbf)
ENDI
RETU

STATIC PROC REL_CAB(qt)                            // cabecalho do relatorio
IF qt>0                                            // se parametro maior que 0
 cl=cl+qt                                          // soma no contador de linhas
ENDI
IF cl>maxli .OR. qt=0                              // quebra de pagina
 cl=qt+2 ; pg_++
ENDI
RETU

* \\ Final de CON_R001.PRG

FUNC RETNGUI()
RETU GUIAS->ANO+GUIAS->NUMERO/*
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
 \ Empresa.: PresServ Inform tica-Limeira (019)452.6623
 \ Programa: ADR_R029.PRG
 \ Data....: 22-09-97
 \ Sistema.: Administradora - RECEP€„O
 \ Funcao..: Recibo Aux.Funeral 1
 \ Analista: Ademilson Pedro Bom
 \ Criacao.: GAS-Pro v3.0 
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/

#include "adrbig.ch"    // inicializa constantes manifestas

LOCAL dele_atu, getlist:={}, so_um_reg, sit_dbf:=POINTER_DBF()
PARA  lin_menu, col_menu, imp_reg
PRIV  tem_borda:=.t., op_menu:=VAR_COMPL, l_s:=10, c_s:=20, l_i:=13, c_i:=61, tela_fundo:=SAVESCREEN(0,0,MAXROW(),79)
nucop=1
so_um_reg=(PCOU()>2)
IF !so_um_reg                             // vai receber a variaveis?
 SETCOLOR(drvtittel)
 vr_memo=NOVAPOSI(@l_s,@c_s,@l_i,@c_i)    // pega posicao atual da tela
 CAIXA(mold,l_s,c_s,l_i,c_i)              // monta caixa da tela
 @ l_s,c_s+10 SAY " RECIBO AUX.FUNERAL 1 "
 SETCOLOR(drvcortel)
 @ l_s+01,c_s+1 SAY " Processo:"
 @ l_s+02,c_s+1 SAY " Confirme:"
ENDI
rproc=SPAC(11)                                     // Processo
confirme=SPAC(1)                                   // Confirme
DO WHILE .t.
 rola_t=.f.
 cod_sos=56
 IF !so_um_reg
  SET KEY K_ALT_F8 TO ROLATELA
  SETCOLOR(drvcortel+","+drvcorget+",,,"+corcampo)
  @ l_s+01 ,c_s+12 GET  rproc;
                   PICT "@R 99999/9999-99";
                   VALI CRIT("!EMPT(RPROC).AND.PTAB(rproc,[AFUNER],1)~Campo utilizado para localiza‡„o dos documentos.|Tecle F8 para busca em tabela")
                   DEFAULT "IIF(PTAB(PADR(SUBSTR(M->ide_maq,2),4)+[AFU],[IMPPAR],1),ALLTRIM(IMPPAR->docto),[])"
                   AJUDA "Digite neste campo o n£mero de|identifica‡„o do processo"
                   CMDF8 "VDBF(6,12,20,77,'AFUNER',{'processo','proc2','categ','contrato','falecido'},1,'V02001F9()',[])"

  @ l_s+02 ,c_s+12 GET  confirme;
                   PICT "!";
                   VALI CRIT("confirme='S'.AND.V02002F9()~CONFIRME n„o aceit vel|Digite S para confirmar|ou|Tecle ESC para cancelar")
                   AJUDA "Digite S para confirmar|ou|tecle ESC para cancelar"

  READ
  SET KEY K_ALT_F8 TO
  IF rola_t
   ROLATELA(.f.)
   LOOP
  ENDI
  IF LASTKEY()=K_ESC                               // se quer cancelar
   RETU                                            // retorna
  ENDI
 ENDI

 #ifdef COM_REDE
  IF !USEARQ("AFUNER",.f.,10,1)                    // se falhou a abertura do arq
   RETU                                            // volta ao menu anterior
  ENDI
 #else
  USEARQ("AFUNER")                                 // abre o dbf e seus indices
 #endi

 PTAB(contrato,"GRUPOS",1,.t.)                     // abre arquivo p/ o relacionamento
 PTAB(contrato,"INSCRITS",1,.t.)
 SET RELA TO contrato INTO GRUPOS,;                // relacionamento dos arquivos
          TO contrato INTO INSCRITS
 titrel:=criterio:=cpord := ""                     // inicializa variaveis
 titrel:=chv_rela:=chv_1:=chv_2 := ""
 tps:=op_x:=ccop := 1
 arq_=drvporta                                     // porta de saida configurada
 IF !so_um_reg
  IF !opcoes_rel(lin_menu,col_menu,2,11)           // nao quis configurar...
   CLOS ALL                                        // fecha arquivos e
   LOOP                                            // volta ao menu
  ENDI

 #ifdef COM_REDE

  ELSE

   tps=lin_menu

 #endi

 ENDI
 IF tps=2                                          // se vai para arquivo/video
  arq_=ARQGER()                                    // entao pega nome do arquivo
  IF EMPTY(arq_)                                   // se cancelou ou nao informou
   LOOP                                            // retorna
  ENDI
 ELSE
  arq_=drvporta                                    // porta de saida configurada
 ENDI
 IF "4WIN"$UPPER(drvmarca) // nome da configuracao/marca impressora
    arq_:=drvdbf+"WIN"+ide_maq
    tps:=3                                          // se vai para arquivo/video
 ENDIF
 SET PRINTER TO (arq_)                             // redireciona saida
 EXIT
ENDD
IF !EMPTY(drvtapg)                                 // existe configuracao de tam pag?
 op_=AT("NNN",drvtapg)                             // se o codigo que altera
 IF op_=0                                          // o tamanho da pagina
  msg="Configura‡„o do tamanho da p gina!"         // foi informado errado
  DBOX(msg,,,,,"ERRO!")                            // avisa
  CLOSE ALL                                        // fecha todos arquivos abertos
  RETU                                             // e cai fora...
 ENDI                                              // codigo para setar/resetar tam pag
 lpp_033=LEFT(drvtapg,op_-1)+"036"+SUBS(drvtapg,op_+3)
 lpp_066=LEFT(drvtapg,op_-1)+"066"+SUBS(drvtapg,op_+3)
ELSE
 lpp_033:=lpp_066 :=""                             // nao ira mudara o tamanho da pag
ENDI
DBOX("[ESC] Interrompe",15,,,NAO_APAGA)
dele_atu:=SET(_SET_DELETED,.t.)                    // os excluidos nao servem...
SET DEVI TO PRIN                                   // inicia a impressao
maxli=36                                           // maximo de linhas no relatorio
IMPCTL(lpp_033)                                    // seta pagina com 33 linhas
SET MARG TO 1                                      // ajusta a margem esquerda
IF tps=2
 IMPCTL("' '+CHR(8)")
ENDI
BEGIN SEQUENCE
 DO WHIL ccop<=nucop                               // imprime qde copias pedida
  pg_=1; cl=999
  IF so_um_reg
   GO imp_reg
  ELSE
   INI_ARQ()                                       // acha 1o. reg valido do arquivo
   IF PTAB(PADR(SUBSTR(M->ide_maq,2),4)+[AFU],[IMPPAR],1)
    PTAB(LEFT(IMPPAR->docto,11),'AFUNER',1)
   ENDI
  ENDI
  ccop++                                           // incrementa contador de copias
  DO WHIL !EOF().AND.(!so_um_reg.OR.imp_reg=RECN())
   #ifdef COM_TUTOR
    IF IN_KEY()=K_ESC                              // se quer cancelar
   #else
    IF INKEY()=K_ESC                               // se quer cancelar
   #endi
    IF canc()                                      // pede confirmacao
     BREAK                                         // confirmou...
    ENDI
   ENDI
   IF (PTAB(PADR(SUBSTR(M->ide_maq,2),4)+[AFU],[IMPPAR],1).and.processo+proc2+filial+categ=ALLTRIM(IMPPAR->docto)) .OR. so_um_reg// se atender a condicao...
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,054 SAY "Processo"
    IMPCTL(drvpenf)
    @ cl,063 SAY TRAN(processo+proc2+filial,"@R 99999/99/!!")// Nr.Processo
    IMPCTL(drvtenf)
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,003 SAY "Nome do Contratante:"
    IMPCTL(drvpenf)
    @ cl,024 SAY TRAN(IIF(PTAB(contrato+GRUPOS->titular,'INSCRITS',1),INSCRITS->nome,GRUPOS->nome),"@!")// Nome do contratante
    IMPCTL(drvtenf)
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    IMPAC("Endere‡o:",cl,003)
    IMPCTL(drvpenf)
    @ cl,013 SAY TRAN(GRUPOS->endereco,"@!")       // Endereco contratante
    IMPCTL(drvtenf)
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,005 SAY "Cidade               Estado  Documento de Identidade Estado Civil"
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    IMPCTL(drvpenf)
    @ cl,005 SAY TRAN(GRUPOS->cidade,"@!")         // cidade contratante
    IMPCTL(drvtenf)
    @ cl,028 SAY TRAN([  ],"!!")                   // Estado Contratante
    IMPCTL(drvpenf)
    @ cl,037 SAY GRUPOS->rg                        // Doc
    IMPCTL(drvtenf)
    if !EMPT(GRUPOS->estcivil)
     IMPCTL(drvpenf)
     @ cl,059 SAY TRAN(subst(tbestciv,AT(GRUPOS->estcivil,tbestciv),10),"@!")// Est.Civil contratante
     IMPCTL(drvtenf)
    endi
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    IMPAC("Contrato    Grupo            Admiss„o                 Processo",cl,005)
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    IMPCTL(drvpenf)
    @ cl,005 SAY contrato                          // contrato numero
    IMPCTL(drvtenf)
    IMPCTL(drvpenf)
    @ cl,018 SAY GRUPOS->grupo                     // grupo
    IMPCTL(drvtenf)
    IMPCTL(drvpenf)
    @ cl,034 SAY GRUPOS->admissao                  // data admissao
    IMPCTL(drvtenf)
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    IMPMEMO(R02901F9(),70,1,cl,002,.t.)            // pedido (memo)
    qli_m=MLCOUNT(R02901F9(),70)-1                 // quantas linhas a imprimir?
    li_m=0
    DO WHIL .t.                                    // imprime linhas do memo
     li_m++
     IF li_m>qli_m                                 // fim do memo
      EXIT
     ENDI
     REL_CAB(1)                                    // soma cl/imprime cabecalho
     IMPMEMO(R02901F9(),70,1+li_m,cl,002,(li_m<qli_m))      // imprime...
     #ifdef COM_TUTOR
      IF IN_KEY()=K_ESC                            // se quer cancelar
     #else
      IF INKEY()=K_ESC                             // se quer cancelar
     #endi
      IF canc()                                    // pede confirmacao
       BREAK                                       // confirmou...
      ENDI
     ENDI
    ENDD
    REL_CAB(2)                                     // soma cl/imprime cabecalho
    @ cl,004 SAY "Nome do falecido....:"
    IMPCTL(drvpenf)
    @ cl,026 SAY TRAN(falecido,"@!")               // nome do falecido
    IMPCTL(drvtenf)
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    IMPAC("Endere‡o do falecido:",cl,004)
    IMPCTL(drvpenf)
    @ cl,026 SAY TRAN(ALLTRIM(ruares)+[, ]+ALLTRIM(baires),"@!")// Endereco falecido
    IMPCTL(drvtenf)
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,004 SAY "Inscrito neste contrato na qualidade de"
    IMPCTL(drvpenf)
    @ cl,044 SAY grauparcon                        // Inscrito na qualidade de
    IMPCTL(drvtenf)
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,004 SAY "Data do Falecimento.:"
    @ cl,026 SAY TRAN(falecto_,"@D")               // Data falcto.
    IMPAC("Hor rio do Falecimento:",cl,036)
    @ cl,060 SAY TRAN(horafal,"99:99")             // Hora Falcto.
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,004 SAY "Cidade do Falecimento Estado   Local do falecimento"
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    IMPCTL(drvpenf)
    @ cl,004 SAY municfal                          // Cidade Falecimento
    IMPCTL(drvtenf)
    IMPCTL(drvpenf)
    @ cl,028 SAY TRAN(estfal,"!!")                 // UF falecimento
    IMPCTL(drvtenf)
    IMPCTL(drvpenf)
    @ cl,035 SAY ALLTRIM(ruafal)                   // local falecimento
    IMPCTL(drvtenf)
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    IMPAC("Cemit‚rio onde foi sepultado        Hora do sepultamento",cl,004)
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    IMPCTL(drvpenf)
    @ cl,004 SAY cemitsep                          // Cemit‚rio sepultamento
    IMPCTL(drvtenf)
    IMPCTL(drvpenf)
    @ cl,046 SAY TRAN(horasepult,"99:99")          // Hora sepultamento
    IMPCTL(drvtenf)
    REL_CAB(2)                                     // soma cl/imprime cabecalho
    @ cl,002 SAY "Datado em       de                    de           , conforme processo"
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    IMPAC("administrativo n£mero",cl,002)
    @ cl,024 SAY TRAN(processo+proc2+filial,"@R 99999/99/!!")// Processo
    @ cl,035 SAY "."
    REL_CAB(2)                                     // soma cl/imprime cabecalho
    @ cl,001 SAY "PROCESSAR"
    @ cl,025 SAY IMPAC(RTRIM(M->p_cidade)+[, ]+LEFT(DTOC(DATE()),2)+[ de ]+NMES(MONTH(DATE()))+ [ de ]+LEFT(DTOS(DATE()),4))// DATA
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY "PAGAMENTO EM"
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    IMPCTL(drvpenf)
    @ cl,002 SAY TRAN(procpagto_,"@D")             // Proc.pagto em
    IMPCTL(drvtenf)
//    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,021 SAY REPL("-",42)
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,021 SAY "Ass.:"
    IMPCTL(drvpenf)
    @ cl,027 SAY GRUPOS->nome                      // Nome
    IMPCTL(drvtenf)
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,027 SAY "RG:"
    @ cl,031 SAY TRAN(GRUPOS->rg,"@!")             // R.G.
/*
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY REPL("-",74)
*/
    SKIP                                           // pega proximo registro
    cl=999                                         // forca salto de pagina
   ELSE                                            // se nao atende condicao
    SKIP                                           // pega proximo registro
   ENDI
   EJEC
   EXIT
  ENDD
 ENDD ccop
END SEQUENCE
SET MARG TO                                        // coloca margem esquerda = 0
IMPCTL(lpp_066)                                    // seta pagina com 66 linhas
SET PRINTER TO (drvporta)                          // fecha arquivo gerado (se houver)
SET DEVI TO SCRE                                   // direciona saida p/ video
IF tps=2                                           // se vai para arquivo/video
 BROWSE_REL(arq_,2,3,MAXROW()-2,78)
ENDI                                               // mostra o arquivo gravado
GRELA(2)                                           // grava variacao do relatorio
SELE AFUNER                                        // salta pagina
SET RELA TO                                        // retira os relacionamentos
SET(_SET_DELETED,dele_atu)                         // os excluidos serao vistos
IF so_um_reg
 POINTER_DBF(sit_dbf)
ENDI
RETU

STATIC PROC REL_CAB(qt)                            // cabecalho do relatorio
IF qt>0                                            // se parametro maior que 0
 cl=cl+qt                                          // soma no contador de linhas
ENDI
IF cl>maxli .OR. qt=0                              // quebra de pagina
 @ 0,015 SAY REPL("-",60)
 @ 0,001 SAY IIF(categ=[PD],[Plano c/Difer. ],IIF(categ=[PL],[Atend.Plano],[Rest.Desp.Funerais]))// Categoria
 @ 1,002 SAY M->setup1                             // Ident1
    IMPCTL(drvpenf)
    IMPCTL(drvpexp)
 @ 3,028 SAY "RECIBO"
    IMPCTL(drvtenf)
    IMPCTL(drvtexp)
 cl=qt+3 ; pg_++
ENDI
RETU

* \\ Final de ADR_R029.PRG
.PRG.OBJ:
     CLIPPER $** /m
contab1.OBJ  : contab1.PRG
ADR_ESTR.OBJ : ADR_ESTR.PRG
ADR_ATRI.OBJ : ADR_ATRI.PRG
ADR_ATR1.OBJ : ADR_ATR1.PRG
ADR_ATR2.OBJ : ADR_ATR2.PRG
ABOUT.OBJ    : ABOUT.PRG
ADR_Rx68.OBJ : ADR_Rx68.PRG
ADR_PROC.OBJ : ADR_PROC.PRG
ADR_FUNC.OBJ : ADR_FUNC.PRG
ADR_OUTR.OBJ : ADR_OUTR.PRG
contab1.EXE:
     bLINKer @contab1.LNK
/*
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
 \ Empresa.: PresServ Inform tica-Limeira (019)452.6623
 \ Programa: ADM_OUTR.PRG
 \ Data....: 23-07-95
 \ Sistema.: Administradora de Funer rias
 \ Funcao..: Define vari veis p£blicas
 \ Analista: Ademilson Pedro Bom
 \ Criacao.: GAS-Pro v2.0
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/

#include "adrbig.ch"    // inicializa constantes manifestas


#ifdef COM_CALE
 PROC CALE      // Rotina para exibir calend rio
 
 /*
    Simplificando a estrutura CASE   (thank you Rick Spence!)
    tbc e' um vetor bidimensional que contem as teclas a serem testadas
    e suas respectivas acoes (dentro de "code blocks")
 */
 LOCAL cale_tela:=SAVESCREEN(0,0,MAXROW(),79), cor_atual:=SETCOLOR(),;
       col_dia, dia_1, lisu_:=6, cosu_:=58, liin_:=20, coin_:=79,;
       i_, cl_, vr_cale, m_e_s, a_n_o, ult_dia,;
       tbc:={;
              {K_DOWN, {||datac:=datac-30}},;
              {K_UP,   {||datac:=datac+30}},;
              {K_RIGHT,{||datac:=datac+365}},;
              {K_LEFT, {||datac:=datac-365}};
            }
 SETCOLOR(drvtitmsg)
 vr_cale=NOVAPOSI(@lisu_,@cosu_,@liin_,@coin_)      // posicao atual do calendario
 CAIXA(mold,lisu_,cosu_,liin_,coin_)                // monta tela de apresentacao
 SETCOLOR(drvcorenf)                                // do calendario
 @ lisu_+2,cosu_+1 SAY "Do 2a 3a 4a 5a 6a Sa"
 SETCOLOR(drvtitmsg)
 @ lisu_+ 9,cosu_+1 SAY REPL("Ä",coin_-cosu_-1)
 @ lisu_+10,cosu_+2 SAY " Incrementa o MES"        // montra teclas disponiveis
 @ lisu_+11,cosu_+2 SAY " Decrementa o MES"
 @ lisu_+12,cosu_+2 SAY CHR(26)+" Incrementa o ANO"
 @ lisu_+13,cosu_+2 SAY CHR(27)+" Decrementa o ANO"
 SETCOLOR(drvcormsg)
 DO WHIL .t.
  @ lisu_+1,cosu_+1 SAY PADL(TRIM(NMES(datac))+" - "+STR(YEAR(datac)),20)
  dia_1=DOW(datac-DAY(datac)+1)          // dia da semana do 1o. dia do mes
  cl_=lisu_+3
  @ cl_,cosu_+1 CLEAR TO liin_-6,coin_-1 // limpa area dos dias
  col_dia=1+cosu_+3*(dia_1-1)            // coluna inicai do 1o. dia do mes
  m_e_s=MONTH(datac)                     // mes
  a_n_o=YEAR(datac)                      // ano
  IF INT(m_e_s/2) = m_e_s/2              // acha ultimo dia do mes
   ult_dia=IF(m_e_s<8,IF(m_e_s=2,IF(INT(a_n_o/4)=a_n_o/4,29,28),30),31)
  ELSE
   ult_dia=IF(m_e_s<8,31,30)
  ENDI
  FOR i_=1 TO ult_dia                    // imprime os dias
   IF DAY(DATE())=i_                     // se for heje
    SETCOLOR(drvcorenf)                  // enfatiza
   ENDI
   @ cl_,col_dia SAY PADL(STR(i_,2),2)   // imprime o dia na tela
   SETCOLOR(drvcormsg)                   // retorna a cor normal
   col_dia+=3                            // proxima coluna
   IF dia_1/7=INT(dia_1/7)               // fim da tela do calendario
    cl_++ ; col_dia=cosu_+1              // passa para proxima linha
   ENDI
   dia_1++                               // proximo dia
  NEXT
  x=SETCURSOR(0)                         // apaga cursor, x=cursor atual

  #ifdef COM_MOUSE
   k=MOUSETECLA(lisu_+10,cosu_+2,liin_-1,cosu_+2)
  #else
   k=INKEY(0)                            // aguarda pressionar tecla
  #endi

  SETCURSOR(x)                           // volta tamanho original do cursor
  nm=ASCAN(tbc,{|ve_a| k=ve_a[1]})       // procura tecla dentro do vetor tbc (e' o CASE)
  IF nm!=0                               // achou!
   EVAL(tbc[nm,2])                       // portanto, executa a acao...
  ELSE
   IF k=K_ALT_F8                         // muda calendario de posicao
    MUDA_PJ(@lisu_,@cosu_,@liin_,@coin_,cale_tela,.t.)
    sinal_=" "
    PUBL &vr_cale.:=STR(lisu_,2)+STR(cosu_,2)
    SAVE TO (arqconf) ALL LIKE drv*      // salva as coordenadas em disco
   ELSE                                  // tecla sem acao, portanto,
    EXIT                                 // fora...
   ENDI
  ENDI
 ENDD
 RESTSCREEN(0,0,MAXROW(),79,cale_tela)   // restaura tela e
 SETCOLOR(cor_atual)                     // o esquema de cor

 #ifdef COM_MOUSE
  IF drvmouse                            // se o mouse esta' ativo
   DO WHIL MOUSEGET(0,0)!=0              // espera que os botoes sejam
   ENDD                                  // liberados (nao pressionados)
  ENDI
 #endi

 RETU
#endi


#ifdef COM_MAQCALC
 PROC MAQCALC      // Apresenta "pop-calculadora"
 LOCAL tela_c:=SAVESCREEN(0,0,MAXROW(),79), cur_sor:=SETCURSOR(1),;
       getlist:={}, vr_calc, pg_up, pg_dn, tec_f3, tec_f4, tec_f9, tec_f8
 PRIV  sinal_:=" ", num_disp, fgpaste, cor_calc:=SETCOLOR(),;
       lisu_:=1, cosu_:=40, liin_:=9, coin_:=64, sinal_ant:=" "
 vr_calc=NOVAPOSI(@lisu_,@cosu_,@liin_,@coin_) // pega posicao atual da calculadora
 fgpaste=(!EMPT(READVAR()).AND.;   // ve se ha campo pendente (captura)
         LEFT(READVAR(),4)!="OPC_")
 SETKEY(K_F6,NIL)                  // evita recursividade
 pg_up =SETKEY(K_PGUP,NIL)         // desabilita PgUp,
 pg_dn =SETKEY(K_PGDN,NIL)         // PgDn,
 tec_f3=SETKEY(K_F3,NIL)           // F3,
 tec_f4=SETKEY(K_F4,NIL)           // F4,
 tec_f9=SETKEY(K_F9,NIL)           // F9 e move caixa ( ALT-F8 )
 tec_f8=SETKEY(K_ALT_F8,{||sinal_dig()})

 SETKEY(35 ,{||sinal_dig()})       // #   raiz quadrada
 SETKEY(36 ,{||sinal_dig()})       // $   inteiro/flutuante
 SETKEY(37 ,{||sinal_dig()})       // %   percentual
 SETKEY(42 ,{||sinal_dig()})       // *   multiplica
 SETKEY(43 ,{||sinal_dig()})       // +   soma
 SETKEY(45 ,{||sinal_dig()})       // -   subtrai
 SETKEY(47 ,{||sinal_dig()})       // /   divide
 SETKEY(61 ,{||sinal_dig()})       // =   total
 SETKEY(94 ,{||sinal_dig()})       // ^   exponencial
 SETKEY(99 ,{||sinal_dig()})       // c   limpa display
 SETKEY(67 ,{||sinal_dig()})       // C
 IF fgpaste
  SETKEY(82 ,{||sinal_dig()})      // R   captura resultado do display
  SETKEY(114,{||sinal_dig()})      // r
 ENDI
 SETCOLOR(drvcormsg)
 CAIXA(mold,lisu_,cosu_,liin_,coin_)
 @ lisu_+1,cosu_+2 SAY "ÉÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ»"
 @ lisu_+2,cosu_+2 SAY "³                   ³"
 @ lisu_+3,cosu_+2 SAY "³                   ³"
 @ lisu_+4,cosu_+2 SAY "ÈÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼"
 @ lisu_+5,cosu_+2 SAY " 7 8 9 C     +  -  * "
 @ lisu_+6,cosu_+2 SAY " 4 5 6 .  =  /  %  ^ "
 @ lisu_+7,cosu_+2 SAY " 1 2 3 0     "+CHR(K_ESC)+"  #  $ "
 SETCOLOR(drvcorget)
 @ lisu_+8,cosu_+2 SAY IF(fgpaste,"R, resultado no campo","")
 SETCOLOR(drvcorget+","+drvcorget+",,,"+drvcorget)
 DO WHIL .t.
  gab=IF(fgint,"   999999999999999",;     // mascara
               "999999999999999.99")
  num_disp=0.00                           // numero no display
  @ lisu_+2,cosu_+3 SAY "="
  @ lisu_+2,cosu_+4 GET nu_calc PICT gab  // mostra total
  CLEAR GETS
  @ lisu_+3,cosu_+3 SAY sinal_ant
  @ lisu_+3,cosu_+4 GET num_disp PICT gab // capta operando
  READ
  DO CASE
   CASE LASTKEY()=K_ESC.OR.sinal_="R"     // finalizou
    IF fgpaste.AND.sinal_="R"
     KEYB ALLTRIM(TRAN(nu_calc,gab))      // joga resultado no campo
    ENDI
    EXIT                                  // e sai
   CASE sinal_="AF8"                      // muda calculadora de posicao
    MUDA_PJ(@lisu_,@cosu_,@liin_,@coin_,tela_c,.t.)
    sinal_=" "
    PUBL &vr_calc.:=STR(lisu_,2)+STR(cosu_,2)
    SAVE TO (arqconf) ALL LIKE drv*       // salva as coordenadas em disco
   CASE sinal_="$"                        // chaveou inteiro/decimal
    fgint=(!fgint); sinal_=" "
   CASE sinal_="C"                        // limpa display
    nu_calc=0; sinal_=" "
   CASE sinal_="#"                        // raiz quadrada
    IF !EMPTY(num_disp)                   // algum numero no display?
     IF sinal_ant="-"                     // op anterior=subtracao?
      nu_calc-=SQRT(num_disp)             // subtrai a raiz
     ELSE                                 // do display no resultado
      nu_calc+=SQRT(num_disp)             // senao, soma
     ENDI
    ELSE                                  // nao exite numero no
     nu_calc=SQRT(nu_calc)                // display, porisso
    ENDI                                  // calcula raiz do total
    sinal_=" "
   OTHERWISE
    DO CASE
     CASE sinal_ant="-"                   // subtrai
      nu_calc-=num_disp
     CASE sinal_ant="*"                   // multiplica
      nu_calc=nu_calc*num_disp
     CASE sinal_ant="/"                   // divide
      nu_calc=nu_calc/num_disp
     CASE sinal_ant="^"                   // eleva potencia
      nu_calc=nu_calc^num_disp
     CASE sinal_ant="%"                   // obtem percentual
      nu_calc=nu_calc/100*num_disp
     OTHERWISE                            // soma (+) ou sem operador
      nu_calc+=num_disp
   ENDC
  ENDC
  sinal_=IF(sinal_="="," ",sinal_)        // igual nao pode ser exibido
  sinal_ant=sinal_; sinal_=" "            // salva sinal digitado
 ENDD
 SETCOLOR(cor_calc)                       // volta com as cores anteriores
 SETCURSOR(cur_sor)                       // volta cursor com era antes
 SET KEY K_F6 TO maqcalc                  // reabilita calculadora (f6)
 SETKEY(35,NIL); SETKEY(36,NIL)           // desabilita as teclas
 SETKEY(37,NIL); SETKEY(42,NIL)           // utilizadas na operacao
 SETKEY(43,NIL); SETKEY(45,NIL)           // da calculadora
 SETKEY(47,NIL); SETKEY(67,NIL)
 SETKEY(94,NIL); SETKEY(99,NIL)
 SETKEY(82,NIL); SETKEY(114,NIL)
 SETKEY(61,NIL)
 SETKEY(K_PGUP,pg_up)                     // habilita teclas PgUp,
 SETKEY(K_PGDN,pg_dn)                     // PgDn,
 SETKEY(K_F3,tec_f3)                      // F3,
 SETKEY(K_F4,tec_f4)                      // F4,
 SETKEY(K_F9,tec_f9)                      // F9 e
 SETKEY(K_ALT_F8,tec_f8)                  // ALT-F8
 RESTSCREEN(0,0,MAXROW(),79,tela_c)       // restaura a tela
 RETU

 STATIC PROC SINAL_DIG  // Recebe sinal da calculadora
 sinal_=IF(LASTKEY()=K_ALT_F8,"AF8",;     // recebe sinal digitado e
        UPPER(CHR(LASTKEY())))            // forca saida do get com
 KEYB CHR(K_ENTER)                        // ENTER simulado
 RETU
#endi


* \\ Final de ADM_OUTR.PRG
FUNC veinscrits(Vinscr)
vinscr:=[Inscritos n„o cadastrados]
vcod:=LEFT(codigo,10)
if PTAB(LEFT(codigo,10),'INSCRITS',1)
 reg_dbfx:=POINTER_DBF()
 SELE INSCRITS
 Vinscr:=[]
 DO WHILE !EOF() .AND. INSCRITS->codigo=vcod
  Vinscr+=INSCRITS->nome+[ (]+;
        SUBSTR([TitPaiMaeSgoSgaEspFilDep],(VAL(grau)-1)*3+1,3)+[) tc ]+;
        dtoc(tcarencia)+[ ]+vivofalec+[ ]+tipo+[|]
  SKIP
 ENDDO
 POINTER_DBF(reg_dbfx)
endi

retu  DBOX(Vinscr,,,E_MENU,,[INSCRITOS DO CONTRATO])
// op_cad=DBOX(Vinscr,,,E_MENU,,[INSCRITOS DO CONTRATO],,,op_cad)
/*
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
 \ Empresa.: PresServ Inform tica-Limeira (019)452.6623.
 \ Programa: V00101F9.PRG
 \ Data....: 03-10-95
 \ Sistema.: Controle de Convˆnios
 \ Funcao..: Valida‡„o da variavel GNUMERO, relatorio CON_R001
 \ Analista: Ademilson Pedro Bom
 \ Criacao.: Programado manualmente pelo analista
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/

func v00101f9
//PARAMETROS('pnumero',gnumero)

  IF !PTAB(PADR(SUBSTR(M->ide_maq,2),4)+[GUI],[IMPPAR],1)
   ord_=LEN(sistema[EVAL(qualsis,"IMPPAR"),O_CHAVE])
   FAZ_LANC("IMPPAR",[ ])
   REPL IMPPAR->idmaq WITH PADR(SUBSTR(M->ide_maq,2),4),;
	IMPPAR->base WITH [GUI]
  ENDI
   #ifdef COM_REDE
    IMPPAR->(DBUNLOCK())                           // libera o registro
   #endi

   IF PTAB(PADR(SUBSTR(M->ide_maq,2),4)+[GUI],[IMPPAR],1)
    REPBLO('IMPPAR->docto',{||gnumero})
   ENDI

RETU .T.      // <- deve retornar um valor L¢GICO

* \\ Final de V00101F9.PRG


func V_carencia
para v_intervalo,dias_carencia
/*
Funcao criada para verificar a carencia dos contratos MA e MB.
 entra em carencia de [dias_carencia] depois de paga parcela com
[v_intervalo] de dias em atraso.
-limpar detalhes e deixar so 25 dias de pagas;
-o contrato q aparecer com mais de 70 dias em aberto, direito suspenso;
-taxas mais de 70 dias de vencidas e paga a menos de 25 dia (carencia);
*/
LOCAL dt_tx:=ctod(''),donex:=[] //,reg_dbf:=POINTER_DBF()
rec_dbf:=RECNO()                // inicializa vetor de retorno
i_=SELECT()                     // salva area atual
Mcod=GRUPOS->codigo
vai_entrar:=esta_em:=.F.
dt_fimcar:=dt_ultpg:=ctod([])
IF EMPTY(SELECT([TAXAS]))                      // o arquivo nao esta' em uso, vamos abri-lo...
 PTAB(Mcod,[TAXAS],1,.T.)
 SELE TAXAS
ELSE
 SELE TAXAS
 SEEK M->mcod       // Verifica todas as taxas do contrato
ENDI
SELE TAXAS
DO WHILE !EOF() .AND. TAXAS->codigo+TAXAS->tipo+TAXAS->circ=M->Mcod //.AND.ct_tx < M->rpend
 IF TAXAS->valorpg>0    // Das pagas, compara vencto e pgto.
  IF (pgto_ - emissao_) >= v_intervalo     // se atrasou nn dias,
	 dt_ultpg:=TAXAS->pgto_                  // guarda data pgto.
   dt_fimcar:=TAXAS->pgto_ + dias_carencia // calcula fim carencia
   IF DATE() < dt_fimcar                   // compara com data atual
    esta_em:=.T.                           // se carencia maior q data = carencia
   ENDI
  ELSE  // se nao atrasou (ou intervalo for menor q carencia)
   IF (pgto_ >= dt_fimcar)     // Se pagou depois do fim de carencia, tira-o
    esta_em:=.F.
   ENDI
  ENDI
 ELSE    // Se ainda num foi paga
  IF (date() - emissao_) > v_intervalo // e ja venceu alem do intervalo...
   vai_entrar:=.T.                     // entra em suspenso...
  ENDI
 ENDI
 SKIP
ENDDO
IF DATE() > dt_fimcar   // mas, se ja passou a data final de carencia...
 esta_em:=.F.           // sai da carencia (ja cumpriu...)
ENDI
//POINTER_DBF(reg_dbf)
sele (i_)
go (rec_dbf)
IF (esta_em)
 RETU 2      // Pagou e esta na Carencia,
ELSEIF (vai_entrar)
 RETU 1      // num pagou, esta suspenso...
ENDI
RETU 0 //(esta_em.OR.vai_entrar)       // <- deve retornar um valor L¢GICO


//020760835
//Cancelamento e reintegra‡ao, verificar os campos transferidos (COROAS)

Function XCRIPTOGRAFA(Pstr, Psenha, Pencript)
LOCAL Tcript, Tx, Tascii
LOCAL Tlensenha
Tlensenha = Len(AllTrim(Psenha))
      Tcript = ""
      For Tx = 1 To Len(Pstr)
          If Pencript           //&& Criptografa
             Tascii = Asc(Subs(Pstr, Tx, 1)) + ;
                       Asc(Subs(Psenha, ((Tx + 77) % Tlensenha) + 1, 1))
          Else                          && DesCriptografa
             Tascii = Asc(Subs(Pstr, Tx, 1)) - ;
                       Asc(Subs(Psenha, ((Tx + 77) % Tlensenha) + 1, 1))
          EndIf
          Tcript = Tcript + Chr(Tascii)
      Next
Return(Tcript)


function xencript(caracteres)
return xCRIPTOGRAFA(caracteres, 'bompastor', .t.)

function xdecript(caracteres)
return xCRIPTOGRAFA(caracteres, 'bompastor', .f.)

GAS-Pro v4.0
002003024079001033001013023001022001




            GUIA DE ENCAMINHAMENTO

    Para:

    Credenciado:

    Endereco...:



    Beneficiario Principal:


    Pessoa a ser atendida.:
    Emitida em           , valida ate           .

    IMPORTANTE: Esta guia tem a finalidade principal de encaminhamento em consultas e exames






ALLTRIM(MEDICOS->nome)+[ Tel:]+ALLTRIM(MEDICOS->fonesdiv)
[Ÿ]
 15 
GUIAS
Emiss„o Guias


PTAB(PADR(SUBSTR(M->ide_maq,2),4)+[GUI],[IMPPAR],1).and.LEFT(IMPPAR->docto,7)=ano+numero
011

























 0 
 1 










-1 
 1 
 0 
 33 
 1 
 3 
 1 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
-1 
 0 
-1 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
Credenciado
ALLTRIM(MEDICOS->nome)+[ Tel:]+ALLTRIM(MEDICOS->fonesdiv)

 60 
C
 9 
 18 


û         










N£mero
numero
99999999
 8 
C
 5 
 40 


          










Emiss„o
data
@D
 10 
D
 19 
 16 


          










validade
data+30
@D
 10 
D
 19 
 39 


          










Codigo
medico
@!
 10 
C
 10 
 18 


          










Endere‡o
MEDICOS->endereco

 50 
C
 11 
 18 


          










Bairro
MEDICOS->bairro
@!
 30 
C
 12 
 18 


          










Cidade
ALLTRIM(MEDICOS->cidade)+[, ]+MEDICOS->uf+[ CEP ]+MEDICOS->cep
@!
 50 
C
 13 
 18 


          










Titular
GRUPOS->nome
@!
 35 
C
 15 
 29 


          










N§ Contrato
contrato
@!
 10 
C
 16 
 29 


          










Nome
nome
@!
 35 
C
 18 
 29 


          










Oldespec
MEDICOS->oldespec
@!
 50 
C
 7 
 12 


          










Ident1
M->setup1

 40 
C
 1 
 7 


          










Ident2
M->setup2

 50 
C
 2 
 7 


          










Setup3
M->setup3

 50 
C
 3 
 7 


          










 9 
Nome da empresa
nemp

 0 
 0 
 44 

T¡tulo aplica‡„o
nsis

 0 
 0 
 25 

Data do sistema
DTOC(DATE())

 0 
 0 
 8 

Nome do mˆs
NMES(DATE())

 0 
 0 
 8 

Dia da semana
NSEM(DATE())

 0 
 0 
 7 

N£mero da p gina
TRAN(pg_,'9999')

 0 
 0 
 4 

C¢digo relat¢rio
"CON_R001"

 0 
 0 
 8 

T¡tulo a definir
titrel

 0 
 0 
 30 

Hora da emiss„o
hora_rel_

 0 
 0 
 5 

 0 
 0 
 0 
 2 
MEDICOS
 1 
medico



GRUPOS
 1 
contrato



#!/bin/sh

    umount /dados/dominios/sistemas/dbf2sql/smb

    smbmount //192.168.0.201/sql /dados/dominios/sistemas/dbf2sql/smb -o username=samuel,password=senha

    php /dados/dominios/sistemas/dbf2sql/convert

    umount /dados/dominios/sistemas/dbf2sql/smb

    echo "Conversao Dados do Plano Antigo efetuada" | mail -s "Conversao" samuel@grupobompastor.com.br
    
GAS-Pro v3.0

[Ÿ]
 0 

Contagem



001









-1 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
procedure r07702f9
/*
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
 \ Empresa.: PresServ Inform tica - Limeira (019)452.6623
 \ Programa: R07702F9.PRG
 \ Data....: 23-05-98
 \ Sistema.: Administradora -CRD/COBRAN€A
 \ Funcao..: Valor do relat¢rio ADC_R077
 \ Analista: Ademilson Pedro Bom
 \ Criacao.: Programado manualmente pelo analista
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/

#include "adrbig.ch"    // inicializa constantes manifestas
PRIVA vladd:=0
IF TAXAS->emissao_< DATE()
 jrok:=PTAB(tipo,'JUROS',1)
 nrd:=(DATE() - TAXAS->emissao_)
 IF jrok .AND. (nrd > JUROS->mltcaren)
  vladd+=TAXAS->valor*JUROS->multa/100
 ENDI
 IF jrok .AND. (nrd > JUROS->jrscaren)
  vladd+=TAXAS->valor*JUROS->juros/100*nrd
 ENDI
ENDI

RETU IIF(EMPT(TAXAS->valorpg),TAXAS->valor+M->vladd,TAXAS->valorpg)

* \\ Final de R07702F9.PRG
/*
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
 \ Empresa.: PresServ Inform tica - Limeira (019)452.6623
 \ Programa: PRCESSOS.PRG
 \ Data....: 04-11-03
 \ Sistema.: Administradora - RECEP€„O
 \ Funcao..: Gerenciador do subsistema de processos
 \ Analista: Ademilson Pedro Bom
 \ Criacao.: GAS-Pro v4.0n
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/
#include "adrbig.ch"    // inicializa constantes manifestas

PARA lin_menu,col_menu
PRIV op_sis, tela_fundo:=SAVESCREEN(0,0,MAXROW(),79), l_s, c_s, l_i, c_i, l_a

op_sis=EVAL(qualsis,"PRCESSOS")
IF nivelop<sistema[op_sis,O_OUTROS,O_NIVEL]        // se usuario nao tem permissao,
 ALERTA()                                          // entao, beep, beep, beep
 DBOX(msg_auto,,,3)                                // lamentamos e
 RETU                                              // retornamos ao menu
ENDI
cn:=fgrep :=.f.

#ifdef COM_LOCK
 IF LEN(pr_ok)>0                                   // se a protecao acusou
  ? pr_ok                                          // erro, avisa e
  QUIT                                             // encerra a aplicacao
 ENDI
#endi

t_fundo=SAVESCREEN(0,0,MAXROW(),79)                // salva tela do fundo
op_cad=1
DO WHIL op_cad!=0
 criterio=""
 RESTSCREEN(0,0,MAXROW(),79,t_fundo)               // restaura tela do fundo
 cod_sos=5 ; cn=.f.
 CLEA TYPEAHEAD                                    // limpa o buffer do teclado
 fgrep=.f.
 SET KEY K_F3 TO                                   // retira das teclas F3 e F4 as
 SET KEY K_F4 TO                                   // funcoes de repeticao e confirmacao
 msg="Consulta Individual~1|"+;
     "Consulta Global~2"
 op_cad=DBOX(msg,lin_menu,col_menu,E_MENU,NAO_APAGA,MAIUSC(sistema[op_sis,O_MENU]),,,op_cad)
 IF op_cad!=0                                      // se escolheu uma opcao
  Tela_fundo=SAVESCREEN(0,0,MAXROW(),79)           // salva a tela para ROLATELA()
  PARAMETROS(dbfparam)
  SELE A                                           // e abre o arquivo e seus indices

  #ifdef COM_REDE
   IF !USEARQ(sistema[op_sis,O_ARQUI,O_NOME],.f.,20,1)
                                                   // se falhou a abertura do
    RETU                                           // arquivo volta ao menu anterior
   ENDI
  #else
   USEARQ(sistema[op_sis,O_ARQUI,O_NOME])
  #endi

  SET KEY K_F9 TO veoutros                         // habilita consulta em outros arquivos
 ENDI
 DO CASE
  CASE op_cad=01                                   // consulta individual
   op_menu=ALTERACAO
   cod_sos=7
   EDIT()

  CASE op_cad=02                                   // consulta global
   op_menu=PROJECOES
   cod_sos=8
   EDITA(03,03,MAXROW()-2,77)

 ENDC
 SET KEY K_F9 TO                                   // F9 nao mais consultara outros arquivos
 CLOS ALL                                          // fecha todos arquivos abertos
ENDD
RETU

PROC PRC_incl(reg_cop)  // inclusao no arquivo PRCESSOS
LOCAL getlist:={}, cabem:=1, rep:=ARRAY(FCOU()), ult_reg:=RECN(),;
      ctl_r, ctl_c, ctl_w, t_f3_, t_f4_, dele_atu:=SET(_SET_DELETED,.f.)
PRIV op_menu:=INCLUSAO, tem_borda, criterio:="", cpord:=""
FOR i=1 TO FCOU()                                  // cria/declara privadas as
 msg=FIEL(i)                                       // variaveis de memoria com
 PRIV &msg.                                        // o mesmo nome dos campos
NEXT                                               // do arquivo
IF reg_cop!=NIL                                    // quer repetir todo o reg atual
 FOR i=1 TO FCOU()                                 // para cada campo,
  msg=FIEL(i)                                      // salva o conteudo
  rep[i]=&msg.                                     // para repetir
 NEXT
ELSE
 AFILL(rep,"")                                     // eche com valor vazio
ENDI
t_f3_=SETKEY(K_F3,{||rep()})                       // repeticao reg anterior
t_f4_=SETKEY(K_F4,{||conf()})                      // confirma campos com ENTER
ctl_w=SETKEY(K_CTRL_W,{||nadafaz()})               // enganando o CA-Clipper...
ctl_c=SETKEY(K_CTRL_C,{||nadafaz()})
ctl_r=SETKEY(K_CTRL_R,{||nadafaz()})
DO WHIL cabem>0
 rola_t=.f.                                        // flag se quer rolar a tela
 SELE PRCESSOS
 GO BOTT                                           // forca o
 SKIP                                              // final do arquivo
 
 /*
    cria variaveis de memoria identicas as de arquivo, para inclusao
    de registros
 */
 FOR i=1 TO FCOU()
  msg=FIEL(i)
  M->&msg.=IF((fgrep .OR. reg_cop!=NIL).AND.!EMPT(rep[1]),rep[i],&msg.)
 NEXT
 DISPBEGIN()                                       // apresenta a tela de uma vez so
 PRC_TELA()
 INFOSIS(.t.)                                      // exibe informacao no rodape' da tela
 DISPEND()
 cabem=DISKSPACE(;
          IF(;
             LEN(sistema[op_sis,O_ARQUI,O_DIR_DBF])<2.OR.sistema[op_sis,O_ARQUI,O_DIR_DBF]="\",;
             0,;
             ASC(sistema[op_sis,O_ARQUI,O_DIR_DBF])-64;
          );
       )
 cabem=INT((cabem-2048)/PRCESSOS->(RECSIZE()))
 IF cabem<1                                        // mais nenhum!!!
  ALERTA()
  msg="Verifique ESPA€O EM DISCO, "+usuario
  DBOX(msg,,,,,"INCLUSŽO INTERROMPIDA!")           // vamos parar por aqui!
  EXIT
 ENDI
 SELE 0                                            // torna visiveis variaveis de memoria
 SETCOLOR(drvcortel+","+drvcorget+",,,"+corcampo)
 SET KEY K_ALT_F8 TO ROLATELA
 
 /*
    recebe chaves do arquivo de indice basico
 */
 @ l_s+01 ,c_s+13 GET  processo;
                  PICT sistema[op_sis,O_CAMPO,01,O_MASC]
                  DEFINICAO 1

 @ l_s+02 ,c_s+13 GET  categ;
                  PICT sistema[op_sis,O_CAMPO,02,O_MASC]
                  DEFINICAO 2

 READ
 SET KEY K_ALT_F8 TO
 IF rola_t
  ROLATELA()
  LOOP
 ENDI
 SELE PRCESSOS
 IF LASTKEY()=K_ESC                                // cancelou ou chave em branco
  cabem=0                                          // prepara saida da inclusao
  LOOP                                             // volta p/ menu de cadastramento
 ENDI
 SEEK M->processo+M->categ
 aprov_reg_=(FOUND().AND.DELE().AND.!drvvisivel)   // vai aproveitar o registro?
 IF FOUND() .AND. !aprov_reg_                      // pesquisou e achou!
  op_menu=ALTERACAO                                // seta flag de ateracao
  DISPBEGIN()
  PRC_GETS()                                       // mostra conteudo do registro
  INFOSIS(.f.)                                     // exibe informacao no rodape' da tela
  DISPEND()
  ALERTA()
  msg="Consultar/alterar|Retornar … inclus„o"      // pergunta se deseja
  op_=DBOX(msg,,,E_MENU,,"REGISTRO J EXISTE")     // alterar o registro
  IF op_ =1                                        // caso afirmativo
   EDIT()                                          // deixa alterar
  ENDI
  op_menu=INCLUSAO
  LOOP                                             // volta para inclusao
 ENDI
 SELE 0
 PRC_GET1(INCLUI)                                  // recebe campos
 SELE PRCESSOS
 IF LASTKEY()=K_ESC                                // se cancelou
  ALERTA()                                         // avisa que o registro
  DBOX("Registro n„o inclu¡do!",18,,1)             // nao foi incluido, e volta
  LOOP
 ENDI

 #ifdef COM_REDE
  GO BOTT                                          // vamos bloquear o final do
  SKIP                                             // arq para que nehum outro
  BLOREG(0,.5)                                     // usuario possa incluir
  SEEK M->processo+M->categ                        // se registro foi incluido
  aprov_reg_=(FOUND().AND.DELE().AND.!drvvisivel)  // vai aproveitar o registro?
  IF FOUND() .AND. !aprov_reg_                     // por outro usuario, entao
   BLOREG(0,.5)
   FOR i=1 TO FCOU()
    msg=FIEL(i)
    rep[i]=&msg.
    REPL &msg. WITH M->&msg.
   NEXT
   PRC_GET1(FORM_INVERSA)                          // executa formula inversa
   RECA
   FOR i=1 TO FCOU()
    msg=FIEL(i)
    REPL &msg. WITH rep[i]
   NEXT
   ALERTA(4)                                       // beep 4 vezes
   msg="Registro acabou de ser|inclu¡do por outro usu rio!"
   DBOX(msg,,,,,"ATEN€ŽO!")                        // avisa
   SELE PRCESSOS
   UNLOCK                                          // libera o registro
   LOOP                                            // e recebe chave novamente
  ENDI
 #endi

 IF aprov_reg_                                     // se vai aproveitar reg excluido

  #ifdef COM_REDE
   BLOREG(0,.5)
  #endi

  RECA                                             // excluido, vamos recupera-lo
 ELSE                                              // caso contrario
  APPEND BLANK                                     // inclui reg em branco no dbf
 ENDI
 FOR i=1 TO FCOU()                                 // para cada campo,
  msg=FIEL(i)                                      // salva o conteudo
  rep[i]=M->&msg.                                  // para repetir
  REPL &msg. WITH rep[i]                           // enche o campo do arquivo
 NEXT

 #ifdef COM_REDE
  UNLOCK                                           // libera o registro e
  COMMIT                                           // forca gravacao
 #else
  IF RECC()-INT(RECC()/20)*20=0                    // a cada 20 registros
   COMMIT                                          // digitados forca gravacao
  ENDI
 #endi

 ult_reg=RECN()                                    // ultimo registro digitado
 IF reg_cop!=NIL                                   // estava na consulta e quis rep o campo
  EXIT                                             // cai fora...
 ENDI
ENDD
GO ult_reg                                         // para o ultimo reg digitado
SETKEY(K_F3,t_f3_)                                 // restaura teclas de funcoes
SETKEY(K_F4,t_f4_)
SET(_SET_DELETED,dele_atu)                            // ecluidos visiveis/invisiveis
SETKEY(K_CTRL_W,ctl_w)
SETKEY(K_CTRL_C,ctl_c)
SETKEY(K_CTRL_R,ctl_r)
RETU


PROC PRC_tela     // tela do arquivo PRCESSOS
tem_borda=.t.
l_s=Sistema[op_sis,O_TELA,O_LS]           // coordenadas da tela
c_s=Sistema[op_sis,O_TELA,O_CS]
l_i=Sistema[op_sis,O_TELA,O_LI]
c_i=Sistema[op_sis,O_TELA,O_CI]
SETCOLOR(drvtittel)
vr_memo=NOVAPOSI(@l_s,@c_s,@l_i,@c_i)     // pega posicao atual da tela
CAIXA(mold,l_s,c_s,l_i,c_i)               // monta caixa da tela
i=LEN(sistema[op_sis,O_MENS])/2
@ l_s,c_s-1+(c_i-c_s+1)/2-i SAY " "+MAIUSC(sistema[op_sis,O_MENS])+" "
SETCOLOR(drvcortel)
@ l_s+01,c_s+1 SAY " Processo.:"
@ l_s+02,c_s+1 SAY " Categoria:    (PL=Plano, PD=Plano c/Dif.,AF=Auxilio)"
@ l_s+03,c_s+1 SAY " Saiu.....:"
@ l_s+04,c_s+1 SAY " Contrato.:   /      / /"
@ l_s+05,c_s+1 SAY " Segurado.:"
@ l_s+06,c_s+1 SAY " Endere‡o.:"
@ l_s+07,c_s+1 SAY " Cidade...:"
@ l_s+08,c_s+1 SAY " Falecido.:"
@ l_s+09,c_s+1 SAY " Sepultam.:"
@ l_s+10,c_s+1 SAY " Data Fal.:"
RETU

PROC PRC_gets     // mostra variaveis do arquivo PRCESSOS
LOCAL getlist := {}
PRC_TELA()
SETCOLOR(drvcortel+","+drvcorget+",,,"+corcampo)
PTAB(NUM,'INSCRITS',1)
@ l_s+01 ,c_s+13 GET  processo;
                 PICT sistema[op_sis,O_CAMPO,01,O_MASC]

@ l_s+02 ,c_s+13 GET  categ;
                 PICT sistema[op_sis,O_CAMPO,02,O_MASC]

@ l_s+03 ,c_s+13 GET  saiu

@ l_s+04 ,c_s+13 GET  grup;
                 PICT sistema[op_sis,O_CAMPO,04,O_MASC]

@ l_s+04 ,c_s+16 GET  num;
                 PICT sistema[op_sis,O_CAMPO,05,O_MASC]

@ l_s+04 ,c_s+23 GET  grau;
                 PICT sistema[op_sis,O_CAMPO,06,O_MASC]

@ l_s+04 ,c_s+25 GET  seq;
                 PICT sistema[op_sis,O_CAMPO,07,O_MASC]

@ l_s+05 ,c_s+13 GET  seg;
                 PICT sistema[op_sis,O_CAMPO,08,O_MASC]

@ l_s+06 ,c_s+13 GET  ends;
                 PICT sistema[op_sis,O_CAMPO,09,O_MASC]

@ l_s+07 ,c_s+13 GET  cids;
                 PICT sistema[op_sis,O_CAMPO,10,O_MASC]

@ l_s+08 ,c_s+13 GET  fal;
                 PICT sistema[op_sis,O_CAMPO,11,O_MASC]

@ l_s+09 ,c_s+13 GET  sep;
                 PICT sistema[op_sis,O_CAMPO,12,O_MASC]

@ l_s+10 ,c_s+13 GET  dfal;
                 PICT sistema[op_sis,O_CAMPO,13,O_MASC]
                 CRIT(sistema[op_sis,O_CAMPO,13,O_CRIT],,"1")

CLEAR GETS
RETU

PROC PRC_get1(tp_mov)     // capta variaveis do arquivo PRCESSOS
LOCAL getlist := {}
PRIV  blk_prcessos:=.t.

IF tp_mov=INCLUI
 DO WHILE .t.
  rola_t=.f.
  SET KEY K_ALT_F8 TO ROLATELA
  SETCOLOR(drvcortel+","+drvcorget+",,,"+corcampo)
  @ l_s+03 ,c_s+13 GET  saiu
                   DEFINICAO 3

  @ l_s+04 ,c_s+13 GET  grup;
                   PICT sistema[op_sis,O_CAMPO,04,O_MASC]
                   DEFINICAO 4

  @ l_s+04 ,c_s+16 GET  num;
                   PICT sistema[op_sis,O_CAMPO,05,O_MASC]
                   DEFINICAO 5

  @ l_s+04 ,c_s+23 GET  grau;
                   PICT sistema[op_sis,O_CAMPO,06,O_MASC]
                   DEFINICAO 6

  @ l_s+04 ,c_s+25 GET  seq;
                   PICT sistema[op_sis,O_CAMPO,07,O_MASC]
                   DEFINICAO 7

  @ l_s+05 ,c_s+13 GET  seg;
                   PICT sistema[op_sis,O_CAMPO,08,O_MASC]
                   DEFINICAO 8

  @ l_s+06 ,c_s+13 GET  ends;
                   PICT sistema[op_sis,O_CAMPO,09,O_MASC]
                   DEFINICAO 9

  @ l_s+07 ,c_s+13 GET  cids;
                   PICT sistema[op_sis,O_CAMPO,10,O_MASC]
                   DEFINICAO 10

  @ l_s+08 ,c_s+13 GET  fal;
                   PICT sistema[op_sis,O_CAMPO,11,O_MASC]
                   DEFINICAO 11

  @ l_s+09 ,c_s+13 GET  sep;
                   PICT sistema[op_sis,O_CAMPO,12,O_MASC]
                   DEFINICAO 12

  @ l_s+10 ,c_s+13 GET  dfal;
                   PICT sistema[op_sis,O_CAMPO,13,O_MASC]
                   DEFINICAO 13
                   MOSTRA sistema[op_sis,O_FORMULA,1]

  READ
  SET KEY K_ALT_F8 TO
  IF rola_t
   ROLATELA()
   LOOP
  ENDI
  IF LASTKEY()!=K_ESC .AND. drvincl .AND. op_menu=INCLUSAO
   IF !CONFINCL()
    LOOP
   ENDI
  ENDI
  EXIT
 ENDD
ENDI
PTAB(GRUP,'ARQGRUP',1)
PTAB(NUM,'GRUPOS',1)
PTAB(NUM,'INSCRITS',1)
IF tp_mov=EXCLUI .OR. tp_mov=FORM_INVERSA
 IF !EMPTY(codlan) .AND. tp_mov=EXCLUI
  ALERTA()       // existe registro validado aqui!
  msg="Registro de Lan‡amento"
  DBOX(msg,,,,,"IMPOSS¡VEL EXCLUIR!")
 ELSE

  #ifdef COM_REDE
   IF saiu<'001'.AND.PTAB(grup,'ARQGRUP',1)
    REPBLO('ARQGRUP->procpend',{||ARQGRUP->procpend - 1})
   ENDI
   IF saiu<'001'.AND.PTAB(grup,'ARQGRUP',1)
    REPBLO('ARQGRUP->partic',{||ARQGRUP->partic + 1})
   ENDI
   IF PTAB(num,'GRUPOS',1)
    REPBLO('GRUPOS->funerais',{||GRUPOS->funerais - 1})
   ENDI
   IF PTAB(num,'GRUPOS',1)
    REPBLO('GRUPOS->particv',{||GRUPOS->particv + 1})
   ENDI
   IF PTAB(num,'GRUPOS',1)
    REPBLO('GRUPOS->particf',{||GRUPOS->particf - 1})
   ENDI
   IF PTAB(num+grau+STR(seq,02,00),'INSCRITS',1)
    REPBLO('INSCRITS->vivofalec',{||[V]})
   ENDI
   IF PTAB(num+grau+STR(seq,02,00),'INSCRITS',1)
    REPBLO('INSCRITS->falecto_',{||ctod('  /  /  ')})
   ENDI
   IF PTAB(num+grau+STR(seq,02,00),'INSCRITS',1)
    REPBLO('INSCRITS->tipo',{||[  ]})
   ENDI
   IF PTAB(num+grau+STR(seq,02,00),'INSCRITS',1)
    REPBLO('INSCRITS->procnr',{||[ ]})
   ENDI
  #else
   IF saiu<'001'.AND.PTAB(grup,'ARQGRUP',1)
    REPL ARQGRUP->procpend WITH ARQGRUP->procpend - 1
   ENDI
   IF saiu<'001'.AND.PTAB(grup,'ARQGRUP',1)
    REPL ARQGRUP->partic WITH ARQGRUP->partic + 1
   ENDI
   IF PTAB(num,'GRUPOS',1)
    REPL GRUPOS->funerais WITH GRUPOS->funerais - 1
   ENDI
   IF PTAB(num,'GRUPOS',1)
    REPL GRUPOS->particv WITH GRUPOS->particv + 1
   ENDI
   IF PTAB(num,'GRUPOS',1)
    REPL GRUPOS->particf WITH GRUPOS->particf - 1
   ENDI
   IF PTAB(num+grau+STR(seq,02,00),'INSCRITS',1)
    REPL INSCRITS->vivofalec WITH [V]
   ENDI
   IF PTAB(num+grau+STR(seq,02,00),'INSCRITS',1)
    REPL INSCRITS->falecto_ WITH ctod('  /  /  ')
   ENDI
   IF PTAB(num+grau+STR(seq,02,00),'INSCRITS',1)
    REPL INSCRITS->tipo WITH [  ]
   ENDI
   IF PTAB(num+grau+STR(seq,02,00),'INSCRITS',1)
    REPL INSCRITS->procnr WITH [ ]
   ENDI
  #endi

  IF !EMPTY(ALIAS())
   DELE
  ENDI
 ENDI
ELSEIF tp_mov=INCLUI .OR. tp_mov=RECUPERA .OR. tp_mov=FORM_DIRETA
 IF (op_menu=INCLUSAO .AND. LASTKEY()!=K_ESC) .OR. op_menu!=INCLUSAO
  IF !EMPTY(codlan) .AND. tp_mov=RECUPERA
   ALERTA()      // existe registro validado aqui!
   msg="Registro de Lan‡amento"
   DBOX(msg,,,,,"IMPOSS¡VEL RECUPERAR!")
  ELSE

   #ifdef COM_REDE
    IF saiu<'001'.AND.PTAB(grup,'ARQGRUP',1)
     REPBLO('ARQGRUP->procpend',{||ARQGRUP->procpend + 1})
    ENDI
    IF saiu<'001'.AND.PTAB(grup,'ARQGRUP',1)
     REPBLO('ARQGRUP->partic',{||ARQGRUP->partic - 1})
    ENDI
    IF PTAB(num,'GRUPOS',1)
     REPBLO('GRUPOS->funerais',{||GRUPOS->funerais + 1})
    ENDI
    IF PTAB(num,'GRUPOS',1)
     REPBLO('GRUPOS->particv',{||GRUPOS->particv - 1})
    ENDI
    IF PTAB(num,'GRUPOS',1)
     REPBLO('GRUPOS->particf',{||GRUPOS->particf + 1})
    ENDI
    IF PTAB(num+grau+STR(seq,02,00),'INSCRITS',1)
     REPBLO('INSCRITS->vivofalec',{||[F]})
    ENDI
    IF PTAB(num+grau+STR(seq,02,00),'INSCRITS',1)
     REPBLO('INSCRITS->falecto_',{||dfal})
    ENDI
    IF PTAB(num+grau+STR(seq,02,00),'INSCRITS',1)
     REPBLO('INSCRITS->tipo',{||categ})
    ENDI
    IF PTAB(num+grau+STR(seq,02,00),'INSCRITS',1)
     REPBLO('INSCRITS->procnr',{||processo})
    ENDI
   #else
    IF saiu<'001'.AND.PTAB(grup,'ARQGRUP',1)
     REPL ARQGRUP->procpend WITH ARQGRUP->procpend + 1
    ENDI
    IF saiu<'001'.AND.PTAB(grup,'ARQGRUP',1)
     REPL ARQGRUP->partic WITH ARQGRUP->partic - 1
    ENDI
    IF PTAB(num,'GRUPOS',1)
     REPL GRUPOS->funerais WITH GRUPOS->funerais + 1
    ENDI
    IF PTAB(num,'GRUPOS',1)
     REPL GRUPOS->particv WITH GRUPOS->particv - 1
    ENDI
    IF PTAB(num,'GRUPOS',1)
     REPL GRUPOS->particf WITH GRUPOS->particf + 1
    ENDI
    IF PTAB(num+grau+STR(seq,02,00),'INSCRITS',1)
     REPL INSCRITS->vivofalec WITH [F]
    ENDI
    IF PTAB(num+grau+STR(seq,02,00),'INSCRITS',1)
     REPL INSCRITS->falecto_ WITH dfal
    ENDI
    IF PTAB(num+grau+STR(seq,02,00),'INSCRITS',1)
     REPL INSCRITS->tipo WITH categ
    ENDI
    IF PTAB(num+grau+STR(seq,02,00),'INSCRITS',1)
     REPL INSCRITS->procnr WITH processo
    ENDI
   #endi

   IF op_menu!=INCLUSAO
    RECA
   ENDI
  ENDI
 ENDI
ENDI
RETU

* \\ Final de PRCESSOS.PRG
€ JUROSá– JUROSCODEJUR_INCLCODEJUR_TELACODEJUR_GETSCODEJUR_GET1CODEC_ETEXTENDCODE	_SYMSTARTSYMSTARTSYMBOLSSYMBOLS_SYMENDSYMENDNULLBEGDATA_DATADATA_SYMPBDATA_SYMPDATA_SYMPEDATA_CONSTCONST_MSGMSG_BEGBSSBEGBSS_BSSBSS_ENDBSSENDBSSDGROUPû˜ @ó&˜ @T	º˜ @é(˜ @a	¬˜ @Ð
9˜ H  ÿ˜ h  Û˜ `@™˜ h  Ó˜ h  Ï˜ H  ë˜ H  ç˜ H €
 ADP_R101V–Þ  ADP_R101CODEREL_CABCODEC_ETEXTENDCODE	_SYMSTARTSYMSTARTSYMBOLSSYMBOLS_SYMENDSYMENDNULLBEGDATA_DATADATA_SYMPBDATA_SYMPDATA_SYMPEDATA_CONSTCONST_MSGMSG_BEGBSSBEGBSS_BSSBSS_ENDBSSENDBSSDGROUPÚ˜ @ ˜ @d²˜ H  ˜ h  	ç˜ ` 
Ä˜ h  ß˜ h  Û˜ H  ÷˜ H  ó˜ H ç˜ H  ë˜ H  ç˜ (  procedure r01801f9
/*
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
 \ Empresa.: PresServ Inform tica-Limeira (019)452.6623
 \ Programa: R01801F9.PRG
 \ Data....: 16-07-96
 \ Sistema.: Administradora de Funer rias
 \ Funcao..: codigo de barras do relat¢rio ADM_R018
 \ Analista: Ademilson Pedro Bom
 \ Criacao.: Programado manualmente pelo analistad
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/

#include "admbig.ch"    // inicializa constantes manifestas

 @ cl,001 say ' '+CHR(18)
 SETPRC(cl,1)               // retorna cabeca impressora
SET MARG TO                                        // coloca margem esquerda = 0
IMPCTL(lpp_066)                                    // seta pagina com 66 linhas
SET PRINTER TO (drvporta)                          // fecha arquivo gerado (se houver)
SET DEVI TO SCRE                                   // direciona saida p/ video
set printer to 'LPT1'
set devi to prin
cl:=prow()
 twinic()
 twdeflbars(2, 6)
 twdefprint(twepson)
 twdefalt(8)
 twdefcode(twc25)
 twdefsalto(12)
 @ cl,001 SAY ' ' + BARCODE(BXREC->codigo+BXREC->circ,15)
 lpp_004=LEFT(drvtapg,op_-1)+"004"+SUBS(drvtapg,op_+3)
 IMPCTL(lpp_004)                                    // seta pagina com 66 linhas
 cl:=Prow()
 @ cl,089 SAY chr(18)                 // normal
//@ cl+9,001 say '  '

RETU []      // <- deve retornar um valor qualquer

FUNCTION BARCODE
PARA vcod,SP_C
if pcount() = 0
 return ''
endif
vlin = 0
   k_ESC = CHR(27)
   vcop= 1
	    xcont= 0

*           twinic()
*           twdeflbars(2, 6)
*           twdefprint(twepson)
*           set device to printer

	    do while (xcont < vcop)
	       twdefsalto(8)
	       twdefalt(8)
	       twdefcode(twc25)

	       @ PRow() + 1,  SP_C say Space(1)

	       twdefalt(8)
	       twimpcod(vcod)
	       twdefsalto(8)
	       @ PRow() + 1,  SP_C say Space(1)

	       twdefalt(8)
	       twimpcod(vcod)
	       twdefsalto(8)
	       @ PRow() + 1,  SP_C say Space(1)

	       twdefalt(8)
	       twimpcod(vcod)
	       twdefsalto(12)

	       @ PRow() + 1,  SP_C say Space(1)

	       ***********
	       ****************
	       xcont=xcont+1
	       @ PRow() + vlin,  5 say Space(1)
	    enddo
	    * @ PRow() + 1,  5 say Space(1)
	    * set device to screen
	    return ''
* EOF
********************

procedure twinic
public twean13, twean8, twupca, twupce, twc25, twc39
public twepson, twlaser
public twcode, twprinter, twlbarf, twlbarg, twaltura, twround, twsource, twmaxalt
public twnulo, twmaxround
twean13 = 1
twean8 = 2
twupca = 3
twupce = 4
twc25 = 5
twc39 = 6
twepson = 1
twlaser = 2

twcode = twean13
twprinter = twepson
twlbarf = 1
twlbarg = 3
twaltura = 8
twround = 12
twsource = ''
twmaxalt = 3000
twmaxround = 100
twnulo = chr (0)
return

procedure twdefcode
parameters twcodetype
do case
   case twcodetype = twean13 .or. twcodetype = twean8 .or. twcodetype = twupca .or. twcodetype = twupce .or. twcodetype = twc25 .or. twcodetype = twc39
      twcode = twcodetype
endcase
return

procedure twdefprint
parameters twprinttyp
do case
   case twprinttyp = twepson .or. twprinttyp = twlaser
      twprinter = twprinttyp
endcase
return

procedure twdeflbars
parameters twfina, twgrossa
if twfina < 1
   twfina = 1
endif
if twgrossa >= twfina
   twlbarg = twgrossa
   twlbarf = twfina
endif
return

procedure twdefalt
parameters twalt
twaltura = twalt
if twaltura > twmaxalt
   twaltura = twmaxalt
endif
return

procedure twdefround
parameters twroundval
twround = twroundval
if twround > twmaxround
   twround = twmaxround
endif
return

procedure twdefsalto
parameters twsalto
@ prow (), pcol () say chr (27) + 'A' + chr (twsalto)
return

function twhpaltura
parameters twalt
return chr (27) + '*c' + transform (twalt, '9999') + 'B'

function twhpavanco
parameters twavanco
return chr (27) + '*p+' + transform (twavanco, '9999') + 'X'

procedure twajusta
if twprinter = twlaser
   @ prow (), pcol () say chr (27) + '&f0S' + chr (27) + '*p-30Y'
endif
return

procedure twrecup
if twprinter = twlaser
   @ prow (), pcol () say chr (27) + '&f1S'
endif
return

function twhpretang
parameters twavanco
return chr (27) + '*c' + transform (twavanco, '9999') + 'a0P' + twhpavanco (twavanco)

function twcalcdig
parameters twsrc
twk = 0
for twi = len (twsrc) to 1 step -1
   twj = val (substr (twsrc, twi, 1))
   if mod (len (twsrc) - twi, 2) = 0
      twj = twj * 3
   endif
   twk = twk + twj
next
twk = mod (10 - mod (twk, 10), 10)
return chr (twk + 48)

function twvalidnum
parameters twsrc, twsrclen
if twsrclen = 0
   twsrclen = len (twsrc)
endif
twflag = .t.
do while len (twsrc) < twsrclen
   twsrc = '0' + twsrc
enddo
for twi = 1 to twsrclen
   twflag = twflag .and. at (substr (twsrc, twi, 1), '0123456789') > 0
next
if twflag
   twsource = twsrc
endif
return twflag

function twvalidc39
parameters twsrc
if substr (twsrc, 1, 1) = '*'
   twsrc = substr (twsrc, 2, len (twsrc))
endif
if substr (twsrc, len (twsrc), 1) = '*'
   twsrc = substr (twsrc, 1, len (twsrc) - 1)
endif
twflag = .t.
for twi = 1 to len (twsrc)
   twflag = twflag .and. at (upper (substr (twsrc, twi, 1)), '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ- $/+%.') > 0
next
if twflag
   twsource = '*' + twsrc + '*'
endif
return twflag

function twvalid
parameters twsrc
twflag = .f.
twi = twcode
do case
   case twi = twean13
      twflag = twvalidnum (twsrc, 12)
      if twflag
	 twsource = twsource + twcalcdig (twsource)
      endif
   case twcode = twean8
      twflag = twvalidnum (twsrc, 7)
      if twflag
	 twsource = twsource + twcalcdig (twsource)
      endif
   case twcode = twupca
      twflag = twvalidnum (twsrc, 12)
      if twflag
	 twsource = twsource + twcalcdig (twsource)
      endif
   case twcode = twupce
      twflag = twvalidnum (twsrc, 7)
      if twflag
	 twsource = twsource + twcalcdig (twsource)
      endif
   case twcode = twc25
      twflag = twvalidnum (twsrc, 0)
      if twflag .and. mod (len (twsrc), 2) = 1
	 twsource = '0' + twsource
      endif
   case twcode = twc39
      twflag = twvalidc39 (twsrc)
endcase
return twflag

function twtam
parameters twsrc
twtamanho = 0
if twvalid (twsrc)
   do case
      case twcode = twean13
	 twtamanho = twlbarf * 95
      case twcode = twean8
	 twtamanho = twlbarf * 67
      case twcode = twupca
	 twtamanho = twlbarf * 95
      case twcode = twupce
	 twtamanho = twlbarf * 51
      case twcode = twc25
	 twtamanho = 6 * twlbarf + twlbarg + len (twsrc) * (3 * twlbarf + 2 * twlbarg)
      case twcode = twc39
	 twtamanho = (7 * twlbarf + 3 * twlbarg) * len (twsrc) - 1
      otherwise
	 twtamanho = 0
   endcase
endif
return twtamanho

function twtamr
parameters twsrc
twi = twtam (twsrc)
do while mod (twi, twround) != 0
   twi = twi + 1
enddo
return twi

function twtamchar
parameters twsrc
return int (twtamr (twsrc) / twround)

function tword39
parameters twchar
return at (upper (twchar), '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ-. $/+%*')

procedure twimpean13
private twalt [8]
private twcodigo1 [10], twcodigo2 [10], twcodigo3 [10], twtab7a12 [10]
twalt [1] = chr (255)
twalt [2] = chr (128)
twalt [3] = chr (192)
twalt [4] = chr (224)
twalt [5] = chr (240)
twalt [6] = chr (248)
twalt [7] = chr (252)
twalt [8] = chr (254)
twcodigo1 [1] = '0001101'
twcodigo1 [2] = '0011001'
twcodigo1 [3] = '0010011'
twcodigo1 [4] = '0111101'
twcodigo1 [5] = '0100011'
twcodigo1 [6] = '0110001'
twcodigo1 [7] = '0101111'
twcodigo1 [8] = '0111011'
twcodigo1 [9] = '0110111'
twcodigo1 [10] = '0001011'
twcodigo2 [1] = '0100111'
twcodigo2 [2] = '0110011'
twcodigo2 [3] = '0011011'
twcodigo2 [4] = '0100001'
twcodigo2 [5] = '0011101'
twcodigo2 [6] = '0111001'
twcodigo2 [7] = '0000101'
twcodigo2 [8] = '0010001'
twcodigo2 [9] = '0001001'
twcodigo2 [10] = '0010111'
twcodigo3 [1] = '1110010'
twcodigo3 [2] = '1100110'
twcodigo3 [3] = '1101100'
twcodigo3 [4] = '1000010'
twcodigo3 [5] = '1011100'
twcodigo3 [6] = '1001110'
twcodigo3 [7] = '1010000'
twcodigo3 [8] = '1000100'
twcodigo3 [9] = '1001000'
twcodigo3 [10] = '1110100'
twtab7a12 [1] = '111111'
twtab7a12 [2] = '221211'
twtab7a12 [3] = '212211'
twtab7a12 [4] = '122211'
twtab7a12 [5] = '221121'
twtab7a12 [6] = '211221'
twtab7a12 [7] = '112221'
twtab7a12 [8] = '212121'
twtab7a12 [9] = '122121'
twtab7a12 [10] = '121221'
do case
   case twprinter = twepson
      twsize = twtamr (twsource)
      twchar = twalt [mod (twaltura, 8) + 1]
      @ prow (), pcol () say chr (27) + 'L' + chr (mod (twsize, 256)) + chr (int (twsize / 256))
      @ prow (), pcol () say replicate (twchar, twlbarf) + replicate (twnulo, twlbarf) + replicate (twchar, twlbarf)
      twl = val (substr (twsource, 1, 1)) + 1
      for twi = 2 to 13
	 twj = val (substr (twsource, twi, 1)) + 1
	 for twk = 1 to 7
	    if twi <= 7
	       twm = 'TWCODIGO' + substr (twtab7a12 [twl], 8 - twi, 1)
	    else
	       twm = 'TWCODIGO3'
	    endif
	    if substr (&twm [twj], twk, 1) = '1'
	       @ prow (), pcol () say replicate (twchar, twlbarf)
	    else
	       @ prow (), pcol () say replicate (twnulo, twlbarf)
	    endif
	 next
	 if twi = 7
	    @ prow (), pcol () say replicate (twnulo, twlbarf)
	    @ prow (), pcol () say replicate (twchar, twlbarf)
	    @ prow (), pcol () say replicate (twnulo, twlbarf)
	    @ prow (), pcol () say replicate (twchar, twlbarf)
	    @ prow (), pcol () say replicate (twnulo, twlbarf)
	 endif
      next
      @ prow (), pcol () say replicate (twchar, twlbarf) + replicate (twnulo, twlbarf) + replicate (twchar, twlbarf)
      @ prow (), pcol () say replicate (twnulo, twsize - twtam (twsource))
   case twprinter = twlaser
      @ prow (), pcol () say twhpaltura (twaltura)
      @ prow (), pcol () say twhpretang (twlbarf) + twhpavanco (twlbarf) + twhpretang (twlbarf)
      twl = val (substr (twsource, 1, 1)) + 1
      for twi = 2 to 13
	 twj = val (substr (twsource, twi, 1)) + 1
	 for twk = 1 to 7
	    if twi <= 7
	       twm = 'TWCODIGO' + substr (twtab7a12 [twl], 8 - twi, 1)
	    else
	       twm = 'TWCODIGO3'
	    endif
	    if substr (&twm [twj], twk, 1) = '1'
	       @ prow (), pcol () say twhpretang (twlbarf)
	    else
	       @ prow (), pcol () say twhpavanco (twlbarf)
	    endif
	 next
	 if twi = 7
	    @ prow (), pcol () say twhpavanco (twlbarf)
	    @ prow (), pcol () say twhpretang (twlbarf)
	    @ prow (), pcol () say twhpavanco (twlbarf)
	    @ prow (), pcol () say twhpretang (twlbarf)
	    @ prow (), pcol () say twhpavanco (twlbarf)
	 endif
      next
      @ prow (), pcol () say twhpretang (twlbarf) + twhpavanco (twlbarf) + twhpretang (twlbarf)
endcase
return

procedure twimpean8
private twalt [8]
private twcodigo1 [10], twcodigo3 [10]
twalt [1] = chr (255)
twalt [2] = chr (128)
twalt [3] = chr (192)
twalt [4] = chr (224)
twalt [5] = chr (240)
twalt [6] = chr (248)
twalt [7] = chr (252)
twalt [8] = chr (254)
twcodigo1 [1] = '0001101'
twcodigo1 [2] = '0011001'
twcodigo1 [3] = '0010011'
twcodigo1 [4] = '0111101'
twcodigo1 [5] = '0100011'
twcodigo1 [6] = '0110001'
twcodigo1 [7] = '0101111'
twcodigo1 [8] = '0111011'
twcodigo1 [9] = '0110111'
twcodigo1 [10] = '0001011'
twcodigo3 [1] = '1110010'
twcodigo3 [2] = '1100110'
twcodigo3 [3] = '1101100'
twcodigo3 [4] = '1000010'
twcodigo3 [5] = '1011100'
twcodigo3 [6] = '1001110'
twcodigo3 [7] = '1010000'
twcodigo3 [8] = '1000100'
twcodigo3 [9] = '1001000'
twcodigo3 [10] = '1110100'
do case
   case twprinter = twepson
      twsize = twtamr (twsource)
      twchar = twalt [mod (twaltura, 8) + 1]
      @ prow (), pcol () say chr (27) + 'L' + chr (mod (twsize, 256)) + chr (int (twsize / 256))
      @ prow (), pcol () say replicate (twchar, twlbarf) + replicate (twnulo, twlbarf) + replicate (twchar, twlbarf)
      twl = val (substr (twsource, 1, 1)) + 1
      for twi = 1 to 8
	 twj = val (substr (twsource, twi, 1)) + 1
	 for twk = 1 to 7
	    if twi <= 4
	       twm = 'TWCODIGO1'
	    else
	       twm = 'TWCODIGO3'
	    endif
	    if substr (&twm [twj], twk, 1) = '1'
	       @ prow (), pcol () say replicate (twchar, twlbarf)
	    else
	       @ prow (), pcol () say replicate (twnulo, twlbarf)
	    endif
	 next
	 if twi = 4
	    @ prow (), pcol () say replicate (twnulo, twlbarf)
	    @ prow (), pcol () say replicate (twchar, twlbarf)
	    @ prow (), pcol () say replicate (twnulo, twlbarf)
	    @ prow (), pcol () say replicate (twchar, twlbarf)
	    @ prow (), pcol () say replicate (twnulo, twlbarf)
	 endif
      next
      @ prow (), pcol () say replicate (twchar, twlbarf) + replicate (twnulo, twlbarf) + replicate (twchar, twlbarf)
      @ prow (), pcol () say replicate (twnulo, twsize - twtam (twsource))
   case twprinter = twlaser
      @ prow (), pcol () say twhpaltura (twaltura)
      @ prow (), pcol () say twhpretang (twlbarf) + twhpavanco (twlbarf) + twhpretang (twlbarf)
      twl = val (substr (twsource, 1, 1)) + 1
      for twi = 1 to 8
	 twj = val (substr (twsource, twi, 1)) + 1
	 for twk = 1 to 7
	    if twi <= 4
	       twm = 'TWCODIGO1'
	    else
	       twm = 'TWCODIGO3'
	    endif
	    if substr (&twm [twj], twk, 1) = '1'
	       @ prow (), pcol () say twhpretang (twlbarf)
	    else
	       @ prow (), pcol () say twhpavanco (twlbarf)
	    endif
	 next
	 if twi = 4
	    @ prow (), pcol () say twhpavanco (twlbarf)
	    @ prow (), pcol () say twhpretang (twlbarf)
	    @ prow (), pcol () say twhpavanco (twlbarf)
	    @ prow (), pcol () say twhpretang (twlbarf)
	    @ prow (), pcol () say twhpavanco (twlbarf)
	 endif
      next
      @ prow (), pcol () say twhpretang (twlbarf) + twhpavanco (twlbarf) + twhpretang (twlbarf)
endcase
return

procedure twimpupca
private twalt [8]
private twcodigo1 [10], twcodigo3 [10]
twalt [1] = chr (255)
twalt [2] = chr (128)
twalt [3] = chr (192)
twalt [4] = chr (224)
twalt [5] = chr (240)
twalt [6] = chr (248)
twalt [7] = chr (252)
twalt [8] = chr (254)
twcodigo1 [1] = '0001101'
twcodigo1 [2] = '0011001'
twcodigo1 [3] = '0010011'
twcodigo1 [4] = '0111101'
twcodigo1 [5] = '0100011'
twcodigo1 [6] = '0110001'
twcodigo1 [7] = '0101111'
twcodigo1 [8] = '0111011'
twcodigo1 [9] = '0110111'
twcodigo1 [10] = '0001011'
twcodigo3 [1] = '1110010'
twcodigo3 [2] = '1100110'
twcodigo3 [3] = '1101100'
twcodigo3 [4] = '1000010'
twcodigo3 [5] = '1011100'
twcodigo3 [6] = '1001110'
twcodigo3 [7] = '1010000'
twcodigo3 [8] = '1000100'
twcodigo3 [9] = '1001000'
twcodigo3 [10] = '1110100'
do case
   case twprinter = twepson
      twsize = twtamr (twsource)
      twchar = twalt [mod (twaltura, 8) + 1]
      @ prow (), pcol () say chr (27) + 'L' + chr (mod (twsize, 256)) + chr (int (twsize / 256))
      @ prow (), pcol () say replicate (twchar, twlbarf) + replicate (twnulo, twlbarf) + replicate (twchar, twlbarf)
      twl = val (substr (twsource, 1, 1)) + 1
      for twi = 2 to 13
	 twj = val (substr (twsource, twi, 1)) + 1
	 for twk = 1 to 7
	    if twi <= 7
	       twm = 'TWCODIGO1'
	    else
	       twm = 'TWCODIGO3'
	    endif
	    if substr (&twm [twj], twk, 1) = '1'
	       @ prow (), pcol () say replicate (twchar, twlbarf)
	    else
	       @ prow (), pcol () say replicate (twnulo, twlbarf)
	    endif
	 next
	 if twi = 7
	    @ prow (), pcol () say replicate (twnulo, twlbarf)
	    @ prow (), pcol () say replicate (twchar, twlbarf)
	    @ prow (), pcol () say replicate (twnulo, twlbarf)
	    @ prow (), pcol () say replicate (twchar, twlbarf)
	    @ prow (), pcol () say replicate (twnulo, twlbarf)
	 endif
      next
      @ prow (), pcol () say replicate (twchar, twlbarf) + replicate (twnulo, twlbarf) + replicate (twchar, twlbarf)
      @ prow (), pcol () say replicate (twnulo, twsize - twtam (twsource))
   case twprinter = twlaser
      @ prow (), pcol () say twhpaltura (twaltura)
      @ prow (), pcol () say twhpretang (twlbarf) + twhpavanco (twlbarf) + twhpretang (twlbarf)
      twl = val (substr (twsource, 1, 1)) + 1
      for twi = 2 to 13
	 twj = val (substr (twsource, twi, 1)) + 1
	 for twk = 1 to 7
	    if twi <= 7
	       twm = 'TWCODIGO1'
	    else
	       twm = 'TWCODIGO3'
	    endif
	    if substr (&twm [twj], twk, 1) = '1'
	       @ prow (), pcol () say twhpretang (twlbarf)
	    else
	       @ prow (), pcol () say twhpavanco (twlbarf)
	    endif
	 next
	 if twi = 7
	    @ prow (), pcol () say twhpavanco (twlbarf)
	    @ prow (), pcol () say twhpretang (twlbarf)
	    @ prow (), pcol () say twhpavanco (twlbarf)
	    @ prow (), pcol () say twhpretang (twlbarf)
	    @ prow (), pcol () say twhpavanco (twlbarf)
	 endif
      next
      @ prow (), pcol () say twhpretang (twlbarf) + twhpavanco (twlbarf) + twhpretang (twlbarf)
endcase
return

procedure twimpupce
private twalt [8]
private twcodigo1 [10], twcodigo2 [10], twtab2a7 [10]
twalt [1] = chr (255)
twalt [2] = chr (128)
twalt [3] = chr (192)
twalt [4] = chr (224)
twalt [5] = chr (240)
twalt [6] = chr (248)
twalt [7] = chr (252)
twalt [8] = chr (254)
twcodigo1 [1] = '0001101'
twcodigo1 [2] = '0011001'
twcodigo1 [3] = '0010011'
twcodigo1 [4] = '0111101'
twcodigo1 [5] = '0100011'
twcodigo1 [6] = '0110001'
twcodigo1 [7] = '0101111'
twcodigo1 [8] = '0111011'
twcodigo1 [9] = '0110111'
twcodigo1 [10] = '0001011'
twcodigo2 [1] = '0100111'
twcodigo2 [2] = '0110011'
twcodigo2 [3] = '0011011'
twcodigo2 [4] = '0100001'
twcodigo2 [5] = '0011101'
twcodigo2 [6] = '0111001'
twcodigo2 [7] = '0000101'
twcodigo2 [8] = '0010001'
twcodigo2 [9] = '0001001'
twcodigo2 [10] = '0010111'
twtab2a7 [1] = '222111'
twtab2a7 [2] = '221211'
twtab2a7 [3] = '221121'
twtab2a7 [4] = '221112'
twtab2a7 [5] = '212211'
twtab2a7 [6] = '211221'
twtab2a7 [7] = '211122'
twtab2a7 [8] = '212121'
twtab2a7 [9] = '212112'
twtab2a7 [10] = '211212'
do case
   case twprinter = twepson
      twsize = twtamr (twsource)
      twchar = twalt [mod (twaltura, 8) + 1]
      @ prow (), pcol () say chr (27) + 'L' + chr (mod (twsize, 256)) + chr (int (twsize / 256))
      @ prow (), pcol () say replicate (twchar, twlbarf) + replicate (twnulo, twlbarf) + replicate (twchar, twlbarf)
      twl = val (substr (twsource, 8, 1)) + 1
      for twi = 2 to 7
	 twj = val (substr (twsource, twi, 1)) + 1
	 for twk = 1 to 7
	    twm = 'TWCODIGO' + substr (twtab2a7 [twl], twi - 1, 1)
	    if substr (&twm [twj], twk, 1) = '1'
	       @ prow (), pcol () say replicate (twchar, twlbarf)
	    else
	       @ prow (), pcol () say replicate (twnulo, twlbarf)
	    endif
	 next
      next
      @ prow (), pcol () say replicate (twnulo, twlbarf) + replicate (twchar, twlbarf)
      @ prow (), pcol () say replicate (twnulo, twlbarf) + replicate (twchar, twlbarf)
      @ prow (), pcol () say replicate (twnulo, twlbarf) + replicate (twchar, twlbarf)
      @ prow (), pcol () say replicate (twnulo, twsize - twtam (twsource))
   case twprinter = twlaser
      @ prow (), pcol () say twhpaltura (twaltura)
      @ prow (), pcol () say twhpretang (twlbarf) + twhpavanco (twlbarf) + twhpretang (twlbarf)
      twl = val (substr (twsource, 8, 1)) + 1
      for twi = 2 to 7
	 twj = val (substr (twsource, twi, 1)) + 1
	 for twk = 1 to 7
	    twm = 'TWCODIGO' + substr (twtab2a7 [twl], twi - 1, 1)
	    if substr (&twm [twj], twk, 1) = '1'
	       @ prow (), pcol () say twhpretang (twlbarf)
	    else
	       @ prow (), pcol () say twhpavanco (twlbarf)
	    endif
	 next
      next
      @ prow (), pcol () say twhpavanco (twlbarf) + twhpretang (twlbarf)
      @ prow (), pcol () say twhpavanco (twlbarf) + twhpretang (twlbarf)
      @ prow (), pcol () say twhpavanco (twlbarf) + twhpretang (twlbarf)
endcase
return

procedure twimpc25
private twalt [8]
private twcodigo [10]
twalt [1] = chr (255)
twalt [2] = chr (128)
twalt [3] = chr (192)
twalt [4] = chr (224)
twalt [5] = chr (240)
twalt [6] = chr (248)
twalt [7] = chr (252)
twalt [8] = chr (254)
twcodigo [1] = '00110'
twcodigo [2] = '10001'
twcodigo [3] = '01001'
twcodigo [4] = '11000'
twcodigo [5] = '00101'
twcodigo [6] = '10100'
twcodigo [7] = '01100'
twcodigo [8] = '00011'
twcodigo [9] = '10010'
twcodigo [10] = '01010'
do case
   case twprinter = twepson
      twsize = twtamr (twsource)
      twchar = twalt [mod (twaltura, 8) + 1]
      @ prow (), pcol () say chr (27) + 'L' + chr (mod (twsize, 256)) + chr (int (twsize / 256))
      @ prow (), pcol () say replicate (twchar, twlbarf) + replicate (twnulo, twlbarf) + replicate (twchar, twlbarf) + replicate (twnulo, twlbarf)
      for twi = 1 to len (twsource) / 2
	 twk = val (substr (twsource, twi * 2 - 1, 1)) + 1
	 twl = val (substr (twsource, twi * 2, 1)) + 1
	 for twj = 1 to 5
	    if substr (twcodigo [twk], twj, 1) = '1'
	       twm = twlbarg
	    else
	       twm = twlbarf
	    endif
	    if substr (twcodigo [twl], twj, 1) = '1'
	       twn = twlbarg
	    else
	       twn = twlbarf
	    endif
	    @ prow (), pcol () say replicate (twchar, twm) + replicate (twnulo, twn)
	 next
      next
      @ prow (), pcol () say replicate (twchar, twlbarg) + replicate (twnulo, twlbarf) + replicate (twchar, twlbarf)
      @ prow (), pcol () say replicate (twnulo, twsize - twtam (twsource))
   case twprinter = twlaser
      @ prow (), pcol () say twhpaltura (twaltura)
      @ prow (), pcol () say twhpretang (twlbarf) + twhpavanco (twlbarf) + twhpretang (twlbarf) + twhpavanco (twlbarf)
      for twi = 1 to int (len (twsource) / 2)
	 twk = val (substr (twsource, twi * 2 - 1, 1)) + 1
	 twl = val (substr (twsource, twi * 2, 1)) + 1
	 for twj = 1 to 5
	    if substr (twcodigo [twk], twj, 1) = '1'
	       twm = twlbarg
	    else
	       twm = twlbarf
	    endif
	    if substr (twcodigo [twl], twj, 1) = '1'
	       twn = twlbarg
	    else
	       twn = twlbarf
	    endif
	    @ prow (), pcol () say twhpretang (twm) + twhpavanco (twn)
	 next
      next
      @ prow (), pcol () say twhpretang (twlbarg) + twhpavanco (twlbarf) + twhpretang (twlbarf)
endcase
return

procedure twimpc39
private twalt [8]
private twcodigo [44]
twalt [1] = chr (255)
twalt [2] = chr (128)
twalt [3] = chr (192)
twalt [4] = chr (224)
twalt [5] = chr (240)
twalt [6] = chr (248)
twalt [7] = chr (252)
twalt [8] = chr (254)
twcodigo [1] = '000110100'
twcodigo [2] = '100100001'
twcodigo [3] = '001100001'
twcodigo [4] = '101100000'
twcodigo [5] = '000110001'
twcodigo [6] = '100110000'
twcodigo [7] = '001110000'
twcodigo [8] = '000100101'
twcodigo [9] = '100100100'
twcodigo [10] = '001100100'
twcodigo [11] = '100001001'
twcodigo [12] = '001001001'
twcodigo [13] = '101001000'
twcodigo [14] = '000011001'
twcodigo [15] = '100011000'
twcodigo [16] = '001011000'
twcodigo [17] = '000001101'
twcodigo [18] = '100001100'
twcodigo [19] = '001001100'
twcodigo [20] = '000011100'
twcodigo [21] = '100000011'
twcodigo [22] = '001000011'
twcodigo [23] = '101000010'
twcodigo [24] = '000010011'
twcodigo [25] = '100010010'
twcodigo [26] = '001010010'
twcodigo [27] = '000000111'
twcodigo [28] = '100000110'
twcodigo [29] = '001000110'
twcodigo [30] = '000010110'
twcodigo [31] = '110000001'
twcodigo [32] = '011000001'
twcodigo [33] = '111000000'
twcodigo [34] = '010010001'
twcodigo [35] = '110010000'
twcodigo [36] = '011010000'
twcodigo [37] = '010000101'
twcodigo [38] = '110000100'
twcodigo [39] = '011000100'
twcodigo [40] = '010101000'
twcodigo [41] = '010100010'
twcodigo [42] = '010001010'
twcodigo [43] = '000101010'
twcodigo [44] = '010010100'
do case
   case twprinter = twepson
      twsize = twtamr (twsource)
      twchar = twalt [mod (twaltura, 8) + 1]
      @ prow (), pcol () say chr (27) + 'L' + chr (mod (twsize, 256)) + chr (int (twsize / 256))
      for twi = 1 to len (twsource)
	 twj = tword39 (substr (twsource, twi, 1))
	 for twk = 1 to 9
	    if substr (twcodigo [twj], twk, 1) = '1'
	       twm = twlbarg
	    else
	       twm = twlbarf
	    endif
	    if mod (twk, 2) = 1
	       @ prow (), pcol () say replicate (twchar, twm)
	    else
	       @ prow (), pcol () say replicate (twnulo, twm)
	    endif
	 next
	 @ prow (), pcol () say replicate (twnulo, twlbarf)
      next
      @ prow (), pcol () say replicate (twnulo, twsize - twtam (twsource))
   case twprinter = twlaser
      @ prow (), pcol () say twhpaltura (twaltura)
      for twi = 1 to len (twsource)
	 twj = tword39 (substr (twsource, twi, 1))
	 for twk = 1 to 9
	    if substr (twcodigo [twj], twk, 1) = '1'
	       twm = twlbarg
	    else
	       twm = twlbarf
	    endif
	    if mod (twk, 2) = 1
	       @ prow (), pcol () say twhpretang (twm)
	    else
	       @ prow (), pcol () say twhpavanco (twm)
	    endif
	 next
	 @ prow (), pcol () say twhpavanco (twlbarf)
      next
endcase
return

procedure twimpcod
parameters twsrc
if twvalid (twsrc)
   twajusta ()
   do case
      case twcode = twean13
	 do twimpean13
      case twcode = twean8
	 do twimpean8
      case twcode = twupca
	 do twimpupca
      case twcode = twupce
	 do twimpupce
      case twcode = twc25
	 do twimpc25
      case twcode = twc39
	 do twimpc39
   endcase
   twrecup ()
endif
return


* \\ Final de R00102F9.PRG




RETU       // <- deve retornar um valor qualquer

* \\ Final de R01801F9.PRG
      SIxMemo                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 procedure bxr_06f9
/*
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
 \ Empresa.: PresServ Inform tica - Limeira (019)452.6623
 \ Programa: BXR_06F9.PRG
 \ Data....: 15-10-03
 \ Sistema.: Administradora - RECEP€„O
 \ Funcao..: Fun‡„o F8 do campo COBRANCA, arquivo BXREC
 \ Analista: Ademilson Pedro Bom
 \ Criacao.: Programado manualmente pelo analista
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/

#include "adrbig.ch"    // inicializa constantes manifestas
LOCAL reg_dbf:=POINTER_DBF()
PRIVA nopc:=1, respx:=space(30), ctx:=0
if op_menu#INCLUSAO
 retu .t.
endi
PTAB(LEFT(codigo,9),[TAXAS],1,.t.)
dele_atu:=SET(_SET_DELETED,.t.)                    // os excluidos nao servem...
nopc:=0
ctx:=0
msg_ins:=[]
msg_arr:={}
SELE TAXAS

 DO WHILE !EOF().AND.TAXAS->codigo=GRUPOS->codigo.AND.ctx<60
  IF DELE()
   SKIP
   LOOP
  ENDI
	vladd:=0
	IF EMPT(TAXAS->valorpg)
	 IF TAXAS->emissao_< DATE()
		jrok:=PTAB([],'JUROS',1)
		nrd:=(DATE() - TAXAS->emissao_)
		IF jrok .AND. (nrd > JUROS->mltcaren)
		 vladd+=TAXAS->valor*JUROS->multa/100
		ENDI
		IF jrok .AND. (nrd > JUROS->jrscaren)
		 vladd+=TAXAS->valor*JUROS->juros/100*nrd
		ENDI
	 ENDI
	ENDI
	/*
	msg_ins+=SUBSTR(TAXAS->codigo,11)+[ ]+DTOC(TAXAS->emissao_)+[ ]+;
			TRANSF(TAXAS->valor+M->vladd,"@E 99,999.99")+[ ]+DTOC(TAXAS->pgto_)+;
			TRANSF(TAXAS->valorpg,"@E 99,999.99")+[|]//+TAXAS->cobrador
	*/
	ctx++
/*
	AADD(msg_arr,{ TAXAS->cobranca+[ ]+DTOC(TAXAS->emissao_)+[ ]+;
			TRANSF(TAXAS->valor+M->vladd,"@E 99,999.99")+[ ]+DTOC(TAXAS->pgto_)+;
			TRANSF(TAXAS->valorpg,"@E 99,999.99")+[|],TAXAS->emissao_, TAXAS->valorpg } )
*/
	AADD(msg_arr,{ TAXAS->codigo+[ ]+DTOC(TAXAS->emissao_)+[ ]+;
			TRANSF(TAXAS->valor+M->vladd,"@E 99,999.99")+[ ]+DTOC(TAXAS->pgto_)+;
			TRANSF(TAXAS->valorpg,"@E 99,999.99")+[|],TAXAS->emissao_, TAXAS->valorpg } )

 SKIP
ENDD

POINTER_DBF(reg_dbf)
IF ctx>0
 ASORT(msg_arr,,,{ |x, y| x[2] < y[2] } )
 for ctx_x=1 to ctx
	msg_ins+=msg_arr[ctx_x] [1]
	IF msg_arr[ctx_x] [3]= 0.and.nopc=0
	 nopc=ctx_x
	ENDI
 next ctx_x
 msg_:=[Escolha a Parcela|Circ. Vencimento   Valor  Pagamento   Vlr.Pg]
 nopc:=DBOX(msg_ins,,,E_MENU,,msg_,,,nopc)
ENDI

IF LASTKEY()=K_ESC             // se teclou ESC
 RETU nil
ENDI
if nopc>0
 respx:=substr(msg_ins,(nopc-1)*57+1,56)
 tipo=left(respx,1)
 circ=substr(respx,3,3)
 valorpg=msg_arr[nopc] [3]
// respx:=LEFT(codigo,9)+respx
else
 respx:=[]
endi
SET(_SET_DELETED,dele_atu)                         // os excluidos serao vistos
RETU respx

* \\ Final de BXR_06F9.PRG
/*
Quem (nome/depto)
quando (data/hora)
pedido:
motivo da solicitacao/problema ocorrido:
Nr.Protocolo:
*/copy y.bat c:\vip4\x.bat /y
rmake adrbig
copy adrbig.exe c:\vip4
c:
cd\vip4
adrbig
GAS-Pro v2.0
011021014062001002001001013000176001
 Data Inicial:
 Data Final..:
[Ÿ]
[Ÿ]
 2 
 0 
Processar Pgto em
Processar Pgto em







056







 0 
 0 
-1 
-1 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
data1_
D
E
@D
 8 
 8 
 1 
 16 
 0 
Data Inicial

!EMPT(data1_)
Necess rio informar DATA INICIAL

Considerar a partir de...

 0 
 0 


data2_
D
E
@D
 8 
 8 
 2 
 16 
 0 
Data Final

!EMPT(data2_)
Necess rio informar DATA FINAL

At‚ a data ...

 0 
 0 


 0 
 0 
 0 
 0 
 0 
procedure contab1
/*
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
 \ Empresa.: PresServ Inform tica - Limeira (019)452.6623
 \ Programa: ADRBIG.PRG
 \ Data....: 29-06-98
 \ Sistema.: Administradora - RECEP€„O
 \ Funcao..: Gerenciador geral
 \ Analista: Ademilson Pedro Bom
 \ Criacao.: GAS-Pro v3.0 
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/
***************************************
public cod_ret   := 0            // Codigo de retorno da funcao hlleprot
cod_ret := hlleprot( "BIGVIP",;            // Nome cadastrado no HPROT.EXE - opcao Define
     "ADMCONESTFINFUNVIA BIGVIP",;  // Chave de prote‡„o cadastrada no HPROT
     "",;                  // Diret¢rio da onde est  a prote‡„o da aplicacao
     1,;                   // Atualizar controle se for copia com limites
     1 )                   // Controlar Licen‡as de uso em rede nesta chamada
if cod_ret <> 0
 ? HLMSGERR()
 ?
// return
 if dtos(DATE()) > [20020820]
  return
 endi
endif
****************************************

#include "adrbig.ch"    // inicializa constantes manifestas

/*
   Funcoes chamadas dentro de macros
*/

REQUEST DESCEND, MTAB, VDV2, VUF, MMAA, DLAPSO, GDV1, VHORA, NMES, EXT, GDV2
REQUEST VCGC, LTOC

#include "ADR_PUBL.ch"  // contem variaveis publicas

V0=SAVESCREEN(0,0,MAXROW(),79)
CLEA SCREEN

#ifdef COM_TUTOR
 PARAM arq_mac, acao_                        // recebe parametros
 acao_mac="D"                                // inicializa flag
 IF !EMPT(arq_mac) .AND. !EMPT(acao_)        // passou os dois paramentros
  acao_=UPPER(acao_)                         // acao em maiusculo
  IF SUBS(acao_,2,1)$'LGCA'.AND.LEN(acao_)=2 // acao e' valida?
   acao_=SUBS(acao_,2,1)                     // separa so a letra
   IF acao_ $ "LCA" .AND. !FILE(arq_mac)     // leitura, se o arq
    ALERTA(2)                                // nao existir vamos
    ? "Arquivo "+arq_mac+" n„o encontrado!"  // avisar e
    RETU                                     // voltar para os DOS
   ELSE
    IF acao_="G"                             // gravacao de tutorial
     IF FILE(arq_mac)                        // se o arq existir
      ALERTA(2)                              // pergunta se pode
      x="N"                                  // mata-lo...
      @ 10,20 SAY "Arquivo "+arq_mac+" j  existe sobrepor?" GET x PICT "!"
      READ
      CLEA SCREEN
			IF LASTKEY()=K_ESC .OR. x!="S"         // nao confirmou...
       ? "Execu‡„o interrompida!"            // da mensagem e
       RETU                                  // retorna para o DOS
      ENDI
      ERASE (arq_mac)                        // mata arq antigo
     ENDI
     handle_mac=FCREATE(arq_mac)             // cria um novo arq
    ELSE
     handle_mac=FOPEN(arq_mac,2)             // abre arq existente
    ENDI
    IF handle_mac=-1                         // se deu erro na abertura
     ? "N„o foi poss¡vel utilizar "+arq_mac  // avisa e
     RETU                                    // retorna
    ENDI
    fat_mac=5                                // fator de tempo default
    acao_mac=acao_                           // seta a acao da macro
   END IF
  END IF
 ENDI
#endi

NAOPISCA()                   // habilita 256 cores (ega/vga)

/*
   rotina utilizando funcoes em assembly  para pegar o nome do programa
   que e  colocado pelo DOS no PSP (Program Segment Prefix) do programa
   que esta  sendo executado. O segmento do ambiente esta  no  endereco
   44/45 do segmento do PSP
*/
VAL_AX("6200")               // funcao 62h retorna segmento do PSP em BX
CALLINT("21")                // executa interrupt 21
x=VAL_BX()                   // pega o segmento do PSP
Sg=PEEK(x,44)+PEEK(x,45)*256 // calcula endereco do segmento de ambiente

/*
   Agora, procura no segmento de ambiente, por dois bytes ZERO seguidos.
   O nome do programa comeca 2 bytes apos os ZEROs
*/
x=0
DO WHIL .t.
 IF PEEK(Sg,x)=0             // este e o primeiro ZERO
  IF PEEK(Sg,x+1)=0          // se o proximo tambem for,
   x+=2                      // entao pula ambos
   EXIT                      // e sai
  ENDI
 ENDI
 x++                         // continua procurando
ENDD
direxe=""
IF PEEK(Sg,x)=1              // se este byte = 1, entao
 x+=2                        // o nome comeca aqui e vai
 DO WHIL PEEK(Sg,x)>0        // at‚ encontrar outro 0
  direxe+=CHR(PEEK(Sg,x))    // pega mais uma letra do nome
  x++
 ENDD
ENDI
direxe=UPPER(LEFT(direxe,RAT("\",direxe)))
arq_sos=direxe+"ADRBIG.SOS"  // nome do arquivo de ajuda
SET CENTURY ON               // datas com informa‡„o do s‚culo DD/MM/AAAA
SETCANCEL(.f.)               // desativa ALT-C/BREAK
SET DATE BRIT                // datas no formato 'britasileiro`
SET EXAC OFF                 // comparacoes parciais habilitadas
SET SCOREBOARD OFF           // habilita uso da linha 0
SET WRAP ON                  // habilita rolagem de menus
SET KEY K_ALT_F2  TO doscom  // ALT-F2 ativa DOS-SHELL
SETKEY(K_INS,{||;            // muda tamanho do cursor quando inserindo
	      IF(READINSERT(),SETCURSOR(1),SETCURSOR(3)),;
	      READINSERT(!READINSERT());
	     };
)


/*
   inicializa variaveis publicas
*/
msg:=cpord:=criterio:=chv_rela:=chv_1:=chv_2:=vr_memo := ""
op_sis:=cod_sos:=nucop:=op_posi:=op_menu :=1
nss=33
exrot:=AFILL(ARRAY(nss),""); usuario=""
datac=DATE()
nao_mostra:=l_s:=c_s:=c_i:=l_i := 0
tem_borda:=drvexcl:=drvvisivel := .t.
v_out:=gr_rela:=ve_outros:=cn:=fgrep:=drvmouse :=.f.
tem_t:=fgconf:=drvconf:=brw:=drvincl :=.f.
gcr=CHR(17)+CHR(217); nivelop=3
drvcara=CHR(250); mold="ÚÄ¿³ÙÄÀ³ÃÄ´"
drvmenucen=.f.; drvfonte=3
drvporta="LPT1"
drvcortna="W/N*"; drvtittna="BG+/N*"
nemp="PresServ Inform tica - Limeira (019)452.6623"
nsis="Administradora - RECEP€„O"

#ifdef COM_MOUSE
 drvmouse=(MOUSE()>0)                   // verifica e inicializa mouse

 #ifdef COM_TUTOR
  IF acao_mac!="D"
   drvmouse=.f.
  ENDI
 #endi

 drvratH=8; drvratV=16                  // default da sensibilidade do mouse
 tpo_mouse=0
#endi

#ifdef COM_REDE
 ms_uso="Arquivo sendo acessado|COM EXCLUSIVIDADE"
#endi

#ifdef COM_LOCK
 pr_ok=__PPRJ(arq_sos,"ùÿäòäâûüäõáæñòë÷àêþú")
 IF LEN(pr_ok)>0
  CLEAR
  ? pr_ok
  RETU
 ENDI
#endi

arqgeral="CTB"

#ifdef COM_REDE

 #undef COM_PROTECAO

 drvtempo=25
 ide_maq=RIGHT(ALLTRIM(NETNAME()),4)    // tenta pegar nome da estacao
 IF EMPTY(ide_maq)                      // se netname() retornou nulo,
  ide_maq=LEFT(GETENV("ESTACAO"),4)     // tenta variavel de ambiente ESTACAO
 ENDI
 
 /*
    Se rede, e se NETNAME() do Clipper ou ESTACAO retornam "", pede ao usuario
    a identificacao da estacao para gravar arquivos de configuracoes
    especificos para cada usuario da rede
 */
 IF EMPTY(ide_maq)                 // CA-Clipper nao reconheceu nome da estacao
  cod_sos=49                       // nem existe variavel ambiental,
  msgt="IDENTIFICA€ŽO DA ESTA€ŽO"  // entao, vamos solicitar ao usuario
  SET KEY K_F1 TO                  // desativa help
  ide_maq=DBOX("Nome da esta‡„o",,,,,msgt,SPAC(4),"@!",,"W+/N")
  SET KEY K_F1 TO help             // habilita F1 (help)
  IF LASTKEY()=K_ESC .OR.;         // desistiu...
     EMPTY(ide_maq)                // ou nao informou
   RESTSCREEN(0,0,MAXROW(),79,v0)  // restaura tela
   SETPOS(MAXROW()-1,1)            // cursor na penultima linha, coluna 1
   RETU                            // e volta ao DOS
  ENDI
 ENDI
 ide_maq="_"+ALLTRIM(ide_maq)
#else
 ide_maq="_temp"                   // nome do arquivo de configuracoes
#endi

ntxpw=direxe+arqgeral+"PW"
dbfpw=ntxpw+".SYS"                 // nomes dos arquivos de senhas
arqconf=direxe+arqgeral+;          // nome do arquivo de configuracoes
	ide_maq+".sys"
IF FILE(arqconf)
 REST FROM (arqconf) ADDI          // restaura configuracoes gravadas


 #ifdef COM_MOUSE
  IF drvmouse
   drvmouse=(MOUSE()>0)            // verifica e inicializa mouse
   MOUSERAT(drvratH,drvratV)       // ajusta sensibilidade do mouse
  ENDI
 #else
  drvmouse=.f.
 #endi

 ******
 ntxpw=drverr+arqgeral+"PW"
 dbfpw=ntxpw+".SYS"                 // nomes dos arquivos de senhas
 ******

ELSE

 /*
    cria variaveis default de cores, codigos de impressao, etc...
 */
 drvmarca := "Padr„o IBM"                     // nome da configuracao/marca impressora
 drvprn =1                                    // configuracao atual
 drvpadrao="1"                                // padrao da impressora
 drvtapg="CHR(27)+'C'+CHR(NNN)"               // tamanho da pagina
 drvpcom="CHR(15)"                            // ativa comprimido (17,5 cpp)
 drvtcom="CHR(18)"                            // desativa comprimido (17,5 cpp)
 drvpc20="CHR(30)+'5'"                        // ativa comprimido (20 cpp)
 drvtc20="CHR(30)+'0'"                        // desativa comprimido (20 cpp)
 drvpeli="CHR(30)+'2'"                        // ativa elite
 drvteli="CHR(30)+'0'"                        // desativa elite
 drvpenf="CHR(27)+'E'"                        // ativa enfatizado
 drvtenf="CHR(27)+'F'"                        // desativa enfatizado
 drvpexp="CHR(27)+'W'+CHR(1)"                 // ativa expansao
 drvtexp="CHR(27)+'W'+CHR(0)"                 // desativa expansao
 drvpde8="CHR(27)+'0'"                        // ativa 8 lpp
 drvtde8="CHR(27)+'2'"                        // desativa 8 lpp
 drvland=""                                   // ativa landscape (paisagem)
 drvport=""                                   // ativa portrait (retrato)
 drvsom=.f.                                   // tipo de saida/efeitos sonoro
 drvautohelp=.f.                              // ajuda automatica em campos
 drvdbf:=drvntx:=drverr := PADR(QUALDIR(),23) // diretorio dos dbf's, ntx's e erros.dbf
 drvcorpad="W+/BG"  ; drvcorbox="W+/B"        // cores default
 drvcormsg="W+/W"   ; drvcorenf="W+/R"
 drvcorget="GR+/N*" ; drvcortel="W+/B"
 drvcorhlp="BG+/B"  ; drvcortna="W/N*"
 drvtitpad="GR+/BG" ; drvtitbox="GR+/B"       // cores dos titulos default
 drvtitmsg="GR+/W"  ; drvtitenf="GR+/R"
 drvtitget="R+/N*"  ; drvtittel="GR+/B"
 drvtithlp="GR+/B"  ; drvtittna="BG+/N*"
 drvultusu=LEFT(M->usuario,10)
 drvultval=0
 drvautent=.f.
 CBC1()
 ALERTA()
 cod_sos=2
 IF !PEGADIR(.t.)                  // se nao informou diretorios de trabalho
  RESTSCREEN(0,0,MAXROW(),79,v0)   // restaura tela
  SETPOS(MAXROW()-1,1)             // cursor na penultima linha, coluna 1
  RETU                             // de volta ao DOS
 ENDI
 ******
 ntxpw=drverr+arqgeral+"PW"
 dbfpw=ntxpw+".SYS"                 // nomes dos arquivos de senhas
 ******

 /*
    cria arquivo de senha e o inicializa com o primeiro usuario
 */
 IF !FILE(dbfpw)                    // nao encontrou arquivo de senhas,
  DBCREATE(dbfpw,{;                 // entao, cria estrutura
		  {"pass"       ,"C", 6,0},;
		  {"nome"       ,"C",15,0},;
		  {"nace"       ,"C", 1,0},;
		  {"exbxrec"    ,"C",20,0},;
			{"exalender"  ,"C",20,0},;
		  {"exobxec"    ,"C",20,0},;
		  {"exgrupos"   ,"C",20,0},;
		  {"extaxas"    ,"C",20,0},;
		  {"execob"     ,"C",20,0},;
		  {"exinscrits" ,"C",20,0},;
		  {"exguias"    ,"C",20,0},;
		  {"exafuner"   ,"C",20,0},;
		  {"extx2via"   ,"C",20,0},;
		  {"eximppar"   ,"C",20,0},;
		  {"exmedicos"  ,"C",20,0},;
		  {"extespec"   ,"C",20,0},;
		  {"exjuros"    ,"C",20,0},;
		  {"extfiliais" ,"C",20,0},;
		  {"exarqgrup"  ,"C",20,0},;
		  {"exfcgrupo"  ,"C",20,0},;
		  {"extxproc"   ,"C",20,0},;
		  {"exregiao"   ,"C",20,0},;
		  {"excobrador" ,"C",20,0},;
		  {"expcbrad"   ,"C",20,0},;
		  {"exfccob"    ,"C",20,0},;
		  {"exclasses"  ,"C",20,0},;
		  {"exclprods"  ,"C",20,0},;
		  {"excircular" ,"C",20,0},;
		  {"excprcirc"  ,"C",20,0},;
		  {"exprcessos" ,"C",20,0},;
		  {"exfncs"     ,"C",20,0},;
		  {"exhistoric" ,"C",20,0},;
		  {"excstseg"   ,"C",20,0},;
		  {"exmensag"   ,"C",20,0},;
		  {"exordpgrc"  ,"C",20,0},;
		  {"expar_adm"  ,"C",20,0};
		 };
  )

  #ifdef COM_REDE
   USEARQ(dbfpw,.t.,20,1,.f.)       // tenta abrir senhas, exclusivo
  #else
   USE (dbfpw)                      // abre arquivo de senhas
  #endi

  INDE ON pass TO (ntxpw)           // indexa pela password
  APPE BLAN                         // credencia usuario ficticio (1o. acesso)
  senha=PWORD(arqgeral)             // com senha = tres primeiras letras
  REPL nome WITH ENCRIPT(SPAC(15)),;
			 pass WITH senha, nace WITH ENCRIPT("3")
  USE
 ENDI
ENDI

#ifdef COM_TUTOR
 IF acao_mac!="D"
  drvmouse=.f.
 ENDI
#endi

arq_prn=drverr+"PRINTERS.DBF"            // nome dbf de "drivers" da prn
IF !FILE(arq_prn)                        // se o arquivo de "drivers"
 DBCREATE(arq_prn,{;                     // de impressoras nao existir
		   {"marca" ,"C",15,0},;  // entao vamos cria-lo
		   {"porta" ,"C", 4,0},;
		   {"padrao","C", 1,0},;
		   {"tapg"  ,"C",40,0},;
		   {"pcom"  ,"C",40,0},;
		   {"tcom"  ,"C",40,0},;
		   {"pc20"  ,"C",40,0},;
		   {"tc20"  ,"C",40,0},;
		   {"peli"  ,"C",40,0},;
		   {"teli"  ,"C",40,0},;
		   {"penf"  ,"C",40,0},;
		   {"tenf"  ,"C",40,0},;
		   {"pexp"  ,"C",40,0},;
		   {"texp"  ,"C",40,0},;
		   {"pde8"  ,"C",40,0},;
		   {"tde8"  ,"C",40,0},;
		   {"land"  ,"C",40,0},;
		   {"port"  ,"C",40,0};
		  };
 )

 #ifdef COM_REDE
  USEARQ(arq_prn,.t.,20,1,.f.)      // tenta abrir configuracoes, exclusivo
 #else
  USE (arq_prn)                     // abre arquivo de configuracoes
 #endi

 APPE BLAN                          // inclui uma configuracao
 REPL marca  WITH drvmarca,;        // marca da impressora
      porta  WITH drvporta,;        // porta de saida
      padrao WITH drvpadrao,;       // padrao da impressora
			tapg   WITH drvtapg,;         // tamanho da pagina
      pcom   WITH drvpcom,;         // ativa comprimido (17,5 cpp)
      tcom   WITH drvtcom,;         // desativa comprimido (17,5 cpp)
      pc20   WITH drvpc20,;         // ativa comprimido (20 cpp)
      tc20   WITH drvtc20,;         // desativa comprimido (20 cpp)
      peli   WITH drvpeli,;         // ativa elite
      teli   WITH drvteli,;         // desativa elite
      penf   WITH drvpenf,;         // ativa enfatizado
      tenf   WITH drvtenf,;         // desativa enfatizado
      pexp   WITH drvpexp,;         // ativa expansao
      texp   WITH drvtexp,;         // desativa expansao
      pde8   WITH drvpde8,;         // ativa 8 lpp
      tde8   WITH drvtde8,;         // desativa 8 lpp
      land   WITH drvland,;         // ativa landscape
      port   WITH drvport           // ativa portrait
 USE
ENDI
MUDAFONTE(drvfonte)                 // troca a fonte de caracteres
corcampo=drvtittel                  // cor "unselected"
SETCOLOR(drvcorpad+","+drvcorget+",,,"+corcampo)
SET(_SET_DELETED,!drvvisivel)       // visibilidade dos reg excluidos
CBC1()

/*
   se informado drive A para criar arquivo, previne preparo do disquete
*/
IF ASC(drvdbf)=65.OR.ASC(drvntx)=65 // informou drive A
 ALERTA()
 cod_sos=1
 op_a=DBOX("Disco pronto|Cancelar a opera‡„o",,,E_MENU,,"DISCO DE DADOS EM "+LEFT(drvdbf,1))
 IF op_a!=1
  RESTSCREEN(0,0,MAXROW(),79,v0)    // restaura tela
  SETPOS(MAXROW()-1,1)              // cursor na penultima linha, coluna 1
  RETU
 ENDI
ENDI
AFILL(sistema:=ARRAY(nss+1),{})     // enche sistema[] com vetores nulos
ADR_ATRI()                          // enche sistema[] com atributos dos arquivos
ADR_ATR1()
ADR_ATR2()

/*
   verifica qual subscricao do vetor SISTEMA corresponde ao arquivo
   aberto na area selecionada
*/
qualsis={|db_f|db_:=db_f,ASCAN(sistema,{|si|si[O_ARQUI]==db_})}

#ifdef COM_PROTECAO
 
 /*
    protege arquivo de dados contra acesso dBase e muda para "read-only"
    vamos comentar este "code block" ...
 */
 protdbf={|fg|pt:=fg,;                             // torna a flag visivel no proximo "code block"
	   tel_p:=SAVESCREEN(0,0,MAXROW(),79),;    // salva a tela
	   DBOX("Um momento!",,,,NAO_APAGA),;      // mensagem ao usuario
	   AEVAL(sistema,{|sis|;                   // executa o "code block" para cada
			   EDBF(drvdbf+;           // um dos arquivos do vetor sistema
				sis[O_ARQUI],pt);  // (se pt, desprotege; senao, protege)
			 };
	   ),;
	   RESTSCREEN(0,0,MAXROW(),79,tel_p);      // restaura a tela
	 }
#endi

IF !FILE(dbfpw)                                    // se nao existir arquivo de
 ALERTA()                                          // senhas, avisa
 DBOX("Arquivo de senhas ausente!",,,2)
 RESTSCREEN(0,0,MAXROW(),79,v0)                    // restaura a tela
 SETPOS(MAXROW()-1,1)                              // cursor na penultima linha, coluna 1
 RETU                                              // retorna ao DOS
ENDI

#ifdef COM_REDE
 IF ! USEARQ(dbfpw,.f.,20,1,.f.)                   // falhou abertura modo compartilhado,
  RESTSCREEN(0,0,MAXROW(),79,v0)                   // restaura tela
  SETPOS(MAXROW()-1,1)                             // cursor na penultima linha, coluna 1
  RETU                                             // retorna ao DOS
 ENDI
#else
 EDBF(dbfpw,.t.)                                   // desprotege arquivo de
 USE (dbfpw)                                       // senhas e o utiliza
#endi

IF !FILE(ntxpw+".idx")                             // se nao ha indice,
 INDE ON pass TO (ntxpw)                           // cria o arquivo indice
ENDI
SET INDE TO (ntxpw)
IF ASC(nace)>48 .AND. ASC(nace)<52                 // previne erro

 #ifdef COM_REDE
  IF !BLOARQ(3,.5)                                 // se nao conseguiu bloquear o arquivo,
   RESTSCREEN(0,0,MAXROW(),79,v0)                  // restaura tela
   SETPOS(MAXROW()-1,1)                            // cursor na penultima linha, coluna 1
   RETU                                            // retorna ao DOS
  ENDI
 #endi

 REPL ALL nace WITH ENCRIPT(nace),;                // manipulacao das senhas
	  nome WITH ENCRIPT(nome)                  // criptografando o nivel e nome

 #ifdef COM_REDE
  UNLOCK                                           // libera arquivo
 #endi

ENDI
cod_sos=15
COLORSELECT(COR_GET)
v1=SAVESCREEN(0,0,MAXROW(),79)
CAIXA(mold,10,22,14,58,440)
@ 11,30 SAY "INFORME A SUA SENHA"                  // monta janela para
@ 12,35 SAY "Þ      Ý"                             // solicitar a entrada
@ 13,26 SAY "ESC para recome‡ar/finalizar"         // da senha de acesso
cp_=1
DO WHIL .t.
 COLORSELECT(COR_GET)
 senha=PADR(PWORD(12,36),6)                        // recebe a senha do usuario
 COLORSELECT(COR_PADRAO)
 SEEK senha                                        // ve se esta' credenciado
 IF FOUND()                                        // OK!
  usuario=TRIM(DECRIPT(nome))                      // nome do usuario
  senhatu=senha                                    // sua senha
  nivelop=VAL(DECRIPT(nace))                       // seu nivel
  FOR t=1 TO nss                                   // exrot[] contera' as
   msg=sistema[t,O_ARQUI]                          // rotinas nao acessadas
   exrot[t]=ex&msg.                                // de cada subsistema
  NEXT
  IF nivelop>0.AND.nivelop<4                       // de 1 a 3...
   DBOX("Bom trabalho, "+usuario,13,45,2)          // boas vindas!
   EXIT                                            // use e abuse...
  ENDI
 ELSE
  IF cp_<2 .AND. !EMPTY(senha)                     // epa! senha invalida
   cp_++                                           // vamos dar outra chance
   ALERTA()                                        // estamos avisando!
	 DBOX("Senha inv lida!",,,1)
   COLORSELECT(COR_GET)
   @ 12,36 SAY SPAC(6)
  ELSE                                             // errou duas vezes!
   IF !EMPTY(senha)                                // se informou senha errada
    ALERTA()                                       // pode ser um E.T.
    DBOX("Usu rio n„o autorizado!",,,2)
   ENDI

   #ifndef COM_REDE
    EDBF(dbfpw,.f.)                                // protege o arquivo de senhas
   #endi

   #ifdef COM_PROTECAO
    EVAL(protdbf,.f.)                              // protege DBF
   #endi

   RESTSCREEN(0,0,MAXROW(),79,v0)                  // restaura tela,
   SETPOS(MAXROW()-1,1)                            // cursor na penultima linha, coluna 1
   MUDAFONTE(0)                                    // retorna com a fonte normal
   RETU                                            // e tchau!
  ENDI
 ENDI
ENDD
RESTSCREEN(0,0,MAXROW(),79,v1)                     // restaura tela
USE                                                // fecha o arquivo de senhas

#ifdef COM_PROTECAO
 EVAL(protdbf,.t.)                                 // desprotege DBFs
#endi

if adr_rx68()

 use f:\vip41\arquivos\bxrec
 ? " Fazendo c¢pia de seguranca"
 copy to f:\vip41\bxrold
 ? " Acrescentando arquivo temporario"
 appe from f:\vip41\bxrtmp
 set uniq on
 ? " Verificando as duplicidades"
 inde on ano+numero to bxrec
 copy to f:\vip41\bxrok
 use f:\vip41\bxrok
 ? " Reposicionando o arquivo correto"
 copy to f:\vip41\arquivos\bxrec
 ? " Procedimento de finaliza‡Æo"
endi

#ifndef COM_REDE
 EDBF(dbfpw,.f.)                                   // protege arquivo senhas
#endi

#ifdef COM_PROTECAO
 EVAL(protdbf,.f.)                                 // protege DBF
#endi

#ifdef COM_TUTOR
 IF acao_mac!="D"
  FCLOSE(handle_mac)
  acao_mac="D"
 END IF
#endi

RESTSCREEN(0,0,MAXROW(),79,v0)                     // s'imbora
SETPOS(MAXROW()-1,1)                               // e cursor na penultima linha, coluna 1
RETU                                               // volta ao DOS

* \\ Final de ADRBIG.PRG
procedure gru_01f9
/*
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
 \ Empresa.: PresServ Inform tica-Limeira (019)452.6623
 \ Programa: GRU_01F9.PRG
 \ Data....: 10-07-96
 \ Sistema.: Administradora de Funer rias
 \ Funcao..: Valida‡„o do campo CODIGO, arquivo GRUPOS
 \ Analista: Ademilson Pedro Bom
 \ Criacao.: Programado manualmente pelo analistaa
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/

#include "adrbig.ch"    // inicializa constantes manifestas

     LOCAL reg_dbf:=POINTER_DBF()
     PTAB('','ARQGRUP',1)
     SELE ARQGRUP
     DO WHILE ! EOF()
      IF ARQGRUP->final < M->codigo
       SKIP
       LOOP
      ENDIF
      IF ARQGRUP->inicio > M->codigo
       SKIP
       LOOP
      ENDIF
      M->grupo = ARQGRUP->grup
      EXIT
     ENDDO

     POINTER_DBF(reg_dbf)

RETU (!EMPT(M->grupo))   // <- deve retornar um valor L¢GICO

* \\ Final de GRU_01F9.PRG
GAS-Pro v4.0
002003024079001001002001003000142001






                     REQUERIMENTO DE RESTITUI€ŽO DE DESPESAS
                      FUNERAIS E TERMO DE RESPONSABILIDADE

                                                      Processo

   Nome do Contratante:

   Endere‡o:

     Cidade               Estado  Documento de Identidade Estado Civil


     Contrato    Grupo            Admiss„o                 Processo



    Nome do falecido....:
    Endere‡o do falecido:
    Inscrito neste contrato na qualidade de
    Data do Falecimento.:           Hor rio do Falecimento:

    Cidade do Falecimento Estado   Local do falecimento


    Cemit‚rio onde foi sepultado        Hora do sepultamento



                               DECLARA€ŽO




 PROCESSAR
PAGAMENTO EM



                     ------------------------------------------
                     Ass.:
                           RG:
[Ÿ]
 28 
AFUNER
Impress„o Aux.Funeral 1


PTAB(PADR(SUBSTR(M->ide_maq,2),4)+[AFU],[IMPPAR],1).and.processo+proc2+filial+categ=ALLTRIM(IMPPAR->docto)
011

























 0 
 1 










 0 
 1 
 0 
 66 
 0 
 9 
 3 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
-1 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
Nome do contratante
IIF(PTAB(contrato+GRUPOS->titular,'INSCRITS',1),INSCRITS->nome,GRUPOS->nome)
@!
 35 
C
 12 
 25 


û         










Nr.Processo
processo+proc2
@R 99999/99
 8 
C
 10 
 64 


û         










Endereco contratante
GRUPOS->endereco
@!
 40 
C
 14 
 14 


û         










cidade contratante
GRUPOS->cidade
@!
 20 
C
 17 
 6 


û         










Estado Contratante
[  ]
!!
 2 
C
 17 
 29 


          










Doc
GRUPOS->rg

 14 
C
 17 
 38 


û         










Est.Civil contratante
subst(tbestciv,AT(GRUPOS->estcivil,tbestciv),10)
@!
 11 
C
 17 
 60 


û         










contrato numero
contrato

 6 
C
 20 
 7 


û         










grupo
GRUPOS->grupo

 2 
C
 20 
 19 


û         










data admissao
GRUPOS->admissao

 8 
C
 20 
 35 


û         










pedido
R02001F9()

 70 
M
 21 
 2 


    û     










nome do falecido
falecido
@!
 35 
C
 23 
 27 


û         










Endereco falecido
ALLTRIM(ruares)+[, ]+ALLTRIM(baires)
@!
 40 
C
 24 
 27 


û         










Cidade Falecimento
municfal

 20 
C
 29 
 5 


û         










UF falecimento
estfal
!!
 2 
C
 29 
 29 


û         










local falecimento
ALLTRIM(ruafal)

 35 
C
 29 
 36 


û         










Cemit‚rio sepultamento
cemitsep

 30 
C
 32 
 5 


û         










Hora sepultamento
horasepult
99:99
 5 
C
 32 
 47 


û         










Inscrito na qualidade de
grauparcon

 15 
C
 25 
 45 


û         










Data falcto.
falecto_
@D
 8 
D
 26 
 27 


          










Hora Falcto.
horafal
99:99
 5 
C
 26 
 61 


          










DECLARACAO
R02002F9()

 70 
M
 36 
 3 


    û     










Proc.pagto em
procpagto_
@D
 8 
D
 42 
 3 


û         










Ident1
M->setup1

 40 
C
 6 
 22 


          










Categoria
IIF(categ=[PD],[Plano c/Difer. ],IIF(categ=[PL],[Atend.Plano],[Rest.Desp.Funerais]))

 18 
C
 1 
 2 


          










Nome
GRUPOS->nome

 35 
C
 46 
 28 


û         










R.G.
GRUPOS->rg
@!
 20 
C
 47 
 32 


          










DATA
IMPAC(RTRIM(M->p_cidade)+[, ]+LEFT(DTOC(DATE()),2)+[ de ]+NMES(MONTH(DATE()))+ [ de ]+LEFT(DTOS(DATE()),4))

 50 
C
 38 
 26 


          










 9 
Nome da empresa
nemp

 0 
 0 
 32 

T¡tulo aplica‡„o
nsis

 0 
 0 
 25 

Data do sistema
DTOC(DATE())

 0 
 0 
 8 

Nome do mˆs
NMES(DATE())

 0 
 0 
 8 

Dia da semana
NSEM(DATE())

 0 
 0 
 7 

N£mero da p gina
TRAN(pg_,'9999')

 0 
 0 
 4 

C¢digo relat¢rio
"ADM_R020"

 0 
 0 
 8 

T¡tulo a definir
titrel

 0 
 0 
 30 

Hora da emiss„o
hora_rel_

 0 
 0 
 5 

 0 
 0 
 0 
 2 
GRUPOS
 1 
contrato



INSCRITS
 1 
contrato



€
 ADR_MANU–ë  ADR_MANUCODE	HELP_PROCCODEMKINXCODEC_ETEXTENDCODE	_SYMSTARTSYMSTARTSYMBOLSSYMBOLS_SYMENDSYMENDNULLBEGDATA_DATADATA_SYMPBDATA_SYMPDATA_SYMPEDATA_CONSTCONST_MSGMSG_BEGBSSBEGBSS_BSSBSS_ENDBSSENDBSSDGROUP˜ @û˜ @=Ø˜ @˜ H  	˜ h  
ã˜ `°5˜ h  Û˜ h  ×˜ H  ó˜ H  ï˜ H ã˜ H  ç˜ H  GAS-Pro v4.0
008005018078001002002001010000176001
 Grupo...:     Circular:
 Mensagem:





 Confirme:
[Ÿ]
[Ÿ]
 8 
 0 
Cartinha de Processos
Cartinha de Processos







056
























 0 











 0 
 0 
-1 
-1 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
rgrupo
C
E
!!
 2 
 2 
 1 
 12 
 0 
Grupo

PTAB(rgrupo,'ARQGRUP',1).OR.EMPT(rgrupo)
GRUPO n„o existe na tabela|Informe um existente |ou|deixe sem preencher para listar todos

Circular de qual grupo?
VDBF(6,54,20,77,'ARQGRUP',{'grup','inicio','final'},1,'grup',[])
 0 
 0 


rcirc
C
E
999
 3 
 3 
 1 
 26 
 0 
Circular

PTAB(rgrupo+rcirc,'CIRCULAR',1).OR.EMPT(rcirc)
Necess rio informar CIRCULAR v lida

Informe o n£mero da circular a listar
VDBF(6,40,20,77,'CIRCULAR',{'grupo','circ','emissao_','valor'},1,'grupo',[grupo=rgrupo])
 0 
 0 


rmens1
C
E
@!
 70 
 70 
 3 
 2 
 0 
Mens1

 


Mensagem 1
Informe a linha 1/5 da cartinha
 0 
 0 


rmens2
C
E
@!
 70 
 70 
 4 
 2 
 0 
Mens2

 


Mensagem 2
Informe a linha 2/5 da cartinha
 0 
 0 


rmens3
C
E
@!
 70 
 70 
 5 
 2 
 0 
Mens3

 


Mensagem 3
Informe a linha 3/5 da cartinha
 0 
 0 


rmens4
C
E
@!
 70 
 70 
 6 
 2 
 0 
Mens4

 


Mensagem 4
Informe a linha 4/5 da cartinha
 0 
 0 


rmens5
C
E
@!
 70 
 70 
 7 
 2 
 0 
Mens5

 


Mensagem 5
Informe a linha 5/5 da cartinha
 0 
 0 


confirme
C
E
!
 1 
 1 
 8 
 12 
 0 
Confirme

confirme= 'S'
CONFIRME n„o aceit vel|Digite S ou Tecle ESC

Digite S para confirmar |ou|Tecle ESC para cancelar

 0 
 0 


 0 
 0 
 0 
 0 
 0 
BIF3 Ã$o B gàc  €‘   hx B
%dg¨~ ÿÿ  0} ¿Y!€*À ÿÿ  \@ ¿o€*À ÿÿ  th BY!€*À ÿÿ  Ø• Bö$Ù²à ÿÿ u¿t  i   1 ,¿Ò `j Y   ˜]B
%kl ÿÿ  ì]B%õF  ÿÿ  œ(B%õF8 ÿÿ  îB%õFP ÿÿ  $B%õF°	 ÿÿ  `ëB%õFÈ
 ÿÿ  À]B%õF 	 ÿÿ  ðPB%õF	 ÿÿ  ØGB%õFx	 ÿÿ  ØFB%õF	 ÿÿ  xÅB%öF¨	 ÿÿ  0«B%öFP
 ÿÿ  øÁB%öFh
 ÿÿ  ÄIB%öF€
 ÿÿ   KB%öF˜
 ÿÿ  LB%öF°
 ÿÿ  \HB
%llÈ
 ÿÿ  PGB%öFà
 ÿÿ  PEB%öFø
 ÿÿ  TCB%öF ÿÿ  $ÈB%÷F( ÿÿ  ŒB%÷F€
 OBX_01F9F–Ñ  OBX_01F9CODEC_ETEXTENDCODE	_SYMSTARTSYMSTARTSYMBOLSSYMBOLS_SYMENDSYMENDNULLBEGDATA_DATADATA_SYMPBDATA_SYMPDATA_SYMPEDATA_CONSTCONST_MSGMSG_BEGBSSBEGBSS_BSSBSS_ENDBSSENDBSSDGROUP˜ @n©˜ H  ˜ h  ë˜ `	]˜ h  
ã˜ h  ß˜ H  û˜ H  ÷˜ H ë˜ H  ï˜ H  ë˜ (  ˜ H  €
 R02002F9©–Ñ  R02002F9CODEC_ETEXTENDCODE	_SYMSTARTSYMSTARTSYMBOLSSYMBOLS_SYMENDSYMENDNULLBEGDATA_DATADATA_SYMPBDATA_SYMPDATA_SYMPEDATA_CONSTCONST_MSGMSG_BEGBSSBEGBSS_BSSBSS_ENDBSSENDBSSDGROUPh˜ @ë-˜ H  ˜ h  ë˜ `0 	¿˜ h  
ã˜ h  ß˜ H  û˜ H  ÷˜ H ë˜ H  ï˜ H  ë˜ (  ˜ H  .PRG.OBJ:
     CLIPPER $** /m
BX_BXREC.OBJ  : BX_BXREC.PRG

BX_BXREC.EXE:
     bLINKer @BX_BXREC.LNK
/*
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
 \ Empresa.: Ind£stria de Urnas Bignotto Ltda
 \ Programa: ADM_R023.PRG
 \ Data....: 21-10-96
 \ Sistema.: Administradora - RECEP€„O
 \ Funcao..: Outros recibos (2¦Via)
 \ Analista: Ademilson Pedro Bom
 \ Criacao.: GAS-Pro v3.0 
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/
#include "adrbig.ch"    // inicializa constantes manifestas

LOCAL dele_atu, so_um_reg, sit_dbf
PARA  lin_menu, col_menu, imp_reg
so_um_reg=(PCOU()>2)
IF so_um_reg
 sit_dbf=POINTER_DBF()
ENDI
nucop=1

#ifdef COM_REDE
 IF !USEARQ("OBXEC",.f.,10,1)                      // se falhou a abertura do arq
  RETU                                             // volta ao menu anterior
 ENDI
#else
 USEARQ("OBXEC")                                   // abre o dbf e seus indices
#endi

PTAB(codigo,"GRUPOS",3,.t.)                        // abre arquivo p/ o relacionamento
PTAB(GRUPOS->grupo,"ARQGRUP",1,.t.)
PTAB(GRUPOS->cobrador,"COBRADOR",1,.t.)
PTAB(GRUPOS->regiao,"REGIAO",1,.t.)
SET RELA TO codigo INTO GRUPOS,;                   // relacionamento dos arquivos
         TO GRUPOS->grupo INTO ARQGRUP,;
         TO GRUPOS->cobrador INTO COBRADOR,;
         TO GRUPOS->regiao INTO REGIAO
titrel:=criterio:=cpord := ""                      // inicializa variaveis
titrel:=chv_rela:=chv_1:=chv_2 := ""
tps:=op_x:=ccop := 1
arq_=drvporta                                      // porta de saida configurada
IF !so_um_reg
 IF !opcoes_rel(lin_menu,col_menu,8,11)            // nao quis configurar...
  CLOS ALL                                         // fecha arquivos e
  RETU                                             // volta ao menu
 ENDI

#ifdef COM_REDE

 ELSE

  tps=lin_menu

#endi

ENDI
IF tps=2                                           // se vai para arquivo/video
 arq_=ARQGER()                                     // entao pega nome do arquivo
 IF EMPTY(arq_)                                    // se cancelou ou nao informou
  RETU                                             // retorna
 ENDI
ELSE
 arq_=drvporta                                     // porta de saida configurada
ENDI
SET PRINTER TO (arq_)                              // redireciona saida
IF !EMPTY(drvtapg)                                 // existe configuracao de tam pag?
 op_=AT("NNN",drvtapg)                             // se o codigo que altera
 IF op_=0                                          // o tamanho da pagina
  msg="Configura‡„o do tamanho da p gina!"         // foi informado errado
  DBOX(msg,,,,,"ERRO!")                            // avisa
  CLOSE ALL                                        // fecha todos arquivos abertos
  RETU                                             // e cai fora...
 ENDI                                              // codigo para setar/resetar tam pag
 lpp_033=LEFT(drvtapg,op_-1)+"033"+SUBS(drvtapg,op_+3)
 lpp_066=LEFT(drvtapg,op_-1)+"066"+SUBS(drvtapg,op_+3)
ELSE
 lpp_033:=lpp_066 :=""                             // nao ira mudara o tamanho da pag
ENDI
DBOX("[ESC] Interrompe",15,,,NAO_APAGA)
dele_atu:=SET(_SET_DELETED,.t.)                    // os excluidos nao servem...
SET DEVI TO PRIN                                   // inicia a impressao
maxli=32                                           // maximo de linhas no relatorio
IMPCTL(lpp_033)                                    // seta pagina com 33 linhas
SET MARG TO 1                                      // ajusta a margem esquerda
IF tps=2
 IMPCTL("' '+CHR(8)")
ENDI
BEGIN SEQUENCE
 DO WHIL ccop<=nucop                               // imprime qde copias pedida
  pg_=1; cl=999
  IF so_um_reg
   GO imp_reg
  ELSE
   INI_ARQ()                                       // acha 1o. reg valido do arquivo
  ENDI
  ccop++                                           // incrementa contador de copias
  DO WHIL !EOF().AND.(!so_um_reg.OR.imp_reg=RECN())
   #ifdef COM_TUTOR
    IF IN_KEY()=K_ESC                              // se quer cancelar
   #else
    IF INKEY()=K_ESC                               // se quer cancelar
   #endi
    IF canc()                                      // pede confirmacao
     BREAK                                         // confirmou...
    ENDI
   ENDI
   IF (ano+numero=M->nrauxrec) .OR. so_um_reg      // se atender a condicao...
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY TRAN(M->nrauxrec,"@R 99-999999")  // N§ Recibo
    @ cl,050 SAY "Valor.:"
    IMPCTL(drvpenf)
    @ cl,058 SAY TRAN(valorpg,"@E 999,999.99")     // Valor
    IMPCTL(drvtenf)
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    IMPAC("Referˆnte.:",cl,000)
    IMPCTL(drvpenf)
    @ cl,014 SAY ref                               // Ref
    IMPCTL(drvtenf)
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY "Contrato..:"
    IMPCTL(drvpenf)
    @ cl,014 SAY GRUPOS->grupo +[  ]+codigo        // Grupo 1
    IMPCTL(drvtenf)
    @ cl,050 SAY "Data..:"
    @ cl,058 SAY TRAN(emitido_,"@D")               // data 1
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY "Nome......:"
    IMPCTL(drvpenf)
    @ cl,014 SAY GRUPOS->nome                      // Nome
    IMPCTL(drvtenf)
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    IMPAC("Endere‡o..:",cl,000)
    @ cl,014 SAY GRUPOS->endereco                  // Endere‡o
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY "Bairro....:"
    @ cl,014 SAY GRUPOS->bairro                    // Bairro
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY "Cid./Cobr.:"
    @ cl,014 SAY GRUPOS->cidade+[ ] +GRUPOS->cobrador// Cidade
    @ cl,052 SAY REPL("Ä",19)
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,052 SAY "Op:"
    @ cl,056 SAY LEFT(por,1)+LOWER(SUBSTR(por,2))  // operador
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY "Valor:"
    @ cl,007 SAY chr(15)+'('+SUBSTR(EXT(valorpg),1,AT('/',EXT(valorpg))-1)+')'+chr(18)// Valor Ext
    REL_CAB(2)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY REPL("Ä",71)
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    IMPEXP(cl,000,LEFT(M->setup1,35),70)           // 2 Ident1
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY M->setup2                         // 2 Ident 2
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY REPL("-",71)
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY TRAN(M->nrauxrec,"@R 99-999999")  // 2 N§ Recibo
    @ cl,050 SAY "Valor.:"
    IMPCTL(drvpenf)
    @ cl,058 SAY TRAN(valorpg,"@E 999,999.99")     // Valor pago
    IMPCTL(drvtenf)
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    IMPAC("Referˆnte.:",cl,000)
    IMPCTL(drvpenf)
    @ cl,012 SAY ref                               // Ref
    IMPCTL(drvtenf)
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY "Contrato..:"
    IMPCTL(drvpenf)
    @ cl,012 SAY GRUPOS->grupo +[  ]+codigo        // Grupo
    IMPCTL(drvtenf)
    @ cl,050 SAY "Data..:"
    @ cl,058 SAY TRAN(emitido_,"@D")               // Emitido em
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY "Nome......:"
    IMPCTL(drvpenf)
    @ cl,012 SAY GRUPOS->nome                      // Nome
    IMPCTL(drvtenf)
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    IMPAC("Endere‡o..:",cl,000)
    @ cl,012 SAY GRUPOS->endereco                  // Endere‡o
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY "Bairro....:"
    @ cl,012 SAY GRUPOS->bairro                    // Bairro
    @ cl,052 SAY REPL("Ä",19)
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY "Cid./Cobr.:"
    @ cl,012 SAY GRUPOS->cidade+[ ] +GRUPOS->cobrador// Cidade
    @ cl,052 SAY "Op:"
    @ cl,056 SAY LEFT(por,1)+LOWER(SUBSTR(por,2))  // Operador
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY "Valor:"
    @ cl,007 SAY chr(15)+'('+SUBSTR(EXT(valorpg),1,AT('/',EXT(valorpg))-1)+')'+chr(18)// Valor Ext
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    IF PTAB(codigo,'ALENDER',1)                    // pode imprimir?
     @ cl,007 SAY [Endere‡o alterado em ] +DTOC(ALENDER->data_)// Altera‡„o de Endere‡o
    ENDI
    SKIP                                           // pega proximo registro
    cl=999                                         // forca salto de pagina
   ELSE                                            // se nao atende condicao
    SKIP                                           // pega proximo registro
   ENDI
  ENDD
 ENDD ccop
 EJEC                                              // salta pagina
END SEQUENCE
SET MARG TO                                        // coloca margem esquerda = 0
IMPCTL(lpp_066)                                    // seta pagina com 66 linhas
SET PRINTER TO (drvporta)                          // fecha arquivo gerado (se houver)
SET DEVI TO SCRE                                   // direciona saida p/ video
IF tps=2                                           // se vai para arquivo/video
 BROWSE_REL(arq_,2,3,MAXROW()-2,78)
ENDI                                               // mostra o arquivo gravado
GRELA(8)                                           // grava variacao do relatorio
SELE OBXEC                                         // salta pagina
SET RELA TO                                        // retira os relacionamentos
SET(_SET_DELETED,dele_atu)                         // os excluidos serao vistos
IF so_um_reg
 POINTER_DBF(sit_dbf)
ENDI
RETU

STATIC PROC REL_CAB(qt)                            // cabecalho do relatorio
IF qt>0                                            // se parametro maior que 0
 cl=cl+qt                                          // soma no contador de linhas
ENDI
IF cl>maxli .OR. qt=0                              // quebra de pagina
 IMPEXP(0,000,LEFT(M->setup1,35),70)               // Ident1
 @ 1,000 SAY M->setup2                             // Ident2
 @ 2,000 SAY REPL("-",71)
 cl=qt+2 ; pg_++
ENDI
RETU

* \\ Final de ADM_R023.PRG
GAS-Pro v4.0
002003024079001007001001009000176001
                                                                       PAG

TRANSF.FINANCEIRO

N§ OP. Ori Hist DC  Val Lan‡to Documento    Complemento de Hist¢rico
-------------------------------------------------------------------------------
[Ÿ]
 7 
ORDPGRC
Fechamento Caixa


numconta==M->nrconta.AND.EMPT(fechto_)
011

























 0 
 1 










 0 
 2 
 0 
 66 
 0 
 6 
 3 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
-1 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
N§ OP.
numop+R03001F9()
999999
 6 
C
 7 
 1 


          










Ori
origem
!!!
 3 
C
 7 
 8 


          










Hist
historico
999
 3 
C
 7 
 12 


          










D/C
debcred
!
 1 
C
 7 
 17 


          










Val Lan‡to
valortotal * IIF(debcred='C',1,-1)
99999999.99
 11 
N
 7 
 20 


   û      










Documento
documento
@!
 12 
C
 7 
 32 


          










Complemento de Hist¢rico
complement
@!
 35 
C
 7 
 45 


          










 9 
Nome da empresa
nemp

 1 
 1 
 32 

T¡tulo aplica‡„o
nsis

 2 
 1 
 25 

Data do sistema
DTOC(DATE())

 3 
 72 
 8 

Nome do mˆs
NMES(DATE())

 0 
 0 
 8 

Dia da semana
NSEM(DATE())

 3 
 64 
 7 

N£mero da p gina
TRAN(pg_,'9999')

 1 
 76 
 4 

C¢digo relat¢rio
"ADM_R039"

 2 
 72 
 8 

T¡tulo a definir
titrel

 4 
 1 
 30 

Hora da emiss„o
hora_rel_

 0 
 0 
 5 

 2 
ORDPGRC
fechto_
DATE()

EMPT(fechto_)


ORDPGRC
fechpor
M->usuario

EMPT(fechpor)


 0 
 0 
 0 
/*
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
 \ Empresa.: PresServ Inform tica-Limeira (019)452.6623
 \ Programa: ADM_R023.PRG
 \ Data....: 27-06-97
 \ Sistema.: Administradora - RECEP€„O
 \ Funcao..: Outros recibos (2¦Via)
 \ Analista: Ademilson Pedro Bom
 \ Criacao.: GAS-Pro v3.0 
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/

#include "adrbig.ch"    // inicializa constantes manifestas

LOCAL dele_atu, getlist:={}, so_um_reg, sit_dbf:=POINTER_DBF()
PARA  lin_menu, col_menu, imp_reg, OBS2PRINT
PRIV  tem_borda:=.t., op_menu:=VAR_COMPL, l_s:=10, c_s:=20, l_i:=14, c_i:=61, tela_fundo:=SAVESCREEN(0,0,MAXROW(),79)
nucop=1
IF PCOU()<3
 OBS2PRINT=[]
ENDI
so_um_reg=(PCOU()>2)
IF !so_um_reg                             // vai receber a variaveis?
 IF nivelop < 2                                    // se usuario nao tem
  DBOX("Emiss„o negada, "+usuario,20)              // permissao, avisa
  RETU                                             // e retorna
 ENDI
 SETCOLOR(drvtittel)
 vr_memo=NOVAPOSI(@l_s,@c_s,@l_i,@c_i)    // pega posicao atual da tela
 CAIXA(mold,l_s,c_s,l_i,c_i)              // monta caixa da tela
 @ l_s,c_s+11 SAY " OUTROS RECEBIMENTOS "
 SETCOLOR(drvcortel)
 @ l_s+02,c_s+1 SAY " Numero..:"
 @ l_s+03,c_s+1 SAY " Confirme:"
ENDI
rnumero=SPAC(8)                                    // Numero
confirme=SPAC(1)                                   // Confirme
DO WHILE .t.
 rola_t=.f.
 cod_sos=56
 IF !so_um_reg
  SET KEY K_ALT_F8 TO ROLATELA
  SETCOLOR(drvcortel+","+drvcorget+",,,"+corcampo)
  @ l_s+02 ,c_s+12 GET  rnumero;
		   PICT "@R 99-999999";
		   VALI CRIT("PTAB(rnumero,'OBXEC',1)~Necess rio informar NUMERO|Tecle F8 para buscar em tabela")
                   DEFAULT "IIF(PTAB(UPPER(RIGHT(M->ide_maq,4))+[OBX],[IMPPAR],1),SUBSTR(IMPPAR->docto,3,6),[ ])"
                   AJUDA "N£mero do Recibo a emitir"
		   CMDF8 "VDBF(6,4,20,77,'OBXEC',{'numero','codigo','cobranca','valorpg','emitido_'},1,'numero',[])"

  @ l_s+03 ,c_s+12 GET  confirme;
                   PICT "!";
                   VALI CRIT("confirme='S'.AND.V02301F9()~CONFIRME n„o aceit vel|Digite S para confirmar|ou|Tecle ESC para cancelar")
                   AJUDA "Digite S para confirmar|ou|tecle ESC para cancelar"

  READ
  SET KEY K_ALT_F8 TO
  IF rola_t
   ROLATELA(.f.)
   LOOP
  ENDI
  IF LASTKEY()=K_ESC                               // se quer cancelar
   RETU                                            // retorna
  ENDI
 ENDI

 #ifdef COM_REDE
  IF !USEARQ("OBXEC",.f.,10,1)                     // se falhou a abertura do arq
   RETU                                            // volta ao menu anterior
  ENDI
 #else
  USEARQ("OBXEC")                                  // abre o dbf e seus indices
 #endi

 PTAB(codigo,"GRUPOS",1,.t.)                       // abre arquivo p/ o relacionamento
 PTAB(GRUPOS->grupo,"ARQGRUP",1,.t.)
 PTAB(GRUPOS->cobrador,"COBRADOR",1,.t.)
 PTAB(GRUPOS->regiao,"REGIAO",1,.t.)
 SET RELA TO codigo INTO GRUPOS,;                  // relacionamento dos arquivos
          TO GRUPOS->grupo INTO ARQGRUP,;
          TO GRUPOS->cobrador INTO COBRADOR,;
          TO GRUPOS->regiao INTO REGIAO
 titrel:=criterio:=cpord := ""                     // inicializa variaveis
 titrel:=chv_rela:=chv_1:=chv_2 := ""
 tps:=op_x:=ccop := 1
 arq_=drvporta                                     // porta de saida configurada
 IF !so_um_reg
  IF !opcoes_rel(lin_menu,col_menu,9,11)           // nao quis configurar...
   CLOS ALL                                        // fecha arquivos e
   LOOP                                            // volta ao menu
  ENDI

 #ifdef COM_REDE

  ELSE

   tps=lin_menu

 #endi

 ENDI
 IF tps=2                                          // se vai para arquivo/video
  arq_=ARQGER()                                    // entao pega nome do arquivo
  IF EMPTY(arq_)                                   // se cancelou ou nao informou
   LOOP                                            // retorna
  ENDI
 ELSE
  arq_=drvporta                                    // porta de saida configurada
 ENDI
 IF "4WIN"$UPPER(drvmarca) // nome da configuracao/marca impressora
    arq_:=drvdbf+"WIN"+ide_maq
    tps:=3                                          // se vai para arquivo/video
 ENDIF
 SET PRINTER TO (arq_)                             // redireciona saida
 EXIT
ENDD
IF !EMPTY(drvtapg)                                 // existe configuracao de tam pag?
 op_=AT("NNN",drvtapg)                             // se o codigo que altera
 IF op_=0                                          // o tamanho da pagina
  msg="Configura‡„o do tamanho da p gina!"         // foi informado errado
  DBOX(msg,,,,,"ERRO!")                            // avisa
  CLOSE ALL                                        // fecha todos arquivos abertos
  RETU                                             // e cai fora...
 ENDI                                              // codigo para setar/resetar tam pag
 lpp_033=LEFT(drvtapg,op_-1)+"033"+SUBS(drvtapg,op_+3)
 lpp_066=LEFT(drvtapg,op_-1)+"066"+SUBS(drvtapg,op_+3)
ELSE
 lpp_033:=lpp_066 :=""                             // nao ira mudara o tamanho da pag
ENDI
DBOX("[ESC] Interrompe",15,,,NAO_APAGA)
dele_atu:=SET(_SET_DELETED,.t.)                    // os excluidos nao servem...
SET DEVI TO PRIN                                   // inicia a impressao
maxli=32                                           // maximo de linhas no relatorio
IMPCTL(lpp_033)                                    // seta pagina com 33 linhas
SET MARG TO 1                                      // ajusta a margem esquerda
IF tps=2
 IMPCTL("' '+CHR(8)")
ENDI
BEGIN SEQUENCE
 DO WHIL ccop<=nucop                               // imprime qde copias pedida
  pg_=1; cl=999
  IF so_um_reg
   GO imp_reg
  ELSE
   INI_ARQ()                                       // acha 1o. reg valido do arquivo
  ENDI
  ccop++                                           // incrementa contador de copias
  IF PTAB(PADR(SUBSTR(M->ide_maq,2),4)+[OBX],[IMPPAR],1)
   SEEK ALLTRIM(IMPPAR->docto)
  ENDI
  DO WHIL !EOF().AND.(!so_um_reg.OR.imp_reg=RECN())
   #ifdef COM_TUTOR
    IF IN_KEY()=K_ESC                              // se quer cancelar
   #else
    IF INKEY()=K_ESC                               // se quer cancelar
   #endi
    IF canc()                                      // pede confirmacao
     BREAK                                         // confirmou...
    ENDI
   ENDI
   IF (PTAB(PADR(SUBSTR(M->ide_maq,2),4)+[OBX],[IMPPAR],1).AND.numero=LEFT(IMPPAR->docto,8)) .OR. so_um_reg// se atender a condicao...
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY TRAN(numero,"@R 99-999999")  // N§ Recibo
    @ cl,050 SAY "Valor.:"
    IMPCTL(drvpenf)
    @ cl,058 SAY TRAN(valorpg,"@E 999,999.99")     // Valor
    IMPCTL(drvtenf)
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    IMPAC("Referˆnte.:",cl,000)
    IMPCTL(drvpenf)
    @ cl,014 SAY cobranca                               // Ref
    IMPCTL(drvtenf)
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY "Contrato..:"
    IMPCTL(drvpenf)
    @ cl,014 SAY GRUPOS->grupo +[  ]+codigo        // Grupo 1
    IMPCTL(drvtenf)
    @ cl,050 SAY "Data..:"
    @ cl,058 SAY TRAN(emitido_,"@D")               // data 1
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY "Nome......:"
    IMPCTL(drvpenf)
    @ cl,014 SAY GRUPOS->nome                      // Nome
    IMPCTL(drvtenf)
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    IMPAC("Endere‡o..:",cl,000)
    @ cl,014 SAY GRUPOS->endereco                  // Endere‡o
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY "Bairro....:"
    @ cl,014 SAY GRUPOS->bairro                    // Bairro
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY "Cid./Cobr.:"
    @ cl,014 SAY GRUPOS->cidade+[ ] +GRUPOS->cobrador// Cidade
    @ cl,052 SAY REPL("Ä",19)
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,052 SAY "Op:"
    @ cl,056 SAY LEFT(por,1)+LOWER(SUBSTR(por,2))  // operador
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY "Valor:"
    IMPCTL(drvpcom)
    @ cl,007 SAY '('+SUBSTR(EXT(valorpg),1,AT('/',EXT(valorpg))-1)+')'// Valor Ext
    IMPCTL(drvtcom)
    REL_CAB(2)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY REPL("Ä",71)
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    IMPEXP(cl,000,LEFT(M->setup1,35),70)           // 2 Ident1
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY M->setup2                         // 2 Ident 2
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY REPL("-",71)
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY TRAN(numero,"@R 99-999999")  // 2 N§ Recibo
    @ cl,050 SAY "Valor.:"
    IMPCTL(drvpenf)
    @ cl,058 SAY TRAN(valorpg,"@E 999,999.99")     // Valor pago
    IMPCTL(drvtenf)
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    IMPAC("Referˆnte.:",cl,000)
    IMPCTL(drvpenf)
    @ cl,012 SAY cobranca                               // Ref
    IMPCTL(drvtenf)
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY "Contrato..:"
    IMPCTL(drvpenf)
    @ cl,012 SAY GRUPOS->grupo +[  ]+codigo        // Grupo
    IMPCTL(drvtenf)
    @ cl,050 SAY "Data..:"
    @ cl,058 SAY TRAN(emitido_,"@D")               // Emitido em
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY "Nome......:"
    IMPCTL(drvpenf)
    @ cl,012 SAY GRUPOS->nome                      // Nome
    IMPCTL(drvtenf)
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    IMPAC("Endere‡o..:",cl,000)
    @ cl,012 SAY GRUPOS->endereco                  // Endere‡o
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY "Bairro....:"
    @ cl,012 SAY GRUPOS->bairro                    // Bairro
    @ cl,052 SAY REPL("Ä",19)
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY "Cid./Cobr.:"
    @ cl,012 SAY GRUPOS->cidade+[ ] +GRUPOS->cobrador// Cidade
    @ cl,052 SAY "Op:"
    @ cl,056 SAY LEFT(por,1)+LOWER(SUBSTR(por,2))  // Operador
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY "Valor:"
    IMPCTL(drvpcom)
    @ cl,007 SAY '('+SUBSTR(EXT(valorpg),1,AT('/',EXT(valorpg))-1)+')'// Valor Ext
    IMPCTL(drvtcom)
    REL_CAB(1)                                     // soma cl/imprime cabecalho
/*
    IF PTAB(codigo,'ALENDER',1)                    // pode imprimir?
     @ cl,007 SAY [Endere‡o alterado em ] +DTOC(ALENDER->data_)// Altera‡„o de Endere‡o
    ENDI
*/
    IF PCOUNT()=4.AND.!empt(OBS2PRINT)
     @ cl,007 SAY [OBS: ] +OBS2PRINT
    ENDI
    SKIP                                           // pega proximo registro
    cl=999                                         // forca salto de pagina
   ELSE                                            // se nao atende condicao
    SKIP                                           // pega proximo registro
   ENDI
   EXIT
  ENDD
 ENDD ccop
 EJEC                                              // salta pagina
END SEQUENCE
SET MARG TO                                        // coloca margem esquerda = 0
IMPCTL(lpp_066)                                    // seta pagina com 66 linhas
SET PRINTER TO (drvporta)                          // fecha arquivo gerado (se houver)
SET DEVI TO SCRE                                   // direciona saida p/ video
IF tps=2                                           // se vai para arquivo/video
 BROWSE_REL(arq_,2,3,MAXROW()-2,78)
ENDI                                               // mostra o arquivo gravado
GRELA(9)                                           // grava variacao do relatorio
SELE OBXEC                                         // salta pagina
SET RELA TO                                        // retira os relacionamentos
SET(_SET_DELETED,dele_atu)                         // os excluidos serao vistos
IF so_um_reg
 POINTER_DBF(sit_dbf)
ENDI
RETU

STATIC PROC REL_CAB(qt)                            // cabecalho do relatorio
IF qt>0                                            // se parametro maior que 0
 cl=cl+qt                                          // soma no contador de linhas
ENDI
IF cl>maxli .OR. qt=0                              // quebra de pagina
 IMPEXP(0,000,LEFT(M->setup1,35),70)               // Ident1
 @ 1,000 SAY M->setup2                             // Ident2
 @ 2,000 SAY REPL("-",71)
 cl=qt+2 ; pg_++
ENDI
RETU

* \\ Final de ADM_R023.PRG
€
 RX2001F9‚–Ñ  RX2001F9CODEC_ETEXTENDCODE	_SYMSTARTSYMSTARTSYMBOLSSYMBOLS_SYMENDSYMENDNULLBEGDATA_DATADATA_SYMPBDATA_SYMPDATA_SYMPEDATA_CONSTCONST_MSGMSG_BEGBSSBEGBSS_BSSBSS_ENDBSSENDBSSDGROUPA˜ @æ3˜ H  ˜ h  ë˜ `  	O˜ h  
ã˜ h  ß˜ H  û˜ H  ÷˜ H ë˜ H  ï˜ H  ë˜ (  ˜ H  procedure adm_estr
/*
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
 \ Empresa.: PresServ Inform tica-Limeira (019)452.6623
 \ Programa: ADM_ESTR.PRG
 \ Data....: 29-09-96
 \ Sistema.: Administradora - RECEP€„O
 \ Funcao..: Cria estrutura dos arquivos
 \ Analista: Ademilson Pedro Bom
 \ Criacao.: GAS-Pro v2.0d
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/
#include "admbig.ch"    // inicializa constantes manifestas

PROC BXR_estr     // estrutura do arquivo BXREC
DBCREATE(dbf,{;
               {"ano"       ,"C",  2, 0},; // 99
               {"numero"    ,"C",  6, 0},; // 999999
               {"codigo"    ,"C",  6, 0},; // 999999
               {"tipo"      ,"C",  1, 0},; // !
               {"circ"      ,"C",  3, 0},; // 999
               {"valorpg"   ,"N",  9, 2},; // @E 999,999.99
               {"valoraux"  ,"N",  9, 2},; // @E 999,999.99
               {"emitido_"  ,"D",  8, 0},; // @D
               {"por"       ,"C", 10, 0},; // 
               {"numop"     ,"C",  6, 0},; // 999999
               {"grupo"     ,"C",  2, 0},; // !9
               {"intlan"    ,"C",  8, 0};  // 99999999
             };
)
RETU

PROC TXA_estr     // estrutura do arquivo TXACONTR
DBCREATE(dbf,{;
               {"codigo"    ,"C",  6, 0};  // 999999
             };
)
RETU

PROC TAX_estr     // estrutura do arquivo TAXAS
DBCREATE(dbf,{;
               {"codigo"    ,"C",  6, 0},; // 999999
               {"tipo"      ,"C",  1, 0},; // !
               {"circ"      ,"C",  3, 0},; // 999
               {"emissao_"  ,"D",  8, 0},; // @D
               {"valor"     ,"N",  9, 2},; // @E 999,999.99
               {"pgto_"     ,"D",  8, 0},; // @D
               {"valorpg"   ,"N",  9, 2},; // @E 999,999.99
               {"cobrador"  ,"C",  2, 0},; // !!
               {"forma"     ,"C",  1, 0},; // !
               {"baixa_"    ,"D",  8, 0},; // @D
               {"por"       ,"C", 10, 0},; // 
               {"stat"      ,"C",  1, 0},; // 9
               {"flag_excl" ,"C",  1, 0},; // !
               {"codlan"    ,"C", 20, 0};  // !!!-99999999-999-999
             };
)
RETU

PROC ALE_estr     // estrutura do arquivo ALENDER
DBCREATE(dbf,{;
               {"codigo"    ,"C",  6, 0},; // 999999
               {"endereco"  ,"C", 35, 0},; // @!
               {"bairro"    ,"C", 25, 0},; // @!
               {"cidade"    ,"C", 25, 0},; // @!
               {"cep"       ,"C",  8, 0},; // @R 99999-999
               {"data_"     ,"D",  8, 0},; // @D
               {"por"       ,"C", 10, 0},; // 
               {"dendereco" ,"C", 35, 0},; // @!
               {"dbairro"   ,"C", 25, 0},; // @!
               {"dcidade"   ,"C", 25, 0},; // @!
               {"dcep"      ,"C",  8, 0},; // @R 99999-999
               {"dgrupo"    ,"C",  2, 0},; // 
               {"emitido_"  ,"D",  8, 0};  // @D
             };
)
RETU

PROC OBX_estr     // estrutura do arquivo OBXEC
DBCREATE(dbf,{;
               {"ano"       ,"C",  2, 0},; // 99
               {"numero"    ,"C",  6, 0},; // 999999
               {"codigo"    ,"C",  6, 0},; // 999999
               {"ref"       ,"C", 25, 0},; // @S23
               {"valorpg"   ,"N",  9, 2},; // @E 999,999.99
               {"valoraux"  ,"N",  9, 2},; // @E 999,999.99
               {"emitido_"  ,"D",  8, 0},; // @D
               {"por"       ,"C", 10, 0},; // 
               {"numop"     ,"C",  6, 0},; // 999999
               {"grupo"     ,"C",  2, 0},; // !9
               {"intlan"    ,"C",  8, 0};  // 99999999
             };
)
RETU

PROC AFU_estr     // estrutura do arquivo AFUNER
DBCREATE(dbf,{;
               {"processo"  ,"C",  5, 0},; // 99999
               {"proc2"     ,"C",  2, 0},; // 99
               {"ocorr_"    ,"D",  8, 0},; // @D
               {"contrato"  ,"C",  6, 0},; // 999999
               {"grauparcon","C", 10, 0},; // 
               {"nomedec"   ,"C", 35, 0},; // @!
               {"ruadec"    ,"C", 35, 0},; // @!
               {"fonedec"   ,"C", 14, 0},; // @!
               {"codigofal" ,"C", 11, 0},; // 
               {"falecido"  ,"C", 35, 0},; // 
               {"ruares"    ,"C", 30, 0},; // 
               {"baires"    ,"C", 25, 0},; // 
               {"munres"    ,"C", 25, 0},; // 
               {"estres"    ,"C",  2, 0},; // !!
               {"nascto_"   ,"D",  8, 0},; // @D
               {"falecto_"  ,"D",  8, 0},; // @D
               {"horafal"   ,"C",  5, 0},; // 99:99
               {"ruafal"    ,"C", 30, 0},; // 
               {"municfal"  ,"C", 25, 0},; // 
               {"estfal"    ,"C",  2, 0},; // !!
               {"sepult_"   ,"D",  8, 0},; // @D
               {"horasepult","C",  5, 0},; // 99:99
               {"cemitsep"  ,"C", 30, 0},; // 
               {"funcresp"  ,"C",  3, 0},; // 999
               {"procpagto_","D",  8, 0},; // @D
               {"vlauxilio" ,"N", 14, 2},; // 99999999999.99
               {"pagtoem_"  ,"D",  8, 0},; // @D
               {"intlan"    ,"C",  8, 0};  // 99999999
             };
)
RETU

PROC ARQ_estr     // estrutura do arquivo ARQGRUP
DBCREATE(dbf,{;
               {"grup"      ,"C",  2, 0},; // !9
               {"classe"    ,"C",  2, 0},; // 99
               {"inicio"    ,"C",  6, 0},; // 999999
               {"final"     ,"C",  6, 0},; // 999999
               {"acumproc"  ,"N",  2, 0},; // 99
               {"periodic"  ,"N",  3, 0},; // 999
               {"qtdremir"  ,"N",  2, 0},; // 99
               {"ultcirc"   ,"C",  3, 0},; // 999
               {"emissao_"  ,"D",  8, 0},; // @D
               {"procpend"  ,"N",  3, 0},; // 999
               {"contrat"   ,"N",  6, 0},; // 999999
               {"partic"    ,"N",  6, 0},; // 999999
               {"proxcirc"  ,"C",  3, 0};  // 999
             };
)
RETU

PROC CLA_estr     // estrutura do arquivo CLASSES
DBCREATE(dbf,{;
               {"classcod"  ,"C",  2, 0},; // 99
               {"descricao" ,"C", 35, 0},; // @!
               {"contrat"   ,"N",  6, 0},; // 999999
               {"prior"     ,"C",  1, 0},; // !
               {"vljoia"    ,"N", 11, 2},; // 99999999.99
               {"nrparc"    ,"N",  2, 0},; // 99
               {"vlmensal"  ,"N", 11, 2},; // 99999999.99
               {"vldepend"  ,"N", 11, 2},; // 99999999.99
               {"nrmesval"  ,"N",  2, 0},; // 99
               {"renvenc"   ,"C",  1, 0},; // !
               {"renuso"    ,"C",  1, 0},; // !
               {"vltotal"   ,"N", 11, 2};  // @E 99,999,999.99
             };
)
RETU

PROC CLP_estr     // estrutura do arquivo CLPRODS
DBCREATE(dbf,{;
               {"classcod"  ,"C",  2, 0},; // 99
               {"codigo"    ,"C",  4, 0},; // 9999
               {"qtdade"    ,"N",  4, 0},; // 9999
               {"data"      ,"D",  8, 0},; // @D
               {"por"       ,"C", 10, 0},; // 
               {"flag_excl" ,"C",  1, 0};  // !
             };
)
RETU

PROC REG_estr     // estrutura do arquivo REGIAO
DBCREATE(dbf,{;
               {"codigo"    ,"C",  3, 0},; // 999
               {"regiao"    ,"C", 30, 0},; // 
               {"cobrador"  ,"C",  2, 0};  // !!
             };
)
RETU

PROC CIR_estr     // estrutura do arquivo CIRCULAR
DBCREATE(dbf,{;
               {"grupo"     ,"C",  2, 0},; // !9
               {"circ"      ,"C",  3, 0},; // 999
               {"procpend"  ,"N",  2, 0},; // 99
               {"emissao_"  ,"D",  8, 0},; // @D
               {"mesref"    ,"C",  4, 0},; // @R 99/99
               {"valor"     ,"N",  9, 2},; // @E 999,999.99
               {"menscirc"  ,"C", 60, 0},; // @S30@!
               {"emitidos"  ,"N",  6, 0},; // 999999
               {"pagos"     ,"N",  6, 0},; // 999999
               {"cancelados","N",  6, 0},; // 999999
               {"lancto_"   ,"D",  8, 0},; // @D
               {"funcionar" ,"C", 10, 0},; // 
               {"impress_"  ,"D",  8, 0};  // @D
             };
)
RETU

PROC CPR_estr     // estrutura do arquivo CPRCIRC
DBCREATE(dbf,{;
               {"grupo"     ,"C",  2, 0},; // !9
               {"circ"      ,"C",  3, 0},; // 999
               {"processo"  ,"C",  9, 0},; // @R 99999/99/!!
               {"categ"     ,"C",  2, 0},; // !!
               {"num"       ,"C",  5, 0},; // 99999
               {"fal"       ,"C", 35, 0},; // @!
               {"ends"      ,"C", 40, 0},; // @!
               {"cids"      ,"C", 15, 0},; // @!
               {"dfal"      ,"D",  8, 0},; // @D
               {"flag_excl" ,"C",  1, 0};  // !
             };
)
RETU

PROC COB_estr     // estrutura do arquivo COBRADOR
DBCREATE(dbf,{;
               {"cobrador"  ,"C",  2, 0},; // !!
               {"funcao"    ,"C",  1, 0},; // !
               {"nome"      ,"C", 30, 0},; // 
               {"endereco"  ,"C", 30, 0},; // 
               {"bairro"    ,"C", 20, 0},; // 
               {"cidade"    ,"C", 25, 0},; // 
               {"telefone"  ,"C", 14, 0},; // 
               {"cpf"       ,"C", 11, 0},; // @R 999.999.999-99
               {"obs"       ,"M", 10, 0},; // @S35
               {"percent"   ,"N",  5, 1};  // 999.9
             };
)
RETU

PROC FCC_estr     // estrutura do arquivo FCCOB
DBCREATE(dbf,{;
               {"cobrador"  ,"C",  2, 0},; // !!
               {"mesref"    ,"C",  4, 0},; // @R 99/99
               {"qtdemit"   ,"N",  6, 0},; // 999999
               {"qtdpaga"   ,"N",  6, 0},; // 999999
               {"qtdret"    ,"N",  6, 0},; // 999999
               {"vlentr"    ,"N",  9, 2},; // @E 999,999.99
               {"vlreceb"   ,"N",  9, 2},; // @E 999,999.99
               {"vlretorn"  ,"N",  9, 2},; // @E 999,999.99
               {"flag_excl" ,"C",  1, 0};  // !
             };
)
RETU

PROC PRC_estr     // estrutura do arquivo PRCESSOS
DBCREATE(dbf,{;
               {"processo"  ,"C",  9, 0},; // @R 99999/99/!!
               {"categ"     ,"C",  2, 0},; // !!
               {"saiu"      ,"C",  3, 0},; // 
               {"grup"      ,"C",  2, 0},; // !9
               {"num"       ,"C",  5, 0},; // 99999
               {"grau"      ,"C",  1, 0},; // 9
               {"seq"       ,"N",  2, 0},; // 99
               {"seg"       ,"C", 35, 0},; // @!
               {"ends"      ,"C", 40, 0},; // @!
               {"cids"      ,"C", 15, 0},; // @!
               {"fal"       ,"C", 35, 0},; // @!
               {"sep"       ,"C", 35, 0},; // @!
               {"dfal"      ,"D",  8, 0},; // @D
               {"codlan"    ,"C", 20, 0};  // !!!-99999999-999-999
             };
)
RETU

PROC GRU_estr     // estrutura do arquivo GRUPOS
DBCREATE(dbf,{;
               {"codigo"    ,"C",  6, 0},; // 999999
               {"grupo"     ,"C",  2, 0},; // !9
               {"situacao"  ,"C",  1, 0},; // 9
               {"nome"      ,"C", 35, 0},; // 
               {"nascto_"   ,"D",  8, 0},; // @D
               {"estcivil"  ,"C",  2, 0},; // !!
               {"cpf"       ,"C", 11, 0},; // @R 999.999.999-99
               {"rg"        ,"C", 20, 0},; // @!
               {"endereco"  ,"C", 35, 0},; // 
               {"bairro"    ,"C", 20, 0},; // 
               {"cidade"    ,"C", 25, 0},; // 
               {"cep"       ,"C",  8, 0},; // @R 99999-999
               {"contato"   ,"C", 25, 0},; // @!
               {"tipcont"   ,"C",  2, 0},; // 99
               {"vlcarne"   ,"C",  3, 0},; // 
               {"formapgto" ,"C",  2, 0},; // 99
               {"seguro"    ,"N",  2, 0},; // 
               {"admissao"  ,"D",  8, 0},; // @D
               {"tcarencia" ,"D",  8, 0},; // @D
               {"saitxa"    ,"C",  4, 0},; // @R 99/99
               {"vendedor"  ,"C",  2, 0},; // !!
               {"regiao"    ,"C",  3, 0},; // 999
               {"cobrador"  ,"C",  2, 0},; // !!
               {"obs"       ,"M", 10, 0},; // @S35
               {"renovar"   ,"D",  8, 0},; // @D
               {"funerais"  ,"N",  2, 0},; // 99
               {"circinic"  ,"C",  3, 0},; // 999
               {"ultcirc"   ,"C",  3, 0},; // 999
               {"qtcircs"   ,"N",  3, 0},; // 999
               {"qtcircpg"  ,"N",  3, 0},; // 999
               {"titular"   ,"C",  3, 0},; // 
               {"particv"   ,"N",  2, 0},; // 99
               {"particf"   ,"N",  2, 0},; // 99
               {"nrdepend"  ,"N",  2, 0},; // 99
               {"ultimp_"   ,"D",  8, 0},; // @D
               {"ender_"    ,"D",  8, 0},; // @D
               {"ultend"    ,"C", 10, 0};  // 
             };
)
RETU

PROC INS_estr     // estrutura do arquivo INSCRITS
DBCREATE(dbf,{;
               {"codigo"    ,"C",  6, 0},; // 999999
               {"grau"      ,"C",  1, 0},; // 9
               {"seq"       ,"N",  2, 0},; // 99
               {"ehtitular" ,"C",  1, 0},; // !
               {"nome"      ,"C", 35, 0},; // 
               {"nascto_"   ,"D",  8, 0},; // @D
               {"estcivil"  ,"C",  2, 0},; // 
               {"interdito" ,"C",  1, 0},; // !
               {"sexo"      ,"C",  1, 0},; // !
               {"tcarencia" ,"D",  8, 0},; // @D
               {"lancto_"   ,"D",  8, 0},; // @D
               {"vivofalec" ,"C",  1, 0},; // !
               {"falecto_"  ,"D",  8, 0},; // @D
               {"tipo"      ,"C",  3, 0},; // !!!
               {"procnr"    ,"C",  7, 0},; // @R 99999/99
               {"por"       ,"C", 10, 0},; // 
               {"flag_excl" ,"C",  1, 0};  // !
             };
)
RETU

PROC FNC_estr     // estrutura do arquivo FNCS
DBCREATE(dbf,{;
               {"codigo"    ,"C",  3, 0},; // 
               {"nome"      ,"C", 35, 0},; // @!
               {"profiss"   ,"C", 15, 0},; // @!
               {"nacional"  ,"C", 15, 0},; // @!
               {"estciv"    ,"C",  2, 0},; // !A
               {"nascto_"   ,"D",  8, 0},; // @D
               {"endereco"  ,"C", 30, 0},; // @!
               {"bairro"    ,"C", 25, 0},; // @!
               {"cidade"    ,"C", 25, 0},; // @!
               {"cpf"       ,"C", 11, 0},; // @R 999.999.999-99
               {"telefone"  ,"C", 14, 0},; // 
               {"percent"   ,"N",  5, 1},; // 999.9
               {"obs"       ,"M", 10, 0};  // @S35
             };
)
RETU

PROC HIS_estr     // estrutura do arquivo HISTORIC
DBCREATE(dbf,{;
               {"historico" ,"C",  3, 0},; // 999
               {"descricao" ,"C", 40, 0},; // 
               {"tipo"      ,"C",  1, 0},; // !
               {"origem"    ,"C",  3, 0},; // !!!
               {"intlan"    ,"C",  8, 0},; // 99999999
               {"codlan"    ,"C", 20, 0};  // !!!-99999999-999-999
             };
)
RETU

PROC ORD_estr     // estrutura do arquivo ORDPGRC
DBCREATE(dbf,{;
               {"numop"     ,"C",  6, 0},; // 999999
               {"origem"    ,"C",  3, 0},; // !!!
               {"lancto_"   ,"D",  8, 0},; // @D
               {"por"       ,"C", 10, 0},; // 
               {"numconta"  ,"C", 10, 0},; // @!
               {"historico" ,"C",  3, 0},; // 999
               {"debcred"   ,"C",  1, 0},; // !
               {"valortotal","N", 11, 2},; // 99999999.99
               {"vencto_"   ,"D",  8, 0},; // @D
               {"documento" ,"C", 12, 0},; // @!
               {"nrdoctos"  ,"N",  5, 0},; // 99999
               {"complement","C", 35, 0},; // @!
               {"fechto_"   ,"D",  8, 0},; // @D
               {"fechpor"   ,"C", 10, 0},; // 
               {"autoriz_"  ,"D",  8, 0},; // @D
               {"autorpor"  ,"C", 10, 0},; // 
               {"numos"     ,"C",  7, 0},; // 9999999
               {"intlan"    ,"C",  8, 0},; // 99999999
               {"codlan"    ,"C", 20, 0};  // !!!-99999999-999-999
             };
)
RETU

PROC PAR_estr     // estrutura do arquivo PAR_ADM
DBCREATE(dbf,{;
               {"pgrupo"    ,"C",  2, 0},; // !9
               {"pcontrato" ,"C",  6, 0},; // 999999
               {"pgrau"     ,"C",  1, 0},; // 9
               {"pseq"      ,"N",  2, 0},; // 99
               {"lastcodigo","C",  6, 0},; // 999999
               {"nrcanc"    ,"N",  6, 0},; // 999999
               {"nrreint"   ,"N",  6, 0},; // 999999
               {"contarec"  ,"C",  5, 0},; // @!
               {"contapag"  ,"C",  5, 0},; // @!
               {"histrcfcc" ,"C",  3, 0},; // 999
               {"histrcrec" ,"C",  3, 0},; // 999
               {"histrccar" ,"C",  3, 0},; // 999
               {"histpg"    ,"C",  3, 0},; // 999
               {"nrauxrec"  ,"C",  8, 0},; // @R 99-999999
               {"mcodigo"   ,"C",  6, 0},; // 999999
               {"mcirc"     ,"C",  3, 0},; // 999
               {"mgrupvip"  ,"C",  2, 0},; // !9
               {"combarra"  ,"C",  1, 0},; // !
               {"cinscr"    ,"C",  1, 0},; // !
               {"comfalec"  ,"C",  1, 0},; // !
               {"mproc1"    ,"C",  5, 0},; // 99999
               {"mproc2"    ,"C",  2, 0},; // 99
               {"impnrrec"  ,"C",  5, 0},; // 99999
               {"procimp"   ,"C",  7, 0},; // @R 99999/99
               {"pvalor"    ,"N",  9, 2},; // @E 999,999.99
               {"setup1"    ,"C", 40, 0},; // 
               {"setup2"    ,"C", 50, 0},; // 
               {"setup3"    ,"C", 50, 0};  // 
             };
)
RETU

* \\ Final de ADM_ESTR.PRG
procedure sin_01f9
/*
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
 \ Empresa.: PresServ Inform tica-Limeira (019)452.6623
 \ Programa: SIN_01F9.PRG
 \ Data....: 31-03-97
 \ Sistema.: Seguros
 \ Funcao..: Valida‡„o do campo NASCTO_, arquivo SINSCRIT
 \ Analista: Ademilson Pedro Bom
 \ Criacao.: Programado manualmente pelo analista
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/

#include "adrbig.ch"    // inicializa constantes manifestas
PRIV idmes
idmes := (YEAR(DATE()) - YEAR(nascto_))*12
idmes += (MONTH(DATE()) - MONTH(nascto_))

IF op_menu=1.AND.!EMPT(nascto_) .AND. idmes > (60*12)
 DBOX([Inscrito com ]+STR(INT(idmes/12),2)+[ anos completos])
ENDI

RETU .T.       // <- deve retornar um valor L¢GICO

* \\ Final de SIN_01F9.PRG
/*
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
 \ Empresa.: Ind£stria de Urnas Bignotto Ltda
 \ Programa: ADR_FUNC.PRG
 \ Data....: 06-11-97
 \ Sistema.: Administradora - RECEP€„O
 \ Funcao..: Fun‡”es auxiliares
 \ Analista: Ademilson Pedro Bom
 \ Criacao.: GAS-Pro v3.0 
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/

#include "adrbig.ch"    // inicializa constantes manifestas

/*
   Sintaxe: CANC()
   Funcao.: Cancela impressao de relat¢rio ou consulta
   Retorna: .t. se confirmou o cancelamento.
*/
FUNC CANC()
LOCAL ii, msg, defa_dev
PRIV cod_sos:=1
defa_dev=SET(_SET_DEVICE,"SCREEN")   // direciona para video para mensagem
ALERTA()                             // beep, beep, beep
msg="Cancelar o relat¢rio|Prosseguir a impress„o"
ii=DBOX(msg,,,E_MENU,,"EMISSŽO SUSPENSA")
SET(_SET_DEVICE,defa_dev)            // redireciona para impressora ou arquivo
RETU ii=1

/*
   Sintaxe: ROLATELA()
   Funcao.: Ajusta flag e prepara rolamento de tela
   Retorna: NIL
*/
FUNC ROLATELA()
LOCAL t_atual:=SAVESCREEN(l_s,c_s,l_i,c_i)
PRIV  tela_fundo:=tela_fundo
IF rola_t                                          // rolar a tela...
 DISPBEGIN()                                       // inicia montagem da tela
 RESTSCREEN(0,0,MAXROW(),79,tela_fundo)            // restaura pano de fundo
 IMPRELA()                                         // imprime DBFs relacionados
 tela_fundo=SAVESCREEN(0,0,MAXROW(),79)            // exceto o atual
 CAIXA(mold,l_s,c_s,l_i,c_i)                       // salva novo pano de fundo e
 RESTSCREEN(l_s,c_s,l_i,c_i,t_atual)               // restaura a tela do DBF atual
 DISPEND()                                         // reapresenta tela
 MUDA_PJ(@l_s,@c_s,@l_i,@c_i,tela_fundo,tem_borda) // muda posicao da janela
 PUBL &vr_memo.:=STR(l_s,2)+STR(c_s,2)             // salva novas coordenadas da
 SAVE TO (arqconf) ALL LIKE drv*                   // janela em disco
 REST FROM (arqconf) ADDI
ELSE                                               // seta flag e abandona get pendente
 rola_t=.t.
 KEYB CHR(K_ESC)                                   // forca ESC
ENDI
RETU NIL

/*
   Sintaxe: PEGAPAI( <ExpN> )
   Funcao.: Capta o numero da subscricao do arquivo "pai de todos"
              ExpN = subscricao do arquivo relacionado
   Retorna: subscricao do "pai de todos"
*/
FUNC PEGAPAI(op_)
LOCAL ii
DO WHIL .t.
 IF LEN(sistema[op_,O_CPRELA])>0           // tem campo de ligacao com o pai?
  ii=sistema[op_,O_CPRELA,1]               // extrai o nome do arquivo da ligacao
  op_=EVAL(qualsis,LEFT(ii,AT("->",ii)-1)) // e acha a sua subscricao
  LOOP                                     // repete operacao para ver se o pai
 ENDI                                      // tambem e' filho
 EXIT
ENDD
RETU op_                                   // retorna susbcricao do pai de todos

/*
   Sintaxe: MENURELA( <ExpN> )
   Funcao.: Monta string com titulos de arquivos relacionados
              ExpN = subscricao do arquivo no vetor "sistema"
   Retorna: String
*/
FUNC MENURELA(op_)
LOCAL i, ii, menu
menu=IF(op_!=op_sis,"|"+sistema[op_,O_MENU],"") // se o DBF e' dif do atual
FOR i=1 TO LEN(sistema[op_,O_DBRELA])           // pega todos os DBF relacionados
 ii=EVAL(qualsis,sistema[op_,O_DBRELA,i])       // pega sua subscricao no vetor sistema
 IF LEN(sistema[ii,O_DBRELA])>0                 // se o DBF da relacao tem suas proprias
  menu=menu+MENURELA(ii)                        // relacoes chama a funcao recursivamente
 ELSE                                           // se DBF relacionado nao tem relacao
  IF ii!=op_sis                                 // e nao e' o DBF atual
   menu+="|"+sistema[ii,O_MENU]                 // entao monta string
  ENDI
 ENDI
NEXT
RETU menu                                       // retorna string dos nomes do DBFs

/*
   Sintaxe: QUALRELA( <ExpN1> <,ExpN2> <,ExpN3> )
   Funcao.: Pega subscricao do enesimo arquivo da relacao
              ExpN1 = subscricao do arquivo atual
              ExpN2 = enesimo arquivo da relacao
              ExpN3 = valor temporario que contera' a qde de arquivos
                      da relacao. Passar sempre 0.
   Retorna: Subscricao encontrada
*/
FUNC QUALRELA(op_,op_esc,qt_op)
LOCAL i, ii, menu:=0
IF op_!=op_sis                             // se nao for o DBF atual, soma
 qt_op++                                   // 1 na qde de DBFs relacionados
 IF op_esc=qt_op                           // e' o enesimo arquivo da relacao
  menu=op_                                 // prepara p/ retornar sua subscricao
 ENDI
ENDI
IF menu=0                                  // ainda nao achou o enesimo arquivo
 FOR i=1 TO LEN(sistema[op_,O_DBRELA])     // pega todos os DBF da relacao
  ii=EVAL(qualsis,sistema[op_,O_DBRELA,i]) // pega sua subscricao no vetor sistema
  IF LEN(sistema[ii,O_DBRELA])>0           // se o DBF da relacao tem suas proprias
   menu=QUALRELA(ii,op_esc,@qt_op)         // relacoes chama a funcao recursivamente
   IF menu>0                               // se achou o enesimo,
    EXIT                                   // cai fora
   ENDI
  ELSE                                     // se DBF relacionado nao tem relacao
   IF ii!=op_sis                           // e nao e' o DBF atual
    IF ++qt_op=op_esc                      // entao soma qde de DBFs da relacao
     menu=ii                               // e verifica se e' o enesimo
     EXIT                                  // se for, cai fora
    ENDI
   ENDI
  ENDI
 NEXT
ENDI
RETU menu                                  // retorna o enesimo DBF da relacao

/*
   Sintaxe: OPCOES_REL( <N1> <,N2> <,N3> <,N4> )
   Funcao.: Abre diversas op‡”es para emissao de relatorio
               N1,N2 = coordenada linha/coluna superior do menu de opcoes
                  N3 = Numero sequencial para montar nome de arquivo para
                       gravar as variacoes do relatorio.
                  N4 = codigo do bloco de ajuda (cod_sos)
   Retorna: .t. se vai prosseguir
*/
FUNC OPCOES_REL(l_m,c_m,op_rel,sos_cod)
LOCAL li_, op_x, ant_, cr_i, or_i, t_opc:=SAVESCREEN(0,0,MAXROW(),79)
op_x=LRELA(l_m,c_m,op_rel)     // verifica/seleciona relatorios gravados
IF op_x=2                      // leu um relatorio gravado anteriormente
 improk=.t.
 IF tps=1                      // vai para impressora...
  improk=PREPIMP()             // confima preparacao da impressora
 ENDI
 IF !improk                    // cancelou
  op_x=0
 ELSE
  INDTMP()                     // verifica/indexa o arquivo se for necessario
 ENDI
 RETU .t.                      // retorna
ENDI
nucop=1
or_i=cpord                     // salva ordenacao inicial
ant_=criterio+cpord+titrel     // salva criterio, ordenacao e titulo atuais
DO WHIL op_x>0
 cod_sos=sos_cod
 msg="Prosseguir|Sa¡da: "      // monta menu de opcoes
 IF tps=1                      // se a saida e para prn
  msg+=drvmarca+" em "+drvporta// pega conf atual
 ELSE                          // caso contrario
  msg+="Arquivo/Video"         // coloca a palavra "Arquivo/Video"
 ENDI
 msg+="|Filtrar|C¢pia(s) ("+TRAN(nucop,"99")+")"+;
      "|Ordenar|T¡tulo"
 IF !EMPTY(titrel)             // se tem titulo coloca-o no menu
  msg+=": "+IF(LEN(titrel)>30,LEFT(titrel,30)+"...",titrel)
 ENDI
 cr_i=criterio+cpord+titrel    // se tem alteracao, liga
 gr_rela=(ant_!=cr_i)          // flag de gravacao de relatorio
 msgt="OP€”ES DO RELAT¢RIO"    // recebe opcao desejada
 RESTSCREEN(0,0,MAXROW(),79,t_opc)
 op_x=DBOX(msg,l_m,c_m,E_MENU,NAO_APAGA,msgt,,,op_x)
 DO CASE
  CASE op_x=1                  // prossegue...
   IF tps=1                    // vai para impressora.....
    IF !PREPIMP()              // pede confirmacao da impressora
     LOOP                      // nao quis mais, volta para menu de opcoes
    ENDI
   ENDI
   INDTMP()                    // verifica/indexa o arquivo se for necessario
   EXIT

  CASE op_x=2                  // tipo de saida
   tps=TP_SAIDA(l_m+2,c_m+8,.t.)

  CASE op_x=3                  // pega criterio de selecao dos registro
   FILTRA(.f.)                 // parametro .f. = nao indexa ao final da selecao

  CASE op_x=4                  // numero de copias a emitir
   nucop=DBOX("(de 1 a 99)",l_m+2,c_m+8,,,"QUANTIDADE DE C¢PIAS",nucop,"99")
   nucop=IF(nucop<1.OR.LASTKEY()=K_ESC,1,nucop)

  CASE op_x=5                  // escolhe uma nova ordem
   cpord=or_i                  // inicializa ordenacao
   CLASS(.f.)

  CASE op_x=6                  // recebe um titulo para o sistema
   msg="Informe, se Desejar:"
   titrel=LEFT(titrel+SPAC(70),70)
   titrel=ALLTRIM(DBOX(msg,,,,,"T¡TULO DO RELAT¢RIO",titrel))
   RESTSCREEN(0,0,MAXROW(),79,t_opc)

 ENDC
ENDD                           // restaura a tela
RESTSCREEN(0,0,MAXROW(),79,t_opc)
RETU(op_x=1)                   // retorna .t. se quiser prosseguir

/*
   Sintaxe: TP_SAIDA( <N1> <,N2> <,L> )
   Funcao.: Permite a escolha das diversas configuracoes da impressora
              N1,N2 = coordenada linha/coluna superior do menu
               ExpL = se .t. deixa escolher saida para arquivo/video
   Retorna: o tipo de saida escolhido
*/
FUNC TP_SAIDA(l_tp,c_tp,arq_vid)
LOCA ar_, i:=1
tps:=IF(TYPE("tps")="N",tps,1)
ar_=SELECT()               // salva area atual e
SELE 0                     // vai p/ uma area vazia

#ifdef COM_REDE
 IF ! USEARQ(arq_prn,.f.,20,1,.f.)
  RETU tps                 // falhou abertura, retorna
 ENDI
#else
 USE (arq_prn)             // abre arquivo de configuracoes
#endi

msg=""                     // variavel que contera as configuracoes
DO WHIL !EOF()             // le todo o arquivo
 msg+="|"+ALLTRIM(marca)+; // e vai montando a variavel
      " em "+porta         // para o menu de tipos de saidas
 IF drvporta=porta .AND.;  // pega impressora configurada
    drvmarca=ALLTRIM(marca)// para o default do menu
  i=RECNO()
 ENDI
 SKIP
ENDD
msg=SUBS(msg,2)            // retira o primeiro "|"
IF arq_vid                 // se pode enviar para arq/video
 msg+="|Arquivo/Video"     // acrescenta esta opcao
END IF
i=DBOX(msg,l_tp,c_tp,E_MENU,,"TIPO DE SA¡DA",,,i)
IF i>0                     // escolheu um tipo...
 tps=IF(i<=RECC(),1,2)     // ajusta tps: 1-impressora, 2=arquivo
 IF tps=1
  drvprn=i                 // ajusta default da configuracao atual
  GO drvprn                // reinicializa as variaveis de impressao
  FOR i=1 TO FCOU()        // de acordo com configuracao escolhida
   msg=FIEL(i)
   drv&msg.=ALLTRIM(FIELDGET(i))
  NEXT
  SAVE TO (arqconf) ALL LIKE drv* // salva mo disco configuracao escolhida
 ENDI
ENDI
USE                        // fecha o arq de conf de prn
SELE (ar_)                 // volta para area anterior
RETU tps

/*
   Sintaxe: TRANSCAMPO( <ExpL> <,ExpC> [,ExpN] )
   Funcao.: Adapta campo para pesquisa segundo seu tipo
             ExpL = se .t. monta expressao com conteudo do campo, caso
                    contrario, monta expressao com o nome do campo
             ExpC = nome do campo para adaptacao
             ExpN = numero do campo dentro da estrutura do DBF
   Retorna: String convertida
*/
FUNC TRANSCAMPO(conteudo_,chv_,indcp_)
LOCAL tp_cp:=VALTYPE(&chv_.), cp_, estr_dbf:=DBSTRUCT()
IF conteudo_
 IF tp_cp="D"
  cp_=DTOS(&chv_.)
 ELSEIF tp_cp="N"
  IF indcp_=NIL
   cp_=STR(&chv_.)
  ELSE
   cp_=STR(&chv_.,estr_dbf[indcp_,3],estr_dbf[indcp_,4])
  ENDI
 ELSE
  cp_=&chv_.
 ENDI
ELSE
 IF tp_cp="D"
  cp_="DTOS("+chv_+")"
 ELSEIF tp_cp="N"
  IF indcp_=NIL
   cp_="STR("+chv_+")"
  ELSE
   cp_="STR("+chv_+","+LPAD(estr_dbf[indcp_,3],2,"0")+","+LPAD(estr_dbf[indcp_,4],2,"0")+")"
  ENDI
 ELSE
  cp_=chv_
 ENDI
ENDI
RETU cp_

/*
   Sintaxe: ARQGER()
   Funcao.: recebe nome do arquivo
   Retorna: String (nome do arquivo)
*/
FUNC ARQGER()
LOCAL defa_:=drvdbf+"TMP"+ide_maq, t_l, t_r
t_l=SETKEY(K_LEFT,NIL)                         // desabilita seta -> e <-
t_r=SETKEY(K_RIGHT,NIL)
KEYB CHR(K_END)                                   // cursor no final do drive sugerido
arq_=DBOX("Nome do arquivo",,,,,"ARQUIVO EM DISCO",PADR(defa_,30),"@!")
arq_=TRIM(arq_)
SETKEY(K_LEFT,t_l)                             // reabilita setas cursoras
SETKEY(K_RIGHT,t_r)
RETU IF(LEN(SUBS(arq_,RAT("\",arq_)+1))<1.OR.; // nome do arquivo sem dir ou
     LASTKEY()=K_ESC,"",arq_)                  // ou cancelou

/*
   Sintaxe: PREPIMP( [msgt] )
   Funcao.: Apresenta mensagem para preparo da impressora
            msgt=titulo para menu
   Retorna: .t. se pronta
*/
FUNC PREPIMP(msgt)
PRIV cod_sos:=29
msgt=IF(msgt=NIL,"ATEN€ŽO, "+usuario,msgt)
ALERTA(3)
op_=1
DO WHILE op_=1
 msg="Impressora pronta|Cancelar opera‡„o"
 op_=DBOX(msg,,,E_MENU,,msgt)             // solicita preparo da impressora
 IF LEFT(drvporta,3)="LPT".AND.op_=1
  IF !IMPOK(VAL(SUBS(drvporta,4,1)))      // porta paralela podemos testar
   ALERTA(4)
   DBOX("Impressora n„o pronta!",,,,,"ATEN€ŽO, "+usuario)
   LOOP                                   // fora de linha, ficamos por aqui
  ENDI
 ENDI
 EXIT                                     // s'imbora
ENDD
RETU (op_=1)                              // retorna .T. se pronta

/*
   Sintaxe: CONFINCL()
   Funcao.: Apresenta mensagem para confirmar a inclusao
   Retorna: .t. se inclusao ok
*/
FUNC CONFINCL()
PRIV cod_sos:=1
ALERTA(2)
op_=1
msg="Efetuar inclus„o|Corrigir digita‡„o"
op_=DBOX(msg,l_i-1,c_i-10,E_MENU,,"ATEN€ŽO, "+usuario) // solicita confirmacao
RETU (op_=1)     // retorna .T. se quer incluir

/*
   Sintaxe: CONFEXCL()
   Funcao.: Apresenta mensagem para confirmacao da exclusao e
            verifica se o reg pode ser excluido
   Retorna: .t. se ok
*/
FUNC CONFEXCL()
LOCAL op_:=1
PRIV cod_sos:=1
IF drvexcl                                      // se conf de exclusao
 ALERTA(1)                                      // esta ligada, vamos
 cod_sos=1                                      // pedir confirmacao
 msg=IF(LEN(sistema[op_sis,O_DBRELA])>0,"|(INCLUSIVE RELACIONADOS)","")
 msg="EXCLUIR"+msg
 op_=DBOX("Sim|N„o",17,,E_MENU,,msg)
ENDI
IF op_=1.AND.!EMPT(sistema[op_sis,O_CONDEXC,1]) // se tem condicao de
 IF !&(sistema[op_sis,O_CONDEXC,1])             // exclusao e se esse
  ALERTA(2)                                     // reg nao pode ser
  op_=2                                         // excluido, avisa o
  msg=sistema[op_sis,O_CONDEXC,2]               // motivo e prepara
  DBOX(msg,,,,,"ATEN€ŽO!|IMPOSS¡VEL EXCLUIR")   // para retornar .f.
 ENDI
ENDI
RETU op_=1

/*
   Sintaxe: CONFALT()
   Funcao.: verifica se o reg pode ser alterado
   Retorna: .t. se ok
*/
FUNC CONFALT()
LOCAL op_:=1
PRIV cod_sos:=1
IF !EMPT(sistema[op_sis,O_CONDALT,1])         // se tem condicao de
 IF !&(sistema[op_sis,O_CONDALT,1])           // alteracao e se esse
  ALERTA(2)                                   // reg nao pode ser
  op_=2                                       // alterado, avisa o
  msg=sistema[op_sis,O_CONDALT,2]             // motivo e prepara
  DBOX(msg,,,,,"ATEN€ŽO!|IMPOSS¡VEL ALTERAR") // para retornar .f.
 ENDI
ENDI
RETU op_=1

/*
   Sintaxe: ROLAPOP( <ExpN> )
   Funcao.: Efetua a rolagem do menu pop-down
   Retorna: NIL
*/
FUNC ROLAPOP(q_t)
IF q_t=NIL               // se nao tem parametro desabilita setas da
 SETKEY(K_LEFT,NIL)      // esquerda/direita, caso contrario, liga as
 SETKEY(K_RIGHT,NIL)     // teclas com a qde de ESC, SETA e ENTER
ELSE                     // nesessarios para rolar a janela na horizontal
 SETKEY(K_LEFT,{||KEYBUFF(REPL(CHR(K_ESC),q_t)+CHR(K_LEFT)+CHR(K_ENTER))})
 SETKEY(K_RIGHT,{||KEYBUFF(REPL(CHR(K_ESC),q_t)+CHR(K_RIGHT)+CHR(K_ENTER))})
ENDI
RETU NIL

/*
   Sintaxe: PEGADIR( <ExpL> )
   Funcao.: Pega novo diret¢rio de trabalho para a aplica‡„o
              ExpL = se .f., so pega diretorios de dados e de indices
                     se .t. recebe o diret¢rio do ERROS.DBF tambem
   Retorna: .t. se nao foi cancelado
*/
FUNC PEGADIR(pri_vez)
LOCAL cn,drv_dbf:=drvdbf,drv_ntx:=drvntx,drv_err:=drverr,defa:=QUALDIR(),t,i,;
      msgt:="DIRET¢RIOS DE TRABALHO",msg,ado_,aio_,add_,aid_
cn=.f.

#ifdef COM_PROTECAO
 IF !pri_vez                                   // se veio do apoio
  EVAL(protdbf,.f.)                            // protege DBFs
 ENDI
#endi

DO WHIL !cn
 msg="Arquivo de dados"
 drvdbf=DBOX(msg,,,,,msgt,PADR(drvdbf,23),"@!")// diretorio dos DBF
 IF LASTKEY()=K_ESC                            // cancelou
  cn=.t.
  LOOP
 ENDI
 drvdbf=ALLTRIM(drvdbf)                        // tira espacos
 drvdbf=IF(RIGHT(drvdbf,1)!="\".AND.;          // diretorio tem que
        LEN(drvdbf)>0,drvdbf+"\",drvdbf)       // terminar com barra (\)
 IF !criadrv(drvdbf)                           // verifica/cria diretorio
  LOOP                                         // desistiu de criar
 ENDI
 msg+=": "+drvdbf                              // diretorio dos NTX
 drvntx=DBOX(msg+"|*|Arquivos de ¡ndices",,,,,msgt,PADR(drvntx,23),"@!")
 IF LASTKEY()=K_ESC                            // se cancelou,
  LOOP                                         // volta a pedir dir DBF
 ENDI
 drvntx=ALLTRIM(drvntx)                        // tira espacos
 drvntx=IF(RIGHT(drvntx,1)!="\".AND.;          // diretorio tem que
        LEN(drvntx)>0,drvntx+"\",drvntx)       // terminar com barra (\)
 IF !criadrv(drvntx)                           // verifica/cria diretorio
  LOOP                                         // desistiu de criar
 ENDI
 msg+="|Arquivo de ¡ndices: "+drvntx
 IF pri_vez                                    // recebe diretorio do ERROS.DBF
  PADR(drverr,23)
  drverr=DBOX(msg+"|*|Arquivos de apoio … aplica‡„o:",,,,,msgt,PADR(drverr,23),"@!")
  IF LASTKEY()=K_ESC                           // se cancelou,
   LOOP                                        // volta a pedir dir DBF
  ENDI
  drverr=ALLTRIM(drverr)                       // tira espacos
  drverr=IF(RIGHT(drverr,1)!="\".AND.;         // diretorio tem que
         LEN(drverr)>0,drverr+"\",drverr)      // terminar com barra (\)
  IF !criadrv(drverr)                          // verifica/cria diretorio
   LOOP                                        // desistiu de criar
  ENDI
  msg+="|Arquivos de apoio: "+drverr
 ENDI
 msg=msgt+"|*|"+msg
 ALERTA(1)
 op_=DBOX("Prosseguir|Corrigir",,,E_MENU,,msg) // confirma as informacoes
 IF op_=1                                      // se tudo certo,
  EXIT                                         // sai do loop
 ENDI
ENDD
IF (!(drvdbf==drv_dbf) .OR.;                   // se mudou diretorio de trabalho
   !(drvntx==drv_ntx)) .AND.;                  // e nao for a primeira vez, testa
   !pri_vez .AND. !cn                          // existencia dos DBF e NTX,
 cn=!CRIADBF()                                 // caso nao exista, cria-os
ENDI
IF cn                                          // se cancelou,
 drvdbf=drv_dbf;drvntx=drv_ntx;drverr=drv_err  // retorna dir anteriores
ELSE
 SAVE TO (arqconf) ALL LIKE drv*               // salva diretorios no disco
ENDI

#ifdef COM_PROTECAO
 IF !pri_vez                                   // se veio do apoio
  EVAL(protdbf,.t.)                            // desprotege DBFs
 ENDI
#endi

RETU !cn

/*
   Sintaxe: CRIADRV( <ExpC> )
   Funcao.: Testa/cria se nao exitir o diretorio ExpC
   Retorna: .t. se teve sucesso.
*/
FUNC CRIADRV(drv_)
LOCAL drv_atual:="\"+CURDIR(),x
drv_=LEFT(drv_,LEN(drv_)-1)
IF !CHDIR(drv_) .AND. LEN(drv_)>2              // se diretorio nao existe
 ALERTA(2)                                     // beep, beep e
 x="Criar "+drv_+"|Digitar outro diret¢rio"    // pergunta se quer
 op_=DBOX(x,,,E_MENU,,"DIRET¢RIO NŽO EXISTE!") // cria-lo
 IF op_!=1                                     // se nao quis...
  RETU .f.                                     // retorna
 ENDI
 IF !MKDIR(drv_)                               // se nao conseguiu criar
  ALERTA(4)                                    // avisa e retorna
  x="Erro ao criar o diret¢rio"
  op_=DBOX(x,,,3,,"ERRO!")
  RETU .f.
 ENDI
ELSE                                           // ok diretorio existe
 CHDIR(drv_atual)                              // posiciona dentro dele
ENDI
RETU .t.

/*
   Sintaxe: ABRE( <ExpC> <,ExpL> )
   Funcao.: Abre/cria arquivo binario para backup
              ExpC = nome do arquivo a ser criado/aberto
              ExpL = .t. cria, .f. abre
   Retorna: "Handle" do arquivo
*/
FUNC ABRE(arq_,cria_)
LOCAL i, handle:=1
DO WHIL .t.
 IF cria_                // se quer criar arquivo
  handle=FCREATE(arq_)   // vamos cria-lo
 ELSE                    // senao,
  handle=FOPEN(arq_)     // abriremos para leitura
 END IF
 IF FERROR() !=0         // deu erro na aberura do arquivo
  ALERTA()               // manda aviso sonoro
  cod_sos=1              // e deixa tentar novamente
  i=DBOX("Tentar novamente|Cancelar opera‡„o",,,E_MENU,,"ERRO!|IMPOSS¡VEL ABRIR O ARQUIVO|"+arq_)
  IF i!=1                // nao quer tentar mais...
   cn=.t.                // retorna
   EXIT
  ENDI
 ELSE                    // tudo certo
  EXIT                   // abriu corretamente
 ENDI
ENDD
RETU handle              // retorna o "handle" do arquivo

/*
   Sintaxe: CRIADBF()
   Funcao.: Verifica e cria os arquivos DBF e NTX, quando nao existirem.
   Retorna: .t. se teve sucesso
*/
FUNC CRIADBF
LOCAL tel_a:=SAVESCREEN(0,0,MAXROW(),79)    // salva a tela
FOR i=1 TO nss                              // para cada subsistema,
 dbf=drvdbf+sistema[i,O_ARQUI]; harq=.f.    // obtem nome do DBF
 IF !FILE(dbf+".dbf")                       // existe?
  IF i=1
   cod_sos=1
   ALERTA(3)                                // beep, beep, beep
   msg="Criar os arquivos|"+;               // confirma a criacao
       "Abandonar a opera‡„o"
   op_=DBOX(msg,,,E_MENU,,"ARQUIVOS NŽO ENCONTRADOS")
   IF op_!=1
    RETU (.f.)                              // retorna .f. pois abandonou
   ENDI
  ENDI
  harq=.t.                                  // monta o nome do modulo
  stru=LEFT(sistema[i,O_ARQUI],3)+"_estr"   // que cria a estrutura
  DBOX(dbf+".DBF",,,,NAO_APAGA,"CRIANDO")   // avisa...
  &stru.()                                  // e cria a estrutura
  RESTSCREEN(0,0,MAXROW(),79,tel_a)         // restaura a tela
 ENDI
 FOR t=1 TO LEN(sistema[i,O_INDIC])         // para cada indice do subsistema
  ntx=drvntx+sistema[i,O_INDIC,t]           // obtem nome do indice
  IF !FILE(ntx+".ntx").OR.harq              // se nao existir ou criou estrutura
   DBOX(ntx+".NTX",,,,NAO_APAGA,"CRIANDO")  // vamos criar...

   #ifdef COM_REDE
    IF !USEARQ(dbf,.t.,20,1,.f.)            // tenta abrir arquivo modo exclusivo
     SETPOS(23,1)
     RETU (.f.)                             // retorna .f., pois nao conseguiu
    ENDI
   #else
    USE (dbf)                               // abre arquivo
   #endi

   INDE ON &(sistema[i,O_CHAVE,t]) TO (ntx) // e indexa
   RESTSCREEN(0,0,MAXROW(),79,tel_a)        // restaura tela
  ENDI
 NEXT
 CLOS ALL                                   // fecha tudo
NEXT
dbfparam=drvdbf+"PAR_ADM"
SELE A

#ifdef COM_REDE
 USEARQ(dbfparam,.t.,,,.f.)
#else
 USE (dbfparam)
#endi

/*
   se nao existir nenhum registro no arquivo cria-o e coloca o valor
   inicial para cada um dos campos
*/
IF EOF() .OR. BOF()
 APPE BLAN
 REPL nrcanc WITH 000000
 REPL contarec WITH [RECEP]
 REPL contapag WITH [RECEP]
 REPL histrcfcc WITH LPAD([001],03,[0])
 REPL histrcrec WITH LPAD([002],03,[0])
 REPL histrccar WITH LPAD([004],03,[0])
 REPL histpg WITH LPAD([003],03,[0])
 REPL p_cidade WITH [LIMEIRA]
 REPL p_recp WITH [S]
 REPL setup1 WITH [BIGNOTTO IND.DE URNAS LTDA]
ENDI

/*
   cria variaveis de memoria publicas identicas as de arquivo,
   para serem usadas por toda a aplicacao
*/
FOR i=1 TO FCOU()
 msg=FIEL(i)
 M->&msg.=&msg.
NEXT
USE
RETU (.t.)                                  // retorna .t. - ok

/*
   Sintaxe: IMPEXP(<ExpN1> <,ExpN2> <,Exp> <,ExpN3> )
   Funcao.: Imprime conteudo expandido na impressora
              ExpN1 = linha a imprimir o conteudo
              ExpN2 = coluna a imprimir o conteudo
              Exp   = expressao a imprimir
              ExpN3 = largura total ocupada pela expressao
   Retorna: NIL
*/
FUNC IMPEXP(l_,c_,cp_,lg_)
@ l_,c_ SAY &drvpexp.+TRAN(cp_,"")+&drvtexp. // imprime campo expandido
SETPRC(l_,c_+lg_)                            // e ajusta o "carro" da
RETURN NIL                                   // impressora

/*
   Sintaxe: IMPCTL( <ExpC> )
   Funcao.: Imprime codigo de controle na impressora
              ExpC = codigo de controle
   Retorna: NIL
*/
FUNC IMPCTL(ctl_)
LOCAL li_:=PROW(), co_:=PCOL() // salva posicao do carro da impressora
IF LEN(ctl_)>0                 // se foi passado um codigo de controle
 lp_=SET(_SET_PRINTER,.t.)     // liga "echo" para impressora
 lc_=SET(_SET_CONSOLE,.f.)     // desliga saidas para video
 ?? &ctl_.                     // imprime caracteres de controle
 SET(_SET_PRINTER,lp_)         // retorna o "echo" original da impressora
 SET(_SET_CONSOLE,lc_)         // impressao no video habilitada
 SETPRC(li_,co_)               // retorna cabeca impressora
ENDI
RETURN NIL                     // para a posicao original

/*
   Sintaxe: IMPMEMO( <ExpM> <,N1> <,N2> <,N3> <,N4> <,ExpL> )
   Funcao.: Imprime campo "memo" em relat¢rio
              ExpM = campo "memo" a imprimir
              N1   = largura do campo "memo"
              N2   = linha a extrair e imprimir do campo "memo"
              N3/N4= linha e coluna onde sera impressa a linha
              ExpL = se .t., imprime alinhado
   Retorna: NIL
*/
FUNC IMPMEMO(cp_,tam_,nl_,l_,c_,just_)
LOCAL i_:=.f., ii_:=MEMOLINE(cp_,tam_,nl_)
IF just_.AND.RIGHT(RTRIM(ii_),1)!="."  // nao vamos justificar a
 i_=.t.                                // ultima linha do memo
ENDI
IMPAC(ii_,l_,c_,i_)                    // imprime linha do memo acentuada
RETU NIL

/*
   Sintaxe: PTAB( <ExpC1>, <ExpC2> [,ExpN] [,ExpL] )
   Funcao.: Executa pesquisa em tabelas
              ExpC1 = chave de pesquisa
              ExpC2 = arquivo alvo
              ExpN  = numero do indice associado a ExpC2
              ExpL  = se .t. deixa na ordem do indice do parametro
  
   Retorna: .t. se o registro existe
*/
FUNC PTAB(ch_,db_,or_dem,fix_ind_)
LOCAL ar_:=SELECT(), in_, sem_dbf:=ALIAS(), achou, del_a:=SET(_SET_DELETED,.f.)
or_dem=IF(or_dem=NIL,1,or_dem)
fix_ind_=IF(fix_ind_=NIL,.f.,fix_ind_)
IF !USEARQ(db_)            // tenta abrir DBF e seus indices
 RETU (.f.)                // retorna .f. se nao conseguiu
ENDI
in_=INDEXORD()             // salva ordem atual dos indices
DBSETORDER(or_dem)         // vai para o indice desejado
SEEK ch_                   // procura o registro
achou=(!EOF().AND.!DELE()) // flag se achou (DELE() nao vale)
IF !fix_ind_               // se nao quer deixar na ordem da pesquisa
 DBSETORDER(in_)           // retorna ordem original
ENDI
IF EMPTY(sem_dbf)          // se area anterior estiver vaga
 SELE 0                    //  seleciona proxima area vaga
ELSE                       // senao
 SELE (ar_)                //  seleciona area anterior
ENDI
SET(_SET_DELETED,del_a) // retorna a visibilidade dos excluidos
RETU achou

/*
   Sintaxe: USEARQ( <ExpC> [,ExpL1] [,ExpN1], [,ExpN2] [,ExpL2] )
   Funcao.: Abre arquivo de dados e seus ¡ndices associados
              ExpC  = nome do arquivo
              ExpL1 = .t. abre modo exclusivo
              ExpN1 = num de vezes que sera tentada a abertura
              ExpN2 = tempo em segundos entre as tentativas de abertura
              ExpL2 = .t. abre associando os ntx
   Retorna: .t. se abriu o arquivo
*/
FUNC USEARQ(db_,use_ex,n_tent,t_tent,com_ntx)
LOCAL op_sis, qt_ind, p_, drv_dbf, p_sempre, v_r, msg,;
      ind01, ind02, ind03, ind04, ind05
n_tent=IF(n_tent=NIL,0,n_tent)
t_tent=IF(t_tent=NIL,1,t_tent)
com_ntx=IF(com_ntx=NIL,.t.,com_ntx)
use_ex=IF(use_ex=NIL,.f.,use_ex)
p_sempre=(n_tent=0)
n_ant=n_tent
v_r=.f.
drv_dbf=drvdbf                             // drive de dados
IF "\" $ db_                               // verifica se passou diretorio + arquivo
 p_=RAT("\",db_)
 drv_dbf=LEFT(db_,p_)                      // pega diretorio passado e
 db_=SUBS(db_,p_+1)                        // o nome do arquivo
ENDI
IF EMPTY(SELECT(db_))                      // o arquivo nao esta' em uso, vamos abri-lo...
 db_f=drv_dbf + db_
 SELE 0                                    // seleciona proxima area livre

 #ifdef COM_REDE
  msgt="OUTRO USURIO ACESSANDO|O ARQUIVO"
  DO WHIL n_tent>=0 .OR. p_sempre          // tenta abrir o aruivo n vezes ou p/ sempre
   IF use_ex                               // tenta abrir com exclusividade
    USE (db_f) EXCLUSIVE
   ELSE                                    // tenta abrir compartilhado
    USE (db_f) SHARED
   ENDI
   IF ! NETERR()                           // abriu sem problemas
    v_r=.t.
    EXIT
   ENDI
   DBOX("Tentando abrir|"+;                // avisa usuario, espera n_tent
        IF(p_sempre,"(NŽO","(ESC")+;       // segundos para tentar novamente
        " cancela)",15,,t_tent,,msgt)
   n_tent-=t_tent
   IF !p_sempre .AND. LASTKEY()=K_ESC      // se nao for para sempre e quer
    EXIT                                   // cancelar, nao tenta abrir mais
   ENDI
  ENDD
  CLEA TYPEAHEAD                           // limpa o buffer do teclado
  IF ! v_r                                 // se nao conseguiu abrir o arquivo
   RETU (.f.)                              // retorna falso
  ENDI
 #else
  USE (db_f)                               // abre o arquivo
 #endi

 IF com_ntx                                // abre arquivo com os indices
  op_sis=EVAL(qualsis,ALIAS())             // obtem subscricao do DBF no vetor Sistema
  IF op_sis=0                              // se o arquivo e' externo ao sistema...
   v_r=AT(".",db_)                         //  tira extensao do arquivo
   n_t_x=IF(v_r>0,LEFT(db_,v_r-1),db_)     //  caso exista
   nt_x=drv_dbf+LEFT(n_t_x,7)+"1"          //  verifica se existe arquivo
   IF FILE(nt_x+".NTX")                    //  se existir indice com nome xxx1.ntx,
    SET INDE TO (nt_x)                     //   vamos usa-lo
   ELSE                                    //  se nao procura
    IF FILE(n_t_x+".NTX")                  //  indice com nome xxx.ntx, usa
     SET INDE TO (n_t_x)
    ENDI
   ENDI
  ELSEIF LEN(sistema[op_sis,O_INDIC])>0    // senao, abre indices segundo vetor sistema
   qt_ind=LEN(sistema[op_sis,O_INDIC])
   IF op_sis<=nss                          // se nao for as senhas,
    ind01=drvntx+sistema[op_sis,O_INDIC,1] //  coloca o path
   ELSE                                    // senao,
    ind01=sistema[op_sis,O_INDIC,1]        //  o indice ja tem o path
   ENDI
   IF qt_ind=1
    SET INDE TO (ind01)
   ELSE
    ind02=drvntx+sistema[op_sis,O_INDIC,2]
    IF qt_ind=2
     SET INDE TO (ind01), (ind02)
    ELSE
     ind03=drvntx+sistema[op_sis,O_INDIC,3]
     IF qt_ind=3
      SET INDE TO (ind01), (ind02), (ind03)
     ELSE
      ind04=drvntx+sistema[op_sis,O_INDIC,4]
      IF qt_ind=4
       SET INDE TO (ind01), (ind02), (ind03), (ind04)
      ELSE
       ind05=drvntx+sistema[op_sis,O_INDIC,5]
       IF qt_ind=5
        SET INDE TO (ind01), (ind02), (ind03), (ind04), (ind05)
       ENDI
      ENDI
     ENDI
    ENDI
   ENDI
  ENDI
 ENDI
ELSE
 SELE SELECT(db_)                          // arquivo ja' estava aberto
ENDI
RETU .t.                                   // deu tudo certo...

/*
   Sintaxe: CRIT( <ExpC1> <,ExpN> [,ExpC2] )
   Funcao.: Executa validacao de campos/ mostra formulas na tela
              ExpC1 = expressao de validacao e a mensagem a ser mostrada
                      separados separadas pelo caracter "~".
              ExpN  = linha onde sera mostrada a mensagem
              ExpC2 = formulas a serem mostradas na tela. ("nn|nn|nn|...",
                      "nn"=num das f¢rmulas especificadas no vetor "sistema"
   Retorna: .t. se critica ok
*/
FUNC CRIT(msgc,li,form_)
LOCAL cond, msg, flag:=.t., no_gets, i_
PRIV  l, c
no_gets=(RIGHT(PROCNAME(1),5)="_GETS")        // flg se nao esta consultando
IF !EMPT(msgc) .AND. !("V"==msgc) .AND. !("I"==msgc)
 li=IF(li=NIL.OR.li>MAXROW()-5,MAXROW()-5,li) // ajusta linha da mensagem
 msg =SUBS(msgc,AT("~",msgc)+1)               // mensagem a mostrar
 cond=LEFT(msgc,AT("~",msgc)-1)               // condicao de validacao
 IF !(&cond.)                                 // se condicao nao satisfeita,
  IF !no_gets .AND. LEN(TRIM(msg))>0          // se tem msg para mostrar
   ALERTA()                                   // beep, beep, beep
   DBOX(msg,li,,,,"ATEN€ŽO! "+usuario)        // avisa ao usuario
  ENDI
  flag=.f.                                    //  retornando falso
 ENDI
ENDI
IF flag .AND. form_!=NIL                      // validacao ok e tem formulas
 DO WHIL LEN(form_)>0                         // mostraremos todas ...
  i_=VAL(PARSE(@form_,"|"))                   // pega subscricao da formula
  IMP_FORM(sistema[op_sis,O_FORMULA,i_])      // imprime a formula
 ENDD
ENDI
RETU flag                                     // retorna ok se validacao ok

/*
   Sintaxe: EDITA( <N1> <,N2> <,N3> <,N4> <,ExpL|ExpC1> <,Arr1> <,Arr2> <,ExpC2> <,ExpC3> )
   Funcao.: Apresenta a tela de consulta no objeto "TBrowse" com diversos recursos.
              N1,N2,N3,N4 = coordenadas da janela de consulta
               ExpL|ExpC1 = rotinas nao acessadas
                     Arr1 = arranjo de campos a apresentar na janela
                     Arr2 = titulos dos campos de Arr1
                    ExpC2 = filtro inicial
                    ExpC3 = ordem inicial
   Retorna: NIL
*/
FUNC EDITA(li_supp,co_supp,li_infp,co_infp,mo_difp,coluna_cp,coluna_tit,cr_,ord_)
LOCAL op_sy_:=op_sis, cor_orig, i_, t_f8, dele_atu:=SET(_SET_DELETED)
PRIV cp_:="", cond_p:="", tit_cons:={"",""}, db_1rela:="", cpord,;
     db_2rela:="", cpord:="", criterio, ind_ord:=1, ind_rela:=1, chvpesq:="",;
     grava_db:=.f., op_db:=1, volta_db, ch_tecl:="05042419", op_menu:=PROJECOES,;
     di_tecl:="24262527", br_reg_ori, br_reg_out, brw_tempo, brw_ant:=brw,;
     col_cp:=coluna_cp,col_tit:=coluna_tit, li_sup:=li_supp, vr_edita,;
     li_inf:=li_infp, co_sup:=co_supp, co_inf:=co_infp, posi_cur,;
     dir_cur:=IF(op_sis>nss,2,3), mo_dif:=mo_difp, hlp_cod:=cod_sos
IF ! USED()                          // se nao existir arquivo
 RETU .f.                            // aberto, cai fora
ENDI
criterio=IF(cr_=NIL,"",cr_)          // tem filtro inicial?
cpord=IF(ord_=NIL,"",ord_)           // tem ordem inicial?
FOR i_=1 TO FCOU()                   // declara privados todos os
 msg=FIELD(i_)                       // campos do arquivo da consulta
 PRIV &msg.
NEXT

#ifdef COM_MOUSE
 IF drvmouse
  DO WHIL MOUSEGET(0,0)!=0           // se qualquer botao do mouse
  ENDD                               // estiver pressionado espera
 ENDI                                // liberacao
#endi

brw=.t.                              // pega posicao atual da tela
vr_edita=NOVAPOSI(@li_sup,@co_sup,@li_inf,@co_inf)
mo_dif=IF(mo_dif=NIL,.t.,mo_dif)     // trata as rotinas
IF TYPE("mo_dif")="L"                // que nao poderao
 IF !mo_dif                          // ser acessadas
  mo_dif="DERMG"                     // durante a consulta
 ELSE
  mo_dif=""
 ENDI
ENDI
cor_orig=SETCOLOR()                  // salva cor original
brw_reg=RECN()                       // registro atual
volta_db=.t.

#ifdef COM_REDE
 brw_tempo=drvtempo                  // tempo de "refresh"
#endi

t_f8=SETKEY(K_ALT_F8,NIL)            // salva/reseta tecla ALT-F8
BRWFUNC(PROCNAME(1)!="VDBF")         // funcoes auxiliares
SETKEY(K_ALT_F8,t_f8)                // seta tecla ALT-F8

#ifdef COM_REDE
 IF brw_tempo!=drvtempo              // se alterou o tempo de "refresh"
  SAVE TO (arqconf) ALL LIKE drv*    // salva em disco
 ENDI
#endi

SETCOLOR(cor_orig)                   // restaura cor original
op_sis = op_sy_
SET KEY K_TAB TO                     // resta TAB
brw=brw_ant
SET(_SET_DELETED,dele_atu)           // SET DELE=anterior
RETU .t.

/*
   Sintaxe: MOV_PTR( <ExpN> )
   Funcao.: Move o ponteiro em arquivo relacionado e ou filtrado
              ExpN  = numero de registros para mover o ponteiro
   Retorna: Num de registros pulados
*/
FUNC MOV_PTR(a_pular)
LOCAL ja_pulado := 0, chv_
IF a_pular = 0                             // nao vai pular registros
 SKIP 0
ELSE                                       // vai pular registros...
 chv_=&("{||"+INDEXKEY(0)+"=["+;           // so servem os registro que
      IF(EMPT(criterio),"","T")+chv_1+"]}")// atendao ao filtro/relacao
 DO WHILE !EOF() .AND. !BOF() .AND.;       // pula qtos reg's forao pedidos
    a_pular != ja_pulado .AND. EVAL(chv_)  // ate eof ou fora filtro/relacao
  IF a_pular > 0                           // pulando para frente
   SKIP
   ja_pulado++                             // conta quando foroa pulados
  ELSE                                     // pulando para traz
   SKIP -1
   ja_pulado--                             // menos um pulado
  ENDI
 ENDD
 IF !EVAL(chv_) .OR. EOF() .OR. BOF()      // reg nao atende filtro/relacao
  IF a_pular > 0                           // esta pulando para frente
   FIM_ARQ()                               // acha o fim do arquivo
   ja_pulado--                             // decrementa um na qde de reg pulados
  ELSE                                     // pulando para traz
   INI_ARQ()                               // acha o inicio do arquivo
   ja_pulado++                             // incrementa um na qde de reg pulados
  ENDI
 ENDI
ENDI
RETU ja_pulado                             // retorna a qde exata de reg pulados

/*
   Sintaxe: CABBRW()
   Funcao.: Monta cabecalho da consulta
   Retorna: NIL
*/
STATIC FUNC CABBRW
br_w:hilite()                             // tira barra cursora da tela
br_w:headsep:=chr(205)+chr(209)+chr(205)  // separador do cabecalho (ÍÑÍ)
br_w:colsep:=" "+chr(179)+" "             // separador das colunas  ( ³ )
op_sis=EVAL(qualsis,ALIAS())              // subscricao do arquivo atual
br_w:cargo:={"","","",INDEXORD()}         // salva alguns parametros da consulta
RETU NIL

/*
   Sintaxe: MONTABRW()
   Funcao.: Monta janela de visualiza‡„o da consulta
   Retorna: NIL
*/
STATIC FUNC MONTABRW()
LOCAL id_carg:={}
op_sis   = EVAL(qualsis,ALIAS())       // subscricao do arquivo atual
arq_cor  = LEFT(ALIAS(),3)             // prefixo do arquivo
id_carg  = br_w:cargo                  // variaveis da consulta
criterio = id_carg[1]                  // filtro
cpord    = id_carg[2]                  // ordenacao
chv_rela = id_carg[3]                  // relacao
ind_ord  = id_carg[4]                  // indice atual
DBSETORDER(ind_ord)                    // escolhe o indice atual
PEGACHV2()                             // pega final do relaciomento
SETCOLOR(drvcorbox)                    // cor da janela selecionada

#ifdef COM_MOUSE
 IF drvmouse                           // define area de atuacao do mouse
  MOUSEBOX(br_w:ntop-1,br_w:nleft-1,br_w:nbottom+1,br_w:nright+1)
 ENDI
#endi


/*
   Monta janela de consulta e mensagens de status e teclas disponiveis
   nas suas bordas
*/
CAIXA(mold+CHR(0),br_w:ntop-2, br_w:nleft-1, br_w:nbottom+1, br_w:nright+1)
@ br_w:ntop-2,br_w:nleft SAY IF(EMPTY(criterio),"{Qde="+LTRIM(STR(RECC(),10))+"}",REPL(SUBS(mold,2,1),11))
msg="TAB [ ],F10"+IF(op_sis<=nss.AND.((M->v_out.AND.tem_t).OR.!M->v_out),",F9","")

#ifdef COM_MOUSE
 IF drvmouse                           // botoes do mouse
  msg+=" "+CHR(174)+" "+CHR(175)+" "+CHR(30)+" "+CHR(31)+" "+CHR(24)+" "+CHR(26)+" "+CHR(25)+" "+CHR(27)+" "+CHR(18)
 ENDI
#endi

msg=LEFT(msg,br_w:nright-br_w:nleft)
posi_cur=INT((br_w:nright-br_w:nleft-LEN(msg))/2)
@ br_w:nbottom+1,br_w:nleft+posi_cur SAY msg
@ br_w:nbottom+1,br_w:nleft+posi_cur+5 SAY CHR(VAL(SUBS(di_tecl,dir_cur*2-1,2)))
x=br_w:nright-br_w:nleft+1
@ br_w:ntop-1,br_w:nleft SAY PADC(MAIUSC(tit_cons[IF(br_w == br_origem,1,2)]),x,' ')
RETU NIL

/*
   Sintaxe: FORCABRW( <ExpL> )
   Funcao.: Reimprime dados da funcao EDITA()
              ExpL = se .t. reimprime inclusive a moldura.
   Retorna: NIL
*/
STATIC FUNC FORCABRW(imp_cx)
LOCAL id_carg:={}
PRIV op_sis, chv_1, chv_2, criterio, cpord, chv_rela, chv_1, chv_2
COMMIT
IF br_outro != NIL               // se a 2a. janela estiver aberta
 TROCA_BRW()                     // troca janela do browse

 #ifdef COM_REDE
  COMMIT                         // forca atualizacao em disco
 #endi

 id_carg = br_w:cargo            // retira da variavel de instancia
 criterio=id_carg[1]             // o filtro que tinha
 cpord=id_carg[2]                // a ordenacao
 chv_rela=id_carg[3]             // a relacao
 ind_ord=id_carg[4]              // e o indice utilizado
 SET ORDE TO (ind_ord)
 op_sis=EVAL(qualsis,ALIAS())    // obtem subscricao do DBF no vetor Sistema
 PEGACHV2()                      // pega final do relaciomento
 IF imp_cx                       // reemprime moldura da janela
  SETCOLOR(drvcortna)
  br_w:colorspec := drvcortna+","+INVCOR(drvcortna)+","+drvcorenf+","+drvcorget
  CAIXA(mold+CHR(0),br_w:ntop-2, br_w:nleft-1, br_w:nbottom+1, br_w:nright+1)
  x=br_w:nright-br_w:nleft+1
  @ br_w:ntop-1,br_w:nleft SAY PADC(MAIUSC(tit_cons[IF(br_w == br_origem,1,2)]),x,' ')
 ENDI
 IF DELE().AND.SET(_SET_DELETED) // registro esta apagado e nao visivel
  MOV_PTR(-1)                    // acha o 1o. reg nao apagado
 ENDI
 br_w:refreshall()               // forca atualizacao da tela nao selecionada
 br_w:forcestable()              // apresenta os dados
 br_w:dehilite()                 // liga barra cursora
 TROCA_BRW()                     // troca janela do browse
ENDI
RETU NIL

/*
   Sintaxe: ABREOUTRO( <ExpN> )
   Funcao.: Abre segunda janela de consulta
              ExpN = subscricao do arquivo dentro vetor "sistema"
   Retorna: .t. se teve sucesso
*/
STATIC FUNC ABREOUTRO(op_s)
LOCAL ar_, c_1, c_2
ar_=UPPER(sistema[op_s,O_ARQUI])        // nome do arquivo da consuta

#ifdef COM_REDE
 IF !USEARQ(ar_,.f.,20,1)               // se nao conseguiu abrir o arquivo
  DBOX(ms_uso,20)                       // avisa
  SELE (m_origem)                       // retorna para o DBF original
  RETU .f.                              // e retorna
 ENDI
#else
 USEARQ(ar_)                            // abre DBF da consulta
#endi

outro_db=ALLTRIM(STR(SELEC(ar_)))       // salva area do arquivo aberto
SELE (m_origem)
M->tp=li_sup+INT((li_inf-li_sup-1)/2)+1 // linha de divisao das janelas
br_reg_ori=RECNO()                      // salva registro do DBF original
br_w:dehilite()                         // apaga barra cursora
br_w:nbottom := M->tp - 2               // final da janela do DBF original
br_w:configure()                        // seta remontagem da janela
c_1=br_w:nleft                          // salva coordenadas da direita
c_2=br_w:nright                         // e da esquerda para a nova janela
SELE (outro_db)                         // novo arquivo
GO TOP                                  // monta browse da nova consulta
br_outro=TBROWSENEW(M->tp+1,c_1,li_inf,c_2)
br_outro:colorspec := drvcorbox+","+INVCOR(drvcorbox)+","+drvcorenf+","+drvcorget
br_w=br_outro                           // browse atual
CABBRW()                                // monta janela do novo browse
RETU .t.                                // e retorna

/*
   Sintaxe: MOSTRA_RELA()
   Funcao.: Verifica se a janela de baixa esta relacionada e
            se e' necessario mostra os seus registros
   Retorna: .t. se preciso remonta-la
*/
STATIC FUNC MOSTRA_RELA()
LOCAL ok:=.f.
PRIV chv_rela, criterio, cpord, chv_1, chv_2, op_sis
IF TYPE("br_outro")="O"                       // tem outra janela aberta?
 id_carg = br_outro:cargo
 IF !EMPT(id_carg[3])                         // a janela esta relacionada?
  criterio = id_carg[1]                       // restabelece o filtro
  cpord    = id_carg[2]                       // ordem e a
  chv_rela = id_carg[3]                       // relacao entre as janelas
  SELE (outro_db)                             // seleciona dbf da janela
  op_sis=EVAL(qualsis,ALIAS())                // sua subscricao no vetor sistema
  PEGACHV2()                                  // acha o inicio/fim da relacao
  IF chv_1 != &chv_rela .OR. !br_outro:stable // precisa remonta-la?
   INI_ARQ()                                  // acha o inicio da relacao
   br_reg_out = RECNO()                       // salva reg atual
   br_outro:rowpos := 1                       // cursor na 1a. lin do browse
   ok:=.t.                                    // tem que remontar a janela
  ENDI
  SELE (m_origem)                             // seleciona janela superior
 ENDI
ENDI
RETU ok

/*
   Sintaxe: BRWFUNC( [ExpL] )
   Funcao.: Diversas funcoes auxiliares da EDITA()
              ExpL = .t./omitida le consultas gravadas
   Retorna: NIL
*/
STATIC FUNC BRWFUNC(nao_vdbf)
LOCAL br_w1, brw_tela, cri_ant, brw_reg, cp_exp:={}, estr_dbf:={}, tps,;
      tecl_p, l_sup, l_inf, m_od, arqexp, dli_exp, id_carg:={}, q_tela,;
      just_memo, tot_num, Li:=1, Co:=1, ppp:=0, pp:=0, t, i, l_m, Tp_Sai,;
      tit_rel, brw_fundo:=SAVESCREEN(0,0,MAXROW(),79), dele_atu, x_, y_
PRIV cp_, cp_titu, cp_masc, cp_crit, cp_when, cp_help, cp_cmd, tp_cp, br_w,;
     fg_loc:=.f., volta_db:=.t., arq_cor:=LEFT(ALIAS(),3), br_origem,;
     br_outro:=NIL, m_origem, outro_db:=NIL, chv_rela:="", chv_1:="",;
     chv_2:="", l_s, c_s, l_i, c_i, db_zoom:=.f., br_arq:="", br_tit:=""
m_origem = ALLTRIM(STR(SELEC()))
br_origem = TBROWSENEW(li_sup,co_sup,li_inf,co_inf)
br_origem:colorspec := drvcorbox+","+INVCOR(drvcorbox)+","+drvcorenf+","+drvcorget
br_w = br_origem
CABBRW()                                      // monta cabecalho da consulta
tit_cons[1]=sistema[op_sis,O_MENS]            // titulo da janela
nao_vdbf=IF(nao_vdbf=NIL,.t.,nao_vdbf)        // trata parametro
IF !LDBEDIT(nao_vdbf)                         // menu de consultas gravadas
 RETU NIL
ENDI
col_cp:=col_tit := NIL
tb = {{K_DOWN,      {||br_w:down()}},;        // vetor contendo as teclas
      {K_UP,        {||br_w:up()}},;          // e suas acoes
      {K_PGDN,      {||br_w:pagedown()}},;
      {K_PGUP,      {||br_w:pageup()}},;
      {K_CTRL_PGUP, {||br_w:gotop()}},;
      {K_CTRL_PGDN, {||br_w:gobottom()}},;
      {K_RIGHT,     {||br_w:right()}},;
      {K_LEFT,      {||br_w:left()}},;
      {K_HOME,      {||br_w:home()}},;
      {K_END,       {||br_w:end()}},;
      {K_CTRL_LEFT, {||br_w:panleft()}},;
      {K_CTRL_RIGHT,{||br_w:panright()}},;
      {K_CTRL_HOME, {||br_w:panhome()}},;
      {K_CTRL_END,  {||br_w:panend()}};
     }
SETCOLOR(drvcorbox)
volta_db=.t.
MONTABRW()                                    // inicializa tbrowse
DO WHILE volta_db
 SET CURSO OFF                                // apaga cursor da tela
 DO WHILE !br_w:stabilize() .AND. NEXTKEY()=0 // apresenta dados na tela
 ENDD
 x_ = COL() ; y_ = ROW()                      // salva posicao atual do cursor
 READINSERT(.f.)                              // retira o "insert"
 t = SUBS(mold,2,1)
 IF br_w:nleft+22<br_w:nright                 // msg no canto superior esquerdo
  @ br_w:ntop-2,br_w:nleft+12 SAY IF(DELE(),"{Exclu¡do}",REPL(t,10))
 ENDI
 IF br_w:nleft+31<br_w:nright                 // msg inicio/fim de arq no centro
  msg=IF(br_w:hittop,"{In¡cio}",IF(br_w:hitbottom,"{Final}"+t,REPL(t,8)))
  @ br_w:ntop-2,br_w:nleft+23 SAY msg
 ENDI
 IF br_w == br_origem .AND. br_w:stable       // esta na janela superior
  IF MOSTRA_RELA()                            // e' preciso refazer janela de baixo
   FORCABRW(.f.)                              // entao vamos la...
  ENDI
 ENDI
 cod_sos=hlp_cod

 #ifdef COM_MOUSE
  tecl_p=MOUSETECLA(br_w:ntop-1,br_w:nleft-1,; // aguarda com controle de mouse
                    br_w:nbottom+1,br_w:nright+1,.f.;
         )
  MOUSEGET(@li,@co)                            // salva posicao atual do mouse
  IF tecl_p=CLICK                              // se botao esquerdo foi pressionado
   t=br_w:rowpos; colpos_=br_w:colpos          // salva linha/coluna atual
   br_w:dehilite(); tecl_p=0                   // desliga cursor do browse
   br_w:rowpos:=t+li-y_                        // linha do clique
   FOR i=br_w:rightvisible TO br_w:leftvisible STEP -1
    br_w:dehilite()                            // deliga/liga cursor da coluna para
    br_w:colpos:=i                             // pegar as nova coordenadas do cursor
    br_w:hilite()
    IF COL()-1<=co                             // a coluna do clique e' esta?
     tecl_p=1                                  // flag fim da procura
     EXIT                                      // e sai do FOR...
    ENDI
   NEXT
   IF tecl_p=0 .AND. Br_w:freeze>0             // se ainda nao achou a coluna
    FOR i=br_w:freeze TO 1 STEP -1             // verifica se esta' nas colunas
     br_w:dehilite()                           // congeladas
     br_w:colpos:=i
     br_w:hilite()
     IF COL()-1<=Co                            // achamos a coluna do clique
      EXIT
     ENDI
    NEXT
   ENDI
   IF t=br_w:rowpos .AND. colpos_=br_w:colpos  // clicou duas vezes na mesma
    KEYB CHR(77)                               // coluna entao forca modificacao
   ENDI
   tecl_p=0                                    // nao faz nada
  ENDI
 #else

  #ifdef COM_TUTOR

   #ifdef COM_REDE
    tecl_p=IN_KEY(drvtempo)                    // espera tecla ser digitada
   #else
    tecl_p=IN_KEY(0)                           // espera tecla ser digitada
   #endi

  #else

   #ifdef COM_REDE
    tecl_p=INKEY(drvtempo)                     // espera tecla ser digitada
   #else
    tecl_p=INKEY(0)                            // espera tecla ser digitada
   #endi

  #endi

 #endi

 #ifdef COM_REDE
  IF tecl_p=0                                  // nao teclou nada, sai pelo
   br_w:refreshall()                           // tempo de "refresh" entao
   FORCABRW(.f.)                               // forca reimpressao dos dados
   LOOP                                        // na tela e volta
  ENDI
 #endi

 IF SETKEY(tecl_p)!=NIL                        // executa funcao associada a
  EVAL(SETKEY(tecl_p))                         // tecla digitada se existir
  tecl_p=0                                     // nao faz mais nada
 ENDI
 SET CURSO ON                                  // acende o cursor
 nm = ASCAN(tb,{|ve_a| tecl_p = ve_a[1]})      // verifica se tecla esta
 IF nm != 0                                    // no vetor de teclas progamadas
  IF tb[nm,2]!=NIL                             // em caso afirmativo,
   EVAL(tb[nm,2])                              // executa a funcao definida para
  ENDI                                         // a tecla
 ELSE
  br_w:dehilite()                              // apaga barra cursora
  IF tecl_p=K_F10
   SET CURS OFF                                // desliga cursor
   tbmenu="PFDMERVNAIOQL"+IF(fg_loc,"S","")+;
          "GCTJXZ"

   #ifdef COM_REDE
    tbmenu+="+-"                               // teclas de "refresh"
   #endi

   l_m=IF(op_sis>nss,"",exrot[op_sis])         // senhas nao tem rotinas
   l_m=RTRIM(mo_dif+l_m)                       // para serem retiradas
   FOR i=1 TO LEN(l_m)                         // retira rotina que o usuario
    tbmenu=STRTRAN(tbmenu,SUBS(l_m,i,1),"")    // nao pode acessar e monta menu
    tbmenu=STRTRAN(tbmenu,SUBS(l_m,i,1),"")    // nao pode acessar e monta menu
   NEXT                                        // com as rotinas disponiveis
   msg =IF(AT("P",tbmenu)>0,"P. Procura determinado registro  ÿ|","")
   msg+=IF(AT("F",tbmenu)>0,"F. Filtragem (seleciona/ordena)  ÿ|","")
   msg+=IF(AT("D",tbmenu)>0,"D. Digita‡„o - inclui registros  ÿ|","")
   msg+=IF(AT("M",tbmenu)>0,"M. Modifica conte£do do campo    ÿ|","")
   msg+=IF(AT("E",tbmenu)>0,"E. Exclui (marca apagamento)     ÿ|","")
   msg+=IF(AT("R",tbmenu)>0,"R. Recupera (desmarca apagamento)ÿ|","")
   msg+=IF(AT("V",tbmenu)>0,"V. Vˆ todo o registro na tela    ÿ|","")
   msg+=IF(AT("N",tbmenu)>0,"N. Nova coluna                    |","")
   msg+=IF(AT("A",tbmenu)>0,"A. Apaga coluna do cursor        ÿ|","")
   msg+=IF(AT("I",tbmenu)>0,"I. Imprime a consulta            ÿ|","")
   msg+=IF(AT("O",tbmenu)>0,"O. Ordena os registros           ÿ|","")
   msg+=IF(AT("Q",tbmenu)>0,"Q. Quantifica registros          ÿ|","")
   msg+=IF(AT("L",tbmenu)>0,"L. Localiza um registro          ÿ|","")
   msg+=IF(AT("S",tbmenu)>0,"S. Seguinte - localiza seguinte  ÿ|","")
   msg+=IF(AT("G",tbmenu)>0,"G. Global - processa os registrosÿ|","")
   msg+=IF(AT("C",tbmenu)>0,"C. Congela/descongela colunas    ÿ|","")
   msg+=IF(AT("T",tbmenu)>0,"T. Tamanho - muda tamanho coluna ÿ|","")
   msg+=IF(AT("J",tbmenu)>0,"J. "+IF(outro_db=NIL,"Janela - abre uma nova janela ÿ|","Janela - troca de janelas     ÿ|"),"")
   msg+=IF(AT("X",tbmenu)>0,"X. eXporta dados (TXT, SDF, DBF) ÿ|","")
   msg+=IF(AT("Z",tbmenu)>0,"Z. totaliZa coluna (se num‚rica) ÿ|","")

   #ifdef COM_REDE
    msg+=IF(AT("+",tbmenu)>0,"+. +5 seg na remontagem da tela  ÿ|","")
    msg+=IF(AT("-",tbmenu)>0,"-. -5 seg na remontagem da tela  ÿ|","")
   #endi

   msgt="OP€™ES|(ALT-F10=excluidos, ALT-Z=zoom, ALT-G=grava)"
   op_db=DBOX(msg,,,E_MENU,,msgt,,,op_db)       // escolhe a rotina
   IF op_db = 0                                 // cancelou...
    LOOP
   ENDI
   tecl_p = ASC(SUBS(tbmenu,op_db,1))           // pega o ASC
   IF SUBS(tbmenu,op_db,1)="L"                  // se escolheu "localiza", entao ajusta
    op_db++                                     // default para o continua
   ENDI
   SET CURSO ON                                 // acende o cursor
  ELSEIF tecl_p = K_F9 .AND. op_sis<=nss        // ve outros arquivos
   tecl_p=K_F9
   IF !M->v_out                                 // se tem permissao
    l_sup=li_sup; l_inf=li_inf                  // salva coordenadas da janela
    c_sup=co_sup; c_inf=co_inf
    m_od=mo_dif                                 // salva rotinas acessadas e
    br_w1 := br_w                               // o objeto browse atual
    VEOUTROS()                                  // escolhe arquivo a consultar
    br_w := br_w1                               // restaura o browse
    br_w:configure()                            // remonta titulo da colunas
    volta_db=.t.
    li_sup=l_sup; li_inf=l_inf                  // restaura as coordenadas da
    co_sup=c_sup; co_inf=c_inf                  // janela e
    mo_dif=m_od                                 // rotinas acessadas
    br_w:refreshall()                           // refaz os dados na tela
    FORCABRW(.f.)                               // forca browse do 2a. janela (se existir)
    MONTABRW()                                  // remonta as bordas da janela
   ELSEIF tem_t                                 // transfere o campo para o get pendente
    IF nao_vdbf                                 // se nao veio do VDBF()
     SEPARA(br_w:getcolumn(br_w:colpos):cargo)  // separa atrib coluna e transf p/ caracter
     IF tp_cp="D"
      msg=STRTRAN(DTOC(&cp_.),"/")
     ELSE
      msg=TRANSCAMPO(.t.,cp_)
     ENDI
     KEYB ALLTRIM(msg)                          // coloca campo no buffer do teclado
    ENDI
    volta_db=.f.
   ENDI
  ELSEIF tecl_p = K_ALT_F10                     // ALT-F10 esconde e mostra os
   SET(_SET_DELETED,!SET(_SET_DELETED))         // registros excluidos na consulta
   IF DELE() .AND. SET(_SET_DELETED)            // registro esta apagado
    MOV_PTR(1)                                  // acha o 1o. reg nao apagado
   ENDI
   br_w:refreshall()                            // remonta os dados do browse
   br_w:forcestable()                           // apresenta os dados
   br_w:refreshcurrent()                        // refaz so' a linha do browse
   FORCABRW(.f.)

  ELSEIF tecl_p = K_ALT_G                       // grava a consulta em arquivo
   t=ALIAS()                                    // salva arquivo corrente
   br_w1 := br_w                                // e browse atual
   SELE (m_origem)                              // selecion dbf da janela de cima
   cod_sos=22                                   // novo codigo de help
   db_aqcom=PADR(br_tit,58)                     // default para o titulo a gravar
   ALERTA(2)                                    // solicita o titulo para a consulta
   db_aqcom=DBOX("Identifique-a para grava‡„o. ESC cancela",,,,,"GRAVA CONSULTA",db_aqcom)
   db_aqcom=ALLTRIM(db_aqcom)                   // tira brancos do nome
   IF LASTKEY()!=K_ESC.AND.!EMPT(db_aqcom)      // se nao cancelou...
    pas = "1"                                   // grava paramenetros das duas janelas
    br_w = br_origem                            // vai para janela de cima
    db_outro=IF(outro_db=NIL,"",ALIAS(VAL(outro_db)))
    db_indrela=ind_rela                         // indice utilizado para relacionar
    DO WHILE .t.
     db_&pas.qtdc=br_w:colcount                 // numero de colunas
     FOR i=1 TO db_&pas.qtdc                    // para cada coluna
      tt=RIGHT(STR(100+i,3),2)
      db_&pas.carg&tt.= br_w:getcolumn(i):cargo // (conteudo,mascara,titulo,pre-val,valida,tipo)
      db_&pas.tam&tt. = br_w:getcolumn(i):width // tamanho da coluna
     NEXT
     id_carg = br_w:cargo                       // situacao do browse
     db_&pas.expo=id_carg[2]                    // ordem
     db_&pas.arqf=id_carg[1]                    // filtro
     db_&pas.chvr=id_carg[3]                    // relacionamento, outra janela
     db_&pas.ind_ord=id_carg[4]                 // indice atual
     db_&pas.freeze=br_w:freeze                 // coluna congelada
     IF pas = "1" .AND. br_outro != NIL         // tem outra janela aberta?
      pas="2"                                   // salva o mesmo
      SELE (outro_db)                           // para a outra janela
      br_w = br_outro
     ELSE
      EXIT                                      // tudo feito...
     ENDI
    ENDD
    IF br_tit==db_aqcom                         // se for a mesma consulta lida
     aqdbe=br_arq                               // grava no arquivo de mesmo nome
    ELSE                                        // se nao,
     DO WHIL .t.                                // procura um nome para gravar
      hms=TIME()                                // a consulta
      resaq=LEFT(hms,2)+SUBS(hms,4,2)+RIGHT(hms,2)+"."+LEFT(ALIAS(VAL(m_origem)),3)
      aqdbe=drvdbf+"DB"+resaq
      IF ! FILE("&aqdbe.")                      // se achou um
       EXIT                                     // cai fora...
      ENDI
     ENDD
    ENDI
    SAVE ALL LIKE db_* TO (aqdbe)               // salva em disco a consulta
   ENDI
   SELE (t)                                     // volta para a area anterior
   br_w := br_w1                                // e browse atual

  ELSEIF tecl_p = K_ALT_F8                      // ALT-F8 rola a janela
   li_sup-=2; co_sup--                          // ajusta coordenadas e
   li_inf++; co_inf++                           // executa a rolagem da janela
   MUDA_PJ(@li_sup,@co_sup,@li_inf,@co_inf,brw_fundo,.t.)
   li_sup+=2; co_sup++                          // reajusta as coordenadas
   li_inf--; co_inf--
   PUBL &vr_edita.:=STR(li_sup,2)+STR(co_sup,2) // publica variaves que contem
   SAVE TO (arqconf) ALL LIKE drv*              // as coordenadas da janela e
   REST FROM (arqconf) ADDI                     // grava em disco
   br_origem:ntop   := li_sup                   // ajusta browse com
   br_origem:nleft  := co_sup                   // as novas coordenadas
   br_origem:nbottom:= li_inf
   br_origem:nright := co_inf
   IF br_outro != NIL                           // se existe outra janela aberta
    M->tp=li_sup+INT((li_inf-li_sup-1)/2)+1     // ajusta as coordenadas dela
    br_origem:nbottom:=M->tp-2                  // tambem
    br_outro:ntop   := M->tp+1
    br_outro:nleft  := co_sup
    br_outro:nbottom:= li_inf
    br_outro:nright := co_inf
    FORCABRW(.f.)                               // reemprime dados na tela
   ENDI
  ENDI
  carac_ = UPPER(CHR(tecl_p))                   // escolheu uma rotina...
  IF AT(carac_,"ERMG")>0 .AND.RECC()=0          // nao permite alterar um
   LOOP                                         // arquivo vazio...
  ENDI
  l_m=IF(op_sis>nss,"",exrot[op_sis])           // arq de senhas nao tem restricoes
  IF AT(carac_,mo_dif+l_m)>0                    // se usuario nao tem permissao
   LOOP                                         // nao deixa executar
  ENDI
  IF AT(carac_,"DERMGV")>0 .AND.;               // se vai alterar um registro
     LEN(sistema[op_sis,O_CPRELA])>0            // e se e' um filho
   POSIPAI()                                    // abre/posiciona seus pais
  ENDI
  DO CASE

   #ifdef COM_REDE
    CASE (tecl_p=43 .OR. tecl_p=45)             // teclou + ou - para mudar o "refresh"
     DO WHILE .T.
      msg=LTRIM(STR(drvtempo))
      msg=IF(drvtempo=0,"N„o",msg+" seg")       // tempo=0 nao tem "refresh"
      ALERTA(1)
      DBOX(msg,,,25,,"'REFRESH`|(+/-)")         // mostra msg do tempo atual
      IF LASTKEY()=43                           // teclou +, entao
       drvtempo=IF(drvtempo>57,60,drvtempo+5)   // aumenta o tempo em 5 seg
      ELSEIF LASTKEY()=45                       // teclou -, entao
       drvtempo=IF(drvtempo<1,0,drvtempo-5)     // diminui o tempo em 5 seg
      ELSE                                      // teclou algo diferente de + e -
       EXIT                                     // entao aceita refresh atual
      ENDI
     ENDD
   #endi


   CASE tecl_p = K_ENTER                        // teclou o ENTER
    IF nao_vdbf                                 // nao veio do VDBF() o ENTER movimentara'
     KEYB CHR(VAL(SUBS(ch_tecl,dir_cur*2-1,2))) // para onde a SETA (TAB) esta apontando
    ELSE                                        // caso contrario,
     volta_db=.f.                               // retorna falso
    ENDI

   CASE tecl_p = K_TAB                          // teclou o TAB
    dir_cur()                                   // muda direcao do cursor

   CASE tecl_p = K_ALT_Z .AND. !db_zoom         // aumenta o tamanho da janela
    li_sup=3; li_inf=22; co_sup=3; co_inf=77    // coordenadas da janela expandida
    br_origem:nTop   := li_sup                  // passa as novas coordenadas
    br_origem:nbottom:= li_inf                  // para o browse de cima
    br_origem:nleft  := co_sup
    br_origem:nright := co_inf
    IF br_outro != NIL                          // existe a janela de baixo
     M->tp=li_sup+INT((li_inf-li_sup-1)/2)+1    // linha de divisao das janelas
     br_origem:nbottom := M->tp - 2             // final da janela de cima
     br_outro:nTop   := M->tp+1                 // topo da jenela de baixo
     br_outro:nbottom:= li_inf                  // ajusta o resto das
     br_outro:nleft  := co_sup                  // coordenadas
     br_outro:nright := co_inf
    ENDI
    db_zoom:=.t.                                // flag dizendo do zoom
    FORCABRW(.t.)                               // reimprime janela nao ativa
    MONTABRW()                                  // remonta janela

   CASE tecl_p = K_F1                           // teclou F1
    help()                                      // mostra ajuda correspondente

   CASE tecl_p = K_ESC                          // teclou ESC
    volta_db=.f.                                // abandona a consulta

   CASE carac_="A" .AND. br_w:colcount > 1      // apaga consulta se mais de 1 coluna
    ALERTA(2)                                   // pede confirmacao
    msg="Apagar a coluna|Cancelar a opera‡„o"
    cod_sos=1
    op_=DBOX(msg,,,E_MENU,,"COLUNA "+MAIUSC(br_w:getcolumn(br_w:colpos):heading))
    IF op_=1                                    // confirmou...
     br_w:delColumn(br_w:colpos)                // retira a coluna do browse
     grava_db = .t.                             // seta flag de consulta alterada
     br_w:configure()                           // remonta todo browse
    ENDI

   CASE carac_="C" .AND.;                       // congela/descongela coluna se
        br_w:colpos-1 != br_w:freeze            // a coluna ja' congelada
    IF br_w:freeze != 0                         // se outra coluna ja' congelada
     br_w:getcolumn(br_w:freeze+1):colsep:=NIL  // retira o marcador da coluna congelada
    ENDI
    br_w:freeze := br_w:colpos - 1              // congela coluna requerida
    IF br_w:freeze != 0                         // se nao descongelou todas colunas
     br_w:getcolumn(br_w:colpos):colsep:=" Û "  // coloca marcador de colunas congeladas
    ENDI
    br_w:configure()                            // remonta todo browse
    grava_db = .t.                              // seta flag de consulta alterada

   CASE carac_="D"                              // inclusao de registros
    IF LEN(sistema[op_sis,O_CPRELA])>0 .AND.;   // se for arquivo filho
       (br_w==br_origem .OR. EMPTY(chv_rela))   // e for janela original
     ALERTA(2)                                  // nao pode incluir!
     DBOX("Inclus„o n„o permitida!",,,3)        // mensagem ao usuario
     LOOP                                       // e retorna ao browse
    ENDI
    dele_atu=SET(_SET_DELETED,!drvvisivel)      // salva DELE() atual,
    br_w1 := br_w                               // browse atual,
    brw_tela = SAVESCREEN(0,0,MAXROW(),79)      // tela atual e o
    in_=INDEXORD()                              // indice atual para incluirmos
    DBSETORDER(1)                               // sempre pelo indice principal
    brw=.f.; op_menu=INCLUSAO                   // prepara para inclusao
    Tela_fundo=SAVESCREEN(0,0,MAXROW(),79)      // salva pano de fundo para ALT-F8
    IF op_sis>nss
     PW_INCL()                                  // inclusao de novos operadores
    ELSE
     &arq_cor._incl()                           // inclusao de novos registros de dados
    ENDI
    op_menu=PROJECOES; brw=.t.                  // volta para consulta
    DBSETORDER(in_)                             // retorna ao indice da consulta
    REGINICIO()                                 // verifica se reg esta' no filtro
    RESTSCREEN(0,0,MAXROW(),79,brw_tela)        // restaura a tela,
    SET(_SET_DELETED,dele_atu)                  // DELE() e o
    br_w := br_w1                               // browse anteriores
    br_w:refreshall()                           // reapresenta os dados na tela
    FORCABRW(.f.)                               // forca remontagem da janela relacionada
    MONTABRW()

   CASE carac_="E"                              // exclui registro

    #ifdef COM_REDE
     IF !BLOREG(10,.5)                          // tenta bloquear o arquivo
      LOOP                                      // nao conseguiu...
     ENDI
    #endi

    IF ! DELE()                                 // ja esta excluido?
     IF CONFEXCL()                              // pede confirmacao
      IF op_sis<=nss                            // se nao for a senha
       &arq_cor._get1(EXCLUI)                   // exclui registro/processo inverso
      ELSE                                      // se nao,
       DELE                                     // so' exclui
      ENDI
      br_w:refreshall()                         // remonta os reg da tela
      FORCABRW(.f.)                             // remonta janela relacionada
     ENDI
    ENDI

    #ifdef COM_REDE
     UNLOCK                                     // libera o registro
    #endi

    IF DELE() .AND.SET(_SET_DELETED)            // se nao que ver excluidos
     MOV_PTR(1)                                 // procura o proximo que
    ENDI                                        // nao esteje excluido

   CASE carac_="F" .OR. carac_="Q"              // filtra/quantifica
    cri_ant = criterio
    IF carac_="F"                               // filtra
     FILTRA(.t.,.t.)                            // escolhe o filtro
     br_w:cargo := {criterio,cpord,chv_rela,INDEXORD()}
     br_w:refreshall()                          // refaz toda a tela
     IF cri_ant!=criterio.AND.!EMPTY(criterio)  // se alterou o filtro
      grava_db=.t.                              // seta flag de consulta alterada
     ENDI
    ELSE                                        // quantifica
     FILTRA(.f.)                                // so' monta a expressao
     condq=criterio                             // retorna filtro anterior
     criterio = cri_ant
    ENDI
    brw_reg=RECN()                              // salva registro atual
    IF carac_="Q" .AND. LEN(condq)>2            // continuacao da quantificacao
     brw_tela = SAVESCREEN(0,0,MAXROW(),79)     // da mensagem que esta contando...
     DBOX("Condi‡„o:|"+LEFT(condq,78)+"|| AGUARDE...  Contando. ESC cancela",,,,NAO_APAGA)
     INI_ARQ()                                  // move ponteiro para o inicio do arquivo

     #ifdef COM_TUTOR
      COUN FOR &condq WHIL IN_KEY()!=K_ESC TO qu// conta....
     #else
      COUN FOR &condq WHIL INKEY()!=K_ESC TO qu // conta....
     #endi

     IF LASTKEY()!=K_ESC                        // nao cancelou entao mostra
      ALERTA(2)                                 // quantos reg foram contados
      DBOX("Existe(m) "+LTRIM(TRAN(qu,"@E 9,999,999"))+" registro(s)|na condi‡„o|"+LEFT(condq,78)+"|*",8)
     ENDI
     RESTSCREEN(0,0,MAXROW(),79,brw_tela)       // restaura a tela anterior e
     GO brw_reg                                 // o registro
    ENDI
    MONTABRW()                                  // remonta janela de visualizacao

   CASE carac_="G"                              // processo glogal
    brw_tela = SAVESCREEN(0,0,MAXROW(),79)      // salva situacao atual
    brw_reg = RECNO()
    GLOBAL()                                    // executa processo
    GO brw_reg                                  // restabelece situacao anterior
    REGINICIO()                                 // verifica se reg esta' no filtro
    br_w:cargo := {criterio,cpord,chv_rela,INDEXORD()}
    br_w:refreshall()                           // remonta dados da tela
    RESTSCREEN(0,0,MAXROW(),79,brw_tela)        // restaura tela
    MONTABRW()                                  // remonta janela do browse

   CASE carac_="I"                              // imprime consulta
    IMP_BRW()

   CASE carac_="J" .AND. br_outro != NIL        // troca janela de consulta
    TROCA_BRW()                                 // troca arquivo do browse
    br_w:colorspec := drvcorbox+","+INVCOR(drvcorbox)+","+drvcorenf+","+drvcorget
    FORCABRW(.t.)                               // troca as cores da janela
    MONTABRW()                                  // remonta dados e a
    br_w:hilite()                               // janela com a nova cor

   CASE carac_="J"                              // abre uma nova janela
    msg=""; op_a=0; db=""
    pp=SETKEY(K_F9,NIL)                         // desliga F9 (consulta outro DBF)
    FOR i=1 TO nss                              // monta menu de DBF disponiveis
     IF sistema[i,O_OUTROS,O_NIVEL]<=nivelop .AND.;
        LEN(sistema[i,O_INDIC])>0
      msg+="|"+sistema[i,O_MENU]
      db+=RIGHT(STR(100+i),2)
     ENDI
    NEXT
    cod_sos=30
    IF LEN(msg)>1                               // escolhe o DBF da nova janela
     op_a=DBOX(SUBS(msg,2),,,E_MENU,,"BASES DE DADOS")
    ENDI
    IF op_a>0                                   // escolheu...
     op_a=VAL(SUBS(db,op_a*2-1,2))              // acha a sua subscricao
     op_sis_x=op_sis                            // salva subscricao atual
     SETCOLOR(drvcortna)
     IF abreoutro(op_a)                         // e abre a outra janela
      grava_db = .t.                            // flag de consulta alterada
      tit_cons[2]=sistema[op_sis,O_MENS]        // titulo da segunda janela
      IF op_sis_x != op_sis
       op_ind=1                                 // indice 'default`
       qt_ind=LEN(sistema[op_sis,O_INDIC])      // qde de indices do arquivo
       chv=ATAIL(sistema[op_sis,O_CHAVE])       // pega ultimo elemento das chaves
       IF chv=="codlan"                         // se e' ntx de relacionamento nao pode
        qt_ind--
       ENDI
       IF qt_ind>1                              // escolheum conjunto de indice
        msg=""
        FOR t=1 to qt_ind
         msg+="|"+sistema[op_sis,O_CONSU,t]
        NEXT
        op_ind=DBOX(SUBS(msg,2),,,E_MENU,,"SELECIONE O INDICE")
        IF op_ind>1
         ind_rela=op_ind
         DBSETORDER(op_ind)
        ENDI
       ENDI
       SELE (m_origem)
       x_=ASCAN(sistema[op_sis_x,O_DBRELA],{|db_|sistema[op_sis,O_ARQUI]=db_})
       i_=LEN(sistema[op_sis,O_CPRELA])         // se DBF escolhido e relacionado,
       IF x_>0.AND.i_>0                         // monta a expressao de relacionamento
        chv_rela=""
        FOR i=1 TO LEN(sistema[op_sis,O_CPRELA])
         chv_rela+="+"+TRANSCAMPO(.f.,sistema[op_sis,O_CPRELA,i],i)
        NEXT
       ELSE                                     // se usuario montar expressao
        PEGARELA(.t.)
       ENDI
       chv_rela=IF(LEN(chv_rela)>2,SUBS(chv_rela,2),"")
       br_outro:cargo := {"","",chv_rela,op_ind}// inicializa variavel de usuario
      ENDI
      criterio:=cpord := ""                     // inicializa filtro/ordenacao
      SELE (outro_db)                           // muda para a janela de baixo
      PEGACHV2()                                // pega final do relaciomento
      INI_ARQ()                                 // procura 1o. reg da relacao
      LDBEDIT(.f.)                              // monta as novas colunas
      FORCABRW(.t.)                             // imprime dados da janela de cima
      MONTABRW()                                // monta nova janela de visualizacao
     ELSE
      op_sis = op_sis_x                         // nao conseguiu abrir nova janela
     ENDI
    ENDI
    SETKEY(K_F9,pp)                             // habilita F9 (consulta outros DBFs)

   CASE carac_="L"                              // localiza registro
    SEPARA(br_w:getcolumn(br_w:colpos):cargo)   // separa atributos da coluna
    cod_sos=36
    ecara=(tp_cp=="C".OR.tp_cp=="M")            // tipo do campo
    brw_tela = SAVESCREEN(0,0,MAXROW(),79)      // salva tela atual
    chvpesq=IF(ecara,SPAC(30),IF(tp_cp="D",CTOD(''),IF(tp_cp="L",.t.,0)))
    msg="Argumento - Localiza argumento no campo "+cp_titu+;
        "|Condi‡„o - Localiza registro sob uma condi‡„o"+;
        "|Cancelar a opera‡„o"                  // escolhe o tipo de localizacao
    x=DBOX(msg,,,E_MENU,,SEPLETRA("LOCALIZA€ŽO",1))
    IF x!=0 .AND. x!=3                          // nao cancelou
     cond_p=""
     IF x=1                                     // localiza por argumento
      msg="LOCALIZAR ARGUMENTO "+IF(ecara,"CONTIDO ","")+" EM "+MAIUSC(cp_titu)
      chvpesq=DBOX("Informe o argumento",,,,,msg,chvpesq,cp_masc)
      IF cp_crit=="V" .OR. CRIT(cp_crit,18)     // argumento de pesquisa ok?
       IF (!EMPT(chvpesq) .OR. tp_cp="L").AND.LASTKEY()!=K_ESC
        IF ecara                                // se for caracter
         chvpesq=ALLTRIM(chvpesq)               // deixa localizar so as letras digitadas
         igc=1                                  // se tem minusculo no campo
         IF cp_masc!="@!"                       // pergunta se quer ignorar a caixa
          igc=DBOX("Sim|N„o|Cancelar a opera‡„o",,,E_MENU,,"IGNORAR CAIXA|(A=a)?")
         ENDI
         IF igc=1.OR.igc=2                      // prepara expressao de pesquisa
          cond_p=IF(igc=2,"'"+chvpesq+"' $ "+cp_,"MAIUSC('"+chvpesq+"') $ UPPER("+cp_+")")
         ENDI
        ELSE
         cond_p=cp_+"=chvpesq"                  // prepara expressao de pesquisa
        ENDI
       ENDI
      ENDI
     ELSE                                       // localiza por condicao
      cri_ant = criterio                        // salva filtro atual
      FILTRA(.f.)                               // monta expressao de pesquisa
      cond_p=criterio
      criterio = cri_ant                        // retorna filtro atual
     ENDI
     RESTSCREEN(0,0,MAXROW(),79,brw_tela)       // restaura tela anterior
     IF LEN(cond_p)>2                           // continua a localizar...
      DBOX("Localizando|"+LTRIM(TRAN(chvpesq,""))+"|*|ESC interrompe",,,,NAO_APAGA,"AGUARDE...")
      brw_reg=RECN()
      INI_ARQ()                                 // move ponteiro para o inicio do arquivo

      #ifdef COM_TUTOR
       LOCA FOR &cond_p. WHIL IN_KEY()!=K_ESC   // tenta localizar registro desejado
      #else
       LOCA FOR &cond_p. WHIL INKEY()!=K_ESC    // tenta localizar registro desejado
      #endi

      IF ! FOUND().AND.LASTKEY()!=K_ESC         // nao achou ou cancelou
       ALERTA(4)
       DBOX("N„o encontrado!|*",13,40)          // mensagem ao usuario
       GO brw_reg
      ELSE
       ALERTA(1)                                // achou...
       fg_loc=.t.                               // sinal sonoro
      ENDI
     ENDI
     br_w:refreshall()                          // remonta os dados da consulta
    ENDI
    RESTSCREEN(0,0,MAXROW(),79,brw_tela)        // restaura tela anterior

   CASE carac_="M"                              // modifica registro
    IF !br_w:stable                             // forca a apresentacao de
     br_w:forcestable()                         // todos os registros na tela
     x_=COL(); y_=ROW()                         // salva coordenadas atuais do cursor
    ENDI

    #ifdef COM_REDE
     IF !BLOREG(10,.5)                          // tenta bloquear o registro
      LOOP                                      // nao conseguiu...
     ENDI
    #endi

    IF !CONFALT()                               // verifica se o registro
     LOOP                                       // pode ser modificado
    ENDI
    SEPARA(br_w:getcolumn(br_w:colpos):cargo)   // separa atributos da coluna
    evirt=(cp_crit=="V")                        // pode modificar?
    IF (AT(UPPER(cp_),UPPER(INDEXKEY(1)))>0.AND.sistema[op_sis,O_OUTROS,O_TPCHV]).OR.;
       evirt.OR.DELE()
     ALERTA()
     DBOX(IF(DELE(),"REGISTRO EXCLU¡DO","CAMPO NŽO EDITVEL"),12,,1)
    ELSE
     IF op_sis<=nss                             // se nao esta' alterando a senha,
      &arq_cor._get1(FORM_INVERSA)              // executa processo inverso, se existir
     ENDI
     pp=.f.                                     // flag "refresh" na outra janela?
     IF IF(!EMPTY(cp_when).AND.;                // tem pre-validacao. pode modificar?
        !("MTAB(" $ cp_when).AND.!("VDBF(" $ cp_when),EVAL(&("{||"+cp_when+"}")),.t.)
      SETCOLOR(drvcorbox)                       // coloca mensagem no topo da janela
      IF br_w:nleft+22<br_w:nright              // avisando que estamos modificando
       @ br_w:ntop-2,br_w:nleft+12 SAY "{Modifica}"
      ENDI
      brw_reg = RECNO()                         // salva registro atual
      ALERTA(1)                                 // Beep!
      IF tp_cp=="M"                             // campo memo...
       EDIMEMO(cp_,cp_titu,15,2,MAXROW()-1,3+VAL(SUBS(cp_masc,3)),cp_crit)
      ELSE
       i = br_w:getcolumn(br_w:colpos):width    // o tamanho atual da coluna
       IF i != LEN(TRAN(&cp_.,cp_masc)) .AND.;  // esta' diferente to tamanho
          tp_cp="C"                             // real do campo estao vamos
        cp_masc="@S"+ALLTRIM(STR(i,3))+cp_masc  // forcar a rolagem do campo
       ENDI
       @ y_,x_ GET &cp_. PICT cp_masc;
                         VALI CRIT(cp_crit);
                         WHEN cp_when
                         AJUDA cp_help
                         CMDF8 cp_cmd
       READ
      ENDI
      IF br_w:nleft+22<br_w:nright              // retira mensagem de alteracao
       @ br_w:ntop-2,br_w:nleft+12 SAY REPL(SUBS(mold,2,1),10)
      ENDI
      REGINICIO()                               // verifica se reg esta' no filtro
      br_w:refreshcurrent()                     // refaz a linha onde o campo foi modificado
      IF tp_cp!="M".AND.LASTKEY()!=K_ESC.AND.;  // se o campo nao for memo, nao deu ESC,
         RECNO()=brw_reg .AND.;                 // nao esta fora do filtro/relacao e
         AT(UPPER(cp_),UPPER(INDEXKEY(0)))=0    // o campo nao faz parte do indice
       i_=CHR(VAL(SUBS(ch_tecl,dir_cur*2-1,2))) // entao passa para o proximo campo
       KEYB i_+"M"                              // onte o TAB esta indicando
      ELSE                                      // caso contrario,
       IF RECNO() <> brw_reg .OR.;              // se o campo esta fora do filtro
          AT(UPPER(cp_),UPPER(INDEXKEY(0)))>0   // ou o campo for parte do indice
        br_w:refreshall()                       // remonta toda a tela
       ENDI
       pp=.t.                                   // flag para refazer o browse
      ENDI
      GO brw_reg                                // reposiciona ponteiro

     ELSE                                       // nao pode ser modificado
      ALERTA()                                  // mostra por que
      DBOX("Modifica quando "+UPPER(cp_when),,,3,,"PR-CR¡TICA NŽO ATENDIDA!")
     ENDI

     IF op_sis<=nss                             // se nao for o arquivo de senhas,
      &arq_cor._get1(FORM_DIRETA)               // executa processos/lancamentos
     ENDI
     IF pp                                      // se for preciso, forca
      REGINICIO()                               // verifica se reg esta' no filtro
      FORCABRW(.f.)                             // browse da outra janela
     ENDI
    ENDI

    #ifdef COM_REDE
     UNLOCK                                     // atualiza o disco
    #endif


   CASE carac_="N"                              // cria nova coluna
    cod_sos=28
    cp_ =SPAC(250) ; cp_titu=SPAC(30)           // inicializa variveis
    cp_masc=SPAC(30)
    msg="T¡tulo da nova coluna:"
    f10=.f.                                     // recebe titulo da nova coluna
    SET KEY K_F10 TO colnova                    // F10 campo de outro arquivo
    cp_titu=DBOX(msg,,,,,"NOVA COLUNA|*|F10=CAMPO DE OUTRO ARQUIVO",cp_titu)
    SET KEY K_F10 TO                            // desativa F10
    IF LASTKEY()!=K_ESC                         // se nao abandonou e nao teclou
     IF !f10                                    // F10, recebe conteudo da nova coluna
      msg+=" "+ALLTRIM(cp_titu)+"|Express„o conte£do:"
      DO WHILE .t.
       SET KEY K_F10 TO ve_campos               // F10 ve campos da estrutura
       cp_=DBOX(msg,,,,,"NOVA COLUNA|*|F10=CAMPOS DO ARQUIVO",cp_,"@S52@!")
       SET KEY K_F10 TO                         // desativa F10
       IF LASTKEY()!=27 .AND. !EMPTY(cp_)       // verifica se o conteudo e valido
        IF !CRIT("[U]!=TYPE(cp_) .OR. ([|] $ cp_ .AND. [->] $ cp_)~EXPRESSŽO ILEGAL",15)
         LOOP
        ENDI
       ENDI
       EXIT
      ENDD
     ENDI
     IF !EMPT(cp_) .AND. LASTKEY()!=K_ESC      // nao cancelou...
      IF !f10                                  // recebe mascara da nova coluna
       msg+=" "+LEFT(ALLTRIM(cp_),30)+"|Com a m scara:"
       cp_masc=DBOX(msg,,,,,"NOVA COLUNA",cp_masc,"@!")
      ENDI
      IF LASTKEY()!=K_ESC                      // se nao cancelou
       IF SETARELA(cp_)                        // coloca set relation
        IF br_w == br_origem                   // e prepara variavel para
         db_1rela=db_1rela+TRIM(cp_)+"³"       // a gravacao da consulta
        ELSE
         db_2rela=db_2rela+TRIM(cp_)+"³"
        ENDI
        cp_=SUBS(cp_,AT("|",cp_)+1)
       ENDI                                    // cria nova coluna com o que
       ncol = br_w:colpos                      // foi informado
       cp_titu=ALLTRIM(cp_titu) ; cp_=ALLTRIM(cp_) ; cp_masc=ALLTRIM(cp_masc)
       br_w:inscolumn(ncol,tbcolumnnew(cp_titu,&("{||TRAN("+cp_+",["+cp_masc+"])}")))
       br_w:getcolumn(ncol):cargo := cp_+"³"+cp_masc+"³"+cp_titu+"³³V"
       br_w:getcolumn(ncol):width := LEN(TRAN(&cp_.,cp_masc))
       br_w:getcolumn(ncol):colorblock={||IF(DELE(),{3,2},{1,2})}
       grava_db = .t.                          // modificou a consulta (flag)
       br_w:refreshall()                       // remonta toda a tela
      ENDI
     ENDI
    ENDI
    SET KEY K_F10 TO                           // desativa F10

   CASE carac_="O"                             // ordenacao da consulta
    cpord=""
    br_wx = br_w                               // salva browse atual
    CLASS(.t.)                                 // recebe expressao de ordenacao
    IF !EMPT(cpord)                            // montou ordenacao?
     br_w:refreshall()                         // refaz toda a tela
     IF INDEXORD()>LEN(sistema[op_sis,O_CHAVE])// se criou indice extra
      grava_db = .t.                           // seta flag de gravacao e
     ENDI                                      // grava a nova ordenacao
     br_w:cargo:={criterio,cpord,chv_rela,INDEXORD()}
    ENDI
    MONTABRW()                                 // refaz todo o browse

   CASE carac_="P" .AND. ! EMPT(INDEXKEY(1))   // pesquisa indexada de registro
    brw_reg = RECNO()                          // registro atual
    POSI()                                     // recebe/procura registro
    IF brw_reg != RECNO()                      // se o reg nao e o mesmo,
     br_w:rowpos = 1                           // coloca reg atual na primeira
    ENDI                                       // linha da tela
    br_w:configure()                           // refaz a configuracao do browse

   CASE carac_="R"                             // recupera registro

    #ifdef COM_REDE
     IF !BLOREG(10,.5)                         // se nao bloqueou o registro,
      LOOP                                     // retorna ao browse
     ENDI
    #endi

    IF DELE()                                  // se o registro esta' excluido
     IF !EMPT(sistema[op_sis,O_CONDREC,1])     // se tem condicao de
      IF !&(sistema[op_sis,O_CONDREC,1])       // recuperacao e se esse
       ALERTA(2)                               // reg nao pode ser
       msg=sistema[op_sis,O_CONDREC,2]         // avisa o motivo
       DBOX(msg,,,,,"ATEN€ŽO!|IMPOSS¡VEL RECUPERAR")
       LOOP                                    // e retorna
      ENDI
     ENDI
     IF op_sis<=nss                            // se o arquivo nao for o de senhas,
      &arq_cor._get1(RECUPERA)                 // recupera reg/processo direto
     ELSE                                      // se for o de senhas
      RECA                                     // so' recupera
     ENDI
     ALERTA(1)                                 // aviso sonoro
     br_w:refreshcurrent()                     // refaz so' a linha do browse
     FORCABRW(.f.)                             // remonta a outra janela (se houver)
    ENDI

    #ifdef COM_REDE
     UNLOCK                                    // libera registro
    #endi


   CASE carac_="S".AND.fg_loc                  // seguinte (proximo do localiza)
    brw_tela = SAVESCREEN(0,0,MAXROW(),79)     // salva tela/avisa que esta localizando
    DBOX("LOCALIZANDO "+LTRIM(TRAN(chvpesq,""))+".|ESC interrompe",,,,NAO_APAGA,"AGUARDE!")
    brw_reg=RECN()                             // salva registro atual
    SKIP IF(EOF(),0,1)                         // pula para o proximo, se nao for fim de arq

    #ifdef COM_TUTOR
     LOCA FOR &cond_p. WHIL IN_KEY()!=K_ESC    // continua a procura...
    #else
     LOCA FOR &cond_p. WHIL INKEY()!=K_ESC     // continua a procura...
    #endi

    IF ! FOUND().AND.LASTKEY()!=K_ESC          // se nao achou,
     ALERTA(4)                                 // avisa
     DBOX("Registro n„o encontrado!",13,40)
     GO brw_reg
    ELSE                                       // achou...
     ALERTA(1)                                 // avisa com beep e
     br_w:refreshall()                         // prepara p/ remontar toda a tela
    ENDI
    RESTSCREEN(0,0,MAXROW(),79,brw_tela)       // retira msg de "localizando"

   CASE carac_="T"                             // muda tamanho da coluna
    SEPARA(br_w:getcolumn(br_w:colpos):cargo)  // pega tamanho atual
    x=IF(TYPE(cp_)=="M",60,LEN(TRAN(&cp_.,cp_masc)))
    msg="Informe o novo tamanho da coluna "+;
        MAIUSC(br_w:getcolumn(br_w:colpos):heading)
    cod_sos=1
    x=DBOX(msg,,,,,"TAMANHO DA COLUNA",x,"99") // recebe o novo tamanho
    IF CRIT(STR(x)+"<=77.AND."+STR(x)+;        // se o tamanho e valido
       ">0~TAMANHO ILEGAL",12)
     br_w:getcolumn(br_w:colpos):width = x     // atualiza tamanho da coluna
     grava_db = .t.                            // no browse e
     br_w:configure()                          // reconfigura tudo
    ENDI

   CASE carac_="V"                             // ve todo o registro na tela
    tela_fundo=SAVESCREEN(0,0,MAXROW(),79)     // salva tela
    t_tab:=SETKEY(K_TAB,NIL)                   // desativa o TAB

    #ifdef COM_MOUSE
     IF drvmouse                               // se mouse esta' ativo,
      MOUSEGET(@x_,@y_)                        // salva sua posicao atual
     ENDI
    #endi

    i_=SETCOLOR()                              // salva a cor atual
    DO WHILE .t.
     DISPBEGIN()                               // comeca a montagem da tela
     IMPRELA()                                 // imprime telas relacionadas
     &arq_cor._gets()                          // apresenta o conteudo do registro
     INFOSIS()                                 // imprime o rodape' da tela
     DISPEND()                                 // mostra tela pronta
     ALERTA(1)
     cod_sos=35

     #ifdef COM_MOUSE
      tecl_p=MOUSETECLA(l_s,c_s,l_i,c_i,.f.)   // espera clique ou alguma tecla
     #else

      #ifdef COM_TUTOR

       #ifdef COM_REDE
        tecl_p=IN_KEY(drvtempo)                // espera tecla ou sai para refresh
       #else
        tecl_p=IN_KEY(0)                       // espera uma tecla ser digitada
       #endi

      #else

       #ifdef COM_REDE
        tecl_p=INKEY(drvtempo)                 // espera tecla ou sai para refresh
       #else
        tecl_p=INKEY(0)                        // espera uma tecla ser digitada
       #endi

      #endi

     #endi

     DO CASE
      CASE tecl_p=K_ALT_F8                     // teclou F8 (rolagem da janela)
       rola_t=.t.                              // liga flag e
       ROLATELA()                              // executa a rolagem
      CASE tecl_p=K_ESC.OR.tecl_p=K_ENTER.OR.tecl_p=32
       EXIT                                    // abandona
     ENDC
    ENDD
    SETCOLOR(i_)                               // restaura cor anterior

    #ifdef COM_MOUSE
     IF drvmouse                               // define janela do mouse
      MOUSEBOX(br_w:ntop-1,br_w:nleft-1,br_w:nbottom+1,br_w:nright+1)
      DO WHIL MOUSEGET(0,0)!=0                 // so' sai se os botoes do
      ENDD                                     // mouse estiverem liberados
      MOUSESET(x_,y_)                          // restaura a posicao do mouse
     ENDI
    #endi

    RESTSCREEN(0,0,MAXROW(),79,tela_fundo)     // restaura tela
    SETKEY(K_TAB,t_tab)                        // TAB volta a funcionar

   CASE carac_="X"                           // exporta dados
    cod_sos=32                               // escolhe o formato da exportacao
    msg="Texto - delimitados, para editores de texto|"+;
        "SDF - 'standard Data Format` para outros sistemas|"+;
        "DBF - formato padr„o dBASE"
    op_exp=DBOX(msg,,,E_MENU,,"TIPO DE ARQUIVO DE SAIDA")
    IF op_exp!=0
     IF op_exp=1                             // escolheu o delimitado, entao
      dli_exp=","                            // escolhe o delimitador
      dli_exp=DBOX("Informe o delimitador",,,,,"SEPARA€ŽO DOS CAMPOS",dli_exp)
     ENDI
     IF LASTKEY()!=K_ESC
      brw_tela = SAVESCREEN(0,0,MAXROW(),79) // salva a tela
      arq_=ARQGER()                          // recebe o nome do arquivo a gerar
      IF !EMPTY(arq_)                        // quer continuar...
       cod_sos=1
       arqexp=arq_+".TXT"                    // se o arq informado existir
       IF FILE(arqexp)                       // verifica se pode gravar por cima
        op_=DBOX("Gravar por cima|Cancelar a opera‡„o",,,E_MENU,,"ARQUIVO "+UPPER(arqexp)+" JA EXISTE!")
        cn=(op_!=1)
        IF !cn                               // pode sobrepor,
         ERASE (arqexp)                      // entao mata arq
        ENDI
       ENDI
       IF op_exp=3                           // se exporta para outro DBF
        IF FILE(arq_+".DBF")                 // verifica se o DBF ja existe
         op_=DBOX("Gravar por cima|Cancelar a opera‡„o",,,E_MENU,,"ARQUIVO "+UPPER(arq_)+".DBF JA EXISTE!")
         cn=(op_!=1)
        ENDI
       ENDI
      ENDI
      IF !cn                                 // avisa que esta' trabalhando...
       DBOX("Gerando o arquivo "+arqexp,15,,,NAO_APAGA)
       ASIZE(estr_dbf,0); ASIZE(cp_exp,0)    // vetores auxiliares
       FOR i=1 TO br_w:colcount              // exporta todas as colunas
        SEPARA(br_w:getcolumn(i):cargo)      // separa atributo da coluna
        IF tp_cp!="M"                        // campo memo nao e' exportado
//         IF op_exp=3                         // exporta para DBF
	  cp_x=cp_
	  casadec=0                          // se a coluna for numerica, verifica
	  IF tp_cp="N"                       // a qde de casas decimais
	   casadec=IF("." $ cp_masc,LEN(cp_masc)-RAT(".",cp_masc),0)
	   tamanho=0                         // acha o tamanho
	   FOR t=1 TO LEN(cp_masc)           // do campo
	    IF !(SUBS(cp_masc,t,1) $ "@BCDEKXZR, ()")
	     tamanho++
	    ENDI
	   NEXT
	  ELSEIF tp_cp="D"                   // a coluna e' uma data
	   tamanho=8                         // o tamanho e' sempre 8
	  ELSEIF tp_cp="L"                   // a coluna e' tipo logico
	   tamanho=1                         // o tamanho e' sempre 1
	  ELSE                               // coluna tipo caracter
	   tamanho=br_w:getcolumn(i):width
	   cp_="LEFT("+cp_+"+["+SPAC(tamanho)+"],"+STR(tamanho,3)+")"
	  ENDI
	  IF "->" $ cp_x                     // coluna de outro arquivo
	   cp_x=SUBS(cp_x,AT("->",cp_x)+2)   // retira o nome do DBF
	  ENDI
	  FOR tt=1 TO 12                     // retira caracteres ilegais
	   cr_=SUBS(" ()*/+-^%$@&",tt,1)     // do conteudo da coluna
	   IF cr_ $ cp_x                     // nome do campo do DBF a exportar
	    cp_x=STRTRAN(cp_titu,cr_,"")
	   ENDI
	  NEXT                               // monta vetor da nova estrutura
	  AADD(estr_dbf,{cp_x,tp_cp,tamanho,casadec})
//         ELSE                                // exportacao TXT/SDF
	 IF op_exp!=3                                // exportacao TXT/SDF
	  IF AT(tp_cp,"CN")>0                // caracter/numerico trunca pelo tam da coluna
	   cp_="LEFT(TRAN("+cp_+",["+cp_masc+"])+["+SPAC(br_w:getcolumn(i):width)+"],"+STR(br_w:getcolumn(i):width,3)+")"
	  END IF
	 ENDI
	 AADD(cp_exp,cp_)                    // vetor com conteudos a exportar
	ENDI
       NEXT
       brw_reg = RECNO()                     // volta para registro anterior
       dele_atu:=SET(_SET_DELETED,.t.)       // os excluidos nao serao exportados
       INI_ARQ()                             // move ponteiro para o inicio do arquivo
       SET ALTE TO (arq_)                    // abre o arquivo para gravacao
       SET ALTE ON                           // liga gravacao
       SET CONS OFF                          // nao iremos exibir na tela
       q=CHR(34)                             // "aspas"

       IF op_exp=1                             // escolheu o delimitado, entao
	FOR t=1 TO LEN(estr_dbf)               // e para todas as colunas
	 c_p=estr_dbf[t,1]    // "code block" com o conteudo da coluna
	 ?? q+c_p+q+IF(t=LEN(estr_dbf),"",dli_exp)
	NEXT
	?
       ENDI

       DO WHIL !EOF()                        // para todos os registros
        FOR t=1 TO LEN(cp_exp)               // e para todas as colunas
         c_p=EVAL(&("{||"+cp_exp[t]+"}"))    // "code block" com o conteudo da coluna
         IF op_exp!=1                        // se nao for delimitado
          c_p=IF(VALTYPE(c_p)="D",DTOS(c_p),c_p)
          ?? c_p                             // grava no arquivo
         ELSE                                // se delimitado grava entre aspas
          c_p=IF(VALTYPE(c_p)="D",DTOC(c_p),c_p)
          ?? q+ALLTRIM(c_p)+q+IF(t=LEN(cp_exp),"",dli_exp)
         ENDI
        NEXT
        ?                                    // pula para proxima linha
        SKIP                                 // pega proximo registro
       ENDD
       SET ALTE OFF                          // desliga a gravacao
       SET ALTE TO                           // fecha arquivo
       SET CONS ON                           // reabilita o video
       SET(_SET_DELETED,dele_atu)            // restaura situacao do DELE()
       GO brw_reg                            // volta para registro anterior
       IF op_exp=3                           // exportacao para DBF
        DBOX("Gerando o arquivo "+arq_+".DBF",15,,,NAO_APAGA)
        i_=LEN(estr_dbf)                     // verifica/assegura que os nomes
        FOR t=1 TO i_                        // dos campos nao estao repetidos
         FOR i=t+1 TO i_
          IF estr_dbf[t,1]=estr_dbf[i,1]
           estr_dbf[i,1]=LEFT(estr_dbf[i,1],8)+STRZERO(i,2)
          ENDI
         NEXT
        NEXT
	are_a:=SELECT()                      // area atual
	SELE 0
        DBCREATE(arq_,estr_dbf)              // cria o novo DBF
        USE (arq_)                           // abre
        APPEND FROM (arqexp) SDF             // e anexa os registros
        USE                                  // fecha
        ERASE (arqexp)                       // elimina arq .txt temporario
	SELE (are_a)                         // retorna para area DBF origem
       ENDI
       AFILL(cp_exp,"")
       RESTSCREEN(0,0,MAXROW(),79,brw_tela)  // restaura a tela e
       ALERTA()                              // beep
      ENDI
     ENDI
    ENDI

   CASE carac_="Z"                             // totaliza coluna
    SEPARA(br_w:getcolumn(br_w:colpos):cargo)  // separa atributos da coluna
    IF !(tp_cp $ "NC")                         // se o campo nao for numerico
     ALERTA()                                  // nao da para somar
     DBOX("Coluna n„o pode ser totalizada",,,2)
    ELSE
     brw_tela = SAVESCREEN(0,0,MAXROW(),79)    // salva tela, registro e avisa
     brw_reg=RECN()                            // que esta somando
     DBOX("Totalizando "+MAIUSC(cp_titu)+"|ESC interrompe",,,,NAO_APAGA,"AGUARDE!")
     INI_ARQ()                                 // vai para o topo do arquivo
     x=INDEXKEY(0)                             // e comeca a somar
     y=IF(EMPTY(criterio),"1=1",criterio)

     #ifdef COM_TUTOR
      IF tp_cp="N"
       SUM &cp_. TO tot_ FOR !DELE() WHIL IN_KEY()!=K_ESC .AND. &y. .AND. IF(EMPTY(chv_rela).OR.br_w==br_origem,.t.,&x.=chv_1)
      ELSE
       SUM VAL(&cp_.) TO tot_ FOR !DELE() WHIL IN_KEY()!=K_ESC .AND. &y. .AND. IF(EMPTY(chv_rela).OR.br_w==br_origem,.t.,&x.=chv_1)
      ENDI
     #else
      IF tp_cp="N"
       SUM &cp_. TO tot_ FOR !DELE() WHIL INKEY()!=K_ESC .AND. &y. .AND. IF(EMPTY(chv_rela).OR.br_w==br_origem,.t.,&x.=chv_1)
      ELSE
       SUM VAL(&cp_.) TO tot_ FOR !DELE() WHIL INKEY()!=K_ESC .AND. &y. .AND. IF(EMPTY(chv_rela).OR.br_w==br_origem,.t.,&x.=chv_1)
      ENDI
     #endi

     GO brw_reg
     IF LASTKEY()!=K_ESC                       // nao cancelou
      ms="999,999,999,999,999,999"             // mostra quanto foi o somatorio
      dec=AT(".",cp_masc)
      ms+=IF(dec>0,SUBS(cp_masc,dec),".99")
      ms=IF(LEFT(cp_masc,1)="@",LEFT(cp_masc,3)+ms,ms)
      ALERTA(4)
      DBOX("O somat¢rio de "+MAIUSC(cp_titu)+" ‚|"+TRAN(tot_,ms),,,,,"TOTALIZA€ŽO")
     ENDI
     RESTSCREEN(0,0,MAXROW(),79,brw_tela)      // restaura a tela
    ENDI

  ENDC
 ENDI
ENDD

#ifdef COM_MOUSE
 IF drvmouse
  DO WHIL MOUSEGET(@Li,@Co)!=0                 // se qualquer botao do mouse
  ENDD                                         // estiver pressionado, espera
  MOUSEBOX(0,0,MAXROW(),79)                    // a sua liberacao
 ENDI
#endi

RETU NIL

/*
   Sintaxe: IMP_BRW()
   Funcao.: Imprime a consulta da funcao EDITA()
   Retorna: NIL
*/
STATIC FUNC IMP_BRW()
LOCAL dele_atu
ALERTA(1)
x=PADR(tit_cons[IF(br_w == br_origem,1,2)],40)          // recebe um titulo do relatorio
cod_sos=38                                              // sugerindo o titulo da consulta
tit_rel=DBOX("Informe um t¡tulo",,,,,"IMPRESSŽO DE CONSULTA",x)
IF LASTKEY()!=K_ESC
 cod_sos=1
 ALERTA(1)                                              // a onde vai imprimir?
 tps=TP_SAIDA(,0,.T.)                                   // escolhe a saida...
 IF tps>0 .AND. LASTKEY()!=K_ESC
  cn=.f.
  ALERTA(1)
  IF tps=2                                              // saida para arquivo
   arq_=ARQGER()                                        // solicita um nome
   cn=EMPTY(arq_)
  ELSE                                                  // vai para a impressora
   cn=!PREPIMP()                                        // pede para prepara-la
   arq_=drvporta                                        // porta de saida configurada
  ENDI
  IF !cn
   brw_reg=RECN()                                       // salva registro atual
   dele_atu=SET(_SET_DELETED,.t.)                       // salva/seta visao dos reg apagados
   brw_tela = SAVESCREEN(0,0,MAXROW(),79)               // salva tela
   ltot := ltot_o := 0                                  // inicializa variaveis
   brw_cb1 = ""; brw_imp:=just_memo:=tot_num := .f.
   IF br_w == br_origem .AND. VALTYPE(outro_db) = "C"   // se esta imprimindo da janela de cima
    id_carg = br_outro:cargo                            // vamos verificar se a janela
    brw_imp = !EMPTY(id_carg[3])                        // de baixo esta relacionada
   ENDI
   FOR t = 1 TO br_w:colcount                           // para cada coluna,
    SEPARA(br_w:getcolumn(t):cargo)                     // separa os atributos
    le_=br_w:getcolumn(t):width                         // tamanho da coluna
    brw_cb1 +=" "+PADR(ALLTRIM(cp_titu),le_)            // monta linha de cabecalho
    ltot += le_ + 1                                     // tamanho do relatorio
    IF tp_cp=="N"                                       // coluna e' numerica?
     var="to"+SUBS(STR(t+100,3),2)                      // inicializa variavel
     &var.=0; tot_num=.t.                               // para totalizar a coluna
    ENDI
    IF tp_cp="M"                                        // coluna e' memo?
     just_memo=.t.                                      // liga flag da pergunta
    ENDI                                                // para justificar memo
   NEXT
   brw_cb1 = SUBS(brw_cb1,2)                            // tira 1o. espaco do titulo e
   ltot--                                               // ajusta tamanho do relatorio
   IF brw_imp                                           // existe janela relacionada?
    SELE (outro_db)                                     // seleciona o DBF da janela de
    ltot_o = 0                                          // baixo e inicializa variaveis
    brw_cb2 = ""
    FOR t = 1 TO br_outro:colcount                      // para cada coluna
     SEPARA(br_outro:getcolumn(t):cargo)                // separa os atributos
     le_=br_outro:getcolumn(t):width                    // tamanho da coluna
     brw_cb2 +=" "+PADR(ALLTRIM(cp_titu),le_)           // monta titulo das colunas
     ltot_o += le_ + 1                                  // e o tamanho do relatorio
     IF tp_cp=="N"                                      // coluna e' numerica?
      var="too"+SUBS(STR(t+100,3),2)                    // inicializa variavel
      &var.=0; tot_num=.t.                              // para totalizar a coluna
     END IF
     IF tp_cp="M"                                       // coluna e' memo?
      just_memo=.t.                                     // liga flag de pergunta
     ENDI                                               // para justificar memo
    NEXT
    brw_cb2 = SUBS(brw_cb2,2)                           // tira 1o. espaco do titulo e
    ltot_o--                                            // ajusta tamanho do relatorio
    SELE (m_origem)                                     // seleciona DBF da janela de cima
   ENDI
   IF tot_num                                           // tem alguma coluna numerica?
    ALERTA(1)                                           // pergunta se quer totalizar
    cod_sos=1                                           // o relatorio
    i=DBOX("Sim|N„o",,,E_MENU,,"TOTALIZAR AS|COLUNAS NUMRICAS")
    IF i=0
     RETU                                               // cancelou...
    ENDI                                                // flag se quer totalizar
    tot_num=(i=1)
   ENDI
   IF just_memo                                         // tem algum campo memo?
    ALERTA(1)                                           // pergunta se quer justificar
    cod_sos=50                                          // os campos memos no relatorio
    i=DBOX("Sim|N„o",,,E_MENU,,"JUSTIFICAR OS|CAMPOS MEMO")
    IF i=0
     RETU                                               // cancelou...
    ENDI
    just_memo=(i=1)                                     // flag se quer justificar memos
   ENDI
   DBOX("Aguarde o final de impress„o||ESC para interromper",17,,,NAO_APAGA)
   INI_ARQ()                                            // vai para o inicio do arquivo
   cl:=pg:=creg := 0                                    // inicializar variaveis
   SET PRINTER TO (arq_)                                // abre arq escolhido ou redireciona saida
   SET DEVI TO PRIN                                     // se tamanho > 80, comprime
   @ PROW(),PCOL() SAY IF(MAX(ltot,ltot_o)>80,&drvpcom.,"")
   cl=CABCONS(brw_cb1,tit_rel)                          // imprime cabecalho da janela superior
   brw_cn = .f.
   x = INDEXKEY(0)
   DO WHIL ! EOF() .AND. ! brw_cn .AND.;                // imprime ate o fim do arquivo
      IF(EMPTY(chv_rela).OR.br_w==br_origem,.t.,&x.=IF(EMPTY(criterio),"","T")+chv_1)
    IF cl>IF(brw_imp,54,57)                             // atingiu o final da folha
     EJEC                                               // pula para proxima pagina
     cl=CABCONS(brw_cb1,tit_rel)                        // e reimprime o cabecalho
    ENDI

    #ifdef COM_TUTOR
     IF IN_KEY()=K_ESC .OR. MOUSEGET(0,0)=2             // quer cancelar a impressao?
    #else
     IF INKEY()=K_ESC .OR. MOUSEGET(0,0)=2              // quer cancelar a impressao?
    #endi
     brw_cn = CANC(1)                                   // pede confimacao do cancelamento
     LOOP
    ENDI
    lin=""; tem_memo=.f.; qli_m=0
    FOR t=1 TO br_w:colcount                            // monta linha a imprimir
     SEPARA(br_w:getcolumn(t):cargo)                    // separa os atributos da coluna
     i = br_w:getcolumn(t):width                        // tamanho da coluna
     IF tp_cp="M"                                       // coluna e' memo?
      IF qli_m<MLCOUNT(&cp_.,i)                         // mumero maximo de linhas
       qli_m=MLCOUNT(&cp_.,i)                           // a imprimir de todos campos memo
      ENDI                                              // monta linha de impressao
      lin += IMPAC(LEFT(MEMOLINE(&cp_.,i,1)+SPACE(i),i),just_memo)+" "
      tem_memo=.t.                                      // flag tem memo?
     ELSE
      IF tp_cp=="N" .AND. tot_num                       // coluna e' numerica?
       var="to"+SUBS(STR(t+100,3),2)                    // soma coluna para
       &var. += &cp_.                                   // totalizacao
      ENDI
      lin+=LEFT(TRAN(&cp_.,cp_masc)+SPAC(i),i)+" "      // monta linha de impressao
     ENDI
    NEXT
    @ cl++,0 SAY lin                                    // joga linha na impressora
    IF tem_memo .AND. qli_m>1                           // imprime resto do memo
     li_m=1
     DO WHIL .t.
      li_m++                                            // proxima linha do memo
      IF li_m>qli_m                                     // se ja' imprimiu todos
       EXIT                                             // cai fora...
      ENDI
      lin=""
      FOR t=1 TO br_w:colcount                          // procura todos os memo
       SEPARA(br_w:getcolumn(t):cargo)                  // e monta uma linha so'
       i = br_w:getcolumn(t):width
       IF tp_cp="M"
        lin += IMPAC(LEFT(MEMOLINE(&cp_.,i,li_m)+SPACE(i),i),just_memo)+" "
       ELSE
        lin += SPAC(i+1)
       ENDI
      NEXT
      IF cl+1>IF(brw_imp,54,57)
       EJEC                                             // quebra de folha
       cl=CABCONS(brw_cb1,tit_rel)
      ENDI
      @ cl++,0 SAY lin                                  // imprime as linhas dos memo

      #ifdef COM_TUTOR
       IF IN_KEY()=K_ESC .OR. MOUSEGET(0,0)=2           // quer cancelar a impressao?
      #else
       IF INKEY()=K_ESC .OR. MOUSEGET(0,0)=2            // quer cancelar a impressao?
      #endi

       brw_cn = CANC(1)
       LOOP
      ENDI
     ENDD
    ENDI
    IF tem_memo                                         // se imprimiu algum campo
     cl++                                               // memo, forca espacejamento duplo
    ENDI
    creg++                                              // contador de registros impressos
    IF brw_imp                                          // tem outra janela relacionada?
     cl++                                               // forca salto de linha
     id_carg=br_outro:cargo                             // prepara para a impressao
     c_antes=IF(EMPTY(id_carg[1]),"","T")+&(id_carg[3]) // da janela relacionada
     SELE (outro_db)
     SEEK c_antes                                       // acha o 1o. registro da relacao
     ind_outro = INDEXKEY(0)                            // ordem atual do arquivo
     imp_brw_out=.f.
     IF !EOF().AND.!brw_cn.AND.&ind_outro.=c_antes      // se tem registro a imprimir
      cl=CABCONS_O(cl,brw_cb2)                          // imprime cabecalho
      cl++
     ENDI
     DO WHIL !EOF().AND.!brw_cn.AND.&ind_outro.=c_antes // imprime so quem atende a relacao
      cl--
      IF cl>57                                          // final da folha
       EJEC                                             // salta para proxima
       cl=CABCONS(brw_cb1,tit_rel)                      // imprime cabecalho do "pai"
      ENDI

      #ifdef COM_TUTOR
       IF IN_KEY()=K_ESC .OR. MOUSEGET(0,0)=2           // quer cancelar?
      #else
       IF INKEY()=K_ESC .OR. MOUSEGET(0,0)=2            // quer cancelar?
      #endi

       brw_cn = CANC(1)                                 // pede confirmacao
       LOOP
      ENDI
      lin_o=""; tem_memo=.f.; qli_m=0
      FOR t=1 TO br_outro:colcount                      // monta linha a imprimir
       SEPARA(br_outro:getcolumn(t):cargo)              // separa os atributos da coluna
       IF tp_cp="M"                                     // tamanho da coluna
        IF qli_m<MLCOUNT(&cp_.,i)                       // coluna e' memo?
         qli_m=MLCOUNT(&cp_.,i)                         // mumero maximo de linhas
        ENDI                                            // a imprimir de todos campos memo
        lin_o+=" "+IMPAC(LEFT(MEMOLINE(&cp_.,i,1)+;
             SPACE(i),i),just_memo)                     // monta linha de impressao
        tem_memo=.t.                                    // flag se tem memo
       ELSE
        IF tp_cp=="N" .AND. tot_num                     // coluna e' numerica?
         var="too"+SUBS(STR(t+100,3),2)                 // soma coluna para
         &var. += &cp_.                                 // totalizacao
        ENDI
        i = br_outro:getcolumn(t):width                 // tamanho da coluna
        lin_o+=" "+LEFT(TRAN(&cp_.,cp_masc)+SPAC(i),i)  // monta linha de impressao
       ENDI
      NEXT
      imp_brw_out=.t.
      @ cl,0 SAY PADL(SUBS(lin_o,2),MAX(ltot,ltot_o))   // joga linha na impressora
      IF tem_memo .AND. qli_m>1                         // imprime resto do memo
       li_m=1
       DO WHIL .t.
        li_m++                                          // proxima linha do memo
        IF li_m>qli_m                                   // se ja imprimiu todos
         EXIT                                           // cai fora...
        ENDI
        lin=""
        FOR t=1 TO br_w:colcount                        // procura todos os memo
         SEPARA(br_w:getcolumn(t):cargo)                // e monta uma linha so'
         i = br_w:getcolumn(t):width
         IF tp_cp="M"
          lin += IMPAC(LEFT(MEMOLINE(&cp_.,i,li_m)+SPACE(i),i),just_memo)+" "
         ELSE
          lin += SPAC(i+1)
         ENDI
        NEXT
        IF cl+1>57                                      // chegou no final da folha?
         EJEC                                           // salta para proxima pagina
         cl=CABCONS(brw_cb1,tit_rel)                    // reimprime cabecalho do "pai"
        ENDI
        @ ++cl,0 SAY PADL(lin,MAX(ltot,ltot_o))         // imprime linhas dos memo

        #ifdef COM_TUTOR
         IF IN_KEY()=K_ESC .OR. MOUSEGET(0,0)=2         // quer cancelar?
        #else
         IF INKEY()=K_ESC .OR. MOUSEGET(0,0)=2          // quer cancelar?
        #endi

         brw_cn = CANC(1)
         LOOP
        ENDI
       ENDD
      ENDI
      cl += 2
      SKIP                                              // de imprimir o proximo "pai"
     ENDD
     IF imp_brw_out                                     // se imprimiu algum registro...
      @ cl-1,0 SAY PADL(REPL("-",ltot_o),MAX(ltot,ltot_o))
     ENDI
     cl++
     IF tot_num                                         // pediu para totalizar
      lin_o=""
      FOR t=1 TO br_outro:colcount                      // monta linha dos totais
       SEPARA(br_outro:getcolumn(t):cargo)
       i=br_outro:getcolumn(t):width
       IF tp_cp=="N"
        var="too"+SUBS(STR(t+100,3),2)                  // variavel com a mascara
        lin_o+=" "+LEFT(TRAN(&var.,cp_masc)+SPAC(i),i)  // da propria coluna
        &var.=0
       ELSE
        lin_o += SPAC(i+1)
       ENDI
      NEXT
      IF LEN(ALLTRIM(lin_o))>0                          // se tem totais, imprime
       @ cl-1,0 SAY PADL(SUBS(lin_o,2),MAX(ltot,ltot_o))
       cl++
      ENDI
     ENDI
     SELE (m_origem)                                    // retorna ao "pai"
    ENDI
    SKIP
   ENDD
   @ PROW()+1,0 SAY REPL("=", MAX(ltot,ltot_o))         // traco do fim do relatorio
   lin=""
   IF tot_num                                           // quer totalizar
    FOR t=1 TO br_w:colcount                            // monta linha dos totais
     SEPARA(br_w:getcolumn(t):cargo)
     i = br_w:getcolumn(t):width
     IF tp_cp=="N"
      var="to"+SUBS(STR(t+100,3),2)                     // variavel com a mascara
      lin += LEFT(TRAN(&var.,cp_masc)+SPAC(i),i)+" "    // da propria coluna
     ELSE
      lin += SPAC(i+1)
     ENDI
    NEXT
    @ PROW()+1,0 SAY lin
   ENDI                                                 // se tem totais, imprime
   @ PROW()+1,0 SAY "Listados: "+;                      // imprime qde de registros
                    LTRIM(TRAN(creg,"@E 999,999"))+;    // listados
                    IF(MAX(ltot,ltot_o)>80,&drvtcom.,"")
   EJEC
   SET PRINTER TO (drvporta)                            // finaliza o relatorio
   SET DEVI TO SCRE
   SET(_SET_DELETED,dele_atu)                           // restaura visao dos reg apagados
   GO brw_reg                                           // reposiciona o ponteiro
   IF tps=2                                             // se vai para arquivo/video
    BROWSE_REL(arq_,2,3,MAXROW()-2,78)                  // mostra o arquivo gravado
   ENDI
   RESTSCREEN(0,0,MAXROW(),79,brw_tela)                 // restaura a tela e
  ENDI                                                  // do arquivo
 ENDI
ENDI
RETU NIL

/*
   Sintaxe: CABCONS(<ExpC1> <,ExpC2> )
   Funcao.: Imprime cabecalho da consulta na impressora (pai)
              ExpC1 = titulo da consulta
              ExpC2 = titulo extra
   Retorna: Linha de impressao do proximo registro
*/
STATIC FUNC CABCONS(cb_1,tit_rel)
pg++
@ 1,ltot-18 SAY DATE()                   // data do sistema
@ 1,ltot-7  SAY TRAN(pg,"Pag 999")       // numero da pagina
@ 2,0 SAY IMPAC(PADC(TRIM(nemp),ltot))   // nome da empresa
@ 3,0 SAY PADC(TRIM(tit_rel),ltot)       // titulo informado
@ 4,0 SAY IMPAC(cb_1)                    // titulo das colunas
@ 5,0 SAY REPL("=",MAX(ltot,ltot_o))
RETU 6

/*
   Sintaxe: CABCONS_O()
   Funcao.: Imprime cabecalho da consulta na impressora (filho)
              ExpC1 = titulo da consulta
              ExpC2 = titulo extra
   Retorna: Linha de impressao do proximo registro
*/
STATIC FUNC CABCONS_O(cl,cb_1)
@ cl++,0 SAY IMPAC(PADL(cb_1,MAX(ltot,ltot_o)))              // titulo das colunas
@ cl++,0 SAY IMPAC(PADL(REPL("-",ltot_o),MAX(ltot,ltot_o)))  // justificado a direita
RETU cl

/*
   Sintaxe: TROCA_BRW()
   Funcao.: Troca os arquivos do browse
   Retorna: NIL
*/
STATIC FUNC TROCA_BRW()
IF br_w == br_outro    // se for a janela de baixo
 br_reg_out = RECNO()  // salva situacao e
 SELE (m_origem)       // passa para a janela de cima
 br_w = br_origem
 GO br_reg_ori
ELSE                   // esta' na janela de cima
 br_reg_ori = RECNO()  // salva situacao e
 SELE (outro_db)       // passa para a janela de baixo
 br_w = br_outro
 GO br_reg_out
ENDI
RETU NIL

/*
   Sintaxe: LDBEDIT( <ExpL> )
   Funcao.: Carrega parametros de consulta
            se .t. le consulta dos discos e apresenta menu
   Retorna: .t. se teve sucesso.
*/
STATIC FUNC LDBEDIT(lecons)
LOCAL aqdbe, naq, qarq, cor_, ret_:=.t., sos_cod:=cod_sos, leat_,;
      tela_brw:=SAVESCREEN(0,0,MAXROW(),79), i_, l_mp, c_mp
IF ! USED()                                          // nao existe DBF aberto
 RETU .f.
ENDI
cod_sos=27
leat_=.t.
IF lecons                                            // se quer ler consultas gravadas
 DBOX("AGUARDE!",,,,NAO_APAGA)
 aqdbe=drvdbf+"DB*."+LEFT(ALIAS(),3)                 // mascara dos arquivos
 qarq=ADIR(aqdbe)                                    // capta arquivo do disco
 IF qarq>0                                           // existe alguma consulta gravada?
  PRIV l_arq[qarq+1]
  ADIR(aqdbe,l_arq)                                  // monta vetor com os titulos
  FOR i=qarq TO 1 STEP -1                            // de cada consulta
   naq=drvdbf+l_arq[i]
   REST FROM (naq) ADDI
   l_arq[i+1]=db_aqcom+"³"+l_arq[i]
  NEXT
  l_arq[1]="* Definir nova consulta *"               // primeira opcao do menu
  volta_ac=.t.
  RESTSCREEN(0,0,MAXROW(),79,tela_brw)
  DO WHIL volta_ac
   volta_ac=.f.
   msg=""                                            // tira os espacos dos titulos
   AEVAL(l_arq,{|ms|;                                // da consulta
                 IF(ms!=NIL,msg+="|"+ALLTRIM(PARSE(ms,"³")),"");
               };
   )
   l_mp=IF(TYPE("lin_menu")="N",lin_menu+2,NIL)      // coordenadas do menu
   c_mp=IF(TYPE("col_menu")="N",col_menu+8,NIL)      // apresenta menu
   op_co=DBOX(SUBS(msg,2),l_mp,c_mp,E_MENU,,"CONSULTAS DEFINIDAS|(DEL=APAGA)")
   IF volta_ac                                       // quer apagar a consulta
    pos_=RAT("³",l_arq[op_co])
    IF pos_>3                                        // evita matar opcao sem aquivo
     naq=drvdbf+SUBS(l_arq[op_co],pos_+1)
     i_=ALLTRIM(UPPE(LEFT(l_arq[op_co],pos_-1)))
     ALERTA()                                        // pede confirmacao
     msg="Cancelar a opera‡„o|Efetivar exclus„o"
     op_=DBOX(msg,8,,E_MENU,,"EXCLUINDO|¯ "+i_+" ®")
     IF op_=2                                        // se confirmou exclusao elimina
      ERAS &naq.                                     // arquivo de atributos da consulta
      ADEL(l_arq,op_co)                              // exclui consulta do menu
     ENDI
    ENDI
   ENDI
  ENDD
  RELE ALL LIKE db_*                                 // libera variaveis com "DB"
  db_1rela:=db_2rela := ""
  db_zoom=.f.
  IF op_co=0                                         // nao quis ler consulta
   ret_=.f.
  ELSEIF op_co>1
   op_=l_arq[op_co]                                  // consulta escolhida
   br_tit=ALLTRIM(PARSE(@op_,"³"))                   // extrai o nome do arquivo
   br_arq=drvdbf+op_
   REST FROM (br_arq) ADDI                            // le variaveis do disco
   pas = "1"
   tit_cons[1]=ALLTRIM(br_tit)                       // titulo da consulta
   IF db_zoom                                        // se janela tem zoom
    li_sup=3; li_inf=22; co_sup=3; co_inf=77         // ajusta as coordanadas
    br_w:nTop   := li_sup                            // da janela e do browse
    br_w:nbottom:= li_inf
    br_w:nleft  := co_sup
    br_w:nright := co_inf
   END IF
   ind_rela=db_indrela                               // indice utilizado para relacionar
   DO WHILE .t.
    xdb_rela=LEFT(db_&pas.rela,LEN(db_&pas.rela)-1)
    DO WHIL LEN(xdb_rela)>0                          // restabelece relations
     n_cp=ALLTRIM(PARSE(@xdb_rela,"³"))
     SETARELA(n_cp)
    ENDD
    FOR t=1 TO db_&pas.qtdc                          // remonta todas colunas
     tt=RIGHT(STR(100+t,3),2)
     cargox=db_&pas.carg&tt.
     cp_ =PARSE(@cargox,"³")                         // conteudo
     cp_masc=PARSE(@cargox,"³")                      // mascara
     cp_titu=PARSE(@cargox,"³")                      // titulo
     cp_when=PARSE(@cargox,"³")                      // pre-validacao
     cp_crit=PARSE(@cargox,"³")                      // validacao
     br_w:addcolumn(tbcolumnnew(cp_titu,&("{||"+IF(TYPE(cp_)=="M","MEMOLINE("+cp_+")","TRAN("+cp_+",["+cp_masc+"])")+"}")))
     br_w:getcolumn(t):cargo = db_&pas.carg&tt.
     br_w:getcolumn(t):width = db_&pas.tam&tt.       // tamanho da coluna
     br_w:getcolumn(t):colorblock = {||IIF(DELE(),{3,2},{1,2})}
    NEXT
    br_w:freeze = db_&pas.freeze                     // coluna congelada
    IF br_w:freeze != 0
     br_w:getcolumn(br_w:freeze+1):colsep := " Û "
     br_w:configure()
    ENDI
    criterio=db_&pas.arqf                            // filtro
    cpord=db_&pas.expo                               // ordem
    chv_rela=db_&pas.chvr                            // ligacao entre janelas
    ind_ord=db_&pas.ind_ord                          // indice atual
    br_w:cargo         := {criterio,cpord,chv_rela,ind_ord}
    br_w:gobottomblock := {||FIM_ARQ()}
    br_w:gotopblock    := {||INI_ARQ()}
    br_w:skipblock     := {|n|MOV_PTR(n)}
    PEGACHV2()
    INDTMP()
    IF pas = "1"
     br_reg_ori = IF(FOUND(),RECNO(),1)
     IF TYPE("db_outro")=="C".AND.!EMPTY(db_outro)   // tem duas janelas?
      opi = ASCAN(sistema,{|sis| UPPER(db_outro)=UPPER(sis[O_ARQUI])})
      IF !abreoutro(opi)                             // abre o segundo browse
       EXIT
      ENDI
      SETCOLOR(drvcortna)                            // monta janela
      CAIXA(mold,br_outro:ntop-2, br_outro:nleft-1, br_outro:nbottom+1, br_outro:nright+1)
     ELSE
      EXIT
     ENDI
     pas = "2"
     tit_cons[2]=sistema[opi,O_MENS]                 // titulo da segunda janela
     DBSETORDER(ind_rela)                            // vai para utilizado da relacao
    ELSE
     br_reg_out = IF(FOUND(),RECNO(),1)              // segunda janela
     SELE (m_origem)
     br_w = br_origem
     GO br_reg_ori
     br_outro:colorspec := drvcortna+","+INVCOR(drvcortna)+","+drvcorenf+","+drvcorget
     FORCABRW(.f.)                                   // imprime dados na tela
     EXIT
    ENDI
   ENDD
   leat_=.f.
  ENDI
 ELSE
  RESTSCREEN(0,0,MAXROW(),79,tela_brw)               // restaura tela
 ENDI
ENDI
IF leat_
 IF col_cp!=NIL                                      // passou arranjo das colunas
  estr_dbf=DBSTRUCT()                                // campos dos arquivo
  ct_cp=0
  FOR i=1 TO LEN(col_cp)
   t=ASCAN(estr_dbf,{|db_|UPPER(col_cp[i])==db_[1]}) // ve se a coluna e cp do arquivo
   IF t>0
    MONTA_COL()                                      // e' um campo do arquivo
   ELSE
    ct_cp++                                          // nao e' campo do arquivo
    br_w:addcolumn(tbcolumnnew(col_cp[i],&("{||"+col_cp[i]+"}")))
    x=LEN(&(col_cp[i]))
    br_w:getcolumn(ct_cp):width := LEN(&(col_cp[i]))
    br_w:getcolumn(ct_cp):colorblock := {||IF(DELE(),{3,2},{1,2})}
    i_=IF(TYPE("col_tit[i]")!="UE".AND.!EMPTY(col_tit[i]),col_tit[i],"")
    br_w:getcolumn(ct_cp):cargo := col_cp[i]+"³@X³"+i_+"³³V³"+VALTYPE(col_cp[i])
   ENDI
   IF TYPE("col_tit[i]")!="UE" .AND. !EMPTY(col_tit[i])
    br_w:getcolumn(ct_cp):heading := col_tit[i]
   ENDI
  NEXT
 ELSE                                                // monta consulta com todos
  estr_dbf=DBSTRUCT()                                // os campos do arquivo
  ct_cp=0
  FOR t=1 TO LEN(estr_dbf)
   IF !("I"==sistema[op_sis,O_CAMPO,t,O_CRIT])       // exceto os invisiveis...
    MONTA_COL()
   END IF
  NEXT
 ENDI
 br_w:gobottomblock := {||FIM_ARQ()}
 br_w:gotopblock    := {||INI_ARQ()}
 br_w:skipblock     := {|n|MOV_PTR(n)}
 IF !EMPTY(criterio) .OR. !EMPTY(cpord)              // tem filtro ou ordem inicial
  i_=IF(!EMPTY(criterio).AND.&criterio.,RECNO(),0)   // reg atual esta dentro do filtro?
  INDTMP()                                           // cria indice temporario
  IF i_>0                                            // se reg estava no filtro
   GO i_                                             // reposiciona em cima dele
  ENDI
 ENDI
 br_w:cargo := {criterio,cpord,chv_rela,INDEXORD()}  // grada nova configuracao
ENDI
RELE ALL LIKE db_*                                   // libera variaveis
cod_sos=sos_cod
RETU ret_                                            // .t. montou consulta com sucesso

/*
   Sintaxe: MONTA_COL()
   Funcao.: Enche uma coluna da edita com atributos de campo
   Retorna: NIL
*/
STATIC FUNC MONTA_COL
M->ms:=sistema[op_sis,O_CAMPO,t,O_MASC]                  // mascara
M->tm:=LEN(TRAN(&(FIELD(t)),M->ms))                      // conteudo
M->tm:=IF(M->tm=0,34,M->tm)                              // ajusta tamanho
M->tm:=IF(LEFT(M->ms,2)="@S",VAL(SUBS(M->ms,3)),M->tm)   // da coluna
ct_cp++
br_w:addcolumn(;                                         // inicializa coluna
       tbcolumnnew(sistema[op_sis,O_CAMPO,t,O_TITU],;
                      &("{||"+;
                        IF(TYPE(estr_dbf[t,1])=="M",;
                           "MEMOLINE("+estr_dbf[t,1]+")",;
                           "TRAN("+estr_dbf[t,1]+",["+M->ms+"])";
                        )+"}";
                       );
       );
     )
br_w:getcolumn(ct_cp):cargo := estr_dbf[t,1]+"³"+M->ms+"³"+sistema[op_sis,O_CAMPO,t,O_TITU]+"³"+;
                               sistema[op_sis,O_CAMPO,t,O_WHEN]+"³"+sistema[op_sis,O_CAMPO,t,O_CRIT]+"³"+;
                               sistema[op_sis,O_CAMPO,t,O_HELP]+"³"+sistema[op_sis,O_CAMPO,t,O_CMD]
br_w:getcolumn(ct_cp):width := M->tm
br_w:getcolumn(ct_cp):colorblock := {||IF(DELE(),{3,2},{1,2})}
RETU

/*
   Sintaxe: SEPARA( <ExpC> )
   Funcao.: Separa atributos de campos da coluna da consulta
              ExpC = atributos (nome do campo/mascara/titulo/validacao)
   Retorna: NIL
*/
STATIC FUNC SEPARA(cr_)
cp_ =PARSE(@cr_,"³")     // conteudo
cp_masc=PARSE(@cr_,"³")  // mascara
cp_titu=PARSE(@cr_,"³")  // titulo
cp_when=PARSE(@cr_,"³")  // pre-validacao
cp_crit=PARSE(@cr_,"³")  // validacao (critica)
cp_help=PARSE(@cr_,"³")  // help do campo
cp_cmd =PARSE(@cr_,"³")  // comando especial
tp_cp= TYPE(cp_)         // tipo da coluna
RETU NIL

/*
   Sintaxe: DIR_CUR()
   Funcao.: Muda direcionamento do cursor dentro da funcao EDITA() quando
            o TAB e' acionado
   Retorna: NIL
*/
STATIC FUNC DIR_CUR
dir_cur=IF(dir_cur=4,1,dir_cur+1)
@ br_w:nbottom+1,br_w:nleft+posi_cur+5 SAY CHR(VAL(SUBS(di_tecl,dir_cur*2-1,2)))
RETU NIL

/*
   Sintaxe: COLNOVA()
   Funcao.: Cria uma nova coluna na consulta
   Retorna: NIL
*/
STATIC FUNC COLNOVA
LOCAL brw_tela, ar_, i, ii, db:="", msg:="", qt_ind, op_ind
PRIV cod_sos:=1
brw_tela = SAVESCREEN(0,0,MAXROW(),79)                 // salva tela e monta
FOR i=1 TO nss                                         // menu dos arquivos possiveis
 IF sistema[i,O_ARQUI]!=ALIAS(VAL(m_origem)) .AND. ;
    IF(EMPTY(outro_db),.t.,sistema[i,O_ARQUI]!=ALIAS(VAL(outro_db))) .AND.;
    sistema[i,O_OUTROS,O_NIVEL]<=nivelop .AND.;
    LEN(sistema[i,O_INDIC])>0
  msg+="|"+sistema[i,O_MENU]
  db+=RIGHT(STR(100+i),2)
 ENDI
NEXT
IF LEN(msg) <= 0                                       // nao existe arq a escolher
 ALERTA()
 DBOX("N„o h  mais arquivos dispon¡veis",15,,3,,"ATEN€ŽO!, "+usuario)
 KEYB CHR(K_ESC)
ELSE
 tit="SELECIONE O ARQUIVO|DO QUAL SER MOSTRADO O CAMPO"
 op_a=DBOX(SUBS(msg,2),,,E_MENU,,tit)                  // escolhe um arquivo
 ar_:=SELECT()
 IF op_a>0                                             // escolheu...
  op_a=VAL(SUBS(db,op_a*2-1,2))                        // subscricao de "sistema"
  db=sistema[op_a,O_ARQUI]                             // nome do arquivo (sem dir)
  IF USEARQ(db)                                        // abre o arquivo
   op_ind=1                                            // indice 'default`
   qt_ind=LEN(sistema[op_a,O_INDIC])                   // qde de indices do arquivo
   IF ATAIL(sistema[op_a,O_CHAVE])="codlan"         // o ntx de relacionamento nao pode...
    qt_ind--
   ENDI
   IF qt_ind>1                                         // escolhe um conjunto de indice
    msg=""
    FOR i=1 to qt_ind
     msg+="|"+sistema[op_a,O_CONSU,i]
    NEXT
    op_ind=DBOX(SUBS(msg,2),,,E_MENU,,"SELECIONE O INDICE")
    IF op_ind>1
     DBSETORDER(op_ind)
    ENDI
   ENDI
   SELE (ar_)
   IF PEGARELA(.f.)                                    // pega campos de relacionamentos
    msg=""
    SELE (db)
    FOR i=1 TO FCOU()                                  // menu de campos
     IF !("I"==sistema[op_a,O_CAMPO,i,O_CRIT])         // exceto os invisiveis...
      msg+="|"+sistema[op_a,O_CAMPO,i,O_TITU]
     ENDI
    NEXT
    op_0=DBOX(SUBS(msg,2),,,E_MENU,,"CAMPO A MOSTRAR NA NOVA COLUNA")
    IF LASTKEY()!=K_ESC .AND. op_0 > 0                 // escolheu um campo
     ii=0
     FOR i=1 TO FCOU()                                 // acha campo escolhido
      IF !("I"==sistema[op_a,O_CAMPO,i,O_CRIT])
       ii++
      ENDI
      IF ii=op_0
       op_0=i
       EXIT
      ENDI
     NEXT
     v_ar=READVAR()                                   // titulo da coluna
     &v_ar.:=sistema[op_a,O_CAMPO,op_0,O_TITU]        // contera' o titulo do campo
     cp_masc:=sistema[op_a,O_CAMPO,op_0,O_MASC]       // mascara
     cp_ =ALLTRIM(STR(op_ind))+"}"+cp_+"|"+;       // expressao para relacionar
          db+"->"+FIEL(op_0)
    ELSE
     cp_=" "
    ENDI
   ELSE
    cp_=" "
   ENDI
  ENDI
 ENDI
 SELE (ar_)                                           // seleciona arquivo original
 f10=.t.
 KEYB CHR(K_CTRL_W)                                   // forca saida do get pendente
ENDI
RETU NIL

/*
   Sintaxe: PEGARELA( <ExpL> )
   Funcao.: Monta menu com arquivos e campos para relacionamento
              ExpL = .t. relacao entre duas janelas
                     .f. relacao entre colunas
   Retorna: .t. se teve sucesso.
*/
STATIC FUNC PEGARELA(fl)
LOCAL tit_chv:="", msg:="", op_0:=0, cp_rela:="", ii
PRIV cod_sos:=31
op_x = EVAL(qualsis,ALIAS())                // subscricao do arquivo atual
FOR i=1 TO FCOU()                           // monta menu com os campos do
 IF !("I"==sistema[op_x,O_CAMPO,i,O_CRIT])  // arquivo, exceto os invisiveis
  msg+="|"+sistema[op_x,O_CAMPO,i,O_TITU]
 ENDI
NEXT                                        // titulo da DBOX()
tit="RELACIONAMENTO|*|ESCOLHA O CAMPO PARA|SINCRONIZAR OS ARQUIVOS|ESC=FIM|*"
IF fl
 chv_rela=""                                // vai sincronizar duas janelas
ENDI
temrela=.f.
DO WHIL .t.                                 // escolhe um campo
 op_0=DBOX(SUBS(msg,2),,,E_MENU,,tit+tit_chv,,,op_0)
 IF LASTKEY()=K_ESC .OR. op_0<=0
  EXIT                                      // cancelou ou ja terminou
 ENDI
 ii=0                                       // procura campo escolhido
 FOR i=1 TO FCOU()
  IF !("I"==sistema[op_x,O_CAMPO,i,O_CRIT]) // despreza os invisiveis
   ii++
  ENDI
  IF ii=op_0
   op_0=i
   EXIT
  ENDI
 NEXT
 cp_ = FIEL(op_0)                           // campo escolhido
 IF TYPE(cp_)="M"
  DBOX("Campo ilegal",,,3,,"ATEN€ŽO!")      // campo memo nao pode...
  LOOP
 ELSE
  temrela=.t.                               // atualiza o titulo da DBOX()
  tit_chv+="|"+MAIUSC(sistema[op_x,O_CAMPO,op_0,O_TITU])+","
  cp_=TRANSCAMPO(.f.,cp_,op_0)              // transforma campo em caracter
  IF fl
   chv_rela+="+"+ALIAS()+"->"+cp_           // chave de relacionamento entre janelas
  ENDI
  cp_rela+="+"+cp_                          // mais um campo de sincronismo?
  op_0=DBOX("Prosseguir|Informar outro campo",,,E_MENU,,"RELACIONAMENTO POR"+tit_chv)
  IF op_0!=2
   cp_=SUBS(cp_rela,2)                      // sincronismo terminado
   EXIT
  ENDI
 ENDI
ENDD
RETU temrela

/*
   Sintaxe: SETARELA( <ExpC> )
   Funcao.: Estabelece relacionamento de arquivos na consulta
              ExpC = parametros de relacionamento
   Retorna: .t. se relacionou
*/
STATIC FUNC SETARELA(p_cp)
op_ind=1                           // indice 'default`
IF VAL(p_cp)>0                     // existe um indice?
 op_ind=VAL(p_cp)                  // vamos utiliza-lo
 p_cp=SUBS(p_cp,AT("}",p_cp)+1)    // arruma expressao de relacionamento
ENDI
p_m=RAT("->",p_cp)
p_b=AT("|",p_cp)
IF p_m>0 .AND. p_b>0               // existe campo e arq para o relacionamento
 c_rel=LEFT(p_cp,p_b-1)            // campo ou expressao para a relacao
 a_u=SUBS(p_cp,p_b+1,(p_m-1)-p_b)  // nome do arquivo que sera' relacionado
 a_r_=SELEC()
 IF USEARQ(a_u)                    // abre arquivo e seus indices
  INDEXORD(op_ind)                 // indice escolhido...
  SELE (a_r_)
  ja=.f.
  FOR t=1 TO 99                    // verifica se a relacao ja' foi feita
   x=DBRSELECT(t)
   IF x>0
    IF UPPER(a_u) == ALIAS(x)
     ja=.t.                        // existe o relacionamento
     EXIT
    ENDI
   ENDI
  NEXT
  IF !ja                           // relaciona se nao tem o relacionamento
   SET RELA ADDI TO &c_rel. INTO &a_u.
  ENDI
 ELSE
  CLOSE ALL                        // ocorreu erro de abertura de arquivo
  BREAK                            // cancela toda a operacao
 ENDI
ENDI
RETU (p_m>0 .AND. p_b>0)           // retorna .t. se relacionou

/*
   Sintaxe: POINTER_DBF( [ExpA] [,ExpL] )
   Funcao.: acha/restaura ponteiro dos dbf do vetor sistema
               ExpA = arranjo de RECNO() dos dbf do vetor sistema
               ExpL = se .t. deixa abertos os dbf's usados apos salvamento
   Retorna: arranjo de RECNO() dos dbf do vetor sistema
*/
FUNC POINTER_DBF(reg_dbf, deixa_ab)
LOCAL t, i_, i_reg, i_ord, db_, repoe:=(reg_dbf!=NIL)
deixa_ab=IF(deixa_ab=NIL,.f.,deixa_ab)
IF !repoe                        // ira retornar os RECNO() de cada dbf
 reg_dbf:={}                     // inicializa vetor de retorno
 i_=SELECT()                     // salva area atual
ENDI
FOR t=1 TO nss                   // para cada sistema do vetor sistema...
 db_=sistema[t,O_ARQUI]          // nome do dbf
 IF repoe                        // vai repor os ponteiros dos dbf's
  IF reg_dbf[t,1]>=0             // se o arquivo estava aberto
   SELE (db_)                    // seleciona-o e
   DBSETORDER(reg_dbf[t,2])      // restaura o indice e o
   GO reg_dbf[t,1]               // seu ponteiro
  ELSE                           // se o arquivo estava fechado
   IF !EMPTY(SELECT(db_)) .AND.; // e agora esta aberto
      !deixa_ab                  // e quer fechar,
    CLOSE (db_)                  // entao vamos fecha-lo
   ENDI
  ENDI
 ELSE                            // acha situacao dos dbf's
  IF !EMPTY(SELECT(db_))         // se o dbf esta aberto
   i_reg=(db_)->(RECNO())        // pega o seu ponteiro
   i_ord=(db_)->(INDEXORD())     // e o seu indice atual
  ELSE                           // caso contrario vamos
   i_reg:= i_ord := -1           // colocar uma flag para fecha-lo depois
  ENDI
  AADD(reg_dbf,{i_reg,i_ord})    // adiciona ponteiro ao vetor de retorno
 ENDI
NEXT
IF !repoe                        // se esta enchendo o vetor, adiciona
 AADD(reg_dbf,i_)                // a area atual no ultimo elemento
ELSE                             // se esta restabelecendo,
 SELE (reg_dbf[nss+1])           // retorna para area original
ENDI
RETU reg_dbf                     // retorna vetor

/*
   Sintaxe: VDBF( <N1> <,N2> <,N3> <,N4> <,ExpC1> [,ExpA1] [,ExpN] [,ExpC2] )
   Funcao.: Abre janela de consulta a outro arquivo da aplicacao
              N1,N2,N3,N4 = coordenadas da janela
                    ExpC1 = nome do arquivo a ser consultado
                    ExpA1 = arranjo de campos a mostrar na consulta
                     ExpN = ordem do indice associado ao arquivo
                    ExpC2 = campo a ser transferido para o get pendente
                    ExpC3 = expressao de filtro inicial
   Retorna: logico sempre .t.
*/
FUNC VDBF(l_1,c_1,l_2,c_2,db,cp_db,ord_db,cp_trans,fil_db)
LOCAL v_ar, v_:=SAVESCREEN(0,0,MAXROW(),79), t_w, t_r, t_c, t_7, t_9,;
      reg_dbf:={}, ret_val, del_a
PRIV tela_fundo
v_ar=READVAR()
ord_db=IF(ord_db=NIL,1,ord_db)
reg_dbf=POINTER_DBF()                     // salva situacao de todos dbf's
del_a:=SET(_SET_DELETED,!drvvisivel)      // coloca visibilidade escolhida
tem_t=.f.
IF !EMPTY(v_ar)                           // alguma variavel pendente?
 IF VALTYPE(&v_ar.) $ "CNDL" .AND.;       // se for caracter, numerica, data
    !EMPTY(&v_ar.)                        // ou logico e tiver conteudo
  tem_t=!("OP_" $ UPPER(v_ar))            // e nao for de menu, pode
  v_ar=TRIM(TRANSCAMPO(.t.,v_ar))         // transferir para o get pendente
 ENDI
ENDI
PTAB(IF(tem_t,v_ar,"%^"),db)              // abre arquivo e tenta posicionar

#ifdef COM_REDE
 IF NETERR()                              // se ocorreu erro de abertura
  RETU .t.                                // retorna
 ENDI
#endi

SELE (db)                                 // seleciona o arquivo escolhido
IF EOF()                                  // se fim de arquivo,
 DBSETORDER(ord_db)                       // vai para o indice desejado
 GO TOP                                   // vai para o 1o. registro
ENDI
t_w:=SETKEY(K_CTRL_W,NIL)                 // desabilita e salva
t_r:=SETKEY(K_CTRL_R,NIL)                 // as teclas de controle
t_c:=SETKEY(K_CTRL_C,NIL)
t_7:=SETKEY(K_F7,NIL); t_9:=SETKEY(K_F9,NIL)
IF sistema[EVAL(qualsis,ALIAS()),O_OUTROS,O_NIVEL]>nivelop
 ALERTA()                                 // usuario nao tem permissao
 DBOX(msg_auto,,,3)                       // avisa
ELSE
 l_2=IF(l_2-l_1-1>RECC(),l_1+RECC()+1,l_2)
 v_out=.t.
 cod_sos=10
 EDITA(l_1,c_1,l_2,c_2,.t.,cp_db,,fil_db,INDEXKEY(ord_db))
 IF LASTKEY()!=K_ESC .AND. cp_trans!=NIL
  ret_val=&cp_trans.
 ENDI
 v_out=.f.
ENDI
SET(_SET_DELETED,del_a)                   // retorna a visibilidade dos excluidos
POINTER_DBF(reg_dbf)                      // restaura ponteiro dos dbf's
SETKEY(K_CTRL_W,t_w)                      // restaura teclas de controle
SETKEY(K_CTRL_R,t_r)
SETKEY(K_CTRL_C,t_c)
SETKEY(K_F7,t_7); SETKEY(K_F9,t_9)
RESTSCREEN(0,0,MAXROW(),79,v_)            // restaura tela
RETU ret_val


#ifdef COM_MOUSE

 /*
    Sintaxe: MOUSETECLA( [N1] [,N2] [,N3] [,N4] [,ExpL] )
    Funcao.: Aguarda digita‡„o de tecla com controle de mouse
               N1,N2,N3,N4 = janela de avaliacao
                      ExpL = .f. somente as bordas da janela serao verificadas
    Retorna: codigo ASCII da tecla digitada
 */
 FUNC MOUSETECLA(l1,c1,l2,c2,cx_toda)
 LOCAL tecl_p, i, li:=1, co:=1, clic:=0, Tp_Sai, lin_cur, col_cur,;
       cur_, e_calc:=(PROCNAME(3)="MAQCALC")
 IF drvmouse                            // mouse esta' ligado?
  lin_cur=ROW()                         // salva linha e
  col_cur=COL()                         // coluna atual do mouse
  cur_=SETCURSOR()                      // setuacao atual do cursor
  IF e_calc                             // mouse na calculadora
   l1=lisu_+5                           // ajusta area de atuacao do mouse
   c1=cosu_+2
   l2=lisu_+8
   c2=cosu_+22
  ELSE
   l1=IF(l1=NIL,0,l1)                   // acha a area de atuacao do mouse
   c1=IF(c1=NIL,0,c1)
   l2=IF(l2=NIL,MAXROW(),l2)
   c2=IF(c2=NIL,79,c2)
  ENDI
  cx_toda=IF(cx_toda=NIL,.t.,cx_toda)   // avalia toda a area de atuacao do mouse?
  MOUSEBOX(l1,c1,l2,c2)                 // define area do mouse
  Tecl_p=0
  MOUSECUR(.t.)                         // liga cursor do mouse

  #ifdef COM_REDE
   Tp_Sai=SECONDS()+drvtempo            // tempo de "refresh"
  #endi

  DO WHIL Tecl_p=0

   #ifdef COM_REDE
    IF drvtempo>0.AND.SECONDS()>Tp_Sai  // see' tempo do "refresh"
     EXIT                               // cai fora...
    ENDI
   #endi

   DO WHILE (clic:=MOUSEGET(@li,@co))>0 // espera um clique do mouse
    IF SECONDS()>tpo_mouse              // botao do mouse retido por mais de 1 seg,
     EXIT                               // significa mouse sendo arrastado com
    ENDI                                // o botao apertado
   ENDD
   tecl_p=NEXTKEY()                     // le tecla do buffer do teclado
   IF tecl_p=0                          // esta vazio
    IF clic=ESQUERDO                    // botao esquerdo pressionado
     tecl_p=CLICK
     IF li=l1 .OR. li=l2 .OR. cx_toda   // avalia onde foi o clique
      IF CLICK_EM(gcr,li,co)
       tecl_p=K_ENTER
      ELSEIF CLICK_EM("F10",li,co)
       tecl_p=K_F10
      ELSEIF CLICK_EM("F9",li,co)
       tecl_p=K_F9
      ELSEIF CLICK_EM("F8",li,co)
       tecl_p=K_F8
      ELSEIF CLICK_EM("F4",li,co)
       tecl_p=K_F4
      ELSEIF CLICK_EM("F3",li,co)
       tecl_p=K_F3
      ELSEIF CLICK_EM("TAB",li,co)
       tecl_p=K_TAB
      ELSEIF CLICK_EM(CHR(27),li,co)
       tecl_p=K_LEFT
      ELSEIF CLICK_EM(CHR(26),li,co)
       tecl_p=K_RIGHT
      ELSEIF CLICK_EM(CHR(24),li,co)
       tecl_p=K_UP
      ELSEIF CLICK_EM(CHR(25),li,co)
       tecl_p=K_DOWN
      ELSEIF CLICK_EM("PgUp",li,co) .OR. CLICK_EM(CHR(30),li,co)
       tecl_p=K_PGUP
      ELSEIF CLICK_EM("PgDn",li,co) .OR. CLICK_EM(CHR(31),li,co)
       tecl_p=K_PGDN
      ELSEIF CLICK_EM("Topo",li,co) .OR. CLICK_EM(CHR(174),li,co)
       tecl_p=K_CTRL_PGUP
      ELSEIF CLICK_EM("Fim",li,co)  .OR. CLICK_EM(CHR(175),li,co)
       tecl_p=K_CTRL_PGDN
      ELSEIF CLICK_EM(CHR(18),li,co)
       tecl_p=74
      ELSEIF e_calc                     // clique da calculadora sobre
       msg="1234567890.+-*/%^#$C=R"     // um numero ou sinal
       FOR i=1 TO LEN(msg)
        IF CLICK_EM(SUBS(msg,i,1),li,co)
         tecl_p=ASC(SUBS(msg,i,1))
         EXIT
        ENDI
       NEXT
      ENDI
     ENDI
    ELSEIF clic=DIREITO                 // botao da direita
     tecl_p=K_ESC                       // abandona com ESC
    ELSE
     tpo_mouse=-1                       // reseta o tempo do mouse
    ENDI
    IF tecl_p>2                         // tecla de funcao clicada
     KEYB CHR(tecl_p)                   // forca tecla no buffer do teclado

     #ifdef COM_TUTOR
      IN_KEY(0)
     #else
      INKEY(0)
     #endi

    ENDI
   ELSE

    #ifdef COM_TUTOR
     IN_KEY(0)                          // recebe tecla digitada
    #else
     INKEY(0)                           // recebe tecla digitada
    #endi

   ENDI
  ENDD
  MOUSECUR(.f.)                         // deliga cursor do mouse
  tpo_mouse=IF(tpo_mouse=-1,SECONDS()+1,tpo_mouse)
  IF cur_!=0
   SETPOS(lin_cur,col_cur)              // retorna o cursor a posicao original
  ENDI
 ELSE                                   // mouse esta' desligado...

  #ifdef COM_TUTOR

   #ifdef COM_REDE
    tecl_p=IN_KEY(drvtempo)             // faz "refresh" a cada drvtempo seg
   #else
    tecl_p=IN_KEY(0)                    // aguarda usuario teclar algo
   #endi

  #else

   #ifdef COM_REDE
    tecl_p=INKEY(drvtempo)              // faz "refresh" a cada drvtempo seg
   #else
    tecl_p=INKEY(0)                     // aguarda usuario teclar algo
   #endi

  #endi

 ENDI
 RETU tecl_p                            // retorna tecla desejada

 /*
    Sintaxe: CLICK_EM( <ExpC> <,ExpN1> <,ExpN2> )
    Funcao.: Verifica se ExpC esta sobre as coordenadas ExpN1 e ExpN2
    Retorna: .t. se teve sucesso
 */
 STATIC FUNC CLICK_EM(te_cl,li,co)
 LOCAL t_s:="", t1, t2, t_
 t1=LEN(te_cl)                          // salva trecho de tela nas
 t_ := SAVESCREEN(li,co-t1,li,co+t1)    // coordenadas do clique
 t1=LEN(t_)
 FOR t2=1 TO t1 STEP 2                  // separa os atributos das letras
  t_s+=SUBST(t_,t2,1)                   // do trecho salvo
 NEXT
 t1=AT(te_cl,t_s)                       // tecla esta sob o cursor?
 IF t1>0                                // verifica se a tecla nao e'
  t2=ASC(SUBS(t_s,t1-1,1))              // um pedaco de palavvra
  t1=ASC(SUBS(t_s,t1+LEN(te_cl),1))
  IF (t1<65 .OR. t1>125) .AND. (t2<65 .OR. t2>125)
   RETU .t.                             // ok. a tecla foi clicada
  ENDI
 ENDI
 RETU .f.                               // a tecla nao foi clicada

#endi

* \\ Final de ADR_FUNC.PRG
/*
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
 \ Empresa.: PresServ Inform tica - Limeira (019)452.6623
 \ Programa: MFILIAL.PRG
 \ Data....: 22-01-08
 \ Sistema.: Administradora - RECEP€„O
 \ Funcao..: Gerenciador do subsistema de avisos / carencias
 \ Analista: Ademilson Pedro Bom
 \ Criacao.: GAS-Pro v4.0o
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/

#include "adrbig.ch"    // inicializa constantes manifestas

PARA lin_menu,col_menu
PRIV op_sis, tela_fundo:=SAVESCREEN(0,0,MAXROW(),79), l_s, c_s, l_i, c_i, l_a

op_sis=EVAL(qualsis,"MFILIAL")
IF .f. //nivelop<sistema[op_sis,O_OUTROS,O_NIVEL]        // se usuario nao tem permissao,
 ALERTA()                                          // entao, beep, beep, beep
 DBOX(msg_auto,,,3)                                // lamentamos e
 RETU                                              // retornamos ao menu
ENDI
cn:=fgrep :=.f.

#ifdef COM_LOCK
 IF LEN(pr_ok)>0                                   // se a protecao acusou
  ? pr_ok                                          // erro, avisa e
  QUIT                                             // encerra a aplicacao
 ENDI
#endi

t_fundo=SAVESCREEN(0,0,MAXROW(),79)                // salva tela do fundo
op_cad=1
DO WHIL op_cad!=0
 criterio=""
 RESTSCREEN(0,0,MAXROW(),79,t_fundo)               // restaura tela do fundo
 cod_sos=5 ; cn=.f.
 CLEA TYPEAHEAD                                    // limpa o buffer do teclado
 fgrep=.f.
 SET KEY K_F3 TO                                   // retira das teclas F3 e F4 as
 SET KEY K_F4 TO                                   // funcoes de repeticao e confirmacao
 msg="Inclus„o~1|"+;
     "Manuten‡„o~2|"+;
     "Consulta~3"
 op_cad=DBOX(msg,lin_menu,col_menu,E_MENU,NAO_APAGA,MAIUSC(sistema[op_sis,O_MENU]),,,op_cad)
 IF op_cad!=0                                      // se escolheu uma opcao
  Tela_fundo=SAVESCREEN(0,0,MAXROW(),79)           // salva a tela para ROLATELA()
  PARAMETROS(dbfparam)
  SELE A                                           // e abre o arquivo e seus indices

  #ifdef COM_REDE
   IF !USEARQ(sistema[op_sis,O_ARQUI,O_NOME],.f.,20,1)
                                                   // se falhou a abertura do
    RETU                                           // arquivo volta ao menu anterior
   ENDI
  #else
   USEARQ(sistema[op_sis,O_ARQUI,O_NOME])
  #endi

  SET KEY K_F9 TO veoutros                         // habilita consulta em outros arquivos
 ENDI
 DO CASE
  CASE op_cad=01                                   // inclus„o
   op_menu=INCLUSAO
   IF AT("D",exrot[op_sis])=0                      // se usuario pode fazer inclusao
    MFI_INCL()                                     // neste arquivo chama prg de inclusao
   ELSE                                            // caso contrario vamos avisar que
    ALERTA()                                       // ele nao tem permissao para isto
    DBOX(msg_auto,,,3)
   ENDI

  CASE op_cad=02                                   // manuten‡„o
   op_menu=ALTERACAO
   cod_sos=7
   EDIT()

  CASE op_cad=03                                   // consulta
   op_menu=PROJECOES
   cod_sos=8
   EDITA(03,03,MAXROW()-2,77)

 ENDC
 SET KEY K_F9 TO                                   // F9 nao mais consultara outros arquivos
 CLOS ALL                                          // fecha todos arquivos abertos
ENDD
RETU

PROC MFI_incl(reg_cop)  // inclusao no arquivo MFILIAL
LOCAL getlist:={},cabem:=1,rep:=ARRAY(FCOU()),ult_reg:=RECN(),dbfseq_,;
      ctl_r, ctl_c, ctl_w, t_f3_, t_f4_, dele_atu:=SET(_SET_DELETED,.f.)
PRIV op_menu:=INCLUSAO, sq_atual_, tem_borda, criterio:="", cpord:=""
FOR i=1 TO FCOU()                                  // cria/declara privadas as
 msg=FIEL(i)                                       // variaveis de memoria com
 PRIV &msg.                                        // o mesmo nome dos campos
NEXT                                               // do arquivo
IF reg_cop!=NIL                                    // quer repetir todo o reg atual
 FOR i=1 TO FCOU()                                 // para cada campo,
  msg=FIEL(i)                                      // salva o conteudo
  rep[i]=&msg.                                     // para repetir
 NEXT
ELSE
 AFILL(rep,"")                                     // eche com valor vazio
ENDI
t_f3_=SETKEY(K_F3,{||rep()})                       // repeticao reg anterior
t_f4_=SETKEY(K_F4,{||conf()})                      // confirma campos com ENTER
ctl_w=SETKEY(K_CTRL_W,{||nadafaz()})               // enganando o CA-Clipper...
ctl_c=SETKEY(K_CTRL_C,{||nadafaz()})
ctl_r=SETKEY(K_CTRL_R,{||nadafaz()})

#ifdef COM_REDE
 MFI_CRIA_SEQ()                                    // cria dbf de controle de cp sequenciais
 FOR i=1 TO FCOU()                                 // cria/declara privadas as
  msg="sq_"+FIEL(i)                                // variaveis de memoria com
  PRIV &msg.                                       // o mesmo nome dos campos
 NEXT                                              // do arquivo com extensao _seq
#endi

DO WHIL cabem>0
 cod_sos=6
 rola_t=.f.                                        // flag se quer rolar a tela
 SELE MFILIAL
 GO BOTT                                           // forca o
 SKIP                                              // final do arquivo
 
 /*
    cria variaveis de memoria identicas as de arquivo, para inclusao
    de registros
 */
 FOR i=1 TO FCOU()
  msg=FIEL(i)
  M->&msg.=IF((fgrep .OR. reg_cop!=NIL).AND.!EMPT(rep[1]),rep[i],&msg.)
 NEXT
 DISPBEGIN()                                       // apresenta a tela de uma vez so
 MFI_TELA()
 INFOSIS(.t.)                                      // exibe informacao no rodape' da tela
 DISPEND()
 MFI_GERA_SEQ()
 cabem=DISKSPACE(;
          IF(;
             LEN(sistema[op_sis,O_ARQUI,O_DIR_DBF])<2.OR.sistema[op_sis,O_ARQUI,O_DIR_DBF]="\",;
             0,;
             ASC(sistema[op_sis,O_ARQUI,O_DIR_DBF])-64;
          );
       )
 cabem=INT((cabem-2048)/MFILIAL->(RECSIZE()))
 IF cabem<1                                        // mais nenhum!!!
  ALERTA()
  msg="Verifique ESPA€O EM DISCO, "+usuario
  DBOX(msg,,,,,"INCLUSŽO INTERROMPIDA!")           // vamos parar por aqui!
  EXIT
 ENDI
 M->data_=DATE()
 M->por=M->usuario
 SELE 0                                            // torna visiveis variaveis de memoria
 MFI_GET1(INCLUI)                                  // recebe campos
 SELE MFILIAL
 IF LASTKEY()=K_ESC                                // se cancelou
  cabem=0                                          // prepara saida da inclusao
  LOOP
 ENDI

 #ifdef COM_REDE
  GO BOTT                                          // vamos bloquear o final do
  SKIP                                             // arq para que nehum outro
  BLOREG(0,.5)                                     // usuario possa incluir
 #endi

 APPEND BLANK                                      // inclui reg em branco no dbf
 FOR i=1 TO FCOU()                                 // para cada campo,
  msg=FIEL(i)                                      // salva o conteudo
  rep[i]=M->&msg.                                  // para repetir
  REPL &msg. WITH rep[i]                           // enche o campo do arquivo
 NEXT

 #ifdef COM_REDE
  UNLOCK                                           // libera o registro e
  COMMIT                                           // forca gravacao
 #else
  IF RECC()-INT(RECC()/20)*20=0                    // a cada 20 registros
   COMMIT                                          // digitados forca gravacao
  ENDI
 #endi

 ult_reg=RECN()                                    // ultimo registro digitado
 IF reg_cop!=NIL                                   // estava na consulta e quis rep o campo
  sq_atual_=NIL
  EXIT                                             // cai fora...
 ENDI
ENDD

#ifdef COM_REDE
 MFI_ANT_SEQ()                                     // restaura sequencial anterior
 SELE MFILIAL
#endi

GO ult_reg                                         // para o ultimo reg digitado
SETKEY(K_F3,t_f3_)                                 // restaura teclas de funcoes
SETKEY(K_F4,t_f4_)
SET(_SET_DELETED,dele_atu)                            // ecluidos visiveis/invisiveis
SETKEY(K_CTRL_W,ctl_w)
SETKEY(K_CTRL_C,ctl_c)
SETKEY(K_CTRL_R,ctl_r)
RETU



#ifdef COM_REDE
 PROC MFI_ANT_SEQ(est_seq)     // restaura sequencial anterior
 SELE MFI_SEQ     // seleciona arquivo de controle de sequencial
 BLOARQ(0,.5)     // esta estacao foi a ultima a incluir?
 IF sq_atual_ == seq0
  REPL seq0 WITH sq_seq0
 ENDI
 UNLOCK           // libera DBF para outros usuarios
 COMMIT           // atualiza cps sequenciais no disco
 RETU
#endi


PROC MFI_CRIA_SEQ   // cria dbf de controle de campos sequenciais
LOCAL dbfseq_:=sistema[op_sis,O_ARQUI,O_DIR_DBF]+"MFI_seq" // arq temporario
SELE 0                          // seleciona area vazia
IF !FILE(dbfseq_+".dbf")        // se o dbf nao existe
 DBCREATE(dbfseq_,{;            // vamos criar a sua estrutura
                    {"seq0"      ,"C",  6, 0};
                  };
 )
ENDI
USEARQ(dbfseq_,.f.,,,.f.)       // abre arquivo de cps sequencial
IF RECC()=0                     // se o dbf foi criado agora
 BLOARQ(0,.5)                   // inclui um registro que tera
 APPEND BLANK                   // os ultomos cps sequenciais
 SELE MFILIAL
 IF RECC()>0                    // se o DBF nao estiver
  SET ORDER TO 0                // vazio, entao enche DBF seq
  GO BOTT                       // com o ultimo reg digitado
  REPL MFI_SEQ->seq0 WITH seq0
  DBSETORDER(1)                 // retorna ao indice principal
 ENDI
 SELE MFI_SEQ                   // seleciona arq de sequencias
 UNLOCK                         // libera DBF para outros usuarios
 COMMIT                         // atualiza cps sequenciais no disco
ENDI
RETURN

PROC MFI_GERA_SEQ()

#ifdef COM_REDE
 LOCAL ar_:=SELEC()
#else
 LOCAL reg_:=RECNO(),ord_ind:=INDEXORD()
#endi


#ifdef COM_REDE
 SELE MFI_SEQ
 BLOARQ(0,.5)
 sq_seq0=MFI_SEQ->seq0
#else
 DBSETORDER(0)
 GO BOTT
#endi

M->seq0=LPAD(STR(VAL(seq0)+1),06,[0])

#ifdef COM_REDE
 MFI_GRAVA_SEQ()
 sq_atual_=MFI_SEQ->seq0
 UNLOCK                                            // libera o registro
 COMMIT
 SELE (ar_)
#else
 DBSETORDER(ord_ind)
 GO reg_
#endi

RETU

PROC MFI_GRAVA_SEQ
REPL seq0 WITH M->seq0
RETU

PROC MFI_tela     // tela do arquivo MFILIAL
tem_borda=.t.
l_s=Sistema[op_sis,O_TELA,O_LS]           // coordenadas da tela
c_s=Sistema[op_sis,O_TELA,O_CS]
l_i=Sistema[op_sis,O_TELA,O_LI]
c_i=Sistema[op_sis,O_TELA,O_CI]
SETCOLOR(drvtittel)
vr_memo=NOVAPOSI(@l_s,@c_s,@l_i,@c_i)     // pega posicao atual da tela
CAIXA(mold,l_s,c_s,l_i,c_i)               // monta caixa da tela
i=LEN(sistema[op_sis,O_MENS])/2
@ l_s,c_s-1+(c_i-c_s+1)/2-i SAY " "+MAIUSC(sistema[op_sis,O_MENS])+" "
SETCOLOR(drvcortel)
@ l_s+02,c_s+1 SAY "ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ"
@ l_s+03,c_s+1 SAY " Codigo..........:"
@ l_s+04,c_s+1 SAY " Termino Carencia:"
@ l_s+05,c_s+1 SAY " Obs1............:"
@ l_s+06,c_s+1 SAY " Obs2............:"
@ l_s+07,c_s+1 SAY " Obs3............:"
RETU

PROC MFI_gets     // mostra variaveis do arquivo MFILIAL
LOCAL getlist := {}
MFI_TELA()
SETCOLOR(drvcortel+","+drvcorget+",,,"+corcampo)
PTAB(ALLTRIM(CODIGO),[GRUPOS])
@ l_s+01 ,c_s+03 GET  seq0;
                 PICT sistema[op_sis,O_CAMPO,02,O_MASC]

@ l_s+01 ,c_s+49 GET  data_;
                 PICT sistema[op_sis,O_CAMPO,03,O_MASC]

@ l_s+01 ,c_s+60 GET  por

@ l_s+03 ,c_s+20 GET  codigo;
                 PICT sistema[op_sis,O_CAMPO,05,O_MASC]

@ l_s+04 ,c_s+20 GET  tcarenc_;
                 PICT sistema[op_sis,O_CAMPO,06,O_MASC]

@ l_s+05 ,c_s+20 GET  obs1;
                 PICT sistema[op_sis,O_CAMPO,07,O_MASC]

@ l_s+06 ,c_s+20 GET  obs2;
                 PICT sistema[op_sis,O_CAMPO,08,O_MASC]

@ l_s+07 ,c_s+20 GET  obs3;
                 PICT sistema[op_sis,O_CAMPO,09,O_MASC]

CRIT("",,"1")
CLEAR GETS
RETU

PROC MFI_get1(tp_mov)     // capta variaveis do arquivo MFILIAL
LOCAL getlist := {}
PRIV  blk_mfilial:=.t.

IF tp_mov=INCLUI
 DO WHILE .t.
  rola_t=.f.
  SET KEY K_ALT_F8 TO ROLATELA
  SETCOLOR(drvcortel+","+drvcorget+",,,"+corcampo)
  @ l_s+01 ,c_s+03 GET seq0;
                   PICT sistema[op_sis,O_CAMPO,02,O_MASC]
  @ l_s+01 ,c_s+49 GET data_;
                   PICT sistema[op_sis,O_CAMPO,03,O_MASC]
  @ l_s+01 ,c_s+60 GET por
  CLEA GETS
  @ l_s+03 ,c_s+20 GET  codigo;
                   PICT sistema[op_sis,O_CAMPO,05,O_MASC]
                   DEFINICAO 5

  @ l_s+04 ,c_s+20 GET  tcarenc_;
                   PICT sistema[op_sis,O_CAMPO,06,O_MASC]
                   DEFINICAO 6

  @ l_s+05 ,c_s+20 GET  obs1;
                   PICT sistema[op_sis,O_CAMPO,07,O_MASC]
                   DEFINICAO 7

  @ l_s+06 ,c_s+20 GET  obs2;
                   PICT sistema[op_sis,O_CAMPO,08,O_MASC]
                   DEFINICAO 8

  @ l_s+07 ,c_s+20 GET  obs3;
                   PICT sistema[op_sis,O_CAMPO,09,O_MASC]
                   DEFINICAO 9

  READ
  SET KEY K_ALT_F8 TO
  IF rola_t
   ROLATELA()
   LOOP
  ENDI
  IF LASTKEY()!=K_ESC .AND. drvincl .AND. op_menu=INCLUSAO
   IF !CONFINCL()
    LOOP
   ENDI
  ENDI
  EXIT
 ENDD
ENDI
PTAB(ALLTRIM(CODIGO),[GRUPOS])
PTAB(CODIGO,'TAXAS',1)
IF tp_mov=EXCLUI .OR. tp_mov=FORM_INVERSA
 msgX:=[]
 msg1find:=[**> ATENCAO   ATENCAO   ATENCAO <**]
 msg2find:=[(]+ALLTRIM(idxd)
 ultmsg1:=ultmsg2:=0
 FOR contmsg=1 TO 20
  msgadd:=MEMOLINE(GRUPOS->obs,60,contmsg)
  IF (msg1find$msgadd)
   ultmsg1:=contmsg
  ENDI
  IF (msg2find$msgadd)
   ultmsg2:=contmsg
  ENDI
 NEXT
 FOR contmsg=1 TO 20
  IF contmsg>=ultmsg1.AND.contmsg<=ultmsg2
  ELSE
   msgadd:=MEMOLINE(GRUPOS->obs,60,contmsg)
   msgX+=msgadd+chr(13)+chr(10)
  ENDI
 NEXT

 #ifdef COM_REDE
  REPBLO('GRUPOS->obs',{||msgX})
 #else
  REPL GRUPOS->obs WITH msgX
 #endi

 IF !EMPTY(ALIAS())
  DELE
 ENDI
ELSEIF tp_mov=INCLUI .OR. tp_mov=RECUPERA .OR. tp_mov=FORM_DIRETA
 IF (op_menu=INCLUSAO .AND. LASTKEY()!=K_ESC) .OR. op_menu!=INCLUSAO
   IF EMPT(idxd)
    IF op_menu=INCLUSAO
     idxd=dtoS(DATE())+time()+M->usuario
    ELSE
     REPL idxd WITH dtoS(DATE())+time()+M->usuario
    ENDI
   ENDI
   msg_obs_aux:=[**> ATENCAO   ATENCAO   ATENCAO <**]+CHR(13)+CHR(10)
   msg_obs_fim:=[***--(]+ALLTRIM(idxd)+[)--***]+CHR(13)+CHR(10)
   IF !EMPT(tcarenc_)
    msg_obs_aux+=[ Contrato em Carencia por negociacao ate ]+dtoc(TCARENc_)+;
                CHR(13)+CHR(10)
   ENDI
   REPBLO('GRUPOS->obs',{||msg_obs_aux+ALLTRIM(obs1)+CHR(13)+CHR(10)+;
                          ALLTRIM(obs2)+CHR(13)+CHR(10)+;
                          ALLTRIM(obs3)+chr(13)+chr(10)+;
                          msg_obs_fim+GRUPOS->obs})
//   [ (]+LEFT(DTOC(DATE()),6)+RIGHT(DTOC(DATE()),2)+[ ]+LEFT(TIME(),5)+[ ]+M->USUARIO+[)]+chr(13)+chr(10)+GRUPOS->obs})
   IF op_menu=INCLUSAO
    idxm=DTOS(DATE())+time()+M->usuario
   ELSE
    REPL idxm WITH DTOS(DATE())+time()+M->usuario
   ENDI
   IF op_menu=INCLUSAO
    filial=M->p_filial
   ELSE
    REPL filial WITH M->p_filial
   ENDI
  IF op_menu!=INCLUSAO
   RECA
  ENDI
 ENDI
ENDI
RETU

* \\ Final de MFILIAL.PRG
GAS-Pro v3.0

[Ÿ]
 0 





001









 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
procedure adr_adap
/*
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
 \ Empresa.: PresServ Inform tica - Limeira (019)452.6623
 \ Programa: ADR_ADAP.PRG
 \ Data....: 29-01-04
 \ Sistema.: Administradora - RECEP€„O
 \ Funcao..: Adapta arquivos do sistema
 \ Analista: Ademilson Pedro Bom
 \ Criacao.: GAS-Pro v4.0o
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/
#include "adrbig.ch"    // inicializa constantes manifestas

REQUEST IN_KEY

V0=SAVESCREEN(0,0,MAXROW(),79) // tela do DOS
CLEA SCREEN                    // limpa a tela

NAOPISCA()                     // habilita 256 cores (ega/vga)
SETCANCEL(.f.)                 // desativa ALT-C/BREAK
SET SCOREBOARD OFF             // habilita uso da linha 0
SET CENTURY ON               // datas com informa‡„o do s‚culo DD/MM/AAAA
SET DATE BRIT                  // datas no formato 'britasileiro`
SET WRAP ON                    // habilita rolagem de menus
SETKEY(K_INS,{||;              // muda tamanho do cursor quando inserindo
              IF(READINSERT(),SETCURSOR(1),SETCURSOR(3)),;
              READINSERT(!READINSERT());
             };
)

VideoSeg=IF(CARDTYPE()=V_MONO,45056,-18432) // area de video

/*
   rotina utilizando funcoes em assembly para pegar o  nome do programa
   que e' colocado pelo DOS no PSP (Program Segment Prefix) do programa
   que esta sendo executado.  O segmento do ambiente esta  no  endereco
   44/45 do segmento do PSP
*/
VAL_AX("6200")                 // funcao 62h retorna segmento do PSP em BX
CALLINT("21")                  // executa interrupt 21
x=VAL_BX()                     // pega o segmento do PSP
Sg=PEEK(x,44)+PEEK(x,45)*256   // calcula endereco do segmento de ambiente

/*
   Agora, procura no segmento de ambiente, por dois bytes ZERO seguidos.
   O nome do programa comeca 2 bytes apos os ZEROs
*/
x=0
DO WHIL .t.
 IF PEEK(Sg,x)=0               // este e o primeiro ZERO
  IF PEEK(Sg,x+1)=0            // se o proximo tambem for,
   x+=2                        // entao pula ambos
   EXIT                        // e sai
  ENDI
 ENDI
 x++                           // continua procurando
ENDD
exe=""
IF PEEK(Sg,x)=1                // se este byte = 1, entao
 x+=2                          // o nome comeca aqui e vai
 DO WHIL PEEK(Sg,x)>0          // at‚ encontrar outro 0
  exe+=CHR(PEEK(Sg,x))         // pega mais uma letra do nome
  x++
 ENDD
ENDI
IF EMPTY(exe)                  // CA-Clipper nao pegou diretorio do exe
 exe=TRATADIR(QUALDIR())       // assume diretorio atual
ENDI

/*
   inicializa variaveis publicas
*/
nss=030
drvdbf:=drvntx:=drverr:=drvpw := TRATADIR(QUALDIR())
drvcara=CHR(178); mold="ÚÄ¿³ÙÄÀ³ÃÄ´"
drvmenucen=.f.; drvfonte=1
nemp="PresServ Inform tica - Limeira (019)452.6623"
nsis="Administradora - RECEP€„O"
arqgeral="ADR"
drvcorpad="W+/RB"  ; drvcorbox="W+/B"         // cores default
drvcormsg="W+/W"   ; drvcorenf="W+/R"
drvcorget="W+/BG"  ; drvcortel="W+/B"
drvcorhlp="GR+/GR" 
drvtitpad="GR+/RB" ; drvtitbox="GR+/B"        // cores dos titulos default
drvtitmsg="GR+/W"  ; drvtitenf="GR+/R"
drvtitget="GR+/BG" ; drvtittel="GR+/B"
drvtithlp="W+/GR"  
IF EMPTY(exe)                      // CA-Clipper nao pegou diretorio do exe
 cod_sos=1
 msgt="DIRET¢RIO DO EXECUTVEL"    // entao, vamos solicitar ao usuario
 exe=DBOX("Informe o nome do diret¢rio|onde o arquivo EXE esta",,,,,msgt,SPAC(60),"@!",,"W+/N")
 IF LASTKEY()=K_ESC .OR.;          // desistiu...
    EMPTY(exe)                     // ou nao informou
  RESTSCREEN(0,0,MAXROW(),79,v0)   // restaura tela
  SETPOS(MAXROW()-1,1)             // cursor na penultima linha, coluna 1
  RETU                             // e volta ao DOS
 ENDI
 exe=TRATADIR(exe)                 // assume diretorio atual
ENDI
exe=UPPER(exe)                 // captaliza nome do programa
drvexe=LEFT(exe,RAT("\",exe))
arqconf=drvexe+arqgeral+"_temp.sys"
acao_mac="D"                                   // inicializa flag
IF FILE(arqconf)
 REST FROM (arqconf) ADDI                      // restaura configuracoes gravadas
ENDI
drvautohelp:=drvmouse:=drvsom :=.f.            // sem ajuda ativa, sem mouse e som
AFILL(sistema:=ARRAY(nss),{})                  // enche sistema[] com vetores nulos
SETCOLOR(drvcorpad)                            // imprime pano de fundo
CAIXA(REPL(drvcara,9),0,0,MAXROW(),79)
SETCOLOR(drvtitbox)
CAIXA(mold,01,03,05,77)                        // monta cabecalho do programa
SETCOLOR(drvcorbox)
@ 02,05 SAY nemp                               // conteudo do cabecalho
@ 02,66 SAY DATE()
@ 02,57 SAY NSEM(DATE())
@ 03,05 SAY nsis
@ 04,05 SAY "ADAPTADOR DE ARQUIVOS DBF"
cn=.f.; cod_sos=4
DO WHIL !cn
 V1=SAVESCREEN(0,0,MAXROW(),79)                // salva fundo/cabecalho
 SETCOLOR(drvtittel)
 CAIXA(mold,07,16,16,63)
 @ 10,16 SAY SUBS(mold,9,1)+REPL(SUBS(mold,10,1),46)+SUBS(mold,11,1)
 SETCOLOR(drvcortel)
 @ 08,29 SAY "DIRET¢RIOS DE TRABALHO"          // monta tela para receber
 @ 09,31 SAY "F10=pega diret¢rio"
 @ 11,18 SAY "Arquivos de dados..:"            // os diretorios dos dados
 @ 12,18 SAY "Arquivos de indices:"
 @ 13,18 SAY "Arquivos de apoio..:"
 @ 14,18 SAY "Arquivo execut vel.:"
 @ 15,18 SAY "Arquivo de senha...:"
 drvdbf=PADR(drvdbf,50)                        // prepara diretorio para o get
 drvntx=PADR(drvntx,50)
 drverr=PADR(drverr,50)
 drvexe=PADR(drvexe,50)
 drvpw=PADR(drvpw,50)
 SET KEY K_F10 TO CAPTURADIR()
 @ 11,39 GET drvdbf PICT "@S23@!" VALI DRVEXISTE(drvdbf)
 @ 12,39 GET drvntx PICT "@S23@!" VALI DRVEXISTE(drvntx)
 @ 13,39 GET drverr PICT "@S23@!" VALI DRVEXISTE(drverr)
 @ 14,39 GET drvexe PICT "@S23@!" VALI DRVEXISTE(drvexe)
 @ 15,39 GET drvpw PICT "@S23@!" VALI DRVEXISTE(drvpw)
 READ
 SET KEY K_F10 TO
 IF LASTKEY()=K_ESC                            // abandonado...
  op_=3
 ELSE
  drvdbf=TRATADIR(drvdbf)                      // coloca "\" ao final
  drvntx=TRATADIR(drvntx)                      // do diretorio
  drverr=TRATADIR(drverr)
  drvexe=TRATADIR(drvexe)
  drvpw=TRATADIR(drvpw)
  AFILL(sistema:=ARRAY(nss),{})                // enche sistema[] com vetores nulos
  ADR_ATRI()                                   // enche sistema[] com atributos dos DBF
ADR_ATR1()
ADR_ATR2()
  dbfdefa:=ntxdefa := ""
  FOR t=1 TO nss-3                             // verifica que mais pede diretorio
   IF sistema[t,O_OUTROS,O_PEDEDIR]            // esse pede...
    RESTSCREEN(0,0,MAXROW(),79,v1)             // restaura cabecalho e pano de fundo
    SETCOLOR(drvtittel)
    CAIXA(mold,07,16,13,63)                    // janela dos diretorios
    @ 10,16 SAY SUBS(mold,9,1)+REPL(SUBS(mold,10,1),46)+SUBS(mold,11,1)
    SETCOLOR(drvcortel)
    @ 08,17 SAY PADC(UPPER(sistema[t,O_MENU]),46)
    @ 09,17 SAY PADC("F10=pega diret¢rio",46)
    @ 11,18 SAY "Arquivos de dados..:"
    @ 12,18 SAY "Arquivos de indices:"
    cn=.f.; cod_sos=4
    drv_="drvdbf"+LEFT(sistema[t,O_ARQUI,O_NOME],3)
    ntx_="drvntx"+LEFT(sistema[t,O_ARQUI,O_NOME],3)
    IF EMPTY(dbfdefa)
     dbfdefa=&drv_.
     ntxdefa=&ntx_.
    ENDI
    &drv_.=PADR(dbfdefa,50)                     // prepara diretorio para o get
    &ntx_.=PADR(ntxdefa,50)
    SET KEY K_F10 TO CAPTURADIR()
    @ 11,39 GET &drv_. PICT "@S23@!" VALI DRVEXISTE(&drv_.)
    @ 12,39 GET &ntx_. PICT "@S23@!" VALI DRVEXISTE(&ntx_.)
    READ
    SET KEY K_F10 TO
    IF LASTKEY()=K_ESC                         // cancelou...
     RESTSCREEN(0,0,MAXROW(),79,v0)            // s'imbora
     SETPOS(MAXROW()-1,1)                      // cursor na penultima linha, coluna 1
     RETU                                      // retorna ao DOS
    ENDI
    &drv_.=TRATADIR(&drv_)                     // coloca "\" ao final
    &ntx_.=TRATADIR(&ntx_)                     // coloca "\" ao final
    dbfdefa=&drv_.
    ntxdefa=&ntx_.
   ENDI
  NEXT
  ALERTA(1)
  msg="Prosseguir|Corrigir|Retornar ao DOS"
  op_=DBOX(msg,12,55,E_MENU,,"DIRET¢RIOS")     // confirma as informacoes
 ENDI
 IF op_=1                                      // se tudo certo,
  EXIT                                         // sai do loop
 ELSEIF op_=3
  RESTSCREEN(0,0,MAXROW(),79,v0)               // s'imbora
  SETPOS(MAXROW()-1,1)                         // cursor na penultima linha, coluna 1
  RETU                                         // retorna ao DOS
 ENDI
ENDD
RESTSCREEN(0,0,MAXROW(),79,v1)                 // restaura cabecalho e pano de fundo
msg_veri="Verificando arquivos..."             // pode demorar um pouco entao vamos
DBOX(msg_veri,,,,NAO_APAGA,"AGUARDE!")         // avisar que estamos trabalhando
cod_sos=1
cps_:=ARRAY(100)                               // armazenara' os novos conteudos dos cps
ADR_ATRI()                                     // enche sistema[] com atributos dos DBF
ADR_ATR1()
ADR_ATR2()

/*
   protege arquivo de dados contra acesso dBase e muda para "read-only"
*/
protdbf={|fg|pt:=fg,;                          // torna a flag visivel no proximo "code block"
          tel_p:=SAVESCREEN(0,0,MAXROW(),79),; // salva a tela
          DBOX("Um momento!",,,,NAO_APAGA),;   // mensagem ao usuario
          AEVAL(sistema,{|sis|;                // executa o "code block" para cada
                          EDBF(sis[O_ARQUI,O_DIR_DBF]+;  // um dos arquivos do vetor sistema
                              sis[O_ARQUI,O_NOME],pt);// (se pt, desprotege; senao, protege)
                        };
          ),;
          RESTSCREEN(0,0,MAXROW(),79,tel_p);   // restaura a tela
        }
arq_prn=drverr+"PRINTERS.DBF"                    // nome dbf de "drivers" da prn
IF FILE(arq_prn)                                 // se o arquivo de "drivers"
 estru_prn={;                                    // de impressoras existir
             {"marca" ,"C",15,0},;               // entao vamos verificar se ele
             {"porta" ,"C", 4,0},;               // necessita de alguma adaptacao
             {"padrao","C", 1,0},;
             {"tapg"  ,"C",40,0},;
             {"pcom"  ,"C",40,0},;
             {"tcom"  ,"C",40,0},;
             {"pc20"  ,"C",40,0},;
             {"tc20"  ,"C",40,0},;
             {"peli"  ,"C",40,0},;
             {"teli"  ,"C",40,0},;
             {"penf"  ,"C",40,0},;
             {"tenf"  ,"C",40,0},;
             {"pexp"  ,"C",40,0},;
             {"texp"  ,"C",40,0},;
             {"pde8"  ,"C",40,0},;
             {"tde8"  ,"C",40,0},;
             {"land"  ,"C",40,0},;
             {"port"  ,"C",40,0};
           }
 USE (arq_prn)                                   // abre DBF de impressoras
 IF LEN(DBSTRUCT())!=LEN(estru_prn)              // se a qde de campos for
  USE                                            // diferente da nova estrutura
  bak=LEFT(arq_prn,LEN(arq_prn)-3)+"bak"         // entao vamos adaptar o DBF
  IF FILE(bak)                                   // se existir o arquivo temporario
   ERASE (bak)                                   // entao elimina-o
  ENDI
  RENAME (arq_prn) TO (bak)                      // cria .bak
  DBCREATE(arq_prn,estru_prn)                    // cria novo DBF para as impressoras
  USE (arq_prn)                                  // abre o DBF e aproveita
  APPEND FROM (bak)                              // os dados nele digitados
  USE
 ENDI
 CLOSE ALL                                       // fecha o DBF das impressoras aberto
ENDI
EVAL(protdbf,.t.)                                   // desprotege DBF
FOR op_sis=1 TO nss-3                            // vamos verificar quais DBF
 IF FILE(sistema[op_sis,O_ARQUI,O_DIR_DBF]+sistema[op_sis,O_ARQUI,O_NOME]+".dbf") // necessitam ser adaptados
  dbf=sistema[op_sis,O_ARQUI,O_DIR_DBF]+"temp9"  // se existir o DBF,
  stru=LEFT(sistema[op_sis,O_ARQUI,O_NOME],3)+"_estr"  // cria a estrutura atual
  &stru.()                                       // em um arquivo temporario
  USE (dbf)                                      // abre DBF temporario
  estru_nov=DBSTRUCT()                           // e captura a nova estrutura
  dbf=sistema[op_sis,O_ARQUI,O_DIR_DBF]+sistema[op_sis,O_ARQUI,O_NOME] // vamos fazer a mesma coisa
  USE (dbf)                                      // para capturar a antiga
  estru_vel=DBSTRUCT()                           // estrutura do arquivo,
  USE                                            // abrindo o DBF anterior
  ok=(LEN(estru_nov)=LEN(estru_vel))             // se a qde de campos for
  IF ok                                          // a mesma, entao vamos
   FOR t=1 TO LEN(estru_nov)                     // ver se os atributos dos
    FOR tt=1 TO 4                                // dois arquivos sao iguais
     IF !(estru_nov[t,tt]==estru_vel[t,tt])      // (nome, tipo, tam, dec)
      ok=.f.; t:=tt:= 9999
     ENDI
    NEXT
   NEXT
  ENDI
  IF !ok                                         // se o arquivo esta' diferente
   IF !CONVERTE(op_sis,estru_nov,estru_vel)      // executa a conversao do DBF
    RESTSCREEN(0,0,MAXROW(),79,v0)               // cancelou a adaptacao
    SETPOS(MAXROW()-1,1)                         // reposiciona cursor e
    RETU                                         // volta para o DOS
   ENDI
  ENDI
  FOR t=1 TO LEN(sistema[op_sis,O_INDIC])        // para eliminar os arquivos
   ntx=sistema[op_sis,O_ARQUI,O_DIR_NTX]+sistema[op_sis,O_INDIC,t]+EXTENSAO()
   IF FILE(ntx)                                  // de indices caso existam
    ERASE (ntx)
   ENDI
  NEXT
  dbf=sistema[op_sis,O_ARQUI,O_DIR_DBF]+LEFT(sistema[op_sis,O_ARQUI,O_NOME],3)+"_SEQ.dbf" // mata dbf de sequenciais
  IF FILE(dbf)
   ERASE (dbf)
  ENDI
  dbf=sistema[op_sis,O_ARQUI,O_DIR_DBF]+"temp9.dbf"
  IF FILE(dbf)                                   // se foi criado algum arquivo
   ERASE (dbf)                                   // temporario elimina-o antes
  ENDI                                           // de retornar ao DOS
  dbt=sistema[op_sis,O_ARQUI,O_DIR_DBF]+"temp9"+EXTENSAO(.f.)
  IF FILE(dbt)                                   // se foi criado algum arquivo
   ERASE (dbt)                                   // temporario do memo elimina-o
  ENDI                                           // antes de retornar ao DOS
 ENDI
NEXT
CLOSE ALL

#ifdef COM_PROTECAO
 EVAL(protdbf,.f.)                               // protege DBF
#endi

EVAL(protdbf,.t.)                                // desprotege DBF
dbft=drvpw+"temp9.dbf"                           // arq temporario
dbfg=drvpw+sistema[nss-2,O_ARQUI,O_NOME]+".dbf"  // grupos das senhas
dbf=drvpw+sistema[nss-1,O_ARQUI,O_NOME]+".dbf"   // acesso aos arq dbf dos grupos
IF FILE(dbf) .AND. FILE(dbfg)                    // se exite os aquivos de senhas
 IF FILE(dbft)                                   // se o arq temporario existir
  ERASE (dbft)                                   // vamos mata-lo
 ENDI
 DBCREATE(dbft,{;                                // cria arquio temp = acesso aos
                {"pw_grupo"  ,"C",  4, 0},;      // arq dbf dos gupos
                {"pw_dbf"    ,"C", 35, 0},;
                {"pw_permis" ,"C", 20, 0},;
                {"flag_excl" ,"C",  1, 0};
               };
         )
 SET DELE ON                                     // excluidos nao serao adaptados
 SELE A                                          // seleciona uma area vazia
 USE (dbfg)                                      // abre o arq de gupos de senhas
 SELE B                                          // seleciona outra area vazia
 USE (dbf)                                       // abre o arq de acessos
 INDEX ON pw_grupo+pw_dbf TO &drvpw.temp9        // cria indice temp pelo grupo+nome do arquivo
 SELE C                                          // outra area vazia
 USE (dbft)                                      // abre arq temporario
 SELE A                                          // vamos correr
 GO TOP                                          // todos os grupos
 DO WHILE !EOF()
  FOR i=1 TO nss-3                               // para cada arquivo
   SELE C                                        // vamos colocar seu acesso
   APPEND BLANK                                  // dentro do arq temporario
   REPL pw_grupo WITH A->pw_grupo,;
        pw_dbf WITH ENCRIPT(PADR(sistema[i,O_MENU],35))
   SELE B                                        // procura este acesso no arquivo velho
   SEEK A->pw_grupo+ENCRIPT(PADR(sistema[i,O_MENU],35))
   IF FOUND()                                    // achou...
    REPL C->pw_permis WITH B->pw_permis          // aproveita as permissoes anteriores
   ELSE
    REPL C->pw_permis WITH ENCRIPT(SPACE(20))    // nao achou, coloca brancos
   ENDI
  NEXT
  SELE A
  SKIP                                           // proximo grupo...
 ENDD
 CLOSE ALL                                       // fecha todos os arq
 ERASE (dbf)                                     // mata arq de acessos velho
 RENAME (dbft) TO (dbf)                          // troca o nome do arq temp para arq de acessos
 ERASE &drvpw.temp.ntx                           // mata indice temp
 FOR op_sis=nss-2 TO nss                         // corre os arq de senhas
  FOR t=1 TO LEN(sistema[op_sis,O_INDIC])        // para eliminar os arquivos
   ntx=sistema[op_sis,O_ARQUI,O_DIR_NTX]+sistema[op_sis,O_INDIC,t]+EXTENSAO()
   IF FILE(ntx)                                  // de indices caso existam
    ERASE (ntx)
   ENDI
  NEXT
 NEXT
ENDI
dbf=drvpw+"temp9"+EXTENSAO()                     // arq de indice temporario
IF FILE(dbf)                                     // se foi criado algum arquivo
 ERASE (dbf)                                     // temporario de indice elimina-o antes
ENDI                                             // de retornar ao DOS

#ifdef COM_PROTECAO
 EVAL(protdbf,.f.)                               // protege DBF
#endi

ALERTA(3)                                        // beep, beep, beep
DBOX("OK! Opera‡„o terminada",13,40,4)           // mostra msg de fim de operacao
RESTSCREEN(0,0,MAXROW(),79,v0)                   // s'imbora
SETPOS(MAXROW()-1,1)                             // cursor na penultima linha, coluna 1
RETU                                             // retorna para o DOS

FUNC CONVERTE(op_sis,estru_nov,estru_vel)        // converte DBF ...
dbf=sistema[op_sis,O_ARQUI,O_DIR_DBF]+sistema[op_sis,O_ARQUI,O_NOME]        // DBF a converter
USE (dbf)
AFILL(cps_,"")                                   // 'cps_` e' o vetor que armazenara'
qtcps=LEN(estru_nov)                             // os conteudos dos campos
FOR t=1 TO qtcps                                 // da nova estrutura
 i=ASCAN(estru_vel,;                             // inicializa 'cps_` com os
           {|cp|cp[1]==estru_nov[t,1].AND.;      // conteudos da estrutura anterior
                cp[2]==estru_nov[t,2];           // se o campo tiver o mesmo
           };                                    // nome e tamanho da nova estrutura
   )
 IF i>0                                          // ok! este campo e' o mesmo
  cps_[t]=estru_vel[i,1]                         // enche 'cps_` com o nome do
 ENDI                                            // campo da estrutura anterior
NEXT
op_a=1
DO WHIL op_a!=0
 RESTSCREEN(0,0,MAXROW(),79,v1)                  // retira msg 'aguarde...`
 msg=""                                          // msg armazenara' as opcoes
 FOR t=1 TO qtcps                                // de menu dos campos da
  msg+="|"+PADR(estru_nov[t,1],11)+"³ "+;        // nova estrutura e o conteudo
       PADR(cps_[t],30)                          // que sera' colocado em
 NEXT                                            // cada um deles
 msg =SUBS(msg,2)                                // retira o '|` do inicio
 cod_sos=1
 msgt='ARQUIVO "'+sistema[op_sis,O_ARQUI,O_NOME]+; // titulo do menu
      '"|*|ESTRUTURA    PREENCHER COM:'+SPAC(17)
 op_a=DBOX(msg,,,E_MENU,NAO_APAGA,msgt,,,op_a)   // apresenta o menu
 IF op_a>0                                       // escolheu um campo
  cp_=cps_[op_a]
  DO WHIL .t.
   SET KEY K_F10 TO ve_campos                    // F10 monta menu de campos
   cp_=LEFT(cp_+SPACE(250),250)                  // ate' 250 caracteres para digitar
   msg ="Entre com a express„o para preencher o campo"
   msgt='CONTEUDO DO CAMPO "'+estru_nov[op_a,1]+;
        '"|(F10=ESTRUTURA ANTERIOR)'
   cod_sos=2
   cp_=DBOX(msg,,,,NAO_APAGA,msgt,cp_,"@S50")    // recebe o novo conteudo...
   SET KEY K_F10 TO                              // desabilita a tecla F10
   IF LASTKEY()=K_ESC                            // se cancelou,
    EXIT                                         // retorna ao menu de campos
   ENDI
   cp_=ALLTRIM(cp_)                              // retira os espacos do novo conteudo
   tp_crit=TYPE(cp_)                             // se a expressao=indeterminada,
   IF tp_crit="UI"                               // existe funcao fora da clipper.lib
    tp_crit=VALTYPE(&cp_.)                       // na expressao, logo avalia o seu
   ENDI                                          // conteudo...
   IF EMPT(cp_).OR.tp_crit==estru_nov[op_a,2]    // se o tipo da expressao
    cps_[op_a]=cp_                               // informada for igual ao tipo
    EXIT                                         // do campo em questao,
   ENDI                                          // entao prossegue,
   ALERTA(3)                                     // caso contrario, vamos avisar
   DBOX("EXPRESSŽO ILEGAL",15)                   // que a expressao nao atende
  ENDD
 ELSE                                            // teclou ESC, entao vamos
  msg ="Prosseguir convers„o|"+;                 // perguntar se o usuario
       "Refazer conte£do dos campos|"+;          // quer continuar com a
       "Cancelar a opera‡„o"                     // adaptacao do DBF...
  msgt="ARQUIVO "+sistema[op_sis,O_ARQUI,O_NOME]
  cod_sos=3
  op_=DBOX(msg,12,45,E_MENU,,msgt)               // apresenta menu
  IF op_=1                                       // quer continuar...
   msg='Atualizando o arquivo "'+;
       sistema[op_sis,O_ARQUI,O_NOME]+'"'        // avisa que estamos
   DBOX(msg,,,,NAO_APAGA,"AGUARDE!")             // trabalhando...
   CLOSE ALL                                     // fecha todos os arquivos abertos
   drv_dbf=sistema[op_sis,O_ARQUI,O_DIR_DBF]
   dbf=drv_dbf+sistema[op_sis,O_ARQUI,O_NOME]+".dbf" // nome do arquivo para adaptar
   IF FILE(drv_dbf+"temp9.dbf") // se o backup existir
    ERASE &drv_dbf.temp9.dbf                     // vamos elimina-lo
   ENDI
   RENAME (dbf) TO &drv_dbf.temp9.dbf            // troca o nome do DBF para temp9
   dbt=drv_dbf+sistema[op_sis,O_ARQUI,O_NOME]+EXTENSAO(.f.) // nome do arq memo p/ adaptar
   IF FILE(dbt)                                   // se dbf tem memo e
    dbtt=drv_dbf+"temp9"+EXTENSAO(.f.)
    IF FILE(dbtt)                                 // se o backup existir
     ERASE (dbtt)                                 // vamos elimina-lo
    ENDI
    RENAME (dbt) TO (dbtt)                        // troca o nome do DBT para temp9
   ENDI
   stru=LEFT(sistema[op_sis,O_ARQUI,O_NOME],3)+"_estr" // nome do prg da nova estrutura
   &stru.()                                      // cria nova estrutura
   SELE A
   USE (dbf) ALIAS ATUAL                         // abre o novo DBF
   SELE B
   USE &drv_dbf.temp9 ALIAS VELHO                // abre o dbf antigo
   DO WHILE !EOF()                               // processaremos todos os registros...
    SELE ATUAL
    APPEND BLANK                                 // cria um novo registro
    FOR i=1 TO qtcps                             // coloca em cada campo
     msg=estru_nov[i,1]                          // do novo registro, o conteudo
     IF !EMPTY(cps_[i])                          // escolhido do DBF anterior
      REPL &msg. WITH VELHO->(&(cps_[i]))
     ENDI
    NEXT
    IF VELHO->(DELE())                           // se o reg esta macado para
     DELE                                        // exclusao vamos marcar no
    ENDI                                         // novo tambem
    SELE VELHO                                   // proximo...
    SKIP
   ENDD
   op_a=0
  ELSEIF op_=2 .OR. op_=0                        // quer redigitar os conteudos
   op_a=1
  ELSE                                           // cancelou a operacao
   RETU .f.
  ENDI
 ENDI
ENDD
RESTSCREEN(0,0,MAXROW(),79,v1)                   // coloca cabecalho e pano de fundo
DBOX(msg_veri,,,,NAO_APAGA,"AGUARDE!")           // avisa que estamos trabalhando...
CLOSE ALL                                        // fecha todos os arquivos e
RETU .t.                                         // prossegue conversao de outros arquivos

FUNC TRATADIR(drv_)                              // trata diretorio informado
drv_=ALLTRIM(drv_)                               // tira espacos
drv_=IF(RIGHT(drv_,1)!="\".AND.;                 // diretorio tem que
       LEN(drv_)>0,drv_+"\",drv_)                // terminar com barra (\)
RETU drv_

FUNC DRVEXISTE(drv_)                             // testa se diretorio existe
LOCAL drv_atual:="\"+CURDIR(),x
drv_=ALLTRIM(drv_)                               // tira espacos
drv_=IF(RIGHT(drv_,1)!="\".AND.;
     LEN(drv_)>0,drv_+"\",drv_)                  // terminar com barra (\)
drv_=LEFT(drv_,LEN(drv_)-1)
IF !CHDIR(drv_) .AND. LEN(drv_)>2                // se diretorio nao existe,
 ALERTA(2)                                       // beep, beep e
 op_=DBOX("Diret¢rio ilegal!",,,,,"ATEN€ŽO!")    // avisa
 RETU .f.
ELSE                                             // ok, diretorio existe,
 CHDIR(drv_atual)                                // posiciona no diretorio anterior
ENDI
RETU .t.

PROC VE_CAMPOS                                   // mostra os campos da
LOCAL ve_op:=""                                  // estrutura anterior e
FOR i=1 TO LEN(estru_vel)                        // permite a captura do
 ve_op+="|"+PADR(estru_vel[i,1],12)+;            // nome do campo para
        " "+estru_vel[i,2]+;                     // dentro da expressao
        LPAD(STR(estru_vel[i,3]),4)+;            // que esta sendo informada
        LPAD(STR(estru_vel[i,4]),3)
NEXT
op_campo=DBOX(SUBS(ve_op,2),,50,E_MENU,,"CAMPOS DA ESTRUTURA|ANTERIOR|Nome         T Tam CD")
IF op_campo>0
 KEYB ALLTRIM(estru_vel[op_campo,1])
ENDI
RETU

PROC HELP                                        // ajuda (F1)
LOCAL tela_, cor_, t, estr_db, tec_f10, txt:=ARRAY(6)
SETKEY(K_F1,NIL)                                 // evita recursividade
tec_f10=SETKEY(K_F10,NIL)                        // desabilita tecla F10
tela_=SAVESCREEN(0,0,MAXROW(),79)                // salva a tela por baixo e
cor_=SETCOLOR(drvcorenf)                         // o esquema de cor vigente
DO CASE
 CASE cod_sos=1
  txt={;
        "A coluna ESTRUTURA deste menu mostra os campos atuais do",;
        "arquivo de  dados que necessitam ser adaptados. Na colu-",;
        "na PREENCHER COM: aparecem as sugest”es para serem colo-",;
        "cadas dentro de cada campo.     Caso queira mudar alguma",;
        "sugest„o  pressione ENTER  sobre o campo  desejado  caso",;
        "contrario, tecle ESC para prosseguir a opera‡„o.        ";
      }
 CASE cod_sos=2
  txt={;
        "     Informe um novo conte£do para colocar no campo,  em",;
        "todos os registros do arquivo.  Pode ser utilizada qual-",;
        "quer express„o em CA-Clipper, nomes de campos, etc, des-",;
        "de que tenham o mesmo tipo do campo a modificar. A tecla",;
        "F10 pode ser utilizada para capturar conte£dos de campos",;
        "da estrutura anterior deste arquivo DBF.";
      }
 CASE cod_sos=3
  txt={;
        "     Selecione a op‡„o PROSSEGUIR para iniciar o proces-",;
        "so de convers„o do arquivo  em  destaque no t¡tulo  dete",;
        "menu (todos os registros do arquivo ser„o atingidos). Se",;
        "desejar corrigir mais alguma informa‡„o, selecione REFA-",;
        "ZER CONTEUDO ou tecle ESC.   A op‡„o CANCELAR A OPERA€ŽO",;
        "serve para retornar ao DOS.";
      }
 CASE cod_sos=4
  txt={;
        "     Informe os diret¢rios onde residem os diversos  ar-",;
        "quivos (DBF, NTX e senhas) da aplica‡„o que ir  sofrer a",;
        "adapta‡„o.    Os nomes dos diret¢rios informados dever„o",;
        "terminar com o caracter '\'.   Informados os diret¢rios,",;
        "selecione a op‡„o 'Prosseguir` para  este programa  ini-",;
        "ciar as adapta‡”es necess rias.";
      }
ENDC
SETCOLOR("GR+"+SUBS(drvcorenf,AT("/",drvcorenf)))// prepara esquema de cor
CAIXA(mold,2,10,9,69)                            // monta janela
@ 9,37 SAY " ESC "                               // mostra tecla de finalizacao
SETCOLOR(drvcorenf)
FOR t=1 TO 6                                     // apresenta msg na janela
 @ 2+t,12 SAY txt[t]
NEXT
INKEY(0)                                         // espera uma tecla
SETCOLOR(cor_)                                   // retorna a cor original
RESTSCREEN(0,0,MAXROW(),79,tela_)
SETKEY(K_F10,tec_f10)                            // habilita tecla F10
SET KEY K_F1 TO help                             // reprograma o help
RETU

PROC CAPTURADIR()  // captura diretorio da lista
LSTARQDIR(.f.)
RETU

PROC ESCOLHIDOUM()
_Escolheu=.t.
KEYB CHR(K_ENTER)
RETU

PROC LSTARQDIR(_comarq)
LOCAL t, op_a, dir_arq:={}, dir_, qt_dir, dir_base, v_ar:=READVAR(),;
      t_f10:=SETKEY(K_F10,NIL), msgt:=""
PRIVATE _Escolheu
IF !EMPTY(v_ar)
 dir_base=ALLTRIM(&v_ar.)
ENDI
IF EMPTY(dir_base)
 dir_base=drvdbf
ENDI
IF !DRVEXISTE(dir_base)
 dir_base=drvdbf
 IF !DRVEXISTE(dir_base)
  dir_base=QUALDIR()
 ENDI
ENDI
IF RIGHT(dir_base,1)<>"\"
 dir_base=dir_base+"\"
ENDI
DO WHILE .t.
 _Escolheu=.f.
 IF _comarq
  dir_arq=DIRECTORY(dir_base+mask_)
  msgt=mask_
 ELSE
  dir_arq:={}
  msgt="|F10=Escolhe"
 ENDI
 dir_=DIRECTORY(dir_base+"*.*","D")
 qt_dir=1
 FOR t=1 TO LEN(dir_)
  IF dir_[t,5]="D" .AND. "."!=dir_[t,1]
   AADD(dir_arq,{})
   AINS(dir_arq,qt_dir)
   ACOPY(dir_,dir_arq,t,1,qt_dir)
   qt_dir++
  ENDI
 NEXT
 FOR t=1 TO LEN(dir_arq)
  IF AT("~",dir_arq[t,1])>0
   dir_arq[t,1]=STRTRAN(dir_arq[t,1],"~","ô")
  ENDI
 NEXT
 IF _comarq=.f.
  SET KEY K_F10 TO ESCOLHIDOUM()
 ENDI
 op_a=DBOX(dir_arq,,,.T.,,dir_base+msgt)
 IF op_a=0
  EXIT
 ENDI
 IF AT("ô",dir_arq[op_a,1])>0
  dir_arq[op_a,1]=STRTRAN(dir_arq[op_a,1],"ô","~")
 ENDI
 IF dir_arq[op_a,5]="D" .AND. _escolheu=.f.
  IF dir_arq[op_a,1]=".."
   dir_base=LEFT(dir_base,LEN(dir_base)-1)
   dir_base=LEFT(dir_base,RAT("\",dir_base))
  ELSE
   dir_base=dir_base+dir_arq[op_a,1]+"\"
  ENDI
 ELSE
  KEYB CHR(K_HOME)+CHR(K_CTRL_Y)+dir_base+IIF(dir_arq[op_a,1]="..","",dir_arq[op_a,1])
  EXIT
 ENDI
ENDD
SETKEY(K_F10,t_f10)
RETU

* \\ Final de ADR_ADAP.PRG
procedure acins03
#ifdef CDX
  #include "SIXCDX.CH"
  #define RDDNAME "SIXCDX"
  #define MEMOEXT ".FPT"
#else
  #include "SIXNSX.CH"
  #define RDDNAME "SIXNSX"
  #define MEMOEXT ".SMT"
#endif


para rfil
set cent on
set date brit

if !file("d:grupos.dbf")
 use grupos
 copy next 1 to d:grupos
 use d:grupos
 zap
endi
use grupos
if val(codigo)>0
 repl codigo with rfil+codigo all
else
 repl codigo with rfil+substr(codigo,3) all
endi
use d:grupos
appe from c:grupos


if !file("d:inscrits.dbf")
 use inscrits
 copy next 1 to d:inscrits
 use d:inscrits
 zap
endi
use inscrits
if val(codigo)>0
 repl codigo with rfil+left(codigo,6)+grau+str(seq,2) all
else
 repl codigo with rfil+substr(codigo,3,6)+grau+str(seq,2) all
endi
use d:inscrits
appe from c:inscrits


if !file("d:taxas.dbf")
 use taxas
 copy next 1 to d:taxas
 use d:taxas
 zap
endi
use taxas
if val(codigo)>0
 repl codigo with rfil+left(codigo,6)+[  ]+tipo+circ all
else
 repl codigo with rfil+substr(codigo,3) all
endi
use d:taxas
appe from taxas



procedure v02002f9
/*
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
 \ Empresa.: PresServ Inform tica-Limeira (019)452.6623
 \ Programa: V02002F9.PRG
 \ Data....: 26-05-97
 \ Sistema.: Administradora - RECEP€„O
 \ Funcao..: Valida‡„o da variavel CONFIRME, relatorio ADM_R020
 \ Analista: Ademilson Pedro Bom
 \ Criacao.: Programado manualmente pelo analista
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/

#include "adrbig.ch"    // inicializa constantes manifestas

  IF !PTAB(PADR(SUBSTR(M->ide_maq,2),4)+[AFU],[IMPPAR],1)
   ord_=LEN(sistema[EVAL(qualsis,"IMPPAR"),O_CHAVE])
   FAZ_LANC("IMPPAR",[ ])
   REPL IMPPAR->idmaq WITH PADR(SUBSTR(M->ide_maq,2),4),;
   IMPPAR->base WITH [AFU]
  ENDI
   #ifdef COM_REDE
    IMPPAR->(DBUNLOCK())                           // libera o registro
   #endi

   IF PTAB(PADR(SUBSTR(M->ide_maq,2),4)+[AFU],[IMPPAR],1)
    REPBLO('IMPPAR->docto',{||AFUNER->processo+AFUNER->proc2+AFUNER->filial+AFUNER->categ})
   ENDI

RETU .t.       // <- deve retornar um valor L¢GICO

* \\ Final de V02002F9.PRG
.PRG.OBJ:
     CLIPPER $** /m
ADRBIG.OBJ   : ADRBIG.PRG
BXR_07F9.OBJ : BXR_07F9.PRG
BXR_06F9.OBJ : BXR_06F9.PRG
BXR_02F9.OBJ : BXR_02F9.PRG
BXR_01F9.OBJ : BXR_01F9.PRG
BXREC.OBJ    : BXREC.PRG
ALE_01F9.OBJ : ALE_01F9.PRG
ALENDER.OBJ  : ALENDER.PRG
OBX_07F9.OBJ : OBX_07F9.PRG
OBX_01F9.OBJ : OBX_01F9.PRG
OBXEC.OBJ    : OBXEC.PRG
GRU_01F9.OBJ : GRU_01F9.PRG
GRU_02F9.OBJ : GRU_02F9.PRG
GRUPOS.OBJ   : GRUPOS.PRG
CTAINSC.OBJ  : CTAINSC.PRG
CTXAS.OBJ    : CTXAS.PRG
TAX_02F9.OBJ : TAX_02F9.PRG
INS_01F9.OBJ : INS_01F9.PRG
INS_02F9.OBJ : INS_02F9.PRG
GUI_07F9.OBJ : GUI_07F9.PRG
GUI_06F9.OBJ : GUI_06F9.PRG
GUI_08F9.OBJ : GUI_08F9.PRG
GUI_02F9.OBJ : GUI_02F9.PRG
GUIAS.OBJ    : GUIAS.PRG
MFILIAL.OBJ  : MFILIAL.PRG
ADP_R101.OBJ : ADP_R101.PRG
ADC_RX76.OBJ : ADC_RX76.PRG
CAD_04F9.OBJ : CAD_04F9.PRG
KINSCF9.OBJ  : KINSCF9.PRG
AFUNER.OBJ   : AFUNER.PRG
R02001F9.OBJ : R02001F9.PRG
R02002F9.OBJ : R02002F9.PRG
ADM_R020.OBJ : ADM_R020.PRG
V02001F9.OBJ : V02001F9.PRG
V02002F9.OBJ : V02002F9.PRG
R02901F9.OBJ : R02901F9.PRG
ADR_R029.OBJ : ADR_R029.PRG
RX2001F9.OBJ : RX2001F9.PRG
RX2002F9.OBJ : RX2002F9.PRG
ADM_RX20.OBJ : ADM_RX20.PRG
RX2901F9.OBJ : RX2901F9.PRG
ADR_RX29.OBJ : ADR_RX29.PRG
ADM_R029.OBJ : ADM_R029.PRG
ADM_R026.OBJ : ADM_R026.PRG
ADM_R021.OBJ : ADM_R021.PRG
DCI_P001.OBJ : DCI_P001.PRG
DCI01F9.OBJ  : DCI01F9.PRG
DCI03F9.OBJ  : DCI03F9.PRG
DCI04F9.OBJ  : DCI04F9.PRG
ADM_RS18.OBJ : ADM_RS18.PRG
V01801F9.OBJ : V01801F9.PRG
ADM_R023.OBJ : ADM_R023.PRG
V02301F9.OBJ : V02301F9.PRG
ADM_R022.OBJ : ADM_R022.PRG
R03001F9.OBJ : R03001F9.PRG
ADM_R039.OBJ : ADM_R039.PRG
IMP_01F9.OBJ : IMP_01F9.PRG
IMPPAR.OBJ   : IMPPAR.PRG
MEDICOS.OBJ  : MEDICOS.PRG
TESPEC.OBJ   : TESPEC.PRG
JUROS.OBJ    : JUROS.PRG
TFILIAIS.OBJ : TFILIAIS.PRG
ARQGRUP.OBJ  : ARQGRUP.PRG
REGIAO.OBJ   : REGIAO.PRG
COB_01F9.OBJ : COB_01F9.PRG
COBRADOR.OBJ : COBRADOR.PRG
CLASSES.OBJ  : CLASSES.PRG
CIRCULAR.OBJ : CIRCULAR.PRG
PRCESSOS.OBJ : PRCESSOS.PRG
FNCS.OBJ     : FNCS.PRG
HISTORIC.OBJ : HISTORIC.PRG
CSTSEG.OBJ   : CSTSEG.PRG
MEN_01F9.OBJ : MEN_01F9.PRG
MENSAG.OBJ   : MENSAG.PRG
ORDPGRC.OBJ  : ORDPGRC.PRG
PAR_ADM.OBJ  : PAR_ADM.PRG
ADR_ESTR.OBJ : ADR_ESTR.PRG
ADR_ATRI.OBJ : ADR_ATRI.PRG
ADR_ATR1.OBJ : ADR_ATR1.PRG
ADR_ATR2.OBJ : ADR_ATR2.PRG
ADR_MENU.OBJ : ADR_MENU.PRG
ADR_MANU.OBJ : ADR_MANU.PRG
CON_RX01.OBJ : CON_RX01.PRG
ABOUT.OBJ    : ABOUT.PRG
ADR_PROC.OBJ : ADR_PROC.PRG
ADR_FUNC.OBJ : ADR_FUNC.PRG
ADR_FUN2.OBJ : ADR_FUN2.PRG
ADR_OUTR.OBJ : ADR_OUTR.PRG
ADRBIG.EXE:
	 bLINKer @ADRBIG.LNK
/*
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
 \ Empresa.: Ind£stria de Urnas Bignotto Ltda
 \ Programa: ADP_R044.PRG
 \ Data....: 19-01-97
 \ Sistema.: Administradora - PLANO
 \ Funcao..: Impress„o VIP
 \ Analista: Ademilson Pedro Bom
 \ Criacao.: GAS-Pro v3.0 
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/

#include "adpbig.ch"    // inicializa constantes manifestas

LOCAL dele_atu, getlist:={}
PARA  lin_menu, col_menu
PRIV  tem_borda:=.t., op_menu:=VAR_COMPL, l_s:=11, c_s:=20, l_i:=16, c_i:=61, tela_fundo:=SAVESCREEN(0,0,MAXROW(),79)
nucop=1
SETCOLOR(drvtittel)
vr_memo=NOVAPOSI(@l_s,@c_s,@l_i,@c_i)     // pega posicao atual da tela
CAIXA(mold,l_s,c_s,l_i,c_i)               // monta caixa da tela
@ l_s,c_s+9 SAY " GRUPOS C/TAXAS A EMITIR "
SETCOLOR(drvcortel)
@ l_s+01,c_s+1 SAY " Emiss„o:"
@ l_s+02,c_s+1 SAY " Grupo..:      De:       -"
@ l_s+03,c_s+1 SAY " £ltima Circular.:"
@ l_s+04,c_s+1 SAY " Pr¢xima Circular:        Confirme:"
remissao_=CTOD('')                                 // Emiss„o
rgrupo=SPAC(2)                                     // Grupo
rproxcirc=SPAC(3)                                  // N§Proxima Circ.
confirme=SPAC(1)                                   // Confirme
DO WHILE .t.
 rola_t=.f.
 cod_sos=56
 SET KEY K_ALT_F8 TO ROLATELA
 SETCOLOR(drvcortel+","+drvcorget+",,,"+corcampo)
 @ l_s+01 ,c_s+11 GET  remissao_;
                  PICT "@D";
                  VALI CRIT("!EMPT(Remissao_)~Informe uma data v lida p/ EMISSŽO | data de hoje ou posterior.")
                  DEFAULT "CTOD('05'+SUBSTR(DTOC(DATE()+30),3))"
                  AJUDA "Data da Emiss„o da Circular.| Para atualizar circulares se n„o preenchidas| com antecedˆncia."

 @ l_s+02 ,c_s+11 GET  rgrupo;
                  PICT "!9";
		  VALI CRIT("PTAB(rgrupo,'ARQGRUP',1)~GRUPO n„o existe na tabela")
                  DEFAULT "M->mgrupvip"
                  AJUDA "Entre com o grupo ou |tecle F8 para consulta em tabela"
                  CMDF8 "VDBF(6,33,20,77,'ARQGRUP',{'grup','inicio','final','ultcirc','emissao_','procpend'},1,'grup',[])"
                  MOSTRA {"LEFT(TRAN(ARQGRUP->inicio,[999999]),06)", 2 , 20 }
                  MOSTRA {"LEFT(TRAN(ARQGRUP->final,[999999]),06)", 2 , 27 }
                  MOSTRA {"LEFT(TRAN(ARQGRUP->ultcirc,[999]),03)", 3 , 20 }
                  MOSTRA {"LEFT(TRAN(ARQGRUP->emissao_,[@D]),08)", 3 , 24 }

 @ l_s+04 ,c_s+20 GET  rproxcirc;
                  PICT "999";
                  VALI CRIT("rproxcirc>=ARQGRUP->ultcirc~A Pr¢xima circular deve ser maior|ou igual a £ltima emitida")
                  AJUDA "Entre com o n£mero da pr¢xima circular"
                  CMDF8 "STRZERO(VAL(ARQGRUP->ultcirc)+1,3)"

 @ l_s+04 ,c_s+37 GET  confirme;
                  PICT "!";
                  VALI CRIT("confirme='S'.AND.V03001F9()~CONFIRME n„o aceit vel")
                  AJUDA "Digite S para confirmar|ou|tecle ESC para cancelar"

 READ
 SET KEY K_ALT_F8 TO
 IF rola_t
  ROLATELA(.f.)
  LOOP
 ENDI
 IF LASTKEY()=K_ESC                                // se quer cancelar
  RETU                                             // retorna
 ENDI

 #ifdef COM_REDE
  IF !USEARQ("TAXAS",.t.,10,1)                     // se falhou a abertura do arq
   RETU                                            // volta ao menu anterior
  ENDI
 #else
  USEARQ("TAXAS")                                  // abre o dbf e seus indices
 #endi

 PTAB(M->mgrupvip,'ARQGRUP',1)
 PTAB(codigo,"GRUPOS",1,.t.)                       // abre arquivo p/ o relacionamento
 PTAB(GRUPOS->tipcont,"CLASSES",1,.t.)
 PTAB(cobrador,"COBRADOR",1,.t.)
 PTAB(M->mgrupvip+ARQGRUP->proxcirc,"CIRCULAR",1,.t.)
 PTAB(codigo+circ,"MENSAG",1,.t.)
 PTAB(codigo+[3]+circ,"CSTSEG",3,.t.)
 SET RELA TO codigo INTO GRUPOS,;                  // relacionamento dos arquivos
	  TO GRUPOS->tipcont INTO CLASSES,;
	  TO cobrador INTO COBRADOR,;
	  TO M->mgrupvip+ARQGRUP->proxcirc INTO CIRCULAR,;
	  TO codigo+circ INTO MENSAG,;
	  TO codigo+tipo+circ INTO CSTSEG
 titrel:=criterio:=cpord := ""                     // inicializa variaveis
 titrel:=chv_rela:=chv_1:=chv_2 := ""
 tps:=op_x:=ccop := 1
 IF !opcoes_rel(lin_menu,col_menu,31,11)           // nao quis configurar...
  CLOS ALL                                         // fecha arquivos e
  LOOP                                             // volta ao menu
 ENDI
 IF tps=2                                          // se vai para arquivo/video
  arq_=ARQGER()                                    // entao pega nome do arquivo
  IF EMPTY(arq_)                                   // se cancelou ou nao informou
   LOOP                                            // retorna
  ENDI
 ELSE
  arq_=drvporta                                    // porta de saida configurada
 ENDI
 SET PRINTER TO (arq_)                             // redireciona saida
 EXIT
ENDD
IF !EMPTY(drvtapg)                                 // existe configuracao de tam pag?
 op_=AT("NNN",drvtapg)                             // se o codigo que altera
 IF op_=0                                          // o tamanho da pagina
  msg="Configura‡„o do tamanho da p gina!"         // foi informado errado
  DBOX(msg,,,,,"ERRO!")                            // avisa
  CLOSE ALL                                        // fecha todos arquivos abertos
  RETU                                             // e cai fora...
 ENDI                                              // codigo para setar/resetar tam pag
 lpp_026=LEFT(drvtapg,op_-1)+"026"+SUBS(drvtapg,op_+3)
 lpp_066=LEFT(drvtapg,op_-1)+"066"+SUBS(drvtapg,op_+3)
ELSE
 lpp_026:=lpp_066 :=""                             // nao ira mudara o tamanho da pag
ENDI
DBOX("[ESC] Interrompe",15,,,NAO_APAGA)
dele_atu:=SET(_SET_DELETED,.t.)                    // os excluidos nao servem...
SET DEVI TO PRIN                                   // inicia a impressao
maxli=24                                           // maximo de linhas no relatorio
IMPCTL(lpp_026)                                    // seta pagina com 26 linhas
SET MARG TO 1                                      // ajusta a margem esquerda
IF tps=2
 IMPCTL("' '+CHR(8)")
ENDI
BEGIN SEQUENCE
 DO WHIL ccop<=nucop                               // imprime qde copias pedida
  pg_=1; cl=999
  INI_ARQ()                                        // acha 1o. reg valido do arquivo
  ccop++                                           // incrementa contador de copias
  DO WHIL !EOF()
   #ifdef COM_TUTOR
    IF IN_KEY()=K_ESC                              // se quer cancelar
   #else
    IF INKEY()=K_ESC                               // se quer cancelar
   #endi
    IF canc()                                      // pede confirmacao
     BREAK                                         // confirmou...
    ENDI
   ENDI
   IF emissao_=CIRCULAR->emissao_.AND.CLASSES->prior=[S].AND.valorpg=0.AND.!(tipo$'16')// se atender a condicao...
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,015 SAY "Manut.:"
//    valororig=IIF(!CSTSEG->(EOF()),CSTSEG->vlorig,valor)// variavel temporaria
    valororig=IIF(PTAB(codigo+[3]+circ,'CSTSEG',3),CSTSEG->vlorig,valor)// variavel temporaria

    @ cl,023 SAY TRAN(valororig,"@E 999,999.99")   // Valor Contribuicao
    @ cl,062 SAY "Manut.:"
    @ cl,069 SAY TRAN(valororig,"@E 999,999.99")   // Valor Contribuicao
//    @ cl,069 SAY TRAN(IIF(!CSTSEG->(EOF()),CSTSEG->vlorig,valor),"@E 999,999.99")// Valor Contribuicao 2
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,015 SAY "Seguro:"
    @ cl,023 SAY TRAN(valor-valororig,"@E 999,999.99")// Valor Seguro
    @ cl,062 SAY "Seguro:"
    @ cl,069 SAY TRAN(valor-valororig,"@E 999,999.99")// Valor Seguro 2
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,015 SAY "TOTAL.:"
    @ cl,023 SAY TRAN(valor,"@E 999,999.99")       // Valor Total
    @ cl,062 SAY "TOTAL.:"
    @ cl,069 SAY TRAN(valor,"@E 999,999.99")       // Valor Total 2
    REL_CAB(3)                                     // soma cl/imprime cabecalho
    IMPEXP(cl,000,GRUPOS->codigo,12)               // Codigo
    IMPCTL(drvpenf)
    @ cl,024 SAY [/]+tipo+[/]+circ+[ ]             // compl.codigo 2
    IMPCTL(drvtenf)
    IMPEXP(cl,039,GRUPOS->codigo,12)               // Codigo 2
    IMPCTL(drvpenf)
    @ cl,062 SAY [/]+tipo+[/]+circ+[ ]             // compl.codigo 1
    IMPCTL(drvtenf)
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY "Emiss:"
    @ cl,007 SAY TRAN(emissao_,"@D")               // Emissao
    @ cl,020 SAY "Admiss:"
    @ cl,027 SAY TRAN(GRUPOS->admissao,"@D")       // Admiss„o
    @ cl,039 SAY "Emiss:"
    @ cl,046 SAY TRAN(emissao_,"@D")               // Emissao 2
    @ cl,059 SAY "Admiss:"
    @ cl,066 SAY TRAN(GRUPOS->admissao,"@D")       // Admiss„o 2
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY "Cobrador..:"
    @ cl,011 SAY COBRADOR->cobrador+[ ]+LEFT(COBRADOR->nome,15)// Cobrador
    @ cl,039 SAY "Cobrador..:"
    @ cl,050 SAY COBRADOR->cobrador+[ ]+LEFT(COBRADOR->nome,15)// Cobrador 2
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY ALLTRIM(CLASSES->descricao)+[ ]+IIF(GRUPOS->formapgto<[05],SUBSTR(tbfpgto,(VAL(GRUPOS->formapgto)-1)*13+1,13),GRUPOS->formapgto)// definicao 1
    @ cl,039 SAY ALLTRIM(CLASSES->descricao)+[ ]+IIF(GRUPOS->formapgto<[05],SUBSTR(tbfpgto,(VAL(GRUPOS->formapgto)-1)*13+1,13),GRUPOS->formapgto)// definicao 2
    REL_CAB(2)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY GRUPOS->nome                      // Nome
    @ cl,039 SAY GRUPOS->nome                      // Nome 2
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY GRUPOS->endereco                  // Endere‡o
    @ cl,039 SAY GRUPOS->endereco                  // Endere‡o 2
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY GRUPOS->bairro                    // Bairro
    @ cl,039 SAY GRUPOS->bairro                    // Bairro 2
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY GRUPOS->cep+[ ]+ALLTRIM(GRUPOS->cidade)+[, ]+GRUPOS->uf// Cidade
    @ cl,039 SAY GRUPOS->cep+[ ]+ALLTRIM(GRUPOS->cidade)+[, ]+GRUPOS->uf// Cidade 2
    REL_CAB(2)                                     // soma cl/imprime cabecalho
    IMPCTL(drvpcom)
    @ cl,039 SAY MENSAG->mens1          // Mens1
    IMPCTL(drvtcom)
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    IMPCTL(drvpcom)
    @ cl,039 SAY MENSAG->mens2      // Mens2
    IMPCTL(drvtcom)
    IF M->combarra=[S]
     CODBARRAS({{codigo+tipo+circ,4,10,19}},10,6)
    ENDI
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    IMPCTL(drvpcom)
    @ cl,039 SAY IIF(EMPT(MENSAG->mens3),CIRCULAR->menscirc,MENSAG->mens3)// Mens 3
    IMPCTL(drvtcom)
    IF M->combarra=[S]
     CODBARRAS({{codigo+tipo+circ,4,10,19}},10,6)
    ENDI
    SKIP                                           // pega proximo registro
    cl=999                                         // forca salto de pagina
   ELSE                                            // se nao atende condicao
    SKIP                                           // pega proximo registro
   ENDI
  ENDD
 ENDD ccop
 EJEC                                              // salta pagina
END SEQUENCE
SET MARG TO                                        // coloca margem esquerda = 0
IMPCTL(lpp_066)                                    // seta pagina com 66 linhas
SET PRINTER TO (drvporta)                          // fecha arquivo gerado (se houver)
SET DEVI TO SCRE                                   // direciona saida p/ video
IF tps=2                                           // se vai para arquivo/video
 BROWSE_REL(arq_,2,3,MAXROW()-2,78)
ENDI                                               // mostra o arquivo gravado
GRELA(31)                                          // grava variacao do relatorio
msgt="PROCESSAMENTOS DO RELAT¢RIO|IMPRESSŽO VIP"
ALERTA()
op_=DBOX("Prosseguir|Cancelar opera‡„o",,,E_MENU,,msgt)
IF op_=1
 DBOX("Processando registros|<      %>",,,,NAO_APAGA,"AGUARDE!")
 dele_atu:=SET(_SET_DELETED,.t.)                   // os excluidos nao servem...
 SELE TAXAS                                        // processamentos apos emissao
 gauge(0)
 INI_ARQ()                                         // acha 1o. reg valido do arquivo
 DO WHIL !EOF()
  gauge(1)
  IF emissao_=CIRCULAR->emissao_.AND.CLASSES->prior=[S].AND.valorpg=0.AND.!(tipo$'16')// se atender a condicao...

/*
   #ifdef COM_REDE
    IF stat < [2]
     REPBLO('TAXAS->stat',{||[2]})
    ENDI
   #else
*/
    IF stat < [2]
     REPL TAXAS->stat WITH [2]
    ENDI

//   #endi

   SKIP                                            // pega proximo registro
  ELSE                                             // se nao atende condicao
   SKIP                                            // pega proximo registro
  ENDI
 ENDD
 ALERTA(2)
 DBOX("Processo terminado com sucesso!",,,,,msgt)
ENDI
SELE TAXAS                                         // salta pagina
SET RELA TO                                        // retira os relacionamentos
SET(_SET_DELETED,dele_atu)                         // os excluidos serao vistos
RETU

STATIC PROC REL_CAB(qt)                            // cabecalho do relatorio
IF qt>0                                            // se parametro maior que 0
 cl=cl+qt                                          // soma no contador de linhas
ENDI
IF cl>maxli .OR. qt=0                              // quebra de pagina
 cl=qt+1 ; pg_++
ENDI
RETU

* \\ Final de ADP_R044.PRG
GAS-Pro v4.0
002011024076001001001001003001176001
 N£mero:            Emiss„o:
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 N§ Contrato:
 Admiss„o...:
 Sai Taxas..:                                       Cobr:





ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 Pessoa a Atend:

 M‚dico...:
[Ÿ]
Inclus„o~~26006
Manuten‡„o~~27007
Consulta~~28008
[Ÿ]
 10 
 2 
p/N£mero

 1 
[Ÿ]
p/N§Transf.

 1 
[Ÿ]
Emiss„o de Guias
Emiss„o de Guias







005




































 0 
 1 
-1 
-1 
 0 
-1 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
numero
C
V
99999999
 8 
 8 
 1 
 10 
 0 
N£mero



RIGHT(DTOC(DATE()),2)+[000001]


 0 
 1 


data
D
I
@D
 8 
 10 
 1 
 30 
 0 
Emiss„o






 0 
 0 


hora
C
I
99:99
 5 
 5 
 0 
 0 
 0 
Hora






 0 
 0 


filial
C
I
 
 2 
 2 
 0 
 0 
 0 
Filial






 0 
 0 


login
C
I
 
 10 
 10 
 0 
 0 
 0 
Login






 0 
 0 


contrato
C
E
@!
 9 
 9 
 3 
 15 
 0 
N§ Contrato

GUI_07F9().AND.CAD_04F9(op_menu).AND.((PTAB(contrato,'INSCRITS',1).and.PTAB(contrato,'TAXAS',1)).OR.1=1)
N£mero do contrato inv lido,|ou |Titular n„o cadastrado|Tecle F8 para consulta.

Entre com o c¢digo do contrato
VDBF(6,3,20,77,'GRUPOS',{'grupo','codigo','nome','endereco'},1,'codigo')
 0 
 0 


nome
C
E
@!
 35 
 35 
 12 
 18 
 0 
Nome

!EMPT(nome).AND.(PTAB([],'MEDICOS',1).OR.1=1) // Associa Medicos(doc)
Informar NOME
GRUPOS->nome
Informe o nome do benefici rio.
GUI_06F9()
 0 
 0 


inscrito
C
I
@!
 18 
 18 
 0 
 0 
 0 
Inscrito






 0 
 0 


medico
C
E
@!
 10 
 10 
 14 
 13 
 0 
M‚dico

PTAB(medico,'MEDICOS',1).OR.GUI_08F9()
MDICO n„o existe na tabela

Informe o m‚dico
VDBF(6,3,20,77,'MEDICOS',{'codbenefic','nome','endereco','cidade','fonecom1','fonecom2'},2,'codbenefic',[])
 0 
 0 


por
C
I
 
 10 
 10 
 0 
 0 
 0 
Por






 0 
 0 


 14 
circ 1-4
GUI_02F9()

 6 
 15 
 45 

Nome do titular
GRUPOS->nome

 3 
 26 
 35 

Admiss„o
GRUPOS->admissao
@D
 4 
 15 
 10 

Saitxa
GRUPOS->saitxa
@R 99/99
 5 
 15 
 5 

Cobrador
GRUPOS->cobrador
!!
 5 
 59 
 2 

Endere‡o contr
GRUPOS->endereco

 4 
 26 
 35 

Bairro contr
GRUPOS->bairro

 5 
 26 
 25 

Endere‡o
IIF(!EMPT(medico).AND.PTAB(medico,'MEDICOS',1),MEDICOS->endereco,SPACE(40))

 15 
 24 
 40 

Munic¡pio
IIF(PTAB(medico,'MEDICOS',1),MEDICOS->cidade,[])

 16 
 32 
 30 

Fone
IIF(!EMPT(medico),MEDICOS->fonecom1,SPACE(14))

 15 
 9 
 14 

Nome m‚dico
IIF(!EMPT(medico),MEDICOS->nome,SPACE(40))

 14 
 24 
 40 

Especialidade
IIF(!EMPT(medico),MEDICOS->oldespec,SPACE(30))

 16 
 2 
 30 

Emiss„o
IIF(EMPT(data),DATE(),data)
@D
 1 
 43 
 10 

Por
IIF(EMPT(por),M->usuario,por)

 1 
 54 
 10 

 1 
IMPPAR
docto
numero

PTAB(PADR(SUBSTR(M->ide_maq,2),4)+[GUI],[IMPPAR],1)


 0 
 1 
IMPPAR
1
 3 
!PTAB(PADR(SUBSTR(M->ide_maq,2),4)+[GUI],[IMPPAR],1)
1=3
 0 



idmaq
C
PADR(SUBSTR(M->ide_maq,2),4)


base
C
[GUI]


docto
C



 0 
         / '    	 pw_grupo+pw_dbf                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            ( W † µ ä Bq Ïþ-\‹ºéGv       ¤•¤–µÛÝØâç…£…¶Õ×ÙÓÖÝÆç…“”…”…“”…”…“”…”…“    BLINKER INCREMENTAL OFF
BLINKER OVERLAY UMB ON
BLINKER OVERLAY PAGEFRAME ON
BLINKER CACHE EMS 50%
BLINKER CACHE XMS 50%
BLINKER OVE OPS 60
BLINKER EXECUTABLE CLIPPER F200
BLINKER MESSAGE NOBLINK


MAP S,A
OUTPUT contab1
STACK 7168


FI contab1
fi dbt
fi sixuk
fi sixcdx
fi sixtools
LIB GASPRO52
fi adr_rx68
LIB HPROT
FI ADR_ESTR
FI ADR_ATRI
FI ADR_ATR1
FI ADR_ATR2
FI ABOUT
FI ADR_PROC
FI ADR_FUNC
FI ADR_OUTR

@CL520MID.LNK
@SIX3.LNK

€ BXREC –S BXRECCODEBXR_INCLCODEBXR_RELCODE
BXR_ANT_SECODE
BXR_CRIA_SCODE
BXR_GERA_SCODE
BXR_GRAVA_CODEBXR_TELACODEBXR_GETSCODEBXR_GET1CODEC_ETEXTENDCODE	_SYMSTARTSYMSTARTSYMBOLSSYMBOLS_SYMENDSYMENDNULLBEGDATA_DATADATA_SYMPBDATA_SYMPDATA_SYMPEDATA_CONSTCONST_MSGMSG_BEGBSSBEGBSS_BSSBSS_ENDBSSENDBSSDGROUPq˜ @IÏ˜ @‚˜ @ÿ ˜ @| 	“˜ @G
Ã˜ @˜ @2 Ñ˜ @oŒ˜ @h˜ @´5˜ H  ë˜ h  Ç˜ `	€
 V02301F9£–Ñ  V02301F9CODEC_ETEXTENDCODE	_SYMSTARTSYMSTARTSYMBOLSSYMBOLS_SYMENDSYMENDNULLBEGDATA_DATADATA_SYMPBDATA_SYMPDATA_SYMPEDATA_CONSTCONST_MSGMSG_BEGBSSBEGBSS_BSSBSS_ENDBSSENDBSSDGROUPb˜ @
˜ H  ˜ h  ë˜ ` 	î˜ h  
ã˜ h  ß˜ H  û˜ H  ÷˜ H ë˜ H  ï˜ H  ë˜ (  ˜ H  GAS-Pro v4.0
009021022062001001001001010000176001
 Especialidades
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
[Ÿ]
Inclus„o~~26006
Manuten‡„o~~27007
Consulta~~28008
[Ÿ]
 1 
 1 
Por Especialidade

 1 
[Ÿ]
Especialidades
Especialidades







005
























 0 











 0 
 1 
-1 
-1 
-1 
-1 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
especialid
C
E
@!
 30 
 30 
 3 
 2 
 0 
Especialidade

!EMPT(especialid)
Necess rio informar ESPECIALIDADE

Informe a|Especialidade/Categoria Profissional.

 0 
 0 


 0 
 0 
 0 
 0 
 0 
procedure tespec
/*
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
 \ Empresa.: PresServ Inform tica - Limeira (019)452.6623
 \ Programa: TESPEC.PRG
 \ Data....: 04-11-03
 \ Sistema.: Administradora - RECEP€„O
 \ Funcao..: Gerenciador do subsistema de especialidades
 \ Analista: Ademilson Pedro Bom
 \ Criacao.: GAS-Pro v4.0n
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/
#include "adrbig.ch"    // inicializa constantes manifestas

PARA lin_menu,col_menu
PRIV op_sis, tela_fundo:=SAVESCREEN(0,0,MAXROW(),79), l_s, c_s, l_i, c_i, l_a

op_sis=EVAL(qualsis,"TESPEC")
IF nivelop<sistema[op_sis,O_OUTROS,O_NIVEL]        // se usuario nao tem permissao,
 ALERTA()                                          // entao, beep, beep, beep
 DBOX(msg_auto,,,3)                                // lamentamos e
 RETU                                              // retornamos ao menu
ENDI
cn:=fgrep :=.f.

#ifdef COM_LOCK
 IF LEN(pr_ok)>0                                   // se a protecao acusou
  ? pr_ok                                          // erro, avisa e
  QUIT                                             // encerra a aplicacao
 ENDI
#endi

t_fundo=SAVESCREEN(0,0,MAXROW(),79)                // salva tela do fundo
op_cad=1
DO WHIL op_cad!=0
 criterio=""
 RESTSCREEN(0,0,MAXROW(),79,t_fundo)               // restaura tela do fundo
 cod_sos=5 ; cn=.f.
 CLEA TYPEAHEAD                                    // limpa o buffer do teclado
 fgrep=.f.
 SET KEY K_F3 TO                                   // retira das teclas F3 e F4 as
 SET KEY K_F4 TO                                   // funcoes de repeticao e confirmacao
 msg="Inclus„o~1|"+;                               // menu do subsistema
     "Manuten‡„o~2|"+;
     "Consulta~3"
 op_cad=DBOX(msg,lin_menu,col_menu,E_MENU,NAO_APAGA,MAIUSC(sistema[op_sis,O_MENU]),,,op_cad)
 IF op_cad!=0                                      // se escolheu uma opcao
  Tela_fundo=SAVESCREEN(0,0,MAXROW(),79)           // salva a tela para ROLATELA()
  PARAMETROS(dbfparam)
  SELE A                                           // e abre o arquivo e seus indices

  #ifdef COM_REDE
   IF !USEARQ(sistema[op_sis,O_ARQUI,O_NOME],.f.,20,1)
                                                   // se falhou a abertura do
    RETU                                           // arquivo volta ao menu anterior
   ENDI
  #else
   USEARQ(sistema[op_sis,O_ARQUI,O_NOME])
  #endi

  SET KEY K_F9 TO veoutros                         // habilita consulta em outros arquivos
 ENDI
 DO CASE
  CASE op_cad=01                                   // inclus„o
   op_menu=INCLUSAO
   IF AT("D",exrot[op_sis])=0                      // se usuario pode fazer inclusao
    TES_INCL()                                     // neste arquivo chama prg de inclusao
   ELSE                                            // caso contrario vamos avisar que
    ALERTA()                                       // ele nao tem permissao para isto
    DBOX(msg_auto,,,3)
   ENDI

  CASE op_cad=02                                   // manuten‡„o
   op_menu=ALTERACAO
   cod_sos=7
   EDIT()

  CASE op_cad=03                                   // consulta
   op_menu=PROJECOES
   cod_sos=8
   EDITA(05,23,MAXROW()-4,57)

 ENDC
 SET KEY K_F9 TO                                   // F9 nao mais consultara outros arquivos
 CLOS ALL                                          // fecha todos arquivos abertos
ENDD
RETU

PROC TES_incl(reg_cop)  // inclusao no arquivo TESPEC
LOCAL getlist:={}, cabem:=1, rep:=ARRAY(FCOU()), ult_reg:=RECN(),;
      ctl_r, ctl_c, t_f3_, t_f4_, l_max, dele_atu:=SET(_SET_DELETED,.f.)
PRIV op_menu:=INCLUSAO, tem_borda, criterio:="", cpord:="", l_a
FOR i=1 TO FCOU()                                  // cria/declara privadas as
 msg=FIEL(i)                                       // variaveis de memoria com
 PRIV &msg.                                        // o mesmo nome dos campos
NEXT                                               // do arquivo
IF reg_cop!=NIL                                    // quer repetir todo o reg atual
 FOR i=1 TO FCOU()                                 // para cada campo,
  msg=FIEL(i)                                      // salva o conteudo
  rep[i]=&msg.                                     // para repetir
 NEXT
ELSE
 AFILL(rep,"")                                     // eche com valor vazio
ENDI
t_f3_=SETKEY(K_F3,{||rep()})                       // repeticao reg anterior
t_f4_=SETKEY(K_F4,{||conf()})                      // confirma campos com ENTER
ctl_w=SETKEY(K_CTRL_W,{||nadafaz()})               // enganando o CA-Clipper...
ctl_c=SETKEY(K_CTRL_C,{||nadafaz()})
ctl_r=SETKEY(K_CTRL_R,{||nadafaz()})
DISPBEGIN()                                        // monta tela na pagina de traz
TES_TELA()                                         // imp tela para inclusao
INFOSIS(.t.)                                       // exibe informacao no rodape' da tela
l_a=Sistema[op_sis,O_TELA,O_SCROLL]
DISPEND()                                          // apresenta tela de uma vez so
DO WHIL cabem>0
 cod_sos=6
 rola_t=.f.                                        // flag se quer rolar a tela
 SELE TESPEC
 GO BOTT                                           // forca o
 SKIP                                              // final do arquivo
 
 /*
    cria variaveis de memoria identicas as de arquivo, para inclusao
    de registros
 */
 FOR i=1 TO FCOU()
  msg=FIEL(i)
  M->&msg.=IF((fgrep .OR. reg_cop!=NIL).AND.!EMPT(rep[1]),rep[i],&msg.)
 NEXT
 cabem=DISKSPACE(;
          IF(;
             LEN(sistema[op_sis,O_ARQUI,O_DIR_DBF])<2.OR.sistema[op_sis,O_ARQUI,O_DIR_DBF]="\",;
             0,;
             ASC(sistema[op_sis,O_ARQUI,O_DIR_DBF])-64;
          );
       )
 cabem=INT((cabem-2048)/TESPEC->(RECSIZE()))
 IF cabem<1                                        // mais nenhum!!!
  ALERTA()
  msg="Verifique ESPA€O EM DISCO, "+usuario
  DBOX(msg,,,,,"INCLUSŽO INTERROMPIDA!")           // vamos parar por aqui!
  EXIT
 ENDI
 SELE 0                                            // torna visiveis variaveis de memoria
 SETCOLOR(drvcortel+","+drvcorget+",,,"+corcampo)
 SET KEY K_ALT_F8 TO ROLATELA
 
 /*
    recebe chaves do arquivo de indice basico
 */
 @ l_s+l_a,c_s+02 GET  especialid;
                  PICT sistema[op_sis,O_CAMPO,01,O_MASC]
                  DEFINICAO 1

 READ
 SET KEY K_ALT_F8 TO
 IF rola_t
  ROLATELA()
  LOOP
 ENDI
 SELE TESPEC
 IF LASTKEY()=K_ESC                                // cancelou ou chave em branco
  cabem=0                                          // prepara saida da inclusao
  LOOP                                             // volta p/ menu de cadastramento
 ENDI
 SEEK M->especialid
 aprov_reg_=(FOUND().AND.DELE().AND.!drvvisivel)   // vai aproveitar o registro?
 IF FOUND() .AND. !aprov_reg_                      // pesquisou e achou!
  l_a=Sistema[op_sis,O_TELA,O_SCROLL]
  op_menu=ALTERACAO                                // seta flag de ateracao
  DISPBEGIN()
  TES_GETS()                                       // mostra conteudo do registro
  INFOSIS(.f.)                                     // exibe informacao no rodape' da tela
  DISPEND()
  ALERTA()
  msg="Consultar/alterar|Retornar … inclus„o"      // pergunta se deseja
  op_=DBOX(msg,,,E_MENU,,"REGISTRO J EXISTE")     // alterar o registro
  IF op_ =1                                        // caso afirmativo
   EDIT()                                          // deixa alterar
  ENDI
  op_menu=INCLUSAO
  DISPBEGIN()
  TES_TELA()
  INFOSIS(.t.)                                     // exibe informacao no rodape' da tela
  DISPEND()
  LOOP                                             // volta para inclusao
 ENDI
 SELE 0
 TES_GET1(INCLUI)                                  // recebe campos
 SELE TESPEC
 IF LASTKEY()=K_ESC                                // se cancelou
  ALERTA()                                         // avisa que o registro
  DBOX("Registro n„o inclu¡do!",18,,1)             // nao foi incluido, e volta
  LOOP
 ENDI

 #ifdef COM_REDE
  GO BOTT                                          // vamos bloquear o final do
  SKIP                                             // arq para que nehum outro
  BLOREG(0,.5)                                     // usuario possa incluir
  SEEK M->especialid                               // se registro foi incluido
  aprov_reg_=(FOUND().AND.DELE().AND.!drvvisivel)  // vai aproveitar o registro?
  IF FOUND() .AND. !aprov_reg_                     // por outro usuario, entao
   BLOREG(0,.5)
   FOR i=1 TO FCOU()
    msg=FIEL(i)
    rep[i]=&msg.
    REPL &msg. WITH M->&msg.
   NEXT
   TES_GET1(FORM_INVERSA)                          // executa formula inversa
   RECA
   FOR i=1 TO FCOU()
    msg=FIEL(i)
    REPL &msg. WITH rep[i]
   NEXT
   ALERTA(4)                                       // beep 4 vezes
   msg="Registro acabou de ser|inclu¡do por outro usu rio!"
   DBOX(msg,,,,,"ATEN€ŽO!")                        // avisa
   SELE TESPEC
   UNLOCK                                          // libera o registro
   LOOP                                            // e recebe chave novamente
  ENDI
 #endi

 IF aprov_reg_                                     // se vai aproveitar reg excluido

  #ifdef COM_REDE
   BLOREG(0,.5)
  #endi

  RECA                                             // excluido, vamos recupera-lo
 ELSE                                              // caso contrario
  APPEND BLANK                                     // inclui reg em branco no dbf
 ENDI
 FOR i=1 TO FCOU()                                 // para cada campo,
  msg=FIEL(i)                                      // salva o conteudo
  rep[i]=M->&msg.                                  // para repetir
  REPL &msg. WITH rep[i]                           // enche o campo do arquivo
 NEXT

 #ifdef COM_REDE
  UNLOCK                                           // libera o registro e
  COMMIT                                           // forca gravacao
 #else
  IF RECC()-INT(RECC()/20)*20=0                    // a cada 20 registros
   COMMIT                                          // digitados forca gravacao
  ENDI
 #endi

 ult_reg=RECN()                                    // ultimo registro digitado
 l_max=l_s+Sistema[op_sis,O_TELA,O_SCROLL]+Sistema[op_sis,O_TELA,O_QTDE]
 IF l_s+l_a+1<l_max                                // se nao atingiu o fim da tela
  l_a++                                            // digita na proxima linha
 ELSE                                              // se nao rola a campos para cima
  SCROLL(l_s+Sistema[op_sis,O_TELA,O_SCROLL],c_s+02,l_max-1,c_s+31,1)
 ENDI
 IF reg_cop!=NIL                                   // estava na consulta e quis rep o campo
  EXIT                                             // cai fora...
 ENDI
ENDD
GO ult_reg                                         // para o ultimo reg digitado
SETKEY(K_F3,t_f3_)                                 // restaura teclas de funcoes
SETKEY(K_F4,t_f4_)
SET(_SET_DELETED,dele_atu)                            // ecluidos visiveis/invisiveis
SETKEY(K_CTRL_W,ctl_w)
SETKEY(K_CTRL_C,ctl_c)
SETKEY(K_CTRL_R,ctl_r)
RETU


PROC TES_tela     // tela do arquivo TESPEC
tem_borda=.t.
l_s=Sistema[op_sis,O_TELA,O_LS]           // coordenadas da tela
c_s=Sistema[op_sis,O_TELA,O_CS]
l_i=Sistema[op_sis,O_TELA,O_LI]
c_i=Sistema[op_sis,O_TELA,O_CI]
SETCOLOR(drvtittel)
vr_memo=NOVAPOSI(@l_s,@c_s,@l_i,@c_i)     // pega posicao atual da tela
CAIXA(mold,l_s,c_s,l_i,c_i)               // monta caixa da tela
i=LEN(sistema[op_sis,O_MENS])/2
@ l_s,c_s-1+(c_i-c_s+1)/2-i SAY " "+MAIUSC(sistema[op_sis,O_MENS])+" "
SETCOLOR(drvcortel)
@ l_s+01,c_s+1 SAY " Especialidades"
@ l_s+02,c_s+1 SAY "ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ"
RETU

PROC TES_gets     // mostra variaveis do arquivo TESPEC
LOCAL getlist := {}, l_max, reg_atual:=RECNO()
PRIV  l_a:=Sistema[op_sis,O_TELA,O_SCROLL]
TES_TELA()
l_max=l_s+Sistema[op_sis,O_TELA,O_SCROLL]+Sistema[op_sis,O_TELA,O_QTDE]
SETCOLOR(drvcortel+","+drvcorget+",,,"+corcampo)
DO WHILE !EOF() .AND. l_s+l_a<l_max
 @ l_s+l_a,c_s+02 GET  especialid;
                  PICT sistema[op_sis,O_CAMPO,01,O_MASC]

 SETCOLOR(drvcortel+","+drvcortel+",,,"+drvcortel)
 l_a++
 SKIP
ENDD
GO reg_atual
SETCOLOR(drvcortel+","+drvcorget+",,,"+corcampo)
CLEAR GETS
RETU

PROC TES_get1(tp_mov)     // capta variaveis do arquivo TESPEC
LOCAL getlist := {}
PRIV  blk_tespec:=.t.

IF tp_mov=INCLUI
 IF TYPE("l_a")!="N"
  l_a=Sistema[op_sis,O_TELA,O_SCROLL]
 ENDI
 DO WHILE .t.
  rola_t=.f.
  SET KEY K_ALT_F8 TO ROLATELA
  SETCOLOR(drvcortel+","+drvcorget+",,,"+corcampo)
  READ
  SET KEY K_ALT_F8 TO
  IF rola_t
   ROLATELA()
   LOOP
  ENDI
  IF LASTKEY()!=K_ESC .AND. drvincl .AND. op_menu=INCLUSAO
   IF !CONFINCL()
    LOOP
   ENDI
  ENDI
  EXIT
 ENDD
ENDI
IF tp_mov=EXCLUI .OR. tp_mov=FORM_INVERSA
 IF !EMPTY(codlan) .AND. tp_mov=EXCLUI
  ALERTA()       // existe registro validado aqui!
  msg="Registro de Lan‡amento"
  DBOX(msg,,,,,"IMPOSS¡VEL EXCLUIR!")
 ELSE
  DELE
 ENDI
ELSEIF tp_mov=INCLUI .OR. tp_mov=RECUPERA .OR. tp_mov=FORM_DIRETA
 IF !EMPTY(codlan) .AND. tp_mov=RECUPERA
  ALERTA()       // existe registro validado aqui!
  msg="Registro de Lan‡amento"
  DBOX(msg,,,,,"IMPOSS¡VEL RECUPERAR!")
 ELSE
  IF op_menu!=INCLUSAO
   RECA
  ENDI
 ENDI
ENDI
RETU

* \\ Final de TESPEC.PRG

 Start  Stop   Length Name                   Class                  Group
 00000H 0006EH 0006FH SIXUK_TEXT             CODE
 0006FH 00833H 007C5H NATION_TEXT            CODE
 00834H 01087H 00854H GAS_PROG               CODE
 01088H 03FBAH 02F33H _TEXT                  CODE
 03FBCH 03FBCH 00000H SORTBLOC_TEXT          CODE
 03FBCH 042A8H 002EDH ASUPPORT_TEXT          CODE
 042A9H 04841H 00599H FILESYS_TEXT           CODE
 04842H 050A5H 00864H DATE_TEXT              CODE
 050A6H 050F7H 00052H OSDATE_TEXT            CODE
 050F8H 05A0BH 00914H TXOPEN_TEXT            CODE
 05A0CH 05F27H 0051CH DVC_TEXT               CODE
 05F28H 05F57H 00030H HARDINIT_TEXT          CODE
 05F58H 05FD3H 0007CH MAIN_TEXT              CODE
 05FD4H 06253H 00280H UPREF_TEXT             CODE
 06254H 0661CH 003C9H EVENT_DRIVER_TEXT      CODE
 0661EH 07495H 00E78H EVENT_TEXT             CODE
 07496H 078E7H 00452H DYNC_TEXT              CODE
 078E8H 07929H 00042H DYNA_TEXT              CODE
 0792AH 0797AH 00051H WEEDBED_TEXT           CODE
 0797CH 0808DH 00712H SYMSYS_TEXT            CODE
 0808EH 0B30FH 03282H OM_TEXT                CODE
 0B310H 0CE69H 01B5AH STACK_TEXT             CODE
 0CE6AH 0D33BH 004D2H FIELD_TEXT             CODE
 0D33CH 0DCB9H 0097EH EXTEND_TEXT            CODE
 0DCBAH 0DE75H 001BCH CALL_TEXT              CODE
 0DE76H 0E467H 005F2H SET_TEXT               CODE
 0E468H 0FEA9H 01A42H OPS_TEXT               CODE
 0FEAAH 10FC5H 0111CH ERRSYS1_TEXT           CODE
 10FC6H 11147H 00182H AEVAL_TEXT             CODE
 11148H 117D9H 00692H ALLOC_TEXT             CODE
 117DAH 14477H 02C9EH VM_TEXT                CODE
 14478H 14654H 001DDH KMAP_TEXT              CODE
 14656H 148A0H 0024BH SUBAL_TEXT             CODE
 148A2H 14906H 00065H OSMEM_TEXT             CODE
 14908H 1490BH 00004H OSME_TEXT              CODE
 1490CH 16F9CH 02691H MACRO_TEXT             CODE
 16F9EH 1705DH 000C0H XMACRO_TEXT            CODE
 1705EH 191BBH 0215EH PLANKTON_TEXT          CODE
 191BCH 191D8H 0001DH INSTD_TEXT             CODE
 191DAH 1AC15H 01A3CH GT_TEXT                CODE
 1AC16H 1C2EDH 016D8H TERM_TEXT              CODE
 1C2EEH 1C473H 00186H BOX_TEXT               CODE
 1C474H 1C605H 00192H TCVT_TEXT              CODE
 1C606H 1CD21H 0071CH COLOR_TEXT             CODE
 1CD22H 1CD3BH 0001AH SETCURS_TEXT           CODE
 1CD3CH 1DD37H 00FFCH PICT_TEXT              CODE
 1DD38H 1E853H 00B1CH RDDSVR_TEXT            CODE
 1E854H 1E991H 0013EH DBJUNCT_TEXT           CODE
 1E992H 1FFEDH 0165CH WORKAREA_TEXT          CODE
 1FFEEH 20003H 00016H EMMALLOC_TEXT          CODE
 20004H 20023H 00020H EMMCONTX_TEXT          CODE
 20024H 20033H 00010H EMMFREE_TEXT           CODE
 20034H 2004DH 0001AH EMMMAP_TEXT            CODE
 2004EH 20066H 00019H EMMPAGE_TEXT           CODE
 20068H 2007EH 00017H EMMVERS_TEXT           CODE
 20080H 2008AH 0000BH BEEP_TEXT              CODE
 2008BH 2152CH 014A2H SCREEN_DRIVER_TEXT     CODE
 2152DH 218ABH 0037FH KEYBD_DRIVER_TEXT      CODE
 218ACH 218ACH 00000H 6NSXDYN_TEXT           CODE
 218ACH 25377H 03ACCH NSXCORE_TEXT           CODE
 25378H 25378H 00000H SWDATA_TEXT            CODE
 25378H 25378H 00000H SWDATA2_TEXT           CODE
 25378H 25378H 00000H SWDATA3_TEXT           CODE
 25378H 27B7DH 02806H SWDBF1_TEXT            CODE
 27B7EH 27B7EH 00000H SWDBFDYN_TEXT          CODE
 27B7EH 27B7EH 00000H SWNAT2_TEXT            CODE
 27B7EH 27B7EH 00000H SWNATIO_TEXT           CODE
 27B7EH 27B7EH 00000H SWSTACK_TEXT           CODE
 27B7EH 27D0FH 00192H SWUTIL3_TEXT           CODE
 27D10H 27DF7H 000E8H TSUPPORT_TEXT          CODE
 27DF8H 27FC9H 001D2H ERRORAPI_TEXT          CODE
 27FCAH 284F7H 0052EH VMAPI_TEXT             CODE
 284F8H 28624H 0012DH DYNAMIC_TEXT           CODE
 28626H 28D37H 00712H DYNX_TEXT              CODE
 28D38H 29365H 0062EH ITEMAPI_TEXT           CODE
 29366H 297B7H 00452H $$$OVLCLP              CODE                   BLICLPMGR
 297B8H 297CDH 00016H $$$OVLDYN              CODE                   BLICLPMGR
 297CEH 2A8F5H 01128H $$$OVLVEC              CODE                   BLIOVLMGR
 2A8F6H 2A901H 0000CH $$$OVLEXE              CODE                   BLIOVLMGR
 2A902H 2A902H 00000H C_ETEXT                ENDCODE
 2A904H 2CE93H 02590H $$$KRNCDE              BLIKRNMGR              BLIKRNMGR
 2CE94H 2E1BFH 0132CH $$$KRNDAT              BLIKRNMGR              BLIKRNMGR
 2E1C0H 2E21FH 00060H $$$KRNINI              BLIKRNMGR              BLIKRNMGR
 2E220H 2E24FH 00030H $$$KRNEXI              BLIKRNMGR              BLIKRNMGR
 2E250H 2E250H 00000H $$$KRNEND              BLIKRNMGR              BLIKRNMGR
 2E250H 2E250H 00000H _SYMSTART              SYMSTART
 2E250H 2ECBFH 00A70H SYMBOLS                SYMBOLS
 2ECC0H 2ED0FH 00050H SYMBOLS                SYMBOLS
 2ED10H 2ED8FH 00080H SYMBOLS                SYMBOLS
 2ED90H 2ED9FH 00010H SYMBOLS                SYMBOLS
 2EDA0H 2EDA0H 00000H SYMBOLS                SYMBOLS
 2EDA0H 2EDA0H 00000H SYMBOLS                SYMBOLS
 2EDA0H 2EF4FH 001B0H SYMBOLS                SYMBOLS
 2EF50H 2F51FH 005D0H SYMBOLS                SYMBOLS
 2F520H 2F59FH 00080H SYMBOLS                SYMBOLS
 2F5A0H 2F5BFH 00020H SYMBOLS                SYMBOLS
 2F5C0H 2F83FH 00280H SYMBOLS                SYMBOLS
 2F840H 2F84FH 00010H SYMBOLS                SYMBOLS
 2F850H 2F85FH 00010H SYMBOLS                SYMBOLS
 2F860H 2F860H 00000H SYMBOLS                SYMBOLS
 2F860H 2F860H 00000H SYMBOLS                SYMBOLS
 2F860H 2FA3FH 001E0H SYMBOLS                SYMBOLS
 2FA40H 2FA4FH 00010H SYMBOLS                SYMBOLS
 2FA50H 2FA5FH 00010H SYMBOLS                SYMBOLS
 2FA60H 2FC0FH 001B0H SYMBOLS                SYMBOLS
 2FC10H 2FC10H 00000H SYMBOLS                SYMBOLS
 2FC10H 2FC10H 00000H SYMBOLS                SYMBOLS
 2FC10H 2FC9FH 00090H SYMBOLS                SYMBOLS
 2FCA0H 2FD3FH 000A0H SYMBOLS                SYMBOLS
 2FD40H 2FD40H 00000H SYMBOLS                SYMBOLS
 2FD40H 2FD40H 00000H SYMBOLS                SYMBOLS
 2FD40H 2FD40H 00000H SYMBOLS                SYMBOLS
 2FD40H 2FD6FH 00030H SYMBOLS                SYMBOLS
 2FD70H 2FE8FH 00120H SYMBOLS                SYMBOLS
 2FE90H 2FE90H 00000H SYMBOLS                SYMBOLS
 2FE90H 2FE9FH 00010H SYMBOLS                SYMBOLS
 2FEA0H 2FEBFH 00020H SYMBOLS                SYMBOLS
 2FEC0H 3009FH 001E0H SYMBOLS                SYMBOLS
 300A0H 300AFH 00010H SYMBOLS                SYMBOLS
 300B0H 3019FH 000F0H SYMBOLS                SYMBOLS
 301A0H 3025FH 000C0H SYMBOLS                SYMBOLS
 30260H 3026FH 00010H SYMBOLS                SYMBOLS
 30270H 3027FH 00010H SYMBOLS                SYMBOLS
 30280H 302CFH 00050H SYMBOLS                SYMBOLS
 302D0H 302EFH 00020H SYMBOLS                SYMBOLS
 302F0H 3035FH 00070H SYMBOLS                SYMBOLS
 30360H 303CFH 00070H SYMBOLS                SYMBOLS
 303D0H 303D0H 00000H _SYMEND                SYMEND
 303D0H 303D0H 00000H _CONST                 CONST
 303D0H 30571H 001A2H OPERR                  CONST
 30572H 30572H 00000H _MSG                   MSG
 30572H 30572H 00000H _BEGBSS                BEGBSS
 30572H 30572H 00000H _ENDBSS                ENDBSS
 30572H 30572H 00000H DMTB                   DLL
 30572H 30581H 00010H DMT                    DLL
 30582H 30582H 00000H DMTE                   DLL
 30590H 32125H 01B96H MACRO5_DATA            FAR_DATA
 32130H 3215EH 0002FH SWDATA5_DATA           FAR_DATA
 32160H 3216AH 0000BH SWDATA25_DATA          FAR_DATA
 32170H 32192H 00023H SWNAT25_DATA           FAR_DATA
 321A0H 3229AH 000FBH SWNATIO5_DATA          FAR_DATA
 322A0H 322A0H 00000H $$DYNBEGIN             $$DYNBEGIN             DYNGROUP
 322A0H 32327H 00088H $$DYNFNAMES            $$DYNFNAMES            DYNGROUP
 32330H 32330H 00000H $$DYNBPAGES            $$DYNPAGES             DYNGROUP
 32330H 3253CH 0020DH $$DYNPAGES             $$DYNPAGES             DYNGROUP
 32540H 32540H 00000H $$DYNEND               $$DYNEND               DYNGROUP
 32540H 32AE3H 005A4H FAR_BSS                FAR_BSS
 32AF0H 32B31H 00042H NULL                   BEGDATA                DGROUP
 32B32H 37089H 04558H _DATA                  DATA                   DGROUP
 3708AH 3708AH 00000H _SYMPB                 DATA                   DGROUP
 3708AH 37099H 00010H _SYMP                  DATA                   DGROUP
 3709AH 3709AH 00000H _SYMPE                 DATA                   DGROUP
 3709AH 370A7H 0000EH CDATA                  DATA                   DGROUP
 370A8H 370A8H 00000H XIFB                   DATA                   DGROUP
 370A8H 370ABH 00004H XIF                    DATA                   DGROUP
 370ACH 370ACH 00000H XIFE                   DATA                   DGROUP
 370ACH 370ACH 00000H XIB                    DATA                   DGROUP
 370ACH 370AFH 00004H XI                     DATA                   DGROUP
 370B0H 370B0H 00000H XIE                    DATA                   DGROUP
 370B0H 370B0H 00000H XPB                    DATA                   DGROUP
 370B0H 370B0H 00000H XP                     DATA                   DGROUP
 370B0H 370B0H 00000H XPE                    DATA                   DGROUP
 370B0H 370B0H 00000H XCB                    DATA                   DGROUP
 370B0H 370B0H 00000H XC                     DATA                   DGROUP
 370B0H 370B0H 00000H XCE                    DATA                   DGROUP
 370B0H 370B0H 00000H XCFB                   DATA                   DGROUP
 370B0H 370B0H 00000H XCF                    DATA                   DGROUP
 370B0H 370B0H 00000H XCFE                   DATA                   DGROUP
 370B0H 370B0H 00000H XNCB                   DATA                   DGROUP
 370B0H 370D7H 00028H XNC                    DATA                   DGROUP
 370D8H 370D8H 00000H XNCE                   DATA                   DGROUP
 370E0H 37227H 00148H $LIB_TABLE             DATA                   DGROUP
 37228H 37291H 0006AH CONST                  CONST                  DGROUP
 37292H 37299H 00008H HDR                    MSG                    DGROUP
 3729AH 3740FH 00176H MSG                    MSG                    DGROUP
 37410H 37436H 00027H PAD                    MSG                    DGROUP
 37437H 37437H 00001H EPAD                   MSG                    DGROUP
 37438H 37579H 00142H _BSS                   BSS                    DGROUP
 3757AH 3757AH 00000H XOB                    BSS                    DGROUP
 3757AH 3757AH 00000H XO                     BSS                    DGROUP
 3757AH 3757AH 00000H XOE                    BSS                    DGROUP
 37580H 376EDH 0016EH C_COMMON               BSS                    DGROUP
 376F0H 39EEFH 02800H STACK                  STACK                  DGROUP

 Overlays

 Section Pubs  Length Name                   Module
 0001H     1     212  GETENV_TEXT            GETENV
 0002H     2      52  SQUAWK_TEXT            SQUAWK
 0003H     9     630  INITEXIT_TEXT          INITEXIT
 0004H     6     828  APPINIT_TEXT           APPINIT
 0005H     3     358  APPEXIT_TEXT           APPEXIT
 0006H    14    2774  SEND_TEXT              SEND
 0007H     4     238  TB_TEXT                TB
 0008H     1     390  ACOPY_TEXT             ACOPY
 0009H     1     244  AINS_TEXT              AINS
 000AH     4    1464  MSAVE_TEXT             MSAVE
 000BH     2     600  ERRSYS0_TEXT           ERRSYS0
 000CH     6     476  SEQ_TEXT               SEQ
 000DH     6      80  CMEM_TEXT              CMEM
 000EH    11    1608  OUTSTD_TEXT            OUTSTD
 000FH     2      32  MAXROW_TEXT            MAXROW
 0010H     2     988  SAVEREST_TEXT          SAVEREST
 0011H     1     218  SCROLL_TEXT            SCROLL
 0012H     3    1352  GETS0_TEXT             GETS0
 0013H    18    3304  GETS1_TEXT             GETS1
 0014H    50    8194  GETS2_TEXT             GETS2
 0015H    15    1808  RDDORD_TEXT            RDDORD
 0016H    10    1574  DBCMD0_TEXT            DBCMD0
 0017H    39    3158  DBCMD1_TEXT            DBCMD1
 0018H     4    1048  DBCMD3_TEXT            DBCMD3
 0019H     2     650  DBSTRUCT_TEXT          DBSTRUCT
 001AH     4    1416  DBCREATE_TEXT          DBCREATE
 001BH    10    1270  PHILES_TEXT            PHILES
 001CH     3      61  EMMCOUNT_TEXT          EMMCOUNT
 001DH     1      48  EMMINST_TEXT           EMMINST
 001EH     1     254  EXACTCMP_TEXT          EXACTCMP
 001FH     8     993  EXAMPLEA_TEXT          EXAMPLEA
 0020H     1     288  ALLTRIM_TEXT           ALLTRIM
 0021H     1     276  RIGHT_TEXT             RIGHT
 0022H     1     226  RAT_TEXT               RAT
 0023H     1     328  PADL_TEXT              PADL
 0024H     1     326  PADR_TEXT              PADR
 0025H     1     326  PADC_TEXT              PADC
 0026H     1     996  STRTRAN_TEXT           STRTRAN
 0027H     3     680  STUFF_TEXT             STUFF
 0028H     1     688  MEMOLINE_TEXT          MEMOLINE
 0029H     1     342  MLCOUNT_TEXT           MLCOUNT
 002AH     2     492  LINELEN_TEXT           LINELEN
 002BH     2     344  ASCAN_TEXT             ASCAN
 002CH     4    1152  DIRECT_TEXT            DIRECT
 002DH    49   11920  MEMOEDIT_TEXT          MEMOEDIT
 002EH     6     240  NSX0_TEXT              NSXMACH6
 002FH    17    3008  NSX2_TEXT              NSX2
 0030H     4    2910  NSX3_TEXT              NSX3
 0031H    12    9710  NSXCREAT_TEXT          NSXCREAT
 0032H    17    2970  NSXDIREC_TEXT          NSXDIREC
 0033H     2     328  NSXFREEL_TEXT          NSXFREEL
 0034H     2    1870  NSXINDEX_TEXT          NSXINDEX
 0035H     5     830  NSXLOCK_TEXT           NSXLOCK
 0036H     1     844  NSXTRYO_TEXT           NSXTRYO
 0037H    13    2212  SMTMEMO1_TEXT          SMTMEMO1
 0038H     8    2294  SMTMEMO2_TEXT          SMTMEMO2
 0039H     3      70  SWDBF0_TEXT            SWDBF0
 003AH    18    3302  SWDBF2_TEXT            SWDBF2
 003BH     7    2130  SWENCODE_TEXT          SWENCODE
 003CH     2     466  SWFILE_TEXT            SWFILE
 003DH     5     134  SWIFUNC_TEXT           SWIFUNC
 003EH     6    1632  SWIND1_TEXT            SWIND1
 003FH     2    2360  SWINDEX1_TEXT          SWINDEX1
 0040H     5    1750  SWKILLT_TEXT           SWKILLT
 0041H     9    1020  SWLCK_TEXT             SWLCK
 0042H     8    3290  SWMEMO1_TEXT           SWMEMO1
 0043H     2     276  SWMEMO2_TEXT           SWMEMO2
 0044H     3    1074  SWOPT_TEXT             SWOPT
 0045H     5     510  SWPAGE_TEXT            SWPAGE
 0046H     5    1762  SWRLOCK_TEXT           SWRLOCK
 0047H     3    2048  SWSURF_TEXT            SWSURF
 0048H     3     748  SWTRIGGE_TEXT          SWTRIGGE
 0049H     8     978  SWUTIL_TEXT            SWUTIL
 004AH     4     418  SWUTIL2_TEXT           SWUTIL2
 004BH    13    3700  VFCORE_TEXT            VFCORE
 004CH     4    1242  M6CRTMAP_TEXT          M6CRTMAP
 004DH     1     960  M6CSAND_TEXT           M6CSAND
 004EH     1     406  M6CSNOT_TEXT           M6CSNOT
 004FH     1     778  M6CSOR_TEXT            M6CSOR
 0050H     7    1038  M6DBF1_TEXT            M6DBF1
 0051H     2     876  M6EQUAL_TEXT           M6EQUAL
 0052H     5     156  M6ERROR_TEXT           M6ERROR
 0053H     3     704  M6EVAL_TEXT            M6EVAL
 0054H     3    1414  M6FILT1_TEXT           M6FILT1
 0055H     5    1028  M6FILT2_TEXT           M6FILT2
 0056H     1     374  M6GETVAL_TEXT          M6GETVAL
 0057H     1     480  M6GREAT_TEXT           M6GREAT
 0058H     1     108  M6INIT_TEXT            M6INIT
 0059H     1     492  M6INSTR_TEXT           M6INSTR
 005AH     5    2314  M6ISKEY_TEXT           M6ISKEY
 005BH     2     876  M6ISOPT_TEXT           M6ISOPT
 005CH     1     420  M6LESS_TEXT            M6LESS
 005DH     4    1566  M6LOCA1_TEXT           M6LOCA1
 005EH     4    2024  M6LOGIC_TEXT           M6LOGIC
 005FH     1     626  M6NEQUAL_TEXT          M6NEQUAL
 0060H     2    1158  M6OPTDEL_TEXT          M6OPTDEL
 0061H     1     192  M6OURDRV_TEXT          M6OURDRV
 0062H     1     470  M6RANGE_TEXT           M6RANGE
 0063H     6    2462  M6SMART_TEXT           M6SMART
 0064H     6    1640  M6STKEXP_TEXT          M6STKEXP
 0065H     6     968  M6STRING_TEXT          M6STRING
 0066H     1     438  M6SWHILE_TEXT          M6SWHILE
 0067H     6    2646  M6TOKE_TEXT            M6TOKE
 0068H     4     696  M6TRANS_TEXT           M6TRANS
 0069H    13    3430  M6VMMAP_TEXT           M6VMMAP
 006AH     1     308  MEMORY_TEXT            MEMORY
 006BH    19    3030  DISKIO_TEXT            DISKIO
 006CH    23    6076  SORTOF_TEXT            SORTOF
 -------------------
 Total        150986
 -------------------

 Origin    Group
 2936:0006 BLICLPMGR
 297C:000E BLIOVLMGR
 2A90:0004 BLIKRNMGR
 322A:0000 DYNGROUP
 32AF:0000 DGROUP

  Address         Publics by Value

 0000:0000  Abs  __START_SYM
 0000:0000  Res  __NPREVC
 0000:0029  Res  __NNEXTC
 0000:0052  Res  __ZCMP
 0000:006E  Res  __FORCE_ASCII
 0006:010F  Res  _NATSORTVE
 0006:013E  Res  __NATRDDVER
 0006:0150  Res  __NLEXID
 0006:01BA  Res  __NSCANID
 0006:0238  Res  __UPCASE
 0006:024B  Res  __LOCASE
 0006:025E  Res  __CH_TYPE
 0006:02C7  Res  __NCOPYUC
 0006:02E6  Res  __NCOPYLC
 0006:0305  Res  __NTRIMLEN
 0006:0326  Res  __NPREVI
 0006:0339  Res  __NNEXTI
 0006:0350  Res  __NGET
 0006:0365  Res  __NPUT
 0006:037A  Res  __TCMP
 0006:03A2  Res  __DCMP
 0006:03C3  Res  __XCMP
 0006:03DD  Res  __SCANW
 0006:0411  Res  __SCANN
 0006:045F  Res  __NODE_SEARCH
 0006:04B9  Res  __S_ORDER
 0006:05BA  Res  _NATMSGVER
 0006:05D3  Res  ISNEGATIVE
 0006:0620  Res  ISAFFIRM
 0006:066D  Res  NATIONMSG
 0006:06B0  Res  __DAY_NAME
 0006:06C8  Res  __MONTH_NAME
 0006:06E0  Res  __YNSTR
 0006:06F2  Res  __NATMSGVER
 0006:0704  Res  __ERRORDESC
 0006:075C  Res  __NVERSION
 0006:07C2  Res  _CLIPINTL
 0083:0004  Res  DECRIPT
 0083:0004  Res  ENCRIPT
 0083:012C  Res  QUALDIR
 0083:01B3  Res  CHDIR
 0083:01B7  Res  MKDIR
 0083:01BB  Res  RMDIR
 0083:020C  Res  CALLINT
 0083:0311  Res  VAL_CF
 0083:0321  Res  VAL_AX
 0083:0327  Res  VAL_BX
 0083:032D  Res  VAL_CX
 0083:0333  Res  VAL_DX
 0083:0339  Res  VAL_DS
 0083:033F  Res  VAL_ES
 0083:0345  Res  VAL_DI
 0083:034B  Res  VAL_SI
 0083:0351  Res  VAL_FLAGS
 0083:0359  Res  VAL_AH
 0083:035F  Res  VAL_BH
 0083:0365  Res  VAL_CH
 0083:036B  Res  VAL_DH
 0083:0371  Res  VAL_AL
 0083:0377  Res  VAL_BL
 0083:037D  Res  VAL_CL
 0083:0383  Res  VAL_DL
 0083:0477  Res  PEEK
 0083:0506  Res  F_ERROR
 0083:052C  Res  IS_FERROR
 0083:054D  Res  SET_FERROR
 0083:056E  Res  CLR_FERROR
 0083:058D  Res  RONLY
 0083:05DB  Res  RWRITE
 0083:062A  Res  ALOCAMEM
 0083:0673  Res  QDE_FREE
 0083:0679  Res  HEXA_DEC
 0083:0715  Res  TAMASTRI
 0083:0732  Res  POKE
 0083:07F7  Res  CONTA
 0083:0842  Res  _CONTA
 0108:0018  Res  __ASTART
 0108:00C2  Res  __CINTDIV
 0108:00D1  Res  __AMSG_EXIT
 0108:00E6  Res  __CINIT
 0108:01AA  Res  _EXIT
 0108:01C1  Res  __EXIT
 0108:0208  Res  __CTERMSUB
 0108:0248  Res  __FPTRAP
 0108:024E  Res  __FF_MSGBANNER
 0108:0272  Res  __NULLCHECK
 0108:0298  Res  __NMSG_TEXT
 0108:02C3  Res  __NMSG_WRITE
 0108:02EE  Res  __SETENVP
 0108:036A  Res  __SETARGV
 0108:0512  Res  __AFLDIV
 0108:05AE  Res  __AFLMUL
 0108:05AE  Res  __AFULMUL
 0108:05E2  Res  __AFULREM
 0108:064E  Res  __AFULDIV
 0108:06C3  Res  __SLDS
 0108:06C7  Res  __ELDS
 0108:06E5  Res  __FLDS
 0108:070F  Res  __SLDD
 0108:0713  Res  __ELDD
 0108:0733  Res  __FLDD
 0108:0762  Res  __SLDT
 0108:0768  Res  __FLDT
 0108:079C  Res  __SLDL
 0108:07A0  Res  __ELDL
 0108:07A9  Res  __SLDW
 0108:07AD  Res  __ELDW
 0108:07B3  Res  __FLDL
 0108:07BA  Res  __FLDW
 0108:07BC  Res  B$FIL2
 0108:07BD  Res  B$FILD
 0108:0811  Res  __FDUP
 0108:0840  Res  __FLDZ
 0108:0866  Res  __SSTS
 0108:086A  Res  __FSTS
 0108:086E  Res  __ESTS
 0108:087E  Res  __SSTSP
 0108:0882  Res  __FSTSP
 0108:0886  Res  __ESTSP
 0108:08B4  Res  __SSTD
 0108:08B8  Res  __FSTD
 0108:08BC  Res  __ESTD
 0108:08CC  Res  __SSTDP
 0108:08D0  Res  __FSTDP
 0108:08D4  Res  __ESTDP
 0108:08FD  Res  __SSTT
 0108:0901  Res  __FSTT
 0108:0914  Res  __SSTTP
 0108:0918  Res  __FSTTP
 0108:093B  Res  B$FIS2
 0108:0943  Res  B$FIST
 0108:094B  Res  B$FUST
 0108:0983  Res  __FTOL
 0108:09BC  Res  __FTST
 0108:09E9  Res  __FABS
 0108:09F8  Res  __FCHS
 0108:0A30  Res  __SSUBS
 0108:0A38  Res  __ESUBS
 0108:0A3F  Res  __FSUBS
 0108:0A48  Res  __SSUBSR
 0108:0A50  Res  __ESUBSR
 0108:0A57  Res  __FSUBSR
 0108:0A60  Res  __SMULS
 0108:0A68  Res  __EMULS
 0108:0A6F  Res  __FMULS
 0108:0A78  Res  __SDIVS
 0108:0A80  Res  __EDIVS
 0108:0A87  Res  __FDIVS
 0108:0A90  Res  __SDIVSR
 0108:0A98  Res  __EDIVSR
 0108:0A9F  Res  __FDIVSR
 0108:0AA8  Res  __SADDS
 0108:0AB0  Res  __EADDS
 0108:0AB7  Res  __FADDS
 0108:0AEF  Res  __SSUBD
 0108:0AF7  Res  __ESUBD
 0108:0AFE  Res  __FSUBD
 0108:0B07  Res  __SSUBDR
 0108:0B0F  Res  __ESUBDR
 0108:0B16  Res  __FSUBDR
 0108:0B1F  Res  __SMULD
 0108:0B27  Res  __EMULD
 0108:0B2E  Res  __FMULD
 0108:0B37  Res  __SDIVD
 0108:0B3F  Res  __EDIVD
 0108:0B46  Res  __FDIVD
 0108:0B4F  Res  __SDIVDR
 0108:0B57  Res  __EDIVDR
 0108:0B5E  Res  __FDIVDR
 0108:0B67  Res  __SADDD
 0108:0B6F  Res  __EADDD
 0108:0B76  Res  __FADDD
 0108:0B95  Res  __FSUB
 0108:0B9A  Res  __FSUBR
 0108:0B9F  Res  __FMUL
 0108:0BA4  Res  __FDIV
 0108:0BA9  Res  __FDIVR
 0108:0BAE  Res  __FADD
 0108:0BB3  Res  __FCOMPP
 0108:0BB3  Res  B$FCMP
 0108:0BB8  Res  __FCMP
 0108:0C46  Res  __FXCHQ
 0108:0C54  Res  __FXCH
 0108:0C7A  Res  __DCVT
 0108:0C92  Res  $I8_ERRMINF
 0108:0C92  Res  $I4_ERRMINF
 0108:0C92  Res  $I8_ERRPINF
 0108:0C92  Res  $I4_ERRPINF
 0108:0C92  Res  $I8_ERRINF
 0108:0C92  Res  $I4_ERRINF
 0108:0C9C  Res  $I8_ERRDIV0
 0108:0C9C  Res  $I4_ERRDIV0
 0108:0CA6  Res  $I4_ERRINVLD
 0108:0CA6  Res  $I8_ERRINVLD
 0108:0CB0  Res  $I8_ERRSTACK
 0108:0CC3  Res  __FPSIGNAL
 0108:0D00  Res  __FPMATH
 0108:0D2E  Res  __SMOVTMPESBX
 0108:0D30  Res  __SMOVTMPESSI
 0108:0D44  Res  __DMOVTMPESBX
 0108:0D46  Res  __DMOVTMPESSI
 0108:0D5C  Res  __DCVTST0
 0108:0D68  Res  __DCVTST0A
 0108:0D6B  Res  __DCVTDISI
 0108:0DAA  Res  __CTRANDISP2
 0108:0DC2  Res  __CTRANDISP1
 0108:0EAE  Res  $I4_CMP
 0108:0F01  Res  $I8_CMP
 0108:0F53  Res  $I8_4
 0108:0F94  Res  $I4_8
 0108:1016  Res  $I4_W
 0108:1018  Res  $I4_Q
 0108:1020  Res  $I4_S
 0108:102C  Res  $I4_L
 0108:1046  Res  $I8_W
 0108:1048  Res  $I8_Q
 0108:1050  Res  $I8_S
 0108:105C  Res  $I8_L
 0108:107B  Res  $I4_TO_S
 0108:1080  Res  $I4_TO_SRND
 0108:1080  Res  $I4_TO_SIRND
 0108:1085  Res  $I8_TO_S
 0108:108A  Res  $I8_TO_SRND
 0108:108A  Res  $I8_TO_SIRND
 0108:1097  Res  $I4_TO_W
 0108:109C  Res  $I4_TO_WRND
 0108:109C  Res  $I4_TO_WIRND
 0108:10A1  Res  $I8_TO_W
 0108:10A6  Res  $I8_TO_WRND
 0108:10A6  Res  $I8_TO_WIRND
 0108:10AE  Res  $I4_TO_LIRND
 0108:10AE  Res  $I4_TO_LRND
 0108:10B3  Res  $I8_TO_LIRND
 0108:10B3  Res  $I8_TO_LRND
 0108:10B8  Res  $I4_TO_L
 0108:10BD  Res  $I8_TO_L
 0108:10DD  Res  $I4_TO_QRND
 0108:10DD  Res  $I4_TO_QIRND
 0108:10E2  Res  $I8_TO_QRND
 0108:10E2  Res  $I8_TO_QIRND
 0108:1101  Res  $I8_TO_Q
 0108:1136  Res  $I4_TO_Q
 0108:11B2  Res  $I8_FIXIRND
 0108:11B2  Res  $I8_FIXRND
 0108:11D8  Res  $I4_FIXIRND
 0108:11D8  Res  $I4_FIXRND
 0108:11FC  Res  $I8_FIX
 0108:120C  Res  $I4_FIX
 0108:1326  Res  $I4_SUBREV
 0108:1328  Res  $I4_SUB
 0108:1330  Res  $I4_ADD
 0108:1402  Res  $I4_NORM
 0108:1430  Res  $I4_ROUND
 0108:1492  Res  $I4_MUL
 0108:1516  Res  $I4_DIVREV
 0108:1518  Res  $I4_DIV
 0108:1620  Res  $I8_SUBREV
 0108:1622  Res  $I8_SUB
 0108:1645  Res  $I8_ADD
 0108:1778  Res  $I8_NORM
 0108:17CE  Res  $I8_ROUND
 0108:184C  Res  $I8_MUL
 0108:18AD  Res  $I8_DIVREV
 0108:18AF  Res  $I8_DIV
 0108:1BE1  Res  $I8_LGT
 0108:1BF7  Res  $I8_LOG
 0108:1CAE  Res  $I8_EXP
 0108:1CC2  Res  $I8_EXPADJUST
 0108:1CFD  Res  $I8_PF_PWR
 0108:1D14  Res  $I8_C_PWR
 0108:1D18  Res  $I8_PWR
 0108:1E12  Res  $I8_PF_PWR_L
 0108:1E12  Res  $I8_PWR_L
 0108:1EA8  Res  $I8_SQR
 0108:1F66  Res  $I8_ADDF
 0108:1F6A  Res  $I8_ADDFSI
 0108:1F70  Res  $I8_SUBF
 0108:1F74  Res  $I8_SUBFSI
 0108:1F7A  Res  $I8_MULF
 0108:1F7E  Res  $I8_MULFSI
 0108:1F84  Res  $I8_DIVF
 0108:1F88  Res  $I8_DIVFSI
 0108:1F8E  Res  $I8_SUBR
 0108:1F92  Res  $I8_SUBRDI
 0108:1F98  Res  $I8_DIVR
 0108:1F9C  Res  $I8_DIVRDI
 0108:1FA2  Res  $I8_CLEARAC
 0108:1FB2  Res  $I8_MOVAC
 0108:1FBB  Res  $I8_MOVAC_ARG
 0108:1FCB  Res  $I8_MOVARG_AC
 0108:1FCF  Res  $I8_MOVARG
 0108:1FDA  Res  $I8_MOVTEMP
 0108:1FE5  Res  $I8_PSHARG
 0108:1FEA  Res  $I8_PSHAC
 0108:1FEE  Res  $I8_PSHSI
 0108:1FFC  Res  $I8_POPARG
 0108:2001  Res  $I8_POPAC
 0108:2005  Res  $I8_POPSI
 0108:2013  Res  $I8_POLY
 0108:2058  Res  $I8_EVEN
 0108:208E  Res  $I8_EXPM1
 0108:209F  Res  $I8_EXPM1REDUCED
 0108:20CF  Res  $I8_LNREDUCEAC_HI
 0108:20D5  Res  $I8_LNREDUCE
 0108:20E4  Res  $I8_RETONE
 0108:20EE  Res  $I8_RETZERO
 0108:2105  Res  $I8_OVERFLOWRANGE
 0108:210A  Res  $I8_EXPHRANGE
 0108:2112  Res  $I8_EXPRANGE
 0108:2118  Res  $I8_RANGE
 0108:213C  Res  $I8_P_Q
 0108:2172  Res  $I8_Z2P_Q
 0108:2183  Res  $I8_Z3P_Q
 0108:218C  Res  $I8_REDUCE
 0108:21A8  Res  $I8_TMUL
 0108:230E  Res  $I8_TPWR10
 0108:237E  Res  $I8_INPUT
 0108:26CA  Res  $I8_OUTPUT
 0108:27CA  Res  _FLOOR
 0108:27DA  Res  _CEIL
 0108:2840  Res  _FMOD
 0108:289B  Res  _POW
 0108:28A4  Res  _LOG
 0108:28AD  Res  _LOG10
 0108:28B6  Res  _EXP
 0108:28BF  Res  _SQRT
 0108:28C8  Res  __MYALLOC
 0108:290A  Res  __WRT2ERR
 0108:2919  Res  _MATHERR
 0108:2927  Res  __DVINIT
 0108:2950  Res  __DVADD
 0108:2997  Res  __DVSUB
 0108:29DE  Res  __DVMUL
 0108:2A25  Res  __DVDIV
 0108:2A6C  Res  __DVTOQ
 0108:2A87  Res  __DVTOI
 0108:2AA2  Res  __DVTOL
 0108:2ABD  Res  __DVFMQ
 0108:2B05  Res  __DVFMI
 0108:2B3F  Res  __DVFML
 0108:2B7A  Res  __DVFMA
 0108:2BF4  Res  __NTOA
 0108:2CF6  Res  __ATON
 0108:2D4C  Res  __LNTOA
 0108:2DEB  Res  __CFLTCVT
 0108:2DEC  Res  __CROPZEROS
 0108:2DED  Res  __FASSIGN
 0108:2DEE  Res  __FORCDECPT
 0108:2DEF  Res  __POSITIVE
 0108:2DF0  Res  __CFTOE
 0108:2DF1  Res  __CFTOF
 0108:2DF2  Res  __CFTOG
 0108:2E10  Res  __TERMHOOK
 0108:2E22  Res  __GTHOOK
 0108:2E34  Res  __DBCMDHOOK
 0108:2E46  Res  __AFLSHR
 0108:2E52  Res  __AFLREM
 0108:2EF4  Res  __AFNALDIV
 0108:2F18  Res  __DYNXHOOK
 0108:2F2A  Res  __DISKIOHOOK
 03FB:000C  Res  __PTOABSADDR
 03FB:002D  Res  _STRCPY
 03FB:004F  Res  _STCCPY
 03FB:0078  Res  _STRNCPY
 03FB:00A1  Res  __BSET
 03FB:00C4  Res  __BMOVE
 03FB:0119  Res  __BCOPY
 03FB:0137  Res  __BCOPYF
 03FB:0166  Res  __LCOPY
 03FB:0184  Res  __BCMP
 03FB:01AC  Res  __BSCAN
 03FB:01D0  Res  __U2HEX
 03FB:01FF  Res  _STRCAT
 03FB:0229  Res  _STPCHR
 03FB:0256  Res  _STPBLK
 03FB:027D  Res  _STRLEN
 03FB:0299  Res  __DOSFUNC
 03FB:02CB  Res  __ASMCALL
 042A:0037  Res  __TINIT
 042A:0085  Res  __TEND
 042A:00CD  Res  __FSCREATE
 042A:00FA  Res  __TCTEMP
 042A:018B  Res  __FSOPEN
 042A:01BC  Res  __FSCLOSE
 042A:01DE  Res  __FSREAD
 042A:020B  Res  __FSWRITE
 042A:0238  Res  __FSSEEK
 042A:0271  Res  __FSLOCK
 042A:02B0  Res  __TMNAME
 042A:02E6  Res  __FSDELETE
 042A:030A  Res  __FSRENAME
 042A:0331  Res  __THCOUNT
 042A:0375  Res  __FSCOMMIT
 042A:038F  Res  __FSERROR
 042A:03B4  Res  __TISDEVICE
 042A:03D3  Res  __TDEVRAW
 042A:040F  Res  __F_FIRST
 042A:0434  Res  __F_NEXT
 042A:044F  Res  __DSPACE
 042A:0473  Res  __TMKDIR
 042A:04A0  Res  __TRMDIR
 042A:04CD  Res  __TCHDIR
 042A:04FA  Res  __TCURDRV
 042A:0516  Res  __TCHDRV
 042A:0541  Res  __TISDRV
 042A:0565  Res  __TCURDIR
 0484:010C  Res  __DDMYTODATE
 0484:01EE  Res  __DDATETODMYD
 0484:0324  Res  __DSYSDATE
 0484:0348  Res  __DALPHATODATEFMT
 0484:045A  Res  __DALPHATODATEDBF
 0484:0514  Res  __DDATETOALPHAFMT
 0484:060A  Res  __DDATETOALPHADBF
 0484:0696  Res  __DSETFMT
 0484:084C  Res  __DSETEPOCH
 050A:0006  Res  __OSDATE
 050A:002D  Res  __OSTIME
 050F:008E  Res  __SCAN_FILENAME
 050F:01C0  Res  __TXOPEN
 050F:0866  Res  FILE
 050F:0894  Res  __FSEXTOPEN
 05A0:000C  Res  __DVLT
 05A0:0034  Res  __DVLE
 05A0:005C  Res  __DVEQ
 05A0:0084  Res  __DVGE
 05A0:00AC  Res  __DVGT
 05A0:00D4  Res  __DVNE
 05A0:00FC  Res  __DVLTZ
 05A0:0124  Res  __DVEQZ
 05A0:014C  Res  __DVMOD
 05A0:0196  Res  __DVNEG
 05A0:01C6  Res  __DVABS
 05A0:0218  Res  __DVINC
 05A0:024C  Res  __DVDEC
 05A0:0280  Res  __DVINT
 05A0:02EA  Res  __DVPOW
 05A0:0334  Res  __DVLOG
 05A0:0372  Res  __DVSQR
 05A0:03B0  Res  __DVEXP
 05A0:03EE  Res  __DVRND
 05F2:0008  Res  __SYSHARDINIT
 05F5:0008  Res  _TERM
 05F5:0036  Res  _MAIN
 05FD:017C  Res  __UPREFP
 05FD:0220  Res  __UPREF
 0625:035F  Res  __EVLOW
 0625:035F  Res  __EVEENTRY
 0661:0570  Res  __EVSENDSTRUCT
 0661:062A  Res  __EVSENDID
 0661:0640  Res  __EVPOSTSTRUCT
 0661:0660  Res  __EVPOSTID
 0661:068E  Res  __EVREGRECEIVERFUNC
 0661:07C0  Res  __EVDEREGRECEIVER
 0661:07EE  Res  __SYSREGLOW
 0661:0806  Res  __EVREGTYPE
 0661:0818  Res  __EVSEND
 0661:081E  Res  __EVPOST
 0661:086E  Res  __EVMODALREAD
 0661:0932  Res  __EVTRANSLATE
 0661:097C  Res  __EVBREAKENABLE
 0661:09B2  Res  __EVSCROLLPAUSE
 0661:0A08  Res  __EVSTROBE
 0661:0A2C  Res  __BREAK_CYCLE
 0661:0ADC  Res  SETCANCEL
 0661:0B9C  Res  ALTD
 0661:0DEE  Res  __EVENT_INIT
 0749:00C4  Res  __DYNFREEMODULE
 0749:01E4  Res  __DYNGETORDADDR
 0749:0280  Res  __DYNGETNAMEDADDR
 0749:0352  Res  __DYNLOADMODULE
 0749:041E  Res  __DYNINIT
 0749:042E  Res  __DYNINI
 078E:0008  Res  _DMOD_COUNT
 078E:001D  Res  _DINIT_INIT
 0792:000A  Res  __WEED_EATR
 0792:0038  Res  __START_PROC
 0797:0338  Res  _WEED_DIGESTR
 0797:0362  Res  __GET_SYM
 0797:042E  Res  __CHK_SYM
 0797:0492  Res  __CHK_SYM2
 0797:05AC  Res  __SYM_SEARCH
 0797:05F8  Res  __NEXT_SYM
 0797:067E  Res  __SYM_INIT
 0808:03BC  Res  _ARRAYNEW
 0808:04E6  Res  _BLOCKNEW
 0808:059C  Res  _BYTESNEW
 0808:079A  Res  __OCOPY
 0000:9876  Abs  __ACRTUSED
 0000:9876  Abs  __FLTUSED
 0000:9876  Abs  __ACRTMSG
 0808:1AF6  Res  __XCHECK
 0808:1B04  Res  __OSCAVENGEALL
 0808:1B58  Res  __OESTIMATE
 0808:1B64  Res  __IARRAYAT
 0808:1BE6  Res  __CAT
 0808:1D02  Res  __CATPUT
 0808:1EE0  Res  __IARRAYPUT
 0808:1F0C  Res  __IARRAYC2
 0808:1FFE  Res  _VARRAY
 0808:2040  Res  _VARRAYX
 0808:2094  Res  _VARRAYLEN
 0808:20D6  Res  __VDICT
 0808:2126  Res  __VSETDICT
 0808:2192  Res  _VSTR
 0808:21E8  Res  _VSTRX
 0808:223C  Res  _VSTR2
 0808:230E  Res  _VSTRLOCK
 0808:2378  Res  _VSTRUNLOCK
 0808:23CC  Res  _VSTRCOLD
 0808:2424  Res  _BYTESNEW2
 0808:2444  Res  _OSTRDUP
 0808:24FC  Res  __CATAT
 0808:2570  Res  __CATPUTSTR
 0808:26FE  Res  __IMAKEA
 0808:2764  Res  __IMAKELA
 0808:2820  Res  ARRAY
 0808:28BE  Res  _CSCANCHECK
 0808:2956  Res  __CCOPY
 0808:29D4  Res  __CBECOME
 0808:2BF4  Res  __CRESIZE
 0808:2EA2  Res  ASIZE
 0808:2F06  Res  __AADD
 0808:2F70  Res  __XUNLOCK
 0808:2FC2  Res  __XXLOCK
 0808:31E0  Res  __OM_INIT
 0B31:0000  Res  __FIXLEN
 0B31:0126  Res  __SPTOQ
 0B31:0158  Res  __SPTOL
 0B31:018E  Res  __PUTQ
 0B31:01B0  Res  __PUTL
 0B31:01CC  Res  __PUTLN
 0B31:01F0  Res  __PUTCL
 0B31:022C  Res  __PUTC
 0B31:0260  Res  __PUTSYM
 0B31:027E  Res  __PARAM
 0B31:02F2  Res  __LPARAM
 0B31:0350  Res  __ISAVERET
 0B31:0370  Res  __RETL
 0B31:0388  Res  __RETQ
 0B31:03A6  Res  __RETC
 0B31:09E6  Res  __IMVCLEAN
 0B31:0A88  Res  __IMVWIPE
 0B31:0B70  Res  __IGETM
 0B31:0BD4  Res  __XPUSHM
 0B31:0C12  Res  __XPOPM
 0B31:0C7A  Res  __IPUBLICS
 0B31:0C8E  Res  __QQPUB
 0B31:0CB8  Res  __IPRIVATES
 0B31:0CCE  Res  __IPARAMS
 0B31:0DBA  Res  __IPUSHM
 0B31:0E22  Res  __CALLERPOPM
 0B31:0F5C  Res  __IPOPM
 0B31:0FAA  Res  __IPUSHMR
 0B31:1074  Res  __IPUSHLR
 0B31:10DC  Res  __IPUSHFLR
 0B31:1144  Res  __IPUSHSR
 0B31:11AC  Res  __ISINIT
 0B31:120C  Res  __ISFRAME
 0B31:121E  Res  __GETGRIP
 0B31:127C  Res  __DROPGRIP
 0B31:1294  Res  __IPUSHBLOCK
 0B31:13AC  Res  __IZZBLOCK
 0B31:14FC  Res  __IXBLOCK
 0B31:1744  Res  __IZZACT
 0B31:1884  Res  __CEVAL0
 0B31:18AE  Res  __CEVAL1
 0B31:18E4  Res  __ACTINFO
 0B31:193E  Res  __ACTCOUNT
 0B31:19D6  Res  __STACK_EXIT
 0B31:1A7A  Res  __STACK_INIT
 0CE6:000A  Res  __XPUSHF
 0CE6:0190  Res  __XPOPF
 0CE6:01FC  Res  __IPUSHV
 0CE6:028A  Res  __IPUSHF
 0CE6:0304  Res  __IPOPF
 0CE6:037E  Res  __IPUSHQF
 0CE6:0404  Res  __IPOPQF
 0CE6:048A  Res  __FCHECK
 0D33:0280  Res  __STORCLEN
 0D33:0376  Res  __STORC
 0D33:03B4  Res  __PARINFO
 0D33:040A  Res  __PARINFA
 0D33:0522  Res  __PARCPEEK
 0D33:056E  Res  __PARC
 0D33:060A  Res  __PARCSIZ
 0D33:064E  Res  __PARCLEN
 0D33:0678  Res  __PARNI
 0D33:06C0  Res  __PARNL
 0D33:070C  Res  __PARND
 0D33:0770  Res  __PARL
 0D33:0786  Res  __PARDS
 0D33:07B2  Res  __STORND
 0D33:07EC  Res  __STORNL
 0D33:080C  Res  __STORNI
 0D33:082C  Res  __STORL
 0D33:0848  Res  __STORDS
 0D33:0882  Res  __RETCLEN
 0D33:08B4  Res  __RETNI
 0D33:08D6  Res  __RETNL
 0D33:08FA  Res  __RETND
 0D33:0922  Res  __RETDS
 0D33:0956  Res  __RET
 0D33:0958  Res  __RETA
 0D33:0966  Res  __EXMGRAB
 0D33:0976  Res  __EXMBACK
 0DCB:0064  Res  __ICALL
 0DE7:0006  Res  __SETSTRUCT
 0DE7:0182  Res  SET
 0E46:0106  Res  __STRMINUS
 0E46:01FC  Res  __MIN
 0E46:02D2  Res  __MAX
 0E46:03AC  Res  __MODULUS
 0E46:0478  Res  __INT
 0E46:053A  Res  __ROUND
 0E46:05CE  Res  __EXPON
 0E46:070E  Res  __LOGQ
 0E46:071A  Res  __QEXP
 0E46:0726  Res  __QSQRT
 0E46:0732  Res  __CHR
 0E46:0780  Res  __SPACE
 0E46:080A  Res  __SUB3
 0E46:0952  Res  __SUB2
 0E46:0A3E  Res  __LEFT
 0E46:0AE2  Res  __STR3
 0E46:0BF2  Res  __STR2
 0E46:0CBA  Res  __STR1
 0E46:0D6E  Res  __TRIM
 0E46:0DEA  Res  __LTRIM
 0E46:0E78  Res  __UPPER
 0E46:0EDA  Res  __LOWER
 0E46:0F3C  Res  __REPLICATE
 0E46:1062  Res  __VAL
 0E46:1154  Res  __LEN
 0E46:119C  Res  __EMPTY
 0E46:127E  Res  __AT
 0E46:13C0  Res  __INSTR
 0E46:14F8  Res  __ASC
 0E46:153E  Res  __TIME
 0E46:15E2  Res  __SECONDS
 0E46:169E  Res  __DATE
 0E46:16BE  Res  __DAY
 0E46:170C  Res  __MONTH
 0E46:175C  Res  __YEAR
 0E46:17AC  Res  __DOW
 0E46:17FC  Res  __CMONTH
 0E46:184C  Res  __CDOW
 0E46:189C  Res  __DTOC
 0E46:18DE  Res  __CTOD
 0E46:1924  Res  __DTOS
 0E46:1966  Res  __WORD
 0E46:19A4  Res  __VALTYPE
 0E46:1A40  Res  LEFT
 0FEA:0040  Res  _TB
 0FEA:0092  Res  __IERROR
 0FEA:0140  Res  __AFAIL
 0FEA:01D4  Res  __SODIUM
 0FEA:01E0  Res  __SALTY_DYN
 0FEA:0266  Res  __ECANCEL
 0FEA:02D2  Res  ERRORINHAN
 0FEA:0412  Res  __EGENCODE
 0FEA:0426  Res  __ESEVERIT
 0FEA:043A  Res  __ECANRETR
 0FEA:0452  Res  __ECANDEFA
 0FEA:046A  Res  __ECANSUBS
 0FEA:0482  Res  __ETRIES
 0FEA:0496  Res  __EOSCODE
 0FEA:04AA  Res  __ESUBCODE
 0FEA:04BE  Res  __ESUBSYST
 0FEA:04CA  Res  __EDESCRIP
 0FEA:04D6  Res  __EOPERATI
 0FEA:04E2  Res  __EFILENAM
 0FEA:04EE  Res  __EPARAMS
 0FEA:04FA  Res  __ECARGO
 0FEA:0506  Res  __ESETGENC
 0FEA:05CE  Res  __ESETSUBC
 0FEA:0628  Res  __ESETOSCO
 0FEA:0682  Res  __ESETSEVE
 0FEA:06DC  Res  __ESETCAND
 0FEA:0720  Res  __ESETCANR
 0FEA:0764  Res  __ESETCANS
 0FEA:07A8  Res  __ESETTRIE
 0FEA:0802  Res  __ESETSUBS
 0FEA:0812  Res  __ESETOPER
 0FEA:0822  Res  __ESETDESC
 0FEA:0832  Res  __ESETFILE
 0FEA:0842  Res  __ESETPARA
 0FEA:0852  Res  __ESETCARG
 0FEA:0862  Res  ERRORNEW
 0FEA:0AFA  Res  __EOP
 0FEA:0BB2  Res  __EERROR
 0FEA:0C14  Res  __ENOALIAS
 0FEA:0CC0  Res  __ENOVAR
 0FEA:0D30  Res  __EERRORP
 0FEA:0E44  Res  __EARG
 0FEA:0E60  Res  __ENOTABLE
 0FEA:0EDA  Res  __ENOFUNC
 0FEA:0F50  Res  __EREGNFHANDLER
 0FEA:0F7A  Res  __ENOMETHOD
 0FEA:1028  Res  __EPSTACK
 0FEA:103E  Res  ERRORBLOCK
 0FEA:109E  Res  DOSERROR
 0FEA:10C6  Res  __ESETDOSERROR
 0FEA:10D2  Res  NETERR
 0FEA:1108  Res  __ESETNETERR
 0FEA:1118  Res  __ECLASSNA
 10FC:0006  Res  AEVAL
 1114:025E  Res  __CYCLEF
 1114:04F2  Res  __XALLOC
 1114:058C  Res  __XFREE
 1114:0616  Res  __XGRAB
 1114:0646  Res  __ALLOCF
 1114:0688  Res  __FREEF
 117D:076A  Res  __VMADD
 117D:0B88  Res  __VMPREALLOC
 117D:1458  Res  __VMDISCARD
 117D:1516  Res  __VMFREE
 117D:1538  Res  __VMPTR
 117D:1596  Res  __VMDIRTYPTR
 117D:15F4  Res  __VMTWO
 117D:1704  Res  __VMALLOCF
 117D:173A  Res  __VMALLOC
 117D:1770  Res  __VMALLOCD
 117D:17AC  Res  __VMALLOCO
 117D:17EC  Res  __VMXFR
 117D:1B5C  Res  __VMFIX
 117D:1C50  Res  __VMLOCKOVL
 117D:1D9C  Res  __VMUNLOCKOVL
 117D:1DAA  Res  __VMPENDINGOVL
 117D:1DB8  Res  __VMUNLOCK
 117D:1DC6  Res  __VMLOCK
 117D:1E68  Res  __VMLOCKSEG
 117D:1ED6  Res  __VMSIZE
 117D:1EE6  Res  __VMREALLOC
 117D:204A  Res  __VMXCHG
 117D:20DE  Res  __VMSTAT
 117D:21EA  Res  __VMSTATN
 117D:222C  Res  __VMSTATE
 117D:225A  Res  __V16
 117D:2322  Res  __V32
 117D:24A0  Res  __MEM_RESUME
 117D:24BC  Res  __MEM_SUSPEND
 117D:257C  Res  __MEM_EXIT
 117D:2684  Res  _DSNORMAL
 117D:269E  Res  __EFAULT
 117D:289A  Res  __MEM_INIT2
 117D:28CE  Res  __MEM_INIT
 1447:0008  Res  __KMAPSCAN
 1447:0137  Res  __KMAPSET
 1447:018E  Res  __KMAPCLEAR
 1465:0006  Res  __MEMSUBFREE
 1465:001A  Res  __MEMSUBALLOC
 1465:00AB  Res  __MEMSUBALLOCFIRST
 1465:00BD  Res  __MEMSUBINFO
 1465:0137  Res  __MEMSUBAVAIL
 1465:0146  Res  __MEMSUBMAX
 1465:0157  Res  __MEMSUBEXTENT
 1465:016B  Res  __MEMSUBEMPTY
 1465:0182  Res  __MEMSUBREINIT
 1465:01CF  Res  __MEMSUBINIT
 1465:0208  Res  __MEMSUBNEXT
 1465:024D  Res  __MEMSUBCHECK
 148A:0002  Res  __OSALLOCDEFSEG
 148A:002C  Res  __OSAVAIL
 148A:003C  Res  __OSALLOC
 148A:0050  Res  __OSSIZE
 1490:0008  Res  __OSSTACKBASE
 1490:0EC6  Res  __LEX_
 1490:14F0  Res  __MAC_IMMED
 1490:1632  Res  __DBGMACRO
 1490:16E2  Res  __WAVE_
 1490:17F4  Res  __WAVEPOP_
 1490:1878  Res  __WAVEP_
 1490:18FC  Res  __WAVEL_
 1490:1914  Res  __WAVEA_
 1490:1B32  Res  __WAVEQ_
 1490:1B68  Res  __WAVEPOPQ_
 1490:1BA4  Res  __WAVEF_
 1490:1C22  Res  __WAVEPOPF_
 1490:1CA6  Res  __WSYMBOL_
 1490:2024  Res  __TYPE_
 1490:20DE  Res  _AMBIGBLOCK
 1490:22D4  Res  _DOSTUFF
 1490:2536  Res  __PARSE_
 16F9:000E  Res  __VMACRO
 16F9:0070  Res  __BMACRO
 1705:000E  Res  __PLANK_INIT
 1705:003B  Res  __TPLANK
 1705:0074  Res  _ERRORBUILD
 1705:00E1  Res  _ERRORCYCLE
 1705:0141  Res  __PLANKTON
 1705:01CD  Res  __SPLANKTON
 1705:01EC  Res  __DPLANKTON
 1705:0413  Res  _DBGENTRY
 1705:0431  Res  _DBGEXIT
 1705:044F  Res  __NOCODE
 1705:0457  Res  __DYNBADNEWS
 1705:0462  Res  __0ERR
 1705:046C  Res  __0ENDPROC
 1705:047F  Res  __0NOP
 1705:0482  Res  __0LINE
 1705:04C3  Res  __0EVENTS
 1705:04D7  Res  __0JMP
 1705:04DE  Res  __0JF
 1705:04FC  Res  __0JFPT
 1705:051D  Res  __0JT
 1705:053B  Res  __0JTPF
 1705:055C  Res  __0JDBG
 1705:057C  Res  __0UNDEF
 1705:0584  Res  __0TRUE
 1705:0593  Res  __0FALSE
 1705:05A0  Res  __0NULL
 1705:05B9  Res  __0ZER0
 1705:05CE  Res  __0ONE1
 1705:05E5  Res  __0PUSHW
 1705:05FA  Res  __0PUSHI
 1705:0612  Res  __0PUSHN
 1705:063C  Res  __0PUSHC
 1705:0664  Res  __0PUSHBL
 1705:0696  Res  __0ZZBLOCK
 1705:06A8  Res  __0DO
 1705:0797  Res  __DDO
 1705:0893  Res  __XDO
 1705:08B5  Res  __0FUNC
 1705:09C6  Res  __0XBLOCK
 1705:0A3E  Res  __XEVAL
 1705:0B0A  Res  __0SEND
 1705:0BFB  Res  __0CALL
 1705:0CE0  Res  __0PCOUNT
 1705:0CF8  Res  __0FRAME
 1705:0D41  Res  __0SINIT
 1705:0D69  Res  __0SFRAME
 1705:0D89  Res  __0PUBLICS
 1705:0DA2  Res  __0PRIVATES
 1705:0DBB  Res  __0PARAMS
 1705:0DD4  Res  __0ARRAYATI
 1705:0DFB  Res  __0ARRAYAT
 1705:0E67  Res  __0ARRAYPUTI
 1705:0E8E  Res  __0ARRAYPUT
 1705:0EFA  Res  __0MAKEA
 1705:0F13  Res  __0MAKELA
 1705:0F2C  Res  __0PUSHL
 1705:0F71  Res  __0POPL
 1705:0FBF  Res  __0PUSHLR
 1705:0FD8  Res  __0PUSHFL
 1705:1020  Res  __0POPFL
 1705:1068  Res  __0PUSHFLR
 1705:1092  Res  __0PUSHS
 1705:10A9  Res  __0POPS
 1705:10C0  Res  __0PUSHSR
 1705:10D9  Res  __0PUSHM
 1705:1101  Res  __0MPUSHM
 1705:111F  Res  __0POPM
 1705:1147  Res  __0MPOPM
 1705:1165  Res  __0PUSHMR
 1705:118D  Res  __0MPUSHMR
 1705:11AB  Res  __0PUSHF
 1705:11D3  Res  __0MPUSHF
 1705:11F1  Res  __0POPF
 1705:1219  Res  __0MPOPF
 1705:1237  Res  __0PUSHQF
 1705:125F  Res  __0MPUSHQF
 1705:127D  Res  __0POPQF
 1705:12A5  Res  __0MPOPQF
 1705:12C3  Res  __0PUSHV
 1705:12EB  Res  __0MPUSHV
 1705:1309  Res  __0PUSHRV
 1705:1327  Res  __0SAVE_RET
 1705:132E  Res  __0DOOP
 1705:1334  Res  __0QSELF
 1705:133E  Res  __0POP
 1705:1344  Res  __0PUSHA
 1705:139D  Res  __0MPUSHA
 1705:13BF  Res  __0PUSHP
 1705:13C2  Res  __0MPUSHP
 1705:13C5  Res  __0SYMBOL
 1705:13E9  Res  __0SYMF
 1705:1412  Res  __0MSYMBOL
 1705:1428  Res  __0MSYMF
 1705:1443  Res  __0BEGIN_SEQ
 1705:146A  Res  __0BREAK
 1705:1471  Res  __0END_SEQ
 1705:1484  Res  _COERCENUMS
 1705:14FB  Res  _COERCEDNUMS
 1705:15AB  Res  __0JNEI
 1705:15EB  Res  __0JISW
 1705:162B  Res  __XEQ
 1705:1658  Res  __0EEQ
 1705:1761  Res  __0EQ
 1705:182A  Res  __0NE
 1705:18F6  Res  __0LT
 1705:19B2  Res  __XLT
 1705:19E7  Res  __0LE
 1705:1AA3  Res  __0GT
 1705:1B5F  Res  __0GE
 1705:1C1B  Res  __0NOT
 1705:1C2F  Res  __0AND
 1705:1C4C  Res  __0OR
 1705:1C69  Res  __0NEGATE
 1705:1CC8  Res  __0ABS
 1705:1D31  Res  __0PLUS
 1705:1EAA  Res  __0MINUS
 1705:1F89  Res  __0MULT
 1705:200B  Res  __0DIVIDE
 1705:20A6  Res  __0DEC
 1705:2109  Res  __0INC
 191B:000C  Res  __INSTD_
 191D:00BE  Res  __GTWCREATE
 191D:0120  Res  __GTWDESTROY
 191D:0174  Res  __GTWFLASH
 191D:0254  Res  __GTWAPP
 191D:0268  Res  __GTWCURRENT
 191D:037A  Res  __GTWPOS
 191D:03AC  Res  __GTWVIS
 191D:04FC  Res  __GTMODALREAD
 191D:0F1E  Res  __GTSLR
 191D:0F90  Res  DISPBEGIN
 191D:0F96  Res  DISPEND
 191D:0F9C  Res  DISPCOUNT
 191D:0FBE  Res  __GTSCRDIM
 191D:0FD8  Res  __GTISCOLOR
 191D:0FE8  Res  __GTMAXROW
 191D:0FF2  Res  __GTMAXCOL
 191D:0FFC  Res  __GTSETCURSOR
 191D:101C  Res  __GTGETCURSOR
 191D:1032  Res  __GTSETPOS
 191D:1054  Res  __GTGETPOS
 191D:1078  Res  __GTSETCOLOR
 191D:10A8  Res  __GTGETCOLOR
 191D:10CC  Res  __GTSETBORDER
 191D:112C  Res  __GTBEGINWRITE
 191D:12F8  Res  __GTENDWRITE
 191D:13F4  Res  __GTSCROLL
 191D:147A  Res  __GTWRITEAT
 191D:14E4  Res  __GTWRITE
 191D:1510  Res  __GTWRITECON
 191D:16AA  Res  __GTREPCHAR
 191D:16FC  Res  __GTRECTSIZE
 191D:1740  Res  __GTSAVE
 191D:179A  Res  __GTREST
 191D:17F4  Res  __GTBOX
 191D:1862  Res  __GTBOXS
 191D:1880  Res  __GTBOXD
 191D:189E  Res  __GTSETSNOWFLAG
 191D:18D6  Res  __GTSETBLINK
 191D:18F6  Res  __GTFLUSHCURSOR
 191D:190A  Res  __GTPREEXT
 191D:193C  Res  __GTPOSTEXT
 191D:19A6  Res  __GTSETMODE
 191D:19FA  Res  __GTDISPCOUNT
 191D:1A12  Res  __GTDISPBEGIN
 191D:1A36  Res  __GTDISPEND
 1AC1:0006  Res  _SETLASTTRAN
 1AC1:0018  Res  __DBGTERMX
 1AC1:0232  Res  __INKEY0
 1AC1:0254  Res  _NOW
 1AC1:02A6  Res  __INKEY1
 1AC1:03A8  Res  NEXTKEY
 1AC1:0418  Res  LASTKEY
 1AC1:04C2  Res  __KEYBOARD
 1AC1:0610  Res  SETKEY
 1AC1:06E6  Res  __MODAL_KEY
 1AC1:080C  Res  __PCOL
 1AC1:081C  Res  __PROW
 1AC1:082C  Res  SETPRC
 1AC1:0A62  Res  __EJECT
 1AC1:0BCA  Res  __CQOUT
 1AC1:0BF0  Res  QQOUT
 1AC1:0CB6  Res  QOUT
 1AC1:0CCC  Res  __XSETCURSOR
 1AC1:0D0A  Res  __SETPOS
 1AC1:0D58  Res  __SETPOSBS
 1AC1:0D90  Res  DISPOUT
 1AC1:0E6A  Res  __DEVPOS
 1AC1:0EF2  Res  DEVOUT
 1AC1:0FF2  Res  __ROW
 1AC1:101C  Res  __COL
 1AC1:139C  Res  __XHELP
 1AC1:14DA  Res  __TERMSLR
 1AC1:158A  Res  __PRINTOUT
 1AC1:15B0  Res  __CONOUT
 1C2E:000E  Res  DISPBOX
 1C47:0004  Res  __TCVT
 1C60:0006  Res  _CPARSE
 1C60:0250  Res  _SPARSE
 1C60:0356  Res  __XSETCOLOR
 1C60:05DE  Res  SETCOLOR
 1C60:05F8  Res  SETBLINK
 1C60:06FE  Res  COLORSELEC
 1CD2:0002  Res  SETCURSOR
 1CD3:000C  Res  __PARSEATS
 1CD3:01AC  Res  __PICTLITERAL
 1CD3:0266  Res  __DATETEMPLATE
 1CD3:0882  Res  __TBUFFPREP
 1CD3:093A  Res  __ZZTRAN
 1CD3:0CCC  Res  __ZTRAN
 1CD3:0E3C  Res  __XTRAN
 1CD3:0E7C  Res  __YTRAN
 1CD3:0EBE  Res  __TRANS
 1CD3:0F38  Res  DEVOUTPICT
 1CD3:1006  Res  TRANSFORM
 1DD3:005E  Res  __ISRDD
 1DD3:0288  Res  __ISRDDTYPE
 1DD3:0530  Res  __DBUNLOADALL
 1DD3:05EC  Res  __RDDDISINHERIT
 1DD3:063C  Res  __RDDINHERIT
 1DD3:06FE  Res  __XFTABLEGETPTR
 1DD3:0750  Res  __XFTABLEDISCARDPTR
 1DD3:07F4  Res  __RDDSERVERSHUTDOWN
 1DD3:0822  Res  RDDREGISTE
 1DD3:08D4  Res  RDDLIST
 1DD3:09EC  Res  __RDDEXTENDTYPE
 1DD3:0A88  Res  __RDDFIELDTYPE
 1E85:000A  Res  __XPARAMERROR
 1E85:0024  Res  __XNOTABLEERROR
 1E85:003A  Res  __XSELECT
 1E85:00CC  Res  __STRIMTOUPPER
 1FFE:000E  Res  __EMMALLOCPAGES
 2000:0004  Res  __EMMCONTEXTSAVE
 2000:0014  Res  __EMMCONTEXTREST
 2002:0004  Res  __EMMDEALLOCPAGES
 2003:0004  Res  __EMMMAPUNMAPPAGE
 2004:000E  Res  __EMMGETPAGEFRAMESEG
 2006:0008  Res  __EMMGETVERSION
 2008:0000  Res  __BEEP_
 218A:000C  Res  _NSXTAGVALTOKEY
 218A:010C  Res  _NSXTAGSKIP
 218A:077A  Res  _NSXKEYSEEK
 218A:10B0  Res  _NSXTAGGOTO
 218A:1158  Res  _NSXTAGINSERTKEY
 218A:1816  Res  __NSXGETPARENTKEY
 218A:273E  Res  _NSXTAGDELETEKEY
 218A:2EF8  Res  __NSXGOCOLD
 218A:3280  Res  _NSXTAGGOTOP
 218A:32C6  Res  _NSXTAGGOBOTTOM
 218A:330E  Res  _NSXTAGGOSELF
 218A:3478  Res  _NSXTAGSEEK
 218A:3598  Res  __NSXKEYREFRESH
 218A:3688  Res  _NSXCOMPRESSKEY
 218A:388C  Res  _NSXEXPANDKEY
 218A:39C4  Res  _NSXKEYFORWARD
 218A:3A6C  Res  __NSXITEMRECNO
 218A:3AAE  Res  __NSXSPLITRECNO
 2537:0008  Res  __SWDOERROR
 2537:00DE  Res  _SXDBFREAD
 2537:03C2  Res  _SXDBFWRITE
 2537:0644  Res  _SXDBFWRITEHEADER
 2537:077E  Res  _GET_RECCOUNT
 2537:07BA  Res  __SXDBFGOHOT
 2537:0824  Res  __SXDBFGOCOLD
 2537:088A  Res  __SXDBFGOTOID
 2537:08D4  Res  __SXDBFGOTO
 2537:09E6  Res  __SXDBFGOTOP
 2537:0A2A  Res  __SXDBFGOBOTTOM
 2537:0A9E  Res  __SXDBFSKIPRAW
 2537:0B0C  Res  __SXDBFSKIP
 2537:0BD4  Res  __SXDBFFLUSH
 2537:0CE2  Res  __SXDBFCLOSE
 2537:0F94  Res  __SXDBFSETFIELDEXTENT
 2537:0FCE  Res  __SXDBFADDFIELD
 2537:13FE  Res  __SWDEFALIAS
 2537:1490  Res  __SXDBFOPEN
 2537:1828  Res  __SXDBFCREATE
 2537:1BAA  Res  __SXDBFNEW
 2537:1BD6  Res  __SXDBFGETVARLEN
 2537:1C46  Res  __SXDBFGETVALUE
 2537:1EAA  Res  __SXDBFPUTVALUE
 2537:21D8  Res  __SXDBFBOF
 2537:220E  Res  __SXDBFEOF
 2537:2244  Res  __SXDBFFOUND
 2537:227A  Res  __SXDBFLOCK
 2537:22DC  Res  __SXDBFFLOCK
 2537:238C  Res  __SXDBFAPPEND
 2537:266E  Res  __SXDBFPUTREC
 2537:26B4  Res  __SXDBFTRANSREC
 2537:2782  Res  __SXDBFTRANS
 27B7:000E  Res  __SWOURDRIVER
 27B7:013E  Res  ___DBL2X
 27D1:0000  Res  __TCREAT
 27D1:0016  Res  __TUNLINK
 27D1:002A  Res  __TOPEN
 27D1:0040  Res  __TCLOSE
 27D1:0050  Res  __TREAD
 27D1:006A  Res  __TWRITE
 27D1:0084  Res  __TLSEEK
 27D1:009E  Res  __TRENAME
 27D1:00B8  Res  __TLOCK
 27D1:00D8  Res  __TCOMMIT
 27DF:0008  Res  __ERRNEW
 27DF:0022  Res  __ERRLAUNCH
 27DF:0044  Res  __ERRRELEASE
 27DF:0068  Res  __ERRPUTSEVERITY
 27DF:007A  Res  __ERRPUTGENCODE
 27DF:008E  Res  __ERRPUTOSCODE
 27DF:00A2  Res  __ERRPUTFLAGS
 27DF:00B6  Res  __ERRPUTTRIES
 27DF:00CA  Res  __ERRPUTSUBCODE
 27DF:00DE  Res  __ERRPUTSUBSYSTEM
 27DF:00F8  Res  __ERRPUTDESCRIPTION
 27DF:0112  Res  __ERRPUTOPERATION
 27DF:0138  Res  __ERRPUTFILENAME
 27DF:0152  Res  __ERRGETSEVERITY
 27DF:015E  Res  __ERRGETGENCODE
 27DF:016A  Res  __ERRGETOSCODE
 27DF:0176  Res  __ERRGETFLAGS
 27DF:0182  Res  __ERRGETTRIES
 27DF:018E  Res  __ERRGETSUBCODE
 27DF:019A  Res  __ERRGETSUBSYSTEM
 27DF:01AA  Res  __ERRGETDESCRIPTION
 27DF:01BA  Res  __ERRGETOPERATION
 27DF:01CA  Res  __ERRGETFILENAME
 27FC:000A  Res  __XVALLOC
 27FC:0062  Res  __XVFREE
 27FC:008E  Res  __XVREALLOC
 27FC:00F6  Res  __XVLOCK
 27FC:0140  Res  __XVWIRE
 27FC:0186  Res  __XVUNLOCK
 27FC:01D4  Res  __XVUNWIRE
 27FC:01E4  Res  __XVLOCKCOUNT
 27FC:0222  Res  __XVSIZE
 27FC:0260  Res  __XVHEAPNEW
 27FC:02CE  Res  __XVHEAPDESTROY
 27FC:02DE  Res  __XVHEAPRESIZE
 27FC:03D0  Res  __XVHEAPALLOC
 27FC:0426  Res  __XVHEAPFREE
 27FC:0476  Res  __XVHEAPLOCK
 27FC:04E4  Res  __XVHEAPUNLOCK
 284F:0008  Res  __DYN_INIT
 284F:0013  Res  __DYN_RELEASE
 284F:001A  Res  __DYN_GETNBRPAGES
 284F:0052  Res  __DYN_GETPAGE
 284F:00B7  Res  __DYN_FNAME
 2862:053E  Res  __DYNX_READ
 2862:0688  Res  __DYNXSLR
 28D3:0078  Res  __ITEMSIZE
 28D3:00B8  Res  __ITEMRELEASE
 28D3:00D6  Res  __ITEMNEW
 28D3:00E6  Res  __ITEMTYPE
 28D3:00F4  Res  __ITEMPUTL
 28D3:0124  Res  __ITEMPUTCL
 28D3:0164  Res  __ITEMPUTC
 28D3:018C  Res  __ITEMCOPYC
 28D3:01D4  Res  __ITEMPUTNL
 28D3:0206  Res  __ITEMPUTND
 28D3:0250  Res  __ITEMPUTDS
 28D3:02A6  Res  __ITEMGETC
 28D3:02B4  Res  __ITEMFREEC
 28D3:02CA  Res  __ITEMGETNL
 28D3:02D8  Res  __ITEMGETL
 28D3:02E4  Res  __ITEMGETDS
 28D3:030C  Res  __ITEMGETND
 28D3:0372  Res  __ITEMPARAM
 28D3:03AA  Res  __ITEMRETURN
 28D3:03CE  Res  __ITEMARRAYNEW
 28D3:03EC  Res  __ITEMARRAYGET
 28D3:042A  Res  __ITEMARRAYPUT
 28D3:0458  Res  __EVALNEW
 28D3:047E  Res  __EVALPUTPARAM
 28D3:049C  Res  __EVALLAUNCH
 28D3:05CA  Res  __EVALRELEASE
 2936:0006  Pag  ADR_ADAP
 2936:000D  Pag  CONVERTE
 2936:0014  Pag  TRATADIR
 2936:001B  Pag  DRVEXISTE
 2936:0022  Pag  VE_CAMPOS
 2936:0029  Pag  HELP
 2936:0030  Pag  CAPTURADIR
 2936:0037  Pag  ESCOLHIDOU
 2936:003E  Pag  LSTARQDIR
 2936:004C  Pag  RDDSYS
 2936:0053  Pag  SIXTOOLS
 2936:005A  Pag  ODOMETER
 2936:0068  Pag  ADR_ATRI
 2936:006F  Pag  ADR_ATR1
 2936:0076  Pag  ADR_ATR2
 2936:007D  Pag  ADR_ESTR
 2936:0084  Pag  BXR_ESTR
 2936:008B  Pag  ALE_ESTR
 2936:0092  Pag  GRU_ESTR
 2936:0099  Pag  TAX_ESTR
 2936:00A0  Pag  ECO_ESTR
 2936:00A7  Pag  INS_ESTR
 2936:00AE  Pag  GUI_ESTR
 2936:00B5  Pag  AFU_ESTR
 2936:00BC  Pag  IMP_ESTR
 2936:00C3  Pag  MED_ESTR
 2936:00CA  Pag  TES_ESTR
 2936:00D1  Pag  JUR_ESTR
 2936:00D8  Pag  TFI_ESTR
 2936:00DF  Pag  ARQ_ESTR
 2936:00E6  Pag  REG_ESTR
 2936:00ED  Pag  COB_ESTR
 2936:00F4  Pag  CLA_ESTR
 2936:00FB  Pag  CIR_ESTR
 2936:0102  Pag  CPR_ESTR
 2936:0109  Pag  PRC_ESTR
 2936:0110  Pag  FNC_ESTR
 2936:0117  Pag  HIS_ESTR
 2936:011E  Pag  CST_ESTR
 2936:0125  Pag  MEN_ESTR
 2936:012C  Pag  ORD_ESTR
 2936:0133  Pag  PAR_ESTR
 2936:013A  Pag  READMODAL
 2936:0141  Pag  GETREADER
 2936:0148  Pag  AJUSTA_PIC
 2936:014F  Pag  GETAPPLYKE
 2936:0156  Pag  GETPREVALI
 2936:015D  Pag  GETPOSTVAL
 2936:0164  Pag  GETDOSETKE
 2936:018E  Pag  __SETFORMA
 2936:0195  Pag  __KILLREAD
 2936:019C  Pag  GETACTIVE
 2936:01A3  Pag  UPDATED
 2936:01AA  Pag  READEXIT
 2936:01B1  Pag  READINSERT
 2936:01C6  Pag  RANGECHECK
 2936:01CD  Pag  READKILL
 2936:01D4  Pag  STORECARGO
 2936:01DB  Pag  STOREALL
 2936:01E9  Pag  EDIMEMO
 2936:01F0  Pag  MFUNC
 2936:01F7  Pag  EDBF
 2936:01FE  Pag  CARDTYPE
 2936:0205  Pag  DBOX
 2936:0221  Pag  JOGANOBUFF
 2936:0228  Pag  NOVAPOSI
 2936:022F  Pag  Q_TEC
 2936:0236  Pag  LPAD
 2936:023D  Pag  CAIXA
 2936:0244  Pag  NSEM
 2936:024B  Pag  ALERTA
 2936:0252  Pag  PARSE
 2936:0259  Pag  INVCOR
 2936:0260  Pag  MUDA_PJ
 2936:0267  Pag  MON_JAN_MO
 2936:026E  Pag  MOUSECUR
 2936:0275  Pag  MOUSEBOX
 2936:027C  Pag  MOUSEGET
 2936:0283  Pag  MOUSESET
 2936:028A  Pag  NEXT_KEY
 2936:0291  Pag  IN_KEY
 2936:029F  Pag  MONTA_BUFF
 2936:02A6  Pag  KEYB_MAC
 2936:02AD  Pag  KEYBUFF
 2936:02B4  Pag  INKY
 2936:02BB  Pag  POEHORA
 2936:02C2  Pag  RESTSCR
 2936:02C9  Pag  NAOPISCA
 2936:02D0  Pag  EXTENSAO
 2936:02DE  Pag  SYSINIT
 2936:02E5  Pag  ERRORSYS
 2936:02FA  Pag  __SETCENTU
 2936:0301  Pag  __XSAVESCR
 2936:0308  Pag  __XRESTSCR
 2936:0316  Pag  __SETHELPK
 2936:031D  Pag  GETNEW
 2936:0324  Pag  __GETHASFO
 2936:032B  Pag  __GETBUFFE
 2936:0332  Pag  __GETORIGI
 2936:0339  Pag  __GETSETCA
 2936:0340  Pag  __GETSETBL
 2936:0347  Pag  __GETSETNA
 2936:034E  Pag  __GETSETPI
 2936:0355  Pag  __GETSETPB
 2936:035C  Pag  __GETSETPR
 2936:0363  Pag  __GETSETSU
 2936:036A  Pag  __GETSETEX
 2936:0371  Pag  __GETSETRE
 2936:0378  Pag  __GETSETBU
 2936:037F  Pag  __GETBADDA
 2936:0386  Pag  __GETUNDO
 2936:038D  Pag  __GETTODEC
 2936:0394  Pag  __GETDWLEF
 2936:039B  Pag  READVAR
 2936:03A9  Pag  _DTXCONDSE
 2936:03B0  Pag  DBCREATEIN
 2936:03B7  Pag  DBSETINDEX
 2936:03BE  Pag  DBCLEARIND
 2936:03C5  Pag  DBREINDEX
 2936:03CC  Pag  DBSETORDER
 2936:03D3  Pag  INDEXEXT
 2936:03DA  Pag  INDEXKEY
 2936:03E8  Pag  __DBCOPY
 2936:03EF  Pag  __DBAPP
 2936:03F6  Pag  __FLEDIT
 2936:0404  Pag  AFILL
 2936:040B  Pag  ACLONE
 2936:0420  Pag  SIXNSX
 2936:0427  Pag  SX_DEFTRIG
 2936:042E  Pag  BLICALC50
 2936:0435  Pag  BLIMEMAVL
 2936:043C  Pag  BLIMEMMAX
 2936:0443  Pag  BLPRFPRG
 2936:044A  Pag  BLERRC50
 297C:000E  Ovl  __GETENV
 297C:001A  Ovl  __AWK
 297C:0020  Ovl  __SQU
 297C:002C  Ovl  __QUIT
 297C:0032  Ovl  __SYSINIT
 297C:0038  Ovl  __SYSSUSPEND
 297C:003E  Ovl  __SYSRESUME
 297C:0044  Ovl  __SYSEXIT
 297C:004A  Ovl  __SYSLEVEL
 297C:0050  Ovl  __SYSERRORLEVEL
 297C:0056  Ovl  __SYSPOSTARGS
 297C:005C  Ovl  ERRORLEVEL
 297C:0068  Ovl  __APPINITREGISTER
 297C:006E  Ovl  __APPMAIN
 297C:0098  Ovl  __APPEXITREGISTER
 297C:009E  Ovl  __APPEXIT
 297C:00AA  Ovl  __ISENDP
 297C:00B0  Ovl  __CLASSSEL
 297C:00B6  Ovl  __CLASSINS
 297C:00BC  Ovl  __MDCREATE
 297C:00C8  Ovl  __MDADD
 297C:00CE  Ovl  __MDASSOCIATE
 297C:00E0  Ovl  __CLASSNEW
 297C:00E6  Ovl  __CLASSADD
 297C:00F8  Ovl  __CLASSNAM
 297C:0104  Ovl  __TBNAME
 297C:010A  Ovl  PROCNAME
 297C:0110  Ovl  PROCLINE
 297C:0116  Ovl  PROCFILE
 297C:011C  Ovl  ACOPY
 297C:0122  Ovl  AINS
 297C:013A  Ovl  __MSAVE
 297C:0140  Ovl  __MRESTORE
 297C:0152  Ovl  __CREATEERRORDICT
 297C:0164  Ovl  __IENDSEQ
 297C:016A  Ovl  __END_SEQ
 297C:0170  Ovl  __SEQREG
 297C:0176  Ovl  __IBEGINSEQ
 297C:017C  Ovl  __IBREAKCONT
 297C:0188  Ovl  _MALLOC
 297C:018E  Ovl  _FREE
 297C:0194  Ovl  __FMALLOC
 297C:019A  Ovl  __FFREE
 297C:01A0  Ovl  __NMALLOC
 297C:01A6  Ovl  __NFREE
 297C:01BE  Ovl  __COUTSTD
 297C:01C4  Ovl  __ERRMSG
 297C:01CA  Ovl  __COUTERR
 297C:01D0  Ovl  __ERRMSGN
 297C:01D6  Ovl  __NONOALER
 297C:01DC  Ovl  OUTSTD
 297C:01E2  Ovl  ALERT
 297C:01E8  Ovl  OUTERR
 297C:01EE  Ovl  __OUTINI
 297C:01FA  Ovl  MAXROW
 297C:0200  Ovl  MAXCOL
 297C:020C  Ovl  SAVESCREEN
 297C:0212  Ovl  RESTSCREEN
 297C:0218  Ovl  SCROLL
 297C:022A  Ovl  __GETSETUP
 297C:0230  Ovl  __GETCLASS
 297C:023C  Ovl  __GETCDISP
 297C:0242  Ovl  __TOGET
 297C:0248  Ovl  __GETROW
 297C:0254  Ovl  __GETCOL
 297C:025A  Ovl  _DISPLAYTHEGET
 297C:0260  Ovl  _GETGETCONTEXT
 297C:0266  Ovl  _SETGETCONTEXT
 297C:026C  Ovl  __GETSETRO
 297C:0272  Ovl  __GETSETCO
 297C:0278  Ovl  __GETVARGE
 297C:027E  Ovl  __GETVARPU
 297C:0284  Ovl  __GET
 297C:028A  Ovl  __GETA
 297C:0296  Ovl  __GETCOLOR
 297C:029C  Ovl  __GETSETCS
 297C:02B4  Ovl  __GETTYPE
 297C:02C0  Ovl  __GETSETFO
 297C:02D2  Ovl  __GETPOS
 297C:02DE  Ovl  __GETINSER
 297C:02EA  Ovl  __GETDECPO
 297C:02F0  Ovl  __GETOVERS
 297C:02FC  Ovl  __GETCHANG
 297C:0302  Ovl  __GETKILLF
 297C:0308  Ovl  __GETCLEAR
 297C:030E  Ovl  __GETLEFT
 297C:0314  Ovl  __GETRIGHT
 297C:0320  Ovl  __GETASSIG
 297C:0326  Ovl  __GETMINUS
 297C:032C  Ovl  __GETHOME
 297C:0338  Ovl  __GETEND
 297C:033E  Ovl  __GETTYPEO
 297C:0344  Ovl  __GETWORDL
 297C:0350  Ovl  __GETWORDR
 297C:0356  Ovl  __GETREJEC
 297C:035C  Ovl  __GETDELET
 297C:0368  Ovl  __GETWORDD
 297C:036E  Ovl  __GETSETPO
 297C:0374  Ovl  __GETRITED
 297C:037A  Ovl  __GETBACKS
 297C:0380  Ovl  __GETUPDAT
 297C:0386  Ovl  __GETSETCH
 297C:039E  Ovl  __GETUNTRA
 297C:03B0  Ovl  __GETREFOR
 297C:03B6  Ovl  __GETSETCL
 297C:03BC  Ovl  __GETRESET
 297C:03CE  Ovl  __GETSETMI
 297C:03D4  Ovl  __GETDISPL
 297C:03E0  Ovl  ORDFOR
 297C:03E6  Ovl  ORDLISTADD
 297C:03EC  Ovl  ORDCONDSET
 297C:03F2  Ovl  ORDDESTROY
 297C:03F8  Ovl  ORDLISTCLE
 297C:03FE  Ovl  ORDCREATE
 297C:0404  Ovl  ORDLISTREB
 297C:040A  Ovl  ORDSETFOCU
 297C:0410  Ovl  ORDBAGEXT
 297C:041C  Ovl  ORDBAGNAME
 297C:0422  Ovl  ORDNAME
 297C:0428  Ovl  ORDNUMBER
 297C:042E  Ovl  ORDKEY
 297C:0434  Ovl  INDEXORD
 297C:0446  Ovl  RDDNAME
 297C:044C  Ovl  __DBCMDSLR
 297C:0452  Ovl  RDDSETDEFA
 297C:0458  Ovl  DBSETDRIVE
 297C:045E  Ovl  DBCLOSEALL
 297C:0464  Ovl  DBCLOSEARE
 297C:046A  Ovl  DBUSEAREA
 297C:0470  Ovl  __DEFDRIVER
 297C:0476  Ovl  DBTABLEEXT
 297C:0482  Ovl  DBAPPEND
 297C:0488  Ovl  __FLOCK
 297C:048E  Ovl  DBDELETE
 297C:0494  Ovl  __AXPROUT
 297C:049A  Ovl  __EOF
 297C:04A0  Ovl  DBSELECTAR
 297C:04A6  Ovl  DBRECALL
 297C:04AC  Ovl  __BOF
 297C:04B2  Ovl  __DBPACK
 297C:04B8  Ovl  DBEVAL
 297C:04BE  Ovl  __FOUND
 297C:04C4  Ovl  __DBZAP
 297C:04CA  Ovl  __DELETED
 297C:04D0  Ovl  DBSEEK
 297C:04D6  Ovl  DBCOMMIT
 297C:04DC  Ovl  __RECNO
 297C:04E2  Ovl  DBCOMMITAL
 297C:04E8  Ovl  __LASTREC
 297C:04EE  Ovl  __FIELDNAME
 297C:04F4  Ovl  DBUNLOCK
 297C:04FA  Ovl  DBUNLOCKAL
 297C:0500  Ovl  DBSKIP
 297C:0506  Ovl  __FCOUNT
 297C:050C  Ovl  __FSELECT0
 297C:0512  Ovl  DBRLOCKLIS
 297C:0518  Ovl  __FSELECT1
 297C:051E  Ovl  DBGOTOP
 297C:0524  Ovl  DBRLOCK
 297C:0530  Ovl  USED
 297C:0536  Ovl  DBGOBOTTOM
 297C:053C  Ovl  ALIAS
 297C:0548  Ovl  DBGOTO
 297C:054E  Ovl  DBRUNLOCK
 297C:0554  Ovl  __AXPRIN
 297C:055A  Ovl  __LOCK
 297C:0560  Ovl  __V2ALIAS
 297C:0566  Ovl  __XAPPEND
 297C:0572  Ovl  __DBTRANS
 297C:0578  Ovl  __DBTRANSR
 297C:057E  Ovl  __DBFIELDINDEX
 297C:0584  Ovl  ___DBBUILDTRANS
 297C:0596  Ovl  DBSTRUCT
 297C:05AE  Ovl  __DBOPENSD
 297C:05B4  Ovl  DBCREATE
 297C:05C0  Ovl  FSEEK
 297C:05C6  Ovl  FCREATE
 297C:05CC  Ovl  FERASE
 297C:05D2  Ovl  FOPEN
 297C:05D8  Ovl  FRENAME
 297C:05DE  Ovl  FERROR
 297C:05E4  Ovl  FCLOSE
 297C:05EA  Ovl  FREAD
 297C:05F0  Ovl  FREADSTR
 297C:05F6  Ovl  FWRITE
 297C:0602  Ovl  __EMMGETALLOCPAGECOUNT
 297C:0608  Ovl  __EMMGETTOTALPAGECOUNT
 297C:060E  Ovl  __EMMGETUNALLOCPAGECOUNT
 297C:061A  Ovl  __EMMINSTALLED
 297C:0620  Ovl  __EXACTCMP
 297C:062C  Ovl  CURDIR
 297C:0632  Ovl  ISPRINTER
 297C:0638  Ovl  TONE
 297C:063E  Ovl  I2BIN
 297C:0644  Ovl  BIN2I
 297C:064A  Ovl  L2BIN
 297C:0650  Ovl  BIN2L
 297C:0656  Ovl  BIN2W
 297C:065C  Ovl  ALLTRIM
 297C:0662  Ovl  RIGHT
 297C:0668  Ovl  RAT
 297C:066E  Ovl  PADL
 297C:0674  Ovl  PADR
 297C:067A  Ovl  PADC
 297C:0680  Ovl  STRTRAN
 297C:0698  Ovl  STUFF
 297C:069E  Ovl  MEMOLINE
 297C:06A4  Ovl  MLCOUNT
 297C:06B0  Ovl  _LINELEN
 297C:06B6  Ovl  _FETCHAR
 297C:06C2  Ovl  _ASCANSUB
 297C:06C8  Ovl  ASCAN
 297C:06E0  Ovl  DIRECTORY
 297C:0710  Ovl  MEMOEDIT
 297C:081E  Ovl  _SIXOPTIMIZE4SPEED
 297C:0824  Ovl  __NSXWEP
 297C:082A  Ovl  __NSXPLACEKEYP
 297C:0830  Ovl  __NSXNEW
 297C:0836  Ovl  _NSXINIT
 297C:083C  Ovl  __NSXGETFUNCTABLE
 297C:0848  Ovl  __NSXFLUSH
 297C:084E  Ovl  __NSXFORCEREL
 297C:0854  Ovl  __NSXSORT
 297C:085A  Ovl  __NSXORDERLISTCLEAR
 297C:0860  Ovl  __NSXSTRUCTSIZE
 297C:0866  Ovl  __NSXORDERBAGEXT
 297C:086C  Ovl  __NSXORDERINFO
 297C:0872  Ovl  __NSXGOTOP
 297C:0878  Ovl  __NSXGOHOT
 297C:087E  Ovl  __NSXGOBOTTOM
 297C:0884  Ovl  __NSXGOTO
 297C:088A  Ovl  __NSXGOTOID
 297C:0890  Ovl  __NSXSYSNAME
 297C:0896  Ovl  __NSXPACK
 297C:089C  Ovl  __NSXZAPTABLE
 297C:08A8  Ovl  __NSXINDEXEXPR
 297C:08B4  Ovl  __NSXOPEN
 297C:08BA  Ovl  __NSXCLOSE
 297C:08C0  Ovl  __NSXORDERCREATE
 297C:08C6  Ovl  __NSXORDERLISTADD
 297C:08DE  Ovl  __NSXORDERLISTREBUILD
 297C:0902  Ovl  _NSXINDEXCREATE
 297C:0908  Ovl  __NSXISREINDEX
 297C:090E  Ovl  __NSXPLACEKEY
 297C:098C  Ovl  _NSXINDEXGROW
 297C:0992  Ovl  _NSXINDEXSHRINK
 297C:099E  Ovl  _NSXINDEXOPEN
 297C:09B0  Ovl  _NSXTAGLOCK
 297C:09B6  Ovl  _NSXLOCK
 297C:09BC  Ovl  _NSXUNLOCK
 297C:09C8  Ovl  _NSXTAGUNLOCK
 297C:09CE  Ovl  __NSXTAGFINDKEY
 297C:0A3A  Ovl  __SMTAMEMOSIZE
 297C:0A40  Ovl  __SMTARRAYTOMEMO
 297C:0A46  Ovl  __SMTWRITEARRAY
 297C:0A4C  Ovl  __SMTMEMOTOARRAY
 297C:0A64  Ovl  _SXDBFINIT
 297C:0A6A  Ovl  __SXDBFPLACERECP
 297C:0A70  Ovl  __SXDBFGETFUNCTABLE
 297C:0A7C  Ovl  __SXDBFRECCOUNT
 297C:0A82  Ovl  __SXDBFCHILDSYNC
 297C:0A88  Ovl  __SXDBFSYSNAME
 297C:0A8E  Ovl  __SXDBFPACK
 297C:0A94  Ovl  __SXDBFSTRUCTSIZE
 297C:0A9A  Ovl  __SXDBFCHILDEND
 297C:0AA0  Ovl  __SXDBFCHILDSTART
 297C:0AA6  Ovl  __SXDBFZAP
 297C:0AAC  Ovl  __SXDBFDELETE
 297C:0AB2  Ovl  __SXDBFRECALL
 297C:0AB8  Ovl  __SXDBFPLACEREC
 297C:0ABE  Ovl  __SXDBFINFO
 297C:0AC4  Ovl  __SXDBFSORT
 297C:0AD0  Ovl  __SXDBFDELETED
 297C:0AD6  Ovl  __SXDBFFORCEREL
 297C:0ADC  Ovl  __SXDBFSETFILTER
 297C:0AE2  Ovl  __SXDBFRECNO
 297C:0AEE  Ovl  SX_ENCRYPT
 297C:0AF4  Ovl  SX_DECRYPT
 297C:0AFA  Ovl  __SX_ENCRYPT
 297C:0B00  Ovl  __SX_SETSEED
 297C:0B06  Ovl  SX_SETPASS
 297C:0B0C  Ovl  __SX_DECRYPT
 297C:0B12  Ovl  __SX_SETKEY
 297C:0B1E  Ovl  __SWOPENER
 297C:0B24  Ovl  _SWFLENGTH
 297C:0B30  Ovl  SX_ISREIND
 297C:0B36  Ovl  SX_KEYSINC
 297C:0B3C  Ovl  SX_STEP
 297C:0B42  Ovl  SX_I_INDEX
 297C:0B48  Ovl  SX_I_TAGNA
 297C:0B54  Ovl  __SWORDERASNUMBER
 297C:0B5A  Ovl  __SWORDERLISTFOCUS
 297C:0B60  Ovl  __SWORDSET
 297C:0B66  Ovl  _SWINDEXCLOSE
 297C:0B6C  Ovl  __SWNUKETAG
 297C:0B72  Ovl  __SWADJUSTLIST
 297C:0B7E  Ovl  __SWSEEK
 297C:0B84  Ovl  __SWSKIPRAW
 297C:0B90  Ovl  SX_KILLTAG
 297C:0B96  Ovl  __SWORDERDESTROY
 297C:0BA2  Ovl  SX_TAGDELE
 297C:0BB4  Ovl  __SEXRLCK
 297C:0BBA  Ovl  __SEXRUNL
 297C:0BC0  Ovl  __SEXFLCK
 297C:0BC6  Ovl  __SEXFUNL
 297C:0BCC  Ovl  __SEXALCK
 297C:0BD2  Ovl  __SEXAUNL
 297C:0BD8  Ovl  __SEXWPCHK
 297C:0BDE  Ovl  _SEXLOCK
 297C:0BE4  Ovl  _SEXUNLOCK
 297C:0BF0  Ovl  __SWFINDFREEBLOCK
 297C:0BF6  Ovl  __SWFLUSHMEMOROOT
 297C:0BFC  Ovl  __SWISFREEBLOCK
 297C:0C02  Ovl  __SWINSERTFREEBLOCK
 297C:0C08  Ovl  __SWKILLMEMOROOT
 297C:0C0E  Ovl  __SWEXPANDLASTBLOCK
 297C:0C14  Ovl  __SWREADMEMOROOT
 297C:0C1A  Ovl  __SWGETFREEBLOCK
 297C:0C26  Ovl  __SXENCMEMOREAD
 297C:0C2C  Ovl  __SXENCMEMOWRITE
 297C:0C38  Ovl  __SWCONDCLEAR
 297C:0C3E  Ovl  __SEXORDERCONDITION
 297C:0C44  Ovl  _SXCONDSET
 297C:0C50  Ovl  ___CDXPAGEREAD
 297C:0C56  Ovl  ___CDXPAGEAPPEND
 297C:0C5C  Ovl  ___NSXPAGEREAD
 297C:0C62  Ovl  ___NSXPAGEREADLOCK
 297C:0C68  Ovl  ___CDXPAGEREADLOCK
 297C:0C74  Ovl  __SXISLOCKED
 297C:0C7A  Ovl  __SXRLOCK
 297C:0C80  Ovl  __SXUNLOCK
 297C:0C86  Ovl  __SXGETLOCKS
 297C:0C8C  Ovl  __SXDBFUNLOCK
 297C:0C98  Ovl  _SWFINDTAG
 297C:0C9E  Ovl  __SWSURFACE
 297C:0CA4  Ovl  _SWFINDINDEX
 297C:0CB0  Ovl  _SX_TRIGVA
 297C:0CB6  Ovl  SX_SETTRIG
 297C:0CBC  Ovl  __SXCALLTRIGGER
 297C:0CC8  Ovl  __SXPARSENAME
 297C:0CCE  Ovl  __SXGETEXT
 297C:0CD4  Ovl  __CDXSWAPBYTES
 297C:0CDA  Ovl  __SEXTRIM_N
 297C:0CE0  Ovl  __SXMAKESTR
 297C:0CE6  Ovl  __CLIPALLOC
 297C:0CEC  Ovl  __CLIPFREE
 297C:0CF2  Ovl  __SXNAMEEXT
 297C:0CFE  Ovl  __SXSMARTUPPER
 297C:0D04  Ovl  __SWOURDBFDRIVER
 297C:0D0A  Ovl  _SWPARM2TYPE
 297C:0D10  Ovl  __SXSWAPBYTES
 297C:0D1C  Ovl  __VFGETLEN
 297C:0D28  Ovl  __VFGETBLOCK
 297C:0D2E  Ovl  SX_DTOP
 297C:0D34  Ovl  SX_PTOD
 297C:0D46  Ovl  __VFPUTBLOCK
 297C:0D4C  Ovl  SX_VFGET
 297C:0D58  Ovl  __VFPUTVALUE
 297C:0D5E  Ovl  __VFGETVALUE
 297C:0D64  Ovl  __VFGETTYPE
 297C:0D70  Ovl  ___M6FREESIMPLE
 297C:0D76  Ovl  ___M6CREATEMAP
 297C:0D88  Ovl  ___M6CASEAND
 297C:0D8E  Ovl  ___M6CASENOT
 297C:0D94  Ovl  ___M6CASEOR
 297C:0DA0  Ovl  ___M6INITSTRUCTS
 297C:0DA6  Ovl  __M6STRUCTSIZE
 297C:0DAC  Ovl  __M6GOCOLD
 297C:0DB2  Ovl  __M6CLOSE
 297C:0DB8  Ovl  __M6SETFILTER
 297C:0DBE  Ovl  __M6CLEARFILTER
 297C:0DC4  Ovl  __M6PACK
 297C:0DD0  Ovl  ___M6EQUALS
 297C:0DD6  Ovl  ___M6CURRENT
 297C:0DE2  Ovl  M6_RECCOUN
 297C:0DE8  Ovl  _M6SET
 297C:0DEE  Ovl  ___M6RECCOUNT
 297C:0DF4  Ovl  M6_ERROR
 297C:0DFA  Ovl  ___M6ERROR
 297C:0E06  Ovl  ___M6FREETOKE
 297C:0E0C  Ovl  ___M6DROPMAP
 297C:0E12  Ovl  ___M6EVALUATE
 297C:0E1E  Ovl  ___M6NEXTFILTERREC
 297C:0E24  Ovl  ___M6NEXTBITRAW
 297C:0E2A  Ovl  __M6SKIPFILTER
 297C:0E36  Ovl  ___M6INITFILTER
 297C:0E3C  Ovl  ___M6KILLFILTER
 297C:0E42  Ovl  M6_ISFILTE
 297C:0E48  Ovl  M6_REFRESH
 297C:0E4E  Ovl  M6_DBFILTE
 297C:0E54  Ovl  ___M6GETVALUE
 297C:0E5A  Ovl  ___M6GREATER
 297C:0E60  Ovl  M6INIT
 297C:0E66  Ovl  ___M6INSTR
 297C:0E72  Ovl  ___M6FOXEMPTY
 297C:0E78  Ovl  ___M6FOXDATA
 297C:0E7E  Ovl  ___M6ISKEY
 297C:0E84  Ovl  ___M6ISKEYEXPR
 297C:0E8A  Ovl  ___M6ALIASTRIM
 297C:0E96  Ovl  ___M6ISOPT
 297C:0E9C  Ovl  _M6ISOPTIM
 297C:0EA2  Ovl  ___M6LESS
 297C:0EAE  Ovl  ___M6MAPCOPY
 297C:0EB4  Ovl  M6_FILTCOP
 297C:0EBA  Ovl  ___M6FREELOCATE
 297C:0EC0  Ovl  _M6CONTINU
 297C:0ECC  Ovl  ___M6EVALAND
 297C:0ED2  Ovl  ___M6EVALOR
 297C:0ED8  Ovl  ___M6EVALNOT
 297C:0EDE  Ovl  ___M6EVALXOR
 297C:0EE4  Ovl  ___M6NOTEQUALS
 297C:0EF0  Ovl  ___M6OPTIMIZEDELETED
 297C:0EF6  Ovl  ___M6OPTIMIZEPARTIAL
 297C:0EFC  Ovl  __M6OURDRIVER
 297C:0F02  Ovl  ___M6ISRANGE
 297C:0F0E  Ovl  ___M6ISUPPER
 297C:0F14  Ovl  ___M6ISYEARDATE
 297C:0F1A  Ovl  ___M6ISYEARDTOS
 297C:0F20  Ovl  ___M6ISEMPTY
 297C:0F38  Ovl  ___M6STACKEXPR
 297C:0F3E  Ovl  ___M6ISBADEXPR
 297C:0F44  Ovl  ___M6STACKAND
 297C:0F4A  Ovl  ___M6STACKOR
 297C:0F50  Ovl  ___M6STACKNOT
 297C:0F56  Ovl  ___M6SIMPSTRING
 297C:0F62  Ovl  ___M6ISSUBSTR
 297C:0F68  Ovl  ___M6MEMCHR
 297C:0F6E  Ovl  ___M6INCSTR
 297C:0F74  Ovl  ___M6AREYOUSPACED
 297C:0F7A  Ovl  ___M6MATCHPAREN
 297C:0F80  Ovl  ___M6MATCHPARENQ
 297C:0F86  Ovl  ___M6SETWHILE
 297C:0F9E  Ovl  ___M6MATCHBRACK
 297C:0FA4  Ovl  ___M6TOKENIZE
 297C:0FBC  Ovl  ___M6TRANSP
 297C:0FC2  Ovl  ___M6KIND
 297C:0FC8  Ovl  ___M6PRIORITY
 297C:0FCE  Ovl  ___M6TRANSLATE
 297C:0FDA  Ovl  ___M6NEWMAP
 297C:0FE0  Ovl  ___M6BITNO
 297C:0FE6  Ovl  ___M6UNLOCKALL
 297C:0FEC  Ovl  ___M6FREEMAP
 297C:0FF2  Ovl  ___M6NEXTHANDLE
 297C:0FF8  Ovl  ___M6HANDLE2MAP
 297C:0FFE  Ovl  ___M6TOUCHBIT
 297C:1004  Ovl  ___M6ISSET
 297C:100A  Ovl  ___M6GOBIT
 297C:1010  Ovl  ___M6NEXTBIT
 297C:1016  Ovl  ___M6BITCOUNT
 297C:101C  Ovl  ___M6ISMAPEMPTY
 297C:1022  Ovl  _M6ERROR
 297C:1028  Ovl  MEMORY
 297C:1034  Ovl  __PAGE_UNLOCK
 297C:1046  Ovl  __PAGE_READLOCK
 297C:1052  Ovl  __PAGE_READ
 297C:1064  Ovl  __PAGE_UPDATE
 297C:1070  Ovl  __PAGE_WRITE
 297C:1076  Ovl  __DISKIOSLR
 297C:107C  Ovl  __PAGE_FLUSH
 297C:1082  Ovl  __XPAGE_READ
 297C:1088  Ovl  __PAGE_CLEAR
 297C:108E  Ovl  __XPAGE_UPDATE
 297C:10A0  Ovl  __PAGE_APPEND
 297C:10AC  Ovl  __SORTSETFIELD
 297C:10B2  Ovl  _MERGE
 297C:10B8  Ovl  __SORTSORT
 297C:10BE  Ovl  __SORTADVANCE
 297C:10CA  Ovl  __SORTCOMPLETE
 297C:10D0  Ovl  __SORTEND
 297C:112A  Ovl  __SORTINIT
 2A90:020A  Res  _BLIDEMCAL
 2A90:0211  Res  _BLIDEMDTE
 2A90:026A  Res  _BLIDEMMIN
 2A90:0271  Res  _BLIERRNUM
 2A90:0276  Res  _BLIERRPRM
 2A90:0280  Res  _BLIOVLOPS
 2A90:028A  Res  _BLIOVLRES
 2A90:02C5  Res  _BLIOVLSIZ
 2A90:02CF  Res  _BLIOVLSUS
 2A90:030A  Res  _BLIREINIT
 2A90:030A  Res  $$VMREINIT
 2A90:033C  Res  _BLISERNUM
 2A90:0342  Res  $$VMUNHOOK
 2A90:0342  Res  _BLIUNHOOK
 2A90:0386  Res  _BLIVERNUM
 2A90:073E  Res  $$$OVLEND
 2A90:08F7  Res  $$$OVLDEF
 2A90:1010  Res  _BLITOTACT
 2A90:1020  Res  _BLITOTLOD
 2A90:103E  Res  _BLITOTSIZ
 2A90:21B0  Res  $$$OVLERR
 2A90:21C2  Res  $$$OVLINI
 2A90:23E4  Res  $$$OVLCLP
 2A90:2404  Res  BLICALNUM
 2A90:240D  Res  BLIDEMCAL
 2A90:2418  Res  BLIDEMDTE
 2A90:2420  Res  BLIDEMMIN
 2A90:242B  Res  BLIERRNUM
 2A90:2433  Res  BLIERRPRM
 2A90:243B  Res  BLIMEMPAK
 2A90:2459  Res  BLIOVLCLR
 2A90:2470  Res  BLIOVLOPS
 2A90:2478  Res  BLIOVLRES
 2A90:247E  Res  BLIOVLSIZ
 2A90:2486  Res  BLIOVLSUS
 2A90:248F  Res  BLIREINIT
 2A90:2495  Res  BLISERNUM
 2A90:249D  Res  BLIUNHOOK
 2A90:24A3  Res  BLIVERNUM
 2A90:2594  Res  $$$OVLPRM
 2A90:280B  Res  $$$OVLDAT
 2A90:28A6  Res  $$$OVLPRC
 2A90:295F  Res  $$$KRNSEG
 2E25:0000  Res  __WEEDBED
 303D:0000  Res  __WEEDEND
 3059:0000  Res  _T_START
 3059:0188  Res  _T_TRAN
 3059:05BA  Res  _ACCESSOR
 3059:0740  Res  _N_START
 3059:08C8  Res  _N_TRAN
 3059:0E84  Res  _D_RED
 3059:100A  Res  _R_START
 3059:1192  Res  _R_SYMB
 3059:1434  Res  _R_PROD
 3059:16D6  Res  _P_LENGTH
 3059:17E0  Res  _H_SYMBOL
 3059:18EA  Res  _STUFF
 3213:0000  Res  _SEXEMPTY
 3213:0002  Res  __SXCOPYRIGHT
 3216:0000  Res  __SXDEFTRIGGERNAME
 3217:0000  Res  _SEXMTOOMANYTAGS
 321A:0000  Res  _SEXMCORRUPTED
 321A:001C  Res  _SEXMKEYTOOLONG
 321A:0034  Res  _SEXMCANTFINDKEY
 321A:0056  Res  _SEXMINVALIDKEYLEN
 321A:006A  Res  _SEXMBADINDEXEXPR
 321A:0080  Res  _SEXMLOCKTIMEOUT
 321A:008E  Res  _SEXMNOSTRUCTURAL
 321A:00AC  Res  _SEXMINVALIDORDER
 321A:00BC  Res  _SEXMNOMEMO
 321A:00D8  Res  _SEXMNONCOMPACT
 3254:0000  Res  __NSXSUPER
 3254:0128  Res  _SEXKEYBUFFER
 3254:0328  Res  _SEXBUFFER
 3254:0428  Res  _SXTAGINFO
 3254:047C  Res  __M6SUPER
 32AF:0088  Res  __ASIZDS
 32AF:008A  Res  __ATOPSP
 32AF:008C  Res  __AEXIT_RTN
 32AF:008E  Res  __ABRKTB
 32AF:00DE  Res  __ABRKP
 32AF:00DE  Res  __ABRKTBE
 32AF:00E0  Res  __ACFINFO
 32AF:00ED  Res  __AINTDIV
 32AF:00F1  Res  __FAC
 32AF:00F9  Res  _ERRNO
 32AF:00FB  Res  __UMASKVAL
 32AF:00FD  Res  __PSPADR
 32AF:00FF  Res  __PSP
 32AF:0101  Res  __OSVERSION
 32AF:0101  Res  __DOSVERMAJOR
 32AF:0101  Res  __OSMAJOR
 32AF:0102  Res  __OSMINOR
 32AF:0102  Res  __DOSVERMINOR
 32AF:0103  Res  __OSMODE
 32AF:0104  Res  __DOSERRNO
 32AF:0104  Res  __OSERR
 32AF:0106  Res  __NFILE
 32AF:0108  Res  __OSFILE
 32AF:011C  Res  ___ARGC
 32AF:011E  Res  ___ARGV
 32AF:0122  Res  _ENVIRON
 32AF:0126  Res  __PGMPTR
 32AF:012C  Res  __CHILD
 32AF:012E  Res  __OVLFLAG
 32AF:012F  Res  __INTNO
 32AF:0130  Res  __OVLVEC
 32AF:0134  Res  __ADBGMSG
 32AF:0150  Res  _HUGE
 32AF:0158  Res  __MATHERR_FLAG
 32AF:015A  Res  OPTAB
 32AF:0180  Res  __FCSP
 32AF:0182  Res  __FPSIGADR
 32AF:0186  Res  __FCTMP
 32AF:02F0  Res  __FCTOPST
 32AF:0304  Res  $I8_RESULT
 32AF:0304  Res  $I4_RESULT
 32AF:033C  Res  $I4_ROUND_FLAG
 32AF:033D  Res  $I4_ROUND_EXP
 32AF:033F  Res  $I4_AC_HI
 32AF:0343  Res  $I4_AC_LO
 32AF:0354  Res  $I8_ROUND_FLAG
 32AF:0355  Res  $I8_ROUND_EXP
 32AF:0357  Res  $I8_AC_HI
 32AF:035F  Res  $I8_AC_LO
 32AF:03F0  Res  $I8_HALF
 32AF:03F8  Res  $I8_ONE
 32AF:0400  Res  $I8_TWO
 32AF:0408  Res  $I8_ARG
 32AF:0410  Res  $I8_TEMP
 32AF:0431  Res  $I8_LOG_HI
 32AF:0439  Res  $I8_LOG_LO
 32AF:04A6  Res  $I8_Z
 32AF:04AE  Res  $I8_ZZ
 32AF:04B6  Res  $I8_PZZ
 32AF:04CE  Res  $I8_INPUT_WS
 32AF:04CF  Res  $I8_IMPLICIT_EXP
 32AF:0544  Res  __SFIELDS
 32AF:0548  Res  __SFCOUNT
 32AF:054A  Res  __SLBASE
 32AF:054E  Res  __SRBASE
 32AF:0552  Res  __SRSIZE
 32AF:055A  Res  __TERROR
 32AF:055C  Res  __HORROR
 32AF:055E  Res  __TVERSION
 32AF:0560  Res  __TXERROR
 32AF:0562  Res  __TXCLASS
 32AF:0564  Res  __TXACTION
 32AF:0566  Res  __TXLOCUS
 32AF:0726  Res  __MSCONFLICT1
 32AF:0726  Res  __CFLTCVT_TAB
 32AF:07B6  Res  __XARGC
 32AF:07B8  Res  __XARGV
 32AF:082A  Res  C50R100
 32AF:082C  Res  CLIPPER520
 32AF:0924  Res  __EVKBDENTRY
 32AF:094E  Res  _DMOD_TABLE
 32AF:0978  Res  __OGEN0
 32AF:0A14  Res  __OGEN1
 32AF:0AB0  Res  __OGEN
 32AF:0AB4  Res  __OBOUNDS
 32AF:0ABC  Res  __OPF
 32AF:0ABE  Res  __OPX
 32AF:0B00  Res  __XLOCK
 32AF:0B02  Res  __XGRIP1
 32AF:0B04  Res  __XGRIP2
 32AF:0B06  Res  __XGRIP3
 32AF:0B08  Res  __XSEGMIN
 32AF:0B0A  Res  __XSAFE
 32AF:0B42  Res  __SYMEVAL
 32AF:0B4A  Res  __IBPUSHTRAN
 32AF:0B4E  Res  __IBEVALTRAN
 32AF:0B52  Res  __EVAL
 32AF:0B54  Res  __TOS
 32AF:0B56  Res  __EVALHIGH
 32AF:0B58  Res  __ESTATLOW
 32AF:0B5A  Res  __ESTAT
 32AF:0B5C  Res  __EEXTENT
 32AF:0B5E  Res  __LBASE
 32AF:0B60  Res  __FBASE
 32AF:0B62  Res  __SBASE
 32AF:0B64  Res  __PCOUNT
 32AF:0B66  Res  __FZZCOUNT
 32AF:0B6A  Res  __LINE_NUM
 32AF:0B6C  Res  __XLINE
 32AF:0B6E  Res  __SYSFLAGS
 32AF:0B78  Res  __MSTACK
 32AF:0B7C  Res  __MLINK
 32AF:0B80  Res  __MCOUNT
 32AF:0B82  Res  __MTOP
 32AF:0B84  Res  __MBP
 32AF:0B86  Res  __PTOP
 32AF:0C88  Res  __SET
 32AF:0D04  Res  __SETHANDLER
 32AF:0E8C  Res  __ERRORDICT
 32AF:0E98  Res  __SALT
 32AF:0E9A  Res  __NETERR
 32AF:102C  Res  __FSEGS
 32AF:1030  Res  __LONESEGS
 32AF:103E  Res  __OSEGS
 32AF:1C80  Res  __STACKBASE
 32AF:1C82  Res  __STACKSLOP
 32AF:1D0C  Res  _PRESERVE1
 32AF:1D10  Res  _PRESERVE2
 32AF:1D14  Res  _OVERLAYTOP
 32AF:1D16  Res  _OVERLAYLINE
 32AF:1D18  Res  _OVERLAYLEVEL
 32AF:1D1A  Res  __MEMCOUNT
 32AF:1D1C  Res  __DISKIODROP
 32AF:1D20  Res  _SWAPLOWEVENTID
 32AF:1D22  Res  _RECEIVERHANDLE
 32AF:20AC  Res  _MACRO_ERROR
 32AF:276C  Res  _REZ_ALIAS
 32AF:29B2  Res  __MACROP
 32AF:29C0  Res  __PFVERSION
 32AF:29C2  Res  __PFLOCK
 32AF:29C4  Res  __DYN_GETPP
 32AF:29C8  Res  __DBGCOMM
 32AF:2B1E  Res  __PREEXTP
 32AF:2B22  Res  __POSTEXTP
 32AF:2B26  Res  __ALERTP
 32AF:2C84  Res  __NBUFF
 32AF:2D72  Res  __TCSTR
 32AF:2D76  Res  __TCLEN
 32AF:2DE2  Res  __COLORCOUNT
 32AF:2DE4  Res  __COLORS
 32AF:2E60  Res  __TBUFF
 32AF:2E64  Res  __TBUFFSIZE
 32AF:2E9C  Res  __GETDICT
 32AF:30D4  Res  _VGETSYS
 32AF:3114  Res  __SELECTION
 32AF:311A  Res  __WORKAREAS
 32AF:3262  Res  __WAFUNCTABLE
 32AF:3396  Res  __NASCII
 32AF:3398  Res  __NDBCS
 32AF:3B38  Res  _VDISPLAY
 32AF:3C96  Res  _VKEYBOARD
 32AF:3D56  Res  _VSIXNSX
 32AF:3D92  Res  _NSXIDXSDD
 32AF:3DDA  Res  __NSXFUNCTABLE
 32AF:3F8C  Res  __NSXDIRECT
 32AF:400C  Res  _NSXMEMOSDD
 32AF:404A  Res  __SWSKIPOPT
 32AF:404C  Res  __SWSKIPCNT
 32AF:404E  Res  __SEXFPATH
 32AF:4052  Res  __SEXERROR
 32AF:4054  Res  _SEXDIRTYREAD
 32AF:4056  Res  _SEXSORTOPTION
 32AF:4058  Res  _SLOCALERR
 32AF:407C  Res  __SEXLOCKRETRY
 32AF:407E  Res  _UIKEYDUPECNT
 32AF:4080  Res  _UIKEYITEMLEN
 32AF:4082  Res  _UIKEYTRAIL
 32AF:4084  Res  _ULKEYRECNO
 32AF:4088  Res  ___SWCHKHIGHLOW
 32AF:408C  Res  ___SWSCOPEEND
 32AF:4090  Res  __SEXISREINDEX
 32AF:4092  Res  _SEXIINFO
 32AF:40A2  Res  _CPDEFTRIGGER
 32AF:40A6  Res  _CPPENDTRIGGER
 32AF:40AA  Res  _CADEFCODE
 32AF:40B4  Res  _SXENCRBUFF
 32AF:40B8  Res  _SXENCRBUFFSIZE
 32AF:40BA  Res  __SEXAUTOOPEN
 32AF:40BC  Res  __SEXAUTOSHARE
 32AF:40BE  Res  __SEXMEMOSIZE
 32AF:40C2  Res  __SEXMEMOCHANGED
 32AF:40C4  Res  _BHAVEMEMOEXT
 32AF:40C6  Res  __SEXSKIP0REFRESH
 32AF:40C8  Res  __SEXSTRUCTURALCHECK
 32AF:40CA  Res  __MEMOEXT
 32AF:424C  Res  _VSXDBF
 32AF:4282  Res  __SWMEMOSIGNATURE
 32AF:428C  Res  __SWSTACK
 32AF:44C2  Res  _CBIT_ON
 32AF:44CA  Res  _CBIT_OFF
 32AF:44D6  Res  __DYN_USED
 32AF:4546  Res  __PAGE_ERROR
 32AF:4548  Res  __PAGE_GOT
 32AF:459A  Res  ___SYMPB
 32AF:45AA  Res  ___SYMPE
 32AF:45AC  Res  __FPINIT
 32AF:45C8  Res  __DYNINA
 32AF:45CC  Res  __MACROINA
 32AF:45F0  Res  _VMACRO
 32AF:45F0  Res  _VTERM
 32AF:45F0  Res  __LTABLE
 32AF:45F0  Res  _VDB
 32AF:45F0  Res  _VOPS
 32AF:45F0  Res  _VPICT
 32AF:4948  Res  _EDATA
 32AF:4948  Res  __EDATA
 32AF:4A90  Res  _THEGET
 32AF:4A92  Res  _THEGINFO
 32AF:4ABE  Res  _THEBUFF
 32AF:4AC2  Res  _THEBUFFLEN
 32AF:4AC4  Res  _THETEMP
 32AF:4AC8  Res  _THETEMPLEN
 32AF:4ACA  Res  _EBREAK
 32AF:4ACC  Res  __SXDBFSUPER
 32AF:4BF4  Res  __AM6SET
 32AF:4C00  Res  __END
 32AF:4C00  Res  _END

 Program entry point at 2A90:0004
<?
include"conf.php";

$connect = mysql_connect($ip,$login,$senha) or die ("Erro ao conectar");
mysql_select_db($conexao,$connect) or die("Erro ao selecionar base");

$con_associado_dbf = dbase_open($dbf_name_associados,2) or die("Erro ao abrir base DBF: $dbf_name_associados");                   // 2=R/W

$consulta = "SELECT * FROM associado";
$sel_associado = mysql_query($consulta,$connect);

while ($resultado = mysql_fetch_array($sel_associado))
{
$def = array(
 $resultado[codassoc],
 $resultado[nome],
 $resultado[situacao],
 $resultado[sexo],
 $resultado[estcivil],
 $resultado[nascimento],
 $resultado[cpf],
 $resultado[rg ],
 $resultado[exp],
 $resultado[endereco],
 $resultado[bairro],
 $resultado[cidade],
 $resultado[cep],
 $resultado[uf],
 $resultado[fone1],
 $resultado[fone2],
 $resultado[protocolo],
 $resultado[categoria],
 $resultado[codfuner],
 $resultado[codplano],
 $resultado[planonum],
 $resultado[atendimento],
 $resultado[data_adesao],
 $resultado[obs],
 $resultado[atrasado],
 $resultado[regiao],
 $resultado[cobrador],
 $resultado[funerais],
 $resultado[qtcircs],
 $resultado[mensagem],
 $resultado[flagfalecida],
 $resultado[plano],
 $resultado[confeccao],
 $resultado[pedcartao],
 $resultado[validadestr],
 $resultado[codlegivel],
 $resultado[cartao],
 $resultado[carencia],
 $resultado[saitaxa]
);
// echo $resultado[codassoc];
    dbase_add_record($con_associado_dbf,$def);
}
dbase_close($con_associado_dbf);
echo "Associado OK!<br>\n";
//-----------------------------------------------

$con_inscritos_dbf = dbase_open($dbf_name_inscritos,2) or die("Erro ao abrir base DBF: $dbf_name_inscritos");   // 2=Read/Write

$consulta = "SELECT * FROM inscritos";
$sel_inscritos = mysql_query($consulta,$connect);

while ($resultado = mysql_fetch_array($sel_inscritos))
{
$def = array(
 $resultado[codassoc],
 $resultado[seq],
 $resultado[nome],
 $resultado[situacao],
 $resultado[data_falecto],
 $resultado[flagfalecida],
 $resultado[parentesco],
 $resultado[plano],
 $resultado[confeccao],
 $resultado[pedcartao],
 $resultado[validadestr],
 $resultado[codlegivel],
 $resultado[cartao],
 $resultado[incdata],
 $resultado[carencia]
);
    dbase_add_record($con_inscritos_dbf,$def);
}
dbase_close($con_inscritos_dbf);
echo "Inscritos OK!<br>\n";
//-----------------------------------------------------------------

$con_rec_parcela_dbf = dbase_open($dbf_name_rec_parcela,2) or die("Erro ao abrir base DBF: $dbf_name_rec_parcela");   // 2=Read/Write

$consulta = "SELECT * FROM rec_parcela";
$sel_rec_parcela = mysql_query($consulta,$connect);

while ($resultado = mysql_fetch_array($sel_rec_parcela))
{
$def = array(
 $resultado[ai],
 $resultado[codassoc],
 $resultado[codadesao],
 $resultado[parc],
 $resultado[emissao],
 $resultado[codcobr],
 $resultado[codvend],
 $resultado[vencto],
 $resultado[vlrsaldo],
 $resultado[situacao],
 $resultado[estado],
 $resultado[valor],
 $resultado[valor60],
 $resultado[valor30],
 $resultado[valornais],
 $resultado[original],
 $resultado[plano],
 $resultado[regiao]
);          

    dbase_add_record($con_rec_parcela_dbf,$def);
}           
dbase_close($con_rec_parcela_dbf);
echo "Rec_Parcela OK!<br>\n";
//-------------------------------------------------------
/*

$con_cre_cadastro_dbf = dbase_open($dbf_name_cre_cadastro,2) or die("Erro ao abrir base DBF: $dbf_name_cre_cadastro");   // 2=Read/Write

$consulta = "SELECT * FROM cre_cadastro";
$sel_cre_cadastro = mysql_query($consulta,$connect);

while ($resultado = mysql_fetch_array($sel_cre_cadastro))
{
$def = array(
 $resultado[codbenefic],
 $resultado[nome],
 $resultado[fonesdiv],
 $resultado[endereco],
 $resultado[bairro],
 $resultado[cidade],
 $resultado[cep],
 $resultado[uf],
 $resultado[detalhes],
 $resultado[vantagens],
 $resultado[condicoes],
 $resultado[informutil],
 $resultado[prioridade],
 $resultado[status],
 $resultado[contrato],
 $resultado[email],
 $resultado[fonecom1],
 $resultado[fonecom2],
 $resultado[fonecel],
 $resultado[foneres],
 $resultado[fax],
 $resultado[bip],
 $resultado[oldespec],
 $resultado[datainc],
 $resultado[dataalt]
);
    dbase_add_record($con_cre_cadastro_dbf,$def);
}
dbase_close($con_cre_cadastro_dbf);
echo "Cre_Cadastro OK!<br>\n";
*/
mysql_close($connect);
echo "<br><b>Concluido!</b><br>\n";
?>
GAS-Pro v4.0
002003024079001019003001021000142001






                     REQUERIMENTO DE PAGAMENTO/ATENDIMENTO
                      FUNERAL E TERMO DE RESPONSABILIDADE

                                                      Processo

   Nome do Contratante:
   Endere‡o:
     Cidade               Estado  Documento de Identidade Estado Civil


     Contrato    Grupo            Admiss„o                 Processo



    Nome do falecido....:
    Endere‡o do falecido:
    Inscrito neste contrato na qualidade de
    Data do Falecimento.:           Hor rio do Falecimento:

    Cidade do Falecimento Estado   Local do falecimento


    Cemit‚rio onde foi sepultado        Hora do sepultamento


                               DECLARA€ŽO









                     ------------------------------------------
                     Ass.:
                           RG:
[Ÿ]
 27 
AFUNER
Impress„o Modelo 2


PTAB(PADR(SUBSTR(M->ide_maq,2),4)+[AFU],[IMPPAR],1).and.processo+proc2+filial+categ=ALLTRIM(IMPPAR->docto)
011

























 0 
 1 










 0 
 1 
 0 
 66 
 0 
 9 
 3 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
-1 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
Nome do contratante
IIF(PTAB(contrato+GRUPOS->titular,'INSCRITS',1),INSCRITS->nome,GRUPOS->nome)
@!
 35 
C
 12 
 25 


û         










Nr.Processo
processo+proc2
@R 99999/99
 8 
C
 10 
 64 


û         










Endereco contratante
GRUPOS->endereco
@!
 40 
C
 13 
 14 


û         










cidade contratante
GRUPOS->cidade
@!
 20 
C
 15 
 6 


û         










Estado Contratante
[  ]
!!
 2 
C
 15 
 29 


          










Doc
GRUPOS->rg

 14 
C
 15 
 38 


û         










Est.Civil contratante
subst(tbestciv,AT(GRUPOS->estcivil,tbestciv),10)
@!
 11 
C
 15 
 60 


û         










contrato numero
contrato

 6 
C
 18 
 7 


û         










grupo
GRUPOS->grupo

 2 
C
 18 
 19 


û         










data admissao
GRUPOS->admissao

 8 
C
 18 
 35 


û         










pedido
Rx2001F9()

 70 
M
 19 
 2 


    û     










nome do falecido
falecido
@!
 35 
C
 21 
 27 


û         










Endereco falecido
ALLTRIM(ruares)+[, ]+ALLTRIM(baires)
@!
 40 
C
 22 
 27 


û         










Cidade Falecimento
municfal

 20 
C
 27 
 5 


û         










UF falecimento
estfal
!!
 2 
C
 27 
 29 


û         










local falecimento
ALLTRIM(ruafal)

 35 
C
 27 
 36 


û         










Cemit‚rio sepultamento
cemitsep

 30 
C
 30 
 5 


û         










Hora sepultamento
horasepult
99:99
 5 
C
 30 
 47 


û         










Inscrito na qualidade de
grauparcon

 15 
C
 23 
 45 


û         










Data falcto.
falecto_
@D
 8 
D
 24 
 27 


          










Hora Falcto.
horafal
99:99
 5 
C
 24 
 61 


          










DECLARACAO
Rx2002F9()

 70 
M
 33 
 3 


    û     










Ident1
M->setup1

 40 
C
 6 
 22 


          










Categoria
IIF(categ=[PD],[Plano c/Difer. ],IIF(categ=[PL],[Atend.Plano],[Rest.Desp.Funerais]))

 18 
C
 1 
 2 


          










Nome
GRUPOS->nome

 35 
C
 43 
 28 


û         










R.G.
GRUPOS->rg
@!
 20 
C
 44 
 32 


          










DATA
IMPAC(RTRIM(M->p_cidade)+[, ]+LEFT(DTOC(DATE()),2)+[ de ]+NMES(MONTH(DATE()))+ [ de ]+LEFT(DTOS(DATE()),4))

 50 
C
 35 
 26 


          










 9 
Nome da empresa
nemp

 0 
 0 
 32 

T¡tulo aplica‡„o
nsis

 0 
 0 
 25 

Data do sistema
DTOC(DATE())

 0 
 0 
 8 

Nome do mˆs
NMES(DATE())

 0 
 0 
 8 

Dia da semana
NSEM(DATE())

 0 
 0 
 7 

N£mero da p gina
TRAN(pg_,'9999')

 0 
 0 
 4 

C¢digo relat¢rio
"ADM_RX20"

 0 
 0 
 8 

T¡tulo a definir
titrel

 0 
 0 
 30 

Hora da emiss„o
hora_rel_

 0 
 0 
 5 

 0 
 0 
 0 
 2 
GRUPOS
 1 
contrato



INSCRITS
 1 
contrato



procedure historic
/*
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
 \ Empresa.: PresServ Inform tica - Limeira (019)452.6623
 \ Programa: HISTORIC.PRG
 \ Data....: 04-11-03
 \ Sistema.: Administradora - RECEP€„O
 \ Funcao..: Gerenciador do subsistema de hist¢rico padr„o
 \ Analista: Ademilson Pedro Bom
 \ Criacao.: GAS-Pro v4.0n
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/
#include "adrbig.ch"    // inicializa constantes manifestas

PARA lin_menu,col_menu
PRIV op_sis, tela_fundo:=SAVESCREEN(0,0,MAXROW(),79), l_s, c_s, l_i, c_i, l_a

op_sis=EVAL(qualsis,"HISTORIC")
IF nivelop<sistema[op_sis,O_OUTROS,O_NIVEL]        // se usuario nao tem permissao,
 ALERTA()                                          // entao, beep, beep, beep
 DBOX(msg_auto,,,3)                                // lamentamos e
 RETU                                              // retornamos ao menu
ENDI
cn:=fgrep :=.f.

#ifdef COM_LOCK
 IF LEN(pr_ok)>0                                   // se a protecao acusou
  ? pr_ok                                          // erro, avisa e
  QUIT                                             // encerra a aplicacao
 ENDI
#endi

t_fundo=SAVESCREEN(0,0,MAXROW(),79)                // salva tela do fundo
op_cad=1
DO WHIL op_cad!=0
 criterio=""
 RESTSCREEN(0,0,MAXROW(),79,t_fundo)               // restaura tela do fundo
 cod_sos=5 ; cn=.f.
 CLEA TYPEAHEAD                                    // limpa o buffer do teclado
 fgrep=.f.
 SET KEY K_F3 TO                                   // retira das teclas F3 e F4 as
 SET KEY K_F4 TO                                   // funcoes de repeticao e confirmacao
 msg="Inclus„o~1|"+;
     "Manuten‡„o~2|"+;
     "Consulta~3"
 op_cad=DBOX(msg,lin_menu,col_menu,E_MENU,NAO_APAGA,MAIUSC(sistema[op_sis,O_MENU]),,,op_cad)
 IF op_cad!=0                                      // se escolheu uma opcao
  Tela_fundo=SAVESCREEN(0,0,MAXROW(),79)           // salva a tela para ROLATELA()
  PARAMETROS(dbfparam)
  SELE A                                           // e abre o arquivo e seus indices

  #ifdef COM_REDE
   IF !USEARQ(sistema[op_sis,O_ARQUI,O_NOME],.f.,20,1)
                                                   // se falhou a abertura do
    RETU                                           // arquivo volta ao menu anterior
   ENDI
  #else
   USEARQ(sistema[op_sis,O_ARQUI,O_NOME])
  #endi

  SET KEY K_F9 TO veoutros                         // habilita consulta em outros arquivos
 ENDI
 DO CASE
  CASE op_cad=01                                   // inclus„o
   op_menu=INCLUSAO
   IF AT("D",exrot[op_sis])=0                      // se usuario pode fazer inclusao
    HIS_INCL()                                     // neste arquivo chama prg de inclusao
   ELSE                                            // caso contrario vamos avisar que
    ALERTA()                                       // ele nao tem permissao para isto
    DBOX(msg_auto,,,3)
   ENDI

  CASE op_cad=02                                   // manuten‡„o
   op_menu=ALTERACAO
   cod_sos=7
   EDIT()

  CASE op_cad=03                                   // consulta
   op_menu=PROJECOES
   cod_sos=8
   EDITA(05,03,MAXROW()-4,76)

 ENDC
 SET KEY K_F9 TO                                   // F9 nao mais consultara outros arquivos
 CLOS ALL                                          // fecha todos arquivos abertos
ENDD
RETU

PROC HIS_incl(reg_cop)  // inclusao no arquivo HISTORIC
LOCAL getlist:={},cabem:=1,rep:=ARRAY(FCOU()),ult_reg:=RECN(),dbfseq_,;
      ctl_r, ctl_c, t_f3_, t_f4_, l_max, dele_atu:=SET(_SET_DELETED,.f.)
PRIV op_menu:=INCLUSAO, sq_atual_, tem_borda, criterio:="", cpord:="", l_a
FOR i=1 TO FCOU()                                  // cria/declara privadas as
 msg=FIEL(i)                                       // variaveis de memoria com
 PRIV &msg.                                        // o mesmo nome dos campos
NEXT                                               // do arquivo
IF reg_cop!=NIL                                    // quer repetir todo o reg atual
 FOR i=1 TO FCOU()                                 // para cada campo,
  msg=FIEL(i)                                      // salva o conteudo
  rep[i]=&msg.                                     // para repetir
 NEXT
ELSE
 AFILL(rep,"")                                     // eche com valor vazio
ENDI
t_f3_=SETKEY(K_F3,{||rep()})                       // repeticao reg anterior
t_f4_=SETKEY(K_F4,{||conf()})                      // confirma campos com ENTER
ctl_w=SETKEY(K_CTRL_W,{||nadafaz()})               // enganando o CA-Clipper...
ctl_c=SETKEY(K_CTRL_C,{||nadafaz()})
ctl_r=SETKEY(K_CTRL_R,{||nadafaz()})

#ifdef COM_REDE
 HIS_CRIA_SEQ()                                    // cria dbf de controle de cp sequenciais
 FOR i=1 TO FCOU()                                 // cria/declara privadas as
  msg="sq_"+FIEL(i)                                // variaveis de memoria com
  PRIV &msg.                                       // o mesmo nome dos campos
 NEXT                                              // do arquivo com extensao _seq
#endi

DISPBEGIN()                                        // monta tela na pagina de traz
HIS_TELA()                                         // imp tela para inclusao
INFOSIS(.t.)                                       // exibe informacao no rodape' da tela
l_a=Sistema[op_sis,O_TELA,O_SCROLL]
DISPEND()                                          // apresenta tela de uma vez so
DO WHIL cabem>0
 cod_sos=6
 rola_t=.f.                                        // flag se quer rolar a tela
 SELE HISTORIC
 GO BOTT                                           // forca o
 SKIP                                              // final do arquivo
 
 /*
    cria variaveis de memoria identicas as de arquivo, para inclusao
    de registros
 */
 FOR i=1 TO FCOU()
  msg=FIEL(i)
  M->&msg.=IF((fgrep .OR. reg_cop!=NIL).AND.!EMPT(rep[1]),rep[i],&msg.)
 NEXT
 HIS_GERA_SEQ()
 cabem=DISKSPACE(;
          IF(;
             LEN(sistema[op_sis,O_ARQUI,O_DIR_DBF])<2.OR.sistema[op_sis,O_ARQUI,O_DIR_DBF]="\",;
             0,;
             ASC(sistema[op_sis,O_ARQUI,O_DIR_DBF])-64;
          );
       )
 cabem=INT((cabem-2048)/HISTORIC->(RECSIZE()))
 IF cabem<1                                        // mais nenhum!!!
  ALERTA()
  msg="Verifique ESPA€O EM DISCO, "+usuario
  DBOX(msg,,,,,"INCLUSŽO INTERROMPIDA!")           // vamos parar por aqui!
  EXIT
 ENDI
 SELE 0                                            // torna visiveis variaveis de memoria
 SETCOLOR(drvcortel+","+drvcorget+",,,"+corcampo)
 SET KEY K_ALT_F8 TO ROLATELA
 
 /*
    recebe chaves do arquivo de indice basico
 */
 @ l_s+l_a,c_s+02 GET  historico;
                  PICT sistema[op_sis,O_CAMPO,01,O_MASC]
                  DEFINICAO 1

 READ
 SET KEY K_ALT_F8 TO
 IF rola_t
  ROLATELA()

  #ifdef COM_REDE
   HIS_ANT_SEQ()                                   // decrementa sequencial
  #endi

  LOOP
 ENDI
 SELE HISTORIC
 IF LASTKEY()=K_ESC                                // cancelou ou chave em branco
  cabem=0                                          // prepara saida da inclusao
  LOOP                                             // volta p/ menu de cadastramento
 ENDI
 SEEK M->historico
 aprov_reg_=(FOUND().AND.DELE().AND.!drvvisivel)   // vai aproveitar o registro?
 IF FOUND() .AND. !aprov_reg_                      // pesquisou e achou!
  l_a=Sistema[op_sis,O_TELA,O_SCROLL]
  op_menu=ALTERACAO                                // seta flag de ateracao

  #ifdef COM_REDE
   HIS_ANT_SEQ()                                   // decrementa sequencial
   SELE HISTORIC
  #endi

  DISPBEGIN()
  HIS_GETS()                                       // mostra conteudo do registro
  INFOSIS(.f.)                                     // exibe informacao no rodape' da tela
  DISPEND()
  ALERTA()
  msg="Consultar/alterar|Retornar … inclus„o"      // pergunta se deseja
  op_=DBOX(msg,,,E_MENU,,"REGISTRO J EXISTE")     // alterar o registro
  IF op_ =1                                        // caso afirmativo
   EDIT()                                          // deixa alterar
  ENDI
  op_menu=INCLUSAO
  DISPBEGIN()
  HIS_TELA()
  INFOSIS(.t.)                                     // exibe informacao no rodape' da tela
  DISPEND()
  LOOP                                             // volta para inclusao
 ENDI
 SELE 0
 HIS_GET1(INCLUI)                                  // recebe campos
 SELE HISTORIC
 IF LASTKEY()=K_ESC                                // se cancelou

  #ifdef COM_REDE
   HIS_ANT_SEQ()                                   // decrementa sequencial
  #endi

  ALERTA()                                         // avisa que o registro
  DBOX("Registro n„o inclu¡do!",18,,1)             // nao foi incluido, e volta
  LOOP
 ENDI

 #ifdef COM_REDE
  GO BOTT                                          // vamos bloquear o final do
  SKIP                                             // arq para que nehum outro
  BLOREG(0,.5)                                     // usuario possa incluir
  SEEK M->historico                                // se registro foi incluido
  aprov_reg_=(FOUND().AND.DELE().AND.!drvvisivel)  // vai aproveitar o registro?
  IF FOUND() .AND. !aprov_reg_                     // por outro usuario, entao
   BLOREG(0,.5)
   FOR i=1 TO FCOU()
    msg=FIEL(i)
    rep[i]=&msg.
    REPL &msg. WITH M->&msg.
   NEXT
   HIS_GET1(FORM_INVERSA)                          // executa formula inversa
   RECA
   FOR i=1 TO FCOU()
    msg=FIEL(i)
    REPL &msg. WITH rep[i]
   NEXT
   ALERTA(4)                                       // beep 4 vezes
   msg="Registro acabou de ser|inclu¡do por outro usu rio!"
   DBOX(msg,,,,,"ATEN€ŽO!")                        // avisa
   SELE HISTORIC
   UNLOCK                                          // libera o registro
   LOOP                                            // e recebe chave novamente
  ENDI
 #endi

 IF aprov_reg_                                     // se vai aproveitar reg excluido

  #ifdef COM_REDE
   BLOREG(0,.5)
  #endi

  RECA                                             // excluido, vamos recupera-lo
 ELSE                                              // caso contrario
  APPEND BLANK                                     // inclui reg em branco no dbf
 ENDI
 FOR i=1 TO FCOU()                                 // para cada campo,
  msg=FIEL(i)                                      // salva o conteudo
  rep[i]=M->&msg.                                  // para repetir
  REPL &msg. WITH rep[i]                           // enche o campo do arquivo
 NEXT

 #ifdef COM_REDE
  UNLOCK                                           // libera o registro e
  COMMIT                                           // forca gravacao
 #else
  IF RECC()-INT(RECC()/20)*20=0                    // a cada 20 registros
   COMMIT                                          // digitados forca gravacao
  ENDI
 #endi

 ult_reg=RECN()                                    // ultimo registro digitado
 l_max=l_s+Sistema[op_sis,O_TELA,O_SCROLL]+Sistema[op_sis,O_TELA,O_QTDE]
 IF l_s+l_a+1<l_max                                // se nao atingiu o fim da tela
  l_a++                                            // digita na proxima linha
 ELSE                                              // se nao rola a campos para cima
  SCROLL(l_s+Sistema[op_sis,O_TELA,O_SCROLL],c_s+02,l_max-1,c_s+04,1)
  SCROLL(l_s+Sistema[op_sis,O_TELA,O_SCROLL],c_s+08,l_max-1,c_s+47,1)
  SCROLL(l_s+Sistema[op_sis,O_TELA,O_SCROLL],c_s+51,l_max-1,c_s+51,1)
  SCROLL(l_s+Sistema[op_sis,O_TELA,O_SCROLL],c_s+55,l_max-1,c_s+57,1)
  SCROLL(l_s+Sistema[op_sis,O_TELA,O_SCROLL],c_s+61,l_max-1,c_s+61,1)
  SCROLL(l_s+Sistema[op_sis,O_TELA,O_SCROLL],c_s+65,l_max-1,c_s+70,1)
 ENDI
 IF reg_cop!=NIL                                   // estava na consulta e quis rep o campo
  sq_atual_=NIL
  EXIT                                             // cai fora...
 ENDI
ENDD

#ifdef COM_REDE
 HIS_ANT_SEQ()                                     // restaura sequencial anterior
 SELE HISTORIC
#endi

GO ult_reg                                         // para o ultimo reg digitado
SETKEY(K_F3,t_f3_)                                 // restaura teclas de funcoes
SETKEY(K_F4,t_f4_)
SET(_SET_DELETED,dele_atu)                            // ecluidos visiveis/invisiveis
SETKEY(K_CTRL_W,ctl_w)
SETKEY(K_CTRL_C,ctl_c)
SETKEY(K_CTRL_R,ctl_r)
RETU



#ifdef COM_REDE
 PROC HIS_ANT_SEQ(est_seq)     // restaura sequencial anterior
 SELE HIS_SEQ     // seleciona arquivo de controle de sequencial
 BLOARQ(0,.5)     // esta estacao foi a ultima a incluir?
 IF sq_atual_ == historico
  REPL historico WITH sq_historico
  REPL intlan WITH sq_intlan
 ENDI
 UNLOCK           // libera DBF para outros usuarios
 COMMIT           // atualiza cps sequenciais no disco
 RETU
#endi


PROC HIS_CRIA_SEQ   // cria dbf de controle de campos sequenciais
LOCAL dbfseq_:=sistema[op_sis,O_ARQUI,O_DIR_DBF]+"HIS_seq" // arq temporario
SELE 0                          // seleciona area vazia
IF !FILE(dbfseq_+".dbf")        // se o dbf nao existe
 DBCREATE(dbfseq_,{;            // vamos criar a sua estrutura
                    {"historico" ,"C",  3, 0},;
                    {"intlan"    ,"C",  8, 0};
                  };
 )
ENDI
USEARQ(dbfseq_,.f.,,,.f.)       // abre arquivo de cps sequencial
IF RECC()=0                     // se o dbf foi criado agora
 BLOARQ(0,.5)                   // inclui um registro que tera
 APPEND BLANK                   // os ultomos cps sequenciais
 SELE HISTORIC
 IF RECC()>0                    // se o DBF nao estiver
  SET ORDER TO 0                // vazio, entao enche DBF seq
  GO BOTT                       // com o ultimo reg digitado
  REPL HIS_SEQ->historico WITH historico
  REPL HIS_SEQ->intlan WITH intlan
  DBSETORDER(1)                 // retorna ao indice principal
 ENDI
 SELE HIS_SEQ                   // seleciona arq de sequencias
 UNLOCK                         // libera DBF para outros usuarios
 COMMIT                         // atualiza cps sequenciais no disco
ENDI
RETURN

PROC HIS_GERA_SEQ()

#ifdef COM_REDE
 LOCAL ar_:=SELEC()
#else
 LOCAL reg_:=RECNO(),ord_ind:=INDEXORD()
#endi


#ifdef COM_REDE
 SELE HIS_SEQ
 BLOARQ(0,.5)
 sq_historico=HIS_SEQ->historico
 sq_intlan=HIS_SEQ->intlan
#else
 DBSETORDER(0)
 GO BOTT
#endi

M->historico=LPAD(STR(VAL(historico)+1),03,[0])
M->intlan=LPAD(STR(VAL(intlan)+1),08,[0])

#ifdef COM_REDE
 HIS_GRAVA_SEQ()
 IF PROCNAME(1)!="FAZ_LANC"
  sq_atual_=HIS_SEQ->historico
  UNLOCK                                           // libera o registro
  COMMIT
 ENDI
 SELE (ar_)
#else
 DBSETORDER(ord_ind)
 GO reg_
#endi

RETU

PROC HIS_GRAVA_SEQ
REPL historico WITH M->historico
REPL intlan WITH M->intlan
RETU

PROC HIS_tela     // tela do arquivo HISTORIC
tem_borda=.t.
l_s=Sistema[op_sis,O_TELA,O_LS]           // coordenadas da tela
c_s=Sistema[op_sis,O_TELA,O_CS]
l_i=Sistema[op_sis,O_TELA,O_LI]
c_i=Sistema[op_sis,O_TELA,O_CI]
SETCOLOR(drvtittel)
vr_memo=NOVAPOSI(@l_s,@c_s,@l_i,@c_i)     // pega posicao atual da tela
CAIXA(mold,l_s,c_s,l_i,c_i)               // monta caixa da tela
i=LEN(sistema[op_sis,O_MENS])/2
@ l_s,c_s-1+(c_i-c_s+1)/2-i SAY " "+MAIUSC(sistema[op_sis,O_MENS])+" "
SETCOLOR(drvcortel)
@ l_s+01,c_s+1 SAY "Hist ³ Descri‡„o de Hist¢rico                   ³D/C³ C/C ³R/D³ C¢digo"
@ l_s+02,c_s+1 SAY "ÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÅÄÄÄÄÄÅÄÄÄÅÄÄÄÄÄÄÄÄ"
@ l_s+03,c_s+1 SAY "     ³                                          ³   ³     ³   ³"
@ l_s+04,c_s+1 SAY "     ³                                          ³   ³     ³   ³"
@ l_s+05,c_s+1 SAY "     ³                                          ³   ³     ³   ³"
@ l_s+06,c_s+1 SAY "     ³                                          ³   ³     ³   ³"
@ l_s+07,c_s+1 SAY "     ³                                          ³   ³     ³   ³"
@ l_s+08,c_s+1 SAY "     ³                                          ³   ³     ³   ³"
@ l_s+09,c_s+1 SAY "     ³                                          ³   ³     ³   ³"
@ l_s+10,c_s+1 SAY "     ³                                          ³   ³     ³   ³"
@ l_s+11,c_s+1 SAY "     ³                                          ³   ³     ³   ³"
@ l_s+12,c_s+1 SAY "     ³                                          ³   ³     ³   ³"
RETU

PROC HIS_gets     // mostra variaveis do arquivo HISTORIC
LOCAL getlist := {}, ord_, chv_, ar_get1:=ALIAS(), op_ant := op_menu, l_max, reg_atual:=RECNO()
PRIV  l_a:=Sistema[op_sis,O_TELA,O_SCROLL]
HIS_TELA()
l_max=l_s+Sistema[op_sis,O_TELA,O_SCROLL]+Sistema[op_sis,O_TELA,O_QTDE]
SETCOLOR(drvcortel+","+drvcorget+",,,"+corcampo)
DO WHILE !EOF() .AND. l_s+l_a<l_max
 @ l_s+l_a,c_s+02 GET  historico;
                  PICT sistema[op_sis,O_CAMPO,01,O_MASC]

 @ l_s+l_a,c_s+08 GET  descricao

 @ l_s+l_a,c_s+51 GET  tipo;
                  PICT sistema[op_sis,O_CAMPO,03,O_MASC]

 @ l_s+l_a,c_s+55 GET  origem;
                  PICT sistema[op_sis,O_CAMPO,04,O_MASC]

 @ l_s+l_a,c_s+61 GET  recdesp;
                  PICT sistema[op_sis,O_CAMPO,05,O_MASC]

 @ l_s+l_a,c_s+65 GET  codigo;
                  PICT sistema[op_sis,O_CAMPO,06,O_MASC]

 SETCOLOR(drvcortel+","+drvcortel+",,,"+drvcortel)
 l_a++
 SKIP
ENDD
GO reg_atual
SETCOLOR(drvcortel+","+drvcorget+",,,"+corcampo)
CLEAR GETS
RETU

PROC HIS_get1(tp_mov)     // capta variaveis do arquivo HISTORIC
LOCAL getlist := {}, ord_, chv_, ar_get1:=ALIAS(), op_ant := op_menu
PRIV  blk_historic:=.t.

IF tp_mov=INCLUI
 IF TYPE("l_a")!="N"
  l_a=Sistema[op_sis,O_TELA,O_SCROLL]
 ENDI
 DO WHILE .t.
  rola_t=.f.
  SET KEY K_ALT_F8 TO ROLATELA
  SETCOLOR(drvcortel+","+drvcorget+",,,"+corcampo)
  @ l_s+l_a,c_s+08 GET  descricao
                   DEFINICAO 2

  @ l_s+l_a,c_s+51 GET  tipo;
                   PICT sistema[op_sis,O_CAMPO,03,O_MASC]
                   DEFINICAO 3

  @ l_s+l_a,c_s+55 GET  origem;
                   PICT sistema[op_sis,O_CAMPO,04,O_MASC]
                   DEFINICAO 4

  @ l_s+l_a,c_s+61 GET  recdesp;
                   PICT sistema[op_sis,O_CAMPO,05,O_MASC]
                   DEFINICAO 5

  @ l_s+l_a,c_s+65 GET  codigo;
                   PICT sistema[op_sis,O_CAMPO,06,O_MASC]
                   DEFINICAO 6

  READ
  SET KEY K_ALT_F8 TO
  IF rola_t
   ROLATELA()
   LOOP
  ENDI
  IF LASTKEY()!=K_ESC .AND. drvincl .AND. op_menu=INCLUSAO
   IF !CONFINCL()
    LOOP
   ENDI
  ENDI
  EXIT
 ENDD
ENDI
IF tp_mov=EXCLUI .OR. tp_mov=FORM_INVERSA
 IF !EMPTY(codlan) .AND. tp_mov=EXCLUI
  ALERTA()       // existe registro validado aqui!
  msg="Registro de Lan‡amento"
  DBOX(msg,,,,,"IMPOSS¡VEL EXCLUIR!")
 ELSE
  TIRA_LANC("PRCESSOS","HIS-"+intlan,.f.)
  TIRA_LANC("TAXAS","HIS-"+intlan,.f.)
  IF !EMPTY(ALIAS())
   DELE
  ENDI
 ENDI
ELSEIF tp_mov=INCLUI .OR. tp_mov=RECUPERA .OR. tp_mov=FORM_DIRETA
 IF (op_menu=INCLUSAO .AND. LASTKEY()!=K_ESC) .OR. op_menu!=INCLUSAO
  IF !EMPTY(codlan) .AND. tp_mov=RECUPERA
   ALERTA()      // existe registro validado aqui!
   msg="Registro de Lan‡amento"
   DBOX(msg,,,,,"IMPOSS¡VEL RECUPERAR!")
  ELSE
   IF 1=3 //
    ord_=LEN(sistema[EVAL(qualsis,"PRCESSOS"),O_CHAVE])
    IF TYPE("M->intlan")="C" .AND. EMPTY(intlan)
     chv_="HIS-"+M->intlan+"-001"
    ELSE
     chv_="HIS-"+intlan+"-001"
    ENDI
    PTAB(chv_,"PRCESSOS",ord_)
    FAZ_LANC("PRCESSOS",chv_)

    #ifdef COM_REDE
     PRCESSOS->(DBUNLOCK())                        // libera o registro
    #endi

   ENDI
   IF 1=3
    ord_=LEN(sistema[EVAL(qualsis,"TAXAS"),O_CHAVE])
    IF TYPE("M->intlan")="C" .AND. EMPTY(intlan)
     chv_="HIS-"+M->intlan+"-002"
    ELSE
     chv_="HIS-"+intlan+"-002"
    ENDI
    PTAB(chv_,"TAXAS",ord_)
    FAZ_LANC("TAXAS",chv_)

    #ifdef COM_REDE
     TAXAS->(DBUNLOCK())                           // libera o registro
    #endi

   ENDI
   IF op_menu!=INCLUSAO
    RECA
   ENDI
  ENDI
 ENDI
ENDI
RETU

* \\ Final de HISTORIC.PRG
      SIxMemo                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 procedure adr_atr1
/*
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
 \ Empresa.: PresServ Inform tica - Limeira (019)452.6623
 \ Programa: ADR_ATR1.PRG
 \ Data....: 29-01-04
 \ Sistema.: Administradora - RECEP€„O
 \ Funcao..: Define atributos dos arquivos (sistema[])
 \ Analista: Ademilson Pedro Bom
 \ Criacao.: GAS-Pro v4.0o
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/

#include "adrbig.ch"    // inicializa constantes manifestas


sistema[009]={;
            "Lan‡amento Aux.Funeral",;                      // opcao do menu
            "Aux¡lio Funeral",;                             // titulo do sistema
	    {"processo+proc2+filial+categ","falecido+processo","ruafal"},;// chaves do arquivo
	    {"Processo","Nome Falecido","Data e Local Fal."},;// titulo dos indices para consulta
	    {"01020305","1201","20"},;                          // ordem campos chaves
            {"AFUNER",drvdbf,drvntx},;                      // nome do DBF
            {"AFUNER1","AFUNER2","AFUNER3"},;               // nomes dos NTX
            {},;                                            // nome dos dbf's relacionados
            {},;                                            // campos de relacionamento
            {1,1,3,1,22,78},;                               // num telas/tela atual/coordenadas
            {1,.t.,.f.},;                                   // nivel acesso/tp chave/pede dir
            {},;                                            // campos do arquivo
            {},;                                            // formula mostradas
            {"nivelop>1","Permitido apenas a usu rios cadastrados|com n¡vel de Manuten‡„o ou Maior"},;// condicao de exclusao de registros
            {"nivelop>1","Permitido apenas a usu rios cadastrados|com n¡vel de Manuten‡„o ou Maior"},;// condicao de alteracao de registros
            {"nivelop>1","Permitido apenas a usu rios cadastrados|com n¡vel de Manuten‡„o ou Maior"};// condicao de recupercao de registros
           }

AADD(sistema[009,O_CAMPO],{;            // AFUNER
     /* mascara       */    "99999",;
     /* titulo        */    "Processo",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(PROCESSO)~Este ‚ um campo obrigat¢rio!|Ele ‚ usado como chave principal|para localiza‡„o dos documentos.",;
     /* help do campo */    "Digite neste campo o n£mero de|identifica‡„o do processo";
                         };
)
AADD(sistema[009,O_CAMPO],{;            // AFUNER
     /* mascara       */    "99",;
     /* titulo        */    "Ano",;
     /* cmd especial  */    "",;
     /* default       */    "RIGHT(DTOC(DATE()),2)",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(proc2)~Necess rio informar ANO",;
     /* help do campo */    "Informe o ano correspondente ao processo.";
			 };
)
AADD(sistema[009,O_CAMPO],{;            // AFUNER
     /* mascara       */    "@!",;
     /* titulo        */    "Filial",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[009,O_CAMPO],{;            // AFUNER
     /* mascara       */    "@D",;
     /* titulo        */    "Data ocorrˆncia",;
     /* cmd especial  */    "",;
     /* default       */    "DATE()",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPTY(ocorr_)~DATA OCORRENCIA n„o pode estar vazia",;
     /* help do campo */    "Entre com a Data de Ocorrˆncia";
                         };
)
AADD(sistema[009,O_CAMPO],{;            // AFUNER
     /* mascara       */    "!!",;
     /* titulo        */    "Categoria",;
     /* cmd especial  */    "MTAB([PL=Plano|PD=Plano c/Diferen‡a|AF=Auxilio],[CATEGORIA])",;
     /* default       */    "[AF]",;
     /* pre-validacao */    "",;
     /* validacao     */    "categ $ [PL|PD|AF]~CATEGORIA n„o aceit vel",;
     /* help do campo */    "Preencha com:|PL para Plano,| PD p/Diferen‡a ou |AX para Aux.Funeral";
                         };
)
AADD(sistema[009,O_CAMPO],{;            // AFUNER
     /* mascara       */    "@!",;
     /* titulo        */    "Contrato",;
     /* cmd especial  */    "VDBF(6,3,20,77,'GRUPOS',{'codigo','grupo','nome','endereco'},1,'codigo',[])",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "PTAB(contrato,'GRUPOS',1).AND.CAD_04F9(op_menu).AND.(PTAB(contrato,'TAXAS',1).OR.PTAB(GRUPOS->grupo,'ARQGRUP',1).OR.(1=1))~CONTRATO n„o existe em arquivo de tabela",;
     /* help do campo */    "Informe o n£mero do contrato";
                         };
)
AADD(sistema[009,O_CAMPO],{;            // AFUNER
     /* mascara       */    "",;
     /* titulo        */    "Parentesco",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    "Informe o grau de parentesco deste com o falecido.";
                         };
)
AADD(sistema[009,O_CAMPO],{;            // AFUNER
     /* mascara       */    "@!",;
     /* titulo        */    "Nome",;
     /* cmd especial  */    "",;
     /* default       */    "GRUPOS->nome",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(nomedec)~Necess rio informar NOME",;
     /* help do campo */    "Entre com o nome do declarante";
                         };
)
AADD(sistema[009,O_CAMPO],{;            // AFUNER
     /* mascara       */    "@!",;
     /* titulo        */    "Rua Declarante",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    "Entre com o endere‡o do respons vel";
                         };
)
AADD(sistema[009,O_CAMPO],{;            // AFUNER
     /* mascara       */    "@!",;
     /* titulo        */    "Fone",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    "Informe o n£mero do Telefone para contato|com o respons vel pela solicita‡„o do A.F.";
                         };
)
AADD(sistema[009,O_CAMPO],{;            // AFUNER
     /* mascara       */    "",;
     /* titulo        */    "Falecido",;
     /* cmd especial  */    "VDBF(6,3,20,77,'INSCRITS',{'codigo','nome','nascto_'},1,'kinscf9()',[])",;
     /* default       */    "ALLTRIM(contrato)",;
     /* pre-validacao */    "",;
     /* validacao     */    "PTAB(codigofal,'INSCRITS',1).OR.EMPT(codigofal)~Necess rio informar C¢digo do FALECIDO ou|Tecle F8 para consulta.",;
     /* help do campo */    "Entre com o c¢digo do falecido";
                         };
)
AADD(sistema[009,O_CAMPO],{;            // AFUNER
     /* mascara       */    "",;
     /* titulo        */    "Nome do falecido",;
     /* cmd especial  */    "",;
     /* default       */    "IIF(PTAB(codigofal,'INSCRITS',1),INSCRITS->nome,[])",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(falecido)~Necess rio informar NOME DO FALECIDO",;
     /* help do campo */    "Entre com o nome do falecido";
                         };
)
AADD(sistema[009,O_CAMPO],{;            // AFUNER
     /* mascara       */    "",;
     /* titulo        */    "Rua Residˆncia",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    "Entre com o endere‡o de residˆncia do Falecido";
                         };
)
AADD(sistema[009,O_CAMPO],{;            // AFUNER
     /* mascara       */    "",;
     /* titulo        */    "Bairro Residˆncia",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    "Entre com o bairro de residˆncia";
                         };
)
AADD(sistema[009,O_CAMPO],{;            // AFUNER
     /* mascara       */    "",;
     /* titulo        */    "Munic¡pio de residˆncia",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    "Entre com o nome do Munic¡pio de residˆncia";
                         };
)
AADD(sistema[009,O_CAMPO],{;            // AFUNER
     /* mascara       */    "!!",;
     /* titulo        */    "UF Residˆncia",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "EMPTY(ESTRES).OR.VUF(ESTRES)~ESTADO RESIDENCIA N„o aceit vel",;
     /* help do campo */    "Entre com o estado de Residˆncia";
                         };
)
AADD(sistema[009,O_CAMPO],{;            // AFUNER
     /* mascara       */    "@D",;
     /* titulo        */    "Nascimento",;
     /* cmd especial  */    "",;
     /* default       */    "IIF(PTAB(codigofal,'INSCRITS',1),INSCRITS->nascto_,CTOD([  /  /  ]))",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    "Informe a data de nascimento do falecido.";
                         };
)
AADD(sistema[009,O_CAMPO],{;            // AFUNER
     /* mascara       */    "@D",;
     /* titulo        */    "Data falcto.",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "falecto_<=DATE()~Informe uma data v lida para falecimento|Verifique a data do sistema.",;
     /* help do campo */    "Entre com a data de falecimento";
                         };
)
AADD(sistema[009,O_CAMPO],{;            // AFUNER
     /* mascara       */    "99:99",;
     /* titulo        */    "Hora Falcto.",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "!EMPTY(falecto_)",;
     /* validacao     */    "VHORA(horafal+':00')~HORA FALCTO. n„o aceit vel|Digite uma hora correta",;
     /* help do campo */    "";
                         };
)
AADD(sistema[009,O_CAMPO],{;            // AFUNER
     /* mascara       */    "",;
     /* titulo        */    "Rua Falecimento",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    "Entre com o endere‡o (Rua) onde|ocorreu o falecimento";
                         };
)
AADD(sistema[009,O_CAMPO],{;            // AFUNER
     /* mascara       */    "",;
     /* titulo        */    "Munic¡pio de falecimento",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    "Entre com o nome do munic¡pio";
                         };
)
AADD(sistema[009,O_CAMPO],{;            // AFUNER
     /* mascara       */    "!!",;
     /* titulo        */    "UF falecto",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "EMPTY(ESTFAL) .OR.VUF(ESTFAL)~ESTADO FALECIMENTO N„o aceit vel",;
     /* help do campo */    "Entre com o Estado onde ocorreu o falecimento";
			 };
)
AADD(sistema[009,O_CAMPO],{;            // AFUNER
     /* mascara       */    "@D",;
     /* titulo        */    "Data Sepultamento",;
     /* cmd especial  */    "",;
     /* default       */    "DATE()",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    "Informe a data do sepultamento";
                         };
)
AADD(sistema[009,O_CAMPO],{;            // AFUNER
     /* mascara       */    "99:99",;
     /* titulo        */    "Hora sepult.",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "VHORA(horasepult+':00')~HORA SEPULT. n„o aceit vel|digite uma hora correta",;
     /* help do campo */    "Informe a hora do sepultamento";
                         };
)
AADD(sistema[009,O_CAMPO],{;            // AFUNER
     /* mascara       */    "",;
     /* titulo        */    "Cemit‚rio Sepultamento",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    "Entre com o n£mero do cemit‚rio de sepultamento";
                         };
)
AADD(sistema[009,O_CAMPO],{;            // AFUNER
     /* mascara       */    "999",;
     /* titulo        */    "Func.Respons vel",;
     /* cmd especial  */    "VDBF(6,15,20,77,'FNCS',{'codigo','nome','profiss'},1,'codigo',[])",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "PTAB(funcresp,'FNCS',1).OR.EMPTY(funcresp)~Funcion rio n„o existe na tabela",;
     /* help do campo */    "Informe o funcion rio far |o registro ou F8 para consulta em tabela";
                         };
)
AADD(sistema[009,O_CAMPO],{;            // AFUNER
     /* mascara       */    "@D",;
     /* titulo        */    "Proc.pagto em",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    "Processar pagamento em...";
                         };
)
AADD(sistema[009,O_CAMPO],{;            // AFUNER
     /* mascara       */    "99999999999.99",;
     /* titulo        */    "Valor Auxilio",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    "Informe o valor do Auxilio Funeral";
                         };
)
AADD(sistema[009,O_CAMPO],{;            // AFUNER
     /* mascara       */    "@D",;
     /* titulo        */    "Pago em",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    "";
                         };
)
AADD(sistema[009,O_CAMPO],{;            // AFUNER
     /* mascara       */    "99999999",;
     /* titulo        */    "Num.Lan‡amento",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[009,O_FORMULA],{;          // AFUNER - Contratante
     /* form mostrar  */    "LEFT(TRAN(IIF(PTAB(contrato,'GRUPOS',1),GRUPOS->nome,[]),[]),30)",;
     /* lin da formula*/    3,;
     /* col da formula*/    28;
                         };
)
AADD(sistema[009,O_FORMULA],{;          // AFUNER - Endere‡o Contr.
     /* form mostrar  */    "LEFT(TRAN(IIF(PTAB(contrato,'GRUPOS',1),xDECRIPT(GRUPOS->endereco),[]),[]),35)",;
     /* lin da formula*/    4,;
     /* col da formula*/    28;
                         };
)
AADD(sistema[009,O_FORMULA],{;          // AFUNER - Func.Resp.
     /* form mostrar  */    "LEFT(TRAN(IIF(PTAB(funcresp,[FNCS]),FNCS->nome,[ ]),[]),30)",;
     /* lin da formula*/    16,;
     /* col da formula*/    32;
                         };
)
AADD(sistema[009,O_FORMULA],{;          // AFUNER - Categoria
     /* form mostrar  */    "LEFT(TRAN(IIF(categ=[PD],[Plano c/Difer. ],IIF(categ=[PL],[Atend.Plano],[Auxilio Funeral  ])),[]),18)",;
     /* lin da formula*/    1,;
     /* col da formula*/    56;
                         };
)
AADD(sistema[009,O_FORMULA],{;          // AFUNER - Filial
     /* form mostrar  */    "LEFT(TRAN(IIF(EMPT(filial),M->p_filial,filial),[@!]),02)",;
     /* lin da formula*/    1,;
     /* col da formula*/    23;
                         };
)
AADD(sistema[009,O_FORMULA],{;          // AFUNER - Seguro?
     /* form mostrar  */    "LEFT(filial,02)",;
     /* lin da formula*/    1,;
     /* col da formula*/    23;
                         };
)


sistema[010]={;
            "Documento … Imprimir",;                        // opcao do menu
            "Documento … Imprimir",;                        // titulo do sistema
            {"idmaq+base","codlan"},;                       // chaves do arquivo
            {"Esta‡„o","Cod.Lanc"},;                        // titulo dos indices para consulta
            {"0102","04"},;                                 // ordem campos chaves
            {"IMPPAR",drvdbf,drvntx},;                      // nome do DBF
            {"IMPPAR1","IMPPAR2"},;                         // nomes dos NTX
            {},;                                            // nome dos dbf's relacionados
            {},;                                            // campos de relacionamento
            {1,1,8,8,19,72,3,8},;                           // num telas/tela atual/coordenadas/inicio scroll/qtde scroll
            {1,.t.,.f.},;                                   // nivel acesso/tp chave/pede dir
            {},;                                            // campos do arquivo
	    {},;                                            // formula mostradas
            {"",""},;                                       // condicao de exclusao de registros
            {"",""},;                                       // condicao de alteracao de registros
            {"",""};                                        // condicao de recupercao de registros
           }

AADD(sistema[010,O_CAMPO],{;            // IMPPAR
     /* mascara       */    "@!",;
     /* titulo        */    "Esta‡„o",;
     /* cmd especial  */    "M->ide_maq",;
     /* default       */    "PADR(SUBSTR(M->ide_maq,2),4)",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(idmaq)~Necess rio informar Esta‡„o|Tecle F8",;
     /* help do campo */    "Informe o nome da esta‡„o|tecle F8 para preencher autom tico";
                         };
)
AADD(sistema[010,O_CAMPO],{;            // IMPPAR
     /* mascara       */    "@!",;
     /* titulo        */    "Base",;
     /* cmd especial  */    "MTAB([AFU-Aux.funeral|BXR-Baixa Recep‡„o|OBX-Outros Receb.],[BASE])",;
     /* default       */    "[BXR]",;
     /* pre-validacao */    "",;
     /* validacao     */    "base $ [AFU|BXR|OBX]~BASE n„o aceit vel,tecle F8",;
     /* help do campo */    "Informe a Base de Dados|tecle F8 para busca em tabela";
                         };
)
AADD(sistema[010,O_CAMPO],{;            // IMPPAR
     /* mascara       */    "",;
     /* titulo        */    "Documento",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    "Digite neste campo o n£mero de|identifica‡„o do documento|(N„o utilize barras nem tra‡os)";
                         };
)
AADD(sistema[010,O_CAMPO],{;            // IMPPAR
     /* mascara       */    "!!!-99999999-999-999",;
     /* titulo        */    "Cod.Lan‡amento",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[010,O_FORMULA],{;          // IMPPAR - processo falec.
     /* form mostrar  */    "LEFT(TRAN(IMP_01F9(),[]),35)",;
     /* lin da formula*/    {||l_a},;
     /* col da formula*/    28;
                         };
)


sistema[011]={;
            "Credenciados",;                                // opcao do menu
            "Cadastro de Credenciados",;                    // titulo do sistema
	    {"codbenefic","nome","oldespec+cidade+nome"},;               // chaves do arquivo
	    {"Codigo","M‚dico","Especialidade"},;            // titulo dos indices para consulta
	    {"02","12","071512"},;                            // ordem campos chaves
	    {"MEDICOS",drvdbf,drvntx},;                     // nome do DBF
	    {"MEDICOS1","MEDICOS2","MEDICOS3"},;            // nomes dos NTX
            {},;                                            // nome dos dbf's relacionados
            {},;                                            // campos de relacionamento
            {1,1,0,8,24,73},;                               // num telas/tela atual/coordenadas
            {1,.t.,.f.},;                                   // nivel acesso/tp chave/pede dir
            {},;                                            // campos do arquivo
            {},;                                            // formula mostradas
            {"",""},;                                       // condicao de exclusao de registros
            {"",""},;                                       // condicao de alteracao de registros
            {"",""};                                        // condicao de recupercao de registros
           }

AADD(sistema[011,O_CAMPO],{;            // MEDICOS
     /* mascara       */    "",;
     /* titulo        */    "Ai",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(ai)~Necess rio informar AI",;
     /* help do campo */    "";
                         };
)
AADD(sistema[011,O_CAMPO],{;            // MEDICOS
     /* mascara       */    "",;
     /* titulo        */    "Codbenefic",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(codbenefic)~Necess rio informar CODBENEFIC",;
     /* help do campo */    "";
                         };
)
AADD(sistema[011,O_CAMPO],{;            // MEDICOS
     /* mascara       */    "",;
     /* titulo        */    "Oldescrito",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(oldescrito)~Necess rio informar OLDESCRITO",;
     /* help do campo */    "";
                         };
)
AADD(sistema[011,O_CAMPO],{;            // MEDICOS
     /* mascara       */    "",;
     /* titulo        */    "Oldclasse",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(oldclasse)~Necess rio informar OLDCLASSE",;
     /* help do campo */    "";
			 };
)
AADD(sistema[011,O_CAMPO],{;            // MEDICOS
     /* mascara       */    "",;
     /* titulo        */    "Prioridade",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(prioridade)~Necess rio informar PRIORIDADE",;
     /* help do campo */    "";
                         };
)
AADD(sistema[011,O_CAMPO],{;            // MEDICOS
     /* mascara       */    "!!",;
     /* titulo        */    "Situa‡„o",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(status)~Necess rio informar SITUA€ŽO",;
     /* help do campo */    "";
                         };
)
AADD(sistema[011,O_CAMPO],{;            // MEDICOS
     /* mascara       */    "@!",;
     /* titulo        */    "Oldespec",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(oldespec)~Necess rio informar OLDESPEC",;
     /* help do campo */    "";
                         };
)
AADD(sistema[011,O_CAMPO],{;            // MEDICOS
     /* mascara       */    "@S35",;
     /* titulo        */    "Detalhes",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(detalhes)~Necess rio informar DETALHES",;
     /* help do campo */    "";
                         };
)
AADD(sistema[011,O_CAMPO],{;            // MEDICOS
     /* mascara       */    "@S35",;
     /* titulo        */    "Vantagens",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(vantagens)~Necess rio informar VANTAGENS",;
     /* help do campo */    "";
                         };
)
AADD(sistema[011,O_CAMPO],{;            // MEDICOS
     /* mascara       */    "@S35",;
     /* titulo        */    "Condicoes",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(condicoes)~Necess rio informar CONDICOES",;
     /* help do campo */    "";
                         };
)
AADD(sistema[011,O_CAMPO],{;            // MEDICOS
     /* mascara       */    "@S35",;
     /* titulo        */    "Informutil",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(informutil)~Necess rio informar INFORMUTIL",;
     /* help do campo */    "";
                         };
)
AADD(sistema[011,O_CAMPO],{;            // MEDICOS
     /* mascara       */    "",;
     /* titulo        */    "Nome",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(nome)~Necess rio informar NOME",;
     /* help do campo */    "Informe o nome do M‚dico";
                         };
)
AADD(sistema[011,O_CAMPO],{;            // MEDICOS
     /* mascara       */    "",;
     /* titulo        */    "Endere‡o",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    "";
                         };
)
AADD(sistema[011,O_CAMPO],{;            // MEDICOS
     /* mascara       */    "@!",;
     /* titulo        */    "Bairro",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(bairro)~Necess rio informar BAIRRO",;
     /* help do campo */    "";
                         };
)
AADD(sistema[011,O_CAMPO],{;            // MEDICOS
     /* mascara       */    "@!",;
     /* titulo        */    "Cidade",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    "";
                         };
)
AADD(sistema[011,O_CAMPO],{;            // MEDICOS
     /* mascara       */    "!!",;
     /* titulo        */    "UF",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "VUF(uf)~UNIDADE DA FEDERA€ŽO inv lida",;
     /* help do campo */    "";
                         };
)
AADD(sistema[011,O_CAMPO],{;            // MEDICOS
     /* mascara       */    "@R 99999-999",;
     /* titulo        */    "CEP",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(cep)~Necess rio informar CEP",;
     /* help do campo */    "";
                         };
)
AADD(sistema[011,O_CAMPO],{;            // MEDICOS
     /* mascara       */    "@!",;
     /* titulo        */    "Contato",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(contato)~Necess rio informar CONTATO",;
     /* help do campo */    "";
                         };
)
AADD(sistema[011,O_CAMPO],{;            // MEDICOS
     /* mascara       */    "",;
     /* titulo        */    "Telefone",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(fonecom1)~Necess rio informar TELEFONE",;
     /* help do campo */    "";
                         };
)
AADD(sistema[011,O_CAMPO],{;            // MEDICOS
     /* mascara       */    "@!",;
     /* titulo        */    "Fonecom2",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(fonecom2)~Necess rio informar FONECOM2",;
     /* help do campo */    "";
                         };
)
AADD(sistema[011,O_CAMPO],{;            // MEDICOS
     /* mascara       */    "@!",;
     /* titulo        */    "Fonecel",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(fonecel)~Necess rio informar FONECEL",;
     /* help do campo */    "";
                         };
)
AADD(sistema[011,O_CAMPO],{;            // MEDICOS
     /* mascara       */    "@!",;
     /* titulo        */    "Foneres1",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(foneres1)~Necess rio informar FONERES1",;
     /* help do campo */    "";
                         };
)
AADD(sistema[011,O_CAMPO],{;            // MEDICOS
     /* mascara       */    "@!",;
     /* titulo        */    "Email",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(email)~Necess rio informar EMAIL",;
     /* help do campo */    "";
                         };
)
AADD(sistema[011,O_CAMPO],{;            // MEDICOS
     /* mascara       */    "@!",;
     /* titulo        */    "Fax",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(fax)~Necess rio informar FAX",;
     /* help do campo */    "";
                         };
)
AADD(sistema[011,O_CAMPO],{;            // MEDICOS
     /* mascara       */    "@!",;
     /* titulo        */    "Bip",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(bip)~Necess rio informar BIP",;
     /* help do campo */    "";
                         };
)
AADD(sistema[011,O_CAMPO],{;            // MEDICOS
     /* mascara       */    "@!",;
     /* titulo        */    "Fonesdiv",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(fonesdiv)~Necess rio informar FONESDIV",;
     /* help do campo */    "";
                         };
)
AADD(sistema[011,O_CAMPO],{;            // MEDICOS
     /* mascara       */    "@D",;
     /* titulo        */    "Datainc",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(datainc)~Necess rio informar DATAINC",;
     /* help do campo */    "";
                         };
)
AADD(sistema[011,O_CAMPO],{;            // MEDICOS
     /* mascara       */    "@D",;
     /* titulo        */    "Dataalt",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(dataalt)~Necess rio informar DATAALT",;
     /* help do campo */    "";
                         };
)
AADD(sistema[011,O_CAMPO],{;            // MEDICOS
     /* mascara       */    "",;
     /* titulo        */    "Codcidade",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(codcidade)~Necess rio informar CODCIDADE",;
     /* help do campo */    "";
                         };
)
AADD(sistema[011,O_CAMPO],{;            // MEDICOS
     /* mascara       */    "",;
     /* titulo        */    "Contrato",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(contrato)~Necess rio informar CONTRATO",;
     /* help do campo */    "";
                         };
)
AADD(sistema[011,O_CAMPO],{;            // MEDICOS
     /* mascara       */    "",;
     /* titulo        */    "Flagetq",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(flagetq)~Necess rio informar FLAGETQ",;
     /* help do campo */    "";
                         };
)
AADD(sistema[011,O_CAMPO],{;            // MEDICOS
     /* mascara       */    "",;
     /* titulo        */    "Codclasse",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(codclasse)~Necess rio informar CODCLASSE",;
     /* help do campo */    "";
                         };
)
AADD(sistema[011,O_CAMPO],{;            // MEDICOS
     /* mascara       */    "99999999",;
     /* titulo        */    "Num.Lan‡amento",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[011,O_FORMULA],{;          // MEDICOS - porc.desconto
     /* form mostrar  */    "LEFT(TRAN(STR(ultvalor/valorpart*100,6,2),[]),06)",;
     /* lin da formula*/    0,;
     /* col da formula*/    0;
                         };
)


sistema[012]={;
            "Especialidades",;                              // opcao do menu
            "Especialidades",;                              // titulo do sistema
            {"especialid","codlan"},;                       // chaves do arquivo
            {"Por Especialidade","Cod.Lanc"},;              // titulo dos indices para consulta
            {"01","02"},;                                   // ordem campos chaves
            {"TESPEC",drvdbf,drvntx},;                      // nome do DBF
            {"TESPEC1","TESPEC2"},;                         // nomes dos NTX
            {},;                                            // nome dos dbf's relacionados
            {},;                                            // campos de relacionamento
            {1,1,8,20,21,61,3,10},;                         // num telas/tela atual/coordenadas/inicio scroll/qtde scroll
            {1,.t.,.f.},;                                   // nivel acesso/tp chave/pede dir
            {},;                                            // campos do arquivo
            {},;                                            // formula mostradas
            {"",""},;                                       // condicao de exclusao de registros
            {"",""},;                                       // condicao de alteracao de registros
            {"",""};                                        // condicao de recupercao de registros
           }

AADD(sistema[012,O_CAMPO],{;            // TESPEC
     /* mascara       */    "@!",;
     /* titulo        */    "Especialidade",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(especialid)~Necess rio informar ESPECIALIDADE",;
     /* help do campo */    "Informe a|Especialidade/Categoria Profissional.";
                         };
)
AADD(sistema[012,O_CAMPO],{;            // TESPEC
     /* mascara       */    "!!!-99999999-999-999",;
     /* titulo        */    "Cod.Lan‡amento",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)


sistema[013]={;
            "Parƒmetro de Juros",;                          // opcao do menu
            "Parƒmetro de Juros",;                          // titulo do sistema
            {"tipo"},;                                      // chaves do arquivo
            {"Tipo"},;                                      // titulo dos indices para consulta
            {"01"},;                                        // ordem campos chaves
            {"JUROS",drvdbf,drvntx},;                       // nome do DBF
            {"JUROS1"},;                                    // nomes dos NTX
            {},;                                            // nome dos dbf's relacionados
            {},;                                            // campos de relacionamento
            {1,1,8,17,17,66,4,5},;                          // num telas/tela atual/coordenadas/inicio scroll/qtde scroll
            {3,.t.,.f.},;                                   // nivel acesso/tp chave/pede dir
            {},;                                            // campos do arquivo
            {},;                                            // formula mostradas
            {"",""},;                                       // condicao de exclusao de registros
            {"",""},;                                       // condicao de alteracao de registros
            {"",""};                                        // condicao de recupercao de registros
           }

AADD(sistema[013,O_CAMPO],{;            // JUROS
     /* mascara       */    "9",;
     /* titulo        */    "Tipo",;
     /* cmd especial  */    "MTAB([1=J¢ia |2=Taxa |3=Carnˆ|4=Acerto],[TIPO])",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(tipo)~TIPO n„o aceit vel|Deve ser n£mero positivo",;
     /* help do campo */    "Qual o tipo de lan‡amento";
                         };
)
AADD(sistema[013,O_CAMPO],{;            // JUROS
     /* mascara       */    "99.99",;
     /* titulo        */    "Multa %",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "multa>=0~MULTA % n„o aceit vel",;
     /* help do campo */    "Informe a porcentagem de multa";
                         };
)
AADD(sistema[013,O_CAMPO],{;            // JUROS
     /* mascara       */    "999",;
     /* titulo        */    "Carˆncia",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "mltcaren>=0~CARENCIA n„o aceit vel",;
     /* help do campo */    "Informe a carˆncia para a |aplica‡„o da multa|em dias.";
                         };
)
AADD(sistema[013,O_CAMPO],{;            // JUROS
     /* mascara       */    "9.999",;
     /* titulo        */    "Juros %",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "juros>=0~JUROS % n„o aceit vel|deve ser maior ou igual a zeros|(Juros Di rios)",;
     /* help do campo */    "Informe a porcentagem do Juros di rios";
                         };
)
AADD(sistema[013,O_CAMPO],{;            // JUROS
     /* mascara       */    "999",;
     /* titulo        */    "Carˆncia",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "jrscaren>=0~CARENCIA n„o aceit vel|deve ser maior ou igual a zeros",;
     /* help do campo */    "Informe a carˆncia para a |aplica‡„o do juros|em dias.";
                         };
)


sistema[014]={;
            "Filiais",;                                     // opcao do menu
            "Filiais",;                                     // titulo do sistema
            {"codigo"},;                                    // chaves do arquivo
            {"C¢digo"},;                                    // titulo dos indices para consulta
            {"01"},;                                        // ordem campos chaves
            {"TFILIAIS",drvdbf,drvntx},;                    // nome do DBF
            {"TFILIAI1"},;                                  // nomes dos NTX
            {},;                                            // nome dos dbf's relacionados
            {},;                                            // campos de relacionamento
            {1,1,8,8,16,74},;                               // num telas/tela atual/coordenadas
            {1,.t.,.f.},;                                   // nivel acesso/tp chave/pede dir
            {},;                                            // campos do arquivo
            {},;                                            // formula mostradas
            {"nivelop>1","Permitido apenas a usu rios cadastrados|com n¡vel de Manuten‡„o ou Maior"},;// condicao de exclusao de registros
            {"nivelop>1","Permitido apenas a usu rios cadastrados|com n¡vel de Manuten‡„o ou Maior"},;// condicao de alteracao de registros
            {"nivelop>1","Permitido apenas a usu rios cadastrados|com n¡vel de Manuten‡„o ou Maior"};// condicao de recupercao de registros
           }

AADD(sistema[014,O_CAMPO],{;            // TFILIAIS
     /* mascara       */    "@!",;
     /* titulo        */    "C¢digo",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(codigo)~Necess rio informar C¢DIGO",;
     /* help do campo */    "Informe o c¢digo da filial";
                         };
)
AADD(sistema[014,O_CAMPO],{;            // TFILIAIS
     /* mascara       */    "",;
     /* titulo        */    "Abreviatura",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(abrev)~Necess rio informar ABREVIATURA",;
     /* help do campo */    "Dˆ um nome abreviado para a filial|Ser  utilizada para identifica‡Æo nas telas";
                         };
)
AADD(sistema[014,O_CAMPO],{;            // TFILIAIS
     /* mascara       */    "@!",;
     /* titulo        */    "Nome",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(nome)~Necess rio informar NOME",;
     /* help do campo */    "Entre com o nome da filial";
                         };
)
AADD(sistema[014,O_CAMPO],{;            // TFILIAIS
     /* mascara       */    "@!",;
     /* titulo        */    "Endereco",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    "";
                         };
)
AADD(sistema[014,O_CAMPO],{;            // TFILIAIS
     /* mascara       */    "@!",;
     /* titulo        */    "Cidade",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    "";
                         };
)
AADD(sistema[014,O_CAMPO],{;            // TFILIAIS
     /* mascara       */    "@S35",;
     /* titulo        */    "Ref",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    "";
                         };
)
AADD(sistema[014,O_CAMPO],{;            // TFILIAIS
     /* mascara       */    "@!",;
     /* titulo        */    "Contato",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(contato)~Necess rio informar CONTATO",;
     /* help do campo */    "";
                         };
)


sistema[015]={;
            "Grupos",;                                      // opcao do menu
            "Grupos",;                                      // titulo do sistema
            {"grup"},;                                      // chaves do arquivo
            {"Grupo"},;                                     // titulo dos indices para consulta
            {"01"},;                                        // ordem campos chaves
            {"ARQGRUP",drvdbf,drvntx},;                     // nome do DBF
            {"ARQGRUP1"},;                                  // nomes dos NTX
            {},;                                            // nome dos dbf's relacionados
            {},;                                            // campos de relacionamento
            {1,1,4,15,22,62},;                              // num telas/tela atual/coordenadas
            {1,.t.,.f.},;                                   // nivel acesso/tp chave/pede dir
            {},;                                            // campos do arquivo
            {},;                                            // formula mostradas
            {"",""},;                                       // condicao de exclusao de registros
            {"",""},;                                       // condicao de alteracao de registros
            {"",""};                                        // condicao de recupercao de registros
           }

AADD(sistema[015,O_CAMPO],{;            // ARQGRUP
     /* mascara       */    "!!",;
     /* titulo        */    "Grupo",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(grup)~Necess rio informar GRUPO",;
     /* help do campo */    "Entre com o c¢digo do Grupo";
                         };
)
AADD(sistema[015,O_CAMPO],{;            // ARQGRUP
     /* mascara       */    "99",;
     /* titulo        */    "Classe",;
     /* cmd especial  */    "VDBF(6,38,20,77,'CLASSES',{'classcod','descricao','contrat'},1,'classcod',[])",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "PTAB(classe,'CLASSES',1)~CLASSE n„o existe na tabela",;
     /* help do campo */    "Informe a categoria dos planos deste grupo.|Para grupo VIP, digite 00";
                         };
)
AADD(sistema[015,O_CAMPO],{;            // ARQGRUP
     /* mascara       */    "999999",;
     /* titulo        */    "Nr.Inicial",;
     /* cmd especial  */    "",;
     /* default       */    "IF(classe=[00],[000001],STRZERO(VAL(M->lastcodigo)+1,6))",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    "";
                         };
)
AADD(sistema[015,O_CAMPO],{;            // ARQGRUP
     /* mascara       */    "999999",;
     /* titulo        */    "Nr.Final",;
     /* cmd especial  */    "",;
     /* default       */    "IIF(classe=[00],[999999],STRZERO(VAL(inicio)+CLASSES->contrat-1,6))",;
     /* pre-validacao */    "",;
     /* validacao     */    "VAL(final)>VAL(inicio)~NR.FINAL n„o aceit vel",;
     /* help do campo */    "";
                         };
)
AADD(sistema[015,O_CAMPO],{;            // ARQGRUP
     /* mascara       */    "99",;
     /* titulo        */    "N§.Processos",;
     /* cmd especial  */    "",;
     /* default       */    "INT((1+VAL(final)-VAL(inicio))/50)",;
     /* pre-validacao */    "!(CLASSES->prior=[S])",;
     /* validacao     */    "!(acumproc<0)~N§.PROCESSOS n„o aceit vel",;
     /* help do campo */    "Informe quantos processos s„o nescess rios|para se emitir recibos.";
                         };
)
AADD(sistema[015,O_CAMPO],{;            // ARQGRUP
     /* mascara       */    "99",;
     /* titulo        */    "N§.Processos",;
     /* cmd especial  */    "",;
     /* default       */    "acumproc",;
     /* pre-validacao */    "!(CLASSES->prior=[S])",;
     /* validacao     */    "maxproc>=acumproc~N§.PROCESSOS n„o aceit vel|Informe o n£mero m ximo de processos |a se incluir na circular",;
     /* help do campo */    "Informe o n£mero m ximo de processos|para se emitir na cobran‡a.";
                         };
)
AADD(sistema[015,O_CAMPO],{;            // ARQGRUP
     /* mascara       */    "!",;
     /* titulo        */    "Comp.AdmissXAtend.",;
     /* cmd especial  */    "",;
     /* default       */    "[S]",;
     /* pre-validacao */    "acumproc<maxproc",;
     /* validacao     */    "cpadmiss$[SN]~Digite S ou N|S, n„o ser„o incluidos atendimentos|efetuados antes da admiss„o do contrato.",;
     /* help do campo */    "Se digitar S, n„o ser„o incluidos atendimentos|efetuados antes da admiss„o do contrato|quando da 1¦Cobran‡a.";
                         };
)
AADD(sistema[015,O_CAMPO],{;            // ARQGRUP
     /* mascara       */    "999",;
     /* titulo        */    "Periodicidade",;
     /* cmd especial  */    "",;
     /* default       */    "IIF(CLASSES->prior=[S],30,INT((VAL(final)-VAL(inicio)+1)*90/500))",;
     /* pre-validacao */    "",;
     /* validacao     */    "!(periodic<0)~PERIODICIDADE n„o aceit vel",;
     /* help do campo */    "Informe o intervalo m¡nimo em dias entre circulares.";
                         };
)
AADD(sistema[015,O_CAMPO],{;            // ARQGRUP
     /* mascara       */    "999",;
     /* titulo        */    "Remido",;
     /* cmd especial  */    "",;
     /* default       */    "acumproc*5",;
     /* pre-validacao */    "",;
     /* validacao     */    "!(qtdremir<0)~REMIDO n„o aceit vel",;
     /* help do campo */    "Entre com o n§ de taxas nescess rias para que|o processo fique remido.";
                         };
)
AADD(sistema[015,O_CAMPO],{;            // ARQGRUP
     /* mascara       */    "!",;
     /* titulo        */    "P/Atend.",;
     /* cmd especial  */    "",;
     /* default       */    "[S]",;
     /* pre-validacao */    "",;
     /* validacao     */    "poratend$[SN]~Digite|S para deixar de ser remido na utiliza‡„o|ou|N para continuar remido.",;
     /* help do campo */    "Digite S para considerar uma quantidade|a ser paga por atendimento efetuado|ou N para considerar quantidade total.";
                         };
)
AADD(sistema[015,O_CAMPO],{;            // ARQGRUP
     /* mascara       */    "999",;
     /* titulo        */    "Ultcirc",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[015,O_CAMPO],{;            // ARQGRUP
     /* mascara       */    "@D",;
     /* titulo        */    "Emissao",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[015,O_CAMPO],{;            // ARQGRUP
     /* mascara       */    "999",;
     /* titulo        */    "Processos",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[015,O_CAMPO],{;            // ARQGRUP
     /* mascara       */    "999999",;
     /* titulo        */    "Contratos",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[015,O_CAMPO],{;            // ARQGRUP
     /* mascara       */    "999999",;
     /* titulo        */    "Partic.",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[015,O_CAMPO],{;            // ARQGRUP
     /* mascara       */    "999",;
     /* titulo        */    "N§Proxima Circ.",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "nivelop=3",;
     /* validacao     */    "proxcirc>=ultcirc.OR.proxcirc=[000]~A Pr¢xima circular deve ser maior|ou igual a| £ltima emitida ou zeros p/ n„o emitir.",;
     /* help do campo */    "Entre com o n£mero da pr¢xima circular ou|zeros se n„o for emitir.";
                         };
)
AADD(sistema[015,O_FORMULA],{;          // ARQGRUP - Classe/Categor.
     /* form mostrar  */    "LEFT(TRAN(CLASSES->descricao,[]),25)",;
     /* lin da formula*/    2,;
     /* col da formula*/    17;
                         };
)
AADD(sistema[015,O_FORMULA],{;          // ARQGRUP - Ultcirc
     /* form mostrar  */    "LEFT(TRAN(ultcirc,[999]),03)",;
     /* lin da formula*/    13,;
     /* col da formula*/    19;
                         };
)
AADD(sistema[015,O_FORMULA],{;          // ARQGRUP - Emissao
     /* form mostrar  */    "LEFT(TRAN(emissao_,[@D]),08)",;
     /* lin da formula*/    13,;
     /* col da formula*/    33;
                         };
)
AADD(sistema[015,O_FORMULA],{;          // ARQGRUP - Processos
     /* form mostrar  */    "LEFT(TRAN(procpend,[999]),03)",;
     /* lin da formula*/    15,;
     /* col da formula*/    10;
                         };
)
AADD(sistema[015,O_FORMULA],{;          // ARQGRUP - Contratos
     /* form mostrar  */    "LEFT(TRAN(contrat,[999999]),06)",;
     /* lin da formula*/    14,;
     /* col da formula*/    2;
                         };
)
AADD(sistema[015,O_FORMULA],{;          // ARQGRUP - Partic.
     /* form mostrar  */    "LEFT(TRAN(partic,[999999]),06)",;
     /* lin da formula*/    14,;
     /* col da formula*/    27;
                         };
)


sistema[016]={;
            "Regi”es",;                                     // opcao do menu
            "Regi”es",;                                     // titulo do sistema
            {"codigo","regiao"},;                           // chaves do arquivo
            {"p/C¢digo","Nome"},;                           // titulo dos indices para consulta
            {"01","02"},;                                   // ordem campos chaves
            {"REGIAO",drvdbf,drvntx},;                      // nome do DBF
            {"REGIAO1","REGIAO2"},;                         // nomes dos NTX
            {},;                                            // nome dos dbf's relacionados
            {},;                                            // campos de relacionamento
            {1,1,8,14,15,67,3,4},;                          // num telas/tela atual/coordenadas/inicio scroll/qtde scroll
            {1,.t.,.f.},;                                   // nivel acesso/tp chave/pede dir
            {},;                                            // campos do arquivo
            {},;                                            // formula mostradas
            {"nivelop>1","Permitido apenas a usu rios cadastrados|com n¡vel de Manuten‡„o ou Maior"},;// condicao de exclusao de registros
            {"nivelop>1","Permitido apenas a usu rios cadastrados|com n¡vel de Manuten‡„o ou Maior"},;// condicao de alteracao de registros
            {"nivelop>1","Permitido apenas a usu rios cadastrados|com n¡vel de Manuten‡„o ou Maior"};// condicao de recupercao de registros
           }

AADD(sistema[016,O_CAMPO],{;            // REGIAO
     /* mascara       */    "999",;
     /* titulo        */    "C¢digo",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "V",;
     /* help do campo */    "";
                         };
)
AADD(sistema[016,O_CAMPO],{;            // REGIAO
     /* mascara       */    "",;
     /* titulo        */    "Descri‡„o",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(regiao)~Necess rio informar a REGIAO",;
     /* help do campo */    "Informe o nome do bairro, distrito ou regi„o";
                         };
)
AADD(sistema[016,O_CAMPO],{;            // REGIAO
     /* mascara       */    "!!!",;
     /* titulo        */    "Cobrador",;
     /* cmd especial  */    "VDBF(6,11,20,77,'COBRADOR',{'cobrador','nome','cidade'},1,'cobrador')",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "PTAB(cobrador,'COBRADOR',1).OR.EMPT(cobrador)~Necess rio informar COBRADOR",;
     /* help do campo */    "Informe o c¢digo do cobrador.|F8 consulta em tabela.";
                         };
)


sistema[017]={;
            "Cobradores/Vendedores",;                       // opcao do menu
            "Cobradores/Vendedores",;                       // titulo do sistema
            {"cobrador"},;                                  // chaves do arquivo
            {"C¢digo"},;                                    // titulo dos indices para consulta
            {"01"},;                                        // ordem campos chaves
            {"COBRADOR",drvdbf,drvntx},;                    // nome do DBF
            {"COBRADO1"},;                                  // nomes dos NTX
            {},;                                            // nome dos dbf's relacionados
            {},;                                            // campos de relacionamento
            {1,1,6,15,16,66},;                              // num telas/tela atual/coordenadas
            {1,.t.,.f.},;                                   // nivel acesso/tp chave/pede dir
            {},;                                            // campos do arquivo
            {},;                                            // formula mostradas
            {"",""},;                                       // condicao de exclusao de registros
            {"",""},;                                       // condicao de alteracao de registros
            {"",""};                                        // condicao de recupercao de registros
           }

AADD(sistema[017,O_CAMPO],{;            // COBRADOR
     /* mascara       */    "!!!",;
     /* titulo        */    "Cobrador",;
     /* cmd especial  */    "COB_01F9()",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(cobrador)~Necess rio informar COBRADOR",;
     /* help do campo */    "Informe um c¢digo para o cobrador.";
                         };
)
AADD(sistema[017,O_CAMPO],{;            // COBRADOR
     /* mascara       */    "!",;
     /* titulo        */    "Fun‡„o",;
     /* cmd especial  */    "MTAB([Cobrador|Vendedor|Supervisor],[FUN€ŽO])",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "funcao $ [CVS]~FUN€ŽO n„o aceit vel",;
     /* help do campo */    "Informe se ‚ um Cobrador ou Vendedor|";
                         };
)
AADD(sistema[017,O_CAMPO],{;            // COBRADOR
     /* mascara       */    "",;
     /* titulo        */    "Nome do Cobrador",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(nome)~Necess rio informar NOME DO COBRADOR",;
     /* help do campo */    "";
                         };
)
AADD(sistema[017,O_CAMPO],{;            // COBRADOR
     /* mascara       */    "",;
     /* titulo        */    "Endere‡o",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    "";
                         };
)
AADD(sistema[017,O_CAMPO],{;            // COBRADOR
     /* mascara       */    "",;
     /* titulo        */    "Bairro",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    "";
                         };
)
AADD(sistema[017,O_CAMPO],{;            // COBRADOR
     /* mascara       */    "",;
     /* titulo        */    "Cidade",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    "";
                         };
)
AADD(sistema[017,O_CAMPO],{;            // COBRADOR
     /* mascara       */    "",;
     /* titulo        */    "Telefone",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    "";
                         };
)
AADD(sistema[017,O_CAMPO],{;            // COBRADOR
     /* mascara       */    "@R 999.999.999-99",;
     /* titulo        */    "CPF",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "VDV2(cpf).OR.EMPT(cpf)~CPF n„o aceit vel",;
     /* help do campo */    "";
                         };
)
AADD(sistema[017,O_CAMPO],{;            // COBRADOR
     /* mascara       */    "@S35",;
     /* titulo        */    "Observa‡Æo",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    "";
                         };
)
AADD(sistema[017,O_CAMPO],{;            // COBRADOR
     /* mascara       */    "999.9",;
     /* titulo        */    "Percentual",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "!(percent<0).AND.!(percent>100)~PERCENTUAL n„o aceit vel",;
     /* help do campo */    "Informe o percentual de comiss„o";
                         };
)
AADD(sistema[017,O_CAMPO],{;            // COBRADOR
     /* mascara       */    "!!!",;
     /* titulo        */    "Supervisor",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    "Digite o c¢digo do SUPERVISOR deste cobrador";
                         };
)
AADD(sistema[017,O_FORMULA],{;          // COBRADOR - Fun‡„o
     /* form mostrar  */    "LEFT(TRAN(SUBSTR([Cobrador  |Vendedor  |Supervisor],AT(funcao,[Cobrador  |Vendedor  |Supervisor]),10),[]),10)",;
     /* lin da formula*/    1,;
     /* col da formula*/    35;
                         };
)


sistema[018]={;
            "Categoria dos Planos",;                        // opcao do menu
            "Categoria dos Planos",;                        // titulo do sistema
            {"classcod"},;                                  // chaves do arquivo
            {"Classe"},;                                    // titulo dos indices para consulta
            {"01"},;                                        // ordem campos chaves
            {"CLASSES",drvdbf,drvntx},;                     // nome do DBF
            {"CLASSES1"},;                                  // nomes dos NTX
            {},;                                            // nome dos dbf's relacionados
            {},;                                            // campos de relacionamento
            {1,1,4,12,21,68},;                              // num telas/tela atual/coordenadas
            {1,.t.,.f.},;                                   // nivel acesso/tp chave/pede dir
            {},;                                            // campos do arquivo
            {},;                                            // formula mostradas
            {"",""},;                                       // condicao de exclusao de registros
            {"",""},;                                       // condicao de alteracao de registros
            {"",""};                                        // condicao de recupercao de registros
           }

AADD(sistema[018,O_CAMPO],{;            // CLASSES
     /* mascara       */    "99",;
     /* titulo        */    "C¢digo",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(classcod)~Necess rio informar C¢DIGO",;
     /* help do campo */    "Informe um c¢digo para esta categoria";
                         };
)
AADD(sistema[018,O_CAMPO],{;            // CLASSES
     /* mascara       */    "@!",;
     /* titulo        */    "Descri‡„o",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(descricao)~Informe uma descri‡„o deste tipo de contrato.",;
     /* help do campo */    "Informe o nome desta categoria. Ex.: POPULAR, ESPECIAL,...";
                         };
)
AADD(sistema[018,O_CAMPO],{;            // CLASSES
     /* mascara       */    "999999",;
     /* titulo        */    "Contratos",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    "Informe o n£mero de contratos desta categoria|Para categoria VIP, desconsidere esta informa‡„o";
                         };
)
AADD(sistema[018,O_CAMPO],{;            // CLASSES
     /* mascara       */    "!",;
     /* titulo        */    "Prior",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "prior$' SN'~Necess rio informar PRIORIDADE",;
     /* help do campo */    "Os contratos enquadrados nesta categoria|ter„o cobran‡as emitidas periodicamente,|independente de n§ de falecimentos do grupo?";
                         };
)
AADD(sistema[018,O_CAMPO],{;            // CLASSES
     /* mascara       */    "99999999.99",;
     /* titulo        */    "Valor da J¢ia",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "!(VLjoia<0.00)~Valor da j¢ia deve ser positivo",;
     /* help do campo */    "Informe o valor da J¢ia do contrato";
                         };
)
AADD(sistema[018,O_CAMPO],{;            // CLASSES
     /* mascara       */    "99",;
     /* titulo        */    "N§Parcelas",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "vljoia>0",;
     /* validacao     */    "!(nrparc<0)~NR.Parcelas n„o aceit vel",;
     /* help do campo */    "A j¢ia pode ser parcelada em quantas vezes?";
                         };
)
AADD(sistema[018,O_CAMPO],{;            // CLASSES
     /* mascara       */    "99",;
     /* titulo        */    "N§Parcelas",;
     /* cmd especial  */    "",;
     /* default       */    "1",;
     /* pre-validacao */    "vljoia>0",;
     /* validacao     */    "!(parcger<1 .OR. parcger>nrparc)~NR.Parcelas a gerar n„o aceit vel|",;
     /* help do campo */    "Gerar a partir da parcela de J¢ia de n§...";
                         };
)
AADD(sistema[018,O_CAMPO],{;            // CLASSES
     /* mascara       */    "99999999.99",;
     /* titulo        */    "Valor Mensal",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "!(VLmensal<0.00)~Valor da mensal deve ser positivo",;
     /* help do campo */    "Informe o valor mensal do contrato";
                         };
)
AADD(sistema[018,O_CAMPO],{;            // CLASSES
     /* mascara       */    "99999999.99",;
     /* titulo        */    "V.p/Dependente",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "!(VLdepend<0.00)~Valor mensal cobrado a mais por|dependente deve ser maior ou igual a zeros",;
     /* help do campo */    "Informe o valor a ser acrescido por dependente";
                         };
)
AADD(sistema[018,O_CAMPO],{;            // CLASSES
     /* mascara       */    "99",;
     /* titulo        */    "V lidade",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "!(nrmesval<0)~Validade n„o aceit vel",;
     /* help do campo */    "Contratos v lidos por quantos meses?";
                         };
)
AADD(sistema[018,O_CAMPO],{;            // CLASSES
     /* mascara       */    "!",;
     /* titulo        */    "RenVencto",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "renvenc$[ SN]~RENVENCTO n„o aceit vel",;
     /* help do campo */    "Os contratos terÆo|renova‡Æo automatica no vencimento?";
                         };
)
AADD(sistema[018,O_CAMPO],{;            // CLASSES
     /* mascara       */    "!",;
     /* titulo        */    "RenUso",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "renuso$[ SN]~RENUSO n„o aceit vel",;
     /* help do campo */    "Os contratos terÆo|renova‡Æo automatica quando|utilizarem os servi‡os de atendimento/Auxilio?";
                         };
)
AADD(sistema[018,O_CAMPO],{;            // CLASSES
     /* mascara       */    "@E 99,999,999.99",;
     /* titulo        */    "Valor",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[018,O_FORMULA],{;          // CLASSES - Valor
     /* form mostrar  */    "LEFT(TRAN(vltotal,[@E 99,999,999.99]),13)",;
     /* lin da formula*/    16,;
     /* col da formula*/    39;
                         };
)
AADD(sistema[018,O_FORMULA],{;          // CLASSES - Valor da J¢ia
     /* form mostrar  */    "LEFT(TRAN((vljoia/vltotal)*100,[999.99]),06)",;
     /* lin da formula*/    9,;
     /* col da formula*/    29;
                         };
)
AADD(sistema[018,O_FORMULA],{;          // CLASSES - Valor Mensal
     /* form mostrar  */    "LEFT(TRAN((vlmensal/vltotal)*100,[999.99]),06)",;
     /* lin da formula*/    11,;
     /* col da formula*/    29;
                         };
)
AADD(sistema[018,O_FORMULA],{;          // CLASSES - V.p/Dependente
     /* form mostrar  */    "LEFT(TRAN((vldepend/vltotal)*100,[999.99]),06)",;
     /* lin da formula*/    12,;
     /* col da formula*/    29;
                         };
)


sistema[019]={;
            "Circulares",;                                  // opcao do menu
            "Circulares",;                                  // titulo do sistema
            {"grupo+circ"},;                                // chaves do arquivo
            {"Grupo/Circular"},;                            // titulo dos indices para consulta
            {"0102"},;                                      // ordem campos chaves
            {"CIRCULAR",drvdbf,drvntx},;                    // nome do DBF
            {"CIRCULA1"},;                                  // nomes dos NTX
            {"CPRCIRC"},;                                   // nome dos dbf's relacionados
            {},;                                            // campos de relacionamento
            {1,1,7,15,18,66},;                              // num telas/tela atual/coordenadas
            {1,.t.,.f.},;                                   // nivel acesso/tp chave/pede dir
            {},;                                            // campos do arquivo
            {},;                                            // formula mostradas
            {"",""},;                                       // condicao de exclusao de registros
            {"",""},;                                       // condicao de alteracao de registros
            {"",""};                                        // condicao de recupercao de registros
           }

AADD(sistema[019,O_CAMPO],{;            // CIRCULAR
     /* mascara       */    "!!",;
     /* titulo        */    "Grupo",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "PTAB(grupo,'ARQGRUP',1).and.PTAB(ARQGRUP->classe,'CLASSES',1)~GRUPO ou Classe lan‡ada no Grupo|n„o existe na tabela.",;
     /* help do campo */    "Informe o grupo";
                         };
)
AADD(sistema[019,O_CAMPO],{;            // CIRCULAR
     /* mascara       */    "999",;
     /* titulo        */    "Circular",;
     /* cmd especial  */    "STRZERO(VAL(ARQGRUP->proxcirc),3)",;
     /* default       */    "STRZERO(VAL(ARQGRUP->proxcirc),3)",;
     /* pre-validacao */    "nivelop=3",;
     /* validacao     */    "",;
     /* help do campo */    "Informe o n£mero da CIRCULAR a emitir.";
                         };
)
AADD(sistema[019,O_CAMPO],{;            // CIRCULAR
     /* mascara       */    "99",;
     /* titulo        */    "Procpend",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "V",;
     /* help do campo */    "";
                         };
)
AADD(sistema[019,O_CAMPO],{;            // CIRCULAR
     /* mascara       */    "@D",;
     /* titulo        */    "Emiss„o",;
     /* cmd especial  */    "",;
     /* default       */    "DATE()",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(emissao_)~Necess rio informar EMISSŽO",;
     /* help do campo */    "Data da Emiss„o da Circular";
                         };
)
AADD(sistema[019,O_CAMPO],{;            // CIRCULAR
     /* mascara       */    "@R 99/99",;
     /* titulo        */    "Mˆs Ref.",;
     /* cmd especial  */    "",;
     /* default       */    "SUBSTR(DTOC(emissao_),4,2)+RIGHT(DTOC(emissao_),2)",;
     /* pre-validacao */    "",;
     /* validacao     */    "MMAA(mesref)~MES REF. n„o aceit vel",;
     /* help do campo */    "Entre com o mˆs de referˆncia desta circular.";
                         };
)
AADD(sistema[019,O_CAMPO],{;            // CIRCULAR
     /* mascara       */    "@E 999,999.99",;
     /* titulo        */    "Valor",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "valor>0~VALOR n„o aceit vel",;
     /* help do campo */    "";
                         };
)
AADD(sistema[019,O_CAMPO],{;            // CIRCULAR
     /* mascara       */    "@S35",;
     /* titulo        */    "Mensagem",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    "Entre com uma mensagem exclusiva … ‚sta circular.";
                         };
)
AADD(sistema[019,O_CAMPO],{;            // CIRCULAR
     /* mascara       */    "",;
     /* titulo        */    "Mensagem",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    "Entre com uma mensagem exclusiva … ‚sta circular.";
                         };
)
AADD(sistema[019,O_CAMPO],{;            // CIRCULAR
     /* mascara       */    "",;
     /* titulo        */    "Mensagem",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    "Entre com uma mensagem exclusiva … ‚sta circular.";
                         };
)
AADD(sistema[019,O_CAMPO],{;            // CIRCULAR
     /* mascara       */    "999999",;
     /* titulo        */    "Emitidos",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[019,O_CAMPO],{;            // CIRCULAR
     /* mascara       */    "999999",;
     /* titulo        */    "Pagos",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[019,O_CAMPO],{;            // CIRCULAR
     /* mascara       */    "999999",;
     /* titulo        */    "Cancelados",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[019,O_CAMPO],{;            // CIRCULAR
     /* mascara       */    "@D",;
     /* titulo        */    "Lancamento",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "V",;
     /* help do campo */    "";
                         };
)
AADD(sistema[019,O_CAMPO],{;            // CIRCULAR
     /* mascara       */    "",;
     /* titulo        */    "Usu rio",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "V",;
     /* help do campo */    "";
                         };
)
AADD(sistema[019,O_CAMPO],{;            // CIRCULAR
     /* mascara       */    "@D",;
     /* titulo        */    "Impress„o",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "V",;
     /* help do campo */    "";
                         };
)
AADD(sistema[019,O_FORMULA],{;          // CIRCULAR - Descri‡„o
     /* form mostrar  */    "LEFT(TRAN(IIF(CLASSES->prior=[S],[Valor por mˆs......:],IIF(ARQGRUP->maxproc>ARQGRUP->acumproc,[Valor p/atendimento:],[Valor da circular.:])),[]),18)",;
     /* lin da formula*/    3,;
     /* col da formula*/    2;
                         };
)

* \\ Final de ADR_ATR1.PRG
/*
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
 \ Empresa.: Grupo Bom Pastor
 \ Programa: ADM_R033.PRG
 \ Data....: 12-11-96
 \ Sistema.: Administradora -CRD/COBRAN€A
 \ Funcao..: Taxas (2¦ Via)
 \ Analista: Ademilson Pedro Bom
 \ Criacao.: GAS-Pro v2.0d
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/

#include "adcbig.ch"    // inicializa constantes manifestas

LOCAL dele_atu, getlist:={}
PARA  lin_menu, col_menu
PRIV  tem_borda:=.t., op_menu:=VAR_COMPL, l_s:=8, c_s:=16, l_i:=13, c_i:=59, tela_fundo:=SAVESCREEN(0,0,MAXROW(),79)
	   twinic()
	   twdeflbars(2, 6)
	   twdefprint(twepson)

do while .t.

nucop=1
SETCOLOR(drvtittel)
vr_memo=NOVAPOSI(@l_s,@c_s,@l_i,@c_i)     // pega posicao atual da tela
CAIXA(mold,l_s,c_s,l_i,c_i)               // monta caixa da tela
@ l_s,c_s+14 SAY " TAXAS (2¦ VIA) "
SETCOLOR(drvcortel)
@ l_s+01,c_s+1 SAY " Contrato:"
@ l_s+04,c_s+1 SAY " Circular:                  Confirma?"
rcodigo=SPAC(5)                                    // Codigo
rcirc=SPAC(3)                                      // Circular
confirme=SPAC(1)                                   // Confirme?
DO WHILE .t.
 rola_t=.f.
 cod_sos=56
 SET KEY K_ALT_F8 TO ROLATELA
 SETCOLOR(drvcortel+","+drvcorget+",,,"+corcampo)
 @ l_s+01 ,c_s+12 GET  rcodigo;
                  PICT "99999";
                  VALI CRIT("PTAB(rcodigo,'GRUPOS',3)~Necess rio informar CODIGO")
                  AJUDA "Informe o n£mero do contrato"
                  CMDF8 "VDBF(6,3,20,77,'GRUPOS',{'grupo','codigo','nome','cidade'},3,'codigo',[])"
                  MOSTRA {"LEFT(TRAN(GRUPOS->nome,[@!]),35)", 2 , 5 }
                  MOSTRA {"LEFT(TRAN(GRUPOS->endereco,[]),35)", 3 , 5 }

 @ l_s+04 ,c_s+12 GET  rcirc;
		  PICT "999";
                  VALI CRIT("PTAB(rcodigo+rcirc,'TAXAS',1)~Necess rio informar CIRCULAR v lida")
                  AJUDA "Informe o n£mero da circular a imprimir"

 @ l_s+04 ,c_s+39 GET  confirme;
                  PICT "!";
                  VALI CRIT("confirme='S'.AND.V03301F9()~Digite S para confirmar|ou|Tecle ESC para cancelar")
                  AJUDA "Digite S para confirmar|ou|Tecle ESC para cancelar"

 READ
 SET KEY K_ALT_F8 TO
 IF rola_t
  ROLATELA(.f.)
  LOOP
 ENDI
 IF LASTKEY()=K_ESC                                // se quer cancelar
  RETU                                             // retorna
 ENDI

 #ifdef COM_REDE
  IF !USEARQ("GRUPOS",.f.,10,1)                    // se falhou a abertura do arq
   RETU                                            // volta ao menu anterior
  ENDI
 #else
  USEARQ("GRUPOS")                                 // abre o dbf e seus indices
 #endi

 PTAB(grupo,"ARQGRUP",1,.t.)                       // abre arquivo p/ o relacionamento
 PTAB(regiao,"REGIAO",1,.t.)
 PTAB(M->mcodigo+M->mcirc,"TAXAS",1,.t.)
 PTAB(grupo+TAXAS->circ,"CIRCULAR",1,.t.)
 SET RELA TO grupo INTO ARQGRUP,;                  // relacionamento dos arquivos
	  TO regiao INTO REGIAO,;
	  TO M->mcodigo+M->mcirc INTO TAXAS,;
	  TO grupo+TAXAS->circ INTO CIRCULAR
 titrel:=criterio := ""                            // inicializa variaveis
 cpord="codigo"
 titrel:=chv_rela:=chv_1:=chv_2 := ""
 tps:=op_x:=ccop := 1

// IF !opcoes_rel(lin_menu,col_menu,23,11)           // nao quis configurar...
//  CLOS ALL                                         // fecha arquivos e
//  LOOP                                             // volta ao menu
// ENDI
 IF tps=2                                          // se vai para arquivo/video
  arq_=ARQGER()                                    // entao pega nome do arquivo
  IF EMPTY(arq_)                                   // se cancelou ou nao informou
   LOOP                                            // retorna
  ENDI
 ELSE
  arq_=drvporta                                    // porta de saida configurada
 ENDI

 SET PRINTER TO (arq_)                             // redireciona saida
 EXIT
ENDD
criterio_=criterio                                 // salva criterio e ordenacao
cpord_=cpord                                       // definidos se huver
criterio=""

#ifdef COM_REDE
 IF !USEARQ("CPRCIRC",.f.,10,1)                    // se falhou a abertura do arq
  RETU                                             // volta ao menu anterior
 ENDI
#else
 USEARQ("CPRCIRC")                                 // abre o dbf e seus indices
#endi

cpord="grupo+circ+DTOS(dfal)"
INDTMP()
criterio=criterio_                                 // restabelece criterio e
cpord=cpord_                                       // ordenacao definidos
SELE GRUPOS
IF !EMPTY(drvtapg)                                 // existe configuracao de tam pag?
 op_=AT("NNN",drvtapg)                             // se o codigo que altera
 IF op_=0                                          // o tamanho da pagina
  msg="Configura‡„o do tamanho da p gina!"         // foi informado errado
  DBOX(msg,,,,,"ERRO!")                            // avisa
  CLOSE ALL                                        // fecha todos arquivos abertos
  RETU                                             // e cai fora...
 ENDI                                              // codigo para setar/resetar tam pag
 lpp_048=LEFT(drvtapg,op_-1)+"048"+SUBS(drvtapg,op_+3)
 lpp_066=LEFT(drvtapg,op_-1)+"066"+SUBS(drvtapg,op_+3)
ELSE
 lpp_048:=lpp_066 :=""                             // nao ira mudara o tamanho da pag
ENDI
DBOX("[ESC] Interrompe",15,,,NAO_APAGA)
dele_atu:=SET(_SET_DELETED,.t.)                    // os excluidos nao servem...
SET DEVI TO PRIN                                   // inicia a impressao
maxli=19                                           // maximo de linhas no relatorio
IMPCTL(lpp_048)                                    // seta pagina com 48 linhas
SET MARG TO 1                                      // ajusta a margem esquerda
BEGIN SEQUENCE
 DO WHIL ccop<=nucop                               // imprime qde copias pedida
  pg_=1; cl=999
  INI_ARQ()                                        // acha 1o. reg valido do arquivo
  SEEK M->rcodigo
  ccop++                                           // incrementa contador de copias
  ult_imp=0                                        // ultimo reg impresso
  DO WHIL !EOF()
   IF INKEY()=K_ESC                                // se quer cancelar
    IF canc()                                      // pede confirmacao
     BREAK                                         // confirmou...
    ENDI
   ENDI
   IF codigo=M->rcodigo                            // se atender a condicao...
    chv038=grupo+M->mcirc
    SELE CPRCIRC
    SEEK chv038
//    IF FOUND()
//     DO WHIL ! EOF() .AND. chv038=LEFT(&(INDEXKEY(0)),LEN(chv038))
//      IF INKEY()=K_ESC                             // se quer cancelar
//       IF canc()                                   // pede confirmacao
//	BREAK                                      // confirmou...
//       ENDI
//      ENDI
      REL_CAB(1,.t.)                               // soma cl/imprime cabecalho
      IMPCTL(drvpc20)                              // comprime os dados
      @ cl,030 SAY '999' //num                             // Contrato
      @ cl,041 SAY '99999/99'      //processo                        // Processo
      @ cl,054 SAY 'XXXXXXXXXXXX'  //fal                             // Falecido
      @ cl,091 SAY 'XXXXXXXXXXXX'  //TRAN(ALLTRIM(ends)+'-'+ALLTRIM(cids),"@!")// Ends
      @ cl,149 SAY '99/99/99'      //TRAN(dfal,"@D")                 // Data
      IMPCTL(drvtc20)                              // retira comprimido
//      SKIP                                         // pega proximo registro
//     ENDD
//    ENDI
    SELE GRUPOS                                    // volta ao arquivo pai
    ult_imp=RECNO()                                // ultimo reg impresso
    SKIP                                           // pega proximo registro
    cl=999                                         // forca salto de pagina
   ELSE                                            // se nao atende condicao
    SKIP                                           // pega proximo registro
   ENDI
  ENDD
  REL_RDP(.t.)                                     // imprime rodape' do relatorio
 ENDD ccop
 EJEC                                              // salta pagina
END SEQUENCE
SET MARG TO                                        // coloca margem esquerda = 0
IMPCTL(lpp_066)                                    // seta pagina com 66 linhas
SET PRINTER TO (drvporta)                          // fecha arquivo gerado (se houver)
SET DEVI TO SCRE                                   // direciona saida p/ video
IF tps=2                                           // se vai para arquivo/video
 BROWSE_REL(arq_,2,3,MAXROW()-2,78)                // mostra o arquivo gravado
ENDI
GRELA(23)                                          // grava variacao do relatorio
SELE GRUPOS                                        // salta pagina
SET RELA TO                                        // retira os relacionamentos
SET(_SET_DELETED,dele_atu)                         // os excluidos serao vistos

enddo

RETU

STATIC PROC REL_RDP(volta_reg)                     // rodape'
LOCAL ar_:=ALIAS(), reg_atual
SELE GRUPOS                                        // volta ao arquivo pai
reg_atual=RECNO()
IF volta_reg
 GO ult_imp                                        // ajusta reg p/ imp de campos no rodape'
ENDI
@ 21,008 SAY CHR(18)+CIRCULAR->menscirc            // Mensagem
@ 25,017 SAY TRAN(TAXAS->valor,"@E 999,999.99")           // Valor
@ 25,065 SAY TRAN(TAXAS->valor,"@E 999,999.99")           // Valor 2
@ 28,020 SAY TRAN(0,"########")                    // N§ Recibo
@ 28,068 SAY TRAN(0,"########")                    // N§ Recibo 2
@ 31,002 SAY TAXAS->circ+[     ]+DTOC(TAXAS->emissao_)+[     ]+STR(GRUPOS->funerais,2)// Circular 1
@ 31,038 SAY TAXAS->circ+[     ]+DTOC(TAXAS->emissao_)+[     ]+STR(GRUPOS->funerais,2)// Circular 2
@ 34,002 SAY GRUPOS->grupo +[        ]+codigo+[       ]+GRUPOS->cobrador// Grupo 1
@ 34,038 SAY GRUPOS->grupo +[        ]+codigo+[       ]+GRUPOS->cobrador// Grupo 2
@ 36,000 SAY GRUPOS->nome                          // Nome
@ 36,036 SAY GRUPOS->nome                          // Nome 2
@ 37,000 SAY GRUPOS->endereco                      // Endere‡o
@ 37,036 SAY GRUPOS->endereco                      // Endere‡o 2
@ 38,000 SAY GRUPOS->bairro                        // Bairro
@ 38,036 SAY GRUPOS->bairro                        // Bairro 2
@ 39,000 SAY GRUPOS->cidade+[ ] +GRUPOS->cep       // Cidade
@ 39,036 SAY GRUPOS->cidade+[ ] +GRUPOS->cep       // Cidade 2
@ 40,000 SAY [Inic:]+DTOC(GRUPOS->admissao)+[ Ult:]+GRUPOS->ultcirc+[ QtTx:]+STR(GRUPOS->qtcircs,3)// Inicio
@ 40,036 SAY [Inic:]+DTOC(GRUPOS->admissao)+[ Ult:]+GRUPOS->ultcirc+[ QtTx:]+STR(GRUPOS->qtcircs,3)// Inicio 2
@ 42,018 SAY R03301F9()                            // BarCode
@ 43,002 SAY [ ]                                   // data 1
@ 43,039 SAY [ ]                                   // data 2
IF volta_reg
 GO reg_atual                                      // retorna reg a posicao original
ENDI
SELE (ar_)
RETU 

STATIC PROC REL_CAB(qt, volta_reg)                 // cabecalho do relatorio
LOCAL ar_:=ALIAS()
volta_reg=IF(volta_reg=NIL,.f.,volta_reg)
IF qt>0                                            // se parametro maior que 0
 cl=cl+qt                                          // soma no contador de linhas
ENDI
IF cl>maxli .OR. qt=0                              // quebra de pagina
 IF pg_>1
  REL_RDP(volta_reg)                               // imprime rodape' do relatorio
 ENDI
 SELE GRUPOS                                       // volta ao arquivo pai
 @ 1,007 SAY GRUPOS->nome                          // Nome
 @ 1,058 SAY TRAN(GRUPOS->codigo,"99999")                  // Codigo
 @ 1,076 SAY TRAN(GRUPOS->grupo,"!9")              // Grupo
 @ 3,032 SAY TRAN(TAXAS->valor,"@E 999,999.99")           // Valor
 SELE (ar_)
 cl=qt+7 ; pg_++
ENDI
RETU

* \\ Final de ADM_R033.PRG
procedure adm_rx20
/*
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
 \ Empresa.: PresServ Inform tica-Limeira (019)452.6623
 \ Programa: ADM_RX20.PRG
 \ Data....: 22-09-97
 \ Sistema.: Administradora - RECEP€„O
 \ Funcao..: Impress„o Aux.Funeral 2
 \ Analista: Ademilson Pedro Bom
 \ Criacao.: GAS-Pro v3.0 
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/

#include "adrbig.ch"    // inicializa constantes manifestas

LOCAL dele_atu, getlist:={}, so_um_reg, sit_dbf:=POINTER_DBF()
PARA  lin_menu, col_menu, imp_reg
PRIV  tem_borda:=.t., op_menu:=VAR_COMPL, l_s:=10, c_s:=20, l_i:=13, c_i:=61, tela_fundo:=SAVESCREEN(0,0,MAXROW(),79)
nucop=1
so_um_reg=(PCOU()>2)
IF !so_um_reg                             // vai receber a variaveis?
 SETCOLOR(drvtittel)
 vr_memo=NOVAPOSI(@l_s,@c_s,@l_i,@c_i)    // pega posicao atual da tela
 CAIXA(mold,l_s,c_s,l_i,c_i)              // monta caixa da tela
 @ l_s,c_s+10 SAY " IMPRESSŽO AUX.FUNERAL "
 SETCOLOR(drvcortel)
 @ l_s+01,c_s+1 SAY " Processo:"
 @ l_s+02,c_s+1 SAY " Confirme:"
ENDI
rproc=SPAC(11)                                     // Processo
confirme=SPAC(1)                                   // Confirme
DO WHILE .t.
 rola_t=.f.
 cod_sos=56
 IF !so_um_reg
  SET KEY K_ALT_F8 TO ROLATELA
  SETCOLOR(drvcortel+","+drvcorget+",,,"+corcampo)
  @ l_s+01 ,c_s+12 GET  rproc;
                   PICT "@R 99999/9999-99";
                   VALI CRIT("!EMPT(RPROC).AND.PTAB(rproc,[AFUNER],1)~Campo utilizado para localiza‡„o dos documentos.|Tecle F8 para busca em tabela")
                   DEFAULT "IIF(PTAB(PADR(SUBSTR(M->ide_maq,2),4)+[AFU],[IMPPAR],1),ALLTRIM(IMPPAR->docto),[])"
                   AJUDA "Digite neste campo o n£mero de|identifica‡„o do processo"
                   CMDF8 "VDBF(6,12,20,77,'AFUNER',{'processo','proc2','categ','contrato','falecido'},1,'V02001F9()',[])"

  @ l_s+02 ,c_s+12 GET  confirme;
                   PICT "!";
                   VALI CRIT("confirme='S'.AND.V02002F9()~CONFIRME n„o aceit vel|Digite S para confirmar|ou|Tecle ESC para cancelar")
                   AJUDA "Digite S para confirmar|ou|tecle ESC para cancelar"

  READ
  SET KEY K_ALT_F8 TO
  IF rola_t
   ROLATELA(.f.)
   LOOP
  ENDI
  IF LASTKEY()=K_ESC                               // se quer cancelar
   RETU                                            // retorna
  ENDI
 ENDI

 #ifdef COM_REDE
  IF !USEARQ("AFUNER",.f.,10,1)                    // se falhou a abertura do arq
   RETU                                            // volta ao menu anterior
  ENDI
 #else
  USEARQ("AFUNER")                                 // abre o dbf e seus indices
 #endi

 PTAB(contrato,"GRUPOS",1,.t.)                     // abre arquivo p/ o relacionamento
 PTAB(contrato,"INSCRITS",1,.t.)
 SET RELA TO contrato INTO GRUPOS,;                // relacionamento dos arquivos
          TO contrato INTO INSCRITS
 titrel:=criterio:=cpord := ""                     // inicializa variaveis
 titrel:=chv_rela:=chv_1:=chv_2 := ""
 tps:=op_x:=ccop := 1
 arq_=drvporta                                     // porta de saida configurada
 IF !so_um_reg
  IF !opcoes_rel(lin_menu,col_menu,3,11)           // nao quis configurar...
   CLOS ALL                                        // fecha arquivos e
   LOOP                                            // volta ao menu
  ENDI

 #ifdef COM_REDE

  ELSE

   tps=lin_menu

 #endi

 ENDI
 IF tps=2                                          // se vai para arquivo/video
  arq_=ARQGER()                                    // entao pega nome do arquivo
  IF EMPTY(arq_)                                   // se cancelou ou nao informou
   LOOP                                            // retorna
  ENDI
 ELSE
  arq_=drvporta                                    // porta de saida configurada
 ENDI
 IF "4WIN"$UPPER(drvmarca) // nome da configuracao/marca impressora
    arq_:=drvdbf+"WIN"+ide_maq
    tps:=3                                          // se vai para arquivo/video
 ENDIF
 SET PRINTER TO (arq_)                             // redireciona saida
 EXIT
ENDD
DBOX("[ESC] Interrompe",15,,,NAO_APAGA)
dele_atu:=SET(_SET_DELETED,.t.)                    // os excluidos nao servem...
SET DEVI TO PRIN                                   // inicia a impressao
maxli=62                                           // maximo de linhas no relatorio
BEGIN SEQUENCE
 DO WHIL ccop<=nucop                               // imprime qde copias pedida
  pg_=1; cl=999
  IF so_um_reg
   GO imp_reg
  ELSE
   INI_ARQ()                                       // acha 1o. reg valido do arquivo
   IF PTAB(PADR(SUBSTR(M->ide_maq,2),4)+[AFU],[IMPPAR],1)
    PTAB(LEFT(IMPPAR->docto,11),'AFUNER',1)
   ENDI
  ENDI
  ccop++                                           // incrementa contador de copias
  DO WHIL !EOF().AND.(!so_um_reg.OR.imp_reg=RECN())
   #ifdef COM_TUTOR
    IF IN_KEY()=K_ESC                              // se quer cancelar
   #else
    IF INKEY()=K_ESC                               // se quer cancelar
   #endi
    IF canc()                                      // pede confirmacao
     BREAK                                         // confirmou...
    ENDI
   ENDI
   IF (PTAB(PADR(SUBSTR(M->ide_maq,2),4)+[AFU],[IMPPAR],1).and.processo+proc2+filial+categ=ALLTRIM(IMPPAR->docto)) .OR. so_um_reg// se atender a condicao...
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,054 SAY "Processo"
    IMPCTL(drvpenf)
    @ cl,063 SAY TRAN(processo+proc2+filial,"@R 99999/99/!!")// Nr.Processo
    IMPCTL(drvtenf)
    REL_CAB(2)                                     // soma cl/imprime cabecalho
    @ cl,003 SAY "Nome do Contratante:"
    IMPCTL(drvpenf)
    @ cl,024 SAY TRAN(IIF(PTAB(contrato+GRUPOS->titular,'INSCRITS',1),INSCRITS->nome,GRUPOS->nome),"@!")// Nome do contratante
    IMPCTL(drvtenf)
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    IMPAC("Endere‡o:",cl,003)
    IMPCTL(drvpenf)
    @ cl,013 SAY TRAN(xDECRIPT(GRUPOS->endereco),"@!")       // Endereco contratante
    IMPCTL(drvtenf)
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,005 SAY "Cidade               Estado  Documento de Identidade Estado Civil"
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    IMPCTL(drvpenf)
    @ cl,005 SAY TRAN(xDECRIPT(GRUPOS->cidade),"@!")         // cidade contratante
    IMPCTL(drvtenf)
    @ cl,028 SAY TRAN([  ],"!!")                   // Estado Contratante
    IMPCTL(drvpenf)
    @ cl,037 SAY GRUPOS->rg                        // Doc
    IMPCTL(drvtenf)
    IMPCTL(drvpenf)
    @ cl,059 SAY TRAN(subst(tbestciv,AT(GRUPOS->estcivil,tbestciv),10),"@!")// Est.Civil contratante
    IMPCTL(drvtenf)
    REL_CAB(2)                                     // soma cl/imprime cabecalho
    IMPAC("Contrato    Grupo            Admiss„o                 Processo",cl,005)
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    IMPCTL(drvpenf)
    @ cl,005 SAY contrato                          // contrato numero
    IMPCTL(drvtenf)
    IMPCTL(drvpenf)
    @ cl,018 SAY GRUPOS->grupo                     // grupo
    IMPCTL(drvtenf)
    IMPCTL(drvpenf)
    @ cl,034 SAY GRUPOS->admissao                  // data admissao
    IMPCTL(drvtenf)
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    IMPMEMO(Rx2001F9(),70,1,cl,001,.t.)            // pedido (memo)
    qli_m=MLCOUNT(Rx2001F9(),70)-1                 // quantas linhas a imprimir?
    li_m=0
    DO WHIL .t.                                    // imprime linhas do memo
     li_m++
     IF li_m>qli_m                                 // fim do memo
      EXIT
     ENDI
     REL_CAB(1)                                    // soma cl/imprime cabecalho
     IMPMEMO(Rx2001F9(),70,1+li_m,cl,001,(li_m<qli_m))      // imprime...
     #ifdef COM_TUTOR
      IF IN_KEY()=K_ESC                            // se quer cancelar
     #else
      IF INKEY()=K_ESC                             // se quer cancelar
     #endi
      IF canc()                                    // pede confirmacao
       BREAK                                       // confirmou...
      ENDI
     ENDI
    ENDD
    REL_CAB(2)                                     // soma cl/imprime cabecalho
    @ cl,004 SAY "Nome do falecido....:"
    IMPCTL(drvpenf)
    @ cl,026 SAY TRAN(falecido,"@!")               // nome do falecido
    IMPCTL(drvtenf)
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    IMPAC("Endere‡o do falecido:",cl,004)
    IMPCTL(drvpenf)
    @ cl,026 SAY TRAN(ALLTRIM(ruares)+[, ]+ALLTRIM(baires),"@!")// Endereco falecido
    IMPCTL(drvtenf)
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,004 SAY "Inscrito neste contrato na qualidade de"
    IMPCTL(drvpenf)
    @ cl,044 SAY grauparcon                        // Inscrito na qualidade de
    IMPCTL(drvtenf)
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,004 SAY "Data do Falecimento.:"
    @ cl,026 SAY TRAN(falecto_,"@D")               // Data falcto.
    IMPAC("Hor rio do Falecimento:",cl,036)
    @ cl,060 SAY TRAN(horafal,"99:99")             // Hora Falcto.
    REL_CAB(2)                                     // soma cl/imprime cabecalho
    @ cl,004 SAY "Cidade do Falecimento Estado   Local do falecimento"
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    IMPCTL(drvpenf)
    @ cl,004 SAY municfal                          // Cidade Falecimento
    IMPCTL(drvtenf)
    IMPCTL(drvpenf)
    @ cl,028 SAY TRAN(estfal,"!!")                 // UF falecimento
    IMPCTL(drvtenf)
    IMPCTL(drvpenf)
    @ cl,035 SAY ALLTRIM(ruafal)                   // local falecimento
    IMPCTL(drvtenf)
    REL_CAB(2)                                     // soma cl/imprime cabecalho
    IMPAC("Cemit‚rio onde foi sepultado        Hora do sepultamento",cl,004)
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    IMPCTL(drvpenf)
    @ cl,004 SAY cemitsep                          // Cemit‚rio sepultamento
    IMPCTL(drvtenf)
    IMPCTL(drvpenf)
    @ cl,046 SAY TRAN(horasepult,"99:99")          // Hora sepultamento
    IMPCTL(drvtenf)
    REL_CAB(2)                                     // soma cl/imprime cabecalho
    IMPAC("DECLARA€ŽO",cl,031)
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    IMPMEMO(Rx2002F9(),70,1,cl,002,.t.)            // DECLARACAO (memo)
    qli_m=MLCOUNT(Rx2002F9(),70)-1                 // quantas linhas a imprimir?
    li_m=0
    DO WHIL .t.                                    // imprime linhas do memo
     li_m++
     IF li_m>qli_m                                 // fim do memo
      EXIT
     ENDI
     REL_CAB(1)                                    // soma cl/imprime cabecalho
     IMPMEMO(Rx2002F9(),70,1+li_m,cl,002,(li_m<qli_m))      // imprime...
     #ifdef COM_TUTOR
      IF IN_KEY()=K_ESC                            // se quer cancelar
     #else
      IF INKEY()=K_ESC                             // se quer cancelar
     #endi
      IF canc()                                    // pede confirmacao
       BREAK                                       // confirmou...
      ENDI
     ENDI
    ENDD
    REL_CAB(2)                                     // soma cl/imprime cabecalho
    @ cl,025 SAY IMPAC(RTRIM(M->p_cidade)+[, ]+LEFT(DTOC(DATE()),2)+[ de ]+NMES(MONTH(DATE()))+ [ de ]+LEFT(DTOS(DATE()),4))// DATA
    REL_CAB(2)                                     // soma cl/imprime cabecalho
//    @ cl,001 SAY "PROCESSAR"
    REL_CAB(1)                                     // soma cl/imprime cabecalho
//    @ cl,000 SAY "PAGAMENTO EM"
    REL_CAB(1)                                     // soma cl/imprime cabecalho
//    IMPCTL(drvpenf)
//    @ cl,002 SAY TRAN(procpagto_,"@D")             // Proc.pagto em
//    IMPCTL(drvtenf)
    REL_CAB(3)                                     // soma cl/imprime cabecalho
    @ cl,021 SAY REPL("-",42)
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,021 SAY "Ass.:"
    IMPCTL(drvpenf)
    @ cl,027 SAY GRUPOS->nome                      // Nome
    IMPCTL(drvtenf)
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,027 SAY "RG:"
    @ cl,031 SAY TRAN(GRUPOS->rg,"@!")             // R.G.
    SKIP                                           // pega proximo registro
    cl=999                                         // forca salto de pagina
   ELSE                                            // se nao atende condicao
    SKIP                                           // pega proximo registro
   ENDI
   EXIT
  ENDD
 ENDD ccop
END SEQUENCE
SET PRINTER TO (drvporta)                          // fecha arquivo gerado (se houver)
SET DEVI TO SCRE                                   // direciona saida p/ video
IF tps=2                                           // se vai para arquivo/video
 BROWSE_REL(arq_,2,3,MAXROW()-2,78)
ENDI                                               // mostra o arquivo gravado
GRELA(3)                                           // grava variacao do relatorio
SELE AFUNER                                        // salta pagina
SET RELA TO                                        // retira os relacionamentos
SET(_SET_DELETED,dele_atu)                         // os excluidos serao vistos
IF so_um_reg
 POINTER_DBF(sit_dbf)
ENDI
RETU

STATIC PROC REL_CAB(qt)                            // cabecalho do relatorio
IF qt>0                                            // se parametro maior que 0
 cl=cl+qt                                          // soma no contador de linhas
ENDI
IF cl>maxli .OR. qt=0                              // quebra de pagina
 @ 0,001 SAY IIF(categ=[PD],[Plano c/Difer. ],IIF(categ=[PL],[Atend.Plano],[Rest.Desp.Funerais]))// Categoria
 @ 5,021 SAY M->setup1                             // Ident1
    IMPCTL(drvPenf)
 @ 6,021 SAY "REQUERIMENTO DE PAGAMENTO/ATENDIMENTO"
 @ 7,022 SAY "FUNERAL E TERMO DE RESPONSABILIDADE"
    IMPCTL(drvtenf)
 cl=qt+8 ; pg_++
ENDI
RETU

* \\ Final de ADM_RX20.PRG
GAS-Pro v4.0
009018018067001008033001017001176001
 Taxa ³    M U L T A      ³    J U R O S
 Tipo ³  %       Carˆncia ³   %      Carˆncia
ÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
      ³                   ³
      ³                   ³
      ³                   ³
      ³                   ³
      ³                   ³
[Ÿ]
Inclus„o~~26006
Manuten‡„o~~27007
Consulta~~28008
[Ÿ]
 5 
 1 
Tipo

 1 
[Ÿ]
Parƒmetro de Juros
Parƒmetro de Juros







005
























 0 











 0 
 3 
-1 
-1 
-1 
-1 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
tipo
C
E
9
 1 
 1 
 4 
 2 
 0 
Tipo

!EMPT(tipo)
TIPO n„o aceit vel|Deve ser n£mero positivo

Qual o tipo de lan‡amento
MTAB([1=J¢ia |2=Taxa |3=Carnˆ|4=Acerto],[TIPO])
 0 
 0 


multa
N
E
99.99
 5 
 5 
 4 
 9 
 2 
Multa %

multa>=0
MULTA % n„o aceit vel

Informe a porcentagem de multa

 0 
 0 


mltcaren
N
E
999
 3 
 3 
 4 
 20 
 0 
Carˆncia

mltcaren>=0
CARENCIA n„o aceit vel

Informe a carˆncia para a |aplica‡„o da multa|em dias.

 0 
 0 


juros
N
E
9.999
 5 
 5 
 4 
 29 
 3 
Juros %

juros>=0
JUROS % n„o aceit vel|deve ser maior ou igual a zeros|(Juros Di rios)

Informe a porcentagem do Juros di rios

 0 
 0 


jrscaren
N
E
999
 3 
 3 
 4 
 41 
 0 
Carˆncia

jrscaren>=0
CARENCIA n„o aceit vel|deve ser maior ou igual a zeros

Informe a carˆncia para a |aplica‡„o do juros|em dias.

 0 
 0 


 0 
 0 
 0 
 0 
 0 
procedure adr_menu
/*
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
 \ Empresa.: PresServ Inform tica - Limeira (019)452.6623
 \ Programa: ADR_MENU.PRG
 \ Data....: 22-01-08
 \ Sistema.: Administradora - RECEP€„O
 \ Funcao..: Menu geral da aplica‡„o
 \ Analista: Ademilson Pedro Bom
 \ Criacao.: GAS-Pro v4.0o
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/

#include "adrbig.ch"    // inicializa constantes manifestas

opc_01=1
v01=SAVESCREEN(0,0,MAXROW(),79)
DO WHIL opc_01!=0
 cod_sos=3
 RESTSCREEN(0,0,MAXROW(),79,v01)
 menu01="Lan‡amentos~1|"+;
        "A.Funeral~2|"+;
        "Relat¢rios~3|"+;
        "Tabelas~4|"+;
        "Apoio~5"
 opc_01=DBOX(menu01,0,,E_POPMENU,NAO_APAGA,,,,opc_01)
 BEGIN SEQUENCE
  DO CASE
   CASE opc_01=0      // retornar ao DOS
    ALERTA()
    msgt="ENCERRAMENTO"
    msg ="Finalizar opera‡”es|N„o finalizar"
    cod_sos=1
    op_=DBOX(msg,,,E_MENU,,msgt,,,1)
    IF op_!=1
     opc_01=1
    ENDI

   CASE opc_01=1     // lan‡amentos
    opc_02=1
    v02=SAVESCREEN(0,0,MAXROW(),79)
    DO WHIL opc_02!=0
     cod_sos=4
     RESTSCREEN(0,0,MAXROW(),79,v02)
     menu02="Recebimentos~1|"+;
            "Endere‡os~2|"+;
            "Outros Recebimentos~3|"+;
            "Consulta Contratos~4|"+;
            "Emiss„o de Guias~5|"+;
            "Avisos / Carencias~6|"+;
            "Cartinha/Falecidos~7|"+;
            "Ajuda Procedimentos~8"
     msgt="LAN€AMENTOS"
     ROLAPOP(1)
     opc_02=DBOX(menu02,1,2,E_MENU,NAO_APAGA,msgt,,,opc_02)
     ROLAPOP()
     DO CASE
      CASE opc_02=1     // recebimentos
       BXREC(3,10)

      CASE opc_02=2     // endere‡os
       ALENDER(3,10)

      CASE opc_02=3     // outros recebimentos
       OBXEC(3,10)

      CASE opc_02=4     // consulta contratos
       GRUPOS(3,10)

      CASE opc_02=5     // emiss„o de guias
       GUIAS(3,10)

      CASE opc_02=6     // avisos / carencias
       MFILIAL(3,10)

      CASE opc_02=7     // Cartinha de Falecidos
       ADP_R101(3,10)

      CASE opc_02=8     // Ajuda aos Procedimentos
       ADR_MANU(3,10)

     ENDC
     CLEA GETS
     CLOS ALL
    ENDD

   CASE opc_01=2     // a.funeral
    opc_02=1
    v02=SAVESCREEN(0,0,MAXROW(),79)
    DO WHIL opc_02!=0
     cod_sos=4
     RESTSCREEN(0,0,MAXROW(),79,v02)
     menu02="Lan‡amento Aux.Funeral~1|"+;
            "Impress„o Modelo 1~2|"+;
            "Recibo Modelo 1~3|"+;
            "Impress„o Modelo 2~4|"+;
            "Recibo Modelo 2~5|"+;
            "Relat¢rio de Processo~6|"+;
            "Capa de Processo~7|"+;
            "Processar Pgto em~8"
     msgt="A.FUNERAL"
     ROLAPOP(1)
     opc_02=DBOX(menu02,1,15,E_MENU,NAO_APAGA,msgt,,,opc_02)
     ROLAPOP()
     DO CASE
      CASE opc_02=1     // lan‡amento aux.funeral
       AFUNER(3,23)

      CASE opc_02=2     // impress„o modelo 1
       ADM_R020(3,23)

      CASE opc_02=3     // recibo modelo 1
       ADR_R029(3,23)

      CASE opc_02=4     // impress„o modelo 2
       ADM_RX20(3,23)

      CASE opc_02=5     // recibo modelo 2
       ADR_RX29(3,23)

      CASE opc_02=6     // relat¢rio de processo
       ADM_R029(3,23)

      CASE opc_02=7     // capa de processo
       ADM_R026(3,23)

      CASE opc_02=8     // processar pgto em
       ADM_R021(3,23)

     ENDC
     CLEA GETS
     CLOS ALL
    ENDD

   CASE opc_01=3     // relat¢rios
    opc_02=1
    v02=SAVESCREEN(0,0,MAXROW(),79)
    DO WHIL opc_02!=0
     cod_sos=4
     RESTSCREEN(0,0,MAXROW(),79,v02)
     menu02="Documento … Imprimir~1|"+;
            "Recibos (2¦via)~2|"+;
            "Outros recibos (2¦Via)~3|"+;
            "Endere‡os Alterados~4|"+;
            "Emissao de guia~5|"+;
            "Fechamento Caixa~6|"+;
            "Ficha de Acerto~7"
     msgt="RELAT¢RIOS"
     ROLAPOP(1)
     opc_02=DBOX(menu02,1,26,E_MENU,NAO_APAGA,msgt,,,opc_02)
     ROLAPOP()
     DO CASE
      CASE opc_02=1     // documento … imprimir
       DCI_P001(3,34)

      CASE opc_02=2     // recibos (2¦via)
       ADM_RS18(3,34)

      CASE opc_02=3     // outros recibos (2¦via)
       ADM_R023(3,34)

      CASE opc_02=4     // endere‡os alterados
       ADM_R022(3,34)

      CASE opc_02=5     // emissao de guia
       cod_sos=1
       CON_RX01(3,34)

      CASE opc_02=6     // fechamento caixa
       ADM_R039(3,34)

      CASE opc_02=7     // ficha de acerto
       ADC_RX76(3,34)

     ENDC
     CLEA GETS
     CLOS ALL
    ENDD

   CASE opc_01=4     // tabelas
    opc_02=1
    v02=SAVESCREEN(0,0,MAXROW(),79)
    DO WHIL opc_02!=0
     cod_sos=4
     RESTSCREEN(0,0,MAXROW(),79,v02)
     menu02="Documento … Imprimir~1|"+;
            "Credenciados~2|"+;
            "Especialidades~3|"+;
            "Parƒmetro de Juros~4|"+;
            "Filiais~5|"+;
            "Grupos~6|"+;
            "Tabelas Secund rias~7|"+;
            "Caixas~8"
     msgt="TABELAS"
     ROLAPOP(1)
     opc_02=DBOX(menu02,1,38,E_MENU,NAO_APAGA,msgt,,,opc_02)
     ROLAPOP()
     DO CASE
      CASE opc_02=1     // documento … imprimir
       IMPPAR(3,46)

      CASE opc_02=2     // credenciados
       MEDICOS(3,46)

      CASE opc_02=3     // especialidades
       TESPEC(3,46)

      CASE opc_02=4     // parƒmetro de juros
       JUROS(3,46)

      CASE opc_02=5     // filiais
       TFILIAIS(3,46)

      CASE opc_02=6     // grupos
       ARQGRUP(3,46)

      CASE opc_02=7     // tabelas secund rias
       opc_03=1
       v03=SAVESCREEN(0,0,MAXROW(),79)
       DO WHIL opc_03!=0
        cod_sos=4
        RESTSCREEN(0,0,MAXROW(),79,v03)
        menu03="Regi”es~1|"+;
               "Cobradores/Vendedores~2|"+;
               "Categoria dos Planos~3|"+;
               "Circulares~4|"+;
               "Processos~5|"+;
               "Funcion rios~6|"+;
               "Hist¢rico Padr„o~7|"+;
               "Custos Adicionais~8|"+;
               "Mensagem p/Contrato~9"
        msgt="TABELAS SECUNDRIAS"
        opc_03=DBOX(menu03,3,46,E_MENU,NAO_APAGA,msgt,,,opc_03)
        DO CASE
         CASE opc_03=1     // regi”es
          REGIAO(5,54)

         CASE opc_03=2     // cobradores/vendedores
          COBRADOR(5,54)

         CASE opc_03=3     // categoria dos planos
          CLASSES(5,54)

         CASE opc_03=4     // circulares
          CIRCULAR(5,54)

         CASE opc_03=5     // processos
          PRCESSOS(5,54)

         CASE opc_03=6     // funcion rios
          FNCS(5,54)

         CASE opc_03=7     // hist¢rico padr„o
          HISTORIC(5,54)

         CASE opc_03=8     // custos adicionais
          CSTSEG(5,54)

         CASE opc_03=9     // mensagem p/contrato
          MENSAG(5,54)

        ENDC
        CLEA GETS
        CLOS ALL
       ENDD

      CASE opc_02=8     // caixas
       ORDPGRC(3,46)

     ENDC
     CLEA GETS
     CLOS ALL
    ENDD

   CASE opc_01=5     // apoio
    opc_02=1
    v02=SAVESCREEN(0,0,MAXROW(),79)
    DO WHIL opc_02!=0
     op_menu=PROJECOES
     cod_sos=9
     RESTSCREEN(0,0,MAXROW(),79,v02)
     menu02="Parƒmetros~1|"+;
            "Vˆ relat¢rio gravado~2|"+;
            "Reconstr¢i ¡ndices~3|"+;
            "Elimina reg apagados~4|"+;
            "Configura ambiente~5|"+;
            "Plano de senhas~6|"+;
            "Sobre...~7"
     msgt="APOIO"
     ROLAPOP(1)
     opc_02=DBOX(menu02,1,47,E_MENU,NAO_APAGA,msgt,,,opc_02)
     ROLAPOP()
     DO CASE
      CASE opc_02=1     // parƒmetros
       PAR_ADM(3,55)

      CASE opc_02=2     // vˆ relat¢rio gravado
       VE_REL()

      CASE opc_02=3     // reconstr¢i ¡ndices
       cod_sos=39
       RCLA()

      CASE opc_02=4     // elimina reg apagados
       cod_sos=40
       COMPACTA()

      CASE opc_02=5     // configura ambiente
       opc_03=1
       v03=SAVESCREEN(0,0,MAXROW(),79)
       DO WHIL opc_03!=0
        cod_sos=41
        RESTSCREEN(0,0,MAXROW(),79,v03)
        menu03="ÿ Diret¢rio de trabalho~1|"+;
               "ÿ Marca da impressoraÿÿ~2|"+;
               "ÿ Pano de fundoÿÿÿÿÿÿÿÿ~3|"+;
               "ÿ Fontes de caracteresÿ~4|"+;
               "ÿ Esquemas de coresÿÿÿÿ~5|"+;
               IF(drvconf,"û ","ÿ ")+"Confirma em camposÿÿÿ~6|"+;
               IF(drvexcl,"û ","ÿ ")+"Confirma exclus”esÿÿÿ~7|"+;
               IF(drvincl,"û ","ÿ ")+"Confirma inclus”esÿÿÿ~8|"+;
               IF(drvvisivel,"û ","ÿ ")+"Excluidos vis¡veisÿÿÿ~9|"+;
               IF(drvautohelp,"û ","ÿ ")+"Ajuda de campo ativaÿ~10|"+;
               IF(drvmouse,"û ","ÿ ")+"Liga/desliga mouseÿÿÿ~11|"+;
               "ÿ Sensibilidade mouseÿÿ~12"
        msgt="CONFIGURA AMBIENTE"
        opc_03=DBOX(menu03,3,55,E_MENU,NAO_APAGA,msgt,,,opc_03)
        DO CASE
         CASE opc_03=1     // diret¢rio de trabalho
          cod_sos=2
          PEGADIR(.f.)

          SAVE TO (arqconf) ALL LIKE drv*          // grava configuracoes,
          CBC1()                                   // monta tela principal e
          v01=SAVESCREEN(0,0,MAXROW(),79)          // salva para o break
          BREAK                                    // que foi configurado
         CASE opc_03=2     // marca da impressora
          CONFPRN()

         CASE opc_03=3     // pano de fundo
          cod_sos=43; msg=""                       // menu de caracteres para fundo
          FOR t=1 TO 255                           // enche msg com as opcoes
           IF t!=124                               // exceto o '|` que e o
            msg+="|"+STR(t,3)+" - "+CHR(t)         // caracter separador das
           ENDI                                    // opcoes da DBOX(
          NEXT
          t=ASC(drvcara)-IF(ASC(drvcara)>123,1,0)
          op_x=DBOX(SUBS(msg,2),,63,E_MENU,,"FUNDO",,,t)
          IF op_x!=0                               // escolhido um caracter
           op_x+=IF(op_x>123,1,0)                  // desconta o '|`
           IF drvcara!=CHR(op_x)                   // se caracter
            drvcara=CHR(op_x)                      // diferente do atual
            SAVE TO (arqconf) ALL LIKE drv*        // grava configuracoes,
            CBC1()                                 // monta tela principal e
            v01=SAVESCREEN(0,0,MAXROW(),79)        // salva para o break
            BREAK                                  // que foi configurado
           ENDI
          ENDI

         CASE opc_03=4     // fontes de caracteres
          op_x=1; cod_sos=53
          msgf=MUDAFONTE(999)
          DO WHILE op_x!=0 .AND.LEN(msgf)>0
           msgf=STRTRAN(msgf,CHR(251)," ")
           msgf=LEFT(msgf,13*drvfonte)+CHR(251)+SUBS(msgf,13*drvfonte+2)
           op_x=DBOX(msgf,05,63,E_MENU,,"FONTES",,,drvfonte+1)
           IF op_x>0
            drvfonte=op_x-1
            MUDAFONTE(drvfonte)
           ENDI
          ENDD

         CASE opc_03=5     // esquemas de cores
          CONFCORES()

         CASE opc_03=6     // confirma em campos
          drvconf=!drvconf
          SET(_SET_CONFIRM,drvconf)

         CASE opc_03=7     // confirma exclus”es
          drvexcl=!drvexcl

         CASE opc_03=8     // confirma inclus”es
          drvincl=!drvincl

         CASE opc_03=9     // excluidos vis¡veis
          drvvisivel=!drvvisivel
          SET(_SET_DELETED,!drvvisivel)

         CASE opc_03=10     // ajuda de campo ativa
          drvautohelp=!drvautohelp

         CASE opc_03=11     // liga/desliga mouse
          IF MOUSE()>0
           drvmouse=!drvmouse
          ENDI

          #ifdef COM_TUTOR
           IF acao_mac!="D"
            drvmouse=.f.
           ENDI
          #endi

         CASE opc_03=12     // sensibilidade mouse
          cod_sos=45
          AJMOUSE()

        ENDC
        CLEA GETS
        CLOS ALL
       ENDD
       SAVE TO (arqconf) ALL LIKE drv*             // diferente do atual

      CASE opc_02=6     // plano de senhas
       cod_sos=17
       MASENHA(1,55)
      CASE opc_02=7     // sobre...
       cod_sos=1
       ABOUT(3,55)

     ENDC
     CLEA GETS
     CLOS ALL
    ENDD

  ENDC
 END
 CLEA GETS
 CLOS ALL
ENDD

RETU

* \\ Final de ADR_MENU.PRG
GAS-Pro v3.0
011021014062001001024001012000176001
 Processo:
 Confirme:
[Ÿ]
[Ÿ]
 2 
 0 
Impress„o Aux.Funeral
Impress„o Aux.Funeral







056







 0 
 0 
-1 
-1 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
rproc
C
E
@R 99999/9999-99
 11 
 13 
 1 
 12 
 0 
Processo

!EMPT(RPROC).AND.PTAB(M->rproc,[AFUNER],1)
Campo utilizado para localiza‡„o dos documentos.|Tecle F8 para busca em tabela
IIF(PTAB(PADR(SUBSTR(M->ide_maq,2),4)+[AFU],[IMPPAR],1),ALLTRIM(IMPPAR->docto),[])
Digite neste campo o n£mero de|identifica‡„o do processo
VDBF(6,12,20,77,'AFUNER',{'processo','proc2','categ','contrato','falecido'},1,'V02001F9()',[])
 0 
 0 


confirme
C
E
!
 1 
 1 
 2 
 12 
 0 
Confirme

confirme='S'.AND.V02002F9()
CONFIRME n„o aceit vel|Digite S para confirmar|ou|Tecle ESC para cancelar

Digite S para confirmar|ou|tecle ESC para cancelar

 0 
 0 


 0 
 0 
 0 
 0 
 0 
FI ADR_ADAP
FI ADR_ATRI
FI ADR_ATR1
FI ADR_ATR2
FI ADR_ESTR

LIB D:\GASPRO40\GASPRO52/****
*  Funcao: GETSYS do Clipper (manipula o GET/READ)
*  OBS...: Este c¢digo foi modificado pela GAS INFORMTICA
*          para suportar as implementa‡”es feitas nos
*          programas gerados pelo GAS-Pro v2.0
*
*          IMPORTANTE!!!
*          Se for necess rio alterar este c¢digo, compilar
*          com as op‡”es   /m/n/l
*  -------------------------------------------------------
*/

#include "getexit.ch"
#include "inkey.ch"
#include "error.ch"
#include "set.ch"

#define K_UNDO          K_CTRL_U

// definicoes para a variavel sistema
#define O_CAMPO   12    // atributos dos campos do subsistema
#define   O_MASC   1    // mascara do campo
#define   O_TITU   2    // titulo do campo
#define   O_CMD    3    // comando especial (f8)
#define   O_DEFA   4    // default para o campo
#define   O_WHEN   5    // clausula when (pre validacao)
#define   O_CRIT   6    // expressao de validacao (critica)
#define   O_HELP   7    // texto de ajuda on-line do campo

// estado das vari veis para o READ ativo
STATIC format
STATIC updated := .f.
STATIC killread
STATIC bumptop
STATIC bumpbot
STATIC lastexit
STATIC lastpos
STATIC activeget
STATIC readprocname
STATIC readprocline

// formato do arranjo usado para preservar o estado das vari veis
#define GSV_KILLREAD            1
#define GSV_BUMPTOP             2
#define GSV_BUMPBOT             3
#define GSV_LASTEXIT            4
#define GSV_LASTPOS             5
#define GSV_ACTIVEGET           6
#define GSV_READVAR             7
#define GSV_READPROCNAME        8
#define GSV_READPROCLINE        9

#define GSV_COUNT               9

/***
*       READMODAL()
*       READ MODAL padr„o em um arranjo de GETS
*/
FUNC READMODAL(listget)

LOCAL get,t,tx,x,co
LOCAL pos, l_24
LOCAL savedgetsysvars
PRIV msg_24
drvmouse=IF(TYPE("drvmouse")!="L",.f.,drvmouse)
drvautohelp=IF(TYPE("drvautohelp")!="L",.f.,drvautohelp)
IF (ValType(Format)=="B")
 EVAL(Format)
ENDI
IF (EMPTY(listget))                   // compatibiliza com Summer 87
 SETPOS(MAXROW()-1, 0)
 RETURN (.F.)                         // NOTE
ENDI
savedgetsysvars:= cleargetsysvars()   // preserva status das vari veis
readprocname:= PROCNAME(1)            // estas ser„o usadas nas SET KEYs
readprocline:= PROCLINE(1)
IF drvmouse
 x="MOUSEBOX"
 &x.(0,0,MAXROW(),79)
 li:=co:= 1; msg_24=""
 l_24=SAVESCREEN(MAXROW(),0,MAXROW(),79)
 FOR t=1 TO 80
  msg_24+=SUBS(l_24,2*t-1,1)
 NEXT
ENDI
pos:= SETTLE(listget, 0)
IF TYPE("novapos")<>"L" .OR. ! novapos
 novapos=.F.
ELSE
 x="MOUSEGET"
 &x.(@li,@co); pos=-1
ENDI
tentardenovo=novapos
WHILE (pos<>0)
 IF pos>0
  get:= listget[pos]                  // pega prox GET da lista e o coloca
  POSTACTIVEGET(get)                  // no GET ativo
  IF (VALTYPE(get:reader)=="B")       // le o GET
   EVAL(get:reader, get)              // usa bloco de leitura do usu rio
  ELSE
   GETREADER(get)                     // usa o leitor padr„o
  ENDI
 ELSE
  Pos=0
 ENDI
 IF novapos                           // move para o pr¢x GET, baseado
  FOR t=1 TO LEN(listget)             // na condi‡„o de sa¡da
   x="MOUSEGET"
   &x.(@li,@co)
   IF listget[t]:row=Li
    IF co>=listget[t]:col .AND. ;
        co<=listget[t]:col+LEN(TRANSFORM(EVAL(listget[t]:BLOCK),listget[t]:picture))-1
     pos=t; tentardenovo=.f.
     JOGANOBUFF(" ")
     Q_TEC(0)
     FOR tx=1 TO pos-1
      IF listget[tx]:postblock!=NIL
       IF !EVAL(listget[tx]:postblock)
        pos=tx
        EXIT
       ENDI
      ENDI
     NEXT
     EXIT
    ENDI
   ENDI
  NEXT
 ELSE
  pos:= SETTLE(listget, pos)
 ENDI
 novapos=tentardenovo
END
RESTOREGETSYSVARS(savedgetsysvars)           // restaura o estado das vari veis
SETPOS(MAXROW()-1, 0)                        // compatibiliza Summer 87
IF drvmouse
 x="MOUSEGET"
 DO WHIL &x.(0,0)!=0
 ENDD
 IF brw .AND. TYPE("br_w")="O"
  x="MOUSEBOX"
  &x.(br_w:ntop-1,br_w:nleft-1,br_w:nbottom+1,br_w:nright+1)  // define janela do mouse
 ENDI
ENDI
RETURN (Updated)


/***
*       GETREADER()
*       READ Modal padr„o de um GET simples
*/
PROC GETREADER(get)
LOCAL press, pp, Tecl_p, ar_db:=ALIAS(), n_cp, qt_lin_hlp, lihlp, tela_hlp,;
      c_box, t_box, tmp_, vlr_defa:=.f., ncol,nrow
PRIV im_aj_at_:=0
IF TYPE("op_menu")!="N" .OR. op_menu=1 .OR.;// se op_menu nao existir ou
   op_menu=4 .OR. (TYPE("cex_com_vl")!="U" .AND. op_menu = 5)               // for inclusao ou tela
 get:setfocus()                             // complementar entao ativa o GET
 tmp_=READVAR()
 IF !EMPT(get:cargo) .AND. EMPT(&tmp_.)     // se o campo esta vazio e pode ter valor inicial
  tmp_=get:cargo
  IF VALTYPE(tmp_)="A" .AND. LEN(tmp_)>2    // se o valor definido no "cargo"
   IF !EMPT(tmp_[3]).AND.EMPT(get:original) // e' o valor inicial
    tmp_=EVAL(&("{||"+tmp_[3]+"}"))         // pega o default
    lihlp=LEN(get:buffer)
    IF get:picture=NIL .OR. AT("@K",get:picture)>0 .OR. AT("@S",get:picture)>0
     pp="@X"
    ELSE
     pp=get:picture
    ENDI
    get:buffer:=LEFT(TRAN(tmp_,pp)+SPAC(lihlp),lihlp)
    get:assign()
    updated:= .T.
    vlr_defa:=.t.
   ENDI
  ENDI
 ENDI
 get:killfocus()                            // desativa o GET
ENDI
IF (GETPREVALIDATE(get))                    // le o GET se condi‡„o WHEN satisfeita
 get:setfocus()                             // ativa o GET para leitura
 IF vlr_defa                                // se teve default, prepara para
  get:clear := .t.                          // apagar se tecla diferente de letra
 ENDI
 WHILE (get:exitstate==GE_NOEXIT)
  lihlp=0
  IF (get:typeout)
   get:exitstate:= GE_ENTER
  ENDI
  WHILE (get:exitstate==GE_NOEXIT)           // aplica toques at‚ a sa¡da
   IF im_aj_at_<2
    IF drvautohelp .AND. !EMPT(get:cargo)
     tmp_=get:cargo
     IF !EMPT(tmp_[1])
      qt_lin_hlp=CONTA("|",tmp_[1])+1
      IF get:row+qt_lin_hlp+3>MAXROW()
       IF get:row-qt_lin_hlp-3>=0
        lihlp=get:row-qt_lin_hlp-3
       ENDI
      ELSE
       lihlp=get:row+1
      ENDI
      IF lihlp>0
       tela_hlp=SAVESCREEN(0,0,MAXROW(),79)
       c_box=drvcorbox; t_box=drvtitbox
       drvcorbox=drvcorhlp; drvtitbox=drvtithlp
       DBOX(tmp_[1],lihlp,get:col+2,,.f.)
       drvcorbox=c_box; drvtitbox=t_box
      ENDI
     ENDI
    ENDI
    IF im_aj_at_=1
     DISPEND()                              // apresenta tela de uma vez so
    ENDI
   ENDI
   im_aj_at_=3
   IF drvmouse
    x="MOUSECUR"
    &x.(.t.)
    x="MOUSETECLA"
    tecl_p=&x.()
    novapos=.f.
    IF tecl_p=-100
     novapos=.t.
     tecl_p=K_UP
    ENDI
    GETAPPLYKEY(get,tecl_p)
   ELSE
    GETAPPLYKEY(get,Q_TEC(0))
   ENDI
   IF LASTKEY()=K_ALT_F1
    im_aj_at_=1; drvautohelp=!drvautohelp
   ELSEIF LASTKEY()=K_F8 .AND. !EMPT(get:cargo)
    tmp_=get:cargo
    IF !EMPTY(tmp_[2])
     nrow:= ROW()
     ncol:= COL()
     JOGANOBUFF(" "); Q_TEC(0)
     get:assign()
     AJUSTA_PICT(get)
     tmp_=EVAL(&("{||"+tmp_[2]+"}"))          // executa comando especial...
     IF !EMPT(tmp_)
      IF get:picture=NIL .OR. AT("@K",get:picture)>0 .OR. AT("@S",get:picture)>0
       pp="@X"
      ELSE
       pp=get:picture
      ENDI
      get:buffer:=PADR(TRAN(tmp_,pp),LEN(get:buffer))
      get:assign()
      get:display()
      updated:= .T.
      IF !SET(_SET_CONFIRM)
       get:exitstate:=GE_ENTER
      ENDI
     ENDI
     SETPOS(nrow, ncol)
    ENDI
   ENDI
   IF get:exitstate!=GE_NOEXIT .OR. im_aj_at_=1
    IF im_aj_at_=1
     DISPBEGIN()                              // monta tela na pagina de traz
    ENDI
    IF lihlp>0
     RESTSCR(0,0,MAXROW(),79,tela_hlp)
    ENDI
    IF im_aj_at_=1 .AND. op_menu!=3 .AND. op_menu!=4
     x="INFOSIS"
     &x.(.t.)
     get:display()
    ENDI
   ENDI
  END
  IF get:exitstate != GE_UP .AND.;            // se nao esta voltando campo
     get:exitstate != GE_ESCAPE               // e nao pressionou ESC
   AJUSTA_PICT(get)
   IF (!GETPOSTVALIDATE(get))                 // n„o permite sa¡da se condi‡„o
    im_aj_at_=0                               // VALID nao estiver satisfeita
    get:exitstate:= GE_NOEXIT
   ELSE
    IF !EMPT(get:cargo)                       // pode ter formulas?
     tmp_=get:cargo
     IF VALTYPE(tmp_)="A" .AND. LEN(tmp_)>3   // se existe a subscricao 4
      IF !EMPT(tmp_[4])                       // e ela nao esta vazia
       pp="IMP_FORM"
       FOR i_=1 TO LEN(tmp_[4])               // mostra todas as formulas
        &pp.(tmp_[4,i_])                      // requisitadas
       NEXT
      ENDI
     ENDI
    ENDI
   ENDI
  ENDI

 END
 get:killfocus()                              // desativa o GET
END
RETURN

/***
*       AJUSTA_PICT()
*       Ajust com "0" ou " " a direita do campo se mascara "999" ou "###"
*
*       OBS: o GET precisa estar com o foco.
*/
PROC AJUSTA_PICT(get)
LOCA tmp_
IF get:type=="C" .AND. get:picture!=NIL    // se o campo for do tipo caracter
 tmp_=STRTRAN(get:picture,"@K")            // tira @K se existir (valor inicial)
 IF UPPER(LEFT(tmp_,2))="@S" .AND. AT(" ",tmp_)>0
  tmp_ = SUBS(tmp_,AT(" ",tmp_)+1)
 ENDI
 IF REPL("9",LEN(get:buffer))==tmp_        // e a mascara tudo "9" entao
  get:buffer:=LPAD(get:buffer,"0")         // coloca "0" a esquerda
  get:assign()
  get:display()                            // mostra como ficou
 ELSEIF REPL("#",LEN(get:buffer))==tmp_    // se mascara tudo "#" entao
  get:buffer:=LPAD(get:buffer)             // coloca " " a esquerda
  get:assign()
  get:display()                            // mostra como ficou
 ENDI
ENDI
RETU

/***
*       GETAPPLYKEY()
*       Aplica um toque IN_KEY() a um GET
*
*       OBS: o GET precisa estar com o foco.
*/
PROC GETAPPLYKEY(get, key)
LOCAL ckey
LOCAL bkeyblock
        // check for SET KEY first
IF ((bKeyBlock:= SETKEY(key))<>NIL)          // primeiro verifica se h  SET KEY
 GETDOSETKEY(bkeyBlock, get)
 RETURN
ENDI
DO CASE
 CASE (key==K_UP)
  get:exitstate:= GE_UP
 CASE (key==K_SH_TAB)
  get:exitstate:= GE_UP
 CASE (key==K_DOWN)
  get:exitState:= GE_DOWN
 CASE (key==K_TAB)
  get:exitstate:= GE_DOWN
 CASE (key==K_ENTER)
  get:exitstate:= GE_ENTER
 CASE (key==K_ESC)
  IF (SET(_SET_ESCAPE))
   get:undo()
   get:exitstate:= GE_ESCAPE
  ENDI
 CASE (key==K_PGUP)
  get:exitstate:= GE_WRITE
 CASE (key==K_PGDN)
  get:exitstate:= GE_WRITE
 CASe (key==K_CTRL_HOME)
  get:exitstate:= GE_TOP
  #ifdef CTRL_END_SPECIAL
   CASE (key == K_CTRL_END)                  // ^W/^END ambos v„o ao £ltimo GET
    get:exitstate:= GE_BOTTOM
  #else
   CASE (key==K_CTRL_W)
    get:exitstate:= GE_WRITE                 // ^W/^END ambos terminam o READ (default)
  #endif
 CASE (key==K_INS)
  SET(_SET_INSERT, !SET(_SET_INSERT))
  SHOWSCOREBOARD()
 CASE (key==K_UNDO)
  get:undo()
 CASE (key==K_HOME)
  get:home()
 CASE (key==K_END)
  get:end()
 CASE (key==K_RIGHT)
  get:right()
 CASE (key==K_LEFT)
  get:left()
 CASE (key==K_CTRL_RIGHT)
  get:wordright()
 CASE (key==K_CTRL_LEFT)
  get:wordleft()
 CASE (key==K_BS)
  get:backspace()
 CASE (key==K_DEL)
  get:delete()
 CASE (key==K_CTRL_T)
  get:delwordright()
 CASE (key==K_CTRL_Y)
  get:delend()
 CASE (key==K_CTRL_BS)
  get:delwordleft()
 OTHERWISE
  IF (key>=32 .AND. key<=255)
   ckey:= CHR(key)
   IF (get:type=="N" .AND. (ckey=="." .OR. ckey==","))
    get:todecpos()
   ELSE
    IF (SET(_SET_INSERT))
     get:insert(ckey)
    ELSE
     get:overstrike(ckey)
    ENDI
    IF (get:typeout .AND. !SET(_SET_CONFIRM))
     IF (SET(_SET_BELL))
      ?? CHR(7)
     ENDI
     get:exitstate:= GE_ENTER
    ENDI
   ENDI
  ENDI
ENDC
RETURN


/***
*       GETPREVALIDATE()
*       Testa a condi‡„o de entrada (cl usula WHEN) para um GET
*/
FUNC GETPREVALIDATE(get)
LOCAL saveupdated
LOCAL when:= .T.
IF (get:preblock<>NIL)
 saveupdated:= updated
 when:= EVAL(get:preblock, get)
 IF when!=NIL .AND. VALTYPE(when)!="L"
  IF EMPTY(when)
   when=.t.
  ELSE
   when:=&when
   IF VALTYPE(when)!="L"
    IF when!=NIL .AND. !EMPT(when)
     get:setfocus()
     IF get:picture=NIL .OR. AT("@K",get:picture)>0 .OR. AT("@S",get:picture)>0
      pp="@X"
     ELSE
      pp=get:picture
     ENDI
     get:buffer:=PADR(TRAN(when,pp),LEN(get:buffer))
     get:assign()
     updated:= .T.
     IF !SET(_SET_CONFIRM) .AND. LASTKEY()!=K_UP
      JOGANOBUFF(CHR(K_ENTER))
     ENDI
     get:killfocus()
    ENDI
    when=.t.
   ENDI
  ENDI
 ENDI
 IF !when                                // Zera valor do campo se nao atendido
  get:setfocus()
  get:home()
  get:delend()
  get:assign()
  updated:= .T.
  get:killfocus()
 ENDI
 get:display()
 killread=.f.
 SHOWSCOREBOARD()
 updated:= saveupdated
ENDI
IF (killread)
 when:= .F.
 get:exitstate:= GE_ESCAPE               // provoca sa¡da READMODAL()
ELSEIF (!when)
 get:exitstate:= GE_WHEN                 // pula para pr¢ximo get
ELSE
 get:exitstate:= GE_NOEXIT               // prepara para edi‡„o
ENDI
RETURN (when)


/***
*       GETPOSTVALIDATE()
*       Testa condi‡„o de n sa¡da (cl usula VALID) para um GET
*
*       NOTA: datas inv lidas s„o rejeitadas com o buffer preservado
*/
FUNC GETPOSTVALIDATE(get)
LOCAL saveUpdated
LOCAL changed, valid:= .T.
IF (get:exitstate==GE_ESCAPE)
 RETURN (.T.)
ENDI
IF (get:baddate())
 get:home()
 DATEMSG()
 SHOWSCOREBOARD()
 RETURN (.F.)
ENDI
IF (get:changed)                         // se ocorreu edi‡„o, designa o
 get:assign()                            // novo valor para a vari vel
 updated:= .T.
ENDI
get:reset()                              // reforma o buffer de edi‡„o,
                                         // cursor na posi‡„o inicial e mostra
IF (get:postblock<>NIL)                  // checa condi‡„o, se especificada
 saveupdated:= updated
 SETPOS(get:row, get:col+LEN(get:buffer))// compatibiliza Summer 87
 valid:= EVAL(get:postblock, get)
 SETPOS(get:row, get:col)                // reseta posi‡„o de compatibilidade
 SHOWSCOREBOARD()
 get:updatebuffer()
 updated:= saveupdated
 IF (killread)
  get:exitstate:= GE_ESCAPE              // provoca sa¡da READMODAL()
  valid:= .t.
 ENDI
ENDI
RETURN (valid)


/***
*       GETDOSETKEY()
*       Processa SET KEY durante a edi‡„o
*/
PROC GETDOSETKEY(keyblock, get)
LOCAL saveupdated
IF (get:changed )                        // se ocorreu edi‡„o, designa variavel
 get:assign()
 updated:= .t.
ENDI
saveupdated:= updated
EVAL(keyblock, readprocname, readprocline, readvar())
SHOWSCOREBOARD()
get:updatebuffer()
updated:= saveupdated
killread=.F.                             // manuten‡„o EVANDRO
IF (killread)
 get:exitstate:= GE_ESCAPE               // provoca sa¡da READMODAL()
ENDI
RETURN


/**************************
*
*       servi‡os READ
*
*/


/***
*       SETTLE()
*
*       Retorna nova posi‡„o num arranjo de objetos GET, baseado em:
*
*               - posi‡„o atual
*               - ExitState do objeto GET na posi‡„o corrente
*
*       NOTA o retorno de um valor 0 indica t‚rmino do READ
*       NOTA exitState do antigo GET ‚ transferido para o novo GET
*/
STATIC FUNC SETTLE(listget, pos)
LOCAL exitState
IF (pos==0)
 exitstate:= GE_DOWN
ELSE
 exitstate:= listget[pos]:exitstate
ENDI
IF (exitState==GE_ESCAPE .OR. exitState==GE_WRITE)
 RETURN (0)
ENDI
IF (exitstate<>GE_WHEN)
 LastPos := pos                          // reseta estado da informa‡„o
 BumpTop := .f.
 BumpBot := .f.
ELSE
 exitstate:= lastexit                    // re-usa ultimo exitstate, nao
ENDI                                     // altera a informa‡„o


/***
        *       move
*/
DO CASE
 CASE (exitstate==GE_UP)
  pos --
 CASE ( exitstate==GE_DOWN)
  pos ++
 CASE ( exitstate==GE_TOP)
  pos := 1
  bumptop:= .T.
  exitstate:= GE_DOWN
 CASE (exitstate==GE_BOTTOM)
  pos:= LEN(listget)
  bumpbot:= .T.
  exitstate:= GE_UP
 CASE (exitState==GE_ENTER)
  pos ++
ENDC


/***
        *       bounce
*/
IF(pos==0)
 IF (!readexit() .AND. !bumpbot)
  bumptop:= .T.
  pos:= lastpos
  exitstate:= GE_DOWN
 ENDI
ELSEIF (pos==LEN(listget)+1)
 IF (!readexit() .AND. exitstate<>GE_ENTER .AND. !bumptop)
  bumpbot:= .T.
  pos:= lastpos
  exitstate:= GE_UP
 ELSE
  pos:= 0
 ENDI
ENDI

lastexit:= exitstate                     // estado de saida do registro
IF (pos<>0 )
 listget[pos]:exitstate:= exitstate
ENDI
RETURN (pos)



/***
*       POSTACTIVEGET()
*       Pos ativa o GET para  READVAR(), GETACTIVE()
*/
STATIC proc POSTACTIVEGET(get)
GETACTIVE(get)
READVAR(GETREADVAR(get))
SHOWSCOREBOARD()
RETURN


/***
*       CLEARGETSYSVARS()
*       Salva e limpa o estado READ das vari veis
*       Retorna arranjo dos valores salvos
*
*       NOTA: O status de 'updated' ‚ apagado por‚m n„o salvo (compat. Summer 87)
*/
STATIC func CLEARGETSYSVARS()
LOCAL saved[GSV_COUNT]
saved[GSV_KILLREAD]:= killread
killread:= .F.
saved[GSV_BUMPTOP]:= bumptop
bumptop:= .F.
saved[GSV_BUMPBOT]:= bumpbot
bumpbot:= .F.
saved[GSV_LASTEXIT]:= lastexit
lastexit:= 0
saved[GSV_LASTPOS]:= lastpos
lastpos:= 0
saved[GSV_ACTIVEGET]:= GETACTIVE(NIL)
saved[GSV_READVAR]:= READVAR("")
saved[GSV_READPROCNAME]:= readprocname
readprocname:= ""
saved[GSV_READPROCLINE]:= readprocline
readprocline:= 0
updated:= .F.
RETURN (saved)


/***
*   RESTOREGETSYSVARS()
*       Restaura o estado do READ das vari veis do arranjo de valores salvos
*
*       NOTA: status do 'updated' n„o ‚ restaurado (compat. Summer 87)
*/
STATIC proc RESTOREGETSYSVARS(saved)
killread:= saved[GSV_KILLREAD]
bumptop:= saved[GSV_BUMPTOP]
bumpbot:= saved[GSV_BUMPBOT]
lastexit:= saved[GSV_LASTEXIT]
lastpos:= saved[GSV_LASTPOS]
GETACTIVE(saved[GSV_ACTIVEGET])
READVAR(saved[GSV_READVAR])
READPROCNAME:= saved[GSV_READPROCNAME]
READPROCLINE:= saved[GSV_READPROCLINE]
RETURN


/***
*       GETREADVAR()
*       seta o valor READVAR() a partir de um GET
*/
STATIC func GETREADVAR(get)
LOCAL name:= UPPER(get:name)

//#ifdef SUBSCRIPT_IN_READVAR
LOCAL i

/*
        * Os codigos a seguir incluem subscri‡”es no nome retornado por
        * esta fun‡„o, se a vari vel GET for um elementro de arranjo
        *
        * Subscri‡”es s„o recuperadas da vari vel de instƒncia get:subscript
        *
        * NOTA: incompativel com Summer 87
*/

IF (get:subscript<>NIL)
 FOR i:= 1 TO LEN(get:subscript)
  name+= "["+LTRIM(STR(get:subscript[i]))+"]"
 NEXT
ENDI

//#endif

RETURN (name)


/**************************
*
*       servi‡os do sistema
*
*/



/***
*   __setformat()
*       servi‡o SET FORMAT
*/
FUNC __SetFormat(b)
format:= IF(VALTYPE(b)=="B",b,NIL)
RETURN (NIL)


/***
*       __killread()
*   servi‡o CLEAR GETS
*/
PROC __killread()
killread:= .T.
RETURN


/***
*       GETACTIVE()
*/
FUNC GETACTIVE(g)
LOCAL oldactive:= activeget
IF( PCOUNT()>0)
 activeget:= g
ENDI
RETURN (oldactive)


/***
*       UPDATED()
*/
FUNC UPDATED()
RETURN (updated)


/***
*       readexit()
*/
FUNC readexit(lnew)
RETURN (SET(_SET_EXIT, lnew))


/***
*       READINSERT()
*/
FUNC READINSERT(lnew)
RETURN (SET(_SET_INSERT, lnew))



/**********************************
*
*       servi‡os para compatibilidade
*
*/


// mostra coordenadas para o SCOREBOARD
#define SCORE_ROW              0
#define SCORE_COL              60


/***
*   SHOWSCOREBOARD()
*/
STATIC PROC showscoreboard()
LOCAL nrow, ncol
IF (SET(_SET_SCOREBOARD))
 nrow:= ROW()
 ncol:= COL()
 SETPOS(SCORE_ROW, SCORE_COL)
 DISPOUT(IF(SET(_SET_INSERT), "Ins", "   "))
 SETPOS(nrow, ncol)
ENDI
RETURN


/***
*       DATEMSG()
*/
STATIC proc DATEMSG()
LOCAL nrow, ncol
nrow:= ROW()
ncol:= COL()
ALERTA()
DBOX("Data incorreta!",21,,,,"ATEN€ŽO!")
SETPOS(nrow, ncol)
RETURN


/***
*   RANGECHECK()
*
*       NOTE: segundo parametro n„o utilizado para compatibilizar v5.00
*/
FUNC RANGECHECK(get, junk, lo, hi)
LOCAL cmsg, nrow, ncol
LOCAL xvalue
IF (!get:changed)
 RETURN (.T.)
ENDI
xvalue:= get:varget()
IF (xvalue>=lo .AND. xvalue<=hi)
 RETURN (.T.)                                                                    // NOTE
ENDI

IF (SET(_SET_SCOREBOARD))
 cmsg:= "Limites: "+LTRIM(TRANSFORM(lo, "")) + ;
                  "-"+LTRIM(TRANSFORM(hi, ""))
 IF (LEN(cmsg)>MAXCOL())
  cmsg:=SUBSTR(cmsg, 1, MAXCOL())
 ENDI
 nrow:= ROW()
 ncol:= COL()
 SETPOS(SCORE_ROW, MIN(60, MAXCOL()-LEN(cmsg)))
 DISPOUT(cmsg)
 SETPOS(nrow, ncol)
 WHILE (NEXTKEY()==0)
 END

 SETPOS(SCORE_ROW, MIN(60, MAXCOL()-LEN(cmsg)))
 DispOut(SPACE(LEN(cmsg)))
 SETPOS(nrow, ncol)
ENDI
RETURN (.F.)

/***
*
*  ReadKill()
*
*/
FUNCTION ReadKill( lKill )

  LOCAL lSavKill := KillRead
//
//   IF ( PCOUNT() > 0 )
//      KillRead := lKill
//   ENDIF

RETURN ( lSavKill )

FUNC STORECARGO(msg_,get_,oq_)
IF EMPT(get_:cargo)
 get_:cargo:=ARRAY(4)
 get_:cargo[4]={}
ENDI
IF !EMPTY(msg_)
 IF oq_=4
  AADD(get_:cargo[oq_],msg_)
 ELSE
  get_:cargo[oq_]=msg_
 ENDI
ENDI
RETU

FUNC STOREALL(cp_,get_)
STORECARGO(sistema[op_sis,O_CAMPO,cp_,O_HELP],get_,1)
STORECARGO(sistema[op_sis,O_CAMPO,cp_,O_CMD],get_,2)
STORECARGO(sistema[op_sis,O_CAMPO,cp_,O_DEFA],get_,3)
IF !EMPT(sistema[op_sis,O_CAMPO,cp_,O_WHEN])
 get_:preblock:=&("{||"+CHR(34)+sistema[op_sis,O_CAMPO,cp_,O_WHEN]+CHR(34)+"}")
ENDI
IF !EMPT(sistema[op_sis,O_CAMPO,cp_,O_CRIT])
 get_:postblock:=&("{||CRIT("+CHR(34)+sistema[op_sis,O_CAMPO,cp_,O_CRIT]+CHR(34)+")}")
ENDI
RETU

// Final de GETSYS.PRG

procedure adr_outr
/*
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
 \ Empresa.: PresServ Inform tica-Limeira (019)452.6623
 \ Programa: ADM_OUTR.PRG
 \ Data....: 23-07-95
 \ Sistema.: Administradora de Funer rias
 \ Funcao..: Define vari veis p£blicas
 \ Analista: Ademilson Pedro Bom
 \ Criacao.: GAS-Pro v2.0
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/

#include "adrbig.ch"    // inicializa constantes manifestas


#ifdef COM_CALE
 PROC CALE      // Rotina para exibir calend rio
 
 /*
    Simplificando a estrutura CASE   (thank you Rick Spence!)
    tbc e' um vetor bidimensional que contem as teclas a serem testadas
    e suas respectivas acoes (dentro de "code blocks")
 */
 LOCAL cale_tela:=SAVESCREEN(0,0,MAXROW(),79), cor_atual:=SETCOLOR(),;
       col_dia, dia_1, lisu_:=6, cosu_:=58, liin_:=20, coin_:=79,;
       i_, cl_, vr_cale, m_e_s, a_n_o, ult_dia,;
       tbc:={;
              {K_DOWN, {||datac:=datac-30}},;
              {K_UP,   {||datac:=datac+30}},;
              {K_RIGHT,{||datac:=datac+365}},;
              {K_LEFT, {||datac:=datac-365}};
            }
 SETCOLOR(drvtitmsg)
 vr_cale=NOVAPOSI(@lisu_,@cosu_,@liin_,@coin_)      // posicao atual do calendario
 CAIXA(mold,lisu_,cosu_,liin_,coin_)                // monta tela de apresentacao
 SETCOLOR(drvcorenf)                                // do calendario
 @ lisu_+2,cosu_+1 SAY "Do 2a 3a 4a 5a 6a Sa"
 SETCOLOR(drvtitmsg)
 @ lisu_+ 9,cosu_+1 SAY REPL("Ä",coin_-cosu_-1)
 @ lisu_+10,cosu_+2 SAY " Incrementa o MES"        // montra teclas disponiveis
 @ lisu_+11,cosu_+2 SAY " Decrementa o MES"
 @ lisu_+12,cosu_+2 SAY CHR(26)+" Incrementa o ANO"
 @ lisu_+13,cosu_+2 SAY CHR(27)+" Decrementa o ANO"
 SETCOLOR(drvcormsg)
 DO WHIL .t.
  @ lisu_+1,cosu_+1 SAY PADL(TRIM(NMES(datac))+" - "+STR(YEAR(datac)),20)
  dia_1=DOW(datac-DAY(datac)+1)          // dia da semana do 1o. dia do mes
  cl_=lisu_+3
  @ cl_,cosu_+1 CLEAR TO liin_-6,coin_-1 // limpa area dos dias
  col_dia=1+cosu_+3*(dia_1-1)            // coluna inicai do 1o. dia do mes
  m_e_s=MONTH(datac)                     // mes
  a_n_o=YEAR(datac)                      // ano
  IF INT(m_e_s/2) = m_e_s/2              // acha ultimo dia do mes
   ult_dia=IF(m_e_s<8,IF(m_e_s=2,IF(INT(a_n_o/4)=a_n_o/4,29,28),30),31)
  ELSE
   ult_dia=IF(m_e_s<8,31,30)
  ENDI
  FOR i_=1 TO ult_dia                    // imprime os dias
   IF DAY(DATE())=i_                     // se for heje
    SETCOLOR(drvcorenf)                  // enfatiza
   ENDI
   @ cl_,col_dia SAY PADL(STR(i_,2),2)   // imprime o dia na tela
   SETCOLOR(drvcormsg)                   // retorna a cor normal
   col_dia+=3                            // proxima coluna
   IF dia_1/7=INT(dia_1/7)               // fim da tela do calendario
    cl_++ ; col_dia=cosu_+1              // passa para proxima linha
   ENDI
   dia_1++                               // proximo dia
  NEXT
  x=SETCURSOR(0)                         // apaga cursor, x=cursor atual

  #ifdef COM_MOUSE
   k=MOUSETECLA(lisu_+10,cosu_+2,liin_-1,cosu_+2)
  #else
   k=INKEY(0)                            // aguarda pressionar tecla
  #endi

  SETCURSOR(x)                           // volta tamanho original do cursor
  nm=ASCAN(tbc,{|ve_a| k=ve_a[1]})       // procura tecla dentro do vetor tbc (e' o CASE)
  IF nm!=0                               // achou!
   EVAL(tbc[nm,2])                       // portanto, executa a acao...
  ELSE
   IF k=K_ALT_F8                         // muda calendario de posicao
    MUDA_PJ(@lisu_,@cosu_,@liin_,@coin_,cale_tela,.t.)
    sinal_=" "
    PUBL &vr_cale.:=STR(lisu_,2)+STR(cosu_,2)
    SAVE TO (arqconf) ALL LIKE drv*      // salva as coordenadas em disco
   ELSE                                  // tecla sem acao, portanto,
    EXIT                                 // fora...
   ENDI
  ENDI
 ENDD
 RESTSCREEN(0,0,MAXROW(),79,cale_tela)   // restaura tela e
 SETCOLOR(cor_atual)                     // o esquema de cor

 #ifdef COM_MOUSE
  IF drvmouse                            // se o mouse esta' ativo
   DO WHIL MOUSEGET(0,0)!=0              // espera que os botoes sejam
   ENDD                                  // liberados (nao pressionados)
  ENDI
 #endi

 RETU
#endi


#ifdef COM_MAQCALC
 PROC MAQCALC      // Apresenta "pop-calculadora"
 LOCAL tela_c:=SAVESCREEN(0,0,MAXROW(),79), cur_sor:=SETCURSOR(1),;
       getlist:={}, vr_calc, pg_up, pg_dn, tec_f3, tec_f4, tec_f9, tec_f8
 PRIV  sinal_:=" ", num_disp, fgpaste, cor_calc:=SETCOLOR(),;
       lisu_:=1, cosu_:=40, liin_:=9, coin_:=64, sinal_ant:=" "
 vr_calc=NOVAPOSI(@lisu_,@cosu_,@liin_,@coin_) // pega posicao atual da calculadora
 fgpaste=(!EMPT(READVAR()).AND.;   // ve se ha campo pendente (captura)
         LEFT(READVAR(),4)!="OPC_")
 SETKEY(K_F6,NIL)                  // evita recursividade
 pg_up =SETKEY(K_PGUP,NIL)         // desabilita PgUp,
 pg_dn =SETKEY(K_PGDN,NIL)         // PgDn,
 tec_f3=SETKEY(K_F3,NIL)           // F3,
 tec_f4=SETKEY(K_F4,NIL)           // F4,
 tec_f9=SETKEY(K_F9,NIL)           // F9 e move caixa ( ALT-F8 )
 tec_f8=SETKEY(K_ALT_F8,{||sinal_dig()})

 SETKEY(35 ,{||sinal_dig()})       // #   raiz quadrada
 SETKEY(36 ,{||sinal_dig()})       // $   inteiro/flutuante
 SETKEY(37 ,{||sinal_dig()})       // %   percentual
 SETKEY(42 ,{||sinal_dig()})       // *   multiplica
 SETKEY(43 ,{||sinal_dig()})       // +   soma
 SETKEY(45 ,{||sinal_dig()})       // -   subtrai
 SETKEY(47 ,{||sinal_dig()})       // /   divide
 SETKEY(61 ,{||sinal_dig()})       // =   total
 SETKEY(94 ,{||sinal_dig()})       // ^   exponencial
 SETKEY(99 ,{||sinal_dig()})       // c   limpa display
 SETKEY(67 ,{||sinal_dig()})       // C
 IF fgpaste
  SETKEY(82 ,{||sinal_dig()})      // R   captura resultado do display
  SETKEY(114,{||sinal_dig()})      // r
 ENDI
 SETCOLOR(drvcormsg)
 CAIXA(mold,lisu_,cosu_,liin_,coin_)
 @ lisu_+1,cosu_+2 SAY "ÉÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ»"
 @ lisu_+2,cosu_+2 SAY "³                   ³"
 @ lisu_+3,cosu_+2 SAY "³                   ³"
 @ lisu_+4,cosu_+2 SAY "ÈÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼"
 @ lisu_+5,cosu_+2 SAY " 7 8 9 C     +  -  * "
 @ lisu_+6,cosu_+2 SAY " 4 5 6 .  =  /  %  ^ "
 @ lisu_+7,cosu_+2 SAY " 1 2 3 0     "+CHR(K_ESC)+"  #  $ "
 SETCOLOR(drvcorget)
 @ lisu_+8,cosu_+2 SAY IF(fgpaste,"R, resultado no campo","")
 SETCOLOR(drvcorget+","+drvcorget+",,,"+drvcorget)
 DO WHIL .t.
  gab=IF(fgint,"   999999999999999",;     // mascara
               "999999999999999.99")
  num_disp=0.00                           // numero no display
  @ lisu_+2,cosu_+3 SAY "="
  @ lisu_+2,cosu_+4 GET nu_calc PICT gab  // mostra total
  CLEAR GETS
  @ lisu_+3,cosu_+3 SAY sinal_ant
  @ lisu_+3,cosu_+4 GET num_disp PICT gab // capta operando
  READ
  DO CASE
   CASE LASTKEY()=K_ESC.OR.sinal_="R"     // finalizou
    IF fgpaste.AND.sinal_="R"
     KEYB ALLTRIM(TRAN(nu_calc,gab))      // joga resultado no campo
    ENDI
    EXIT                                  // e sai
   CASE sinal_="AF8"                      // muda calculadora de posicao
    MUDA_PJ(@lisu_,@cosu_,@liin_,@coin_,tela_c,.t.)
    sinal_=" "
    PUBL &vr_calc.:=STR(lisu_,2)+STR(cosu_,2)
    SAVE TO (arqconf) ALL LIKE drv*       // salva as coordenadas em disco
   CASE sinal_="$"                        // chaveou inteiro/decimal
    fgint=(!fgint); sinal_=" "
   CASE sinal_="C"                        // limpa display
    nu_calc=0; sinal_=" "
   CASE sinal_="#"                        // raiz quadrada
    IF !EMPTY(num_disp)                   // algum numero no display?
     IF sinal_ant="-"                     // op anterior=subtracao?
      nu_calc-=SQRT(num_disp)             // subtrai a raiz
     ELSE                                 // do display no resultado
      nu_calc+=SQRT(num_disp)             // senao, soma
     ENDI
    ELSE                                  // nao exite numero no
     nu_calc=SQRT(nu_calc)                // display, porisso
    ENDI                                  // calcula raiz do total
    sinal_=" "
   OTHERWISE
    DO CASE
     CASE sinal_ant="-"                   // subtrai
      nu_calc-=num_disp
     CASE sinal_ant="*"                   // multiplica
      nu_calc=nu_calc*num_disp
     CASE sinal_ant="/"                   // divide
      nu_calc=nu_calc/num_disp
     CASE sinal_ant="^"                   // eleva potencia
      nu_calc=nu_calc^num_disp
     CASE sinal_ant="%"                   // obtem percentual
      nu_calc=nu_calc/100*num_disp
     OTHERWISE                            // soma (+) ou sem operador
      nu_calc+=num_disp
   ENDC
  ENDC
  sinal_=IF(sinal_="="," ",sinal_)        // igual nao pode ser exibido
  sinal_ant=sinal_; sinal_=" "            // salva sinal digitado
 ENDD
 SETCOLOR(cor_calc)                       // volta com as cores anteriores
 SETCURSOR(cur_sor)                       // volta cursor com era antes
 SET KEY K_F6 TO maqcalc                  // reabilita calculadora (f6)
 SETKEY(35,NIL); SETKEY(36,NIL)           // desabilita as teclas
 SETKEY(37,NIL); SETKEY(42,NIL)           // utilizadas na operacao
 SETKEY(43,NIL); SETKEY(45,NIL)           // da calculadora
 SETKEY(47,NIL); SETKEY(67,NIL)
 SETKEY(94,NIL); SETKEY(99,NIL)
 SETKEY(82,NIL); SETKEY(114,NIL)
 SETKEY(61,NIL)
 SETKEY(K_PGUP,pg_up)                     // habilita teclas PgUp,
 SETKEY(K_PGDN,pg_dn)                     // PgDn,
 SETKEY(K_F3,tec_f3)                      // F3,
 SETKEY(K_F4,tec_f4)                      // F4,
 SETKEY(K_F9,tec_f9)                      // F9 e
 SETKEY(K_ALT_F8,tec_f8)                  // ALT-F8
 RESTSCREEN(0,0,MAXROW(),79,tela_c)       // restaura a tela
 RETU

 STATIC PROC SINAL_DIG  // Recebe sinal da calculadora
 sinal_=IF(LASTKEY()=K_ALT_F8,"AF8",;     // recebe sinal digitado e
        UPPER(CHR(LASTKEY())))            // forca saida do get com
 KEYB CHR(K_ENTER)                        // ENTER simulado
 RETU
#endi


* \\ Final de ADM_OUTR.PRG
FUNC veinscrits(Vinscr)
vinscr:=[Inscritos n„o cadastrados]
vcod:=LEFT(codigo,10)
if PTAB(LEFT(codigo,10),'INSCRITS',1)
 reg_dbfx:=POINTER_DBF()
 SELE INSCRITS
 Vinscr:=[]
 DO WHILE !EOF() .AND. INSCRITS->codigo=vcod
  Vinscr+=INSCRITS->nome+[ (]+;
        SUBSTR([TitPaiMaeSgoSgaEspFilDep],(VAL(grau)-1)*3+1,3)+[) tc ]+;
        dtoc(tcarencia)+[ ]+vivofalec+[ ]+tipo+[|]
  SKIP
 ENDDO
 POINTER_DBF(reg_dbfx)
endi

retu  DBOX(Vinscr,,,E_MENU,,[INSCRITOS DO CONTRATO])
// op_cad=DBOX(Vinscr,,,E_MENU,,[INSCRITOS DO CONTRATO],,,op_cad)
/*
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
 \ Empresa.: PresServ Inform tica-Limeira (019)452.6623.
 \ Programa: V00101F9.PRG
 \ Data....: 03-10-95
 \ Sistema.: Controle de Convˆnios
 \ Funcao..: Valida‡„o da variavel GNUMERO, relatorio CON_R001
 \ Analista: Ademilson Pedro Bom
 \ Criacao.: Programado manualmente pelo analista
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/

func v00101f9
//PARAMETROS('pnumero',gnumero)

  IF !PTAB(PADR(SUBSTR(M->ide_maq,2),4)+[GUI],[IMPPAR],1)
   ord_=LEN(sistema[EVAL(qualsis,"IMPPAR"),O_CHAVE])
   FAZ_LANC("IMPPAR",[ ])
   REPL IMPPAR->idmaq WITH PADR(SUBSTR(M->ide_maq,2),4),;
	IMPPAR->base WITH [GUI]
  ENDI
   #ifdef COM_REDE
    IMPPAR->(DBUNLOCK())                           // libera o registro
   #endi

   IF PTAB(PADR(SUBSTR(M->ide_maq,2),4)+[GUI],[IMPPAR],1)
    REPBLO('IMPPAR->docto',{||gnumero})
   ENDI

RETU .T.      // <- deve retornar um valor L¢GICO

* \\ Final de V00101F9.PRG


func V_carencia
para v_intervalo,dias_carencia
/*
Funcao criada para verificar a carencia dos contratos MA e MB.
 entra em carencia de [dias_carencia] depois de paga parcela com
[v_intervalo] de dias em atraso.
-limpar detalhes e deixar so 25 dias de pagas;
-o contrato q aparecer com mais de 70 dias em aberto, direito suspenso;
-taxas mais de 70 dias de vencidas e paga a menos de 25 dia (carencia);
*/
LOCAL dt_tx:=ctod(''),donex:=[] //,reg_dbf:=POINTER_DBF()
rec_dbf:=RECNO()                // inicializa vetor de retorno
i_=SELECT()                     // salva area atual
Mcod=GRUPOS->codigo
vai_entrar:=esta_em:=.F.
dt_fimcar:=dt_ultpg:=ctod([])
IF EMPTY(SELECT([TAXAS]))                      // o arquivo nao esta' em uso, vamos abri-lo...
 PTAB(Mcod,[TAXAS],1,.T.)
 SELE TAXAS
ELSE
 SELE TAXAS
 SEEK M->mcod       // Verifica todas as taxas do contrato
ENDI
SELE TAXAS
DO WHILE !EOF() .AND. TAXAS->codigo+TAXAS->tipo+TAXAS->circ=M->Mcod //.AND.ct_tx < M->rpend
 IF TAXAS->valorpg>0    // Das pagas, compara vencto e pgto.
  IF (pgto_ - emissao_) >= v_intervalo     // se atrasou nn dias,
	 dt_ultpg:=TAXAS->pgto_                  // guarda data pgto.
   dt_fimcar:=TAXAS->pgto_ + dias_carencia // calcula fim carencia
   IF DATE() < dt_fimcar                   // compara com data atual
    esta_em:=.T.                           // se carencia maior q data = carencia
   ENDI
  ELSE  // se nao atrasou (ou intervalo for menor q carencia)
   IF (pgto_ >= dt_fimcar)     // Se pagou depois do fim de carencia, tira-o
    esta_em:=.F.
   ENDI
  ENDI
 ELSE    // Se ainda num foi paga
  IF (date() - emissao_) >= v_intervalo // e ja venceu alem do intervalo...
   vai_entrar:=.T.                     // entra em suspenso...
  ENDI
 ENDI
 SKIP
ENDDO
IF DATE() > dt_fimcar   // mas, se ja passou a data final de carencia...
 esta_em:=.F.           // sai da carencia (ja cumpriu...)
ENDI
//POINTER_DBF(reg_dbf)
sele (i_)
go (rec_dbf)
IF (esta_em)
 RETU 2      // Pagou e esta na Carencia,
ELSEIF (vai_entrar)
 RETU 1      // num pagou, esta suspenso...
ENDI
RETU 0 //(esta_em.OR.vai_entrar)       // <- deve retornar um valor L¢GICO


//020760835
//Cancelamento e reintegra‡ao, verificar os campos transferidos (COROAS)

Function XCRIPTOGRAFA(Pstr, Psenha, Pencript)
LOCAL Tcript, Tx, Tascii
LOCAL Tlensenha
Tlensenha = Len(AllTrim(Psenha))
      Tcript = ""
      For Tx = 1 To Len(Pstr)
          If Pencript           //&& Criptografa
             Tascii = Asc(Subs(Pstr, Tx, 1)) + ;
                       Asc(Subs(Psenha, ((Tx + 77) % Tlensenha) + 1, 1))
          Else                          && DesCriptografa
             Tascii = Asc(Subs(Pstr, Tx, 1)) - ;
                       Asc(Subs(Psenha, ((Tx + 77) % Tlensenha) + 1, 1))
          EndIf
          Tcript = Tcript + Chr(Tascii)
      Next
Return(Tcript)


function xencript(caracteres)
return xCRIPTOGRAFA(caracteres, 'bompastor', .t.)

function xdecript(caracteres)
return xCRIPTOGRAFA(caracteres, 'bompastor', .f.)

/*
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
 \ Empresa.: PresServ Inform tica - Limeira (019)452.6623
 \ Programa: ADM_RS18.PRG
 \ Data....: 04-11-03
 \ Sistema.: Administradora - RECEP€„O
 \ Funcao..: Recibos (2¦via)
 \ Analista: Ademilson Pedro Bom
 \ Criacao.: GAS-Pro v4.0n
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/

#include "adrbig.ch"    // inicializa constantes manifestas

PRIV dele_atu, cur_atual, getlist:={}, so_um_reg, sit_dbf
PARA lin_menu, col_menu, imp_reg
PRIV  tem_borda:=.t., op_menu:=VAR_COMPL, l_s:=10, c_s:=20, l_i:=14, c_i:=61, tela_fundo:=SAVESCREEN(0,0,MAXROW(),79)
nucop=1
so_um_reg=(PCOUNT()>2)
IF !so_um_reg                             // vai receber a variaveis?
 IF nivelop < 2                                    // se usuario nao tem
  DBOX("Emiss„o negada, "+usuario,20)              // permissao, avisa
  RETU                                             // e retorna
 ENDI
 SETCOLOR(drvtittel)
 vr_memo=NOVAPOSI(@l_s,@c_s,@l_i,@c_i)    // pega posicao atual da tela
 CAIXA(mold,l_s,c_s,l_i,c_i)              // monta caixa da tela
 @ l_s,c_s+10 SAY " RECIBO SEM FALECIDOS "
 SETCOLOR(drvcortel)
 @ l_s+01,c_s+1 SAY " Numero..:   -"
 @ l_s+03,c_s+1 SAY " Confirme:"
ENDI
PRIV rnumero:=SPAC(8)                              // Numero
PRIV confirme:=SPAC(1)                             // Confirme
DO WHILE .t.
 rola_t=.f.
 cod_sos=56
 IF !so_um_reg
  SET KEY K_ALT_F8 TO ROLATELA
  SETCOLOR(drvcortel+","+drvcorget+",,,"+corcampo)
  @ l_s+01 ,c_s+15 GET  rnumero;
                   PICT "99999999";
                   VALI CRIT("!EMPT(rnumero)~Necess rio informar NUMERO")
                   DEFAULT "IF(PTAB(PADR(SUBSTR(M->ide_maq,2),4)+[BXR],[IMPPAR],1),IMPPAR->docto,[])"
                   AJUDA "Informe o n£mero do recibo"
		   CMDF8 "VDBF(6,3,20,77,'BXREC',{'numero','codigo','cobranca','valorpg','emitido_','por'},1,'numero',[])"

  @ l_s+03 ,c_s+12 GET  confirme;
                   PICT "!";
                   VALI CRIT("confirme='S'.AND.V01801F9()~CONFIRME n„o aceit vel|Digite S para confirmar|ou|Tecle ESC para cancelar")
                   AJUDA "Digite S para confirmar|ou|tecle ESC para cancelar"

  READ
  SET KEY K_ALT_F8 TO
  IF rola_t
   ROLATELA(.f.)
   LOOP
  ENDI
  IF LASTKEY()=K_ESC                               // se quer cancelar
   RETU                                            // retorna
  ENDI
 ENDI

 #ifdef COM_REDE
  IF !USEARQ("BXREC",.f.,10,1)                     // se falhou a abertura do arq
   RETU                                            // volta ao menu anterior
  ENDI
 #else
  USEARQ("BXREC")                                  // abre o dbf e seus indices
 #endi

 PTAB(codigo,"GRUPOS",1,.t.)                       // abre arquivo p/ o relacionamento
 PTAB(cobranca,"TAXAS",1,.t.)
 PTAB(GRUPOS->grupo,"ARQGRUP",1,.t.)
 PTAB(TAXAS->cobrador,"COBRADOR",1,.t.)
 PTAB(GRUPOS->regiao,"REGIAO",1,.t.)
 PTAB(GRUPOS->tipcont,"CLASSES",1,.t.)
 SET RELA TO codigo INTO GRUPOS,;                  // relacionamento dos arquivos
	  TO cobranca INTO TAXAS,;
          TO GRUPOS->grupo INTO ARQGRUP,;
          TO TAXAS->cobrador INTO COBRADOR,;
          TO GRUPOS->regiao INTO REGIAO,;
          TO GRUPOS->tipcont INTO CLASSES
 titrel:=criterio := ""                            // inicializa variaveis
 cpord=""
 chv_rela:=chv_1:=chv_2 := ""
 tps:=op_x:=ccop := 1
 arq_=drvporta                                     // porta de saida configurada
 IF !so_um_reg
  fil_ini=""
  IF !opcoes_rel(lin_menu,col_menu,10,11,fil_ini)  // nao quis configurar...
   CLOS ALL                                        // fecha arquivos e
   LOOP                                            // volta ao menu
  ENDI

 #ifdef COM_REDE

  ELSE

   tps=lin_menu

 #endi

 ENDI
 IF tps=2                                          // se vai para arquivo/video
  arq_=ARQGER()                                    // entao pega nome do arquivo
  IF EMPTY(arq_)                                   // se cancelou ou nao informou
   LOOP                                            // retorna
  ENDI
 ELSE
  arq_=drvporta                                    // porta de saida configurada
 ENDI
 IF "4WIN"$UPPER(drvmarca) // nome da configuracao/marca impressora
    arq_:=drvdbf+"WIN"+ide_maq
    tps:=3                                          // se vai para arquivo/video
 ENDIF
 SET PRINTER TO (arq_)                             // redireciona saida
 EXIT
ENDD
cur_atual=SETCURSOR(0)
IF !EMPTY(drvtapg)                                 // existe configuracao de tam pag?
 op_=AT("NNN",drvtapg)                             // se o codigo que altera
 IF op_=0                                          // o tamanho da pagina
  msg="Configura‡„o do tamanho da p gina!"         // foi informado errado
  DBOX(msg,,,,,"ERRO!")                            // avisa
  CLOSE ALL                                        // fecha todos arquivos abertos
  RETU                                             // e cai fora...
 ENDI                                              // codigo para setar/resetar tam pag
 lpp_033=LEFT(drvtapg,op_-1)+"033"+SUBS(drvtapg,op_+3)
 lpp_066=LEFT(drvtapg,op_-1)+"066"+SUBS(drvtapg,op_+3)
ELSE
 lpp_033:=lpp_066 :=""                             // nao ira mudara o tamanho da pag
ENDI
dele_atu:=SET(_SET_DELETED,.t.)                    // os excluidos nao servem...
POE_GAUGE("[ESC] Interrompe","AGUARDE...","Emitidos:")
SET DEVI TO PRIN                                   // inicia a impressao
maxli=32                                           // maximo de linhas no relatorio
IMPCTL(lpp_033)                                    // seta pagina com 33 linhas
SET MARG TO 1                                      // ajusta a margem esquerda
IF tps=2
 IMPCTL("' '+CHR(8)")
ENDI
BEGIN SEQUENCE
 DO WHIL ccop<=nucop                               // imprime qde copias pedida
  pg_=1; cl=50000
  IF so_um_reg
   GO imp_reg
  ELSE
   INI_ARQ()                                       // acha 1o. reg valido do arquivo
   IF PTAB(PADR(SUBSTR(M->ide_maq,2),4)+[BXR],[IMPPAR],1)
    PTAB(LEFT(IMPPAR->docto,8),'BXREC',1)
   ENDI
  ENDI
  IF EOF()
   EXIT
  ENDI
  ccop++                                           // incrementa contador de copias
  DO WHIL !EOF().AND.(!so_um_reg.OR.imp_reg=RECN()).AND.POE_GAUGE()
   IF IN_KEY()=K_ESC                               // se quer cancelar
    IF canc()                                      // pede confirmacao
     BREAK                                         // confirmou...
    ENDI
   ENDI
   IF (PTAB(PADR(SUBSTR(M->ide_maq,2),4)+[BXR],[IMPPAR],1).AND.numero=LEFT(IMPPAR->docto,8)) .OR. so_um_reg// se atender a condicao...
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY TRAN(numero,"@R 99-999999")       // N§ Recibo
    IMPAC("Cobran‡a:",cl,014)
    IMPCTL(drvpenf)
    @ cl,026 SAY TRAN(cobranca,[@R 999.999999-9-99999])   // Ref.:
    IMPCTL(drvtenf)
    @ cl,046 SAY "Vencimento:"
    @ cl,058 SAY TRAN(TAXAS->emissao_,"@D")               // data 1
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,012 SAY TRAN(CLASSES->descricao,"@!")     // Descri‡„o 1
    @ cl,050 SAY "Valor.:"
    IMPCTL(drvpenf)
    @ cl,058 SAY TRAN(valorpg,"@E 999,999.99")     // Valor
    IMPCTL(drvtenf)
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY "Contrato..:"
    IMPCTL(drvpenf)
    @ cl,012 SAY GRUPOS->grupo +[  ]+TRAN(codigo,[@R 999.999999])        // Grupo 1
    IMPCTL(drvtenf)
    @ cl,050 SAY "Data..:"
    @ cl,058 SAY TRAN(emitido_,"@D")               // data 1
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY "Nome......:"
    IMPCTL(drvpenf)
    @ cl,012 SAY GRUPOS->nome                      // Nome
    IMPCTL(drvtenf)
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    IMPAC("Endere‡o..:",cl,000)
    @ cl,012 SAY GRUPOS->endereco                  // Endere‡o
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY "Bairro....:"
    @ cl,012 SAY GRUPOS->bairro                    // Bairro
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY "Cid./Cobr.:"
    @ cl,012 SAY GRUPOS->cidade+[ ] +GRUPOS->cobrador// Cidade
    @ cl,052 SAY REPL("Ä",19)
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,052 SAY "Op:"
    @ cl,056 SAY LEFT(por,1)+LOWER(SUBSTR(por,2))  // operador
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY "Valor:"
    @ cl,007 SAY chr(15)+'('+SUBSTR(EXT(valorpg),1,AT('/',EXT(valorpg))-1)+')'+chr(18)// Valor Ext
    REL_CAB(2)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY REPL("Ä",71)
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    IMPEXP(cl,000,LEFT(M->setup1,35),70)           // 2 Ident1
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY M->setup2                         // 2 Ident 2
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY REPL("-",71)
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY TRAN(numero,"@R 99-999999")       // N§ Recibo
    IMPAC("Cobran‡a:",cl,014)
    IMPCTL(drvpenf)
    @ cl,025 SAY cobranca                          // Ref.:
    IMPCTL(drvtenf)
    @ cl,046 SAY "Vencimento:"
    @ cl,058 SAY TRAN(TAXAS->emissao_,"@D")               // data 1
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,012 SAY TRAN(CLASSES->descricao,"@!")     // Descri‡„o 2
    @ cl,050 SAY "Valor.:"
    IMPCTL(drvpenf)
    @ cl,058 SAY TRAN(valorpg,"@E 999,999.99")     // Valor pago
    IMPCTL(drvtenf)
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY "Contrato..:"
    IMPCTL(drvpenf)
    @ cl,012 SAY GRUPOS->grupo +[  ]+TRAN(codigo,[@R 999.999999])  // Grupo
    IMPCTL(drvtenf)
    @ cl,050 SAY "Data..:"
    @ cl,058 SAY TRAN(emitido_,"@D")               // Emitido em
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY "Nome......:"
    IMPCTL(drvpenf)
    @ cl,012 SAY GRUPOS->nome                      // Nome
    IMPCTL(drvtenf)
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    IMPAC("Endere‡o..:",cl,000)
    @ cl,012 SAY GRUPOS->endereco                  // Endere‡o
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY "Bairro....:"
    @ cl,012 SAY GRUPOS->bairro                    // Bairro
    @ cl,052 SAY REPL("Ä",19)
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY "Cid./Cobr.:"
    @ cl,012 SAY GRUPOS->cidade+[ ] +GRUPOS->cobrador// Cidade
    @ cl,052 SAY "Op:"
    @ cl,056 SAY LEFT(por,1)+LOWER(SUBSTR(por,2))  // Operador
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY "Valor:"
    @ cl,007 SAY chr(15)+'('+SUBSTR(EXT(valorpg),1,AT('/',EXT(valorpg))-1)+')'+chr(18)// Valor Ext
    REL_CAB(2)                                     // soma cl/imprime cabecalho
//    @ cl,000 say [>]+cobranca+[<]
    @ cl,000 SAY ""
    CODBARRAS({{left(cobranca,13)+[0],4,25,9},{ALLTRIM(str(valorpg,10,2)),3,20,47}},10,6)
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY ""
    CODBARRAS({{left(cobranca,13)+[0],4,25,9},{ALLTRIM(str(valorpg,10,2)),3,20,47}},10,6)

    REL_CAB(1)                                     // soma cl/imprime cabecalho
//    @ cl,000 SAY ""
//    CODBARRAS({{strzero(valorpg,10,2),3,20,39}},10,6)
    SKIP                                           // pega proximo registro
    cl=50000                                       // forca salto de pagina
   ELSE                                            // se nao atende condicao
    SKIP                                           // pega proximo registro
   ENDI
  ENDD
 ENDD ccop
 EJEC                                              // salta pagina
END SEQUENCE
SETCURSOR(cur_atual)
SET MARG TO                                        // coloca margem esquerda = 0
IMPCTL(lpp_066)                                    // seta pagina com 66 linhas
SET PRINTER TO (drvporta)                          // fecha arquivo gerado (se houver)
SET DEVI TO SCRE                                   // direciona saida p/ video
IF tps=2                                           // se vai para arquivo/video
 BROWSE_REL(arq_,2,3,MAXROW()-2,78)
ENDI          // mostra o arquivo gravado
GRELA(10)                                          // grava variacao do relatorio
SELE BXREC                                         // seleciona arquivo
SET RELA TO                                        // retira os relacionamentos
SET(_SET_DELETED,dele_atu)                         // os excluidos serao vistos
IF so_um_reg
 POINTER_DBF(sit_dbf)
ENDI
RETU

STATIC PROC REL_CAB(qt)                            // cabecalho do relatorio
IF qt>0                                            // se parametro maior que 0
 cl=cl+qt                                          // soma no contador de linhas
ENDI
IF cl>maxli .OR. qt=0                              // quebra de pagina
 IMPEXP(0,000,LEFT(M->setup1,35),70)               // Ident1
 @ 1,000 SAY M->setup2                             // Ident2
 @ 2,000 SAY REPL("-",71)
 cl=qt+2 ; pg_++
ENDI
RETU

* \\ Final de ADM_RS18.PRG
procedure v03001f9
/*
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
 \ Empresa.: PresServ Inform tica-Limeira (019)452.6623
 \ Programa: V03001F9.PRG
 \ Data....: 15-07-96
 \ Sistema.: Administradora de Funer rias
 \ Funcao..: Valida‡„o da variavel CONFIRME, relatorio ADM_R030
 \ Analista: Ademilson Pedro Bom
 \ Criacao.: Programado manualmente pelo analistad
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/

#include "adrbig.ch"    // inicializa constantes manifestas

#ifdef COM_REDE
 REPBLO('ARQGRUP->proxcirc',rproxcirc)
#else
 REPL ARQGRUP->proxcirc WITH rproxcirc
#endif
RETU .t.      // <- deve retornar um valor L¢GICO

* \\ Final de V03001F9.PRG
procedure r02001f9
/*
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
 \ Empresa.: PresServ Inform tica-Limeira (019)452.6623
 \ Programa: R02001F9.PRG
 \ Data....: 23-07-96
 \ Sistema.: Administradora de Funer rias
 \ Funcao..: recibo do relat¢rio ADM_R020
 \ Analista: Ademilson Pedro Bom
 \ Criacao.: Programado manualmente pelo analistad
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/

#include "adrbig.ch"    // inicializa constantes manifestas
 li_aux:=space(1024)
 li_aux:=[     O Contratante acima qualificado (ou seu representante legal) ]
 li_aux+=[vem mui respeitosamente … presen‡a desta empresa ]
 li_aux+=ALLTRIM(M->setup1)+[, ]
 IF !EMPT(M->cgcsetup)
  li_aux+=[inscrita no CGC sob n§ ]+TRAN(M->cgcsetup,"@R 99.999.999/9999-99")+[, ]
 ENDI
 li_aux+=[requerer que ]
 li_aux+=[se digne autorizar o pagamento da cota denominada RESTITUI€ŽO ]
 li_aux+=[DE DESPESAS FUNERAIS, (conforme cl usulas contratuais) ]
 li_aux+=[referente as respectivas notas fiscais e/ou recibos que est„o ]
 li_aux+=[anexados a este processo administrativo e que totalizam o valor ]
 li_aux+=[de ]+&drvpenf+[R$]+ALLTRIM(TRAN(vlauxilio,[@E 999,999.99]))+;
  [ (]+LEFT(EXT(vlauxilio),AT([/],EXT(vlauxilio))-1)+[)]+&drvtenf
 li_aux+=[ por ocasi„o do falecimento descrito abaixo: ]
RETU M->li_aux       // <- deve retornar um valor qualquer

* \\ Final de R02001F9.PRG
procedure adr_atr2
/*
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
 \ Empresa.: PresServ Inform tica - Limeira (019)452.6623
 \ Programa: ADR_ATR2.PRG
 \ Data....: 29-01-04
 \ Sistema.: Administradora - RECEP€„O
 \ Funcao..: Define atributos dos arquivos (sistema[])
 \ Analista: Ademilson Pedro Bom
 \ Criacao.: GAS-Pro v4.0o
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/

#include "adrbig.ch"    // inicializa constantes manifestas


sistema[020]={;
            "Processos da Circular",;                       // opcao do menu
            "Processos da Circular",;                       // titulo do sistema
            {"grupo+circ+processo","DTOS(dfal)","DTOS(dfal)"},;// chaves do arquivo
            {"Grupo/Circular","p/Data","Grupo e Data"},;    // titulo dos indices para consulta
            {"010203","09","09"},;                          // ordem campos chaves
            {"CPRCIRC",drvdbf,drvntx},;                     // nome do DBF
            {"CPRCIRC1","CPRCIRC2","CPRCIRC3"},;            // nomes dos NTX
            {},;                                            // nome dos dbf's relacionados
            {"CIRCULAR->grupo","CIRCULAR->circ"},;          // campos de relacionamento
            {1,1,8,4,15,76,3,4},;                           // num telas/tela atual/coordenadas/inicio scroll/qtde scroll
            {1,.t.,.f.},;                                   // nivel acesso/tp chave/pede dir
            {},;                                            // campos do arquivo
            {},;                                            // formula mostradas
            {"",""},;                                       // condicao de exclusao de registros
            {"",""},;                                       // condicao de alteracao de registros
            {"",""};                                        // condicao de recupercao de registros
           }

AADD(sistema[020,O_CAMPO],{;            // CPRCIRC
     /* mascara       */    "!!",;
     /* titulo        */    "Grupo",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[020,O_CAMPO],{;            // CPRCIRC
     /* mascara       */    "999",;
     /* titulo        */    "Circular",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[020,O_CAMPO],{;            // CPRCIRC
     /* mascara       */    "@R 99999/99/!!",;
     /* titulo        */    "Processo",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(processo)~Necess rio informar PROCESSO",;
     /* help do campo */    "Informe o n£mero do processo a incluir";
                         };
)
AADD(sistema[020,O_CAMPO],{;            // CPRCIRC
     /* mascara       */    "!!",;
     /* titulo        */    "Categoria",;
     /* cmd especial  */    "MTAB([PL=Plano|PD=Plano c/Diferen‡a|AF=Auxilio],[CATEGORIA])",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "categ $ [PL|PD|AF]~CATEGORIA n„o aceit vel",;
     /* help do campo */    "Preencha com:|PL para Plano,| PD p/Diferen‡a ou |AX para Aux.Funeral";
                         };
)
AADD(sistema[020,O_CAMPO],{;            // CPRCIRC
     /* mascara       */    "999999",;
     /* titulo        */    "Num",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(num).AND.PTAB(num,'GRUPOS',1)~NUM n„o existe na tabela",;
     /* help do campo */    "";
                         };
)
AADD(sistema[020,O_CAMPO],{;            // CPRCIRC
     /* mascara       */    "@!",;
     /* titulo        */    "Fal",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(fal)~Necess rio informar FAL",;
     /* help do campo */    "";
                         };
)
AADD(sistema[020,O_CAMPO],{;            // CPRCIRC
     /* mascara       */    "@!",;
     /* titulo        */    "Ends",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[020,O_CAMPO],{;            // CPRCIRC
     /* mascara       */    "@!",;
     /* titulo        */    "Cids",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[020,O_CAMPO],{;            // CPRCIRC
     /* mascara       */    "@D",;
     /* titulo        */    "Data",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(dfal)~Necess rio informar DATA",;
     /* help do campo */    "";
                         };
)
AADD(sistema[020,O_CAMPO],{;            // CPRCIRC
     /* mascara       */    "!",;
     /* titulo        */    "Flag",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[020,O_FORMULA],{;          // CPRCIRC - Nome
     /* form mostrar  */    "LEFT(TRAN(INSCRITS->nome,[]),35)",;
     /* lin da formula*/    0,;
     /* col da formula*/    0;
                         };
)


sistema[021]={;
            "Processos",;                                   // opcao do menu
            "Processos",;                                   // titulo do sistema
            {"processo+categ","grup+DTOS(dfal)","codlan"},; // chaves do arquivo
            {"p/Processo","Grupo+Data","Cod.Lanc"},;        // titulo dos indices para consulta
            {"0102","0413","14"},;                          // ordem campos chaves
            {"PRCESSOS",drvdbf,drvntx},;                    // nome do DBF
            {"PRCESSO1","PRCESSO2","PRCESSO3"},;            // nomes dos NTX
            {},;                                            // nome dos dbf's relacionados
            {},;                                            // campos de relacionamento
            {1,1,6,14,18,68},;                              // num telas/tela atual/coordenadas
            {0,.t.,.f.},;                                   // nivel acesso/tp chave/pede dir
            {},;                                            // campos do arquivo
            {},;                                            // formula mostradas
            {"EMPT(saiu)","J  emitido nas Taxas|Exclusao nao permitida"},;// condicao de exclusao de registros
            {"EMPT(saiu)","J  emitido nas Taxas|Altera‡ao nao permitida"},;// condicao de alteracao de registros
            {"",""};                                        // condicao de recupercao de registros
           }

AADD(sistema[021,O_CAMPO],{;            // PRCESSOS
     /* mascara       */    "@R 99999/99/!!",;
     /* titulo        */    "Processo",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(processo)~Necess rio informar PROCESSO",;
     /* help do campo */    "Informe o n£mero do processo a incluir";
                         };
)
AADD(sistema[021,O_CAMPO],{;            // PRCESSOS
     /* mascara       */    "!!",;
     /* titulo        */    "Categoria",;
     /* cmd especial  */    "MTAB([PL=Plano|PD=Plano c/Diferen‡a|AF=Auxilio],[CATEGORIA])",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "categ $ [PL|PD|AF]~CATEGORIA n„o aceit vel",;
     /* help do campo */    "Preencha com:|PL para Plano,| PD p/Diferen‡a ou |AX para Aux.Funeral";
                         };
)
AADD(sistema[021,O_CAMPO],{;            // PRCESSOS
     /* mascara       */    "",;
     /* titulo        */    "Saiu",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    "Preencha com o n£mero da circular|ou|deixe em branco se ainda n„o saiu em cobran‡a";
                         };
)
AADD(sistema[021,O_CAMPO],{;            // PRCESSOS
     /* mascara       */    "!!",;
     /* titulo        */    "Grup",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(grup).AND.PTAB(grup,'ARQGRUP',1)~GRUP n„o existe na tabela",;
     /* help do campo */    "Pertence a qual grupo";
                         };
)
AADD(sistema[021,O_CAMPO],{;            // PRCESSOS
     /* mascara       */    "999999",;
     /* titulo        */    "Num",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(num).AND.PTAB(num,'GRUPOS',1)~NUM n„o existe na tabela",;
     /* help do campo */    "Qual contrato";
                         };
)
AADD(sistema[021,O_CAMPO],{;            // PRCESSOS
     /* mascara       */    "9",;
     /* titulo        */    "Inscr.",;
     /* cmd especial  */    "MTAB(M->TBTIPGRAU,[INSCR.])",;
     /* default       */    "IIF(M->pgrau<[7],SUBSTR([1234567],VAL(M->pgrau),1),M->pgrau)",;
     /* pre-validacao */    "",;
     /* validacao     */    "grau $ [12345678].and.(PTAB(num,'INSCRITS',1).or.1=1)~INSCR. n„o aceit vel",;
     /* help do campo */    "Qual o grau de parentesco|Tecle F8 para consulta";
                         };
)
AADD(sistema[021,O_CAMPO],{;            // PRCESSOS
     /* mascara       */    "99",;
     /* titulo        */    "Seq",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "grau>'6'",;
     /* validacao     */    "",;
     /* help do campo */    "Que sequencia";
                         };
)
AADD(sistema[021,O_CAMPO],{;            // PRCESSOS
     /* mascara       */    "@!",;
     /* titulo        */    "Seg",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    "Nome do segurado/Contratante";
                         };
)
AADD(sistema[021,O_CAMPO],{;            // PRCESSOS
     /* mascara       */    "@!",;
     /* titulo        */    "Ends",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    "";
                         };
)
AADD(sistema[021,O_CAMPO],{;            // PRCESSOS
     /* mascara       */    "@!",;
     /* titulo        */    "Cids",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    "";
                         };
)
AADD(sistema[021,O_CAMPO],{;            // PRCESSOS
     /* mascara       */    "@!",;
     /* titulo        */    "Fal",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(fal)~Necess rio informar FAL",;
     /* help do campo */    "Nome do falecido";
                         };
)
AADD(sistema[021,O_CAMPO],{;            // PRCESSOS
     /* mascara       */    "@!",;
     /* titulo        */    "Sep",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(sep)~Necess rio informar SEP",;
     /* help do campo */    "Sepultado em";
                         };
)
AADD(sistema[021,O_CAMPO],{;            // PRCESSOS
     /* mascara       */    "@D",;
     /* titulo        */    "Data",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    "Data do falecimento";
                         };
)
AADD(sistema[021,O_CAMPO],{;            // PRCESSOS
     /* mascara       */    "!!!-99999999-999-999",;
     /* titulo        */    "Cod.Lan‡amento",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[021,O_FORMULA],{;          // PRCESSOS - T.Carˆncia
     /* form mostrar  */    "LEFT(TRAN(IIF(INSCRITS->tcarencia>dfal,[Carˆncia do Inscrito],[]),[]),22)",;
     /* lin da formula*/    4,;
     /* col da formula*/    29;
                         };
)


sistema[022]={;
            "Funcion rios",;                                // opcao do menu
            "Funcion rios",;                                // titulo do sistema
            {"codigo"},;                                    // chaves do arquivo
            {"N£mero"},;                                    // titulo dos indices para consulta
            {"01"},;                                        // ordem campos chaves
            {"FNCS",drvdbf,drvntx},;                        // nome do DBF
            {"FNCS1"},;                                     // nomes dos NTX
            {},;                                            // nome dos dbf's relacionados
            {},;                                            // campos de relacionamento
            {1,1,6,8,15,73},;                               // num telas/tela atual/coordenadas
            {1,.t.,.f.},;                                   // nivel acesso/tp chave/pede dir
            {},;                                            // campos do arquivo
            {},;                                            // formula mostradas
            {"nivelop>2","Permitido apenas para usu rio cadastrado|com n¡vel de Gerˆncia"},;// condicao de exclusao de registros
            {"nivelop>1","Permitido apenas para usu rio cadastrado|com n¡vel de Manuten‡„o ou Gerˆncia"},;// condicao de alteracao de registros
            {"nivelop>2","Permitido apenas para usu rio cadastrado|com n¡vel de Gerˆncia"};// condicao de recupercao de registros
           }

AADD(sistema[022,O_CAMPO],{;            // FNCS
     /* mascara       */    "",;
     /* titulo        */    "C¢digo",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(codigo)~Necess rio informar C¢DIGO",;
     /* help do campo */    "Informe um c¢digo para o funcion rio";
                         };
)
AADD(sistema[022,O_CAMPO],{;            // FNCS
     /* mascara       */    "@!",;
     /* titulo        */    "Nome do funcion rio",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(nome)~Necess rio informar NOME DO FUNCIONRIO",;
     /* help do campo */    "Entre com o nome do funcion rio autorizado a|assinar a declara‡Æo de ¢bito no|Cart¢rio de Registro C¡vil";
                         };
)
AADD(sistema[022,O_CAMPO],{;            // FNCS
     /* mascara       */    "@!",;
     /* titulo        */    "Profiss„o",;
     /* cmd especial  */    "MTAB([ATENDENTE|COBRADOR|MOTORISTA|VENDEDOR],[PROFISSŽO])",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(profiss)~sta informa‡„o ‚ necess rio para a Declara‡„o de ¢bito",;
     /* help do campo */    "Entre com a profiss„o do funcion rio.";
                         };
)
AADD(sistema[022,O_CAMPO],{;            // FNCS
     /* mascara       */    "@!",;
     /* titulo        */    "Nacionalidade",;
     /* cmd especial  */    "",;
     /* default       */    "[BRASILEIRO]",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(nacional)~Necess rio informar NACIONALIDADE",;
     /* help do campo */    "Entre com a nacionalidade";
                         };
)
AADD(sistema[022,O_CAMPO],{;            // FNCS
     /* mascara       */    "!A",;
     /* titulo        */    "Est.Civil",;
     /* cmd especial  */    "MTAB(tbestciv,[EST.CIVIL])",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "estciv $ tbestciv~EST.CIVIL n„o aceit vel.|Tecle F8 para busca em tabela",;
     /* help do campo */    "Entre com o estado civil ou tecle F8";
                         };
)
AADD(sistema[022,O_CAMPO],{;            // FNCS
     /* mascara       */    "@D",;
     /* titulo        */    "Idade",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    "Entre com a data de nascimento";
                         };
)
AADD(sistema[022,O_CAMPO],{;            // FNCS
     /* mascara       */    "@!",;
     /* titulo        */    "Endere‡o",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(endereco)~Necess rio informar Endere‡o",;
     /* help do campo */    "Informe o endere‡o do funcion rio";
                         };
)
AADD(sistema[022,O_CAMPO],{;            // FNCS
     /* mascara       */    "@!",;
     /* titulo        */    "Bairro",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    "Entre com o bairro";
                         };
)
AADD(sistema[022,O_CAMPO],{;            // FNCS
     /* mascara       */    "@!",;
     /* titulo        */    "Cidade",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(cidade)~Necess rio informar CIDADE",;
     /* help do campo */    "Entre com o nome do munic¡pio";
                         };
)
AADD(sistema[022,O_CAMPO],{;            // FNCS
     /* mascara       */    "@R 999.999.999-99",;
     /* titulo        */    "CPF",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "VDV2(cpf) .OR. EMPT(cpf)~CPF n„o aceit vel",;
     /* help do campo */    "";
                         };
)
AADD(sistema[022,O_CAMPO],{;            // FNCS
     /* mascara       */    "",;
     /* titulo        */    "Telefone",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    "";
                         };
)
AADD(sistema[022,O_CAMPO],{;            // FNCS
     /* mascara       */    "999.9",;
     /* titulo        */    "Percentual",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "nivelop=3",;
     /* validacao     */    "!(percent<0).AND.!(percent>100)~PERCENTUAL n„o aceit vel",;
     /* help do campo */    "Informe o percentual de comiss„o|caso o vendedor n„o receba por n£mero de parcelas";
                         };
)
AADD(sistema[022,O_CAMPO],{;            // FNCS
     /* mascara       */    "@S35",;
     /* titulo        */    "Observa‡„o",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    "";
                         };
)
AADD(sistema[022,O_FORMULA],{;          // FNCS - estado civil
     /* form mostrar  */    "LEFT(TRAN(SUBS(tbestciv,AT(estciv,tbestciv),11),[]),15)",;
     /* lin da formula*/    3,;
     /* col da formula*/    15;
                         };
)


sistema[023]={;
            "Hist¢rico Padr„o",;                            // opcao do menu
            "Hist¢rico Padr„o",;                            // titulo do sistema
            {"historico","codigo","codlan"},;               // chaves do arquivo
            {"Por C¢digo","C¢digo Estruturado","Cod.Lanc"},;// titulo dos indices para consulta
            {"01","06","08"},;                              // ordem campos chaves
            {"HISTORIC",drvdbf,drvntx},;                    // nome do DBF
            {"HISTORI1","HISTORI2","HISTORI3"},;            // nomes dos NTX
            {},;                                            // nome dos dbf's relacionados
            {},;                                            // campos de relacionamento
            {1,1,8,4,21,77,3,10},;                          // num telas/tela atual/coordenadas/inicio scroll/qtde scroll
            {1,.t.,.f.},;                                   // nivel acesso/tp chave/pede dir
            {},;                                            // campos do arquivo
            {},;                                            // formula mostradas
            {"origem=[ADM]","Registro utilizado por outro Sistema"},;// condicao de exclusao de registros
            {"orimgem=[ADM]","Registro mantido por outro sistema"},;// condicao de alteracao de registros
            {"",""};                                        // condicao de recupercao de registros
           }

AADD(sistema[023,O_CAMPO],{;            // HISTORIC
     /* mascara       */    "999",;
     /* titulo        */    "Hist",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(HISTORICO)~Este ‚ um campo de preenchimento obrigat¢rio.",;
     /* help do campo */    "Entre com um c¢digo para identificar| este hist¢rico.";
                         };
)
AADD(sistema[023,O_CAMPO],{;            // HISTORIC
     /* mascara       */    "",;
     /* titulo        */    "Descri‡„o de Hist¢rico",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "!EMPTY(historico)",;
     /* validacao     */    "!EMPT(DESCRICAO)~Informe uma DESCRI€ŽO para este c¢digo.",;
     /* help do campo */    "Entre com a identifica‡ao do Hist¢rico.|Ex.:Cheque, Dep¢sito, Pgto de Duplic., etc...";
                         };
)
AADD(sistema[023,O_CAMPO],{;            // HISTORIC
     /* mascara       */    "!",;
     /* titulo        */    "D/C",;
     /* cmd especial  */    "MTAB('D‚bito|Cr‚dito',[TIPO])",;
     /* default       */    "",;
     /* pre-validacao */    "!EMPTY(historico)",;
     /* validacao     */    "EMPTY(TIPO).OR.tipo$[DC]~ necess rio informar se TIPO ‚ D‚bito ou Cr‚dito.|D p/Pagamentos e C para recebimentos.",;
     /* help do campo */    "Este hist¢rico ‚ um D‚bito ou Cr‚dito|Se for D‚b., reduzir  no saldo da conta de|lan‡amento e acrescido na de baixa.";
                         };
)
AADD(sistema[023,O_CAMPO],{;            // HISTORIC
     /* mascara       */    "!!!",;
     /* titulo        */    "C/C",;
     /* cmd especial  */    "MTAB([ADMinistradora|FUNer ria|CONvenio|ESToque|FINanceiro|VIAtura],[ORIGEM])",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    "Informe o prefixo do sistema que|gerou o lan‡amento|O Centro de Custo";
                         };
)
AADD(sistema[023,O_CAMPO],{;            // HISTORIC
     /* mascara       */    "!",;
     /* titulo        */    "R/D",;
     /* cmd especial  */    "MTAB([Receita|Despesa|Transferˆncia],[R/D])",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "recdesp $ [RDT]~Receita/Despesa n„o aceit vel",;
     /* help do campo */    " Receita ou Despesa";
                         };
)
AADD(sistema[023,O_CAMPO],{;            // HISTORIC
     /* mascara       */    "@!",;
     /* titulo        */    "C¢digo",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    "Informe o c¢digo estruturado|para os lan‡amentos com |este hist¢rico.";
                         };
)
AADD(sistema[023,O_CAMPO],{;            // HISTORIC
     /* mascara       */    "99999999",;
     /* titulo        */    "Num.Lan‡amento",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[023,O_CAMPO],{;            // HISTORIC
     /* mascara       */    "!!!-99999999-999-999",;
     /* titulo        */    "Cod.Lan‡amento",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)


sistema[024]={;
            "Custos Adicionais",;                           // opcao do menu
            "Custos Adicionais",;                           // titulo do sistema
            {"DTOS(emissao_)","historic+contrato","contrato+circ","circ+contrato"},;// chaves do arquivo
            {"Ocorrencia","Hist¢rico","Contrato","N§Cobran‡a"},;// titulo dos indices para consulta
            {"01","0405","0510","1005"},;                   // ordem campos chaves
            {"CSTSEG",drvdbf,drvntx},;                      // nome do DBF
            {"CSTSEG1","CSTSEG2","CSTSEG3","CSTSEG4"},;     // nomes dos NTX
            {},;                                            // nome dos dbf's relacionados
            {},;                                            // campos de relacionamento
            {1,1,6,15,13,66},;                              // num telas/tela atual/coordenadas
            {1,.f.,.f.},;                                   // nivel acesso/tp chave/pede dir
            {},;                                            // campos do arquivo
            {},;                                            // formula mostradas
            {"",""},;                                       // condicao de exclusao de registros
            {"",""},;                                       // condicao de alteracao de registros
            {"",""};                                        // condicao de recupercao de registros
           }

AADD(sistema[024,O_CAMPO],{;            // CSTSEG
     /* mascara       */    "@D",;
     /* titulo        */    "Emiss„o",;
     /* cmd especial  */    "DATE()",;
     /* default       */    "date()",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(emissao_)~Necess rio informar DATA DE EMISSAO v lida",;
     /* help do campo */    "Informe a data da gera‡„o desta cobran‡a";
                         };
)
AADD(sistema[024,O_CAMPO],{;            // CSTSEG
     /* mascara       */    "99:99",;
     /* titulo        */    "Hora",;
     /* cmd especial  */    "",;
     /* default       */    "TIME()",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(hora)~Necess rio informar HORA",;
     /* help do campo */    "Informe a hora|Se necess rio";
                         };
)
AADD(sistema[024,O_CAMPO],{;            // CSTSEG
     /* mascara       */    "",;
     /* titulo        */    "Quem",;
     /* cmd especial  */    "",;
     /* default       */    "M->usuario",;
     /* pre-validacao */    "",;
     /* validacao     */    "V",;
     /* help do campo */    "";
                         };
)
AADD(sistema[024,O_CAMPO],{;            // CSTSEG
     /* mascara       */    "999",;
     /* titulo        */    "Hist¢rico",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "PTAB(historic,'HISTORIC',1)~Este ‚ um campo de preenchimento obrigat¢rio.|Tecle F8 para busca em tabela",;
     /* help do campo */    "Entre com um c¢digo para identificar| a cobran‡a";
                         };
)
AADD(sistema[024,O_CAMPO],{;            // CSTSEG
     /* mascara       */    "999999",;
     /* titulo        */    "Contrato",;
     /* cmd especial  */    "VDBF(6,26,20,77,'GRUPOS',{'grupo','codigo','nome'},1,'codigo')",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "PTAB(contrato,'GRUPOS',1)~Contrato inv lido |ou inexistente",;
     /* help do campo */    "Informe o n£mero do contrato";
                         };
)
AADD(sistema[024,O_CAMPO],{;            // CSTSEG
     /* mascara       */    "@!",;
     /* titulo        */    "Complemento",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(complement)~Entre com uma informa‡„o que diferencie este|lan‡amento de outros com mesmo hist¢rico.",;
     /* help do campo */    "Informe algo para identificar esta cobran‡a";
                         };
)
AADD(sistema[024,O_CAMPO],{;            // CSTSEG
     /* mascara       */    "99999",;
     /* titulo        */    "Qtdade",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "!(qtdade<0)~Informe uma quantidade v lida (>=0)",;
     /* help do campo */    "";
                         };
)
AADD(sistema[024,O_CAMPO],{;            // CSTSEG
     /* mascara       */    "999999.99",;
     /* titulo        */    "Valor",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "!(valor=0)~VALOR n„o aceit vel|Deve ser diferente de zeros",;
     /* help do campo */    "Informe o valor do servi‡o";
                         };
)
AADD(sistema[024,O_CAMPO],{;            // CSTSEG
     /* mascara       */    "9",;
     /* titulo        */    "Tipo",;
     /* cmd especial  */    "MTAB([1=J¢ia|2=Taxa|3=Carnˆ],[TIPO])",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    "Qual o tipo de lan‡amento";
                         };
)
AADD(sistema[024,O_CAMPO],{;            // CSTSEG
     /* mascara       */    "999",;
     /* titulo        */    "Circ",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "(PTAB(contrato+tipo+circ,'TAXAS',1).AND.TAXAS->valorpg=0).or.circ<[001]~Taxa n„o cadastrada,|ou,| j  paga.",;
     /* help do campo */    "Informe o n£mero da circular a consultar";
                         };
)


sistema[025]={;
            "Mensagem p/Contrato",;                         // opcao do menu
            "Mensagem p/Contrato",;                         // titulo do sistema
            {"seq"},;                                       // chaves do arquivo
            {"Sequencia"},;                                 // titulo dos indices para consulta
            {"01"},;                                        // ordem campos chaves
            {"MENSAG",drvdbf,drvntx},;                      // nome do DBF
            {"MENSAG1"},;                                   // nomes dos NTX
            {},;                                            // nome dos dbf's relacionados
            {},;                                            // campos de relacionamento
            {1,1,9,9,18,72},;                               // num telas/tela atual/coordenadas
            {1,.t.,.f.},;                                   // nivel acesso/tp chave/pede dir
            {},;                                            // campos do arquivo
            {},;                                            // formula mostradas
            {"",""},;                                       // condicao de exclusao de registros
            {"",""},;                                       // condicao de alteracao de registros
            {"",""};                                        // condicao de recupercao de registros
           }

AADD(sistema[025,O_CAMPO],{;            // MENSAG
     /* mascara       */    "999999",;
     /* titulo        */    "Sequˆncia",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(seq)~Necess rio informar SEQUENCIA",;
     /* help do campo */    "Informe o n£mero sequencial|os menores ser„o apresentados antes";
                         };
)
AADD(sistema[025,O_CAMPO],{;            // MENSAG
     /* mascara       */    "@S50",;
     /* titulo        */    "Crit‚rio",;
     /* cmd especial  */    "MEN_01F9()",;
     /* default       */    "MEN_01F9()",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(filtro)~Informe uma express„o v lida",;
     /* help do campo */    "Informe o crit‚rio de filtragem|para exibi‡„o da mensagem.";
                         };
)
AADD(sistema[025,O_CAMPO],{;            // MENSAG
     /* mascara       */    "@S50",;
     /* titulo        */    "Menssagem",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(mens1)~Informe a mensagem a apresentar,|tecle F7 para entrar e sair do campo",;
     /* help do campo */    "Informe a mensagem que ser  apresentada |na tela quando for satisfeita a condi‡„o informada";
                         };
)
AADD(sistema[025,O_CAMPO],{;            // MENSAG
     /* mascara       */    "@D",;
     /* titulo        */    "Lan‡amento",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[025,O_CAMPO],{;            // MENSAG
     /* mascara       */    "",;
     /* titulo        */    "Por",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[025,O_FORMULA],{;          // MENSAG - Lan‡amento
     /* form mostrar  */    "LEFT(TRAN(lancto_,[@D]),10)",;
     /* lin da formula*/    1,;
     /* col da formula*/    40;
                         };
)
AADD(sistema[025,O_FORMULA],{;          // MENSAG - mensagem1
     /* form mostrar  */    "LEFT(TRAN(MEMOLINE(MENSAG->mens1,50,1),[]),50)",;
     /* lin da formula*/    4,;
     /* col da formula*/    12;
                         };
)
AADD(sistema[025,O_FORMULA],{;          // MENSAG - MENSAGEM 2
     /* form mostrar  */    "LEFT(TRAN(MEMOLINE(MENSAG->mens1,50,2),[]),50)",;
     /* lin da formula*/    5,;
     /* col da formula*/    12;
                         };
)
AADD(sistema[025,O_FORMULA],{;          // MENSAG - MENSAGEM 3
     /* form mostrar  */    "LEFT(TRAN(MEMOLINE(MENSAG->mens1,50,3),[]),50)",;
     /* lin da formula*/    6,;
     /* col da formula*/    12;
                         };
)
AADD(sistema[025,O_FORMULA],{;          // MENSAG - MENSAGEM 4
     /* form mostrar  */    "LEFT(TRAN(MEMOLINE(MENSAG->mens1,50,4),[]),50)",;
     /* lin da formula*/    7,;
     /* col da formula*/    12;
                         };
)
AADD(sistema[025,O_FORMULA],{;          // MENSAG - MENSAGEM 5
     /* form mostrar  */    "LEFT(TRAN(MEMOLINE(MENSAG->mens1,50,5),[]),50)",;
     /* lin da formula*/    8,;
     /* col da formula*/    12;
                         };
)
AADD(sistema[025,O_FORMULA],{;          // MENSAG - Por
     /* form mostrar  */    "LEFT(TRAN(por,[]),10)",;
     /* lin da formula*/    1,;
     /* col da formula*/    51;
                         };
)


sistema[026]={;
            "Caixas",;                                      // opcao do menu
            "Caixas",;                                      // titulo do sistema
            {"numop","numconta+historico+DTOS(fechto_)","codlan"},;// chaves do arquivo
            {"p/N£mero","p/Conta","Cod.Lanc"},;             // titulo dos indices para consulta
            {"01","050613","19"},;                          // ordem campos chaves
            {"ORDPGRC",drvdbf,drvntx},;                     // nome do DBF
            {"ORDPGRC1","ORDPGRC2","ORDPGRC3"},;            // nomes dos NTX
            {},;                                            // nome dos dbf's relacionados
            {},;                                            // campos de relacionamento
            {1,1,7,12,20,71},;                              // num telas/tela atual/coordenadas
            {3,.t.,.f.},;                                   // nivel acesso/tp chave/pede dir
            {},;                                            // campos do arquivo
            {},;                                            // formula mostradas
            {"",""},;                                       // condicao de exclusao de registros
            {"",""},;                                       // condicao de alteracao de registros
            {"",""};                                        // condicao de recupercao de registros
           }

AADD(sistema[026,O_CAMPO],{;            // ORDPGRC
     /* mascara       */    "999999",;
     /* titulo        */    "N§ O.P.",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(numop)~Necess rio informar N§ O.P.",;
     /* help do campo */    "";
                         };
)
AADD(sistema[026,O_CAMPO],{;            // ORDPGRC
     /* mascara       */    "!!!",;
     /* titulo        */    "Origem",;
     /* cmd especial  */    "MTAB([ADMinistradora|FUNer ria|CONvenio|ESToque|FINanceiro|VIAtura],[ORIGEM])",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "origem $ [ADM|FUN|CON|EST|FIN|VIA]~ORIGEM n„o aceit vel",;
     /* help do campo */    "Informe o prefixo do sistema que|gerou o lan‡amento";
                         };
)
AADD(sistema[026,O_CAMPO],{;            // ORDPGRC
     /* mascara       */    "@D",;
     /* titulo        */    "Lancto_",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "V",;
     /* help do campo */    "";
                         };
)
AADD(sistema[026,O_CAMPO],{;            // ORDPGRC
     /* mascara       */    "",;
     /* titulo        */    "Por",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "V",;
     /* help do campo */    "";
                         };
)
AADD(sistema[026,O_CAMPO],{;            // ORDPGRC
     /* mascara       */    "@!",;
     /* titulo        */    "Conta",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(numconta)~Campo obrigat¢rio!|Identifique a Conta/Cadastro com um n£mero | ou nome qualquer.",;
     /* help do campo */    "Informe a conta que receber  este lan‡amento.";
                         };
)
AADD(sistema[026,O_CAMPO],{;            // ORDPGRC
     /* mascara       */    "999",;
     /* titulo        */    "Hist¢rico",;
     /* cmd especial  */    "VDBF(6,24,20,77,'HISTORIC',{'historico','descricao','tipo'},1,'historico',[HISTORIC->origem$']+origem+[   '])",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "EMPT(historico).OR.PTAB(historico,'HISTORIC',1)~HIST¢RICO n„o existe na tabela",;
     /* help do campo */    "Informe o hist¢rico do lan‡amento.";
                         };
)
AADD(sistema[026,O_CAMPO],{;            // ORDPGRC
     /* mascara       */    "!",;
     /* titulo        */    "D‚b/Cr‚d",;
     /* cmd especial  */    "MTAB([D‚bito|Cr‚dito],[DB/CRD])",;
     /* default       */    "HISTORIC->tipo",;
     /* pre-validacao */    "",;
     /* validacao     */    "debcred$[CD]~Necess rio informar DB/CRD",;
     /* help do campo */    "Se for um documento a pagar ser  D, sen„o C";
                         };
)
AADD(sistema[026,O_CAMPO],{;            // ORDPGRC
     /* mascara       */    "99999999.99",;
     /* titulo        */    "Valor Lan‡amento",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "!(VALORtotal<0.00)~VALOR TOTAL DO LAN€AMENTO| deve ser positivo ou zeros",;
     /* help do campo */    "Entre com o valor total do documento,|se valor = zero, ser  apenas agendado.";
                         };
)
AADD(sistema[026,O_CAMPO],{;            // ORDPGRC
     /* mascara       */    "@D",;
     /* titulo        */    "Vencto",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(vencto_)~Necess rio informar VENCTO",;
     /* help do campo */    "Entre com a data do vencimento deste.";
                         };
)
AADD(sistema[026,O_CAMPO],{;            // ORDPGRC
     /* mascara       */    "@!",;
     /* titulo        */    "Documento",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPTY(documento)~Digite algo para identificar o documento",;
     /* help do campo */    "Entre com o n£mero do documento";
                         };
)
AADD(sistema[026,O_CAMPO],{;            // ORDPGRC
     /* mascara       */    "99999",;
     /* titulo        */    "N§Doctos",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "!(nrdoctos<0)~N§DOCTOS n„o aceit vel",;
     /* help do campo */    "";
                         };
)
AADD(sistema[026,O_CAMPO],{;            // ORDPGRC
     /* mascara       */    "@!",;
     /* titulo        */    "Complemento de Hist¢rico",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(complement)~Entre com uma informa‡„o que diferencie este|lan‡amento de outros com mesmo hist¢rico.",;
     /* help do campo */    "";
                         };
)
AADD(sistema[026,O_CAMPO],{;            // ORDPGRC
     /* mascara       */    "@D",;
     /* titulo        */    "Fechto",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "V",;
     /* help do campo */    "";
                         };
)
AADD(sistema[026,O_CAMPO],{;            // ORDPGRC
     /* mascara       */    "",;
     /* titulo        */    "Fechpor",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "V",;
     /* help do campo */    "";
                         };
)
AADD(sistema[026,O_CAMPO],{;            // ORDPGRC
     /* mascara       */    "@D",;
     /* titulo        */    "Autorizado em",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "V",;
     /* help do campo */    "";
                         };
)
AADD(sistema[026,O_CAMPO],{;            // ORDPGRC
     /* mascara       */    "",;
     /* titulo        */    "Autorizado",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "V",;
     /* help do campo */    "";
                         };
)
AADD(sistema[026,O_CAMPO],{;            // ORDPGRC
     /* mascara       */    "9999999",;
     /* titulo        */    "Lan‡amento N§",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "V",;
     /* help do campo */    "";
                         };
)
AADD(sistema[026,O_CAMPO],{;            // ORDPGRC
     /* mascara       */    "99999999",;
     /* titulo        */    "Num.Lan‡amento",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[026,O_CAMPO],{;            // ORDPGRC
     /* mascara       */    "!!!-99999999-999-999",;
     /* titulo        */    "Cod.Lan‡amento",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[026,O_FORMULA],{;          // ORDPGRC - Descri‡„o de Hi
     /* form mostrar  */    "LEFT(TRAN(HISTORIC->descricao,[]),40)",;
     /* lin da formula*/    5,;
     /* col da formula*/    17;
                         };
)


sistema[027]={;
            "Parƒmetros",;                                  // opcao do menu
            "Parƒmetros do sistema",;                       // titulo do sistema
            {},;                                            // chaves do arquivo
            {},;                                            // titulo dos indices para consulta
            {},;                                            // ordem campos chaves
            {"PAR_ADM",drvdbf,drvntx},;                     // nome do DBF
            {},;                                            // nomes dos NTX
            {},;                                            // nome dos dbf's relacionados
            {},;                                            // campos de relacionamento
            {1,1,2,8,23,71},;                               // num telas/tela atual/coordenadas
            {2,.f.,.f.},;                                   // nivel acesso/tp chave/pede dir
            {},;                                            // campos do arquivo
            {},;                                            // formula mostradas
            {"",""},;                                       // condicao de exclusao de registros
            {"",""},;                                       // condicao de alteracao de registros
            {"",""};                                        // condicao de recupercao de registros
           }

AADD(sistema[027,O_CAMPO],{;            // PAR_ADM
     /* mascara       */    "!!",;
     /* titulo        */    "Grupo",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "V",;
     /* help do campo */    "";
                         };
)
AADD(sistema[027,O_CAMPO],{;            // PAR_ADM
     /* mascara       */    "@!",;
     /* titulo        */    "C¢digo",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    "Informe o c¢digo da filial";
                         };
)
AADD(sistema[027,O_CAMPO],{;            // PAR_ADM
     /* mascara       */    "999999",;
     /* titulo        */    "Codigo",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "V",;
     /* help do campo */    "";
                         };
)
AADD(sistema[027,O_CAMPO],{;            // PAR_ADM
     /* mascara       */    "9",;
     /* titulo        */    "Inscr.",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "V",;
     /* help do campo */    "";
                         };
)
AADD(sistema[027,O_CAMPO],{;            // PAR_ADM
     /* mascara       */    "99",;
     /* titulo        */    "Seq",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "V",;
     /* help do campo */    "";
                         };
)
AADD(sistema[027,O_CAMPO],{;            // PAR_ADM
     /* mascara       */    "!",;
     /* titulo        */    "Verificar Pagas?",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[027,O_CAMPO],{;            // PAR_ADM
     /* mascara       */    "!",;
     /* titulo        */    "Repetir lan‡amento?",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[027,O_CAMPO],{;            // PAR_ADM
     /* mascara       */    "999999",;
     /* titulo        */    "Maior Contrato",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[027,O_CAMPO],{;            // PAR_ADM
     /* mascara       */    "999999",;
     /* titulo        */    "N£mero",;
     /* cmd especial  */    "",;
     /* default       */    "000000",;
     /* pre-validacao */    "",;
     /* validacao     */    "V",;
     /* help do campo */    "";
                         };
)
AADD(sistema[027,O_CAMPO],{;            // PAR_ADM
     /* mascara       */    "999999",;
     /* titulo        */    "Nrreint",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "V",;
     /* help do campo */    "";
                         };
)
AADD(sistema[027,O_CAMPO],{;            // PAR_ADM
     /* mascara       */    "@!",;
     /* titulo        */    "Conta Recepcao",;
     /* cmd especial  */    "",;
     /* default       */    "[RECEP]",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(contarec)~Necess rio informar CONTA RECEPCAO p/recebimentos",;
     /* help do campo */    "Informe a Conta que receber |os lan‡amentos da recep‡„o.";
                         };
)
AADD(sistema[027,O_CAMPO],{;            // PAR_ADM
     /* mascara       */    "@!",;
     /* titulo        */    "Conta Pagamento",;
     /* cmd especial  */    "",;
     /* default       */    "[RECEP]",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(contapag)~Necess rio informar CONTA RECEPCAO p/Pagamentos",;
     /* help do campo */    "Informe a Conta que pagar |os lan‡amentos da recep‡„o.";
                         };
)
AADD(sistema[027,O_CAMPO],{;            // PAR_ADM
     /* mascara       */    "999",;
     /* titulo        */    "Hist¢rico",;
     /* cmd especial  */    "VDBF(6,24,20,77,'HISTORIC',{'historico','descricao','tipo'},1,'historico',[HISTORIC->origem$'ADM   '])",;
     /* default       */    "[004]",;
     /* pre-validacao */    "",;
     /* validacao     */    "histrccar=[000].OR. PTAB(histrccar,'HISTORIC',1)~HIST¢RICO n„o existe na tabela",;
     /* help do campo */    "Informe o hist¢rico do lan‡amento|para parcelas recebidas na Recep‡„o.";
                         };
)
AADD(sistema[027,O_CAMPO],{;            // PAR_ADM
     /* mascara       */    "999",;
     /* titulo        */    "Hist¢rico",;
     /* cmd especial  */    "VDBF(6,24,20,77,'HISTORIC',{'historico','descricao','tipo'},1,'historico',[HISTORIC->origem$'ADM   '])",;
     /* default       */    "[001]",;
     /* pre-validacao */    "",;
     /* validacao     */    "histrcfcc=[000].OR. PTAB(histrcfcc,'HISTORIC',1)~HIST¢RICO n„o existe na tabela",;
     /* help do campo */    "Informe o hist¢rico do lan‡amento de|recebimento de FCC.";
                         };
)
AADD(sistema[027,O_CAMPO],{;            // PAR_ADM
     /* mascara       */    "999",;
     /* titulo        */    "Hist¢rico",;
     /* cmd especial  */    "VDBF(6,24,20,77,'HISTORIC',{'historico','descricao','tipo'},1,'historico',[HISTORIC->origem$'ADM   '])",;
     /* default       */    "[002]",;
     /* pre-validacao */    "",;
     /* validacao     */    "histrcrec=[000].OR. PTAB(histrcrec,'HISTORIC',1)~HIST¢RICO n„o existe na tabela",;
     /* help do campo */    "Informe o hist¢rico do lan‡amento|para taxas recebidas na Recep‡„o.";
                         };
)
AADD(sistema[027,O_CAMPO],{;            // PAR_ADM
     /* mascara       */    "999",;
     /* titulo        */    "Hist¢rico",;
     /* cmd especial  */    "VDBF(6,24,20,77,'HISTORIC',{'historico','descricao','tipo'},1,'historico',[HISTORIC->origem$'ADM   '])",;
     /* default       */    "[003]",;
     /* pre-validacao */    "",;
     /* validacao     */    "histpg=[000].OR. PTAB(histpg,'HISTORIC',1)~HIST¢RICO n„o existe na tabela",;
     /* help do campo */    "Informe o hist¢rico|para lan‡amento de pagamentos.";
                         };
)
AADD(sistema[027,O_CAMPO],{;            // PAR_ADM
     /* mascara       */    "@R 99-999999",;
     /* titulo        */    "N§ Recibo",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(nrauxrec)~Necess rio informar N§ RECIBO",;
     /* help do campo */    "Informe o n£mero do recibo a imprimir.|no formato AA-NNNNNN|onde: AA=Ano, N=n£mero";
                         };
)
AADD(sistema[027,O_CAMPO],{;            // PAR_ADM
     /* mascara       */    "999999",;
     /* titulo        */    "Codigo",;
     /* cmd especial  */    "VDBF(6,26,20,77,'GRUPOS',{'grupo','codigo','nome'},1,'codigo',[situacao=1])",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "PTAB(mcodigo,'GRUPOS',1).AND.PTAB(mcodigo,'TAXAS',1).OR.mcodigo=[00000]~C¢digo inv lido ou sem Taxas pendentes",;
     /* help do campo */    "Informe o n£mero do contrato";
                         };
)
AADD(sistema[027,O_CAMPO],{;            // PAR_ADM
     /* mascara       */    "!",;
     /* titulo        */    "Tipo",;
     /* cmd especial  */    "MTAB([1=J¢ia|2=Taxa|3=Carnˆ|6=J¢ia+Seguro|7=Taxa+Seguro|8=Carnˆ+Seguro],[TIPO])",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "mtipo $ [123678]~TIPO n„o aceit vel",;
     /* help do campo */    "Qual o tipo de lan‡amento";
                         };
)
AADD(sistema[027,O_CAMPO],{;            // PAR_ADM
     /* mascara       */    "999",;
     /* titulo        */    "Circular",;
     /* cmd especial  */    "VDBF(6,22,20,77,'TAXAS',{'codigo','circ','emissao_','valor','valorpg','forma'},1,'circ',[])",;
     /* default       */    "",;
     /* pre-validacao */    "!(mcodigo=[00000])",;
     /* validacao     */    "PTAB(mcodigo+mcirc,'TAXAS',1).AND.PTAB(GRUPOS->grupo+mcirc,'CIRCULAR',1)~Necess rio informar CIRCULAR existente",;
     /* help do campo */    "N£mero da Circular|Mantido pela emissao de recibos";
                         };
)
AADD(sistema[027,O_CAMPO],{;            // PAR_ADM
     /* mascara       */    "!!",;
     /* titulo        */    "Grup",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "EMPT(mgrupvip).OR.PTAB(mgrupvip,'ARQGRUP',1)~GRUP n„o existe na tabela",;
     /* help do campo */    "Entre com o c¢digo do Grupo que ser  utilizado|como controle dos contratos VIPs.";
                         };
)
AADD(sistema[027,O_CAMPO],{;            // PAR_ADM
     /* mascara       */    "!",;
     /* titulo        */    "Combarra",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "combarra$'SN '~COMBARRA n„o aceit vel|Digite S ou N",;
     /* help do campo */    "Informe se os recibos devem ser impressos|com o c¢digo de barras";
                         };
)
AADD(sistema[027,O_CAMPO],{;            // PAR_ADM
     /* mascara       */    "!",;
     /* titulo        */    "Com Inscritos",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "cinscr$'SN '~Digite S ou N",;
     /* help do campo */    "Informe se os Inscritos estÆo cadastrados";
                         };
)
AADD(sistema[027,O_CAMPO],{;            // PAR_ADM
     /* mascara       */    "!",;
     /* titulo        */    "Com Falecido",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "comfalec$'SN '~Digite S para imprimir recibos com os|Falecidos da circular.",;
     /* help do campo */    "Informe se os recibos da recep‡Æo|devem ser impressos com os|falecidos (cartinha)";
                         };
)
AADD(sistema[027,O_CAMPO],{;            // PAR_ADM
     /* mascara       */    "99999",;
     /* titulo        */    "Processo",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[027,O_CAMPO],{;            // PAR_ADM
     /* mascara       */    "99",;
     /* titulo        */    "Ano",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[027,O_CAMPO],{;            // PAR_ADM
     /* mascara       */    "!!",;
     /* titulo        */    "Mproc3",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[027,O_CAMPO],{;            // PAR_ADM
     /* mascara       */    "99999",;
     /* titulo        */    "N£mero",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[027,O_CAMPO],{;            // PAR_ADM
     /* mascara       */    "@R 99999/99/!!",;
     /* titulo        */    "Procimp",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[027,O_CAMPO],{;            // PAR_ADM
     /* mascara       */    "@E 999,999.99",;
     /* titulo        */    "Valor",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[027,O_CAMPO],{;            // PAR_ADM
     /* mascara       */    "!!!",;
     /* titulo        */    "Cobrador",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[027,O_CAMPO],{;            // PAR_ADM
     /* mascara       */    "@R 99/99",;
     /* titulo        */    "Mˆs Ref.",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[027,O_CAMPO],{;            // PAR_ADM
     /* mascara       */    "",;
     /* titulo        */    "Pnumfcc",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[027,O_CAMPO],{;            // PAR_ADM
     /* mascara       */    "@!",;
     /* titulo        */    "Munic¡pio",;
     /* cmd especial  */    "",;
     /* default       */    "[LIMEIRA]",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(p_cidade)~Necess rio informar MUNIC¡PIO",;
     /* help do campo */    "Entre com o nome do Munic¡pio";
                         };
)
AADD(sistema[027,O_CAMPO],{;            // PAR_ADM
     /* mascara       */    "!",;
     /* titulo        */    "Recibo Padr„o",;
     /* cmd especial  */    "MTAB([S-Recibos em pap‚l branco|N-Recibos pr‚-impressos],[RECIBO PADRŽO])",;
     /* default       */    "[S]",;
     /* pre-validacao */    "",;
     /* validacao     */    "(p_recp$[SN ])~RECIBO PADRŽO n„o aceit vel|Digite S, N ou deixe sem preencher.",;
     /* help do campo */    "Digite S para utilizar o modelo|Padronizado de recibos (formul rio branco)|ou N para recibos personalizados";
                         };
)
AADD(sistema[027,O_CAMPO],{;            // PAR_ADM
     /* mascara       */    "",;
     /* titulo        */    "Ident1",;
     /* cmd especial  */    "",;
     /* default       */    "[Ind£stria de Urnas Bignotto Ltda]",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(setup1)~Digite o nome da Empresa|Ser  utilizado em relat¢rios",;
     /* help do campo */    "Informe o nome da Empresa";
                         };
)
AADD(sistema[027,O_CAMPO],{;            // PAR_ADM
     /* mascara       */    "@R 99.999.999/9999-99",;
     /* titulo        */    "CGC",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "VCGC(cgcsetup).or.EMPT(cgcsetup)~Necess rio informar CGC",;
     /* help do campo */    "";
                         };
)
AADD(sistema[027,O_CAMPO],{;            // PAR_ADM
     /* mascara       */    "",;
     /* titulo        */    "Ident2",;
     /* cmd especial  */    "Informe o endere‡o da Empresa",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(setup2)~Digite o endere‡o,|ser  a 2¦ linha de cabe‡alho|de alguns relat¢rios",;
     /* help do campo */    "Digite o endere‡o.";
                         };
)
AADD(sistema[027,O_CAMPO],{;            // PAR_ADM
     /* mascara       */    "",;
     /* titulo        */    "Setup3",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    "Informe a 3¦ linha de cabe‡alho.|Ex.: Telefone, Fax, etc...";
                         };
)
AADD(sistema[027,O_FORMULA],{;          // PAR_ADM - Desc.Pgto.
     /* form mostrar  */    "LEFT(TRAN(IIF(PTAB(histpg,'HISTORIC',1),HISTORIC->descricao,SPACE(40)),[]),40)",;
     /* lin da formula*/    5,;
     /* col da formula*/    22;
                         };
)
AADD(sistema[027,O_FORMULA],{;          // PAR_ADM - Desc.Recebto
     /* form mostrar  */    "LEFT(TRAN(IIF(PTAB(histrcrec,'HISTORIC',1),HISTORIC->descricao,SPACE(40)),[]),40)",;
     /* lin da formula*/    3,;
     /* col da formula*/    22;
                         };
)
AADD(sistema[027,O_FORMULA],{;          // PAR_ADM - Desc.Receb.FCC
     /* form mostrar  */    "LEFT(TRAN(IIF(PTAB(histrcfcc,'HISTORIC',1),HISTORIC->descricao,SPACE(40)),[]),40)",;
     /* lin da formula*/    2,;
     /* col da formula*/    22;
                         };
)
AADD(sistema[027,O_FORMULA],{;          // PAR_ADM - Descri‡„o de Hi
     /* form mostrar  */    "LEFT(TRAN(IIF(PTAB(histrccar,'HISTORIC',1),HISTORIC->descricao,SPACE(40)),[]),40)",;
     /* lin da formula*/    4,;
     /* col da formula*/    22;
                         };
)

sistema[028]={;
            "Avisos / Carencias",;                          // opcao do menu
            "Avisos / carencias",;                          // titulo do sistema
            {"seq0","codigo"},;                             // chaves do arquivo
            {"Sequencia","Contrato"},;                      // titulo dos indices para consulta
            {"02","05"},;                                   // ordem campos chaves
            {"MFILIAL",drvdbf,drvntx},;                     // nome do DBF
            {"MFILIAL1","MFILIAL2"},;                       // nomes dos NTX
            {},;                                            // nome dos dbf's relacionados
            {},;                                            // campos de relacionamento
            {1,1,7,5,16,76},;                               // num telas/tela atual/coordenadas
            {1,.t.,.f.},;                                   // nivel acesso/tp chave/pede dir
            {},;                                            // campos do arquivo
            {},;                                            // formula mostradas
            {"",""},;                                       // condicao de exclusao de registros
            {"",""},;                                       // condicao de alteracao de registros
            {"",""};                                        // condicao de recupercao de registros
           }

AADD(sistema[028,O_CAMPO],{;            // MFILIAL
     /* mascara       */    "@!",;
     /* titulo        */    "Filial",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[028,O_CAMPO],{;            // MFILIAL
     /* mascara       */    "999999",;
     /* titulo        */    "Seq0",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "V",;
     /* help do campo */    "";
                         };
)
AADD(sistema[028,O_CAMPO],{;            // MFILIAL
     /* mascara       */    "@D",;
     /* titulo        */    "Data_",;
     /* cmd especial  */    "",;
     /* default       */    "DATE()",;
     /* pre-validacao */    "",;
     /* validacao     */    "V",;
     /* help do campo */    "";
                         };
)
AADD(sistema[028,O_CAMPO],{;            // MFILIAL
     /* mascara       */    "",;
     /* titulo        */    "Por",;
     /* cmd especial  */    "",;
     /* default       */    "M->usuario",;
     /* pre-validacao */    "",;
     /* validacao     */    "V",;
     /* help do campo */    "";
                         };
)
AADD(sistema[028,O_CAMPO],{;            // MFILIAL
     /* mascara       */    "@!",;
     /* titulo        */    "Codigo",;
     /* cmd especial  */    "VDBF(6,3,20,77,'GRUPOS',{'codigo','grupo','nome','endereco'},1,'codigo',[])",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "(PTAB(ALLTRIM(codigo),[GRUPOS]).AND.BXR_07F9()).AND.(PTAB(codigo,'TAXAS',1).OR.(1=1)).AND.CAD_04F9(op_menu)~Contrato inv lido |ou inexistente",;
     /* help do campo */    "Informe o n£mero do contrato";
                         };
)
AADD(sistema[028,O_CAMPO],{;            // MFILIAL
     /* mascara       */    "@D",;
     /* titulo        */    "Termino Carencia",;
     /* cmd especial  */    "date()+90",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    "Informe a data do termino da carencia";
                         };
)
AADD(sistema[028,O_CAMPO],{;            // MFILIAL
     /* mascara       */    "@!",;
     /* titulo        */    "Obs1",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    "";
                         };
)
AADD(sistema[028,O_CAMPO],{;            // MFILIAL
     /* mascara       */    "@!",;
     /* titulo        */    "Obs2",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    "";
                         };
)
AADD(sistema[028,O_CAMPO],{;            // MFILIAL
     /* mascara       */    "@!",;
     /* titulo        */    "Obs3",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    "";
                         };
)
AADD(sistema[028,O_CAMPO],{;            // MFILIAL
     /* mascara       */    "@!",;
     /* titulo        */    "Idxd",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[028,O_CAMPO],{;            // MFILIAL
     /* mascara       */    "@!",;
     /* titulo        */    "Idxm",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[028,O_FORMULA],{;          // MFILIAL - nome
     /* form mostrar  */    "LEFT(TRAN(iif(ptab(codigo,[grupos]),grupos->nome,[ ]),[]),35)",;
     /* lin da formula*/    3,;
     /* col da formula*/    31;
                         };
)

sistema[nss-2]={;
            "Senhas",;                   // opcao do menu
            "Grupos de usu rios",;       // titulo do sistema
            {"pw_grupo"},;               // chaves do arquivo
            {"Codigo"},;                 // titulo dos indices para consulta
            {"01"},;                     // ordem campos chaves
            {"PWGRUPOS",drvpw,drvpw},;   // nome do DBF
            {"PWGRUPO1"},;               // nomes dos NTX
            {"PWTABELA","PWUSUA"},;      // nome dos dbf's relacionados
            {},;                         // campos de relacionamento
            {1,1,1,12,3,65},;            // num telas/tela atual/coordenadas
            {3,.t.,.f.},;                // nivel acesso/tp chave/pede dir
            {},;                         // campos do arquivo
            {},;// fromula { mascara, titulo, formula, linha, coluna }
            {"",""},;      // condicao de exclusao de registros
            {"",""},;      // condicao de alteracao de registros
            {"",""};       // condicao de recuperacao de registros
           }

AADD(sistema[nss-2,O_CAMPO],{;           // PWGRUPOS
     /* mascara       */    "9999",;
     /* titulo        */    "C¢digo",;
     /* cmd especial  */    "",;
     /* default       */    "1",;
     /* pre-validacao */    "",;
     /* validacao     */    "V",;
     /* help do campo */    "";
                         };
)
AADD(sistema[nss-2,O_CAMPO],{;           // PWGRUPOS
     /* mascara       */    "@!",;
     /* titulo        */    "Grupo",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(_nogrupo)~Necess rio informar GRUPO",;
     /* help do campo */    "";
                         };
)

sistema[nss-1]={;
            "Tabelas",;                  // opcao do menu
            "Tabelas",;                  // titulo do sistema
            {"pw_grupo+pw_dbf"},;        // chaves do arquivo
            {"Por Grupo"},;              // titulo dos indices para consulta
            {"0102"},;                   // ordem campos chaves
            {"PWTABELA",drvpw,drvpw},;   // nome do DBF
            {"PWTABEL1"},;               // nomes dos NTX
            {},;                         // nome dos dbf's relacionados
            {"PWGRUPOS->pw_grupo"},;     // campos de relacionamento
            {1,1,4,12,12,65,3,5},;       // num telas/tela atual/coordenadas/inicio scroll/qtde scroll
            {3,.t.,.f.},;                // nivel acesso/tp chave/pede dir
            {},;                         // campos do arquivo
            {},;// fromula { mascara, titulo, formula, linha, coluna }
            {"",""},;      // condicao de exclusao de registros
            {"",""},;      // condicao de alteracao de registros
            {"",""};       // condicao de recuperacao de registros
           }

AADD(sistema[nss-1,O_CAMPO],{;           // PWTABELA
     /* mascara       */    "9999",;
     /* titulo        */    "C¢digo",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[nss-1,O_CAMPO],{;           // PWTABELA
     /* mascara       */    "@S27",;
     /* titulo        */    "Arquivo",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(_dbf)~Necess rio informar ARQUIVO",;
     /* help do campo */    "";
                         };
)
AADD(sistema[nss-1,O_CAMPO],{;           // PWTABELA
     /* mascara       */    "@!",;
     /* titulo        */    "Permis”es",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    "DIGITE INICIAIS DAS ROTINAS CERCEADAS AO USURIO|"+;
                            "P. Procura    F. Filtragem    D. Digita‡„o     ÿ|"+;
                            "M. Modifica   E. Exclui       R. Recupera      ÿ|"+;
                            "V. Vˆ global  N. Nova coluna  A. Apaga coluna  ÿ|"+;
                            "I. Imprime    O. Ordena       Q. Quantifica    ÿ|"+;
                            "L. Localiza   G. Global       C. Congela Colunas|"+;
                            "T. Tamanho    J. nova Janela ÿX. eXporta       ÿ|"+;
                            "Z. totaliZa   B. marca linha                   ÿ|";
                         };
)
AADD(sistema[nss-1,O_CAMPO],{;           // PWTABELA
     /* mascara       */    "!",;
     /* titulo        */    "Flag",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)

sistema[nss]={;
            "Usu rios",;                               // opcao do menu
            "Usu rios",;                               // titulo do sistema
            {"pw_grupo+pw_codigo","pw_nome+pw_pass"},; // chaves do arquivo
            {"Por Grupo","Nome+pass"},;                // titulo dos indices para consulta
            {"0102","0306"},;                          // ordem campos chaves
            {"PWUSUA",drvpw,drvpw},;                   // nome do DBF
            {"PWUSUA1","PWUSUA2"},;                    // nomes dos NTX
            {},;                                       // nome dos dbf's relacionados
            {"PWGRUPOS->pw_grupo"},;                   // campos de relacionamento
            {1,1,13,12,23,65,3,7},;                    // num telas/tela atual/coordenadas/inicio scroll/qtde scroll
            {3,.f.,.f.},;                              // nivel acesso/tp chave/pede dir
            {},;                                       // campos do arquivo
            {},;// fromula { mascara, titulo, formula, linha, coluna }
            {"",""},;      // condicao de exclusao de registros
            {"",""},;      // condicao de alteracao de registros
            {"",""};       // condicao de recuperacao de registros
           }

AADD(sistema[nss,O_CAMPO],{;            // PWUSUA
     /* mascara       */    "9999",;
     /* titulo        */    "C¢digo",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[nss,O_CAMPO],{;            // PWUSUA
     /* mascara       */    "9999",;
     /* titulo        */    "C¢digo",;
     /* cmd especial  */    "",;
     /* default       */    "1",;
     /* pre-validacao */    "",;
     /* validacao     */    "V",;
     /* help do campo */    "";
                         };
)
AADD(sistema[nss,O_CAMPO],{;            // PWUSUA
     /* mascara       */    "@!",;
     /* titulo        */    "Nome",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(_nome)~Necess rio informar NOME",;
     /* help do campo */    "";
                         };
)
AADD(sistema[nss,O_CAMPO],{;            // PWUSUA
     /* mascara       */    "9",;
     /* titulo        */    "Nivel",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "MTAB([1. Opera‡„o|2. Manuten‡„o|3. Gerˆncia],[N¡VEL DE ACESSO])",;
     /* validacao     */    "VAL(_nivel)>0~NIVEL n„o aceit vel",;
     /* help do campo */    "";
                         };
)
AADD(sistema[nss,O_CAMPO],{;            // PWUSUA
     /* mascara       */    "",;
     /* titulo        */    "Obs",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    "";
                         };
)
AADD(sistema[nss,O_CAMPO],{;            // PWUSUA
     /* mascara       */    "",;
     /* titulo        */    "PW",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[nss,O_CAMPO],{;            // PWUSUA
     /* mascara       */    "!",;
     /* titulo        */    "Flag",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)

* \\ Final de ADR_ATR2.PRG
procedure adm_r023
/*
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
 \ Empresa.: PresServ Inform tica-Limeira (019)452.6623
 \ Programa: ADM_R023.PRG
 \ Data....: 27-06-97
 \ Sistema.: Administradora - RECEP€„O
 \ Funcao..: Outros recibos (2¦Via)
 \ Analista: Ademilson Pedro Bom
 \ Criacao.: GAS-Pro v3.0 
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/

#include "adrbig.ch"    // inicializa constantes manifestas

LOCAL dele_atu, getlist:={}, so_um_reg, sit_dbf:=POINTER_DBF()
PARA  lin_menu, col_menu, imp_reg, OBS2PRINT
PRIV  tem_borda:=.t., op_menu:=VAR_COMPL, l_s:=10, c_s:=20, l_i:=14, c_i:=61, tela_fundo:=SAVESCREEN(0,0,MAXROW(),79)
nucop=1
IF PCOU()<3
 OBS2PRINT=[]
ENDI
so_um_reg=(PCOU()>2)
IF !so_um_reg                             // vai receber a variaveis?
 IF nivelop < 2                                    // se usuario nao tem
  DBOX("Emiss„o negada, "+usuario,20)              // permissao, avisa
  RETU                                             // e retorna
 ENDI
 SETCOLOR(drvtittel)
 vr_memo=NOVAPOSI(@l_s,@c_s,@l_i,@c_i)    // pega posicao atual da tela
 CAIXA(mold,l_s,c_s,l_i,c_i)              // monta caixa da tela
 @ l_s,c_s+11 SAY " OUTROS RECEBIMENTOS "
 SETCOLOR(drvcortel)
 @ l_s+02,c_s+1 SAY " Numero..:"
 @ l_s+03,c_s+1 SAY " Confirme:"
ENDI
rnumero=SPAC(8)                                    // Numero
confirme=SPAC(1)                                   // Confirme
DO WHILE .t.
 rola_t=.f.
 cod_sos=56
 IF !so_um_reg
  SET KEY K_ALT_F8 TO ROLATELA
  SETCOLOR(drvcortel+","+drvcorget+",,,"+corcampo)
  @ l_s+02 ,c_s+12 GET  rnumero;
		   PICT "@R 99-999999";
		   VALI CRIT("PTAB(rnumero,'OBXEC',1)~Necess rio informar NUMERO|Tecle F8 para buscar em tabela")
                   DEFAULT "IIF(PTAB(UPPER(RIGHT(M->ide_maq,4))+[OBX],[IMPPAR],1),SUBSTR(IMPPAR->docto,3,6),[ ])"
                   AJUDA "N£mero do Recibo a emitir"
		   CMDF8 "VDBF(6,4,20,77,'OBXEC',{'numero','codigo','cobranca','valorpg','emitido_'},1,'numero',[])"

  @ l_s+03 ,c_s+12 GET  confirme;
                   PICT "!";
                   VALI CRIT("confirme='S'.AND.V02301F9()~CONFIRME n„o aceit vel|Digite S para confirmar|ou|Tecle ESC para cancelar")
                   AJUDA "Digite S para confirmar|ou|tecle ESC para cancelar"

  READ
  SET KEY K_ALT_F8 TO
  IF rola_t
   ROLATELA(.f.)
   LOOP
  ENDI
  IF LASTKEY()=K_ESC                               // se quer cancelar
   RETU                                            // retorna
  ENDI
 ENDI

 #ifdef COM_REDE
  IF !USEARQ("OBXEC",.f.,10,1)                     // se falhou a abertura do arq
   RETU                                            // volta ao menu anterior
  ENDI
 #else
  USEARQ("OBXEC")                                  // abre o dbf e seus indices
 #endi

 PTAB(codigo,"GRUPOS",1,.t.)                       // abre arquivo p/ o relacionamento
 PTAB(GRUPOS->grupo,"ARQGRUP",1,.t.)
 PTAB(GRUPOS->cobrador,"COBRADOR",1,.t.)
 PTAB(GRUPOS->regiao,"REGIAO",1,.t.)
 SET RELA TO codigo INTO GRUPOS,;                  // relacionamento dos arquivos
          TO GRUPOS->grupo INTO ARQGRUP,;
          TO GRUPOS->cobrador INTO COBRADOR,;
          TO GRUPOS->regiao INTO REGIAO
 titrel:=criterio:=cpord := ""                     // inicializa variaveis
 titrel:=chv_rela:=chv_1:=chv_2 := ""
 tps:=op_x:=ccop := 1
 arq_=drvporta                                     // porta de saida configurada
 IF !so_um_reg
  IF !opcoes_rel(lin_menu,col_menu,9,11)           // nao quis configurar...
   CLOS ALL                                        // fecha arquivos e
   LOOP                                            // volta ao menu
  ENDI

 #ifdef COM_REDE

  ELSE

   tps=lin_menu

 #endi

 ENDI
 IF tps=2                                          // se vai para arquivo/video
  arq_=ARQGER()                                    // entao pega nome do arquivo
  IF EMPTY(arq_)                                   // se cancelou ou nao informou
   LOOP                                            // retorna
  ENDI
 ELSE
  arq_=drvporta                                    // porta de saida configurada
 ENDI
 IF "4WIN"$UPPER(drvmarca) // nome da configuracao/marca impressora
    arq_:=drvdbf+"WIN"+ide_maq
    tps:=3                                          // se vai para arquivo/video
 ENDIF
 SET PRINTER TO (arq_)                             // redireciona saida
 EXIT
ENDD
IF !EMPTY(drvtapg)                                 // existe configuracao de tam pag?
 op_=AT("NNN",drvtapg)                             // se o codigo que altera
 IF op_=0                                          // o tamanho da pagina
  msg="Configura‡„o do tamanho da p gina!"         // foi informado errado
  DBOX(msg,,,,,"ERRO!")                            // avisa
  CLOSE ALL                                        // fecha todos arquivos abertos
  RETU                                             // e cai fora...
 ENDI                                              // codigo para setar/resetar tam pag
 lpp_033=LEFT(drvtapg,op_-1)+"033"+SUBS(drvtapg,op_+3)
 lpp_066=LEFT(drvtapg,op_-1)+"066"+SUBS(drvtapg,op_+3)
ELSE
 lpp_033:=lpp_066 :=""                             // nao ira mudara o tamanho da pag
ENDI
DBOX("[ESC] Interrompe",15,,,NAO_APAGA)
dele_atu:=SET(_SET_DELETED,.t.)                    // os excluidos nao servem...
SET DEVI TO PRIN                                   // inicia a impressao
maxli=32                                           // maximo de linhas no relatorio
IMPCTL(lpp_033)                                    // seta pagina com 33 linhas
SET MARG TO 1                                      // ajusta a margem esquerda
IF tps=2
 IMPCTL("' '+CHR(8)")
ENDI
BEGIN SEQUENCE
 DO WHIL ccop<=nucop                               // imprime qde copias pedida
  pg_=1; cl=999
  IF so_um_reg
   GO imp_reg
  ELSE
   INI_ARQ()                                       // acha 1o. reg valido do arquivo
  ENDI
  ccop++                                           // incrementa contador de copias
  IF PTAB(PADR(SUBSTR(M->ide_maq,2),4)+[OBX],[IMPPAR],1)
   SEEK ALLTRIM(IMPPAR->docto)
  ENDI
  DO WHIL !EOF().AND.(!so_um_reg.OR.imp_reg=RECN())
   #ifdef COM_TUTOR
    IF IN_KEY()=K_ESC                              // se quer cancelar
   #else
    IF INKEY()=K_ESC                               // se quer cancelar
   #endi
    IF canc()                                      // pede confirmacao
     BREAK                                         // confirmou...
    ENDI
   ENDI
   IF (PTAB(PADR(SUBSTR(M->ide_maq,2),4)+[OBX],[IMPPAR],1).AND.numero=LEFT(IMPPAR->docto,8)) .OR. so_um_reg// se atender a condicao...
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY TRAN(numero,"@R 99-999999")  // N§ Recibo
    @ cl,050 SAY "Valor.:"
    IMPCTL(drvpenf)
    @ cl,058 SAY TRAN(valorpg,"@E 999,999.99")     // Valor
    IMPCTL(drvtenf)
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    IMPAC("Referˆnte.:",cl,000)
    IMPCTL(drvpenf)
    @ cl,014 SAY cobranca                               // Ref
    IMPCTL(drvtenf)
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY "Contrato..:"
    IMPCTL(drvpenf)
    @ cl,014 SAY GRUPOS->grupo +[  ]+codigo        // Grupo 1
    IMPCTL(drvtenf)
    @ cl,050 SAY "Data..:"
    @ cl,058 SAY TRAN(emitido_,"@D")               // data 1
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY "Nome......:"
    IMPCTL(drvpenf)
    @ cl,014 SAY GRUPOS->nome                      // Nome
    IMPCTL(drvtenf)
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    IMPAC("Endere‡o..:",cl,000)
    @ cl,014 SAY xDECRIPT(GRUPOS->endereco)                  // Endere‡o
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY "Bairro....:"
    @ cl,014 SAY xDECRIPT(GRUPOS->bairro)                    // Bairro
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY "Cid./Cobr.:"
    @ cl,014 SAY xDECRIPT(GRUPOS->cidade)+[ ] +GRUPOS->cobrador// Cidade
    @ cl,052 SAY REPL("Ä",19)
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,052 SAY "Op:"
    @ cl,056 SAY LEFT(por,1)+LOWER(SUBSTR(por,2))  // operador
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY "Valor:"
    IMPCTL(drvpcom)
    @ cl,007 SAY '('+SUBSTR(EXT(valorpg),1,AT('/',EXT(valorpg))-1)+')'// Valor Ext
    IMPCTL(drvtcom)
    REL_CAB(2)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY REPL("Ä",71)
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    IMPEXP(cl,000,LEFT(M->setup1,35),70)           // 2 Ident1
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY M->setup2                         // 2 Ident 2
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY REPL("-",71)
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY TRAN(numero,"@R 99-999999")  // 2 N§ Recibo
    @ cl,050 SAY "Valor.:"
    IMPCTL(drvpenf)
    @ cl,058 SAY TRAN(valorpg,"@E 999,999.99")     // Valor pago
    IMPCTL(drvtenf)
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    IMPAC("Referˆnte.:",cl,000)
    IMPCTL(drvpenf)
    @ cl,012 SAY cobranca                               // Ref
    IMPCTL(drvtenf)
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY "Contrato..:"
    IMPCTL(drvpenf)
    @ cl,012 SAY GRUPOS->grupo +[  ]+codigo        // Grupo
    IMPCTL(drvtenf)
    @ cl,050 SAY "Data..:"
    @ cl,058 SAY TRAN(emitido_,"@D")               // Emitido em
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY "Nome......:"
    IMPCTL(drvpenf)
    @ cl,012 SAY GRUPOS->nome                      // Nome
    IMPCTL(drvtenf)
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    IMPAC("Endere‡o..:",cl,000)
    @ cl,012 SAY xDECRIPT(GRUPOS->endereco)                  // Endere‡o
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY "Bairro....:"
    @ cl,012 SAY xDECRIPT(GRUPOS->bairro)                    // Bairro
    @ cl,052 SAY REPL("Ä",19)
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY "Cid./Cobr.:"
    @ cl,012 SAY xDECRIPT(GRUPOS->cidade)+[ ] +GRUPOS->cobrador// Cidade
    @ cl,052 SAY "Op:"
    @ cl,056 SAY LEFT(por,1)+LOWER(SUBSTR(por,2))  // Operador
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY "Valor:"
    IMPCTL(drvpcom)
    @ cl,007 SAY '('+SUBSTR(EXT(valorpg),1,AT('/',EXT(valorpg))-1)+')'// Valor Ext
    IMPCTL(drvtcom)
    REL_CAB(1)                                     // soma cl/imprime cabecalho
/*
    IF PTAB(codigo,'ALENDER',1)                    // pode imprimir?
     @ cl,007 SAY [Endere‡o alterado em ] +DTOC(ALENDER->data_)// Altera‡„o de Endere‡o
    ENDI
*/
    IF PCOUNT()=4.AND.!empt(OBS2PRINT)
     @ cl,007 SAY [OBS: ] +OBS2PRINT
    ENDI
    SKIP                                           // pega proximo registro
    cl=999                                         // forca salto de pagina
   ELSE                                            // se nao atende condicao
    SKIP                                           // pega proximo registro
   ENDI
   EXIT
  ENDD
 ENDD ccop
 EJEC                                              // salta pagina
END SEQUENCE
SET MARG TO                                        // coloca margem esquerda = 0
IMPCTL(lpp_066)                                    // seta pagina com 66 linhas
SET PRINTER TO (drvporta)                          // fecha arquivo gerado (se houver)
SET DEVI TO SCRE                                   // direciona saida p/ video
IF tps=2                                           // se vai para arquivo/video
 BROWSE_REL(arq_,2,3,MAXROW()-2,78)
ENDI                                               // mostra o arquivo gravado
GRELA(9)                                           // grava variacao do relatorio
SELE OBXEC                                         // salta pagina
SET RELA TO                                        // retira os relacionamentos
SET(_SET_DELETED,dele_atu)                         // os excluidos serao vistos
IF so_um_reg
 POINTER_DBF(sit_dbf)
ENDI
RETU

STATIC PROC REL_CAB(qt)                            // cabecalho do relatorio
IF qt>0                                            // se parametro maior que 0
 cl=cl+qt                                          // soma no contador de linhas
ENDI
IF cl>maxli .OR. qt=0                              // quebra de pagina
 IMPEXP(0,000,LEFT(M->setup1,35),70)               // Ident1
 @ 1,000 SAY M->setup2                             // Ident2
 @ 2,000 SAY REPL("-",71)
 cl=qt+2 ; pg_++
ENDI
RETU

* \\ Final de ADM_R023.PRG
€
 V02002F9¥–Ñ  V02002F9CODEC_ETEXTENDCODE	_SYMSTARTSYMSTARTSYMBOLSSYMBOLS_SYMENDSYMENDNULLBEGDATA_DATADATA_SYMPBDATA_SYMPDATA_SYMPEDATA_CONSTCONST_MSGMSG_BEGBSSBEGBSS_BSSBSS_ENDBSSENDBSSDGROUPd˜ @"ø˜ H  ˜ h  ë˜ `@	®˜ h  
ã˜ h  ß˜ H  û˜ H  ÷˜ H ë˜ H  ï˜ H  ë˜ (  ˜ H  GAS-Pro v3.0
011021014062001001019001012000176001
 Processo:
 Confirme:
[Ÿ]
[Ÿ]
 2 
 0 
Impress„o Aux.Funeral
Impress„o Aux.Funeral







056







 0 
 0 
-1 
-1 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
rproc
C
E
@R 99999/9999-99
 11 
 13 
 1 
 12 
 0 
Processo

!EMPT(RPROC).AND.PTAB(rproc,[AFUNER],1)
Campo utilizado para localiza‡„o dos documentos.|Tecle F8 para busca em tabela
IIF(PTAB(PADR(SUBSTR(M->ide_maq,2),4)+[AFU],[IMPPAR],1),ALLTRIM(IMPPAR->docto),[])
Digite neste campo o n£mero de|identifica‡„o do processo
VDBF(6,12,20,77,'AFUNER',{'processo','proc2','categ','contrato','falecido'},1,'V02001F9()',[])
 0 
 0 


confirme
C
E
!
 1 
 1 
 2 
 12 
 0 
Confirme

confirme='S'.AND.V02002F9()
CONFIRME n„o aceit vel|Digite S para confirmar|ou|Tecle ESC para cancelar

Digite S para confirmar|ou|tecle ESC para cancelar

 0 
 0 


 0 
 0 
 0 
 0 
 0 
€
 TAX_02F9A–Ñ  TAX_02F9CODEC_ETEXTENDCODE	_SYMSTARTSYMSTARTSYMBOLSSYMBOLS_SYMENDSYMENDNULLBEGDATA_DATADATA_SYMPBDATA_SYMPDATA_SYMPEDATA_CONSTCONST_MSGMSG_BEGBSSBEGBSS_BSSBSS_ENDBSSENDBSSDGROUP ˜ @ê 1˜ H  ˜ h  ë˜ `@ 	¯˜ h  
ã˜ h  ß˜ H  û˜ H  ÷˜ H ë˜ H  ï˜ H  ë˜ (  ˜ H  €
 V02001F9¦–Ñ  V02001F9CODEC_ETEXTENDCODE	_SYMSTARTSYMSTARTSYMBOLSSYMBOLS_SYMENDSYMENDNULLBEGDATA_DATADATA_SYMPBDATA_SYMPDATA_SYMPEDATA_CONSTCONST_MSGMSG_BEGBSSBEGBSS_BSSBSS_ENDBSSENDBSSDGROUPe˜ @< ß˜ H  ˜ h  ë˜ `p 	˜ h  
ã˜ h  ß˜ H  û˜ H  ÷˜ H ë˜ H  ï˜ H  ë˜ (  ˜ H  
#!/usr/local/bin/php
<?

//cria banco de dados CREDENC.DBF
if (!file_exists("smb/dados/CREDENC.DBF"))
{
  $dbf_name="smb/dados/CREDENC.DBF";
  $def = array(array("ai"        ,"C",  5),; //
	       array("codbenefic","C", 10),; //
	       array("oldescrito","C",  5),; //
	       array("oldclasse" ,"C",  3),; //
	       array("prioridade","C",  2),; //
	       array("status"    ,"C",  2),; // !!
	       array("oldespec"  ,"C", 50),; // @!
	       array("detalhes"  ,"M", 10),; // @S35
	       array("vantagens" ,"M", 10),; // @S35
	       array("condicoes" ,"M", 10),; // @S35
	       array("informutil","M", 10),; // @S35
	       array("nome"      ,"C", 50),; //
	       array("endereco"  ,"C", 50),; //
	       array("bairro"    ,"C", 30),; // @!
	       array("cidade"    ,"C", 30),; // @!
	       array("uf"        ,"C",  2),; // !!
	       array("cep"       ,"C",  8),; // @R 99999-999
	       array("contato"   ,"C", 50),; // @!
	       array("fonecom1"  ,"C", 15),; //
	       array("fonecom2"  ,"C", 15),; // @!
	       array("fonecel"   ,"C", 15),; // @!
	       array("foneres1"  ,"C", 15),; // @!
	       array("email"     ,"C", 50),; // @!
	       array("fax"       ,"C", 15),; // @!
	       array("bip"       ,"C", 15),; // @!
	       array("fonesdiv"  ,"C", 30),; // @!
	       array("datainc"   ,"D",  8),; // @D
	       array("dataalt"   ,"D",  8),; // @D
	       array("codcidade" ,"C",  4),; //
	       array("contrato"  ,"C", 10),; //
	       array("flagetq"   ,"C", 10),; //
	       array("codclasse" ,"C",  6) //
	       );
  dbase_create($dbf_name, $def);
}

include("config.inc");

$conexao = "iv";
$connect = mysql_connect($ip,$login,$senha) or die ("Erro ao abrir conexao");
mysql_select_db($conexao,$connect) or die("Erro ao selecionar base");

// alimenta base CREDENC.DBF para sistema VIP4.

$dbf_name = "smb/dados/credenc.DBF";
$con_dbf2 = dbase_open($dbf_name,2) or die("Erro ao abrir base DBF: $dbf_name");

$consulta = "SELECT * FROM credenciado;
$executa = mysql_query($consulta,$connect);

while ($resultado = mysql_fetch_array($executa))
{
    $def = array($resultado[codassoc],$resultado[parc],$resultado[data],$resultado[valorpg],$resultado[cx_num],$resultado[login]);
  $def = array($resultado[ai],
	       $resultado[codbenefic],
	       $resultado[oldescrito],
	       $resultado[oldclasse],
	       $resultado[prioridade],
	       $resultado[status],
	       $resultado[oldespec],
	       $resultado[detalhes],
	       $resultado[vantagens],
	       $resultado[condicoes],
	       $resultado[informutil],
	       $resultado[nome],
	       $resultado[endereco],
	       $resultado[bairro],
	       $resultado[cidade],
	       $resultado[uf],
	       $resultado[cep],
	       $resultado[contato],
	       $resultado[fonecom1],
	       $resultado[fonecom2],
	       $resultado[fonecel],
	       $resultado[foneres1],
	       $resultado[email],
	       $resultado[fax],
	       $resultado[bip],
	       $resultado[fonesdiv],
	       $resultado[datainc],
	       $resultado[dataalt],
	       $resultado[codcidade],
	       $resultado[contrato],
	       $resultado[flagetq],
	       $resultado[codclasse])

    dbase_add_record($con_dbf2,$def);
}
dbase_close($con_dbf2);

mysql_close($connect);
?>
€
 V01801F9Ÿ–Ñ  V01801F9CODEC_ETEXTENDCODE	_SYMSTARTSYMSTARTSYMBOLSSYMBOLS_SYMENDSYMENDNULLBEGDATA_DATADATA_SYMPBDATA_SYMPDATA_SYMPEDATA_CONSTCONST_MSGMSG_BEGBSSBEGBSS_BSSBSS_ENDBSSENDBSSDGROUP^˜ @
˜ H  ˜ h  ë˜ ` 	î˜ h  
ã˜ h  ß˜ H  û˜ H  ÷˜ H ë˜ H  ï˜ H  ë˜ (  ˜ H  procedure cseguro
/*
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
 \ Empresa.: PresServ Inform tica-Limeira (019)452.6623
 \ Programa: CSEGURO.PRG
 \ Data....: 08-08-97
 \ Sistema.: Administradora - PLANO
 \ Funcao..: Seguros Ativos
 \ Analista: Ademilson Pedro Bom
 \ Criacao.: GAS-Pro v3.0 
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/
#include "adpbig.ch"    // inicializa constantes manifestas

LOCAL t_, i_, col_cp, col_ti
PRIV  prefixo_dbf:="CSE", op_sis:=EVAL(qualsis,"GRSEGUR")
                                                   // arquivo a consultar
op_menu=PROJECOES                                  // flag consulta e faz projecoes
SELE 0

#ifdef COM_REDE
 IF !USEARQ("GRSEGUR",.t.,10,1)                    // se falhou a abertura do arq
  RETU                                             // volta ao menu anterior
 ENDI
#else
 USEARQ("GRSEGUR")                                 // abre o dbf e seus indices
#endi

PTAB(codigoseg+nrseguro,"SINSCRIT",2,.t.)          // abre arquivo p/ o relacionamento
PTAB(tipo,"TSEGURO",1,.t.)
SET RELA TO codigoseg+nrseguro INTO SINSCRIT,;     // relacionamento dos arquivos
         TO tipo INTO TSEGURO
col_cp={;                                          // conteudo das colunas
          "nrseguro",;
          "apolice",;
          "tipo",;
          "contrato",;
          "aberseg_",;
          "TRAN((YEAR(DATE())-YEAR(aberseg_))*12+MONTH(DATE())-MONTH(aberseg_)+1,[99])",;
          "vencseg_",;
          "tcarencia",;
          "renovar",;
          "ulttipo",;
          "circ",;
          "emissao_",;
          "parcemit",;
          "codigoseg",;
          "TRAN(SINSCRIT->inscseg,[])",;
          "TRAN(SINSCRIT->documento,[@!])",;
          "TRAN(TSEGURO->cobertura,[99999999.99])",;
          "TRAN(TSEGURO->custmesemp,[999999.99])",;
          "TRAN(TSEGURO->custmescon,[999999.99])";
       }
col_ti={;                                          // titulo das colunas
          "N§Seguro",;
          "Ap¢lice",;
          "Tipo",;
          "Contrato",;
          "Abertura",;
          "Parc.",;
          "Vencimento",;
          "T.Carˆncia",;
          "Renovar",;
          "Tipo",;
          "Circular",;
          "£lt.Emiss„o",;
          "ParcEmit",;
          "Segurado",;
          "Nome do inscrito",;
          "Documento",;
          "Cobertura",;
          "Custo Empr.",;
          "Custo Contr.";
       }
GO TOP                                             // vai p/ inicio do arquivo
cod_sos=8
EDITA(3,3,MAXROW()-2,77,.t.,col_cp,col_ti)
SELE GRSEGUR                                       // salta pagina
SET RELA TO                                        // retira os relacionamentos
CLOSE ALL                                          // fecha todos os arquivos e
RETU                                               // volta para o menu anterior

* \\ Final de CSEGURO.PRG
.PRG.OBJ:
     CLIPPER $** /m
ADRBIG.OBJ   : ADRBIG.PRG
CAD_04F9.OBJ : CAD_04F9.PRG
BXR_02F9.OBJ : BXR_02F9.PRG
BXR_01F9.OBJ : BXR_01F9.PRG
BXREC.OBJ    : BXREC.PRG
ALE_01F9.OBJ : ALE_01F9.PRG
ALENDER.OBJ  : ALENDER.PRG
OBX_02F9.OBJ : OBX_02F9.PRG
OBXEC.OBJ    : OBXEC.PRG
GRU_01F9.OBJ : GRU_01F9.PRG
GRU_02F9.OBJ : GRU_02F9.PRG
GRUPOS.OBJ   : GRUPOS.PRG
CTAINSC.OBJ  : CTAINSC.PRG
CTXAS.OBJ    : CTXAS.PRG
TAX_02F9.OBJ : TAX_02F9.PRG
INS_01F9.OBJ : INS_01F9.PRG
INS_02F9.OBJ : INS_02F9.PRG
GUI_07F9.OBJ : GUI_07F9.PRG
GUI_06F9.OBJ : GUI_06F9.PRG
GUI_08F9.OBJ : GUI_08F9.PRG
GUI_02F9.OBJ : GUI_02F9.PRG
GUIAS.OBJ    : GUIAS.PRG
KINSCF9.OBJ  : KINSCF9.PRG
AFUNER.OBJ   : AFUNER.PRG
R02001F9.OBJ : R02001F9.PRG
R02002F9.OBJ : R02002F9.PRG
ADM_R020.OBJ : ADM_R020.PRG
V02001F9.OBJ : V02001F9.PRG
V02002F9.OBJ : V02002F9.PRG
R02901F9.OBJ : R02901F9.PRG
ADR_R029.OBJ : ADR_R029.PRG
RX2001F9.OBJ : RX2001F9.PRG
RX2002F9.OBJ : RX2002F9.PRG
ADM_RX20.OBJ : ADM_RX20.PRG
RX2901F9.OBJ : RX2901F9.PRG
ADR_RX29.OBJ : ADR_RX29.PRG
ADM_R029.OBJ : ADM_R029.PRG
ADM_R026.OBJ : ADM_R026.PRG
ADM_R021.OBJ : ADM_R021.PRG
DCI_P001.OBJ : DCI_P001.PRG
DCI01F9.OBJ  : DCI01F9.PRG
DCI03F9.OBJ  : DCI03F9.PRG
DCI04F9.OBJ  : DCI04F9.PRG
ADM_RS18.OBJ : ADM_RS18.PRG
V01801F9.OBJ : V01801F9.PRG
ADM_R022.OBJ : ADM_R022.PRG
ADM_R023.OBJ : ADM_R023.PRG
V02301F9.OBJ : V02301F9.PRG
CON_R001.OBJ : CON_R001.PRG
V00101F9.OBJ : V00101F9.PRG
R03001F9.OBJ : R03001F9.PRG
ADM_R039.OBJ : ADM_R039.PRG
ADM_R050.OBJ : ADM_R050.PRG
ADP_RX44.OBJ : ADP_RX44.PRG
V03301F9.OBJ : V03301F9.PRG
TX2VIA.OBJ   : TX2VIA.PRG
ADC_R066.OBJ : ADC_R066.PRG
ADR_R067.OBJ : ADR_R067.PRG
ADR_RS69.OBJ : ADR_RS69.PRG
ADR_P001.OBJ : ADR_P001.PRG
ADR_P006.OBJ : ADR_P006.PRG
IMP_01F9.OBJ : IMP_01F9.PRG
IMPPAR.OBJ   : IMPPAR.PRG
MEDICOS.OBJ  : MEDICOS.PRG
TESPEC.OBJ   : TESPEC.PRG
JUROS.OBJ    : JUROS.PRG
TFILIAIS.OBJ : TFILIAIS.PRG
ARQGRUP.OBJ  : ARQGRUP.PRG
TXPROC.OBJ   : TXPROC.PRG
REGIAO.OBJ   : REGIAO.PRG
COB_01F9.OBJ : COB_01F9.PRG
COBRADOR.OBJ : COBRADOR.PRG
CLASSES.OBJ  : CLASSES.PRG
CIRCULAR.OBJ : CIRCULAR.PRG
PRCESSOS.OBJ : PRCESSOS.PRG
FNCS.OBJ     : FNCS.PRG
HISTORIC.OBJ : HISTORIC.PRG
CSTSEG.OBJ   : CSTSEG.PRG
MENSAG.OBJ   : MENSAG.PRG
R08701F9.OBJ : R08701F9.PRG
R08703F9.OBJ : R08703F9.PRG
R08702F9.OBJ : R08702F9.PRG
ADM_RP38.OBJ : ADM_RP38.PRG
V87001F9.OBJ : V87001F9.PRG
ADM_RP33.OBJ : ADM_RP33.PRG
ADP_RP44.OBJ : ADP_RP44.PRG
ADP_R044.OBJ : ADP_R044.PRG
V03001F9.OBJ : V03001F9.PRG
ADM_RV33.OBJ : ADM_RV33.PRG
R06601F9.OBJ : R06601F9.PRG
ADP_R066.OBJ : ADP_R066.PRG
ORDPGRC.OBJ  : ORDPGRC.PRG
PAR_ADM.OBJ  : PAR_ADM.PRG
ADR_ESTR.OBJ : ADR_ESTR.PRG
ADR_ATRI.OBJ : ADR_ATRI.PRG
ADR_ATR1.OBJ : ADR_ATR1.PRG
ADR_ATR2.OBJ : ADR_ATR2.PRG
ABOUT.OBJ    : ABOUT.PRG
ADR_PROC.OBJ : ADR_PROC.PRG
ADR_FUNC.OBJ : ADR_FUNC.PRG
ADR_OUTR.OBJ : ADR_OUTR.PRG
ADRBIG.EXE:
     bLINKer @ADRBIG.LNK
GAS-Pro v4.0
004012024063001009043001013001176001
 Numero:
 Contrato:
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ
                                      ³Circulares
                                      ³ Ini
                            Reg.:     ³  £lt
                                      ³
 Admiss„o:            Sai Taxa:       ³
 Funerais:            Cobrador:       ³
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ




ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 Ref.:                       Vl.Pago:
 Pago com..:             Troco:

  emitida em             por
[Ÿ]
Inclus„o~~26006
Manuten‡„o~~27007
Consulta~~28008
[Ÿ]
 10 
 3 
N£mero

 1 
[Ÿ]
Caixa

 8 
 1 
[Ÿ]
Contrato

 2 
[Ÿ]
Recebimentos
Recebimentos

nivelop>1
Permitido apenas a usu rios cadastrados|com n¡vel de Manuten‡„o ou Maior
nivelop=3
Para alterar este documento|chame o gerente de sistema
nivelop>1
Permitido apenas a usu rios cadastrados|com n¡vel de Manuten‡„o ou Maior
005


nivelop>1
Permitido apenas a usu rios cadastrados|com n¡vel de Manuten‡„o ou Maior
































 0 
 1 
-1 
-1 
 0 
-1 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
numero
C
V
99999999
 8 
 8 
 1 
 12 
 0 
Numero



RIGHT(DTOC(DATE()),2)+[000001]


 0 
 1 


codigo
C
E
@!
 9 
 9 
 2 
 12 
 0 
Codigo

(PTAB(ALLTRIM(codigo),[GRUPOS]).AND.BXR_07F9()).AND.(PTAB(codigo,'TAXAS',1).OR.1=1).AND.CAD_04F9(op_menu)
Contrato inv lido |ou inexistente

Informe o n£mero do contrato
VDBF(6,3,20,77,'GRUPOS',{'codigo','grupo','nome','endereco'},1,'codigo',[])
 0 
 0 


cobranca
C
E
@!
 18 
 18 
 16 
 8 
 0 
Cobranca
BXR_06F9()
PTAB(cobranca,[TAXAS],1).or.!EMPT(cobranca)
Necess rio informar COBRANCA


BXR_06F9()
 0 
 0 


valorpg
N
E
@E 999,999.99
 9 
 10 
 16 
 39 
 2 
Valor pago
!EMPT(cobranca)
valorpg>0.and.!EMPT(BXR_02F9())
VALOR PAGO n„o aceit vel|Digite o valor recebido
BXR_02F9() // Atualiza pr¢x.impress„o
Informe o valor pago ou zeros se for retorno.
BXR_02F9()
 0 
 0 


valoraux
N
E
@E 999,999.99
 9 
 10 
 17 
 14 
 2 
Pago com...

valoraux>=valorpg
VALOR INSUFICIENTE para quitar o d‚bito|A T E N € Ç O

Informe o valor pago

 0 
 0 


emitido_
D
V
@D
 8 
 10 
 19 
 14 
 0 
Emitido em






 0 
 0 


por
C
V
 
 10 
 10 
 19 
 30 
 0 
Por






 0 
 0 


numop
C
V
999999
 6 
 6 
 19 
 44 
 0 
N§ O.P.






 0 
 0 


grupo
C
I
!9
 2 
 2 
 0 
 0 
 0 
Grupo






 0 
 0 


filial
C
I
@!
 2 
 2 
 0 
 0 
 0 
Filial






 0 
 0 


 16 
Nome
GRUPOS->nome

 4 
 2 
 35 

Circ 1 - 4
BXR_01F9()

 11 
 2 
 48 

Ult.Circular
GRUPOS->ultcirc
999
 6 
 47 
 3 

Situa‡„o
IIF(GRUPOS->situacao='2',[CANCELADO],[         ])+[ - Grupo ]+GRUPOS->grupo

 2 
 23 
 22 

Admiss„o
GRUPOS->admissao
@D
 8 
 12 
 10 

Saitxa
GRUPOS->saitxa
@R 99/99
 8 
 33 
 5 

Cobrador
GRUPOS->cobrador
!!
 9 
 33 
 2 

Funerais
GRUPOS->funerais
99
 9 
 12 
 2 

Circ.Inicial
GRUPOS->circinic
999
 5 
 46 
 3 

Endere‡o
GRUPOS->endereco

 5 
 2 
 35 

Bairro
GRUPOS->bairro

 6 
 2 
 25 

Cidade
GRUPOS->cidade

 7 
 2 
 25 

CEP
GRUPOS->cep
@R 99999-999
 7 
 29 
 9 

Regi„o
GRUPOS->regiao
999
 6 
 35 
 3 

troco
valoraux-valorpg
@E 999,999.99
 17 
 33 
 11 

Filial
filial
@!
 1 
 23 
 2 

 14 
BXREC
numop
ORDPGRC->numop
ORDPGRC->numop
EMPT(numop)


ORDPGRC
nrdoctos
ORDPGRC->nrdoctos + 1
ORDPGRC->nrdoctos - 1
PTAB(numop,'ORDPGRC',1)


TAXAS
pgto_
DATE()
CTOD('')
!EMPT(valorpg)


TAXAS
forma
[P]
[ ]
!EMPT(valorpg)


TAXAS
baixa_
DATE()
CTOD('  /  /  ')
!EMPT(valorpg)


TAXAS
por
M->usuario

!EMPT(valorpg)


TAXAS
stat
[6]
[ ]
!EMPT(valorpg)


TAXAS
valorpg
valorpg
0
!EMPT(valorpg)


BXREC
emitido_
DATE()




BXREC
por
M->usuario




BXREC
filial
M->p_filial




ORDPGRC
valortotal
ORDPGRC->valortotal+valorpg
ORDPGRC->valortotal-valorpg
EMPT(numop).AND.PTAB(IIF(EMPT(M->usuario),PADR(M->contarec+ide_maq,10,' '),PADR(M->usuario,10,' '))+M->histrcfcc+[       ],'ORDPGRC',2)


ORDPGRC
valortotal
ORDPGRC->valortotal +valorpg
ORDPGRC->valortotal -valorpg
!EMPT(numop).AND.PTAB(numop,'ORDPGRC',1)


IMPPAR
docto
numero

PTAB(PADR(SUBSTR(M->ide_maq,2),4)+[BXR],[IMPPAR],1)


 0 
 2 
ORDPGRC
1
 17 
!EMPT(valorpg).AND. !PTAB(IIF(EMPT(M->usuario),PADR(M->contarec+ide_maq,10,' '),PADR(M->usuario,10,' '))+M->histrcfcc+[       ],'ORDPGRC',2)
1=3
 0 



numop
C



origem
C
[ADM]


lancto_
D
DATE()


por
C
M->usuario


numconta
C
IIF(EMPT(M->usuario),PADR(M->contarec+ide_maq,10,' '),PADR(M->usuario,10,' '))


historico
C
M->histrcfcc


debcred
C
[C]


valortotal
N
0


vencto_
D
DATE()


documento
C
[FCC/Taxas]


nrdoctos
N



complement
C
[FCC/Taxas pagas na Recep‡„o]


fechto_
D



fechpor
C



autoriz_
D



autorpor
C



numos
C



IMPPAR
1
 3 
!PTAB(PADR(SUBSTR(M->ide_maq,2),4)+[BXR],[IMPPAR],1)
1=3
 0 



idmaq
C
PADR(SUBSTR(M->ide_maq,2),4)


base
C
[BXR]


docto
C



 1 
ADM_RS18
 0 
Taxas (Recep‡„o)



call memoconv assoc asssmt
call memoconv inscrit inssmt
call memoconv c:\vip4\arquivos\grupos grusmt
call processa
call final
cd \teste
arj a arqsv5 arquivos\grupos.* arquivos\inscrits.* arquivos\taxas.* -r
arj a arqsv5X indices\grupo*.* indices\inscri*.* indices\taxa*.* -r
procedure con_r001
/*
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
 \ Empresa.: Ind£stria de Urnas Bignotto Ltda
 \ Programa: CON_R001.PRG
 \ Data....: 15-05-97
 \ Sistema.: Controle de Convˆnios
 \ Funcao..: Emiss„o Guias 1¦ Parte
 \ Analista: Ademilson Pedro Bom
 \ Criacao.: GAS-Pro v3.0
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/

#include "adrbig.ch"    // inicializa constantes manifestas

LOCAL dele_atu, getlist:={}, so_um_reg, sit_dbf:=POINTER_DBF()
PARA  lin_menu, col_menu, imp_reg
PRIV  tem_borda:=.t., op_menu:=VAR_COMPL, l_s:=11, c_s:=20, l_i:=14, c_i:=61, tela_fundo:=SAVESCREEN(0,0,MAXROW(),79)
nucop=1
so_um_reg=(PCOU()>2)
IF !so_um_reg                             // vai receber a variaveis?
 SETCOLOR(drvtittel)
 vr_memo=NOVAPOSI(@l_s,@c_s,@l_i,@c_i)    // pega posicao atual da tela
 CAIXA(mold,l_s,c_s,l_i,c_i)              // monta caixa da tela
 @ l_s,c_s+12 SAY " EMISSŽO DE GUIAS "
 SETCOLOR(drvcortel)
 @ l_s+01,c_s+1 SAY " N£mero:"
ENDI
gnumero=SPAC(7)                                    // N£mero
DO WHILE .t.
 rola_t=.f.
 cod_sos=56
 IF !so_um_reg
  SET KEY K_ALT_F8 TO ROLATELA
  SETCOLOR(drvcortel+","+drvcorget+",,,"+corcampo)
  @ l_s+01 ,c_s+10 GET  gnumero;
                   PICT "@R 99-99999";
                   VALI CRIT("PTAB(gnumero,'GUIAS',1).AND.V00101F9()~N£MERO n„o existe na tabela")
                   AJUDA "Emitir a guia de n£mero?"
                   CMDF8 "VDBF(6,8,20,77,'GUIAS',{'numero','contrato','nome'},1,'R001gf9()')"
                   MOSTRA {"LEFT(TRAN(GUIAS->nome,[@!]),35)", 2 , 5 }

  READ
  SET KEY K_ALT_F8 TO
  IF rola_t
   ROLATELA(.f.)
   LOOP
  ENDI
  IF LASTKEY()=K_ESC                               // se quer cancelar
   RETU                                            // retorna
  ENDI
 ENDI

 #ifdef COM_REDE
  IF !USEARQ("GUIAS",.f.,10,1)                     // se falhou a abertura do arq
   RETU                                            // volta ao menu anterior
  ENDI
 #else
  USEARQ("GUIAS")                                  // abre o dbf e seus indices
 #endi

 PTAB(medico,"MEDICOS",1,.t.)                      // abre arquivo p/ o relacionamento
 PTAB(contrato,"GRUPOS",1,.t.)                      // abre arquivo p/ o relacionamento
 PTAB(GRUPOS->tipcont,"CLASSES",1,.t.)                      // abre arquivo p/ o relacionamento
 SET RELA TO medico INTO MEDICOS                 // relacionamento dos arquivos

 titrel:=criterio:=cpord := ""                     // inicializa variaveis
 titrel:=chv_rela:=chv_1:=chv_2 := ""
 tps:=op_x:=ccop := 1
 arq_=drvporta                                     // porta de saida configurada
 IF !so_um_reg
  IF !opcoes_rel(lin_menu,col_menu,7,11)           // nao quis configurar...
   CLOS ALL                                        // fecha arquivos e
   LOOP                                            // volta ao menu
  ENDI

 #ifdef COM_REDE

  ELSE

   tps=lin_menu

 #endi

 ENDI
 IF tps=2                                          // se vai para arquivo/video
  arq_=ARQGER()                                    // entao pega nome do arquivo
  IF EMPTY(arq_)                                   // se cancelou ou nao informou
   LOOP                                            // retorna
  ENDI
 ELSE
  arq_=drvporta                                    // porta de saida configurada
 ENDI
 SET PRINTER TO (arq_)                             // redireciona saida
 EXIT
ENDD
IF !EMPTY(drvtapg)                                 // existe configuracao de tam pag?
 op_=AT("NNN",drvtapg)                             // se o codigo que altera
 IF op_=0                                          // o tamanho da pagina
  msg="Configura‡„o do tamanho da p gina!"         // foi informado errado
  DBOX(msg,,,,,"ERRO!")                            // avisa
  CLOSE ALL                                        // fecha todos arquivos abertos
  RETU                                             // e cai fora...
 ENDI                                              // codigo para setar/resetar tam pag
 lpp_024=LEFT(drvtapg,op_-1)+"033"+SUBS(drvtapg,op_+3)
 lpp_066=LEFT(drvtapg,op_-1)+"066"+SUBS(drvtapg,op_+3)
ELSE
 lpp_024:=lpp_066 :=""                             // nao ira mudara o tamanho da pag
ENDI
DBOX("[ESC] Interrompe",15,,,NAO_APAGA)
dele_atu:=SET(_SET_DELETED,.t.)                    // os excluidos nao servem...
SET DEVI TO PRIN                                   // inicia a impressao
maxli=17                                           // maximo de linhas no relatorio
IMPCTL(lpp_024)                                    // seta pagina com 24 linhas
SET MARG TO 1                                      // ajusta a margem esquerda
IF tps=2
 IMPCTL("' '+CHR(8)")
ENDI
BEGIN SEQUENCE
 DO WHIL ccop<=nucop				// imprime qde copias pedida
  pg_=1; cl=999
  IF so_um_reg
   GO imp_reg
  ELSE
   INI_ARQ()                                       // acha 1o. reg valido do arquivo
   IF PTAB(PADR(SUBSTR(M->ide_maq,2),4)+[GUI],[IMPPAR],1)
    SEEK ALLTRIM(IMPPAR->docto)
   ENDI
  ENDI
  ccop++                                           // incrementa contador de copias
  ult_imp=0                                        // ultimo reg impresso
  DO WHIL !EOF().AND.(!so_um_reg.OR.imp_reg=RECN())
   #ifdef COM_TUTOR
    IF IN_KEY()=K_ESC                              // se quer cancelar
   #else
    IF INKEY()=K_ESC                               // se quer cancelar
   #endi
    IF canc()                                      // pede confirmacao
     BREAK                                         // confirmou...
    ENDI
   ENDI
   IF (PTAB(PADR(SUBSTR(M->ide_maq,2),4)+[GUI],[IMPPAR],1).AND.ano+numero=LEFT(IMPPAR->docto,7)) .OR. so_um_reg// se atender a condicao...
    PTAB(contrato,"GRUPOS",1,.t.)                      // abre arquivo p/ o relacionamento
    PTAB(GRUPOS->tipcont,"CLASSES",1,.t.)                      // abre arquivo p/ o relacionamento

    REL_CAB(1,.t.)                                 // soma cl/imprime cabecalho
    @ cl,000 SAY "GUIA DE ENCAMINHAMENTO  N§:"
    @ cl,027 SAY ano+'-'+numero+GDV1(ano+numero)   // N£mero
    @ cl,043 SAY IIF(guiapara='C',[Consulta],IIF(guiapara='E',[Exame],IIF(guiapara='I',[Interna‡„o],[     ])))// Guia Para
    IF M->combarra=[S]
     CODBARRAS({{ano+numero+GDV1(ano+numero),4,15,60}},10,6)
    ENDI
    ult_imp=RECNO()                                // ultimo reg impresso
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY "Para:"
    @ cl,008 SAY TRAN(MEDICOS->especialid,"@!")    // Especialidade
    IF M->combarra=[S]
     CODBARRAS({{ano+numero+GDV1(ano+numero),4,15,60}},10,6)
    ENDI
    REL_CAB(2)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY "Encaminhamento a.......:"
    @ cl,025 SAY ALLTRIM(MEDICOS->nome)+[ (]+ALLTRIM(medico)+[) ]+;// M‚dico
                 [ tel: ]+ ALLTRIM(MEDICOS->telefone)
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    IMPAC("Endere‡o...............:",cl,000)
    @ cl,025 SAY MEDICOS->endereco// Endere‡o
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY "Atendimento dia........:"
    @ cl,025 SAY TRAN(emissao_,"@D")               // Emiss„o
    IMPAC("(V lido at‚ 30 dias)",cl,036)
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    IMPAC("Benefici rio principal.:",cl,000)
    @ cl,025 SAY TRAN([ (]+ALLTRIM(titular)+[ / ]+contrato+[)],"@!")+;// Titular
         [ ] +&drvpcom+ALLTRIM(CLASSES->descricao)+&drvtcom
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY "Pessoa a ser atendida..:"
    IMPCTL(drvpenf)
    @ cl,025 SAY TRAN(nome,"@!")                   // Nome
    IMPCTL(drvtenf)
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY REPL("-",60)
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY "Valor Particular:"
    @ cl,018 SAY tran(MEDICOS->valorpart,"@E 99,999,999.99")// Valor Particular
    @ cl,033 SAY "desconto de:"
    IF (MEDICOS->valorpart - valorcon)>0// pode imprimir?
     @ cl,046 SAY TRAN(MEDICOS->valorpart - valorcon,"@E 99,999,999.99")// Valor desconto
    ENDI
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY "Valor Total.....:"
    @ cl,018 SAY TRAN(valorcon+ valorexa,"@E 99,999,999.99")// Valor total
    @ cl,032 SAY LEFT([(]+LEFT(EXT(valorcon+valorexa),AT('/',EXT(valorcon+valorexa))-1)+[)],40)// Total p/Extenso
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,016 SAY SUBSTR([(]+LEFT(EXT(valorcon+valorexa),AT('/',EXT(valorcon+valorexa))-1)+[)],41,54)// Extenso (cont..)
    SKIP                                           // pega proximo registro
    cl=999                                         // forca salto de pagina
   ELSE                                            // se nao atende condicao
    SKIP                                           // pega proximo registro
   ENDI
   exit
  ENDD
  REL_RDP(.t.)                                     // imprime rodape' do relatorio
 ENDD ccop
 EJEC                                              // salta pagina
END SEQUENCE
SET MARG TO                                        // coloca margem esquerda = 0
IMPCTL(lpp_066)                                    // seta pagina com 66 linhas
SET PRINTER TO (drvporta)                          // fecha arquivo gerado (se houver)
SET DEVI TO SCRE                                   // direciona saida p/ video
IF tps=2                                           // se vai para arquivo/video
 BROWSE_REL(arq_,2,3,MAXROW()-2,78)
ENDI                                               // mostra o arquivo gravado
GRELA(7)                                           // grava variacao do relatorio
SELE GUIAS                                         // salta pagina
SET RELA TO                                        // retira os relacionamentos
SET(_SET_DELETED,dele_atu)                         // os excluidos serao vistos
IF so_um_reg
 POINTER_DBF(sit_dbf)
ENDI
RETU

STATIC PROC REL_RDP(volta_reg)                     // rodape'
LOCAL reg_atual:=RECNO()
IF volta_reg
 GO ult_imp                                        // ajusta reg p/ imp de campos no rodape'
ENDI
@ 16,000 SAY "" //chr(15)                               // comprime
IMPCTL(drvpcom)
@ 16,002 SAY [IMPORTANTE:- Esta guia tem a finalidade principal de encaminhamento em consultas e exames,]// Mensagem 1
@ 17,002 SAY [N„o dando direito a cirurgias, interna‡”es entre outros.]// Mensagem 2
@ 18,002 SAY [ - Esta guia s¢ ter  validade com o carimbo e assinatura do respons vel pela emiss„o.]// Mensagem 4
@ 19,002 SAY [ - A BOM PASTOR n„o se responsabiliza por procedimentos medicos e outros, visto ser de]
@ 20,002 SAY [   livre escolha do associado.]
@ 21,000 SAY "" //chr(18)                               // normal
IMPCTL(drvtcom)
@ 22,060 SAY [FR-OPE-0017]
@ 23,001 SAY replicate('- ',36)                    // traco
IF volta_reg
 GO reg_atual                                      // retorna reg a posicao original
ENDI
RETU

STATIC PROC REL_CAB(qt, volta_reg)                 // cabecalho do relatorio
volta_reg=IF(volta_reg=NIL,.f.,volta_reg)
IF qt>0                                            // se parametro maior que 0
 cl=cl+qt                                          // soma no contador de linhas
ENDI
IF cl>maxli .OR. qt=0                              // quebra de pagina
 IF pg_>1
  REL_RDP(volta_reg)                               // imprime rodape' do relatorio
 ENDI
 IMPCTL(drvpenf)
 IMPEXP(0,000,LEFT(M->setup1,38),76)               // Setup1
 IMPCTL(drvtenf)
// @ 1,000 SAY M->defconv                            // Defconv
 @ 2,000 SAY M->setup2                             // setup2
 @ 3,000 SAY M->setup3                             // Setup3
 @ 4,000 SAY REPL("-",60)
 cl=qt+4 ; pg_++
ENDI
RETU

* \\ Final de CON_R001.PRG
FUNC R001GF9
RETURN ano+numero
/*
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
 \ Empresa.: PresServ Inform tica-Limeira (019)452.6623.
 \ Programa: V00101F9.PRG
 \ Data....: 03-10-95
 \ Sistema.: Controle de Convˆnios
 \ Funcao..: Valida‡„o da variavel GNUMERO, relatorio CON_R001
 \ Analista: Ademilson Pedro Bom
 \ Criacao.: Programado manualmente pelo analista
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/

//#include "ADRbig.ch"    // inicializa constantes manifestas
func v00101f9
//PARAMETROS('pnumero',gnumero)

  IF !PTAB(PADR(SUBSTR(M->ide_maq,2),4)+[GUI],[IMPPAR],1)
   ord_=LEN(sistema[EVAL(qualsis,"IMPPAR"),O_CHAVE])
   FAZ_LANC("IMPPAR",[ ])
   REPL IMPPAR->idmaq WITH PADR(SUBSTR(M->ide_maq,2),4),;
	IMPPAR->base WITH [GUI]
  ENDI
   #ifdef COM_REDE
    IMPPAR->(DBUNLOCK())                           // libera o registro
   #endi

   IF PTAB(PADR(SUBSTR(M->ide_maq,2),4)+[GUI],[IMPPAR],1)
    REPBLO('IMPPAR->docto',{||gnumero})
   ENDI

RETU .T.      // <- deve retornar um valor L¢GICO

* \\ Final de V00101F9.PRG
€	 CTAINSCk–Ð  CTAINSCCODEC_ETEXTENDCODE	_SYMSTARTSYMSTARTSYMBOLSSYMBOLS_SYMENDSYMENDNULLBEGDATA_DATADATA_SYMPBDATA_SYMPDATA_SYMPEDATA_CONSTCONST_MSGMSG_BEGBSSBEGBSS_BSSBSS_ENDBSSENDBSSDGROUP*˜ @ÍL˜ H  ˜ h  ë˜ `p	~˜ h  
ã˜ h  ß˜ H  û˜ H  ÷˜ H ë˜ H  ï˜ H  ë˜ (  ˜ H  procedure dci_p001
/*
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
 \ Empresa.: PresServ Inform tica - Limeira (019)452.6623
 \ Programa: DCI_P001.PRG
 \ Data....: 04-11-03
 \ Sistema.: Administradora - RECEP€„O
 \ Funcao..: Documento … Imprimir
 \ Analista: Ademilson Pedro Bom
 \ Criacao.: GAS-Pro v4.0n
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/
#include "adrbig.ch"    // inicializa constantes manifestas

PRIV dele_atu, cur_atual, getlist:={}
PARA lin_menu, col_menu
PRIV  tem_borda:=.t., op_menu:=VAR_COMPL, l_s:=8, c_s:=12, l_i:=12, c_i:=65, tela_fundo:=SAVESCREEN(0,0,MAXROW(),79)
nucop=1
SETCOLOR(drvtittel)
vr_memo=NOVAPOSI(@l_s,@c_s,@l_i,@c_i)     // pega posicao atual da tela
CAIXA(mold,l_s,c_s,l_i,c_i)               // monta caixa da tela
@ l_s,c_s+16 SAY " DOCUMENTO A IMPRIMIR "
SETCOLOR(drvcortel)
@ l_s+01,c_s+1 SAY " Tipo..:"
@ l_s+02,c_s+1 SAY " N£mero:"
PRIV tipdoc:=SPAC(3)                               // Tipo
PRIV docto:=SPAC(12)                               // Documento
DO WHILE .t.
 rola_t=.f.
 cod_sos=56
 SET KEY K_ALT_F8 TO ROLATELA
 SETCOLOR(drvcortel+","+drvcorget+",,,"+corcampo)
 IMP_FORM({"LEFT(TRAN(DCI03F9(M->tipdoc),[]),35)", 1 , 14 })
 IMP_FORM({"LEFT(TRAN(DCI04F9(M->tipdoc),[]),50)", 3 , 2 })
 @ l_s+01 ,c_s+10 GET  tipdoc;
                  PICT "!!!";
                  WHEN "MTAB([BXR-Recebimentos|OBX-Outros recebimentos|AFU-Aux¡lio Funeral],[TIPO])"
                  DEFAULT "[BXR]"
                  AJUDA "Informe o tipo do documento a imprimir|Tecle F8 para tabela auxiliar."
                  CMDF8 "MTAB([BXR-Recebimentos|OBX-Outros recebimentos|AFU-Aux¡lio Funeral],[TIPO])"

 @ l_s+02 ,c_s+10 GET  docto;
                  WHEN "DCI01F9()"
                  DEFAULT "IIF(PTAB(PADR(SUBSTR(M->ide_maq,2),4)+tipdoc,[IMPPAR],1),IMPPAR->docto,[ ])"
                  AJUDA "Digite neste campo o n£mero de|identifica‡„o do documento|(N„o utilize barras nem tra‡os)"
                  CMDF8 "DCI01F9()"

 READ
 SET KEY K_ALT_F8 TO
 IF rola_t
  ROLATELA(.f.)
  LOOP
 ENDI
 IF LASTKEY()=K_ESC                                // se quer cancelar
  RETU                                             // retorna
 ENDI
 EXIT
ENDD
cur_atual=SETCURSOR(0)
cod_sos=1
msgp="DOCUMENTO A IMPRIMIR"
ALERTA()
op_=DBOX("Prosseguir|Cancelar opera‡„o",,,E_MENU,,msgp)
IF op_=1
 POE_GAUGE("Processando registros","AGUARDE!","Feitos:")
 dele_atu:=SET(_SET_DELETED,.t.)                   // os excluidos nao servem...

 #ifdef COM_REDE
  IF !USEARQ("CLASSES",.f.,10,1)                   // se falhou a abertura do arq
   RETU                                            // volta ao menu anterior
  ENDI
 #else
  USEARQ("CLASSES")                                // abre o dbf e seus indices
 #endi

 cpord=""
 criterio=""
 chv_rela:=chv_1:=chv_2 := ""

 #ifdef COM_REDE
  IF !USEARQ("IMPPAR",.f.,10,1)                    // se falhou a abertura do arq
   RETU                                            // volta ao menu anterior
  ENDI
 #else
  USEARQ("IMPPAR")                                 // abre o dbf e seus indices
 #endi

 SELE CLASSES                                      // processamentos apos emissao
 INI_ARQ()                                         // acha 1o. reg valido do arquivo
 DO WHIL !EOF().AND.POE_GAUGE()
  IF !PTAB(PADR(SUBSTR(M->ide_maq,2),4)+M->tipdoc,[IMPPAR],1)
   SELE IMPPAR                                     // arquivo alvo do lancamento

   #ifdef COM_REDE
    DO WHIL .t.
     APPE BLAN                                     // tenta abri-lo
     IF NETERR()                                   // nao conseguiu
      DBOX(ms_uso,20)                              // avisa e
      LOOP                                         // tenta novamente
     ENDI
     EXIT                                          // ok. registro criado
    ENDD
   #else
    APPE BLAN                                      // cria registro em branco
   #endi

   SELE CLASSES                                    // inicializa registro em branco
   REPL IMPPAR->idmaq WITH PADR(SUBSTR(M->ide_maq,2),4),;
        IMPPAR->base WITH M->tipdoc,;
        IMPPAR->docto WITH M->docto

   #ifdef COM_REDE
    IMPPAR->(DBUNLOCK())                           // libera o registro
   #endi

  ENDI

  #ifdef COM_REDE
   IF PTAB(PADR(SUBSTR(M->ide_maq,2),4)+M->tipdoc,[IMPPAR],1)
    REPBLO('IMPPAR->docto',{||M->docto})
   ENDI
  #else
   IF PTAB(PADR(SUBSTR(M->ide_maq,2),4)+M->tipdoc,[IMPPAR],1)
    REPL IMPPAR->docto WITH M->docto
   ENDI
  #endi

  SKIP                                             // pega proximo registro
 ENDD
 SET(_SET_DELETED,dele_atu)                        // os excluidos serao vistos
 ALERTA(2)
 DBOX("Processo terminado com sucesso!",,,,,msgp)
ENDI
SETCURSOR(cur_atual)
CLOSE ALL                                          // fecha todos os arquivos e
RETU                                               // volta para o menu anterior

* \\ Final de DCI_P001.PRG
procedure cobrador
/*
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
 \ Empresa.: PresServ Inform tica - Limeira (019)452.6623
 \ Programa: COBRADOR.PRG
 \ Data....: 04-11-03
 \ Sistema.: Administradora - RECEP€„O
 \ Funcao..: Gerenciador do subsistema de cobradores/vendedores
 \ Analista: Ademilson Pedro Bom
 \ Criacao.: GAS-Pro v4.0n
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/
#include "adrbig.ch"    // inicializa constantes manifestas

PARA lin_menu,col_menu
PRIV op_sis, tela_fundo:=SAVESCREEN(0,0,MAXROW(),79), l_s, c_s, l_i, c_i, l_a

op_sis=EVAL(qualsis,"COBRADOR")
IF nivelop<sistema[op_sis,O_OUTROS,O_NIVEL]        // se usuario nao tem permissao,
 ALERTA()                                          // entao, beep, beep, beep
 DBOX(msg_auto,,,3)                                // lamentamos e
 RETU                                              // retornamos ao menu
ENDI
cn:=fgrep :=.f.

#ifdef COM_LOCK
 IF LEN(pr_ok)>0                                   // se a protecao acusou
  ? pr_ok                                          // erro, avisa e
  QUIT                                             // encerra a aplicacao
 ENDI
#endi

t_fundo=SAVESCREEN(0,0,MAXROW(),79)                // salva tela do fundo
op_cad=1
DO WHIL op_cad!=0
 criterio=""
 RESTSCREEN(0,0,MAXROW(),79,t_fundo)               // restaura tela do fundo
 cod_sos=5 ; cn=.f.
 CLEA TYPEAHEAD                                    // limpa o buffer do teclado
 fgrep=.f.
 SET KEY K_F3 TO                                   // retira das teclas F3 e F4 as
 SET KEY K_F4 TO                                   // funcoes de repeticao e confirmacao
 msg="Inclus„o~1|"+;                               // menu do subsistema
     "Manuten‡„o~2|"+;
     "Consulta~3"
 op_cad=DBOX(msg,lin_menu,col_menu,E_MENU,NAO_APAGA,MAIUSC(sistema[op_sis,O_MENU]),,,op_cad)
 IF op_cad!=0                                      // se escolheu uma opcao
  Tela_fundo=SAVESCREEN(0,0,MAXROW(),79)           // salva a tela para ROLATELA()
  PARAMETROS(dbfparam)
  SELE A                                           // e abre o arquivo e seus indices

  #ifdef COM_REDE
   IF !USEARQ(sistema[op_sis,O_ARQUI,O_NOME],.f.,20,1)
                                                   // se falhou a abertura do
    RETU                                           // arquivo volta ao menu anterior
   ENDI
  #else
   USEARQ(sistema[op_sis,O_ARQUI,O_NOME])
  #endi

  SET KEY K_F9 TO veoutros                         // habilita consulta em outros arquivos
 ENDI
 DO CASE
  CASE op_cad=01                                   // inclus„o
   op_menu=INCLUSAO
   IF AT("D",exrot[op_sis])=0                      // se usuario pode fazer inclusao
    COB_INCL()                                     // neste arquivo chama prg de inclusao
   ELSE                                            // caso contrario vamos avisar que
    ALERTA()                                       // ele nao tem permissao para isto
    DBOX(msg_auto,,,3)
   ENDI

  CASE op_cad=02                                   // manuten‡„o
   op_menu=ALTERACAO
   cod_sos=7
   EDIT()

  CASE op_cad=03                                   // consulta
   op_menu=PROJECOES
   cod_sos=8
   EDITA(03,03,MAXROW()-2,77)

 ENDC
 SET KEY K_F9 TO                                   // F9 nao mais consultara outros arquivos
 CLOS ALL                                          // fecha todos arquivos abertos
ENDD
RETU

PROC COB_incl(reg_cop)  // inclusao no arquivo COBRADOR
LOCAL getlist:={}, cabem:=1, rep:=ARRAY(FCOU()), ult_reg:=RECN(),;
      ctl_r, ctl_c, ctl_w, t_f3_, t_f4_, dele_atu:=SET(_SET_DELETED,.f.)
PRIV op_menu:=INCLUSAO, tem_borda, criterio:="", cpord:=""
FOR i=1 TO FCOU()                                  // cria/declara privadas as
 msg=FIEL(i)                                       // variaveis de memoria com
 PRIV &msg.                                        // o mesmo nome dos campos
NEXT                                               // do arquivo
IF reg_cop!=NIL                                    // quer repetir todo o reg atual
 FOR i=1 TO FCOU()                                 // para cada campo,
  msg=FIEL(i)                                      // salva o conteudo
  rep[i]=&msg.                                     // para repetir
 NEXT
ELSE
 AFILL(rep,"")                                     // eche com valor vazio
ENDI
t_f3_=SETKEY(K_F3,{||rep()})                       // repeticao reg anterior
t_f4_=SETKEY(K_F4,{||conf()})                      // confirma campos com ENTER
ctl_w=SETKEY(K_CTRL_W,{||nadafaz()})               // enganando o CA-Clipper...
ctl_c=SETKEY(K_CTRL_C,{||nadafaz()})
ctl_r=SETKEY(K_CTRL_R,{||nadafaz()})
DO WHIL cabem>0
 cod_sos=6
 rola_t=.f.                                        // flag se quer rolar a tela
 SELE COBRADOR
 GO BOTT                                           // forca o
 SKIP                                              // final do arquivo
 
 /*
    cria variaveis de memoria identicas as de arquivo, para inclusao
    de registros
 */
 FOR i=1 TO FCOU()
  msg=FIEL(i)
  M->&msg.=IF((fgrep .OR. reg_cop!=NIL).AND.!EMPT(rep[1]),rep[i],&msg.)
 NEXT
 DISPBEGIN()                                       // apresenta a tela de uma vez so
 COB_TELA()
 INFOSIS(.t.)                                      // exibe informacao no rodape' da tela
 DISPEND()
 cabem=DISKSPACE(;
          IF(;
             LEN(sistema[op_sis,O_ARQUI,O_DIR_DBF])<2.OR.sistema[op_sis,O_ARQUI,O_DIR_DBF]="\",;
             0,;
             ASC(sistema[op_sis,O_ARQUI,O_DIR_DBF])-64;
          );
       )
 cabem=INT((cabem-2048)/COBRADOR->(RECSIZE()))
 IF cabem<1                                        // mais nenhum!!!
  ALERTA()
  msg="Verifique ESPA€O EM DISCO, "+usuario
  DBOX(msg,,,,,"INCLUSŽO INTERROMPIDA!")           // vamos parar por aqui!
  EXIT
 ENDI
 SELE 0                                            // torna visiveis variaveis de memoria
 SETCOLOR(drvcortel+","+drvcorget+",,,"+corcampo)
 SET KEY K_ALT_F8 TO ROLATELA
 
 /*
    recebe chaves do arquivo de indice basico
 */
 @ l_s+01 ,c_s+20 GET  cobrador;
                  PICT sistema[op_sis,O_CAMPO,01,O_MASC]
                  DEFINICAO 1

 READ
 SET KEY K_ALT_F8 TO
 IF rola_t
  ROLATELA()
  LOOP
 ENDI
 SELE COBRADOR
 IF LASTKEY()=K_ESC                                // cancelou ou chave em branco
  cabem=0                                          // prepara saida da inclusao
  LOOP                                             // volta p/ menu de cadastramento
 ENDI
 SEEK M->cobrador
 aprov_reg_=(FOUND().AND.DELE().AND.!drvvisivel)   // vai aproveitar o registro?
 IF FOUND() .AND. !aprov_reg_                      // pesquisou e achou!
  op_menu=ALTERACAO                                // seta flag de ateracao
  DISPBEGIN()
  COB_GETS()                                       // mostra conteudo do registro
  INFOSIS(.f.)                                     // exibe informacao no rodape' da tela
  DISPEND()
  ALERTA()
  msg="Consultar/alterar|Retornar … inclus„o"      // pergunta se deseja
  op_=DBOX(msg,,,E_MENU,,"REGISTRO J EXISTE")     // alterar o registro
  IF op_ =1                                        // caso afirmativo
   EDIT()                                          // deixa alterar
  ENDI
  op_menu=INCLUSAO
  LOOP                                             // volta para inclusao
 ENDI
 SELE 0
 COB_GET1(INCLUI)                                  // recebe campos
 SELE COBRADOR
 IF LASTKEY()=K_ESC                                // se cancelou
  ALERTA()                                         // avisa que o registro
  DBOX("Registro n„o inclu¡do!",18,,1)             // nao foi incluido, e volta
  LOOP
 ENDI

 #ifdef COM_REDE
  GO BOTT                                          // vamos bloquear o final do
  SKIP                                             // arq para que nehum outro
  BLOREG(0,.5)                                     // usuario possa incluir
  SEEK M->cobrador                                 // se registro foi incluido
  aprov_reg_=(FOUND().AND.DELE().AND.!drvvisivel)  // vai aproveitar o registro?
  IF FOUND() .AND. !aprov_reg_                     // por outro usuario, entao
   BLOREG(0,.5)
   FOR i=1 TO FCOU()
    msg=FIEL(i)
    rep[i]=&msg.
    REPL &msg. WITH M->&msg.
   NEXT
   COB_GET1(FORM_INVERSA)                          // executa formula inversa
   RECA
   FOR i=1 TO FCOU()
    msg=FIEL(i)
    REPL &msg. WITH rep[i]
   NEXT
   ALERTA(4)                                       // beep 4 vezes
   msg="Registro acabou de ser|inclu¡do por outro usu rio!"
   DBOX(msg,,,,,"ATEN€ŽO!")                        // avisa
   SELE COBRADOR
   UNLOCK                                          // libera o registro
   LOOP                                            // e recebe chave novamente
  ENDI
 #endi

 IF aprov_reg_                                     // se vai aproveitar reg excluido

  #ifdef COM_REDE
   BLOREG(0,.5)
  #endi

  RECA                                             // excluido, vamos recupera-lo
 ELSE                                              // caso contrario
  APPEND BLANK                                     // inclui reg em branco no dbf
 ENDI
 FOR i=1 TO FCOU()                                 // para cada campo,
  msg=FIEL(i)                                      // salva o conteudo
  rep[i]=M->&msg.                                  // para repetir
  REPL &msg. WITH rep[i]                           // enche o campo do arquivo
 NEXT

 #ifdef COM_REDE
  UNLOCK                                           // libera o registro e
  COMMIT                                           // forca gravacao
 #else
  IF RECC()-INT(RECC()/20)*20=0                    // a cada 20 registros
   COMMIT                                          // digitados forca gravacao
  ENDI
 #endi

 ult_reg=RECN()                                    // ultimo registro digitado
 IF reg_cop!=NIL                                   // estava na consulta e quis rep o campo
  EXIT                                             // cai fora...
 ENDI
ENDD
GO ult_reg                                         // para o ultimo reg digitado
SETKEY(K_F3,t_f3_)                                 // restaura teclas de funcoes
SETKEY(K_F4,t_f4_)
SET(_SET_DELETED,dele_atu)                            // ecluidos visiveis/invisiveis
SETKEY(K_CTRL_W,ctl_w)
SETKEY(K_CTRL_C,ctl_c)
SETKEY(K_CTRL_R,ctl_r)
RETU


PROC COB_tela     // tela do arquivo COBRADOR
tem_borda=.t.
l_s=Sistema[op_sis,O_TELA,O_LS]           // coordenadas da tela
c_s=Sistema[op_sis,O_TELA,O_CS]
l_i=Sistema[op_sis,O_TELA,O_LI]
c_i=Sistema[op_sis,O_TELA,O_CI]
SETCOLOR(drvtittel)
vr_memo=NOVAPOSI(@l_s,@c_s,@l_i,@c_i)     // pega posicao atual da tela
CAIXA(mold,l_s,c_s,l_i,c_i)               // monta caixa da tela
i=LEN(sistema[op_sis,O_MENS])/2
@ l_s,c_s-1+(c_i-c_s+1)/2-i SAY " "+MAIUSC(sistema[op_sis,O_MENS])+" "
SETCOLOR(drvcortel)
@ l_s+01,c_s+1 SAY " Codigo..........:      Fun‡„o:"
@ l_s+02,c_s+1 SAY " Nome............:"
@ l_s+03,c_s+1 SAY " Endere‡o........:"
@ l_s+04,c_s+1 SAY " Bairro..........:"
@ l_s+05,c_s+1 SAY " Cidade..........:"
@ l_s+06,c_s+1 SAY " Telefone........:"
@ l_s+07,c_s+1 SAY " CPF.............:"
@ l_s+08,c_s+1 SAY " Observa‡„o......:            Percentual.:"
@ l_s+09,c_s+1 SAY " Supervisor......:"
RETU

PROC COB_gets     // mostra variaveis do arquivo COBRADOR
LOCAL getlist := {}, t_f7_
COB_TELA()
SETCOLOR(drvcortel+","+drvcorget+",,,"+corcampo)
@ l_s+01 ,c_s+20 GET  cobrador;
                 PICT sistema[op_sis,O_CAMPO,01,O_MASC]

@ l_s+01 ,c_s+33 GET  funcao;
                 PICT sistema[op_sis,O_CAMPO,02,O_MASC]
                 CRIT(sistema[op_sis,O_CAMPO,02,O_CRIT],,"1")

@ l_s+02 ,c_s+20 GET  nome

@ l_s+03 ,c_s+20 GET  endereco

@ l_s+04 ,c_s+20 GET  bairro

@ l_s+05 ,c_s+20 GET  cidade

@ l_s+06 ,c_s+20 GET  telefone

@ l_s+07 ,c_s+20 GET  cpf;
                 PICT sistema[op_sis,O_CAMPO,08,O_MASC]

@ l_s+08 ,c_s+20 SAY "{M} "

@ l_s+08 ,c_s+44 GET  percent;
                 PICT sistema[op_sis,O_CAMPO,10,O_MASC]

@ l_s+09 ,c_s+20 GET  superv;
                 PICT sistema[op_sis,O_CAMPO,11,O_MASC]

CLEAR GETS
RETU

PROC COB_get1(tp_mov)     // capta variaveis do arquivo COBRADOR
LOCAL getlist := {}, t_f7_
PRIV  blk_cobrador:=.t.

IF tp_mov=INCLUI
 DO WHILE .t.
  rola_t=.f.
  memo09:="{F7}"
  t_f7_=SETKEY(K_F7,{||COB_memo()})
  SET KEY K_ALT_F8 TO ROLATELA
  SETCOLOR(drvcortel+","+drvcorget+",,,"+corcampo)
  @ l_s+01 ,c_s+33 GET  funcao;
                   PICT sistema[op_sis,O_CAMPO,02,O_MASC]
                   DEFINICAO 2
                   MOSTRA sistema[op_sis,O_FORMULA,1]

  @ l_s+02 ,c_s+20 GET  nome
                   DEFINICAO 3

  @ l_s+03 ,c_s+20 GET  endereco
                   DEFINICAO 4

  @ l_s+04 ,c_s+20 GET  bairro
                   DEFINICAO 5

  @ l_s+05 ,c_s+20 GET  cidade
                   DEFINICAO 6

  @ l_s+06 ,c_s+20 GET  telefone
                   DEFINICAO 7

  @ l_s+07 ,c_s+20 GET  cpf;
                   PICT sistema[op_sis,O_CAMPO,08,O_MASC]
                   DEFINICAO 8

  @ l_s+08 ,c_s+20 GET  memo09;
                   PICT "@!"
                   DEFINICAO 9

  @ l_s+08 ,c_s+44 GET  percent;
                   PICT sistema[op_sis,O_CAMPO,10,O_MASC]
                   DEFINICAO 10

  @ l_s+09 ,c_s+20 GET  superv;
                   PICT sistema[op_sis,O_CAMPO,11,O_MASC]
                   DEFINICAO 11

  READ
  SETKEY(K_F7,t_f7_)
  SET KEY K_ALT_F8 TO
  IF rola_t
   ROLATELA()
   LOOP
  ENDI
  IF LASTKEY()!=K_ESC .AND. drvincl .AND. op_menu=INCLUSAO
   IF !CONFINCL()
    LOOP
   ENDI
  ENDI
  EXIT
 ENDD
ENDI
IF tp_mov=EXCLUI .OR. tp_mov=FORM_INVERSA
 DELE
ELSEIF tp_mov=INCLUI .OR. tp_mov=RECUPERA .OR. tp_mov=FORM_DIRETA
 IF op_menu!=INCLUSAO
  RECA
 ENDI
ENDI
RETU

PROC COB_MEMO
IF READVAR()="MEMO09"
 EDIMEMO("obs",sistema[op_sis,O_CAMPO,09,O_TITU],14,2,23,38)
ENDI
RETU

* \\ Final de COBRADOR.PRG
procedure gui_06f9
/*
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
 \ Empresa.: PresServ Inform tica - Limeira (019)452.6623
 \ Programa: GUI_02F9.PRG
 \ Data....: 23-05-98
 \ Sistema.: Administradora - RECEP€„O
 \ Funcao..: Fun‡„o F8 do campo NOME, arquivo GUIAS
 \ Analista: Ademilson Pedro Bom
 \ Criacao.: Programado manualmente pelo analista
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/

#include "adrbig.ch"    // inicializa constantes manifestas

LOCAL reg_dbf:=POINTER_DBF()
PRIVA nopc:=1, respx:=space(30), ctx:=0
PTAB(ALLTRIM(contrato),[INSCRITS],1,.t.)
nopc:=1
ctx:=0
msg_ins:=[]
SELE INSCRITS
DO WHIL !EOF() .AND. INSCRITS->codigo=ALLTRIM(contrato)
 msg_ins+=INSCRITS->nome+[ (]+;
 LEFT(TRAN(SUBSTR([TitPaiMaeSgoSgaEspFilDep],(VAL(grau)-1)*3+1,3),[]),03)+;
 [) tc ]+DTOC(INSCRITS->tcarencia)+[ ]+vivofalec+[ ]+tipo+[|]
 ctx++
 IF (M->nome = INSCRITS->nome)
	nopc:=ctx
 ENDI
 SKIP
ENDD

POINTER_DBF(reg_dbf)
IF !EMPT(msg_ins)
 nopc:=DBOX(msg_ins,,,E_MENU,,[Escolha o Benefici rio],,,nopc)
 respx:=substr(msg_ins,(nopc-1)*62+1,35)
ENDI

IF LASTKEY()=K_ESC             // se teclou ESC
 RETU nil
ENDI

RETU respx
// <- deve retornar um valor qualquer

* \\ Final de GUI_02F9.PRG
€
 IMP_01F9I–Ñ  IMP_01F9CODEC_ETEXTENDCODE	_SYMSTARTSYMSTARTSYMBOLSSYMBOLS_SYMENDSYMENDNULLBEGDATA_DATADATA_SYMPBDATA_SYMPDATA_SYMPEDATA_CONSTCONST_MSGMSG_BEGBSSBEGBSS_BSSBSS_ENDBSSENDBSSDGROUP˜ @@Ú˜ H  ˜ h  ë˜ `à 	˜ h  
ã˜ h  ß˜ H  û˜ H  ÷˜ H ë˜ H  ï˜ H  ë˜ (  ˜ H  /*
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
 \ Empresa.: PresServ Inform tica - Limeira (019)452.6623
 \ Programa: ADR_FUNC.PRG
 \ Data....: 29-01-04
 \ Sistema.: Administradora - RECEP€„O
 \ Funcao..: Fun‡”es auxiliares
 \ Analista: Ademilson Pedro Bom
 \ Criacao.: GAS-Pro v4.0o
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/

#include "adrbig.ch"    // inicializa constantes manifestas

/*
   Sintaxe: PTAB( <ExpC1>, <ExpC2> [,ExpN] [,ExpL] )
   Funcao.: Executa pesquisa em tabelas
              ExpC1 = chave de pesquisa
              ExpC2 = arquivo alvo
              ExpN  = numero do indice associado a ExpC2
              ExpL  = se .t. deixa na ordem do indice do parametro
  
   Retorna: .t. se o registro existe
*/
FUNC PTAB(ch_,db_,or_dem,fix_ind_)
LOCAL ar_:=SELECT(), in_, sem_dbf:=ALIAS(), achou, del_a:=SET(_SET_DELETED,.f.), reg_
or_dem=IF(or_dem=NIL,1,or_dem)
fix_ind_=IF(fix_ind_=NIL,.f.,fix_ind_)
IF !USEARQ(db_)            // tenta abrir DBF e seus indices
 RETU (.f.)                // retorna .f. se nao conseguiu
ENDI
in_=INDEXORD()             // salva ordem atual
DBSETORDER(or_dem)         // seta nova ordem dos indices
SEEK ch_                   // procura o registro
achou=.F.                  // flag se achou
IF FOUND()                 // achou... Verif todos da mesma chave
 reg_=RECNO()              // salva registro atual
 DO WHILE !EOF() .AND. &(INDEXKEY(0))=ch_
  IF !DELE()               // este nao esta excluido..
   EXIT                    // cai fora
  ENDI
  SKIP                     // verifica o proximo
 END
 achou=(&(INDEXKEY(0))=ch_) // se for mesma chave entao achou
 IF !achou                 // se nao achou
  GO reg_                  // volta para o reg excluido
 ENDI
ELSE
 IF !EOF()                 // se nao for final do arquivo
  GO BOTT                  // vamos forcar
  SKIP
 ENDI
ENDI
IF !fix_ind_               // se nao quer deixar na ordem da pesquisa
 DBSETORDER(in_)        // retorna ordem original
ENDI
IF EMPTY(sem_dbf)          // se area anterior estiver vaga
 SELE 0                    //  seleciona proxima area vaga
ELSE                       // senao
 SELE (ar_)                //  seleciona area anterior
ENDI
SET(_SET_DELETED,del_a)    // retorna a visibilidade dos excluidos
RETU achou

/*
   Sintaxe: USEARQ( <ExpC> [,ExpL1] [,ExpN1], [,ExpN2] [,ExpL2] )
   Funcao.: Abre arquivo de dados e seus ¡ndices associados
              ExpC  = nome do arquivo
              ExpL1 = .t. abre modo exclusivo
              ExpN1 = num de vezes que sera tentada a abertura
              ExpN2 = tempo em segundos entre as tentativas de abertura
              ExpL2 = .t. abre associando os ntx
   Retorna: .t. se abriu o arquivo
*/
FUNC USEARQ(db_,use_ex,n_tent,t_tent,com_ntx)
LOCAL op_sis, qt_ind, p_, drv_dbf, p_sempre, v_r, msg,;
      ind01, ind02, ind03, ind04
n_tent=IF(n_tent=NIL,0,n_tent)
t_tent=IF(t_tent=NIL,1,t_tent)
com_ntx=IF(com_ntx=NIL,.t.,com_ntx)
use_ex=IF(use_ex=NIL,.f.,use_ex)
p_sempre=(n_tent=0)
n_ant=n_tent
v_r=.f.
op_sis=EVAL(qualsis,db_)                   // obtem subscricao do DBF no vetor Sistema
IF op_sis>0                                // tem drives
 drv_dbf=sistema[op_sis,O_ARQUI,O_DIR_DBF] // drive de dados
 drv_ntx=sistema[op_sis,O_ARQUI,O_DIR_NTX] // drive dos indices
ELSE                                       // nao tem drives, pega default
 drv_dbf=drvdbf                            // drive de dados
 drv_ntx=drvntx                            // drive dos indices
ENDI
IF "\" $ db_                               // verifica se passou diretorio + arquivo
 p_=RAT("\",db_)
 drv_dbf=LEFT(db_,p_)                      // pega diretorio passado e
 db_=SUBS(db_,p_+1)                        // o nome do arquivo
ENDI
IF EMPTY(SELECT(db_))                      // o arquivo nao esta' em uso, vamos abri-lo...
 db_f=drv_dbf + db_
 SELE 0                                    // seleciona proxima area livre

 #ifdef COM_REDE
  msgt="OUTRO USURIO ACESSANDO|O ARQUIVO"
  DO WHIL n_tent>=0 .OR. p_sempre          // tenta abrir o aruivo n vezes ou p/ sempre
   IF use_ex                               // tenta abrir com exclusividade
    USE (db_f) EXCLUSIVE
   ELSE                                    // tenta abrir compartilhado
    USE (db_f) SHARED
   ENDI
   IF ! NETERR()                           // abriu sem problemas
    v_r=.t.
    EXIT
   ENDI
   DBOX("Tentando abrir|"+;                // avisa usuario, espera n_tent
        IF(p_sempre,"(NŽO","(ESC")+;       // segundos para tentar novamente
        " cancela)",15,,t_tent,,msgt)
   n_tent-=t_tent
   IF !p_sempre .AND. LASTKEY()=K_ESC      // se nao for para sempre e quer
    EXIT                                   // cancelar, nao tenta abrir mais
   ENDI
  ENDD
  CLEA TYPEAHEAD                           // limpa o buffer do teclado
  IF ! v_r                                 // se nao conseguiu abrir o arquivo
   RETU (.f.)                              // retorna falso
  ENDI
 #else
  USE (db_f)                               // abre o arquivo
 #endi

 IF com_ntx                                // abre arquivo com os indices
  IF op_sis=0                              // se o arquivo e' externo ao sistema...
   v_r=AT(".",db_)                         //  tira extensao do arquivo
   n_t_x=IF(v_r>0,LEFT(db_,v_r-1),db_)     //  caso exista
   nt_x=drv_dbf+LEFT(n_t_x,7)+"1"          //  verifica se existe arquivo
   IF FILE(nt_x+EXTENSAO())                //  se existir indice com nome xxx1.ntx,
    SET INDE TO (nt_x)                     //   vamos usa-lo
    DBSETORDER(1)
   ELSE                                    //  se nao procura
    nt_x=drv_dbf+LEFT(n_t_x,7)             //  indice com
    IF FILE(nt_x+EXTENSAO())               //  nome xxx.ntx, usa
     SET INDE TO (nt_x)
     DBSETORDER(1)
    ENDI
   ENDI
  ELSEIF LEN(sistema[op_sis,O_INDIC])>0    // senao, abre indices segundo vetor sistema
   qt_ind=LEN(sistema[op_sis,O_INDIC])
   ind01=sistema[op_sis,O_ARQUI,O_DIR_NTX]+sistema[op_sis,O_INDIC,1]
   IF qt_ind=1
    SET INDE TO (ind01)
   ELSE
    ind02=sistema[op_sis,O_ARQUI,O_DIR_NTX]+sistema[op_sis,O_INDIC,2]
    IF qt_ind=2
     SET INDE TO (ind01), (ind02)
    ELSE
     ind03=sistema[op_sis,O_ARQUI,O_DIR_NTX]+sistema[op_sis,O_INDIC,3]
     IF qt_ind=3
      SET INDE TO (ind01), (ind02), (ind03)
     ELSE
      ind04=sistema[op_sis,O_ARQUI,O_DIR_NTX]+sistema[op_sis,O_INDIC,4]
      IF qt_ind=4
       SET INDE TO (ind01), (ind02), (ind03), (ind04)
      ENDI
     ENDI
    ENDI
   ENDI
   DBSETORDER(1)
  ENDI
 ENDI
ELSE
 SELE SELECT(db_)                          // arquivo ja' estava aberto
ENDI
RETU .t.                                   // deu tudo certo...

/*
   Sintaxe: CRIT( <ExpC1> <,ExpN> [,ExpC2] )
   Funcao.: Executa validacao de campos/ mostra formulas na tela
              ExpC1 = expressao de validacao e a mensagem a ser mostrada
                      separados separadas pelo caracter "~".
              ExpN  = linha onde sera mostrada a mensagem
              ExpC2 = formulas a serem mostradas na tela. ("nn|nn|nn|...",
                      "nn"=num das f¢rmulas especificadas no vetor "sistema"
   Retorna: .t. se critica ok
*/
FUNC CRIT(msgc,li,form_)
LOCAL cond, msg, flag:=.t., no_gets, i_
PRIV  l, c
no_gets=(RIGHT(PROCNAME(1),5)="_GETS")        // flg se nao esta consultando
IF !EMPT(msgc) .AND. !("V"==msgc) .AND. !("I"==msgc)
 li=IF(li=NIL.OR.li>MAXROW()-5,MAXROW()-5,li) // ajusta linha da mensagem
 msg =SUBS(msgc,AT("~",msgc)+1)               // mensagem a mostrar
 cond=LEFT(msgc,AT("~",msgc)-1)               // condicao de validacao
 IF !(&cond.)                                 // se condicao nao satisfeita,
  IF !no_gets                                 // se tem msg para mostrar
   IF LEN(TRIM(msg))>0                        // se tem msg para mostrar
    ALERTA()                                  // beep, beep, beep
    DBOX(msg,li,,,,"ATEN€ŽO! "+usuario)       // avisa ao usuario
   ENDI
   flag=.f.                                   //  retornando falso
  ENDI
 ENDI
ENDI
IF flag .AND. form_!=NIL                      // validacao ok e tem formulas
 DO WHIL LEN(form_)>0                         // mostraremos todas ...
  i_=VAL(PARSE(@form_,"|"))                   // pega subscricao da formula
  IMP_FORM(sistema[op_sis,O_FORMULA,i_])      // imprime a formula
 ENDD
ENDI
RETU flag                                     // retorna ok se validacao ok

/*
   Sintaxe: EDITA( <N1> <,N2> <,N3> <,N4> <,ExpL|ExpC1> <,Arr1> <,Arr2> <,ExpC2> <,ExpC3> <,ExpC4> <,ExpL1> )
   Funcao.: Apresenta a tela de consulta no objeto "TBrowse" com diversos recursos.
              N1,N2,N3,N4 = coordenadas da janela de consulta
               ExpL|ExpC1 = rotinas nao acessadas
                     Arr1 = arranjo de campos a apresentar na janela
                     Arr2 = titulos dos campos de Arr1
                    ExpC2 = filtro inicial
                    ExpC3 = ordem inicial
                    ExpC4 = condicao para marcar o registros
                    ExpL1 = .t.=letras pesq - .f.=letras fazem acao
   Retorna: NIL
*/
FUNC EDITA(li_supp,co_supp,li_infp,co_infp,mo_difp,coluna_cp,coluna_tit,cr_,ord_,cdmr_)
LOCAL op_sy_:=op_sis, cor_orig, i_, t_f8, dele_atu:=SET(_SET_DELETED)
PRIV cp_:="", cond_p:="", tit_cons:={"",""}, db_1rela:="", cpord, qual_prg,;
     db_2rela:="", cpord:="", criterio:="", ind_ord:=1, ind_rela:=1, chvpesq:="",;
     grava_db:=.f., op_db:=1, volta_db, ch_tecl:="05042419", op_menu:=PROJECOES,;
     di_tecl:="24262527", br_reg_ori, br_reg_out, brw_tempo, brw_ant:=brw,;
     col_cp:=coluna_cp,col_tit:=coluna_tit, li_sup:=li_supp, vr_edita, cr_ini:=cr_,;
     li_inf:=li_infp, co_sup:=co_supp, co_inf:=co_infp, posi_cur, cmr_:=cdmr_,;
     mo_dif:=mo_difp, hlp_cod:=cod_sos, dir_cur:=3, chv_rela:=""
IF ! USED()                          // se nao existir arquivo
 RETU .f.                            // aberto, cai fora
ENDI
qual_prg=PROCNAME(1)                 // nome do prg que chamou a funcao
cr_ini=IF(cr_ini=NIL,"",cr_ini)      // filtro inicial nao informado
cmr_=IF(cmr_=NIL,"1=2",cmr_)         // tem condicao de marcar registros?
cpord=IF(ord_=NIL,"",ord_)           // tem ordem inicial?
FOR i_=1 TO FCOU()                   // declara privados todos os
 msg=FIELD(i_)                       // campos do arquivo da consulta
 PRIV &msg.
NEXT

#ifdef COM_MOUSE
 IF drvmouse
  DO WHIL MOUSEGET(0,0)!=0           // se qualquer botao do mouse
  ENDD                               // estiver pressionado espera
 ENDI                                // liberacao
#endi

brw=.t.                              // pega posicao atual da tela
vr_edita=NOVAPOSI(@li_sup,@co_sup,@li_inf,@co_inf)
mo_dif=IF(mo_dif=NIL,.t.,mo_dif)     // trata as rotinas
IF TYPE("mo_dif")="L"                // que nao poderao
 IF !mo_dif                          // ser acessadas
  mo_dif="DERMG"                     // durante a consulta
 ELSE
  mo_dif=""
 ENDI
ENDI
cor_orig=SETCOLOR()                  // salva cor original
brw_reg=RECN()                       // registro atual
volta_db=.t.
IF LEN(cr_ini)>0                     // tem filtro inicial?
 i_=SELECT()                         // salva area atual
 estr_dbf:=DBSTRUCT()                // pega estrutura do dbf aberto
 i=INDEXORD()                        // indice atual
 IF i>LEN(sistema[EVAL(qualsis,ALIAS()),O_ORDEM]) // se esta usando ind tmp
  i=1                                // pega o primeiro
 ENDI
 x_=sistema[EVAL(qualsis,ALIAS()),O_ORDEM,i] // campos do indice
 SELE 0                              // vai para primeira area vazia
 p=1                                 // separa filtro inicial para
 DO WHILE .t.                        // verificar se tem congruencia com o indice
  i=AT("=",SUBS(cr_ini,p))           // campo do filtro
  IF i=0                             // epa! condicao invalida
   chv_rela=""                       // cai fora
   EXIT
  ENDI                               // campo do filtro verifica se ele e' um
  cp_=ALLTRIM(SUBS(cr_ini,p,i-1))    // nome valido e se o indice e formado por ele
  IF AT("+",cp_)>0 .OR. AT("(",cp_)>0 .OR. AT(")",cp_)>0 .OR.;
     AT(".",cp_)>0 .OR. AT(",",cp_)>0 .OR. AT(" ",cp_)>0 .OR.;
     LEN(x_)=0 .OR. !(UPPER(cp_)==UPPER(estr_dbf[VAL(LEFT(x_,2)),1]))
   chv_rela=""                       // campo ilegal
   EXIT                              // cai fora
  ENDI
  x_=SUBS(x_,3)                      // proximo campo do indice
  p+=i
  i=AT(".AND.",SUBS(UPPER(cr_ini),p))// pode ter mais de um campo filtrando
  IF i=0                             // nao tem
   i=LEN(cr_ini)-p+2                 // pega todo o tamanho do filtro
  ENDI
  cond_p=ALLTRIM(SUBS(cr_ini,p,i-1)) // segundo opereando e' valido...
  IF AT("+",cond_p)>0 .OR. AT("(",cond_p)>0 .OR. AT(")",cond_p)>0 .OR.;
     AT(".",cond_p)>0 .OR. AT(",",cond_p)>0 .OR. AT(" ",cond_p)>0
   chv_rela=""
   EXIT                              // se nao cai fora
  ENDI
  p+=i+4                             // ajusta proximo campo
  &cp_.=&cond_p.                     // faz variavel=segundo operando
  IF LEN(chv_rela)>0                 // se ja tem relacionamento
   chv_rela=chv_rela+"+"             // concatenda com um "+"
  ENDI
  chv_rela+="M->"+cp_                // finge que e dbf relacionado
  IF p>=LEN(cr_ini)                  // se nao tem mais filtro
   EXIT                              // cai fora...
  ENDI
 ENDD
 SELE (i_)
 cp_:=cond_p := ""                   // inicializa variaveis
ENDI
IF LEN(cr_ini)>0 .AND. LEN(chv_rela)=0 // se tem filtro e nao consegui relacionar
 criterio=cr_ini                       // vamos preparar para indexar
ENDI

#ifdef COM_REDE
 brw_tempo=drvtempo                  // tempo de "refresh"
#endi

t_f8=SETKEY(K_ALT_F8,NIL)            // salva/reseta tecla ALT-F8
BRWFUNC(PROCNAME(1)!="VDBF")         // funcoes auxiliares
SETKEY(K_ALT_F8,t_f8)                // seta tecla ALT-F8

#ifdef COM_REDE
 IF brw_tempo!=drvtempo              // se alterou o tempo de "refresh"
  SAVE TO (arqconf) ALL LIKE drv*    // salva em disco
 ENDI
#endi

SETCOLOR(cor_orig)                   // restaura cor original
op_sis = op_sy_
SET KEY K_TAB TO                     // resta TAB
brw=brw_ant
SET(_SET_DELETED,dele_atu)           // SET DELE=anterior
RETU .t.

/*
   Sintaxe: MOV_PTR( <ExpN> )
   Funcao.: Move o ponteiro em arquivo relacionado e ou filtrado
              ExpN  = numero de registros para mover o ponteiro
   Retorna: Num de registros pulados
*/
FUNC MOV_PTR(a_pular)
LOCAL ja_pulado := 0, chv_
IF a_pular = 0                             // nao vai pular registros
 SKIP 0
ELSE                                       // vai pular registros...
 chv_=&("{||"+INDEXKEY(0)+"=["+;           // so servem os registro que
      IF(EMPT(criterio),"","T")+chv_1+"]}")// atendao ao filtro/relacao
 DO WHILE !EOF() .AND. !BOF() .AND.;       // pula qtos reg's forao pedidos
    a_pular != ja_pulado .AND. EVAL(chv_)  // ate eof ou fora filtro/relacao
  IF a_pular > 0                           // pulando para frente
   SKIP
   ja_pulado++                             // conta quando foroa pulados
  ELSE                                     // pulando para traz
   SKIP -1
   ja_pulado--                             // menos um pulado
  ENDI
 ENDD
 IF !EVAL(chv_) .OR. EOF() .OR. BOF()      // reg nao atende filtro/relacao
  IF a_pular > 0                           // esta pulando para frente
   FIM_ARQ()                               // acha o fim do arquivo
   ja_pulado--                             // decrementa um na qde de reg pulados
  ELSE                                     // pulando para traz
   INI_ARQ()                               // acha o inicio do arquivo
   ja_pulado++                             // incrementa um na qde de reg pulados
  ENDI
 ENDI
ENDI
RETU ja_pulado                             // retorna a qde exata de reg pulados

/*
   Sintaxe: CABBRW()
   Funcao.: Monta cabecalho da consulta
   Retorna: NIL
*/
STATIC FUNC CABBRW
br_w:headsep:=chr(205)+chr(209)+chr(205)  // separador do cabecalho (ÍÑÍ)
br_w:colsep:=" "+chr(179)+" "             // separador das colunas  ( ³ )
op_sis=EVAL(qualsis,ALIAS())              // subscricao do arquivo atual
br_w:cargo:={"","","",INDEXORD()}         // salva alguns parametros da consulta
RETU NIL

/*
   Sintaxe: MONTABRW()
   Funcao.: Monta janela de visualiza‡„o da consulta
   Retorna: NIL
*/
STATIC FUNC MONTABRW()
LOCAL id_carg:={}
op_sis   = EVAL(qualsis,ALIAS())       // subscricao do arquivo atual
arq_cor  = LEFT(ALIAS(),3)             // prefixo do arquivo
id_carg  = br_w:cargo                  // variaveis da consulta
criterio = id_carg[1]                  // filtro
cpord    = id_carg[2]                  // ordenacao
chv_rela = id_carg[3]                  // relacao
ind_ord  = id_carg[4]                  // indice atual
cmr_     = id_carg[5]                  // marcacao de registros
DBSETORDER(ind_ord)                    // escolhe o indice atual
PEGACHV2()                             // pega final do relaciomento
SETCOLOR(drvcorbox)                    // cor da janela selecionada

#ifdef COM_MOUSE
 IF drvmouse                           // define area de atuacao do mouse
  MOUSEBOX(br_w:ntop-1,br_w:nleft-1,br_w:nbottom+1,br_w:nright+1)
 ENDI
#endi


/*
   Monta janela de consulta e mensagens de status e teclas disponiveis
   nas suas bordas
*/
CAIXA(mold+CHR(0),br_w:ntop-2, br_w:nleft-1, br_w:nbottom+1, br_w:nright+1)
@ br_w:ntop-2,br_w:nleft SAY IF(EMPTY(criterio),"{Qde="+LTRIM(STR(RECC(),10))+"}",REPL(SUBS(mold,2,1),11))
msg="TAB [ ],F10"+IF(SETKEY(K_F8)=NIL,"",",F8")+IF((M->v_out.AND.tem_t).OR.!M->v_out,",F9","")

#ifdef COM_MOUSE
 IF drvmouse                           // botoes do mouse
  msg+=" "+CHR(174)+" "+CHR(175)+" "+CHR(30)+" "+CHR(31)+" "+CHR(24)+" "+CHR(26)+" "+CHR(25)+" "+CHR(27)+" "+CHR(18)
 ENDI
#endi

msg=LEFT(msg,br_w:nright-br_w:nleft)
posi_cur=INT((br_w:nright-br_w:nleft-LEN(msg))/2)
@ br_w:nbottom+1,br_w:nleft+posi_cur SAY msg
@ br_w:nbottom+1,br_w:nleft+posi_cur+5 SAY CHR(VAL(SUBS(di_tecl,dir_cur*2-1,2)))
x=br_w:nright-br_w:nleft+1
@ br_w:ntop-1,br_w:nleft SAY PADC(MAIUSC(tit_cons[IF(br_w == br_origem,1,2)]),x,' ')
RETU NIL

/*
   Sintaxe: FORCABRW( <ExpL> )
   Funcao.: Reimprime dados da funcao EDITA()
              ExpL = se .t. reimprime inclusive a moldura.
   Retorna: NIL
*/
STATIC FUNC FORCABRW(imp_cx)
LOCAL id_carg:={}
PRIV op_sis, chv_1, chv_2, criterio, cpord, chv_rela, cmr_, chv_1, chv_2
COMMIT
IF br_outro != NIL               // se a 2a. janela estiver aberta
 TROCA_BRW()                     // troca janela do browse

 #ifdef COM_REDE
  COMMIT                         // forca atualizacao em disco
 #endi

 id_carg = br_w:cargo            // retira da variavel de instancia
 criterio=id_carg[1]             // o filtro que tinha
 cpord=id_carg[2]                // a ordenacao
 chv_rela=id_carg[3]             // a relacao
 ind_ord=id_carg[4]              // indice utilizado
 cmr_=id_carg[5]                 // e a marcacao de registros
 DBSETORDER(ind_ord)
 op_sis=EVAL(qualsis,ALIAS())    // obtem subscricao do DBF no vetor Sistema
 PEGACHV2()                      // pega final do relaciomento
 IF imp_cx                       // reimprime moldura da janela
  SETCOLOR(drvcortna)
  br_w:colorspec := drvcortna+","+INVCOR(drvcortna)+","+drvcorenf+","+drvcorget+","+drvcorhlp
  CAIXA(mold+CHR(0),br_w:ntop-2, br_w:nleft-1, br_w:nbottom+1, br_w:nright+1)
  x=br_w:nright-br_w:nleft+1
  @ br_w:ntop-1,br_w:nleft SAY PADC(MAIUSC(tit_cons[IF(br_w == br_origem,1,2)]),x,' ')
 ENDI
 IF DELE().AND.SET(_SET_DELETED) // registro esta apagado e nao visivel
  MOV_PTR(-1)                    // acha o 1o. reg nao apagado
 ENDI
 br_w:refreshall()               // forca atualizacao da tela nao selecionada
 br_w:forcestable()              // apresenta os dados
 br_w:dehilite()                 // liga barra cursora
 TROCA_BRW()                     // troca janela do browse
ENDI
RETU NIL

/*
   Sintaxe: ABREOUTRO( <ExpN> )
   Funcao.: Abre segunda janela de consulta
              ExpN = subscricao do arquivo dentro vetor "sistema"
   Retorna: .t. se teve sucesso
*/
STATIC FUNC ABREOUTRO(op_s)
LOCAL ar_, c_1, c_2
ar_=UPPER(sistema[op_s,O_ARQUI,O_NOME]) // nome do arquivo da consuta

#ifdef COM_REDE
 IF !USEARQ(ar_,.f.,20,1)               // se nao conseguiu abrir o arquivo
  DBOX(ms_uso,20)                       // avisa
  SELE (m_origem)                       // retorna para o DBF original
  RETU .f.                              // e retorna
 ENDI
#else
 USEARQ(ar_)                            // abre DBF da consulta
#endi

outro_db=ALLTRIM(STR(SELEC(ar_)))       // salva area do arquivo aberto
SELE (m_origem)
M->tp=li_sup+INT((li_inf-li_sup-1)/2)+1 // linha de divisao das janelas
br_reg_ori=RECNO()                      // salva registro do DBF original
br_w:dehilite()                         // apaga barra cursora
br_w:nbottom := M->tp - 2               // final da janela do DBF original
br_w:configure()                        // seta remontagem da janela
c_1=br_w:nleft                          // salva coordenadas da direita
c_2=br_w:nright                         // e da esquerda para a nova janela
SELE (outro_db)                         // novo arquivo
GO TOP                                  // monta browse da nova consulta
br_outro=TBROWSENEW(M->tp+1,c_1,li_inf,c_2)
br_outro:colorspec := drvcorbox+","+INVCOR(drvcorbox)+","+drvcorenf+","+drvcorget+","+drvcorhlp
br_w=br_outro                           // browse atual
CABBRW()                                // monta janela do novo browse
RETU .t.                                // e retorna

/*
   Sintaxe: MOSTRA_RELA()
   Funcao.: Verifica se a janela de baixa esta relacionada e
            se e' necessario mostra os seus registros
   Retorna: .t. se preciso remonta-la
*/
STATIC FUNC MOSTRA_RELA()
LOCAL ok:=.f.
PRIV chv_rela, criterio, cpord, cmr_, chv_1, chv_2, op_sis
IF TYPE("br_outro")="O"                       // tem outra janela aberta?
 id_carg = br_outro:cargo
 IF !EMPT(id_carg[3])                         // a janela esta relacionada?
  criterio = id_carg[1]                       // restabelece o filtro
  cpord    = id_carg[2]                       // ordem e a
  chv_rela = id_carg[3]                       // relacao entre as janelas
  cmr_     = id_carg[5]                       // marcacao de registros
  SELE (outro_db)                             // seleciona dbf da janela
  op_sis=EVAL(qualsis,ALIAS())                // sua subscricao no vetor sistema
  PEGACHV2()                                  // acha o inicio/fim da relacao
  IF chv_1 != &chv_rela .OR. !br_outro:stable // precisa remonta-la?
   INI_ARQ()                                  // acha o inicio da relacao
   br_reg_out = RECNO()                       // salva reg atual
   br_outro:rowpos := 1                       // cursor na 1a. lin do browse
   ok:=.t.                                    // tem que remontar a janela
  ENDI
  SELE (m_origem)                             // seleciona janela superior
 ENDI
ENDI
RETU ok

/*
   Sintaxe: BRWFUNC( [ExpL] )
   Funcao.: Diversas funcoes auxiliares da EDITA()
              ExpL = .t./omitida le consultas gravadas
   Retorna: NIL
*/
STATIC FUNC BRWFUNC(nao_vdbf)
LOCAL br_w1, brw_tela, cri_ant, brw_reg, cp_exp:={}, estr_dbf:={}, tps,;
      tecl_p, l_sup, l_inf, m_od, arqexp, dli_exp, id_carg:={}, q_tela,;
      just_memo, Li:=1, Co:=1, ppp:=0, pp:=0, t, i, l_m, Tp_Sai,t_f8,;
      tit_rel, brw_fundo:=SAVESCREEN(0,0,MAXROW(),79), dele_atu, x_, y_,;
      cmr_ant, getlist:={}, cont_mod, cur_atual, nao_pesq:=.f., ind_ok
PRIV cp_, cp_titu, cp_masc, cp_crit, cp_when, cp_help, cp_cmd, tp_cp, br_w,;
     fg_loc:=.f., volta_db:=.t., arq_cor:=LEFT(ALIAS(),3), br_origem,;
     br_outro:=NIL, m_origem, outro_db:=NIL, chv_1:="", chv_2:="", l_s,;
     c_s, l_i, c_i, db_zoom:=.f., br_arq:="", br_tit:="", _pesq:=drvpesq,;
     st_pesq:="", blk_, blk_a
m_origem = ALLTRIM(STR(SELEC()))
br_origem = TBROWSENEW(li_sup,co_sup,li_inf,co_inf)
br_origem:colorspec := drvcorbox+","+INVCOR(drvcorbox)+","+drvcorenf+","+drvcorget+","+drvcorhlp
br_w = br_origem
CABBRW()                                      // monta cabecalho da consulta
tit_cons[1]=sistema[op_sis,O_MENS]            // titulo da janela
nao_vdbf=IF(nao_vdbf=NIL,.t.,nao_vdbf)        // trata parametro
IF !nao_vdbf                                  // veio do VDBF()
 _pesq=drvpvdbf                               // coloca pesquisa como default
ENDI
IF !LDBEDIT(nao_vdbf)                         // menu de consultas gravadas
 RETU NIL
ENDI
col_cp:=col_tit := NIL
tb = {{K_DOWN,      {||br_w:down()}},;        // vetor contendo as teclas
      {K_UP,        {||br_w:up()}},;          // e suas acoes
      {K_PGDN,      {||br_w:pagedown()}},;
      {K_PGUP,      {||br_w:pageup()}},;
      {K_CTRL_PGUP, {||br_w:gotop()}},;
      {K_CTRL_PGDN, {||br_w:gobottom()}},;
      {K_RIGHT,     {||br_w:right()}},;
      {K_LEFT,      {||br_w:left()}},;
      {K_HOME,      {||br_w:home()}},;
      {K_END,       {||br_w:end()}},;
      {K_CTRL_LEFT, {||br_w:panleft()}},;
      {K_CTRL_RIGHT,{||br_w:panright()}},;
      {K_CTRL_HOME, {||br_w:panhome()}},;
      {K_CTRL_END,  {||br_w:panend()}};
     }
volta_db=.t.
MONTABRW()                                    // inicializa tbrowse
DO WHILE volta_db
 SETCOLOR(drvcorbox)
 SET CURSO OFF                                // apaga cursor da tela
 DO WHILE !br_w:stabilize() .AND. NEXTKEY()=0 // apresenta dados na tela
 ENDD
 x_ = COL() ; y_ = ROW()                      // salva posicao atual do cursor
 READINSERT(.f.)                              // retira o "insert"
 t = SUBS(mold,2,1)
 msg=IF(_pesq,"{*Procura*}",IF(EMPTY(criterio),"{Qde="+LTRIM(STR(RECC(),10))+"}",""))
 @ br_w:ntop-2,br_w:nleft SAY LEFT(msg+REPL(SUBS(mold,2,1),11),11)
 IF br_w:nleft+22<br_w:nright                 // msg no canto superior esquerdo
  @ br_w:ntop-2,br_w:nleft+12 SAY IF(DELE(),"{Exclu¡do}",REPL(t,10))
 ENDI
 IF br_w:nleft+31<br_w:nright                 // msg inicio/fim de arq no centro
  msg=IF(br_w:hittop,"{In¡cio}",IF(br_w:hitbottom,"{Final}"+t,REPL(t,8)))
  @ br_w:ntop-2,br_w:nleft+23 SAY msg
 ENDI
 IF br_w == br_origem .AND. br_w:stable       // esta na janela superior
  IF MOSTRA_RELA()                            // e' preciso refazer janela de baixo
   FORCABRW(.f.)                              // entao vamos la...
  ENDI
 ENDI
 IF LEN(st_pesq)>0                            // se esta pesquisando
  SEPARA(br_w:getcolumn(br_w:colpos):cargo)   // separa nome do campo
  IF LEN(st_pesq) <= br_w:getcolumn(br_w:colpos):width // da p/ imprimir...
   i_=SETCOLOR(drvcorenf)                     // coloca cor enfatizada
   t=1
   l_m=TRAN(&cp_.,cp_masc)                    // conteudo da coluna
   FOR j=1 TO LEN(l_m)                        // ajustando com a mascara
    IF SUBS(st_pesq,t,1)=SUBS(l_m,j,1)        // vamos ver quantos
     t++                                      // caracteres vamos colorir...
     IF t>LEN(st_pesq)                        // chegamos ao fim da pesquisa
      @ y_,x_ SAY LEFT(l_m,j)                 // imprime colorido
      EXIT
     ENDI
    ENDI
   NEXT
   SETCOLOR(i_)                               // volta para cor normal
  ENDI
 ENDI
 cod_sos=hlp_cod

 #ifdef COM_MOUSE
  tecl_p=MOUSETECLA(br_w:ntop-1,br_w:nleft-1,; // aguarda com controle de mouse
                    br_w:nbottom+1,br_w:nright+1,.f.;
         )
  MOUSEGET(@li,@co)                            // salva posicao atual do mouse
  IF tecl_p=CLICK                              // se botao esquerdo foi pressionado
   t=br_w:rowpos; colpos_=br_w:colpos          // salva linha/coluna atual
   br_w:dehilite(); tecl_p=0                   // desliga cursor do browse
   br_w:rowpos:=t+li-y_                        // linha do clique
   FOR i=br_w:rightvisible TO br_w:leftvisible STEP -1
    br_w:dehilite()                            // deliga/liga cursor da coluna para
    br_w:colpos:=i                             // pegar as nova coordenadas do cursor
    br_w:hilite()
    IF COL()-1<=co                             // a coluna do clique e' esta?
     tecl_p=1                                  // flag fim da procura
     EXIT                                      // e sai do FOR...
    ENDI
   NEXT
   IF tecl_p=0 .AND. Br_w:freeze>0             // se ainda nao achou a coluna
    FOR i=br_w:freeze TO 1 STEP -1             // verifica se esta' nas colunas
     br_w:dehilite()                           // congeladas
     br_w:colpos:=i
     br_w:hilite()
     IF COL()-1<=Co                            // achamos a coluna do clique
      EXIT
     ENDI
    NEXT
   ENDI
   IF t=br_w:rowpos .AND. colpos_=br_w:colpos  // clicou duas vezes na mesma
    KEYB CHR(77)                               // coluna entao forca modificacao
   ENDI
   tecl_p=0                                    // nao faz nada
  ENDI
 #else

  #ifdef COM_REDE
   tecl_p=IN_KEY(drvtempo)                    // espera tecla ser digitada
  #else
   tecl_p=IN_KEY(0)                           // espera tecla ser digitada
  #endi

 #endi

 #ifdef COM_REDE
  IF tecl_p=0                                  // nao teclou nada, sai pelo
   br_w:refreshall()                           // tempo de "refresh" entao
   FORCABRW(.f.)                               // forca reimpressao dos dados
   LOOP                                        // na tela e volta
  ENDI
 #endi

 IF SETKEY(tecl_p)!=NIL .AND. tecl_p!=K_F3     // executa funcao associada a
  EVAL(SETKEY(tecl_p))                         // tecla digitada se existir
  tecl_p=0                                     // nao faz mais nada
 ENDI
 SET CURSO ON                                  // acende o cursor
 nm = ASCAN(tb,{|ve_a| tecl_p = ve_a[1]})      // verifica se tecla esta
 IF nm != 0                                    // no vetor de teclas progamadas
  st_pesq := ""                                // limpa pesq por palavra
  IF tb[nm,2]!=NIL                             // em caso afirmativo,
   EVAL(tb[nm,2])                              // executa a funcao definida para
  ENDI                                         // a tecla
 ELSE
  br_w:dehilite()                              // apaga barra cursora
  nao_pesq=.f.                                 // flag - tudo normal
  IF tecl_p=K_F10
   st_pesq := ""                               // limpa pesq por palavra
   SET CURS OFF                                // desliga cursor
   tbmenu="PFDMERVNAIOQL"+IF(fg_loc,"S","")+;
          "GCTJXZB"

   #ifdef COM_REDE
    tbmenu+="+-"                               // teclas de "refresh"
   #endi

   l_m=exrot[op_sis]                           // senhas nao tem rotinas
   l_m=RTRIM(mo_dif+l_m)                       // para serem retiradas
   FOR i=1 TO LEN(l_m)                         // retira rotina que o usuario
    tbmenu=STRTRAN(tbmenu,SUBS(l_m,i,1),"")    // nao pode acessar e monta menu
    tbmenu=STRTRAN(tbmenu,SUBS(l_m,i,1),"")    // nao pode acessar e monta menu
   NEXT                                        // com as rotinas disponiveis
   msg =IF(AT("P",tbmenu)>0,"P. Procura determinado registro  ÿ|","")
   msg+=IF(AT("F",tbmenu)>0,"F. Filtragem (seleciona/ordena)  ÿ|","")
   msg+=IF(AT("D",tbmenu)>0,"D. Digita‡„o - inclui registros  ÿ|","")
   msg+=IF(AT("M",tbmenu)>0,"M. Modifica conte£do do campo    ÿ|","")
   msg+=IF(AT("E",tbmenu)>0,"E. Exclui (marca apagamento)     ÿ|","")
   msg+=IF(AT("R",tbmenu)>0,"R. Recupera (desmarca apagamento)ÿ|","")
   msg+=IF(AT("V",tbmenu)>0,"V. Vˆ todo o registro na tela    ÿ|","")
   msg+=IF(AT("N",tbmenu)>0,"N. Nova coluna                    |","")
   msg+=IF(AT("A",tbmenu)>0,"A. Apaga coluna do cursor        ÿ|","")
   msg+=IF(AT("I",tbmenu)>0,"I. Imprime a consulta            ÿ|","")
   msg+=IF(AT("O",tbmenu)>0,"O. Ordena os registros           ÿ|","")
   msg+=IF(AT("Q",tbmenu)>0,"Q. Quantifica registros          ÿ|","")
   msg+=IF(AT("L",tbmenu)>0,"L. Localiza um registro          ÿ|","")
   msg+=IF(AT("S",tbmenu)>0,"S. Seguinte - localiza seguinte  ÿ|","")
   msg+=IF(AT("G",tbmenu)>0,"G. Global - processa os registrosÿ|","")
   msg+=IF(AT("C",tbmenu)>0,"C. Congela/descongela colunas    ÿ|","")
   msg+=IF(AT("T",tbmenu)>0,"T. Tamanho - muda tamanho coluna ÿ|","")
   msg+=IF(AT("J",tbmenu)>0,"J. "+IF(outro_db=NIL,"Janela - abre uma nova janela ÿ|","Janela - troca de janelas     ÿ|"),"")
   msg+=IF(AT("X",tbmenu)>0,"X. eXporta dados (TXT, SDF, DBF) ÿ|","")
   msg+=IF(AT("Z",tbmenu)>0,"Z. totaliZa coluna (se num‚rica) ÿ|","")
   msg+=IF(AT("B",tbmenu)>0,"B. estaBelece condi‡„o para marcar|","")

   #ifdef COM_REDE
    msg+=IF(AT("+",tbmenu)>0,"+. +5 seg na remontagem da tela  ÿ|","")
    msg+=IF(AT("-",tbmenu)>0,"-. -5 seg na remontagem da tela  ÿ|","")
   #endi

   msg=LEFT(msg,LEN(msg)-1)                     // tira pipe do final da msg
   msgt="OP€™ES   -   F3=Pesquisa|ALT-F10=excluidos, ALT-Z=zoom, ALT-G=grava"
   op_db=DBOX(msg,,,E_MENU,,msgt,,,op_db)       // escolhe a rotina
   IF op_db = 0                                 // cancelou...
    LOOP
   ENDI
   tecl_p = ASC(SUBS(tbmenu,op_db,1))           // pega o ASC
   IF SUBS(tbmenu,op_db,1)="L"                  // se escolheu "localiza", entao ajusta
    op_db++                                     // default para o continua
   ENDI
   SET CURSO ON                                 // acende o cursor
   nao_pesq=.t.                                 // assume acao da opcao escolhida
  ELSEIF tecl_p = K_F9                          // ve outros arquivos
   st_pesq := ""                                // limpa pesq por palavra
   IF !M->v_out                                 // se tem permissao
    l_sup=li_sup; l_inf=li_inf                  // salva coordenadas da janela
    c_sup=co_sup; c_inf=co_inf
    m_od=mo_dif                                 // salva rotinas acessadas e
    br_w1 := br_w                               // o objeto browse atual
    VEOUTROS()                                  // escolhe arquivo a consultar
    br_w := br_w1                               // restaura o browse
    br_w:configure()                            // remonta titulo da colunas
    volta_db=.t.
    li_sup=l_sup; li_inf=l_inf                  // restaura as coordenadas da
    co_sup=c_sup; co_inf=c_inf                  // janela e
    mo_dif=m_od                                 // rotinas acessadas
    br_w:refreshall()                           // refaz os dados na tela
    FORCABRW(.f.)                               // forca browse do 2a. janela (se existir)
    MONTABRW()                                  // remonta as bordas da janela
   ELSEIF tem_t                                 // transfere o campo para o get pendente
    IF nao_vdbf                                 // se nao veio do VDBF()
     SEPARA(br_w:getcolumn(br_w:colpos):cargo)  // separa atrib coluna e transf p/ caracter
     IF tp_cp="D"
      msg=STRTRAN(DTOC(&cp_.),"/")
     ELSE
      msg=TRANSCAMPO(.t.,cp_)
     ENDI
     KEYB ALLTRIM(msg)                          // coloca campo no buffer do teclado
    ENDI
    volta_db=.f.
   ENDI
  ELSEIF tecl_p = K_ALT_F10                     // ALT-F10 esconde e mostra os
   st_pesq := ""                                // limpa pesq por palavra
   SET(_SET_DELETED,!SET(_SET_DELETED))         // registros excluidos na consulta
   IF DELE() .AND. SET(_SET_DELETED)            // registro esta apagado
    MOV_PTR(1)                                  // acha o 1o. reg nao apagado
   ENDI
   br_w:refreshall()                            // remonta os dados do browse
   br_w:forcestable()                           // apresenta os dados
   br_w:refreshcurrent()                        // refaz so' a linha do browse
   FORCABRW(.f.)

  ELSEIF tecl_p = K_F3                          // liga/desliga pesquisa
   _pesq=(!_pesq)                               // troca flag
   cond_p:=st_pesq := ""                        // inicializa var de pesq
   tecl_p=0                                     // nao faz mais nada
   IF nao_vdbf                                  // se nao veio do VDBF()
    drvpesq=_pesq
   ELSE
    drvpvdbf=_pesq
   ENDI
   SAVE TO (arqconf) ALL LIKE drv*              // salva configuracao

  ELSEIF tecl_p = K_ALT_G                       // grava a consulta em arquivo
   st_pesq := ""                                // limpa pesq por palavra
   t=ALIAS()                                    // salva arquivo corrente
   br_w1 := br_w                                // e browse atual
   SELE (m_origem)                              // selecion dbf da janela de cima
   cod_sos=22                                   // novo codigo de help
   db_aqcom=PADR(br_tit,58)                     // default para o titulo a gravar
   ALERTA(2)                                    // solicita o titulo para a consulta
   db_aqcom=DBOX("Identifique-a para grava‡„o. ESC cancela",,,,,"GRAVA CONSULTA",db_aqcom)
   db_aqcom=ALLTRIM(db_aqcom)                   // tira brancos do nome
   IF LASTKEY()!=K_ESC.AND.!EMPT(db_aqcom)      // se nao cancelou...
    pas = "1"                                   // grava paramenetros das duas janelas
    br_w = br_origem                            // vai para janela de cima
    db_outro=IF(outro_db=NIL,"",ALIAS(VAL(outro_db)))
    db_indrela=ind_rela                         // indice utilizado para relacionar
    db_qprg=qual_prg                            // prg chamador
    DO WHILE .t.
     db_&pas.qtdc=br_w:colcount                 // numero de colunas
     FOR i=1 TO db_&pas.qtdc                    // para cada coluna
      tt=RIGHT(STR(100+i,3),2)
      db_&pas.carg&tt.= br_w:getcolumn(i):cargo // (conteudo,mascara,titulo,pre-val,valida,tipo)
      db_&pas.tam&tt. = br_w:getcolumn(i):width // tamanho da coluna
     NEXT
     id_carg = br_w:cargo                       // situacao do browse
     db_&pas.expo=id_carg[2]                    // ordem
     db_&pas.arqf=id_carg[1]                    // filtro
     db_&pas.chvr=id_carg[3]                    // relacionamento, outra janela
     db_&pas.ind_ord=id_carg[4]                 // indice atual
     db_&pas.cmr=id_carg[5]                     // marcacao de registros
     db_&pas.freeze=br_w:freeze                 // coluna congelada
     IF pas = "1" .AND. br_outro != NIL         // tem outra janela aberta?
      pas="2"                                   // salva o mesmo
      SELE (outro_db)                           // para a outra janela
      br_w = br_outro
     ELSE
      EXIT                                      // tudo feito...
     ENDI
    ENDD
    IF br_tit==db_aqcom                         // se for a mesma consulta lida
     aqdbe=br_arq                               // grava no arquivo de mesmo nome
    ELSE                                        // se nao,
     DO WHIL .t.                                // procura um nome para gravar
      hms=TIME()                                // a consulta
      resaq=LEFT(hms,2)+SUBS(hms,4,2)+RIGHT(hms,2)+"."+LEFT(ALIAS(VAL(m_origem)),3)
      aqdbe=drvdbf+"DB"+resaq
      IF ! FILE("&aqdbe.")                      // se achou um
       EXIT                                     // cai fora...
      ENDI
     ENDD
    ENDI
    SAVE ALL LIKE db_* TO (aqdbe)               // salva em disco a consulta
   ENDI
   SELE (t)                                     // volta para a area anterior
   br_w := br_w1                                // e browse atual

  ELSEIF tecl_p = K_ALT_F8                      // ALT-F8 rola a janela
   st_pesq := ""                                // limpa pesq por palavra
   li_sup-=2; co_sup--                          // ajusta coordenadas e
   li_inf++; co_inf++                           // executa a rolagem da janela
   MUDA_PJ(@li_sup,@co_sup,@li_inf,@co_inf,brw_fundo,.t.)
   li_sup+=2; co_sup++                          // reajusta as coordenadas
   li_inf--; co_inf--
   PUBL &vr_edita.:=STR(li_sup,2)+STR(co_sup,2) // publica variaves que contem
   SAVE TO (arqconf) ALL LIKE drv*              // as coordenadas da janela e
   REST FROM (arqconf) ADDI                     // grava em disco
   br_origem:ntop   := li_sup                   // ajusta browse com
   br_origem:nleft  := co_sup                   // as novas coordenadas
   br_origem:nbottom:= li_inf
   br_origem:nright := co_inf
   IF br_outro != NIL                           // se existe outra janela aberta
    M->tp=li_sup+INT((li_inf-li_sup-1)/2)+1     // ajusta as coordenadas dela
    br_origem:nbottom:=M->tp-2                  // tambem
    br_outro:ntop   := M->tp+1
    br_outro:nleft  := co_sup
    br_outro:nbottom:= li_inf
    br_outro:nright := co_inf
    FORCABRW(.f.)                               // reimprime dados na tela
   ENDI
  ENDI
  carac_ = UPPER(CHR(tecl_p))                   // escolheu uma rotina...
  l_m=exrot[op_sis]                             // arq de senhas nao tem restricoes
  IF _pesq .AND. !nao_pesq .AND. tecl_p>31      // que pesquisar....
   IF AT("L",mo_dif+l_m)>0                      // se usuario nao tem permissao
    LOOP                                        // nao deixa executar
   ENDI
   SEPARA(br_w:getcolumn(br_w:colpos):cargo)    // separa atributos da coluna
   brw_tela = SAVESCREEN(0,0,MAXROW(),79)       // salva tela atual
   st_pesq+=carac_                              // contatena letra dig com que ja existe
   IF tp_cp=="C"                                // carater concatena com aspas
    cond_p="LTRIM("+cp_+")='"+st_pesq+"'"
   ELSEIF tp_cp=="N"                            // numerico
    cond_p="LTRIM(STR("+cp_+"))='"+st_pesq+"'"  // tira os brancos da frente
    i=AT(".",cp_masc)
    IF i=0
     i=LEN(cp_masc)+1
     j=0
    ELSE
     j=LEN(cp_masc)-i
    ENDI
    cp_="STR("+cp_+","+LPAD(i-1,2,"0")+","+LPAD(j,2,"0")+")"
   ELSEIF tp_cp=="D"                            // campo data
    cond_p="STRTRAN(DTOC("+cp_+"),'/')='"+st_pesq+"'"  // tranforma para char antes de testar
   ELSE                                         // tipo sem pesquisa...
    cond_p:=st_pesq := ""
   ENDI
   IF LEN(cond_p)>2                             // tem condicao para pesquisa
    ind_ok=0                                    // verifica se tem um indice pela coluna
    IF tp_cp=="N" .OR. tp_cp=="C" .OR. tp_cp=="D"               // no seek vamos aceitar so data ou caracter
     FOR t=1 TO LEN(sistema[op_sis,O_INDIC])    // corre todos os indices do dbf
      IF UPPE(INDEXKEY(t))=UPPE(cp_)            // indice = a coluna
       ind_ok=t                                 // vamos usa'-lo
       EXIT
      ENDI
     NEXT
    ENDI
    x_=IF(EMPT(criterio),"","T")                // tem filtro?
    IF LEN(chv_rela)>0                          // se tem relacao pesq somente nela
     x_=x_+chv_1                                // chave de relacionamento
    ENDI
    brw_reg=RECN()                              // registro atual
    IF ind_ok=0
     IF LEN(st_pesq)=1                          // 1a. vez
      INI_ARQ()                                 // move ponteiro para o inicio do arquivo
      br_w:rowpos=1                             // posicao da barra seletora
      br_w:refreshall()                         // forca atualizacao da tela
      br_w:forcestable()                        // apresenta os dados
     ENDI
     cur_atual=SETCURSOR(0)                     // salva/apaga cursor
     POE_GAUGE("Pesquisando...|ESC interrompe","AGUARDE...","Processados:")
     IF LEN(x_)>0                               // se tem relacao pesq somente nela
      LOCA FOR &cond_p. WHIL IN_KEY()!=K_ESC .AND. POE_GAUGE() .AND. &(INDEXKEY(0))=x_ // tenta localizar registro desejado
     ELSE
      LOCA FOR &cond_p. WHIL IN_KEY()!=K_ESC .AND. POE_GAUGE() // tenta localizar registro desejado
     ENDI
     ind_ok=(FOUND() .AND. IF(LEN(x_)>0,&(INDEXKEY(0))=x_,.t.)) // achou?
    ELSE
     i=ind_ok                                    // salva indice atual
     ind_ok=PTAB(st_pesq,ALIAS(),ind_ok)         // tenta achar...
     IF ind_ok                                   // achou?
      IF IF(LEN(x_)>0,&(INDEXKEY(0))=x_,.t.)=.f. // esta dentro do filtro
       p=INDEXORD()                              // ordem atual
       DBSETORDER(i)                             // seta ordem do indice
       DO WHILE !EOF()                           // verifica se o proximo
        IF &cond_p.                              // esta dentro da condicao
         IF IF(LEN(x_)>0,&(INDEXKEY(p))=x_,.t.)  // e filtro
          ind_ok=.t.                             // tudo ok
          EXIT
         ENDI
        ELSE                                     // nao encontrou
         ind_ok=.f.                              // cai fora
         EXIT
        ENDI
        SKIP
       END
       DBSETORDER(p)         // volta ordem do indice
      ENDI
     ENDI
    ENDI
    IF !ind_ok .AND. LEN(st_pesq)>0             // nao achou?
     ALERTA(1)                                  // aviso sonoro
     st_pesq=LEFT(st_pesq,LEN(st_pesq)-1)       // descarta caracter digitado
     ind_ok=.t.
     GO brw_reg                                 // volta para o registro que estava
    ENDI
    SETCURSOR(cur_atual)                        // retorna o cursor ao normal
    IF !ind_ok.OR.LASTKEY()=K_ESC               // nao achou ou cancelou
     cond_p:=st_pesq := ""                      // limpa variavies
    ENDI
    IF !ind_ok                                  // nao achou...
     br_w:gobottom()                            // acha o ultimo reg do arq
     KEYB CHR(K_PGDN)
    ELSE
     br_w:rowpos = 1
    ENDI
    br_w:configure()                               // forca atualizacao da tela
    RESTSCREEN(0,0,MAXROW(),79,brw_tela)        // restaura tela anterior
   ENDI
   carac_=""
   tecl_p=0
  ELSE
   IF AT(carac_,"ERMG")>0 .AND. (RECC()=0 .OR.; // nao permite alterar um
      IF(EMPTY(criterio),.f.,!&criterio.))      // arquivo vazio ou
    LOOP                                        // fora do filtro
   ENDI
   IF AT(carac_,mo_dif+l_m)>0                   // se usuario nao tem permissao
    LOOP                                        // nao deixa executar
   ENDI
   IF AT(carac_,"DERMGV")>0 .AND.;              // se vai alterar um registro
      LEN(sistema[op_sis,O_CPRELA])>0           // e se e' um filho
    i=.t.                                       // flag - vai relacionar com o pai
    IF br_outro!=NIL .AND. EOF()                // se for janela de baixo e nao tem registros
     IF br_w==br_outro                          // e esta na janela de baixo
      x_=AT("->",sistema[op_sis,O_CPRELA,1])-1  // separador de arquivo->campo
      x_=LEFT(sistema[op_sis,O_CPRELA,1],x_)    // pega o nome do pai
      IF ALIAS(VAL(m_origem))!=x_               // se janela de cima nao for o pai
      ALERTA(2)                                 // nao pode incluir!
        DBOX("Inclus„o n„o permitida!",,,3)     // mensagem ao usuario
       LOOP                                     // e retorna ao browse
      ELSE
       i=.f.                                    // flag - nao vai relacionar com o pai
      ENDI
     ENDI
   ENDI
    IF i                                        // vai relacionar?
     POSIPAI()                                  // abre/posiciona seus pais
    ENDI
   ENDI
  ENDI
  DO CASE

   #ifdef COM_REDE
    CASE (tecl_p=43 .OR. tecl_p=45)             // teclou + ou - para mudar o "refresh"
     DO WHILE .T.
      msg=LTRIM(STR(drvtempo))
      msg=IF(drvtempo=0,"N„o",msg+" seg")       // tempo=0 nao tem "refresh"
      ALERTA(1)
      DBOX(msg,,,25,,"'REFRESH`|(+/-)")         // mostra msg do tempo atual
      IF LASTKEY()=43                           // teclou +, entao
       drvtempo=IF(drvtempo>57,60,drvtempo+5)   // aumenta o tempo em 5 seg
      ELSEIF LASTKEY()=45                       // teclou -, entao
       drvtempo=IF(drvtempo<1,0,drvtempo-5)     // diminui o tempo em 5 seg
      ELSE                                      // teclou algo diferente de + e -
       EXIT                                     // entao aceita refresh atual
      ENDI
     ENDD
   #endi


   CASE tecl_p = K_ENTER                        // teclou o ENTER
    IF nao_vdbf                                 // nao veio do VDBF() o ENTER movimentara'
     KEYB CHR(VAL(SUBS(ch_tecl,dir_cur*2-1,2))) // para onde a SETA (TAB) esta apontando
    ELSE                                        // caso contrario,
     volta_db=.f.                               // retorna falso
    ENDI

   CASE tecl_p = K_TAB                          // teclou o TAB
    dir_cur()                                   // muda direcao do cursor

   CASE tecl_p = K_ALT_Z .AND. !db_zoom         // aumenta o tamanho da janela
    li_sup=3; li_inf=22; co_sup=3; co_inf=77    // coordenadas da janela expandida
    br_origem:nTop   := li_sup                  // passa as novas coordenadas
    br_origem:nbottom:= li_inf                  // para o browse de cima
    br_origem:nleft  := co_sup
    br_origem:nright := co_inf
    IF br_outro != NIL                          // existe a janela de baixo
     M->tp=li_sup+INT((li_inf-li_sup-1)/2)+1    // linha de divisao das janelas
     br_origem:nbottom := M->tp - 2             // final da janela de cima
     br_outro:nTop   := M->tp+1                 // topo da jenela de baixo
     br_outro:nbottom:= li_inf                  // ajusta o resto das
     br_outro:nleft  := co_sup                  // coordenadas
     br_outro:nright := co_inf
    ENDI
    db_zoom:=.t.                                // flag dizendo do zoom
    FORCABRW(.t.)                               // reimprime janela nao ativa
    MONTABRW()                                  // remonta janela

   CASE tecl_p = K_F1                           // teclou F1
    help()                                      // mostra ajuda correspondente

   CASE tecl_p = K_ESC                          // teclou ESC
    volta_db=.f.                                // abandona a consulta

   CASE carac_="A" .AND. br_w:colcount > 1      // apaga consulta se mais de 1 coluna
    ALERTA(2)                                   // pede confirmacao
    msg="Apagar a coluna|Cancelar a opera‡„o"
    cod_sos=1
    op_=DBOX(msg,,,E_MENU,,"COLUNA "+MAIUSC(br_w:getcolumn(br_w:colpos):heading))
    IF op_=1                                    // confirmou...
     br_w:delColumn(br_w:colpos)                // retira a coluna do browse
     grava_db = .t.                             // seta flag de consulta alterada
     br_w:configure()                           // remonta todo browse
    ENDI

   CASE carac_="B"                              // estabelece condicao de marcacao de reg
    cri_ant = criterio                          // salva filtro atual
    cmr_ant = cmr_                              // salva cond de marcacao atual
    FILTRA(.f.)                                 // monta expressao de pesquisa
    cmr_=criterio                               // condicao de marcacao
    criterio = cri_ant                          // retorna filtro atual
    IF EMPTY(cmr_)                              // tirou marcacao
     cmr_="1=2"                                 // nemhum sera marcado
    ENDI
    IF cmr_!=cmr_ant                            // mudou condicao de marcacao
     br_w:cargo := {criterio,cpord,chv_rela,INDEXORD(),cmr_}
     FOR i=1 TO br_w:colcount                   // atualiza as cores das colunas
      br_w:getcolumn(i):colorblock=&("{||IF(DELE(),{3,2},IF("+cmr_+",{5,2},{1,2}))}")
     NEXT
     br_w:refreshall()                          // reapresenta os dados na tela
    ENDI

   CASE carac_="C" .AND.;                       // congela/descongela coluna se
        br_w:colpos-1 != br_w:freeze            // a coluna ja' congelada
    IF br_w:freeze != 0                         // se outra coluna ja' congelada
     br_w:getcolumn(br_w:freeze+1):colsep:=NIL  // retira o marcador da coluna congelada
    ENDI
    br_w:freeze := br_w:colpos - 1              // congela coluna requerida
    IF br_w:freeze != 0                         // se nao descongelou todas colunas
     br_w:getcolumn(br_w:colpos):colsep:=" Û "  // coloca marcador de colunas congeladas
    ENDI
    br_w:configure()                            // remonta todo browse
    grava_db = .t.                              // seta flag de consulta alterada

   CASE carac_="D"                              // inclusao de registros
    dele_atu=SET(_SET_DELETED,!drvvisivel)      // salva DELE() atual,
    br_w1 := br_w                               // browse atual,
    brw_tela = SAVESCREEN(0,0,MAXROW(),79)      // tela atual e o
    in_=INDEXORD()                              // salva indice atual para incluirmos
    DBSETORDER(1)                               // seta 1 indice para incluirmos
    brw=.f.
    Tela_fundo=SAVESCREEN(0,0,MAXROW(),79)      // salva pano de fundo para ALT-F8
    t_f8=SETKEY(K_F8,NIL)                       // salva/reseta tecla F8
    cp_exp:={}                                  // enche vetor com relacoes atuais
    i_=1                                        // pega todas relacoes que existir
    DO WHILE LEN(DBRELATION(i_))>0
     AADD(cp_exp,{DBRELATION(i_),ALIAS(DBRSELECT(i_))}) // adiciona ao vetor temporario
     i_++
    ENDD
    SET RELA TO                                 // retira todas as relacoes
    &arq_cor._incl()                            // inclusao de novos registros de dados
    FOR i_=1 TO LEN(cp_exp)                     // coloca todos as relacoes anteriores
     dli_exp=cp_exp[i_,1]                       // expresao de ligacao
     arqexp=cp_exp[i_,2]                        // dbf de ligacao
     SET RELA ADDI TO &dli_exp. INTO &arqexp.   // recoloca a relacao
    NEXT
    SETKEY(K_F8,t_f8)                           // seta tecla F8
    op_menu=PROJECOES; brw=.t.                  // volta para consulta
    DBSETORDER(in_)                             // retorna ao indice da consulta
    REGINICIO()                                 // verifica se reg esta' no filtro
    RESTSCREEN(0,0,MAXROW(),79,brw_tela)        // restaura a tela,
    SET(_SET_DELETED,dele_atu)                  // DELE() e o
    br_w := br_w1                               // browse anteriores
    br_w:refreshall()                           // reapresenta os dados na tela
    FORCABRW(.f.)                               // forca remontagem da janela relacionada
    MONTABRW()

   CASE carac_="E"                              // exclui registro

    #ifdef COM_REDE
     IF !BLOREG(10,.5)                          // tenta bloquear o arquivo
      LOOP                                      // nao conseguiu...
     ENDI
    #endi

    IF ! DELE()                                 // ja esta excluido?
     IF CONFEXCL()                              // pede confirmacao
      &arq_cor._get1(EXCLUI)                    // exclui registro/processo inverso
      br_w:refreshall()                         // remonta os reg da tela
      FORCABRW(.f.)                             // remonta janela relacionada
     ENDI
    ENDI

    #ifdef COM_REDE
     UNLOCK                                     // libera o registro
    #endi

    IF DELE() .AND.SET(_SET_DELETED)            // se nao que ver excluidos
     MOV_PTR(1)                                 // procura o proximo que
    ENDI                                        // nao esteje excluido

   CASE carac_="F" .OR. carac_="Q"              // filtra/quantifica
    cri_ant = criterio
    IF carac_="F"                               // filtra
     FILTRA(.t.,.t.)                            // escolhe o filtro
     br_w:cargo := {criterio,cpord,chv_rela,INDEXORD(),cmr_}
     br_w:refreshall()                          // refaz toda a tela
     IF cri_ant!=criterio.AND.!EMPTY(criterio)  // se alterou o filtro
      grava_db=.t.                              // seta flag de consulta alterada
     ENDI
    ELSE                                        // quantifica
     FILTRA(.f.)                                // so' monta a expressao
     condq=criterio                             // retorna filtro anterior
     criterio = cri_ant
    ENDI
    brw_reg=RECN()                              // salva registro atual
    IF carac_="Q" .AND. LEN(condq)>2            // continuacao da quantificacao
     brw_tela = SAVESCREEN(0,0,MAXROW(),79)     // da mensagem que esta contando...
     DBOX("Condi‡„o:|"+LEFT(condq,78)+"|| AGUARDE...  Contando. ESC cancela",,,,NAO_APAGA)
     INI_ARQ()                                  // move ponteiro para o inicio do arquivo

     COUN FOR &condq WHIL IN_KEY()!=K_ESC TO qu// conta....

     IF LASTKEY()!=K_ESC                        // nao cancelou entao mostra
      ALERTA(2)                                 // quantos reg foram contados
      DBOX("Existe(m) "+LTRIM(TRAN(qu,"@E 9,999,999"))+" registro(s)|na condi‡„o|"+LEFT(condq,78)+"|*",8)
     ENDI
     RESTSCREEN(0,0,MAXROW(),79,brw_tela)       // restaura a tela anterior e
     GO brw_reg                                 // o registro
    ENDI
    MONTABRW()                                  // remonta janela de visualizacao

   CASE carac_="G"                              // processo glogal
    brw_tela = SAVESCREEN(0,0,MAXROW(),79)      // salva situacao atual
    brw_reg = RECNO()
    GLOBAL()                                    // executa processo
    GO brw_reg                                  // restabelece situacao anterior
    REGINICIO()                                 // verifica se reg esta' no filtro
    br_w:cargo := {criterio,cpord,chv_rela,INDEXORD(),cmr_}
    br_w:refreshall()                           // remonta dados da tela
    RESTSCREEN(0,0,MAXROW(),79,brw_tela)        // restaura tela
    MONTABRW()                                  // remonta janela do browse

   CASE carac_="I"                              // imprime consulta
    IMP_BRW()

   CASE carac_="J" .AND. br_outro != NIL        // troca janela de consulta
    TROCA_BRW()                                 // troca arquivo do browse
    br_w:colorspec := drvcorbox+","+INVCOR(drvcorbox)+","+drvcorenf+","+drvcorget+","+drvcorhlp
    FORCABRW(.t.)                               // troca as cores da janela
    MONTABRW()                                  // remonta dados e a
    br_w:hilite()                               // janela com a nova cor

   CASE carac_="J"                              // abre uma nova janela
    msg=""; op_a=0; db=""
    pp=SETKEY(K_F9,NIL)                         // desliga F9 (consulta outro DBF)
    FOR i=1 TO nss                              // monta menu de DBF disponiveis
     IF sistema[i,O_OUTROS,O_NIVEL]<=nivelop .AND.;
        LEN(sistema[i,O_INDIC])>0
      msg+="|"+sistema[i,O_MENU]
      db+=RIGHT(STR(1000+i),3)
     ENDI
    NEXT
    cod_sos=30
    IF LEN(msg)>1                               // escolhe o DBF da nova janela
     op_a=DBOX(SUBS(msg,2),,,E_MENU,,"BASES DE DADOS")
    ENDI
    IF op_a>0                                   // escolheu...
     op_a=VAL(SUBS(db,op_a*3-2,3))              // acha a sua subscricao
     op_sis_x=op_sis                            // salva subscricao atual
     SETCOLOR(drvcortna)
     IF abreoutro(op_a)                         // e abre a outra janela
      grava_db = .t.                            // flag de consulta alterada
      tit_cons[2]=sistema[op_sis,O_MENS]        // titulo da segunda janela
      IF op_sis_x != op_sis
       op_ind=1                                 // indice 'default`
       qt_ind=LEN(sistema[op_sis,O_INDIC])      // qde de indices do arquivo
       chv=ATAIL(sistema[op_sis,O_CHAVE])       // pega ultimo elemento das chaves
       IF chv=="codlan"                         // se e' ntx de relacionamento nao pode
        qt_ind--
       ENDI
       IF qt_ind>1                              // escolheum conjunto de indice
        msg=""
        FOR t=1 to qt_ind
         msg+="|"+sistema[op_sis,O_CONSU,t]
        NEXT
        op_ind=DBOX(SUBS(msg,2),,,E_MENU,,"SELECIONE O INDICE")
        IF op_ind>1
         ind_rela=ALLTRIM(STR(op_ind))
         DBSETORDER(VAL(ind_rela))
        ENDI
       ENDI
       SELE (m_origem)
       x_=ASCAN(sistema[op_sis_x,O_DBRELA],{|db_|sistema[op_sis,O_ARQUI,O_NOME]=db_})
       i_=LEN(sistema[op_sis,O_CPRELA])         // se DBF escolhido e relacionado,
       IF x_>0.AND.i_>0                         // monta a expressao de relacionamento
        chv_rela=""
        FOR i=1 TO LEN(sistema[op_sis,O_CPRELA])
         chv_rela+="+"+TRANSCAMPO(.f.,sistema[op_sis,O_CPRELA,i],i)
        NEXT
       ELSE                                     // se usuario montar expressao
        PEGARELA(.t.)
       ENDI
       chv_rela=IF(LEN(chv_rela)>2,SUBS(chv_rela,2),"")
       br_outro:cargo := {"","",chv_rela,op_ind}// inicializa variavel de usuario
      ENDI
      criterio:=cpord := ""                     // inicializa filtro/ordenacao
      cmr_="1=2"                                // cond marcacao de registros
      SELE (outro_db)                           // muda para a janela de baixo
      PEGACHV2()                                // pega final do relaciomento
      INI_ARQ()                                 // procura 1o. reg da relacao
      LDBEDIT(.f.)                              // monta as novas colunas
      FORCABRW(.t.)                             // imprime dados da janela de cima
      MONTABRW()                                // monta nova janela de visualizacao
     ELSE
      op_sis = op_sis_x                         // nao conseguiu abrir nova janela
     ENDI
    ENDI
    SETKEY(K_F9,pp)                             // habilita F9 (consulta outros DBFs)

   CASE carac_="L"                              // localiza registro
    SEPARA(br_w:getcolumn(br_w:colpos):cargo)   // separa atributos da coluna
    cod_sos=36
    ecara=(tp_cp=="C".OR.tp_cp=="M")            // tipo do campo
    brw_tela = SAVESCREEN(0,0,MAXROW(),79)      // salva tela atual
    chvpesq=IF(ecara,SPAC(30),IF(tp_cp="D",CTOD(''),IF(tp_cp="L",.t.,0)))
    msg="Argumento - Localiza argumento no campo "+cp_titu+;
        "|Condi‡„o - Localiza registro sob uma condi‡„o"+;
        "|Cancelar a opera‡„o"                  // escolhe o tipo de localizacao
    x=DBOX(msg,,,E_MENU,,SEPLETRA("LOCALIZA€ŽO",1))
    IF x!=0 .AND. x!=3                          // nao cancelou
     cond_p=""
     IF x=1                                     // localiza por argumento
      msg="LOCALIZAR ARGUMENTO "+IF(ecara,"CONTIDO ","")+" EM "+MAIUSC(cp_titu)
      chvpesq=DBOX("Informe o argumento",,,,,msg,chvpesq,cp_masc)
      IF cp_crit=="V" .OR. CRIT(cp_crit,18)     // argumento de pesquisa ok?
       IF (!EMPT(chvpesq) .OR. tp_cp="L").AND.LASTKEY()!=K_ESC
        IF ecara                                // se for caracter
         chvpesq=ALLTRIM(chvpesq)               // deixa localizar so as letras digitadas
         igc=1                                  // se tem minusculo no campo
         IF cp_masc!="@!"                       // pergunta se quer ignorar a caixa
          igc=DBOX("Sim|N„o|Cancelar a opera‡„o",,,E_MENU,,"IGNORAR CAIXA|(A=a)?")
         ENDI
         IF igc=1.OR.igc=2                      // prepara expressao de pesquisa
          cond_p=IF(igc=2,"'"+chvpesq+"' $ "+cp_,"MAIUSC('"+chvpesq+"') $ UPPER("+cp_+")")
         ENDI
        ELSE
         cond_p=cp_+"=chvpesq"                  // prepara expressao de pesquisa
        ENDI
       ENDI
      ENDI
     ELSE                                       // localiza por condicao
      cri_ant = criterio                        // salva filtro atual
      FILTRA(.f.)                               // monta expressao de pesquisa
      cond_p=criterio
      criterio = cri_ant                        // retorna filtro atual
     ENDI
     RESTSCREEN(0,0,MAXROW(),79,brw_tela)       // restaura tela anterior
     IF LEN(cond_p)>2                           // continua a localizar...
      cur_atual=SETCURSOR(0)                    // salva/apaga cursor
      POE_GAUGE("Loczalizando "+LTRIM(TRAN(chvpesq,""))+".|ESC interrompe","AGUARDE...","Processados:")
      brw_reg=RECN()
      INI_ARQ()                                 // move ponteiro para o inicio do arquivo
      IF LEN(chv_rela)>0                        // se tem relacao pesq somente nela
       x_=IF(EMPT(criterio),"","T")+chv_1       // chave de relacionamento
       LOCA FOR &cond_p. WHIL IN_KEY()!=K_ESC .AND. POE_GAUGE() .AND. &(INDEXKEY(0))=x_ // tenta localizar registro desejado
      ELSE
       LOCA FOR &cond_p. WHIL IN_KEY()!=K_ESC .AND. POE_GAUGE() // tenta localizar registro desejado
      ENDI
      SETCURSOR(cur_atual)                      // retorna o cursor ao normal
      IF ! FOUND().AND.LASTKEY()!=K_ESC         // nao achou ou cancelou
       ALERTA(4)
       DBOX("N„o encontrado!|*",13,40)          // mensagem ao usuario
       GO brw_reg
      ELSE
       ALERTA(1)                                // achou...
       fg_loc=.t.                               // sinal sonoro
      ENDI
     ENDI
     br_w:refreshall()                          // remonta os dados da consulta
    ENDI
    RESTSCREEN(0,0,MAXROW(),79,brw_tela)        // restaura tela anterior

   CASE carac_="M"                              // modifica registro
    IF !br_w:stable                             // forca a apresentacao de
     br_w:forcestable()                         // todos os registros na tela
     x_=COL(); y_=ROW()                         // salva coordenadas atuais do cursor
    ENDI
    brw_reg = RECNO()                           // salva registro atual
    SKIP                                        // tenta pegar o proximo reg
    IF EOF() .OR. &(INDEXKEY(0))!=IF(EMPT(criterio),"","T")+chv_1 // esta fora do filtro/relacao
     regseg = -1                                // esta no ultimo reg
    ELSE
     regseg = RECNO()
    ENDI
    GO brw_reg                                  // tenta pegar o reg anterior
    SKIP -1
    IF BOF() .OR. &(INDEXKEY(0))!=IF(EMPT(criterio),"","T")+chv_1 // esta fora do filtro/relacao
     regant = -1                                // esta no 1o. reg
    ELSE
     regant = RECNO()
    ENDI
    GO brw_reg                                  // volta para o reg que estava
    cont_mod=.f.                                // flag - continua modificando?

    #ifdef COM_REDE
     IF !BLOREG(10,.5)                          // tenta bloquear o registro
      LOOP                                      // nao conseguiu...
     ENDI
     blk_="blk_"+ALIAS()
     IF TYPE(blk_)="L"
      blk_a=&blk_.
     ELSE
      blk_a=.f.
     ENDI
     PRIV &blk_.:=.t.
    #endi

    IF !CONFALT()                               // verifica se o registro
     LOOP                                       // pode ser modificado
    ENDI
    SEPARA(br_w:getcolumn(br_w:colpos):cargo)   // separa atributos da coluna
    evirt=(cp_crit=="V")                        // pode modificar?
    IF (AT(UPPER(cp_),UPPER(INDEXKEY(1)))>0.AND.sistema[op_sis,O_OUTROS,O_TPCHV]).OR.;
       evirt.OR.DELE()
     ALERTA()
     DBOX(IF(DELE(),"REGISTRO EXCLU¡DO","CAMPO NŽO EDITVEL"),12,,1)
    ELSE
     &arq_cor._get1(FORM_INVERSA)               // executa processo inverso se existir
     pp=.f.                                     // flag "refresh" na outra janela?
     IF IF(!EMPTY(cp_when).AND.;                // tem pre-validacao. pode modificar?
        !("MTAB(" $ cp_when).AND.!("VDBF(" $ cp_when),EVAL(&("{||"+cp_when+"}")),.t.)
      SETCOLOR(drvcorbox)                       // coloca mensagem no topo da janela
      IF br_w:nleft+22<br_w:nright              // avisando que estamos modificando
       @ br_w:ntop-2,br_w:nleft+12 SAY "{Modifica}"
      ENDI
      ALERTA(1)                                 // Beep!
      IF tp_cp=="M"                             // campo memo...
       EDIMEMO(cp_,cp_titu,15,2,MAXROW()-1,3+VAL(SUBS(cp_masc,3)),cp_crit)
      ELSE
       i = br_w:getcolumn(br_w:colpos):width    // o tamanho atual da coluna
       IF i != LEN(TRAN(&cp_.,cp_masc)) .AND.;  // esta' diferente to tamanho
          tp_cp="C"                             // real do campo estao vamos
        cp_masc="@S"+ALLTRIM(STR(i,3))+IIF(LEFT(cp_masc,1)<>"@"," ","")+cp_masc  // forcar a rolagem do campo
       ENDI
       @ y_,x_ GET &cp_. PICT cp_masc;
                         VALI CRIT(cp_crit);
                         WHEN cp_when
                         AJUDA cp_help
                         CMDF8 cp_cmd
       READ
      ENDI
      IF br_w:nleft+22<br_w:nright              // retira mensagem de alteracao
       @ br_w:ntop-2,br_w:nleft+12 SAY REPL(SUBS(mold,2,1),10)
      ENDI
      IF tp_cp!="M".AND.LASTKEY()!=K_ESC.AND.;  // se o campo nao for memo, nao deu ESC,
         RECNO()=brw_reg                        // nao esta fora do filtro/relacao e
       cont_mod=.t.                             // segue modificando...
      ENDI
     ELSE                                       // nao pode ser modificado
      ALERTA()                                  // mostra por que
      DBOX("Modifica quando "+UPPER(cp_when),,,3,,"PR-CR¡TICA NŽO ATENDIDA!")
     ENDI
     &arq_cor._get1(FORM_DIRETA)                // executa processos/lancamentos
     IF pp                                      // se for preciso, forca
      REGINICIO()                               // verifica se reg esta' no filtro
      FORCABRW(.f.)                             // browse da outra janela
     ENDI
    ENDI

    #ifdef COM_REDE
     UNLOCK                                     // atualiza o disco
     &blk_.:=blk_a
    #endif

    br_w:refreshcurrent()                       // refaz so' a linha do browse
    IF cont_mod                                 // continua modicar?
     i_=VAL(SUBS(ch_tecl,dir_cur*2-1,2))        // proxima posicao do cursor
     IF &(INDEXKEY(0))!=IF(EMPT(criterio),"","T")+chv_1 // esta fora do filtro/relacao
      IF i_=5                                   // vai para o reg de cima
       IF regant>=0                             // exitem um...
        GO regant                               // posiciona nela e forca
        KEYB CHR(i_)+"M"                        // "M" para cont modificando
       ELSE                                     // esta no 1o. reg
        br_w:gotop()                            // acha o top do arq atual
       ENDI
      ELSE                                      // vai para reg seg ou para os lados
       IF regseg>=0                             // tem reg seguinte?
        GO regseg                               // posiciona nele
        KEYB "M"                                // forca "M" no buffer do teclado
       ELSE                                     // ja esta no ultimo
        br_w:gobottom()                         // acha o novo ultimo reg do arq
       ENDI
      ENDI
      br_w:hilite()                             // tira barra cursora da tela
      br_w:refreshall()                         // forca atualizacao da tela
      br_w:forcestable()                        // apresenta os dados
      br_w:dehilite()                           // liga barra cursora
      FORCABRW(.f.)                             // atualiza browse da outra janela
     ELSE                                       // nao esta fora do filtro...
      IF AT(UPPER(cp_),UPPER(INDEXKEY(0))) > 0  // se esta modificando campo do indice
       br_w:hilite()                             // tira barra cursora da tela
       br_w:refreshall()                         // forca atualizacao da tela
       br_w:forcestable()                        // apresenta os dados
       br_w:dehilite()                           // liga barra cursora
       FORCABRW(.f.)                             // atualiza browse da outra janela
      ENDI
      KEYB CHR(i_)+"M"                          // vai para onde o TAB esta indicando
     ENDI
    ENDI

   CASE carac_="N"                              // cria nova coluna
    cod_sos=28
    cp_ =SPAC(250) ; cp_titu=SPAC(30)           // inicializa variveis
    cp_masc=SPAC(30)
    msg="T¡tulo da nova coluna:"
    f10=.f.                                     // recebe titulo da nova coluna
    SET KEY K_F10 TO colnova                    // F10 campo de outro arquivo
    cp_titu=DBOX(msg,,,,,"NOVA COLUNA|*|F10=CAMPO DE OUTRO ARQUIVO",cp_titu)
    SET KEY K_F10 TO                            // desativa F10
    IF LASTKEY()!=K_ESC                         // se nao abandonou e nao teclou
     IF !f10                                    // F10, recebe conteudo da nova coluna
      msg+=" "+ALLTRIM(cp_titu)+"|Express„o conte£do:"
      DO WHILE .t.
       SET KEY K_F10 TO ve_campos               // F10 ve campos da estrutura
       cp_=DBOX(msg,,,,,"NOVA COLUNA|*|F10=CAMPOS DO ARQUIVO",cp_,"@S52@!")
       SET KEY K_F10 TO                         // desativa F10
       IF LASTKEY()!=27 .AND. !EMPTY(cp_)       // verifica se o conteudo e valido
        IF !CRIT("[U]!=TYPE(cp_) .OR. ([|] $ cp_ .AND. [->] $ cp_)~EXPRESSŽO ILEGAL",15)
         LOOP
        ENDI
       ENDI
       EXIT
      ENDD
     ENDI
     IF !EMPT(cp_) .AND. LASTKEY()!=K_ESC      // nao cancelou...
      IF !f10                                  // recebe mascara da nova coluna
       msg+=" "+LEFT(ALLTRIM(cp_),30)+"|Com a m scara:"
       cp_masc=DBOX(msg,,,,,"NOVA COLUNA",cp_masc,"@!")
      ENDI
      IF LASTKEY()!=K_ESC                      // se nao cancelou
       IF SETARELA(cp_)                        // coloca set relation
        IF br_w == br_origem                   // e prepara variavel para
         db_1rela=db_1rela+TRIM(cp_)+"³"       // a gravacao da consulta
        ELSE
         db_2rela=db_2rela+TRIM(cp_)+"³"
        ENDI
        cp_=SUBS(cp_,AT("|",cp_)+1)
       ENDI                                    // cria nova coluna com o que
       ncol = br_w:colpos                      // foi informado
       cp_titu=ALLTRIM(cp_titu) ; cp_=ALLTRIM(cp_) ; cp_masc=ALLTRIM(cp_masc)
       br_w:inscolumn(ncol,tbcolumnnew(cp_titu,&("{||TRAN("+cp_+",["+cp_masc+"])}")))
       br_w:getcolumn(ncol):cargo := cp_+"³"+cp_masc+"³"+cp_titu+"³³V"
       br_w:getcolumn(ncol):width := LEN(TRAN(&cp_.,cp_masc))
       br_w:getcolumn(ncol):colorblock=&("{||IF(DELE(),{3,2},IF("+cmr_+",{5,2},{1,2}))}")
       grava_db = .t.                          // modificou a consulta (flag)
       br_w:refreshall()                       // remonta toda a tela
      ENDI
     ENDI
    ENDI
    SET KEY K_F10 TO                           // desativa F10

   CASE carac_="O"                             // ordenacao da consulta
    cpord=""
    br_wx = br_w                               // salva browse atual
    CLASS(.t.)                                 // recebe expressao de ordenacao
    IF !EMPT(cpord)                            // montou ordenacao?
     br_w:refreshall()                         // refaz toda a tela
     IF INDEXORD()>LEN(sistema[op_sis,O_CHAVE])// se criou indice extra
      grava_db = .t.                           // seta flag de gravacao e
     ENDI                                      // grava a nova ordenacao
     br_w:cargo:={criterio,cpord,chv_rela,INDEXORD(),cmr_}
    ENDI
    MONTABRW()                                 // refaz todo o browse

   CASE carac_="P" .AND. ! EMPT(INDEXKEY(1))   // pesquisa indexada de registro
    brw_reg = RECNO()                          // registro atual
    POSI()                                     // recebe/procura registro
    IF brw_reg != RECNO()                      // se o reg nao e o mesmo,
     br_w:rowpos = 1                           // coloca reg atual na primeira
    ENDI                                       // linha da tela
    br_w:configure()                           // refaz a configuracao do browse

   CASE carac_="R"                             // recupera registro

    #ifdef COM_REDE
     IF !BLOREG(10,.5)                         // se nao bloqueou o registro,
      LOOP                                     // retorna ao browse
     ENDI
    #endi

    IF DELE()                                  // se o registro esta' excluido
     IF !EMPT(sistema[op_sis,O_CONDREC,1])     // se tem condicao de
      IF !&(sistema[op_sis,O_CONDREC,1])       // recuperacao e se esse
       ALERTA(2)                               // reg nao pode ser
       msg=sistema[op_sis,O_CONDREC,2]         // avisa o motivo
       DBOX(msg,,,,,"ATEN€ŽO!|IMPOSS¡VEL RECUPERAR")
       LOOP                                    // e retorna
      ENDI
     ENDI
     &arq_cor._get1(RECUPERA)                  // recupera reg/processo direto
     ALERTA(1)                                 // aviso sonoro
     br_w:refreshcurrent()                     // refaz so' a linha do browse
     FORCABRW(.f.)                             // remonta a outra janela (se houver)
    ENDI

    #ifdef COM_REDE
     UNLOCK                                    // libera registro
    #endi


   CASE carac_="S".AND.fg_loc                  // seguinte (proximo do localiza)
    brw_tela = SAVESCREEN(0,0,MAXROW(),79)     // salva tela/avisa que esta localizando
    cur_atual=SETCURSOR(0)                     // salva/apaga cursor
    POE_GAUGE("Loczalizando "+LTRIM(TRAN(chvpesq,""))+".|ESC interrompe","AGUARDE...","Processados:")
    brw_reg=RECN()                             // salva registro atual
    SKIP IF(EOF(),0,1)                         // pula para o proximo, se nao for fim de arq
    IF LEN(chv_rela)>0                         // se tem relacao pesq somente nela
     x_=IF(EMPT(criterio),"","T")+chv_1        // chave de relacionamento
     LOCA FOR &cond_p. WHIL IN_KEY()!=K_ESC .AND. POE_GAUGE() .AND. &(INDEXKEY(0))=x_ // continua a procura...
    ELSE
     LOCA FOR &cond_p. WHIL IN_KEY()!=K_ESC .AND. POE_GAUGE() // continua a procura...
    ENDI
    SETCURSOR(cur_atual)                       // retorna o cursor ao normal
    IF ! FOUND().AND.LASTKEY()!=K_ESC          // se nao achou,
     ALERTA(4)                                 // avisa
     DBOX("Registro n„o encontrado!",13,40)
     GO brw_reg
    ELSE                                       // achou...
     ALERTA(1)                                 // avisa com beep e
     br_w:refreshall()                         // prepara p/ remontar toda a tela
    ENDI
    RESTSCREEN(0,0,MAXROW(),79,brw_tela)       // retira msg de "localizando"

   CASE carac_="T"                             // muda tamanho da coluna
    SEPARA(br_w:getcolumn(br_w:colpos):cargo)  // pega tamanho atual
    x=IF(TYPE(cp_)=="M",60,LEN(TRAN(&cp_.,cp_masc)))
    msg="Informe o novo tamanho da coluna "+;
        MAIUSC(br_w:getcolumn(br_w:colpos):heading)
    cod_sos=1
    x=DBOX(msg,,,,,"TAMANHO DA COLUNA",x,"99") // recebe o novo tamanho
    IF CRIT(STR(x)+"<=77.AND."+STR(x)+;        // se o tamanho e valido
       ">0~TAMANHO ILEGAL",12)
     br_w:getcolumn(br_w:colpos):width = x     // atualiza tamanho da coluna
     grava_db = .t.                            // no browse e
     br_w:configure()                          // reconfigura tudo
    ENDI

   CASE carac_="V"                             // ve todo o registro na tela
    tela_fundo=SAVESCREEN(0,0,MAXROW(),79)     // salva tela
    t_tab:=SETKEY(K_TAB,NIL)                   // desativa o TAB

    #ifdef COM_MOUSE
     IF drvmouse                               // se mouse esta' ativo,
      MOUSEGET(@x_,@y_)                        // salva sua posicao atual
     ENDI
    #endi

    i_=SETCOLOR()                              // salva a cor atual
    DO WHILE .t.
     DISPBEGIN()                               // comeca a montagem da tela
     IMPRELA()                                 // imprime telas relacionadas
     &arq_cor._gets()                          // apresenta o conteudo do registro
     INFOSIS(.f.)                              // imprime o rodape' da tela
     DISPEND()                                 // mostra tela pronta
     ALERTA(1)
     cod_sos=35

     #ifdef COM_MOUSE
      tecl_p=MOUSETECLA(l_s,c_s,l_i,c_i,.f.)   // espera clique ou alguma tecla
     #else


      #ifdef COM_REDE
       tecl_p=IN_KEY(drvtempo)                 // espera tecla ou sai para refresh
      #else
       tecl_p=IN_KEY(0)                        // espera uma tecla ser digitada
      #endi

     #endi

     DO CASE
      CASE tecl_p=K_ALT_F8                     // teclou F8 (rolagem da janela)
       rola_t=.t.                              // liga flag e
       ROLATELA()                              // executa a rolagem
      CASE tecl_p=K_ESC.OR.tecl_p=K_ENTER.OR.tecl_p=32
       EXIT                                    // abandona
     ENDC
    ENDD
    SETCOLOR(i_)                               // restaura cor anterior

    #ifdef COM_MOUSE
     IF drvmouse                               // define janela do mouse
      MOUSEBOX(br_w:ntop-1,br_w:nleft-1,br_w:nbottom+1,br_w:nright+1)
      DO WHIL MOUSEGET(0,0)!=0                 // so' sai se os botoes do
      ENDD                                     // mouse estiverem liberados
      MOUSESET(x_,y_)                          // restaura a posicao do mouse
     ENDI
    #endi

    RESTSCREEN(0,0,MAXROW(),79,tela_fundo)     // restaura tela
    SETKEY(K_TAB,t_tab)                        // TAB volta a funcionar

   CASE carac_="X"                           // exporta dados
    cod_sos=32                               // escolhe o formato da exportacao
    msg="Texto - delimitados, para editores de texto|"+;
        "SDF - 'standard Data Format` para outros sistemas|"+;
        "DBF - formato padr„o dBASE"
    op_exp=DBOX(msg,,,E_MENU,,"TIPO DE ARQUIVO DE SAIDA")
    IF op_exp!=0
     IF op_exp=1                             // escolheu o delimitado, entao
      dli_exp=","                            // escolhe o delimitador
      dli_exp=DBOX("Informe o delimitador",,,,,"SEPARA€ŽO DOS CAMPOS",dli_exp)
     ENDI
     IF LASTKEY()!=K_ESC
      brw_tela = SAVESCREEN(0,0,MAXROW(),79) // salva a tela
      arq_=ARQGER()                          // recebe o nome do arquivo a gerar
      IF !EMPTY(arq_)                        // quer continuar...
       cod_sos=1
       arqexp=arq_+".TXT"                    // se o arq informado existir
       IF FILE(arqexp)                       // verifica se pode gravar por cima
        op_=DBOX("Gravar por cima|Cancelar a opera‡„o",,,E_MENU,,"ARQUIVO "+UPPER(arqexp)+" JA EXISTE!")
        cn=(op_!=1)
        IF !cn                               // pode sobrepor,
         ERASE (arqexp)                      // entao mata arq
        ENDI
       ENDI
       IF op_exp=3                           // se exporta para outro DBF
        IF FILE(arq_+".DBF")                 // verifica se o DBF ja existe
         op_=DBOX("Gravar por cima|Cancelar a opera‡„o",,,E_MENU,,"ARQUIVO "+UPPER(arq_)+".DBF JA EXISTE!")
         cn=(op_!=1)
        ENDI
       ENDI
      ENDI
      IF !cn                                 // avisa que esta' trabalhando...
       DBOX("Gerando o arquivo "+arqexp,15,,,NAO_APAGA)
       ASIZE(estr_dbf,0); ASIZE(cp_exp,0)    // vetores auxiliares
       FOR i=1 TO br_w:colcount              // exporta todas as colunas
        SEPARA(br_w:getcolumn(i):cargo)      // separa atributo da coluna
        IF tp_cp!="M"                        // campo memo nao e' exportado
         IF op_exp=3                         // exporta para DBF
          cp_x=cp_
          casadec=0                          // se a coluna for numerica, verifica
          IF tp_cp="N"                       // a qde de casas decimais
           casadec=IF("." $ cp_masc,LEN(cp_masc)-RAT(".",cp_masc),0)
           tamanho=0                         // acha o tamanho
           FOR t=1 TO LEN(cp_masc)           // do campo
            IF !(SUBS(cp_masc,t,1) $ "@BCDEKXZR, ()")
             tamanho++
            ENDI
           NEXT
          ELSEIF tp_cp="D"                   // a coluna e' uma data
           tamanho=8                         // o tamanho e' sempre 8
          ELSEIF tp_cp="L"                   // a coluna e' tipo logico
           tamanho=1                         // o tamanho e' sempre 1
          ELSE                               // coluna tipo caracter
           tamanho=br_w:getcolumn(i):width
           cp_="LEFT("+cp_+"+["+SPAC(tamanho)+"],"+STR(tamanho,3)+")"
          ENDI
          IF "->" $ cp_x                     // coluna de outro arquivo
           cp_x=SUBS(cp_x,AT("->",cp_x)+2)   // retira o nome do DBF
          ENDI
          FOR tt=1 TO 12                     // retira caracteres ilegais
           i_=SUBS(" ()*/+-^%$@&",tt,1)      // do conteudo da coluna
           IF i_ $ cp_x                      // nome do campo do DBF a exportar
            cp_x=STRTRAN(cp_titu,i_,"")
           ENDI
          NEXT                               // monta vetor da nova estrutura
          AADD(estr_dbf,{cp_x,tp_cp,tamanho,casadec})
         ELSE                                // exportacao TXT/SDF
          IF AT(tp_cp,"CN")>0                // caracter/numerico trunca pelo tam da coluna
           cp_="LEFT(TRAN("+cp_+",["+cp_masc+"])+["+SPAC(br_w:getcolumn(i):width)+"],"+STR(br_w:getcolumn(i):width,3)+")"
          END IF
         ENDI
         AADD(cp_exp,cp_)                    // vetor com conteudos a exportar
        ENDI
       NEXT
       brw_reg = RECNO()                     // volta para registro anterior
       dele_atu:=SET(_SET_DELETED,.t.)       // os excluidos nao serao exportados
       INI_ARQ()                             // move ponteiro para o inicio do arquivo
       SET ALTE TO (arq_)                    // abre o arquivo para gravacao
       SET ALTE ON                           // liga gravacao
       SET CONS OFF                          // nao iremos exibir na tela
       q=CHR(34)                             // "aspas"
       DO WHIL !EOF()                        // para todos os registros
        FOR t=1 TO LEN(cp_exp)               // e para todas as colunas
         c_p=EVAL(&("{||"+cp_exp[t]+"}"))    // "code block" com o conteudo da coluna
         IF op_exp!=1                        // se nao for delimitado
          c_p=IF(VALTYPE(c_p)="D",DTOS(c_p),c_p)
          ?? c_p                             // grava no arquivo
         ELSE                                // se delimitado grava entre aspas
          c_p=IF(VALTYPE(c_p)="D",DTOC(c_p),c_p)
          ?? q+ALLTRIM(c_p)+q+IF(t=LEN(cp_exp),"",dli_exp)
         ENDI
        NEXT
        ?                                    // pula para proxima linha
        SKIP                                 // pega proximo registro
       ENDD
       SET ALTE OFF                          // desliga a gravacao
       SET ALTE TO                           // fecha arquivo
       SET CONS ON                           // reabilita o video
       SET(_SET_DELETED,dele_atu)            // restaura situacao do DELE()
       GO brw_reg                            // volta para registro anterior
       IF op_exp=3                           // exportacao para DBF
        DBOX("Gerando o arquivo "+arq_+".DBF",15,,,NAO_APAGA)
        i_=LEN(estr_dbf)                     // verifica/assegura que os nomes
        FOR t=1 TO i_                        // dos campos nao estao repetidos
         FOR i=t+1 TO i_
          IF estr_dbf[t,1]=estr_dbf[i,1]
           estr_dbf[i,1]=LEFT(estr_dbf[i,1],8)+STRZERO(i,2)
          ENDI
         NEXT
        NEXT
        are_a:=SELECT()                      // area atual
        SELE 0
        DBCREATE(arq_,estr_dbf)              // cria o novo DBF
        USE (arq_)                           // abre
        APPEND FROM (arqexp) SDF             // e anexa os registros
        USE                                  // fecha
        ERASE (arqexp)                       // elimina arq .txt temporario
        SELE (are_a)                         // retorna para area DBF origem
       ENDI
       AFILL(cp_exp,"")
       RESTSCREEN(0,0,MAXROW(),79,brw_tela)  // restaura a tela e
       ALERTA()                              // beep
      ENDI
     ENDI
    ENDI

   CASE carac_="Z"                             // totaliza coluna
    SEPARA(br_w:getcolumn(br_w:colpos):cargo)  // separa atributos da coluna
    IF !(tp_cp $ "NC")                         // se o campo nao for numerico
     ALERTA()                                  // nao da para somar
     DBOX("Coluna n„o pode ser totalizada",,,2)
    ELSE
     brw_tela = SAVESCREEN(0,0,MAXROW(),79)    // salva tela, registro e avisa
     brw_reg=RECN()                            // que esta somando
     DBOX("Totalizando "+MAIUSC(cp_titu)+"|ESC interrompe",,,,NAO_APAGA,"AGUARDE!")
     INI_ARQ()                                 // vai para o topo do arquivo
     x=INDEXKEY(0)                             // e comeca a somar
     IF tp_cp="N"
      SUM &cp_. TO tot_ FOR !DELE() WHIL IN_KEY()!=K_ESC .AND. &x.=IF(EMPTY(criterio),"","T")+chv_1
     ELSE
      SUM VALBR(cp_) TO tot_ FOR !DELE() WHIL IN_KEY()!=K_ESC .AND. &x.=IF(EMPTY(criterio),"","T")+chv_1
     ENDI
     GO brw_reg
     IF LASTKEY()!=K_ESC                       // nao cancelou
      ms="999,999,999,999,999,999"             // mostra quanto foi o somatorio
      dec=AT(".",cp_masc)
      ms+=IF(dec>0,SUBS(cp_masc,dec),".99")
      ALERTA(4)
      DBOX("O somat¢rio de "+MAIUSC(cp_titu)+" ‚|"+TRAN(tot_,ms),,,,,"TOTALIZA€ŽO")
     ENDI
     RESTSCREEN(0,0,MAXROW(),79,brw_tela)      // restaura a tela
    ENDI

  ENDC
 ENDI
ENDD

#ifdef COM_MOUSE
 IF drvmouse
  DO WHIL MOUSEGET(@Li,@Co)!=0                 // se qualquer botao do mouse
  ENDD                                         // estiver pressionado, espera
  MOUSEBOX(0,0,MAXROW(),79)                    // a sua liberacao
 ENDI
#endi

RETU NIL

/*
   Sintaxe: VALBR(cp)
   Funcao.: Transforma caracter em numerico despresando a mascara
   Retorna: valor numerico de cp
*/
STATIC FUNC VALBR(cp_)
LOCAL val_br
val_br=&cp_.                       // campo a ser transformado
IF AT("@E", UPPER(cp_))>0          // tem @E na mascara, entao
 val_br=STRTRAN(val_br, ".", "")   // vamos trocar o ponto por nada
 val_br=STRTRAN(val_br, ",", ".")  // e a virgula pelo ponto
ELSE                               // nao tem @E na mascara, entao
 val_br=STRTRAN(val_br, ",", "")   // so vamos trocar a virgula por nada
ENDI
RETU VAL(val_br)                   // retorna o valor numerico

/*
   Sintaxe: IMP_BRW()
   Funcao.: Imprime a consulta da funcao EDITA()
   Retorna: NIL
*/
STATIC FUNC IMP_BRW()
LOCAL dele_atu, qb_:={}, qba_:={}, x_, or_i, tot_num:=.f., tot_snum:=.f.,;
      tot_sint:=.f., lin_qb:={}
ALERTA(1)
x_=PADR(tit_cons[IF(br_w == br_origem,1,2)],40)         // recebe um titulo do relatorio
cod_sos=38                                              // sugerindo o titulo da consulta
tit_rel=DBOX("Informe um t¡tulo",,,,,"IMPRESSŽO DE CONSULTA",x_)
IF LASTKEY()!=K_ESC
 cod_sos=1
 ALERTA(1)                                              // a onde vai imprimir?
 tps=TP_SAIDA(,0,.T.)                                   // escolhe a saida...
 IF tps>0 .AND. LASTKEY()!=K_ESC
  cn=.f.
  ALERTA(1)
  IF "4WIN"$UPPER(drvmarca) // nome da configuracao/marca impressora
    arq_:=drvdbf+"WIN"+ide_maq
    tps:=3                                          // se vai para arquivo/video
    cn:=.F.
  ELSEIF tps=2                                              // saida para arquivo
   arq_=ARQGER()                                        // solicita um nome
   cn=EMPTY(arq_)
  ELSE                                                  // vai para a impressora
   cn=!PREPIMP()                                        // pede para prepara-la
   arq_=drvporta                                        // porta de saida configurada
  ENDI
  IF !cn
   brw_reg=RECN()                                       // salva registro atual
   dele_atu=SET(_SET_DELETED,.t.)                       // salva/seta visao dos reg apagados
   brw_tela = SAVESCREEN(0,0,MAXROW(),79)               // salva tela
   qb_=QUEBRA_BRW()                                     // pega quebra da impressao
   ltot := ltot_o := 0                                  // inicializa variaveis
   lin4win:=iif("4WIN"$UPPER(drvmarca),20,0)
   brw_cb1 = ""; brw_imp:=just_memo:=tot_num:=tot_snum:=tot_sint := .f.
   IF LEN(qb_)>1                                        // se tem quebra
    brw_cb1 = SPACE((3*(LEN(qb_)-1)))                   // coloca cabecalho mais a direita
    ltot = (3*(LEN(qb_)-1))                             // tamanho do cabecalho
   ENDI
   IF br_w == br_origem .AND. VALTYPE(outro_db) = "C"   // se esta imprimindo da janela de cima
    id_carg = br_outro:cargo                            // vamos verificar se a janela
    brw_imp = !EMPTY(id_carg[3])                        // de baixo esta relacionada
   ENDI
   FOR t = 1 TO br_w:colcount                           // para cada coluna,
    SEPARA_IMP(br_w:getcolumn(t):cargo)                 // separa os atributos
    le_=br_w:getcolumn(t):width                         // tamanho da coluna
    brw_cb1 +=" "+PADR(ALLTRIM(cp_titu),le_)            // monta linha de cabecalho
    ltot += le_ + 1                                     // tamanho do relatorio
    IF tp_cp=="N"                                       // coluna e' numerica?
     var="to"+SUBS(STR(t+100,3),2)                      // inicializa variavel
     &var.=0; tot_num=.t.                               // para totalizar a coluna
     IF LEN(qb_)>0                                      // se tem quebra
      FOR ii=1 TO LEN(qb_)                              // inicializa variaves de sub totalizacao
       var="Q"+SUBS(STR(ii+100,3),2)+"to"+SUBS(STR(t+100,3),2)  // inicializa variavel
       &var.=0; tot_snum=.t.                            // para totalizar a coluna
      NEXT
     ENDI
    ENDI
    IF tp_cp="M"                                        // coluna e' memo?
     just_memo=.t.                                      // liga flag da pergunta
    ENDI                                                // para justificar memo
   NEXT
   brw_cb1 = SUBS(brw_cb1,2)                            // tira 1o. espaco do titulo e
   ltot--                                               // ajusta tamanho do relatorio
   IF brw_imp                                           // existe janela relacionada?
    SELE (outro_db)                                     // seleciona o DBF da janela de
    IF LEN(qb_)>1                                       // se tem quebra
     brw_cb2 = SPACE(ltot_o)                            // defasa cabecalho do arq relacionado
     ltot_o = (3*(LEN(qb_)-1))                          // aumenta tamanho da cabecalho do arq rela
    ELSE                                                // nao tem quebra
     ltot_o = 0                                         // inicializa variaveis do cabecalho
     brw_cb2 = ""
    ENDI
    FOR t = 1 TO br_outro:colcount                      // para cada coluna
     SEPARA_IMP(br_outro:getcolumn(t):cargo)            // separa os atributos
     le_=br_outro:getcolumn(t):width                    // tamanho da coluna
     brw_cb2 +=" "+PADR(ALLTRIM(cp_titu),le_)           // monta titulo das colunas
     ltot_o += le_ + 1                                  // e o tamanho do relatorio
     IF tp_cp=="N"                                      // coluna e' numerica?
      var="too"+SUBS(STR(t+100,3),2)                    // inicializa variavel
      &var.=0; tot_num=.t.                              // para totalizar a coluna
     END IF
     IF tp_cp="M"                                       // coluna e' memo?
      just_memo=.t.                                     // liga flag de pergunta
     ENDI                                               // para justificar memo
    NEXT
    brw_cb2 = SUBS(brw_cb2,2)                           // tira 1o. espaco do titulo e
    ltot_o--                                            // ajusta tamanho do relatorio
    SELE (m_origem)                                     // seleciona DBF da janela de cima
   ENDI
   IF tot_num                                           // tem alguma coluna numerica?
    ALERTA(1)                                           // pergunta se quer totalizar
    cod_sos=1                                           // o relatorio
    i=DBOX("Sim|N„o",,,E_MENU,,"TOTALIZAR AS|COLUNAS NUMRICAS")
    IF i=0
     RETU                                               // cancelou...
    ENDI                                                // flag se quer totalizar
    tot_num=(i=1)
    IF !tot_num                                         // se nao vai totalizar
     tot_snum=.f.                                       // tambem nao sub-totaliza
    ENDI
    IF tot_snum                                         // se tem?
     ALERTA(1)                                          // pergunta se quer sub totalizar
     cod_sos=1                                          // a quebra
     i=DBOX("Sim|N„o",,,E_MENU,,"SUBTOTALIZAR AS QUEBRAS")
     IF i=0
      RETU                                               // cancelou...
     ENDI                                                // flag se quer sub totalizar
     tot_snum=(i=1)
    ENDI
    IF tot_snum .AND. !brw_imp                           // vai subtotalizar e nao tem arq relacionado
     ALERTA(1)                                           // pergunta se quer sintetizar a impressao
     cod_sos=1
     i=DBOX("Sim|N„o",,,E_MENU,,"SINTETIZAR O RELATORIO")
     IF i=0
      RETU                                               // cancelou...
     ENDI
     tot_sint=(i=1)                                      // flag se quer sub totalizar
    ENDI
   ENDI
   IF just_memo                                         // tem algum campo memo?
    ALERTA(1)                                           // pergunta se quer justificar
    cod_sos=50                                          // os campos memos no relatorio
    i=DBOX("Sim|N„o",,,E_MENU,,"JUSTIFICAR OS|CAMPOS MEMO")
    IF i=0
     RETU                                               // cancelou...
    ENDI
    just_memo=(i=1)                                     // flag se quer justificar memos
   ENDI
   or_i=cpord                                           // salva ordenacao atual
   IF LEN(qb_)>0                                        // tem quebra
    x_=""                                               // junta a expressao
    FOR t=1 TO LEN(qb_)                                 // de ordenacao de todas
     x_+=IF(LEN(x_)>1,"+","")+qb_[t,2]                  // as quebras
    NEXT
    IF LEFT(cpord,LEN(x_))!=x_                          // se ainda nao esta ordenado
     cpord=x_+IF(LEN(cpord)>1,"+"+cpord,"")             // por esta expressao
     INDTMP()                                           // vamos ordernar agora...
     br_w:refreshall()                                  // forca atualizacao da tela
    ENDI
   ENDI
   DBOX("Aguarde o final de impress„o||ESC para interromper",17,,,NAO_APAGA)
   INI_ARQ()                                            // vai para o inicio do arquivo
   cl:=pg:=creg := 0                                    // inicializar variaveis
   SET PRINTER TO (arq_)                                // abre arq escolhido ou redireciona saida
   SET DEVI TO PRIN                                     // se tamanho > 80, comprime
   @ PROW(),PCOL() SAY IF(MAX(ltot,ltot_o)>80,&drvpcom.,"")
   cl=CABCONS(brw_cb1,tit_rel)                          // imprime cabecalho da janela superior
   brw_cn = .f.
   x_ = INDEXKEY(0)
   IF LEN(qb_)>0                                        // tem quebra definida
    qba_:=AFILL(ARRAY(LEN(qb_)),"")                     // cria vetor do conteudo de cada quebra
   ENDI
   DO WHIL ! EOF() .AND. ! brw_cn .AND.;                // imprime ate o fim do arquivo
      IF(EMPTY(chv_rela).OR.br_w==br_origem,.t.,&x_.=IF(EMPTY(criterio),"","T")+chv_1)
    IF cl>IF(brw_imp,54,57)                             // atingiu o final da folha
     EJEC                                               // pula para proxima pagina
     cl=CABCONS(brw_cb1,tit_rel)                        // e reimprime o cabecalho
    ENDI

    IF IN_KEY()=K_ESC .OR. MOUSEGET(0,0)=2              // quer cancelar a impressao?
     brw_cn = CANC(1)                                   // pede confimacao do cancelamento
     LOOP
    ENDI
    IF LEN(qb_)>0                                       // tem quebra
     FOR t=1 TO LEN(qb_)                                // vamos correr todas
      IF qba_[t]<>&(qb_[t,1])                           // quebrou...
       x_ = .f.
       IF tot_snum .AND. LEN(qba_[t])>0                 // quer totalizar e nao e a 1a. vez
        FOR ii= LEN(qb_) TO t STEP -1                   // coloca os totais das sub-quebras menores
         IF cl+1>IF(brw_imp,52,55)                  // precisa quebrar pagina
          EJEC
          cl=CABCONS(brw_cb1,tit_rel)
         ENDI
         IF ii=LEN(qb_) .AND. tot_sint              // vai sintetizar e e' ultima quebra
          FOR tt=1 TO LEN(lin_qb)                   // corre as linhas salvas
           IF cl+1>IF(brw_imp,54,57)                // precisa quebrar pagina...
            EJEC                                    // forca quebra de folha
            cl=CABCONS(brw_cb1,tit_rel)
           ENDI
           @ cl++,0 SAY lin_qb[tt]                  // imprime linha sintetizada
          NEXT
         ELSE
          lin = SPACE((3*(ii-1)))                   // esp branco ate a quebra
          @ cl++,0 SAY lin+REPL("-", ltot-LEN(lin)) // traco antes da quebra
          lin = SPACE((3*(len(qb_)-1)))             // esp branco ate os dados
         ENDI
         FOR tt=1 TO br_w:colcount                  // monta linha dos sub-totais
          SEPARA_IMP(br_w:getcolumn(tt):cargo)      // separa dados da coluna
          i = br_w:getcolumn(tt):width              // tananho da coluna
          IF tp_cp=="N"                             // coluna numerica, pega sub-total
           var="Q"+SUBS(STR(ii+100,3),2)+"to"+SUBS(STR(tt+100,3),2)
           lin += LEFT(TRAN(&var.,cp_masc)+SPAC(i),i)+" "
           &var.=0
          ELSE
           lin += SPAC(i+1)                         // coluna nao numerica coloca brancos
          ENDI
         NEXT
         IF ii<LEN(qb_) .OR. !tot_sint              // nao e' a ultima quebra
          @ cl++,0 SAY lin                          // imprime sub-totais
          x_ = .t.
         ENDI
         qba_[ii]=""                                // limpa conteudo da quebra
        NEXT
       ENDI
       qba_[t]=&(qb_[t,1])                          // novo conteudo da quebra
       IF LEN(qb_[t,3])>0                                // imprime o titulo
        cl++
        @ cl++,0 SAY SPACE((3*(t-1)))+;                  // somente se foi informado
                     qb_[t,3]+" "+qba_[t]                // imprime titulo da quebra e seu conteudo
       ELSEIF x_
        cl++
       ENDI
      ENDI
     NEXT
     lin = SPACE((3*(LEN(qb_)-1)))                       // onde comeca os dados
    ELSE
     lin = ""                                            // sem quebra, dados comeca na coluna um
    ENDI
    tem_memo=.f.; qli_m=0
    FOR t=1 TO br_w:colcount                            // monta linha a imprimir
     SEPARA_IMP(br_w:getcolumn(t):cargo)                // separa os atributos da coluna
     i = br_w:getcolumn(t):width                        // tamanho da coluna
     IF tp_cp="M"                                       // coluna e' memo?
      IF qli_m<MLCOUNT(&cp_.,i)                         // mumero maximo de linhas
       qli_m=MLCOUNT(&cp_.,i)                           // a imprimir de todos campos memo
      ENDI                                              // monta linha de impressao
      lin += IMPAC(LEFT(MEMOLINE(&cp_.,i,1)+SPACE(i),i),just_memo)+" "
      tem_memo=.t.                                      // flag tem memo?
     ELSE
      IF tp_cp=="N" .AND. tot_num                       // coluna e' numerica?
       var="to"+SUBS(STR(t+100,3),2)                    // soma coluna para
       &var. += &cp_.                                   // totalizacao
       IF LEN(qb_)>0 .AND. tot_snum                     // tem quebra e quer sub-total
        FOR ii=1 TO LEN(qb_)                            // soma de cada quebra
         var="Q"+SUBS(STR(ii+100,3),2)+"to"+SUBS(STR(t+100,3),2)  // inicializa variavel
         &var. += &cp_.
         IF ii=LEN(qb_) .AND. tot_sint                  // sitetiza a ultima quebra
          cp_=var
         ENDI
        NEXT
       ENDI
      ENDI
      lin+=LEFT(TRAN(&cp_.,cp_masc)+SPAC(i),i)+" "      // monta linha de impressao
     ENDI
    NEXT
    IF tot_sint                                            // esta sintetizando
     lin_qb:={}                                            // salva linhas para
     AADD(lin_qb,lin)                                      // imprimir quando quebrar
    ELSE
     @ cl++,0 SAY lin                                      // joga linha na impressora
    ENDI
    IF tem_memo .AND. qli_m>1                           // imprime resto do memo
     li_m=1
     DO WHIL .t.
      li_m++                                            // proxima linha do memo
      IF li_m>qli_m                                     // se ja' imprimiu todos
       EXIT                                             // cai fora...
      ENDI
      IF LEN(qb_)>1                                     // se tem quebra calcula
       lin = SPACE((3*(LEN(qb_)-1)))                    // posicao de inicio dos dados
      ELSE
       lin = ""                                         // sem quebra inicio=1a. coluna
      ENDI
      FOR t=1 TO br_w:colcount                          // procura todos os memo
       SEPARA_IMP(br_w:getcolumn(t):cargo)              // e monta uma linha so'
       i = br_w:getcolumn(t):width
       IF tp_cp="M"
        lin += IMPAC(LEFT(MEMOLINE(&cp_.,i,li_m)+SPACE(i),i),just_memo)+" "
       ELSE
        lin += SPAC(i+1)
       ENDI
      NEXT
      IF cl+1>(IF(brw_imp,54,57)+lin4win)
       IF !("4WIN"$UPPER(drvmarca))
        EJEC                                             // quebra de folha
       ENDI
       cl=CABCONS(brw_cb1,tit_rel)
      ENDI
      IF tot_sint                                       // esta sintetizando
       AADD(lin_qb,lin)                                 // salva linha
      ELSE
       @ cl++,0 SAY lin                                 // joga linha na impressora
      ENDI
      IF IN_KEY()=K_ESC .OR. MOUSEGET(0,0)=2            // quer cancelar a impressao?
       brw_cn = CANC(1)
       LOOP
      ENDI
     ENDD
    ENDI
    IF tem_memo .AND. !tot_sint                         // se imprimiu algum campo
     cl++                                               // memo, forca espacejamento duplo
    ENDI
    creg++                                              // contador de registros impressos
    IF brw_imp                                          // tem outra janela relacionada?
     cl++                                               // forca salto de linha
     id_carg=br_outro:cargo                             // prepara para a impressao
     c_antes=IF(EMPTY(id_carg[1]),"","T")+&(id_carg[3]) // da janela relacionada
     SELE (outro_db)
     SEEK c_antes                                       // acha o 1o. registro da relacao
     ind_outro = INDEXKEY(0)                            // ordem atual do arquivo
     imp_brw_out=.f.
     IF !EOF().AND.!brw_cn.AND.&ind_outro.=c_antes      // se tem registro a imprimir
      cl=CABCONS_O(cl,brw_cb2)                          // imprime cabecalho
      cl++
     ENDI
     DO WHIL !EOF().AND.!brw_cn.AND.&ind_outro.=c_antes // imprime so quem atende a relacao
      cl--
      IF cl>57                                          // final da folha
       IF !("4WIN"$UPPER(drvmarca))
        EJEC                                             // salta para proxima
       ENDI
       cl=CABCONS(brw_cb1,tit_rel)                      // imprime cabecalho do "pai"
      ENDI
      IF IN_KEY()=K_ESC .OR. MOUSEGET(0,0)=2            // quer cancelar?
       brw_cn = CANC(1)                                 // pede confirmacao
       LOOP
      ENDI
      tem_memo=.f.; qli_m=0
      IF LEN(qb_)>1                                     // se tem quebra
       lin_o = SPACE((3*(LEN(qb_)-1)))                  // inicio dos dados
      ELSE
       lin_o = ""                                       // nao tem quebra posicao 0
      ENDI
      FOR t=1 TO br_outro:colcount                      // monta linha a imprimir
       SEPARA_IMP(br_outro:getcolumn(t):cargo)          // separa os atributos da coluna
       IF tp_cp="M"                                     // tamanho da coluna
        IF qli_m<MLCOUNT(&cp_.,i)                       // coluna e' memo?
         qli_m=MLCOUNT(&cp_.,i)                         // mumero maximo de linhas
        ENDI                                            // a imprimir de todos campos memo
        lin_o+=" "+IMPAC(LEFT(MEMOLINE(&cp_.,i,1)+;
             SPACE(i),i),just_memo)                     // monta linha de impressao
        tem_memo=.t.                                    // flag se tem memo
       ELSE
        IF tp_cp=="N" .AND. tot_num                     // coluna e' numerica?
         var="too"+SUBS(STR(t+100,3),2)                 // soma coluna para
         &var. += &cp_.                                 // totalizacao
        ENDI
        i = br_outro:getcolumn(t):width                 // tamanho da coluna
        lin_o+=" "+LEFT(TRAN(&cp_.,cp_masc)+SPAC(i),i)  // monta linha de impressao
       ENDI
      NEXT
      imp_brw_out=.t.
      @ cl,0 SAY PADL(SUBS(lin_o,2),MAX(ltot,ltot_o))   // joga linha na impressora
      IF tem_memo .AND. qli_m>1                         // imprime resto do memo
       li_m=1
       DO WHIL .t.
        li_m++                                          // proxima linha do memo
        IF li_m>qli_m                                   // se ja imprimiu todos
         EXIT                                           // cai fora...
        ENDI
        IF LEN(qb_)>1                                   // se tem quebra
         lin = SPACE((3*(LEN(qb_)-1)))                  // inicio dos dados
        ELSE
         lin = ""                                       // posicao 0 sem quebra
        ENDI
        FOR t=1 TO br_w:colcount                        // procura todos os memo
         SEPARA_IMP(br_w:getcolumn(t):cargo)            // e monta uma linha so'
         i = br_w:getcolumn(t):width
         IF tp_cp="M"
          lin += IMPAC(LEFT(MEMOLINE(&cp_.,i,li_m)+SPACE(i),i),just_memo)+" "
         ELSE
          lin += SPAC(i+1)
         ENDI
        NEXT
        IF cl+1>57                                      // chegou no final da folha?
         IF !("4WIN"$UPPER(drvmarca))
          EJEC                                           // salta para proxima pagina
         ENDI
         cl=CABCONS(brw_cb1,tit_rel)                    // reimprime cabecalho do "pai"
        ENDI
        @ ++cl,0 SAY PADL(lin,MAX(ltot,ltot_o))         // imprime linhas dos memo
        IF IN_KEY()=K_ESC .OR. MOUSEGET(0,0)=2          // quer cancelar?
         brw_cn = CANC(1)
         LOOP
        ENDI
       ENDD
      ENDI
      cl += 2
      SKIP                                              // de imprimir o proximo "pai"
     ENDD
     IF imp_brw_out                                     // se imprimiu algum registro...
      @ cl-1,0 SAY PADL(REPL("-",ltot_o),MAX(ltot,ltot_o))
     ENDI
     cl++
     IF tot_num                                      // pediu para totalizar
      lin_o=""
      FOR t=1 TO br_outro:colcount                   // monta linha dos totais
       SEPARA_IMP(br_outro:getcolumn(t):cargo)
       i=br_outro:getcolumn(t):width
       IF tp_cp=="N"
        var="too"+SUBS(STR(t+100,3),2)                    // variavel com a mascara
        lin_o+=" "+LEFT(TRAN(&var.,cp_masc)+SPAC(i),i)    // da propria coluna
        &var.=0
       ELSE
        lin_o += SPAC(i+1)
       ENDI
      NEXT
      IF LEN(ALLTRIM(lin_o))>0                          // se tem totais, imprime
       @ cl-1,0 SAY PADL(SUBS(lin_o,2),MAX(ltot,ltot_o))
       cl++
      ENDI
     ENDI
     SELE (m_origem)                                    // retorna ao "pai"
    ENDI
    SKIP
   ENDD
   IF tot_snum                                          // quer sub-totalizar?
    IF LEN(qba_[1])>0                                   // teve alguma quebra impressa?
     FOR ii= LEN(qb_) TO 1 STEP -1                      // corre todas para imprimir sub-total
      IF cl+1>IF(brw_imp,52,55)                         // precisa pular pagina
       IF !("4WIN"$UPPER(drvmarca))
        EJEC
       ENDI
       cl=CABCONS(brw_cb1,tit_rel)                      // se pulou reimprime cabecalho
      ENDI
      IF ii=LEN(qb_) .AND. tot_sint                     // ultima quebra vai sintetizar...
       FOR tt=1 TO LEN(lin_qb)                          // imprime linhas salvas
        IF cl+1>(IF(brw_imp,54,57)+lin4win)             // precisa quebrar a pagina
         IF !("4WIN"$UPPER(drvmarca))
          EJEC                                           // entao forca
         ENDI
         cl=CABCONS(brw_cb1,tit_rel)
        ENDI
        @ cl++,0 SAY lin_qb[tt]                         // linha com total da ultima quebra
       NEXT
      ELSE
       lin = SPACE((3*(ii-1)))                          // inicio da quebra
       @ cl++,0 SAY lin+REPL("-", ltot-LEN(lin))        // traco da quebra
       lin = SPACE((3*(len(qb_)-1)))                    // inicio dos dados
      ENDI
      FOR tt=1 TO br_w:colcount                         // monta linha dos sub-totais
       SEPARA_IMP(br_w:getcolumn(tt):cargo)             // separa a coluna
       i = br_w:getcolumn(tt):width                     // tamanho da coluna
       IF tp_cp=="N"                                    // numerico pega sub-total
        var="Q"+SUBS(STR(ii+100,3),2)+"to"+SUBS(STR(tt+100,3),2)
        lin += LEFT(TRAN(&var.,cp_masc)+SPAC(i),i)+" "
        &var.=0                                         // zera sub-total
       ELSE
        lin += SPAC(i+1)                                // col nao numerica poe espacos
       ENDI
      NEXT
      IF ii<LEN(qb_) .OR. !tot_sint                     // nao esta sintetizando...
       @ cl++,0 SAY lin                                 // imprime sub-total
      ENDI
      qba_[ii]=""                                       // inicializa quebra
     NEXT
    ENDI
   ENDI
   @ PROW()+1,0 SAY REPL("=", MAX(ltot,ltot_o))         // traco do fim do relatorio
   IF LEN(qb_)>0                                        // se tem quebra
    lin = SPACE((3*(LEN(qb_)-1)))                       // dados na posicao da ultima quebra
   ELSE
    lin = ""
   ENDI
   IF tot_num                                           // quer totalizar
    FOR t=1 TO br_w:colcount                            // monta linha dos totais
     SEPARA_IMP(br_w:getcolumn(t):cargo)
     i = br_w:getcolumn(t):width
     IF tp_cp=="N"
      var="to"+SUBS(STR(t+100,3),2)                     // variavel com a mascara
      lin += LEFT(TRAN(&var.,cp_masc)+SPAC(i),i)+" "    // da propria coluna
     ELSE
      lin += SPAC(i+1)
     ENDI
    NEXT
    @ PROW()+1,0 SAY lin
   ENDI                                                 // se tem totais, imprime
   @ PROW()+1,0 SAY IIF(tot_sint,"Processados: ","Listados: ")+; // imprime qde de registros
                    ALLTRIM(TRAN(creg,"@E 999,999"))+;           // listados
                    " registros"+;
                    IF(MAX(ltot,ltot_o)>80,&drvtcom.,"")
   IF !("4WIN"$UPPER(drvmarca))
    EJEC
   ENDI
   cpord=or_i                                           // restaura ordenacao
   SET PRINTER TO (drvporta)                            // finaliza o relatorio
   SET DEVI TO SCRE
   SET(_SET_DELETED,dele_atu)                           // restaura visao dos reg apagados
   GO brw_reg                                           // reposiciona o ponteiro
   IF tps=2                                             // se vai para arquivo/video
    BROWSE_REL(arq_,2,3,MAXROW()-2,78,.f.)              // mostra o arquivo gravado
   ENDI
   RESTSCREEN(0,0,MAXROW(),79,brw_tela)                 // restaura a tela e
  ENDI                                                  // do arquivo
 ENDI
ENDI
RETU NIL

/*
   Sintaxe: QUEBRA_BRW()
   Funcao.: pega campos/tituos para quebra da impressao da consulta
   Retorna: arranjo com as quebras
*/
STATIC FUNC QUEBRA_BRW()
LOCAL menucp:="", clivre:=.f., msg, qb_:={}, cpqb_, cpod_, cpti_, ;
      op_qb:=0, tela_qb:=SAVESCREEN(0,0,MAXROW(),79), x_, i_
PRIV cod_sos:=14
IF nivelop>=NIV_CRI_LIVRE         // verifica se usuario autorizado a fazer
 menucp="|* * Quebra livre * *"   // quebra livre
ENDI
x_=ALIAS()                         // monta menu de campos com
DO WHIL LEN(x_)>0                  // todas os arquivos relacionadas
 k_=PARSE(@x_,"|")                 // arquivo atual
 nc=EVAL(&("{||"+k_+"->(FCOU())}"))// numero de campos do arquivo
 FOR i=1 TO nc                     // monta menu de campos, exceto invisivel
  IF !("I"==sistema[EVAL(qualsis,k_),O_CAMPO,i,O_CRIT])
   menucp+="|"+sistema[EVAL(qualsis,k_),O_CAMPO,i,O_TITU]
  ENDI
 NEXT
 i_=1                                  // pega nome dos arq relacionados
 DO WHIL LEN(&k_.->(DBRELATION(i_)))>0 // ao arq principal
  IF LEN(x_)>0
   x_+="|"
  ENDI
  x_+=&k_.->(ALIAS(DBRSELECT(i_)))     // nome do arq relacionado
  i_++                                 // proximo relacionamento
 ENDD
ENDD
DO WHILE .t.                      // vamos montar varias quebras...
 msg:=cpqb_:=cpod_:=cpti_ := ""   // inicializa variaves da quebra
 DO WHIL op_qb=0                  // escolhes os campos de cada quebra
  IF LEN(msg)>0                   // mostra campos escolhidos
   op_0=DBOX(SUBS(msg,2),,50,,NAO_APAGA,"QUEBRA")
  ENDI
  op_0=DBOX(SUBS(menucp,2),,6,E_MENU,,"CAMPOS PARA QUEBRA")
  IF op_0!=0                      // escolheu um campo
   op_1=op_0
   IF nivelop>=NIV_CRI_LIVRE      // se tem autorizacao para quebra
    IF op_1=1                     // livre, entao faz...
     clivre=.t.
     EXIT
    ENDI
    op_1--                        // faz op_1 a subscricao da coluna
   ENDI
   ii=0
   cp_=""                                         // inicializa campo esolhido
   x_=ALIAS()                                     // arquivo principal
   DO WHIL LEN(x_)>0                              // corre todas os arquivos
    k_=PARSE(@x_,"|")                             // para pegar campo escolhido
    nc=EVAL(&("{||"+k_+"->(FCOU())}"))            // numero de campos do arquivo
    FOR i=1 TO nc                                 // desprezando campo invisieis
     IF !("I"==sistema[EVAL(qualsis,k_),O_CAMPO,i,O_CRIT])
      ii++
     ENDI
     IF ii=op_1                                   // campo escolhido?
      IF k_==ALIAS()                              // se for o arq principal nao coloca alias()
       cp_=FIEL(i)
      ELSE                                        // arq relacionado coloca o alias()
       cp_=k_+"->"+&k_.->(FIEL(i))
      ENDI
      ms_=sistema[EVAL(qualsis,k_),O_CAMPO,i,O_MASC] // mascara do cp escolhido
      ti_=sistema[EVAL(qualsis,k_),O_CAMPO,i,O_TITU] // mascara do cp escolhido
      EXIT
     ENDI
    NEXT
    IF LEN(cp_)>0                                 // se ja achou o cp
     EXIT                                         // cai fora...
    ENDI
    i_=1
    DO WHIL LEN(&k_.->(DBRELATION(i_)))>0         // pega todas as relacoes
     IF LEN(x_)>0                                 // deste arquivo
      x_+="|"
     ENDI
     x_+=&k_.->(ALIAS(DBRSELECT(i_)))             // nome do arq relacionado
     i_++                                         // nome da relacao
    ENDD
   ENDD
   IF TYPE(cp_) $ "MU"                // se tipo MEMO ou INDEFINIDO...
    ALERTA(3)                         // ... nao da' para usar
    DBOX("Campo "+MAIUSC(ti_)+" n„o|pode ser usado para quebra",,,,,"ATEN€ŽO!")
    LOOP
   ENDI
   cpod_+=IF(LEN(cpod_)>1,"+","")+;
          TRANSCAMPO(.f.,cp_)          // concatena campos escolhidos para ordenacao
   cp_=TRANSCAMPO(.f.,cp_,,.f.)        // transforma para caracter
   msg +="|"+ti_
   cpqb_+=IF(LEN(cpqb_)>1,"+"+CHR(34)+" - "+CHR(34)+"+","")+cp_  // concatena campos escolhidos
   cpti_+=IF(LEN(cpti_)>1,", ","")+ti_ // titulo default da quebra
  ELSE
   EXIT                                // termino da escolha de cps da quebra
  ENDI
 ENDD
 IF clivre                             // vai fazer quebra livre
  cpqb_=SPAC(210)
  msg="A EXPRESSŽO ABAIXO DEVER ESTAR DE ACORDO COM|"+;
      "A SINTAXE DA LINGUAGEM PARA EVITAR ERRO DE PROCESSAMENTO|*|"+;
      "F10=CAMPOS DO ARQUIVO|*|INFORME A EXPRESSŽO PARA QUEBRA"
  DO WHILE .T.
   SET KEY K_F10 TO ve_campos          // habilita F10 para ver campos DBF
   cpqb_=DBOX(msg,,,,,SEPLETRA("* QUEBRA  LIVRE *",1),cpqb_,"@S50")
   SET KEY K_F10 TO                    // desabilita F10
   IF LASTKEY()=K_ESC
    cpqb_:=cpod_ := ""                 // cancelou...
    EXIT
   ENDI
   cpod_=cpqb_                         // exp de ordenacao = exp da quebra
   tp_crit=TYPE(cpqb_)
   IF tp_crit="UI"                     // se expressao=indeterminado
    tp_crit=VALTYPE(&cpqb_.)           // existe funcao fora da clipper.lib
   ENDI                                // entao avalia o conteudo da expressao
   IF tp_crit $ "CND"                  // so ordena tipos caracter/numerico/data
    IF tp_crit="N"                     // transf p/ caracter ordem tp numerica
     cpqb_="STR("+ALLTRIM(cpqb_)+")"
     cpod_="STR("+ALLTRIM(cpod_)+")"
    ELSEIF tp_crit="D"                 // transf p/ caracter ordem tp data
     cpqb_="DTOC("+ALLTRIM(cpqb_)+")"
     cpod_="DTOS("+ALLTRIM(cpqb_)+")"
    ENDI
    EXIT                               // vamos retornar, ordenacao ajustada
   ENDI
   ALERTA(3)                           // ordenacao livre invalida
   DBOX("EXPRESSŽO ILEGAL!",15)        // vamos avisar...
  ENDD
  cpqb_=ALLTRIM(cpqb_)                 // tira brancos da expressao
  cpod_=ALLTRIM(cpod_)
 ENDI
 RESTSCREEN(0,0,MAXROW(),79,tela_qb)   // restaura tela original
 IF !EMPTY(cpqb_)                      // escolheu uma quebra
  IF LEN(cpti_)>0                      // coloca : no default do titulo
   cpti_+=":"
  ENDI
  cpti_ = LEFT(cpti_+SPAC(80),80)      // pede o titulo para a quebra
  msg="Informe um t¡tulo para ser impresso ao lado|esquerdo do campo da quebra"
  cpti_=DBOX(msg,,,,,"TITULO DA QUEBRA",cpti_,"@S50")
  IF LASTKEY()=K_ESC
   cpqb_:=cpod_ := ""                  // cancelou...
   EXIT
  ENDI
  AADD(qb_,{cpqb_,cpod_,RTRIM(cpti_)}) // imcrementa vetor de quebras
  ALERTA(1)                            // beep! e
  msg="Sim|N„o"                        // ve se usuario quer outra quebra
  msgt="CRIAR QUEBRA "+ALLTRIM(STR(LEN(qb_)+1))
  cod_sos=1
  ii=DBOX(msg,,,E_MENU,,msgt)
  IF ii!=1                             // se desistiu,
   EXIT                                // prossegue impressao
  ENDI
 ELSE
  EXIT                                 // nenhuma quebra feita...
 ENDI
ENDD
RETU qb_                               // retorna vetor de quebras

/*
   Sintaxe: CABCONS(<ExpC1> <,ExpC2> )
   Funcao.: Imprime cabecalho da consulta na impressora (pai)
              ExpC1 = titulo da consulta
              ExpC2 = titulo extra
   Retorna: Linha de impressao do proximo registro
*/
STATIC FUNC CABCONS(cb_1,tit_rel)
pg++
@ 1,ltot-18 SAY DATE()                   // data do sistema
@ 1,ltot-7  SAY TRAN(pg,"Pag 999")       // numero da pagina
//@ 2,0 SAY IMPAC(PADC(TRIM(nemp),ltot))   // nome da empresa
@ 3,0 SAY PADC(TRIM(tit_rel),ltot)       // titulo informado
@ 4,0 SAY IMPAC(cb_1)                    // titulo das colunas
@ 5,0 SAY REPL("=",MAX(ltot,ltot_o))
RETU 6

/*
   Sintaxe: CABCONS_O()
   Funcao.: Imprime cabecalho da consulta na impressora (filho)
              ExpC1 = titulo da consulta
              ExpC2 = titulo extra
   Retorna: Linha de impressao do proximo registro
*/
STATIC FUNC CABCONS_O(cl,cb_1)
@ cl++,0 SAY IMPAC(PADL(cb_1,MAX(ltot,ltot_o)))              // titulo das colunas
@ cl++,0 SAY IMPAC(PADL(REPL("-",ltot_o),MAX(ltot,ltot_o)))  // justificado a direita
RETU cl

/*
   Sintaxe: SEPARA_IMP( <ExpC> )
     Funcao.: Separa atributos de campos da coluna para impressao
              verifica a possibilidade da formula ser um campo numerico
              ExpC = atributos (nome do campo/mascara/titulo/validacao)
     Retorna: NIL
*/
STATIC FUNC SEPARA_IMP(cp_atr)
LOCAL x
SEPARA(cp_atr)                        // separa atributos da coluna
x=AT("@E",UPPER(cp_))                 // posicao do @E dentro da formula
IF tp_cp="C" .AND.;                   // se a formula for caracter,
   UPPER(cp_masc)="@X" .AND.;         // sua mascara for @X, ter @E
   x>0 .AND. LEFT(cp_,5)="TRAN("      // dentro da formula e comecar com TRAN(
 tp_cp="N"                            // entao e' um formula numerica
 cp_masc=SUBS(cp_,x)                  // pega mascara desta formula
 cp_masc=LEFT(cp_masc,LEN(cp_masc)-2)
 cp_=SUBS(cp_,6,x-8)                  // pega somente a formula
ENDI
RETU NIL

/*
   Sintaxe: TROCA_BRW()
   Funcao.: Troca os arquivos do browse
   Retorna: NIL
*/
STATIC FUNC TROCA_BRW()
IF br_w == br_outro    // se for a janela de baixo
 br_reg_out = RECNO()  // salva situacao e
 SELE (m_origem)       // passa para a janela de cima
 br_w = br_origem
 GO br_reg_ori
ELSE                   // esta' na janela de cima
 br_reg_ori = RECNO()  // salva situacao e
 SELE (outro_db)       // passa para a janela de baixo
 br_w = br_outro
 GO br_reg_out
ENDI
RETU NIL

/*
   Sintaxe: LDBEDIT( <ExpL> )
   Funcao.: Carrega parametros de consulta
            se .t. le consulta dos discos e apresenta menu
   Retorna: .t. se teve sucesso.
*/
STATIC FUNC LDBEDIT(lecons)
LOCAL aqdbe, naq, qarq, cor_, ret_:=.t., sos_cod:=cod_sos, leat_,;
      tela_brw:=SAVESCREEN(0,0,MAXROW(),79), i_, l_mp, c_mp, x_, k_
IF ! USED()                                          // nao existe DBF aberto
 RETU .f.
ENDI
cod_sos=27
leat_=.t.
IF lecons                                            // se quer ler consultas gravadas
 DBOX("AGUARDE!",,,,NAO_APAGA)
 aqdbe=drvdbf+"DB*."+LEFT(ALIAS(),3)                 // mascara dos arquivos
 qarq=ADIR(aqdbe)                                    // capta arquivo do disco
 IF qarq>0                                           // existe alguma consulta gravada?
  PRIV l_arq[qarq+1], v_arq[qarq+1]
  ADIR(aqdbe,l_arq)                                  // monta vetor com os titulos
  i_=0
  FOR i=qarq TO 1 STEP -1                            // de cada consulta
   naq=drvdbf+l_arq[i]
   REST FROM (naq) ADDI
   IF TYPE("db_qprg")="U" .OR. qual_prg==db_qprg
    i_++
    v_arq[i_+1]=db_aqcom+"³"+l_arq[i]
   ENDI
   RELE ALL LIKE db_*                                 // libera variaveis com "DB"
  NEXT
  If i_>0
   v_arq[1]="* Definir nova consulta *"               // primeira opcao do menu
   volta_ac=.t.
   RESTSCREEN(0,0,MAXROW(),79,tela_brw)
   DO WHIL volta_ac
    volta_ac=.f.
    msg=""                                            // tira os espacos dos titulos
    AEVAL(v_arq,{|ms|;                                // da consulta
                  IF(ms!=NIL,msg+="|"+ALLTRIM(PARSE(ms,"³")),"");
                };
    )
    l_mp=IF(TYPE("lin_menu")="N",lin_menu+2,NIL)      // coordenadas do menu
    c_mp=IF(TYPE("col_menu")="N",col_menu+8,NIL)      // apresenta menu
    op_co=DBOX(SUBS(msg,2),l_mp,c_mp,E_MENU,,"CONSULTAS DEFINIDAS|(DEL=APAGA)")
    IF volta_ac                                       // quer apagar a consulta
     pos_=RAT("³",v_arq[op_co])
     IF pos_>3                                        // evita matar opcao sem aquivo
      naq=drvdbf+SUBS(v_arq[op_co],pos_+1)
      i_=ALLTRIM(UPPE(LEFT(v_arq[op_co],pos_-1)))
      ALERTA()                                        // pede confirmacao
      msg="Cancelar a opera‡„o|Efetivar exclus„o"
      op_=DBOX(msg,8,,E_MENU,,"EXCLUINDO|¯ "+i_+" ®")
      IF op_=2                                        // se confirmou exclusao elimina
       ERAS &naq.                                     // arquivo de atributos da consulta
       ADEL(v_arq,op_co)                              // exclui consulta do menu
      ENDI
     ENDI
    ENDI
   ENDD
   RELE ALL LIKE db_*                                 // libera variaveis com "DB"
   db_1rela:=db_2rela := ""
   db_zoom=.f.
   IF op_co=0                                         // nao quis ler consulta
    ret_=.f.
   ELSEIF op_co>1
    op_=v_arq[op_co]                                  // consulta escolhida
    br_tit=ALLTRIM(PARSE(@op_,"³"))                   // extrai o nome do arquivo
    br_arq=drvdbf+op_
    REST FROM (br_arq) ADDI                            // le variaveis do disco
    pas = "1"
    tit_cons[1]=ALLTRIM(br_tit)                       // titulo da consulta
    IF db_zoom                                        // se janela tem zoom
     li_sup=3; li_inf=22; co_sup=3; co_inf=77         // ajusta as coordanadas
     br_w:nTop   := li_sup                            // da janela e do browse
     br_w:nbottom:= li_inf
     br_w:nleft  := co_sup
     br_w:nright := co_inf
    END IF
    ind_rela=db_indrela                               // indice utilizado para relacionar
    DO WHILE .t.
     xdb_rela=LEFT(db_&pas.rela,LEN(db_&pas.rela)-1)
     DO WHIL LEN(xdb_rela)>0                          // restabelece relations
      n_cp=ALLTRIM(PARSE(@xdb_rela,"³"))
      SETARELA(n_cp)
     ENDD
     cmr_=db_&pas.cmr                                 // marcacao de reg
     FOR t=1 TO db_&pas.qtdc                          // remonta todas colunas
      tt=RIGHT(STR(100+t,3),2)
      cargox=db_&pas.carg&tt.
      cp_ =PARSE(@cargox,"³")                         // conteudo
      cp_masc=PARSE(@cargox,"³")                      // mascara
      cp_titu=PARSE(@cargox,"³")                      // titulo
      cp_when=PARSE(@cargox,"³")                      // pre-validacao
      cp_crit=PARSE(@cargox,"³")                      // validacao
      br_w:addcolumn(tbcolumnnew(cp_titu,&("{||"+IF(TYPE(cp_)=="M","MEMOLINE("+cp_+")","TRAN("+cp_+",["+cp_masc+"])")+"}")))
      br_w:getcolumn(t):cargo = db_&pas.carg&tt.
      br_w:getcolumn(t):width = db_&pas.tam&tt.       // tamanho da coluna
      br_w:getcolumn(t):colorblock = &("{||IF(DELE(),{3,2},IF("+cmr_+",{5,2},{1,2}))}")
     NEXT
     br_w:freeze = db_&pas.freeze                     // coluna congelada
     IF br_w:freeze != 0
      br_w:getcolumn(br_w:freeze+1):colsep := " Û "
      br_w:configure()
     ENDI
     criterio=db_&pas.arqf                            // filtro
     cpord=db_&pas.expo                               // ordem
     chv_rela=db_&pas.chvr                            // ligacao entre janelas
     ind_ord=db_&pas.ind_ord                          // indice atual
     br_w:cargo         := {criterio,cpord,chv_rela,ind_ord,cmr_}
     br_w:gobottomblock := {||FIM_ARQ()}
     br_w:gotopblock    := {||INI_ARQ()}
     br_w:skipblock     := {|n|MOV_PTR(n)}
     PEGACHV2()
     INDTMP()
     IF pas = "1"
      br_reg_ori = IF(FOUND(),RECNO(),1)
      IF TYPE("db_outro")=="C".AND.!EMPTY(db_outro)   // tem duas janelas?
       opi = EVAL(qualsis,db_outro)                   // obtem subscricao do DBF no vetor Sistema
       IF !abreoutro(opi)                             // abre o segundo browse
        EXIT
       ENDI
       SETCOLOR(drvcortna)                            // monta janela
       CAIXA(mold,br_outro:ntop-2, br_outro:nleft-1, br_outro:nbottom+1, br_outro:nright+1)
      ELSE
       EXIT
      ENDI
      pas = "2"
      tit_cons[2]=sistema[opi,O_MENS]                 // titulo da segunda janela
      DBSETORDER(ind_rela)                            // vai para utilizado da relacao
     ELSE
      br_reg_out = IF(FOUND(),RECNO(),1)              // segunda janela
      SELE (m_origem)
      br_w = br_origem
      GO br_reg_ori
      br_outro:colorspec := drvcortna+","+INVCOR(drvcortna)+","+drvcorenf+","+drvcorget+","+drvcorhlp
      FORCABRW(.f.)                                   // imprime dados na tela
      EXIT
     ENDI
    ENDD
    leat_=.f.
   ENDI
  ELSE
   RESTSCREEN(0,0,MAXROW(),79,tela_brw)              // restaura tela
  ENDI
 ELSE
  RESTSCREEN(0,0,MAXROW(),79,tela_brw)               // restaura tela
 ENDI
ENDI
IF leat_
 IF col_cp!=NIL                                      // passou arranjo das colunas
  estr_dbf=DBSTRUCT()                                // campos dos arquivo
  ct_cp=0
  FOR i=1 TO LEN(col_cp)
   t=ASCAN(estr_dbf,{|db_|UPPER(col_cp[i])==db_[1]}) // ve se a coluna e cp do arquivo
   IF t>0
    MONTA_COL()                                      // e' um campo do arquivo
   ELSE
    ct_cp++                                          // nao e' campo do arquivo
    br_w:addcolumn(tbcolumnnew(col_cp[i],&("{||"+col_cp[i]+"}")))
    i_=IF(TYPE("col_tit[i]")!="UE".AND.!EMPTY(col_tit[i]),col_tit[i],"")
    x_=LEN(&(col_cp[i]))                             // tamanho da coluna
    br_w:getcolumn(ct_cp):width := x_
    br_w:getcolumn(ct_cp):colorblock := &("{||IF(DELE(),{3,2},IF("+cmr_+",{5,2},{1,2}))}")
    x_="@X"                                          // mascara default
    IF LEFT(col_cp[i],5)="TRAN("                     // vamos tentar pegar um mascara p/ o cp
     t=RAT("[",col_cp[i])                            // separa os limitadores da mascara
     k=RAT("]",col_cp[i])
     IF t>0 .AND. t<k                                // achamos vamos pega-la..
      x_=SUBS(col_cp[i],t+1,k-t-1)
      t=RAT(",[",col_cp[i])                          // separa somente o campo
      IF t>0
       col_cp[i]=SUBST(col_cp[i],6,t-6)
      ENDI
     ENDI
    ENDI
    br_w:getcolumn(ct_cp):cargo := col_cp[i]+"³"+x_+"³"+i_+"³³V³"+VALTYPE(col_cp[i])
   ENDI
   IF TYPE("col_tit[i]")!="UE" .AND. !EMPTY(col_tit[i])
    br_w:getcolumn(ct_cp):heading := col_tit[i]
   ENDI
  NEXT
 ELSE                                                // monta consulta com todos
  estr_dbf=DBSTRUCT()                                // os campos do arquivo
  ct_cp=0
  FOR t=1 TO LEN(estr_dbf)
   IF !("I"==sistema[op_sis,O_CAMPO,t,O_CRIT])       // exceto os invisiveis...
    MONTA_COL()
   END IF
  NEXT
 ENDI
 IF LEN(chv_rela)>0                                  // tem relacionamento
  PEGACHV2()                                         // pega faixa
  INI_ARQ()                                          // vai para o inicio do arquivo
 ENDI
 br_w:gobottomblock := {||FIM_ARQ()}
 br_w:gotopblock    := {||INI_ARQ()}
 br_w:skipblock     := {|n|MOV_PTR(n)}
 IF !EMPTY(criterio) .OR. !EMPTY(cpord)              // tem filtro ou ordem inicial
  INDTMP()                                           // cria indice temporario
  INI_ARQ()                                          // vai para o inicio do arquivo
 ENDI
 br_w:cargo := {criterio,cpord,chv_rela,INDEXORD(),cmr_} // grada nova configuracao
ENDI
RELE ALL LIKE db_*                                   // libera variaveis
cod_sos=sos_cod
RETU ret_                                            // .t. montou consulta com sucesso

/*
   Sintaxe: MONTA_COL()
   Funcao.: Enche uma coluna da edita com atributos de campo
   Retorna: NIL
*/
STATIC FUNC MONTA_COL
M->ms:=sistema[op_sis,O_CAMPO,t,O_MASC]     // mascara
M->tm:=LEN(TRAN(&(FIELD(t)),M->ms))         // conteudo
M->tm:=IF(M->tm=0,34,M->tm)                 // tamanho da coluna
IF LEFT(M->ms,2)="@S"                       // mascara truncada
 M->tm:=VAL(SUBS(M->ms,3))                  // ajusta tamanho e mascara
 IF estr_dbf[t,2]!="M"
  M->ms:=ALLTRIM(SUBS(M->ms,AT(ALLTRIM(STR(M->tm)),M->ms)+LEN(ALLTRIM(STR(M->tm)))))
 END IF
END IF
ct_cp++
br_w:addcolumn(;                            // inicializa coluna
       tbcolumnnew(sistema[op_sis,O_CAMPO,t,O_TITU],;
                      &("{||"+;
                        IF(estr_dbf[t,2]=="M",;
                           "MEMOLINE("+estr_dbf[t,1]+")",;
                           "TRAN("+estr_dbf[t,1]+",["+M->ms+"])";
                        )+"}";
                       );
       );
     )
br_w:getcolumn(ct_cp):cargo := estr_dbf[t,1]+"³"+M->ms+"³"+sistema[op_sis,O_CAMPO,t,O_TITU]+"³"+;
                               sistema[op_sis,O_CAMPO,t,O_WHEN]+"³"+sistema[op_sis,O_CAMPO,t,O_CRIT]+"³"+;
                               sistema[op_sis,O_CAMPO,t,O_HELP]+"³"+sistema[op_sis,O_CAMPO,t,O_CMD]
br_w:getcolumn(ct_cp):width := M->tm
br_w:getcolumn(ct_cp):colorblock := &("{||IF(DELE(),{3,2},IF("+cmr_+",{5,2},{1,2}))}")
RETU

/*
   Sintaxe: SEPARA( <ExpC> )
   Funcao.: Separa atributos de campos da coluna da consulta
              ExpC = atributos (nome do campo/mascara/titulo/validacao)
   Retorna: NIL
*/
STATIC FUNC SEPARA(cp_atr)
cp_ =PARSE(@cp_atr,"³")     // conteudo
cp_masc=PARSE(@cp_atr,"³")  // mascara
cp_titu=PARSE(@cp_atr,"³")  // titulo
cp_when=PARSE(@cp_atr,"³")  // pre-validacao
cp_crit=PARSE(@cp_atr,"³")  // validacao (critica)
cp_help=PARSE(@cp_atr,"³")  // help do campo
cp_cmd =PARSE(@cp_atr,"³")  // comando especial
tp_cp= TYPE(cp_)            // tipo da coluna
IF tp_cp="UI"               // se tipo indefinido
 tp_cp = VALTYPE(cp_)       // tenta pegar o conteudo do campo
 IF tp_cp = "UI"            // se ainda continua indefinido
  tp_cp="C"                 // forca caracter
 ENDI
ENDI
RETU NIL

/*
   Sintaxe: DIR_CUR()
   Funcao.: Muda direcionamento do cursor dentro da funcao EDITA() quando
            o TAB e' acionado
   Retorna: NIL
*/
STATIC FUNC DIR_CUR
dir_cur=IF(dir_cur=4,1,dir_cur+1)
@ br_w:nbottom+1,br_w:nleft+posi_cur+5 SAY CHR(VAL(SUBS(di_tecl,dir_cur*2-1,2)))
RETU NIL

/*
   Sintaxe: COLNOVA()
   Funcao.: Cria uma nova coluna na consulta
   Retorna: NIL
*/
STATIC FUNC COLNOVA
LOCAL brw_tela, ar_, i, ii, db:="", msg:="", qt_ind, op_ind
PRIV cod_sos:=1
brw_tela = SAVESCREEN(0,0,MAXROW(),79)                 // salva tela e monta
FOR i=1 TO nss                                         // menu dos arquivos possiveis
 IF sistema[i,O_ARQUI,O_NOME]!=ALIAS(VAL(m_origem)) .AND. ;
    IF(EMPTY(outro_db),.t.,sistema[i,O_ARQUI,O_NOME]!=ALIAS(VAL(outro_db))) .AND.;
    sistema[i,O_OUTROS,O_NIVEL]<=nivelop .AND.;
    LEN(sistema[i,O_INDIC])>0
  msg+="|"+sistema[i,O_MENU]
  db+=RIGHT(STR(1000+i),3)
 ENDI
NEXT
IF LEN(msg) <= 0                                       // nao existe arq a escolher
 ALERTA()
 DBOX("N„o h  mais arquivos dispon¡veis",15,,3,,"ATEN€ŽO!, "+usuario)
 KEYB CHR(K_ESC)
ELSE
 tit="SELECIONE O ARQUIVO|DO QUAL SER MOSTRADO O CAMPO"
 op_a=DBOX(SUBS(msg,2),,,E_MENU,,tit)                  // escolhe um arquivo
 ar_:=SELECT()
 IF op_a>0                                             // escolheu...
  op_a=VAL(SUBS(db,op_a*3-2,3))                        // subscricao de "sistema"
  db=sistema[op_a,O_ARQUI,O_NOME]                      // nome do arquivo (sem dir)
  IF USEARQ(db)                                        // abre o arquivo
   op_ind=1                                            // indice 'default`
   qt_ind=LEN(sistema[op_a,O_INDIC])                   // qde de indices do arquivo
   IF ATAIL(sistema[op_a,O_CHAVE])="codlan"         // o ntx de relacionamento nao pode...
    qt_ind--
   ENDI
   IF qt_ind>1                                         // escolhe um conjunto de indice
    msg=""
    FOR i=1 to qt_ind
     msg+="|"+sistema[op_a,O_CONSU,i]
    NEXT
    op_ind=DBOX(SUBS(msg,2),,,E_MENU,,"SELECIONE O INDICE")
    IF op_ind>1
     DBSETORDER(op_ind)
    ENDI
   ENDI
   SELE (ar_)
   IF PEGARELA(.f.)                                    // pega campos de relacionamentos
    msg=""
    SELE (db)
    FOR i=1 TO FCOU()                                  // menu de campos
     IF !("I"==sistema[op_a,O_CAMPO,i,O_CRIT])         // exceto os invisiveis...
      msg+="|"+sistema[op_a,O_CAMPO,i,O_TITU]
     ENDI
    NEXT
    op_0=DBOX(SUBS(msg,2),,,E_MENU,,"CAMPO A MOSTRAR NA NOVA COLUNA")
    IF LASTKEY()!=K_ESC .AND. op_0 > 0                 // escolheu um campo
     ii=0
     FOR i=1 TO FCOU()                                 // acha campo escolhido
      IF !("I"==sistema[op_a,O_CAMPO,i,O_CRIT])
       ii++
      ENDI
      IF ii=op_0
       op_0=i
       EXIT
      ENDI
     NEXT
     v_ar=READVAR()                                   // titulo da coluna
     &v_ar.:=sistema[op_a,O_CAMPO,op_0,O_TITU]        // contera' o titulo do campo
     cp_masc:=sistema[op_a,O_CAMPO,op_0,O_MASC]       // mascara
     cp_ =ALLTRIM(STR(op_ind))+"}"+cp_+"|"+;       // expressao para relacionar
          db+"->"+FIEL(op_0)
    ELSE
     cp_=" "
    ENDI
   ELSE
    cp_=" "
   ENDI
  ENDI
 ENDI
 SELE (ar_)                                           // seleciona arquivo original
 f10=.t.
 KEYB CHR(K_CTRL_W)                                   // forca saida do get pendente
ENDI
RETU NIL

/*
   Sintaxe: PEGARELA( <ExpL> )
   Funcao.: Monta menu com arquivos e campos para relacionamento
              ExpL = .t. relacao entre duas janelas
                     .f. relacao entre colunas
   Retorna: .t. se teve sucesso.
*/
STATIC FUNC PEGARELA(fl)
LOCAL tit_chv:="", msg:="", op_0:=0, cp_rela:="", ii
PRIV cod_sos:=31
op_x = EVAL(qualsis,ALIAS())                // subscricao do arquivo atual
FOR i=1 TO FCOU()                           // monta menu com os campos do
 IF !("I"==sistema[op_x,O_CAMPO,i,O_CRIT])  // arquivo, exceto os invisiveis
  msg+="|"+sistema[op_x,O_CAMPO,i,O_TITU]
 ENDI
NEXT                                        // titulo da DBOX()
tit="RELACIONAMENTO|*|ESCOLHA O CAMPO PARA|SINCRONIZAR OS ARQUIVOS|ESC=FIM|*"
IF fl
 chv_rela=""                                // vai sincronizar duas janelas
ENDI
temrela=.f.
DO WHIL .t.                                 // escolhe um campo
 op_0=DBOX(SUBS(msg,2),,,E_MENU,,tit+tit_chv,,,op_0)
 IF LASTKEY()=K_ESC .OR. op_0<=0
  EXIT                                      // cancelou ou ja terminou
 ENDI
 ii=0                                       // procura campo escolhido
 FOR i=1 TO FCOU()
  IF !("I"==sistema[op_x,O_CAMPO,i,O_CRIT]) // despreza os invisiveis
   ii++
  ENDI
  IF ii=op_0
   op_0=i
   EXIT
  ENDI
 NEXT
 cp_ = FIEL(op_0)                           // campo escolhido
 IF TYPE(cp_)="M"
  DBOX("Campo ilegal",,,3,,"ATEN€ŽO!")      // campo memo nao pode...
  LOOP
 ELSE
  temrela=.t.                               // atualiza o titulo da DBOX()
  tit_chv+="|"+MAIUSC(sistema[op_x,O_CAMPO,op_0,O_TITU])+","
  cp_=TRANSCAMPO(.f.,cp_,op_0)              // transforma campo em caracter
  IF fl
   chv_rela+="+"+ALIAS()+"->("+cp_+")"      // chave de relacionamento entre janelas
  ENDI
  cp_rela+="+"+cp_                          // mais um campo de sincronismo?
  op_0=DBOX("Prosseguir|Informar outro campo",,,E_MENU,,"RELACIONAMENTO POR"+tit_chv)
  IF op_0!=2
   cp_=SUBS(cp_rela,2)                      // sincronismo terminado
   EXIT
  ENDI
 ENDI
ENDD
RETU temrela

/*
   Sintaxe: SETARELA( <ExpC> )
   Funcao.: Estabelece relacionamento de arquivos na consulta
              ExpC = parametros de relacionamento
   Retorna: .t. se relacionou
*/
STATIC FUNC SETARELA(p_cp)
op_ind=1                           // indice 'default`
IF VAL(p_cp)>0                     // existe um indice?
 op_ind=VAL(p_cp)                  // vamos utiliza-lo
 p_cp=SUBS(p_cp,AT("}",p_cp)+1)    // arruma expressao de relacionamento
ENDI
p_m=RAT("->",p_cp)
p_b=AT("|",p_cp)
IF p_m>0 .AND. p_b>0               // existe campo e arq para o relacionamento
 c_rel=LEFT(p_cp,p_b-1)            // campo ou expressao para a relacao
 a_u=SUBS(p_cp,p_b+1,(p_m-1)-p_b)  // nome do arquivo que sera' relacionado
 a_r_=SELEC()
 IF USEARQ(a_u)                    // abre arquivo e seus indices
  DBSETORDER(op_ind)         // indice escolhido...
  SELE (a_r_)
  ja=.f.
  FOR t=1 TO 99                    // verifica se a relacao ja' foi feita
   x=DBRSELECT(t)
   IF x>0
    IF UPPER(a_u) == ALIAS(x)
     ja=.t.                        // existe o relacionamento
     EXIT
    ENDI
   ENDI
  NEXT
  IF !ja                           // relaciona se nao tem o relacionamento
   SET RELA ADDI TO &c_rel. INTO &a_u.
  ENDI
 ELSE
  CLOSE ALL                        // ocorreu erro de abertura de arquivo
  BREAK                            // cancela toda a operacao
 ENDI
ENDI
RETU (p_m>0 .AND. p_b>0)           // retorna .t. se relacionou

* \\ Final de ADR_FUNC.PRG
/*
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
 \ Empresa.: PresServ Inform tica - Limeira (019)452.6623
 \ Programa: BXREC.PRG
 \ Data....: 04-11-03
 \ Sistema.: Administradora - RECEP€„O
 \ Funcao..: Gerenciador do subsistema de recebimentos
 \ Analista: Ademilson Pedro Bom
 \ Criacao.: GAS-Pro v4.0n
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/

#include "adrbig.ch"    // inicializa constantes manifestas

PARA lin_menu,col_menu
PRIV op_sis, tela_fundo:=SAVESCREEN(0,0,MAXROW(),79), l_s, c_s, l_i, c_i, l_a

op_sis=EVAL(qualsis,"BXREC")
IF nivelop<sistema[op_sis,O_OUTROS,O_NIVEL]        // se usuario nao tem permissao,
 ALERTA()                                          // entao, beep, beep, beep
 DBOX(msg_auto,,,3)                                // lamentamos e
 RETU                                              // retornamos ao menu
ENDI
cn:=fgrep :=.f.

#ifdef COM_LOCK
 IF LEN(pr_ok)>0                                   // se a protecao acusou
  ? pr_ok                                          // erro, avisa e
  QUIT                                             // encerra a aplicacao
 ENDI
#endi

t_fundo=SAVESCREEN(0,0,MAXROW(),79)                // salva tela do fundo
op_cad=1
DO WHIL op_cad!=0
 criterio=""
 RESTSCREEN(0,0,MAXROW(),79,t_fundo)               // restaura tela do fundo
 cod_sos=5 ; cn=.f.
 CLEA TYPEAHEAD                                    // limpa o buffer do teclado
 fgrep=.f.
 SET KEY K_F3 TO                                   // retira das teclas F3 e F4 as
 SET KEY K_F4 TO                                   // funcoes de repeticao e confirmacao
 if nivelop>2
  msg="Inclus„o~1|"+;
     "Manuten‡„o~2|"+;
     "Consulta~3"
  op_cad=DBOX(msg,lin_menu,col_menu,E_MENU,NAO_APAGA,MAIUSC(sistema[op_sis,O_MENU]),,,op_cad)
 else
  op_cad=1
 endif
 IF op_cad!=0                                      // se escolheu uma opcao
  Tela_fundo=SAVESCREEN(0,0,MAXROW(),79)           // salva a tela para ROLATELA()
  PARAMETROS(dbfparam)
  SELE A                                           // e abre o arquivo e seus indices

  #ifdef COM_REDE
   IF !USEARQ(sistema[op_sis,O_ARQUI,O_NOME],.f.,20,1)
						   // se falhou a abertura do
    RETU                                           // arquivo volta ao menu anterior
   ENDI
  #else
   USEARQ(sistema[op_sis,O_ARQUI,O_NOME])
  #endi

  SET KEY K_F9 TO veoutros                         // habilita consulta em outros arquivos
  Vinscr:=[]
  SET KEY K_F2 TO veinscrits()                         // habilita consulta em outros arquivos
 ENDI
 DO CASE
  CASE op_cad=01                                   // inclus„o
   op_menu=INCLUSAO
   IF AT("D",exrot[op_sis])=0                      // se usuario pode fazer inclusao
    BXR_INCL()                                     // neste arquivo chama prg de inclusao
   ELSE                                            // caso contrario vamos avisar que
    ALERTA()                                       // ele nao tem permissao para isto
    DBOX(msg_auto,,,3)
   ENDI

  CASE op_cad=02                                   // manuten‡„o
   op_menu=ALTERACAO
   cod_sos=7
   EDIT()

  CASE op_cad=03                                   // consulta
   op_menu=PROJECOES
   cod_sos=8
   EDITA(03,03,MAXROW()-2,77)

 ENDC
 SET KEY K_F9 TO                                   // F9 nao mais consultara outros arquivos
 set key K_F2 TO
 CLOS ALL                                          // fecha todos arquivos abertos
 exit
ENDD
RETU

PROC BXR_incl(reg_cop)  // inclusao no arquivo BXREC
LOCAL getlist:={},cabem:=1,rep:=ARRAY(FCOU()),ult_reg:=RECN(),cond_incl_,dbfseq_,;
      ctl_r, ctl_c, ctl_w, t_f3_, t_f4_, dele_atu:=SET(_SET_DELETED,.f.)
PRIV op_menu:=INCLUSAO, sq_atual_, tem_borda, criterio:="", cpord:=""
cond_incl_={||nivelop>1}                           // condicao de inclusao de registros
IF !EVAL(cond_incl_)                               // se nao pode incluir
 ALERTA(2)                                         // avisa o motivo
 DBOX("Permitido apenas a usu rios cadastrados|com n¡vel de Manuten‡„o ou Maior",,,4,,"ATEN€ŽO, "+usuario)
 RETU                                              // e retorna
ENDI
FOR i=1 TO FCOU()                                  // cria/declara privadas as
 msg=FIEL(i)                                       // variaveis de memoria com
 PRIV &msg.                                        // o mesmo nome dos campos
NEXT                                               // do arquivo
IF reg_cop!=NIL                                    // quer repetir todo o reg atual
 FOR i=1 TO FCOU()                                 // para cada campo,
  msg=FIEL(i)                                      // salva o conteudo
  rep[i]=&msg.                                     // para repetir
 NEXT
ELSE
 AFILL(rep,"")                                     // eche com valor vazio
ENDI
t_f3_=SETKEY(K_F3,{||rep()})                       // repeticao reg anterior
t_f4_=SETKEY(K_F4,{||conf()})                      // confirma campos com ENTER
ctl_w=SETKEY(K_CTRL_W,{||nadafaz()})               // enganando o CA-Clipper...
ctl_c=SETKEY(K_CTRL_C,{||nadafaz()})
ctl_r=SETKEY(K_CTRL_R,{||nadafaz()})

#ifdef COM_REDE
 BXR_CRIA_SEQ()                                    // cria dbf de controle de cp sequenciais
 FOR i=1 TO FCOU()                                 // cria/declara privadas as
  msg="sq_"+FIEL(i)                                // variaveis de memoria com
  PRIV &msg.                                       // o mesmo nome dos campos
 NEXT                                              // do arquivo com extensao _seq
#endi

DO WHIL cabem>0
 cod_sos=6
 rola_t=.f.                                        // flag se quer rolar a tela
 SELE BXREC
 GO BOTT                                           // forca o
 SKIP                                              // final do arquivo
 
 /*
    cria variaveis de memoria identicas as de arquivo, para inclusao
    de registros
 */
 FOR i=1 TO FCOU()
  msg=FIEL(i)
  M->&msg.=IF((fgrep .OR. reg_cop!=NIL).AND.!EMPT(rep[1]),rep[i],&msg.)
 NEXT
 DISPBEGIN()                                       // apresenta a tela de uma vez so
 BXR_TELA()
 INFOSIS(.t.)                                      // exibe informacao no rodape' da tela
 DISPEND()
 BXR_GERA_SEQ()
 IF !EVAL(cond_incl_)
  EXIT
 ENDI
 cabem=DISKSPACE(;
          IF(;
             LEN(sistema[op_sis,O_ARQUI,O_DIR_DBF])<2.OR.sistema[op_sis,O_ARQUI,O_DIR_DBF]="\",;
             0,;
             ASC(sistema[op_sis,O_ARQUI,O_DIR_DBF])-64;
          );
       )
 cabem=INT((cabem-2048)/BXREC->(RECSIZE()))
 IF cabem<1                                        // mais nenhum!!!
  ALERTA()
  msg="Verifique ESPA€O EM DISCO, "+usuario
  DBOX(msg,,,,,"INCLUSŽO INTERROMPIDA!")           // vamos parar por aqui!
  EXIT
 ENDI
 SELE 0                                            // torna visiveis variaveis de memoria
 BXR_GET1(INCLUI)                                  // recebe campos
 SELE BXREC
 IF LASTKEY()=K_ESC                                // se cancelou
  cabem=0                                          // prepara saida da inclusao
  LOOP
 ENDI

 #ifdef COM_REDE
  GO BOTT                                          // vamos bloquear o final do
  SKIP                                             // arq para que nehum outro
  BLOREG(0,.5)                                     // usuario possa incluir
 #endi

 APPEND BLANK                                      // inclui reg em branco no dbf
 FOR i=1 TO FCOU()                                 // para cada campo,
  msg=FIEL(i)                                      // salva o conteudo
  rep[i]=M->&msg.                                  // para repetir
  REPL &msg. WITH rep[i]                           // enche o campo do arquivo
 NEXT

 #ifdef COM_REDE
  UNLOCK                                           // libera o registro e
  COMMIT                                           // forca gravacao
 #else
  IF RECC()-INT(RECC()/20)*20=0                    // a cada 20 registros
   COMMIT                                          // digitados forca gravacao
  ENDI
 #endi

 ult_reg=RECN()                                    // ultimo registro digitado
 BXR_REL(ult_reg)                               // imprime relat apos inclusao
 IF reg_cop!=NIL                                   // estava na consulta e quis rep o campo
  sq_atual_=NIL
  EXIT                                             // cai fora...
 ENDI
ENDD

#ifdef COM_REDE
 BXR_ANT_SEQ()                                     // restaura sequencial anterior
 SELE BXREC
#endi

GO ult_reg                                         // para o ultimo reg digitado
SETKEY(K_F3,t_f3_)                                 // restaura teclas de funcoes
SETKEY(K_F4,t_f4_)
SET(_SET_DELETED,dele_atu)                            // ecluidos visiveis/invisiveis
SETKEY(K_CTRL_W,ctl_w)
SETKEY(K_CTRL_C,ctl_c)
SETKEY(K_CTRL_R,ctl_r)
RETU


PROC BXR_REL(ult_reg)  // imprime relatorio apos inclusao
LOCAL p_imp:=.t., i_ok:=.f., imp_rel:=.f.
DO WHIL .t.
 SAVE SCREEN                     // salva a tela

 #ifdef COM_REDE
  tps=TP_SAIDA(,,.t.)
  IF LASTKEY()=K_ESC
   EXIT
  ENDI
  i_ok=(tps=2 .OR. PREPIMP("TAXAS (RECEP€ŽO)"))
  IF i_ok
   ADM_RS18(tps,0,ult_reg)
   imp_rel=.t.
  ENDI
 #else
  i_ok=PREPIMP("TAXAS (RECEP€ŽO)")
  IF i_ok
   ADM_RS18(0,0,ult_reg)
   imp_rel=.t.
  ENDI
 #endi

 REST SCREEN                    // restaura tela
 IF imp_rel                     // imprimiu algo?
  msg="Prosseguir|Outra c¢pia"
  op_=1 //DBOX(msg,,,E_MENU,,"FIM DE IMPRESSŽO") // quer emitir outra copia?
  IF op_=2
   LOOP                         // nao quer...
  ENDI
 ENDI
 EXIT
ENDD
RETU


#ifdef COM_REDE
 PROC BXR_ANT_SEQ(est_seq)     // restaura sequencial anterior
 SELE BXR_SEQ     // seleciona arquivo de controle de sequencial
 BLOARQ(0,.5)     // esta estacao foi a ultima a incluir?
 IF sq_atual_ == numero
  REPL numero WITH sq_numero
  REPL intlan WITH sq_intlan
 ENDI
 UNLOCK           // libera DBF para outros usuarios
 COMMIT           // atualiza cps sequenciais no disco
 RETU
#endi


PROC BXR_CRIA_SEQ   // cria dbf de controle de campos sequenciais
LOCAL dbfseq_:=sistema[op_sis,O_ARQUI,O_DIR_DBF]+"BXR_seq" // arq temporario
SELE 0                          // seleciona area vazia
IF !FILE(dbfseq_+".dbf")        // se o dbf nao existe
 DBCREATE(dbfseq_,{;            // vamos criar a sua estrutura
                    {"numero"    ,"C",  8, 0},;
                    {"intlan"    ,"C",  8, 0};
                  };
 )
ENDI
USEARQ(dbfseq_,.f.,,,.f.)       // abre arquivo de cps sequencial
IF RECC()=0                     // se o dbf foi criado agora
 BLOARQ(0,.5)                   // inclui um registro que tera
 APPEND BLANK                   // os ultomos cps sequenciais
 SELE BXREC
 IF RECC()>0                    // se o DBF nao estiver
  SET ORDER TO 0                // vazio, entao enche DBF seq
  GO BOTT                       // com o ultimo reg digitado
  REPL BXR_SEQ->numero WITH numero
  REPL BXR_SEQ->intlan WITH intlan
  DBSETORDER(1)                 // retorna ao indice principal
 ENDI
 SELE BXR_SEQ                   // seleciona arq de sequencias
 UNLOCK                         // libera DBF para outros usuarios
 COMMIT                         // atualiza cps sequenciais no disco
ENDI
RETURN

PROC BXR_GERA_SEQ()

#ifdef COM_REDE
 LOCAL ar_:=SELEC()
#else
 LOCAL reg_:=RECNO(),ord_ind:=INDEXORD()
#endi


#ifdef COM_REDE
 SELE BXR_SEQ
 BLOARQ(0,.5)
 sq_numero=BXR_SEQ->numero
 sq_intlan=BXR_SEQ->intlan
#else
 DBSETORDER(0)
 GO BOTT
#endi

M->numero=LPAD(STR(VAL(numero)+1),08,[0])
IF VAL(M->numero)=1
 M->numero=LPAD(RIGHT(DTOC(DATE()),2)+[000001],08,[0])
ENDI
M->intlan=LPAD(STR(VAL(intlan)+1),08,[0])

#ifdef COM_REDE
 BXR_GRAVA_SEQ()
 sq_atual_=BXR_SEQ->numero
 UNLOCK                                            // libera o registro
 COMMIT
 SELE (ar_)
#else
 DBSETORDER(ord_ind)
 GO reg_
#endi

RETU

PROC BXR_GRAVA_SEQ
REPL numero WITH M->numero
REPL intlan WITH M->intlan
RETU

PROC BXR_tela     // tela do arquivo BXREC
tem_borda=.t.
l_s=Sistema[op_sis,O_TELA,O_LS]           // coordenadas da tela
c_s=Sistema[op_sis,O_TELA,O_CS]
l_i=Sistema[op_sis,O_TELA,O_LI]
c_i=Sistema[op_sis,O_TELA,O_CI]
SETCOLOR(drvtittel)
vr_memo=NOVAPOSI(@l_s,@c_s,@l_i,@c_i)     // pega posicao atual da tela
CAIXA(mold,l_s,c_s,l_i,c_i)               // monta caixa da tela
i=LEN(sistema[op_sis,O_MENS])/2
@ l_s,c_s-1+(c_i-c_s+1)/2-i SAY " "+MAIUSC(sistema[op_sis,O_MENS])+" "
SETCOLOR(drvcortel)
@ l_s+01,c_s+1 SAY " Numero:"
@ l_s+02,c_s+1 SAY " Contrato:"
@ l_s+03,c_s+1 SAY "ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ"
@ l_s+04,c_s+1 SAY "                                      ³Circulares"
@ l_s+05,c_s+1 SAY "                                      ³ Ini"
@ l_s+06,c_s+1 SAY "                            Reg.:     ³  £lt"
@ l_s+07,c_s+1 SAY "                                      ³"
@ l_s+08,c_s+1 SAY " Admiss„o:            Sai Taxa:       ³"
@ l_s+09,c_s+1 SAY " Funerais:            Cobrador:       ³"
@ l_s+10,c_s+1 SAY "ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ"
@ l_s+15,c_s+1 SAY "ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ"
@ l_s+16,c_s+1 SAY " Ref.:                       Vl.Pago:"
@ l_s+17,c_s+1 SAY " Pago com..:             Troco:"
@ l_s+19,c_s+1 SAY "  emitida em             por"
RETU

PROC BXR_gets     // mostra variaveis do arquivo BXREC
LOCAL getlist := {}, ord_, chv_, ar_get1:=ALIAS(), op_ant := op_menu
BXR_TELA()
SETCOLOR(drvcortel+","+drvcorget+",,,"+corcampo)
PTAB(CODIGO,[GRUPOS])
PTAB(IIF(EMPT(M->USUARIO),PADR(M->CONTAREC+IDE_MAQ,10,' '),PADR(M->USUARIO,10,' '))+M->HISTRCFCC+[       ],'ORDPGRC',2)
PTAB(PADR(SUBSTR(M->IDE_MAQ,2),4)+[BXR],[IMPPAR],1)
CRIT("",,"16")
@ l_s+01 ,c_s+12 GET  numero;
		 PICT sistema[op_sis,O_CAMPO,01,O_MASC]

@ l_s+02 ,c_s+12 GET  codigo;
                 PICT sistema[op_sis,O_CAMPO,02,O_MASC]
                 CRIT(sistema[op_sis,O_CAMPO,02,O_CRIT],,"1|2|3|4|5|6|7|8|9|10|11|12|13|14")

@ l_s+16 ,c_s+08 GET  cobranca;
                 PICT sistema[op_sis,O_CAMPO,03,O_MASC]

@ l_s+16 ,c_s+39 GET  valorpg;
                 PICT sistema[op_sis,O_CAMPO,04,O_MASC]

@ l_s+17 ,c_s+14 GET  valoraux;
                 PICT sistema[op_sis,O_CAMPO,05,O_MASC]
                 CRIT(sistema[op_sis,O_CAMPO,05,O_CRIT],,"15")

@ l_s+19 ,c_s+14 GET  emitido_;
                 PICT sistema[op_sis,O_CAMPO,06,O_MASC]

@ l_s+19 ,c_s+30 GET  por

@ l_s+19 ,c_s+44 GET  numop;
                 PICT sistema[op_sis,O_CAMPO,08,O_MASC]

CRIT("",,"1|3|4|5|6|7|8|9|10|11|12|13|14")
CLEAR GETS
RETU

PROC BXR_get1(tp_mov)     // capta variaveis do arquivo BXREC
LOCAL getlist := {}, ord_, chv_, ar_get1:=ALIAS(), op_ant := op_menu
PRIV  blk_bxrec:=.t.

IF tp_mov=INCLUI
 DO WHILE .t.
  rola_t=.f.
  SET KEY K_ALT_F8 TO ROLATELA
  SETCOLOR(drvcortel+","+drvcorget+",,,"+corcampo)
  @ l_s+01 ,c_s+12 GET numero;
                   PICT sistema[op_sis,O_CAMPO,01,O_MASC]
  @ l_s+19 ,c_s+14 GET emitido_;
		   PICT sistema[op_sis,O_CAMPO,06,O_MASC]
  @ l_s+19 ,c_s+30 GET por
  @ l_s+19 ,c_s+44 GET numop;
                   PICT sistema[op_sis,O_CAMPO,08,O_MASC]
  CLEA GETS
  CRIT("",,"16")
  @ l_s+02 ,c_s+12 GET  codigo;
                   PICT sistema[op_sis,O_CAMPO,02,O_MASC]
                   DEFINICAO 2
                   MOSTRA sistema[op_sis,O_FORMULA,1]
                   MOSTRA sistema[op_sis,O_FORMULA,2]
                   MOSTRA sistema[op_sis,O_FORMULA,3]
                   MOSTRA sistema[op_sis,O_FORMULA,4]
                   MOSTRA sistema[op_sis,O_FORMULA,5]
                   MOSTRA sistema[op_sis,O_FORMULA,6]
                   MOSTRA sistema[op_sis,O_FORMULA,7]
                   MOSTRA sistema[op_sis,O_FORMULA,8]
                   MOSTRA sistema[op_sis,O_FORMULA,9]
                   MOSTRA sistema[op_sis,O_FORMULA,10]
                   MOSTRA sistema[op_sis,O_FORMULA,11]
		   MOSTRA sistema[op_sis,O_FORMULA,12]
                   MOSTRA sistema[op_sis,O_FORMULA,13]
                   MOSTRA sistema[op_sis,O_FORMULA,14]

  @ l_s+16 ,c_s+08 GET  cobranca;
                   PICT sistema[op_sis,O_CAMPO,03,O_MASC]
                   DEFINICAO 3

  @ l_s+16 ,c_s+39 GET  valorpg;
                   PICT sistema[op_sis,O_CAMPO,04,O_MASC]
                   DEFINICAO 4

  @ l_s+17 ,c_s+14 GET  valoraux;
                   PICT sistema[op_sis,O_CAMPO,05,O_MASC]
                   DEFINICAO 5
                   MOSTRA sistema[op_sis,O_FORMULA,15]

  READ
  SET KEY K_ALT_F8 TO
  IF rola_t
   ROLATELA()
   LOOP
  ENDI
  IF LASTKEY()!=K_ESC .AND. drvincl .AND. op_menu=INCLUSAO
   IF !CONFINCL()
    LOOP
   ENDI
  ENDI
  EXIT
 ENDD
ENDI
PTAB(CODIGO,[GRUPOS])
PTAB(LEFT(COBRANCA,15),'TAXAS',1)
PTAB(IIF(EMPT(M->USUARIO),PADR(M->CONTAREC+IDE_MAQ,10,' '),PADR(M->USUARIO,10,' '))+M->HISTRCFCC+[       ],'ORDPGRC',2)
PTAB(PADR(SUBSTR(M->IDE_MAQ,2),4)+[BXR],[IMPPAR],1)
IF tp_mov=EXCLUI .OR. tp_mov=FORM_INVERSA

 #ifdef COM_REDE
  IF EMPT(numop)
   IF !EMPTY(ALIAS())
    REPL numop WITH ORDPGRC->numop
   ENDI
  ENDI
  IF PTAB(numop,'ORDPGRC',1)
   REPBLO('ORDPGRC->nrdoctos',{||ORDPGRC->nrdoctos - 1})
  ENDI
  IF !EMPT(valorpg)
   REPBLO('TAXAS->pgto_',{||CTOD('')})
   REPBLO('TAXAS->forma',{||[ ]})
   REPBLO('TAXAS->baixa_',{||CTOD('  /  /  ')})
   REPBLO('TAXAS->stat',{||[ ]})
   REPBLO('TAXAS->valorpg',{||0})
  ENDI
  IF EMPT(numop).AND.PTAB(IIF(EMPT(M->usuario),PADR(M->contarec+ide_maq,10,' '),PADR(M->usuario,10,' '))+M->histrcfcc+[       ],'ORDPGRC',2)
   REPBLO('ORDPGRC->valortotal',{||ORDPGRC->valortotal-valorpg})
  ENDI
  IF !EMPT(numop).AND.PTAB(numop,'ORDPGRC',1)
   REPBLO('ORDPGRC->valortotal',{||ORDPGRC->valortotal -valorpg})
  ENDI
 #else
  IF EMPT(numop)
   IF !EMPTY(ALIAS())
    REPL numop WITH ORDPGRC->numop
   ENDI
  ENDI
  IF PTAB(numop,'ORDPGRC',1)
   REPL ORDPGRC->nrdoctos WITH ORDPGRC->nrdoctos - 1
  ENDI
  IF !EMPT(valorpg)
   REPL TAXAS->pgto_ WITH CTOD('')
   REPL TAXAS->forma WITH [ ]
   REPL TAXAS->baixa_ WITH CTOD('  /  /  ')
   REPL TAXAS->stat WITH [ ]
   REPL TAXAS->valorpg WITH 0
  ENDI
  IF EMPT(numop).AND.PTAB(IIF(EMPT(M->usuario),PADR(M->contarec+ide_maq,10,' '),PADR(M->usuario,10,' '))+M->histrcfcc+[       ],'ORDPGRC',2)
   REPL ORDPGRC->valortotal WITH ORDPGRC->valortotal-valorpg
  ENDI
  IF !EMPT(numop).AND.PTAB(numop,'ORDPGRC',1)
   REPL ORDPGRC->valortotal WITH ORDPGRC->valortotal -valorpg
  ENDI
 #endi

 IF 1=3
  IF !EMPTY(ORDPGRC->codlan)
   TIRA_LANC("ORDPGRC",LEFT(ORDPGRC->codlan,16),.f.)
  ENDI
 ENDI
 IF 1=3
  IF !EMPTY(IMPPAR->codlan)
   TIRA_LANC("IMPPAR",LEFT(IMPPAR->codlan,16))
  ENDI
 ENDI
 IF !EMPTY(ALIAS())
  DELE
 ENDI
ELSEIF tp_mov=INCLUI .OR. tp_mov=RECUPERA .OR. tp_mov=FORM_DIRETA
 IF (op_menu=INCLUSAO .AND. LASTKEY()!=K_ESC) .OR. op_menu!=INCLUSAO
  IF !EMPT(valorpg).AND. !PTAB(IIF(EMPT(M->usuario),PADR(M->contarec+ide_maq,10,' '),PADR(M->usuario,10,' '))+M->histrcfcc+[       ],'ORDPGRC',2)
   ord_=LEN(sistema[EVAL(qualsis,"ORDPGRC"),O_CHAVE])
   IF !EMPTY(ORDPGRC->codlan)
    chv_=LEFT(ORDPGRC->codlan,16)
   ELSE
    IF TYPE("M->intlan")="C" .AND. EMPTY(intlan)
     chv_="BXR-"+M->intlan+"-001"
    ELSE
     chv_="BXR-"+intlan+"-001"
    ENDI
   ENDI
   PTAB(chv_,"ORDPGRC",ord_)
   FAZ_LANC("ORDPGRC",chv_,.t.)
   REPL ORDPGRC->origem WITH [ADM],;
        ORDPGRC->lancto_ WITH DATE(),;
        ORDPGRC->por WITH M->usuario,;
        ORDPGRC->numconta WITH IIF(EMPT(M->usuario),PADR(M->contarec+ide_maq,10,' '),PADR(M->usuario,10,' ')),;
        ORDPGRC->historico WITH M->histrcfcc,;
        ORDPGRC->debcred WITH [C],;
        ORDPGRC->valortotal WITH 0,;
        ORDPGRC->vencto_ WITH DATE(),;
        ORDPGRC->documento WITH [FCC/Taxas],;
	ORDPGRC->complement WITH [FCC/Taxas pagas na Recep‡„o]

   #ifdef COM_REDE
    ORDPGRC->(DBUNLOCK())                          // libera o registro
   #endi

  ENDI
  IF !PTAB(PADR(SUBSTR(M->ide_maq,2),4)+[BXR],[IMPPAR],1)
   ord_=LEN(sistema[EVAL(qualsis,"IMPPAR"),O_CHAVE])
   IF !EMPTY(IMPPAR->codlan)
    chv_=LEFT(IMPPAR->codlan,16)
   ELSE
    IF TYPE("M->intlan")="C" .AND. EMPTY(intlan)
     chv_="BXR-"+M->intlan+"-002"
    ELSE
     chv_="BXR-"+intlan+"-002"
    ENDI
   ENDI
   PTAB(chv_,"IMPPAR",ord_)
   FAZ_LANC("IMPPAR",chv_)
   REPL IMPPAR->idmaq WITH PADR(SUBSTR(M->ide_maq,2),4),;
        IMPPAR->base WITH [BXR]

   #ifdef COM_REDE
    IMPPAR->(DBUNLOCK())                           // libera o registro
   #endi

  ENDI
   IF EMPT(numop)
    IF op_menu=INCLUSAO
     numop=ORDPGRC->numop
    ELSE
     REPL numop WITH ORDPGRC->numop
    ENDI
   ENDI

  #ifdef COM_REDE
   IF PTAB(numop,'ORDPGRC',1)
    REPBLO('ORDPGRC->nrdoctos',{||ORDPGRC->nrdoctos + 1})
   ENDI
   IF !EMPT(valorpg)
    REPBLO('TAXAS->pgto_',{||DATE()})
   ENDI
   IF !EMPT(valorpg)
    REPBLO('TAXAS->forma',{||[P]})
   ENDI
   IF !EMPT(valorpg)
    REPBLO('TAXAS->baixa_',{||DATE()})
   ENDI
   IF !EMPT(valorpg)
    REPBLO('TAXAS->por',{||M->usuario})
   ENDI
   IF !EMPT(valorpg)
    REPBLO('TAXAS->stat',{||[6]})
   ENDI
   IF !EMPT(valorpg)
    REPBLO('TAXAS->valorpg',{||valorpg})
   ENDI
   IF op_menu=INCLUSAO
    emitido_=DATE()
   ELSE
    REPL emitido_ WITH DATE()
   ENDI
   IF op_menu=INCLUSAO
    por=M->usuario
   ELSE
    REPL por WITH M->usuario
   ENDI
   IF op_menu=INCLUSAO
    filial=M->p_filial
   ELSE
    REPL filial WITH M->p_filial
   ENDI
   IF EMPT(numop).AND.PTAB(IIF(EMPT(M->usuario),PADR(M->contarec+ide_maq,10,' '),PADR(M->usuario,10,' '))+M->histrcfcc+[       ],'ORDPGRC',2)
    REPBLO('ORDPGRC->valortotal',{||ORDPGRC->valortotal+valorpg})
   ENDI
   IF !EMPT(numop).AND.PTAB(numop,'ORDPGRC',1)
    REPBLO('ORDPGRC->valortotal',{||ORDPGRC->valortotal +valorpg})
   ENDI
   IF PTAB(PADR(SUBSTR(M->ide_maq,2),4)+[BXR],[IMPPAR],1)
    REPBLO('IMPPAR->docto',{||numero})
   ENDI
  #else
   IF EMPT(numop)
    IF op_menu=INCLUSAO
     numop=ORDPGRC->numop
    ELSE
     REPL numop WITH ORDPGRC->numop
    ENDI
   ENDI
   IF PTAB(numop,'ORDPGRC',1)
    REPL ORDPGRC->nrdoctos WITH ORDPGRC->nrdoctos + 1
   ENDI
   IF !EMPT(valorpg)
    REPL TAXAS->pgto_ WITH DATE()
   ENDI
   IF !EMPT(valorpg)
    REPL TAXAS->forma WITH [P]
   ENDI
   IF !EMPT(valorpg)
    REPL TAXAS->baixa_ WITH DATE()
   ENDI
   IF !EMPT(valorpg)
    REPL TAXAS->por WITH M->usuario
   ENDI
   IF !EMPT(valorpg)
    REPL TAXAS->stat WITH [6]
   ENDI
   IF !EMPT(valorpg)
    REPL TAXAS->valorpg WITH valorpg
   ENDI
   IF op_menu=INCLUSAO
    emitido_=DATE()
   ELSE
    REPL emitido_ WITH DATE()
   ENDI
   IF op_menu=INCLUSAO
    por=M->usuario
   ELSE
    REPL por WITH M->usuario
   ENDI
   IF op_menu=INCLUSAO
    filial=M->p_filial
   ELSE
    REPL filial WITH M->p_filial
   ENDI
   IF EMPT(numop).AND.PTAB(IIF(EMPT(M->usuario),PADR(M->contarec+ide_maq,10,' '),PADR(M->usuario,10,' '))+M->histrcfcc+[       ],'ORDPGRC',2)
    REPL ORDPGRC->valortotal WITH ORDPGRC->valortotal+valorpg
   ENDI
   IF !EMPT(numop).AND.PTAB(numop,'ORDPGRC',1)
    REPL ORDPGRC->valortotal WITH ORDPGRC->valortotal +valorpg
   ENDI
   IF PTAB(PADR(SUBSTR(M->ide_maq,2),4)+[BXR],[IMPPAR],1)
    REPL IMPPAR->docto WITH numero
   ENDI
  #endi

  IF op_menu!=INCLUSAO
   RECA
  ENDI
 ENDI
ENDI
RETU

* \\ Final de BXREC.PRG
/*
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
 \ Empresa.: Ind£stria de Urnas Bignotto Ltda
 \ Programa: ADMBIG.CH
 \ Data....: 29-09-96
 \ Sistema.: Administradora - RECEP€„O
 \ Funcao..: Inicializa constantes do sistema
 \ Analista: Ademilson Pedro Bom
 \ Criacao.: GAS-Pro v2.0d
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/
#include "inkey.ch"          // constantes de codigos das teclas
#include "Fileio.ch"         // funcoes de leitura/gravacao de arquivo
#include "set.ch"            // constantes da funcao SETKEY()

#define NIV_CRI_LIVRE 2      // define quem podera acessar o criterio livre

/*
   As diretivas (#define) a seguir referem-se a configuracao da aplicacao

   COM_MAQCALC  cria "pop calculadora" acionada atraves da tecla F5
   COM_CALE ... cria "pop calendario"  acionado atraves da tecla F6
   COM_PROTECAO protege os arquivos ao acesso interativo dBASE
   COM_REDE ... prepara o sistema para operar em rede (multiusuario)
   COM_MOUSE .. prepara programa para funcionar com mouse (se existir)
*/
#define COM_CALE
#define COM_MAQCALC
#define COM_REDE
#define COM_MOUSE

/*
   Define variaveis a serem usadas na integridade referencial de
   arquivos subordinados (pai e filhos)
*/
#define INCLUI       0       // inclusao de novos registros
#define EXCLUI       1       // exclusao de registros
#define RECUPERA     2       // recupera registros
#define FORM_INVERSA 3       // exclui registros executando formula inversa
#define FORM_DIRETA  4       // recupera registros executando formula direta
#define POSICIONA    5       // abre/posicionas os arquvios relacionados

/*
   Opcoes atribuidas `a variavel do menu de cadastramento (op_menu)
*/
#define INCLUSAO  1          // inclusao de registros
#define ALTERACAO 2          // alteracao de registros (proc edit)
#define PROJECOES 3          // consulta/tela paginada (funcao edita())
#define VAR_COMPL 4          // tela de variaveis complementares
#define TEL_EXTRA 5          // tela complemetar


/*
   Ativa atributo do esquema de cor corrente
*/
#define COR_PADRAO 0          // cor padrao (drvcorpad)
#define COR_GET    1          // cor do campo/menu (drvcorget)

/*
   tipos de video para funcao cardtype()
*/
#define V_CGA   0            // video cga
#define V_MONO  1            // video mono/hercules
#define V_EGA   2            // video ega
#define V_VGA   3            // video vga

/*
   Define variaveis a serem usadas na funcao DBOX() - 'caixa de dialogo`
*/
#define E_MENU .t.           // monta menu de barra
#define NAO_APAGA .f.        // nao apagar janela ao selecionar

/*
   tratamento do mouse
*/
#define ESQUERDO    1        // botao esquerdo
#define DIREITO     2        // botao direito
#define CLICK    -100        // botao esquerdo foi clicado

/*
   Define variaveis usadas para facilitar a identificacao dentro
   do vetos sistema[]
*/
#define O_MENU     1    // titulo reduzido para menus
#define O_MENS     2    // titulo do menu de subsistemas
#define O_CHAVE    3    // chaves do arquivos
#define O_CONSU    4    // titulos para menus dos indices de consulta
#define O_ORDEM    5    // numeros sequenciais dos campos nos arqs indices
#define O_ARQUI    6    // nome do arquivo de dados
#define O_INDIC    7    // nomes dos arquivos indices
#define O_DBRELA   8    // nome dos arquivos relacionados
#define O_CPRELA   9    // campos do relacionamento
#define O_TELA    10    // definicao da tela
#define   O_DEF    1    // numero de telas definidas
#define   O_ATUAL  2    // numero da tela atual
#define   O_LS     3    // linha superior da janela
#define   O_CS     4    // coluna superior da janela
#define   O_LI     5    // linha inferior da janela
#define   O_CI     6    // coluna inferior da janela
#define   O_SCROLL 7    // linha onde comeca o scroll
#define   O_QTDE   8    // quantas linhas vao rolar
#define O_OUTROS  11    // miscelanea
#define   O_NIVEL  1    // nivel de acesso do subsistema
#define   O_TPCHV  2    // tipo de chave primaria/nao primaria
#define O_CAMPO   12    // atributos dos campos do subsistema
#define   O_MASC   1    // mascara do campo
#define   O_TITU   2    // titulo do campo
#define   O_CMD    3    // comando especial (f8)
#define   O_DEFA   4    // default para o campo
#define   O_WHEN   5    // clausula when (pre validacao)
#define   O_CRIT   6    // expressao de validacao (critica)
#define   O_HELP   7    // texto de ajuda on-line do campo
#define O_FORMULA 13    // atributos das formulas do subsistema
#define   O_FORM   1    // formula a mostrar
#define   O_LINHA  2    // linha onde a formula sera' mostrada
#define   O_COLUNA 3    // coluna onde a formula sera' mostrada
#define O_CONDEXC 14    // condicao p/ exclusao de registros
#define O_CONDALT 15    // condicao p/ alteracao de registros

/*
   Comandos criados para auxiliar o comando GET para receber mais outros
   parametro e armazenar na variavel de instancia "CARGO". Este artificio
   e' usado para guardar o texto de ajuda e o comando a executrar quando
   a techa F8 for pressionada, o valor inicial e as formulas que serao
   mostrada apos a digitacao do campo
*/
#command AJUDA <var>     =>  STORECARGO(<var>,ATAIL(getlist),1)
#command CMDF8 <var>     =>  STORECARGO(<var>,ATAIL(getlist),2)
#command DEFAULT <var>   =>  STORECARGO(<var>,ATAIL(getlist),3)
#command MOSTRA <var>    =>  STORECARGO(<var>,ATAIL(getlist),4)
#command DEFINICAO <cp>  =>  STOREALL(<cp>,ATail(GetList))

* \\ Final de ADMBIG.ch
procedure cstseg
/*
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
 \ Empresa.: PresServ Inform tica - Limeira (019)452.6623
 \ Programa: CSTSEG.PRG
 \ Data....: 04-11-03
 \ Sistema.: Administradora - RECEP€„O
 \ Funcao..: Gerenciador do subsistema de custos adicionais
 \ Analista: Ademilson Pedro Bom
 \ Criacao.: GAS-Pro v4.0n
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/
#include "adrbig.ch"    // inicializa constantes manifestas

PARA lin_menu,col_menu
PRIV op_sis, tela_fundo:=SAVESCREEN(0,0,MAXROW(),79), l_s, c_s, l_i, c_i, l_a

op_sis=EVAL(qualsis,"CSTSEG")
IF nivelop<sistema[op_sis,O_OUTROS,O_NIVEL]        // se usuario nao tem permissao,
 ALERTA()                                          // entao, beep, beep, beep
 DBOX(msg_auto,,,3)                                // lamentamos e
 RETU                                              // retornamos ao menu
ENDI
cn:=fgrep :=.f.

#ifdef COM_LOCK
 IF LEN(pr_ok)>0                                   // se a protecao acusou
  ? pr_ok                                          // erro, avisa e
  QUIT                                             // encerra a aplicacao
 ENDI
#endi

t_fundo=SAVESCREEN(0,0,MAXROW(),79)                // salva tela do fundo
op_cad=1
DO WHIL op_cad!=0
 criterio=""
 RESTSCREEN(0,0,MAXROW(),79,t_fundo)               // restaura tela do fundo
 cod_sos=5 ; cn=.f.
 CLEA TYPEAHEAD                                    // limpa o buffer do teclado
 fgrep=.f.
 SET KEY K_F3 TO                                   // retira das teclas F3 e F4 as
 SET KEY K_F4 TO                                   // funcoes de repeticao e confirmacao
 msg="Inclus„o~1|"+;                               // menu do subsistema
     "Manuten‡„o~2|"+;
     "Consulta~3"
 op_cad=DBOX(msg,lin_menu,col_menu,E_MENU,NAO_APAGA,MAIUSC(sistema[op_sis,O_MENU]),,,op_cad)
 IF op_cad!=0                                      // se escolheu uma opcao
  Tela_fundo=SAVESCREEN(0,0,MAXROW(),79)           // salva a tela para ROLATELA()
  PARAMETROS(dbfparam)
  SELE A                                           // e abre o arquivo e seus indices

  #ifdef COM_REDE
   IF !USEARQ(sistema[op_sis,O_ARQUI,O_NOME],.f.,20,1)
                                                   // se falhou a abertura do
    RETU                                           // arquivo volta ao menu anterior
   ENDI
  #else
   USEARQ(sistema[op_sis,O_ARQUI,O_NOME])
  #endi

  SET KEY K_F9 TO veoutros                         // habilita consulta em outros arquivos
 ENDI
 DO CASE
  CASE op_cad=01                                   // inclus„o
   op_menu=INCLUSAO
   IF AT("D",exrot[op_sis])=0                      // se usuario pode fazer inclusao
    CST_INCL()                                     // neste arquivo chama prg de inclusao
   ELSE                                            // caso contrario vamos avisar que
    ALERTA()                                       // ele nao tem permissao para isto
    DBOX(msg_auto,,,3)
   ENDI

  CASE op_cad=02                                   // manuten‡„o
   op_menu=ALTERACAO
   cod_sos=7
   EDIT()

  CASE op_cad=03                                   // consulta
   op_menu=PROJECOES
   cod_sos=8
   EDITA(03,03,MAXROW()-2,77)

 ENDC
 SET KEY K_F9 TO                                   // F9 nao mais consultara outros arquivos
 CLOS ALL                                          // fecha todos arquivos abertos
ENDD
RETU

PROC CST_incl(reg_cop)  // inclusao no arquivo CSTSEG
LOCAL getlist:={}, cabem:=1, rep:=ARRAY(FCOU()), ult_reg:=RECN(),;
      ctl_r, ctl_c, ctl_w, t_f3_, t_f4_, dele_atu:=SET(_SET_DELETED,.f.)
PRIV op_menu:=INCLUSAO, tem_borda, criterio:="", cpord:=""
FOR i=1 TO FCOU()                                  // cria/declara privadas as
 msg=FIEL(i)                                       // variaveis de memoria com
 PRIV &msg.                                        // o mesmo nome dos campos
NEXT                                               // do arquivo
IF reg_cop!=NIL                                    // quer repetir todo o reg atual
 FOR i=1 TO FCOU()                                 // para cada campo,
  msg=FIEL(i)                                      // salva o conteudo
  rep[i]=&msg.                                     // para repetir
 NEXT
ELSE
 AFILL(rep,"")                                     // eche com valor vazio
ENDI
t_f3_=SETKEY(K_F3,{||rep()})                       // repeticao reg anterior
t_f4_=SETKEY(K_F4,{||conf()})                      // confirma campos com ENTER
ctl_w=SETKEY(K_CTRL_W,{||nadafaz()})               // enganando o CA-Clipper...
ctl_c=SETKEY(K_CTRL_C,{||nadafaz()})
ctl_r=SETKEY(K_CTRL_R,{||nadafaz()})
DO WHIL cabem>0
 cod_sos=6
 rola_t=.f.                                        // flag se quer rolar a tela
 SELE CSTSEG
 GO BOTT                                           // forca o
 SKIP                                              // final do arquivo
 
 /*
    cria variaveis de memoria identicas as de arquivo, para inclusao
    de registros
 */
 FOR i=1 TO FCOU()
  msg=FIEL(i)
  M->&msg.=IF((fgrep .OR. reg_cop!=NIL).AND.!EMPT(rep[1]),rep[i],&msg.)
 NEXT
 DISPBEGIN()                                       // apresenta a tela de uma vez so
 CST_TELA()
 INFOSIS(.t.)                                      // exibe informacao no rodape' da tela
 DISPEND()
 cabem=DISKSPACE(;
          IF(;
             LEN(sistema[op_sis,O_ARQUI,O_DIR_DBF])<2.OR.sistema[op_sis,O_ARQUI,O_DIR_DBF]="\",;
             0,;
             ASC(sistema[op_sis,O_ARQUI,O_DIR_DBF])-64;
          );
       )
 cabem=INT((cabem-2048)/CSTSEG->(RECSIZE()))
 IF cabem<1                                        // mais nenhum!!!
  ALERTA()
  msg="Verifique ESPA€O EM DISCO, "+usuario
  DBOX(msg,,,,,"INCLUSŽO INTERROMPIDA!")           // vamos parar por aqui!
  EXIT
 ENDI
 M->quem=M->usuario
 SELE 0                                            // torna visiveis variaveis de memoria
 CST_GET1(INCLUI)                                  // recebe campos
 SELE CSTSEG
 IF LASTKEY()=K_ESC                                // se cancelou
  cabem=0                                          // prepara saida da inclusao
  LOOP
 ENDI

 #ifdef COM_REDE
  GO BOTT                                          // vamos bloquear o final do
  SKIP                                             // arq para que nehum outro
  BLOREG(0,.5)                                     // usuario possa incluir
 #endi

 APPEND BLANK                                      // inclui reg em branco no dbf
 FOR i=1 TO FCOU()                                 // para cada campo,
  msg=FIEL(i)                                      // salva o conteudo
  rep[i]=M->&msg.                                  // para repetir
  REPL &msg. WITH rep[i]                           // enche o campo do arquivo
 NEXT

 #ifdef COM_REDE
  UNLOCK                                           // libera o registro e
  COMMIT                                           // forca gravacao
 #else
  IF RECC()-INT(RECC()/20)*20=0                    // a cada 20 registros
   COMMIT                                          // digitados forca gravacao
  ENDI
 #endi

 ult_reg=RECN()                                    // ultimo registro digitado
 IF reg_cop!=NIL                                   // estava na consulta e quis rep o campo
  EXIT                                             // cai fora...
 ENDI
ENDD
GO ult_reg                                         // para o ultimo reg digitado
SETKEY(K_F3,t_f3_)                                 // restaura teclas de funcoes
SETKEY(K_F4,t_f4_)
SET(_SET_DELETED,dele_atu)                            // ecluidos visiveis/invisiveis
SETKEY(K_CTRL_W,ctl_w)
SETKEY(K_CTRL_C,ctl_c)
SETKEY(K_CTRL_R,ctl_r)
RETU


PROC CST_tela     // tela do arquivo CSTSEG
tem_borda=.t.
l_s=Sistema[op_sis,O_TELA,O_LS]           // coordenadas da tela
c_s=Sistema[op_sis,O_TELA,O_CS]
l_i=Sistema[op_sis,O_TELA,O_LI]
c_i=Sistema[op_sis,O_TELA,O_CI]
SETCOLOR(drvtittel)
vr_memo=NOVAPOSI(@l_s,@c_s,@l_i,@c_i)     // pega posicao atual da tela
CAIXA(mold,l_s,c_s,l_i,c_i)               // monta caixa da tela
i=LEN(sistema[op_sis,O_MENS])/2
@ l_s,c_s-1+(c_i-c_s+1)/2-i SAY " "+MAIUSC(sistema[op_sis,O_MENS])+" "
SETCOLOR(drvcortel)
@ l_s+01,c_s+1 SAY " Emiss„o....:           Horas:"
@ l_s+02,c_s+1 SAY " Hist¢rico..:"
@ l_s+03,c_s+1 SAY " Contrato...:"
@ l_s+04,c_s+1 SAY " Complemento:"
@ l_s+05,c_s+1 SAY "ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ"
@ l_s+06,c_s+1 SAY " Qtde:       Valor:            Tipo:    Circ:"
RETU

PROC CST_gets     // mostra variaveis do arquivo CSTSEG
LOCAL getlist := {}
CST_TELA()
SETCOLOR(drvcortel+","+drvcorget+",,,"+corcampo)
@ l_s+01 ,c_s+15 GET  emissao_;
                 PICT sistema[op_sis,O_CAMPO,01,O_MASC]

@ l_s+01 ,c_s+32 GET  hora;
                 PICT sistema[op_sis,O_CAMPO,02,O_MASC]

@ l_s+01 ,c_s+40 GET  quem

@ l_s+02 ,c_s+15 GET  historic;
                 PICT sistema[op_sis,O_CAMPO,04,O_MASC]

@ l_s+03 ,c_s+15 GET  contrato;
                 PICT sistema[op_sis,O_CAMPO,05,O_MASC]

@ l_s+04 ,c_s+15 GET  complement;
                 PICT sistema[op_sis,O_CAMPO,06,O_MASC]

@ l_s+06 ,c_s+08 GET  qtdade;
                 PICT sistema[op_sis,O_CAMPO,07,O_MASC]

@ l_s+06 ,c_s+21 GET  valor;
                 PICT sistema[op_sis,O_CAMPO,08,O_MASC]

@ l_s+06 ,c_s+38 GET  tipo;
                 PICT sistema[op_sis,O_CAMPO,09,O_MASC]

@ l_s+06 ,c_s+47 GET  circ;
                 PICT sistema[op_sis,O_CAMPO,10,O_MASC]

CLEAR GETS
RETU

PROC CST_get1(tp_mov)     // capta variaveis do arquivo CSTSEG
LOCAL getlist := {}
PRIV  blk_cstseg:=.t.

IF tp_mov=INCLUI
 DO WHILE .t.
  rola_t=.f.
  SET KEY K_ALT_F8 TO ROLATELA
  SETCOLOR(drvcortel+","+drvcorget+",,,"+corcampo)
  @ l_s+01 ,c_s+40 GET quem
  CLEA GETS
  @ l_s+01 ,c_s+15 GET  emissao_;
                   PICT sistema[op_sis,O_CAMPO,01,O_MASC]
                   DEFINICAO 1

  @ l_s+01 ,c_s+32 GET  hora;
                   PICT sistema[op_sis,O_CAMPO,02,O_MASC]
                   DEFINICAO 2

  @ l_s+02 ,c_s+15 GET  historic;
                   PICT sistema[op_sis,O_CAMPO,04,O_MASC]
                   DEFINICAO 4

  @ l_s+03 ,c_s+15 GET  contrato;
                   PICT sistema[op_sis,O_CAMPO,05,O_MASC]
                   DEFINICAO 5

  @ l_s+04 ,c_s+15 GET  complement;
                   PICT sistema[op_sis,O_CAMPO,06,O_MASC]
                   DEFINICAO 6

  @ l_s+06 ,c_s+08 GET  qtdade;
                   PICT sistema[op_sis,O_CAMPO,07,O_MASC]
                   DEFINICAO 7

  @ l_s+06 ,c_s+21 GET  valor;
                   PICT sistema[op_sis,O_CAMPO,08,O_MASC]
                   DEFINICAO 8

  @ l_s+06 ,c_s+38 GET  tipo;
                   PICT sistema[op_sis,O_CAMPO,09,O_MASC]
                   DEFINICAO 9

  @ l_s+06 ,c_s+47 GET  circ;
                   PICT sistema[op_sis,O_CAMPO,10,O_MASC]
                   DEFINICAO 10

  READ
  SET KEY K_ALT_F8 TO
  IF rola_t
   ROLATELA()
   LOOP
  ENDI
  IF LASTKEY()!=K_ESC .AND. drvincl .AND. op_menu=INCLUSAO
   IF !CONFINCL()
    LOOP
   ENDI
  ENDI
  EXIT
 ENDD
ENDI
PTAB(HISTORIC,'HISTORIC',1)
PTAB(CONTRATO,'GRUPOS',1)
PTAB(CONTRATO+TIPO+CIRC,'TAXAS',1)
IF tp_mov=EXCLUI .OR. tp_mov=FORM_INVERSA
 IF !EMPTY(ALIAS())
  DELE
 ENDI
ELSEIF tp_mov=INCLUI .OR. tp_mov=RECUPERA .OR. tp_mov=FORM_DIRETA
 IF (op_menu=INCLUSAO .AND. LASTKEY()!=K_ESC) .OR. op_menu!=INCLUSAO
   IF op_menu=INCLUSAO
    quem=M->usuario
   ELSE
    REPL quem WITH M->usuario
   ENDI
  IF op_menu!=INCLUSAO
   RECA
  ENDI
 ENDI
ENDI
RETU

* \\ Final de CSTSEG.PRG
€
 GRU_02F9@–Ñ  GRU_02F9CODEC_ETEXTENDCODE	_SYMSTARTSYMSTARTSYMBOLSSYMBOLS_SYMENDSYMENDNULLBEGDATA_DATADATA_SYMPBDATA_SYMPDATA_SYMPEDATA_CONSTCONST_MSGMSG_BEGBSSBEGBSS_BSSBSS_ENDBSSENDBSSDGROUPÿ˜ @ÖD˜ H  ˜ h  ë˜ `ð 	ÿ˜ h  
ã˜ h  ß˜ H  û˜ H  ÷˜ H ë˜ H  ï˜ H  ë˜ (  ˜ H  € MENSAG·–U MENSAGCODEMEN_INCLCODE
MEN_ANT_SECODE
MEN_CRIA_SCODE
MEN_GERA_SCODE
MEN_GRAVA_CODEMEN_TELACODEMEN_GETSCODEMEN_GET1CODEMEN_MEMOCODEC_ETEXTENDCODE	_SYMSTARTSYMSTARTSYMBOLSSYMBOLS_SYMENDSYMENDNULLBEGDATA_DATADATA_SYMPBDATA_SYMPDATA_SYMPEDATA_CONSTCONST_MSGMSG_BEGBSSBEGBSS_BSSBSS_ENDBSSENDBSSDGROUPG˜ @ô%˜ @z•˜ @s  ˜ @%	é˜ @« 
`˜ @) Þ˜ @¬V˜ @(Ö˜ @¹@˜ @c ”˜ H  ë˜ h  Ç˜ `pÿØÿà JFIF      ÿÛ „ 
(procedure adr_proc
/*
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
 \ Empresa.: PresServ Inform tica - Limeira (019)452.6623
 \ Programa: ADR_PROC.PRG
 \ Data....: 29-01-04
 \ Sistema.: Administradora - RECEP€„O
 \ Funcao..: Rotinas auxiliares
 \ Analista: Ademilson Pedro Bom
 \ Criacao.: GAS-Pro v4.0o
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/
#include "adrbig.ch"    // inicializa constantes manifestas

PROC CBC1    // rotina para exibir pano de fundo
DISPBEGIN()                            // monta tela no buffer
SETCOLOR(drvcorpad)                    // imprime pano de fundo
CAIXA(REPL(drvcara,9),0,0,MAXROW(),79)
SETCOLOR(drvtitbox)
CAIXA(mold,01,03,04,77)                // monta caixa da tela
SETCOLOR(drvcorbox)
@ 02,04 SAY "                                                            ,"
@ 02,05 SAY nemp
@ 03,05 SAY nsis
@ 02,66 SAY DATE()
@ 02,57 SAY NSEM(DATE())
@ 03,53 SAY drvdbf
DISPEND()                         // mostra tela que esta no buffer
RETU

PROC AJMOUSE      // Rotina para ajuste da sensibilidade do mouse
#ifdef COM_MOUSE
 IF drvmouse                                  // sensibilidade do mouse
  tpo:=tecl:=li:=co := 1; V=drvratV; H=drvratH
  msg="Horizontal: "+CHR(27)+LPAD(STR(H),3)+" "+CHR(26)+;
      "|Vertical..: "+CHR(27)+LPAD(STR(V),3)+" "+CHR(26)+;
      "|(P)adr„o - 'default`|"+gcr+" = Ok"
  DBOX(msg,,,,NAO_APAGA,"AJUSTA SENSIBILIDADE DO MOUSE")
  MOUSEBOX(0,0,MAXROW(),79)                   // define area de atuacao
  SETCOLOR(drvcorbox)
  SET CURSOR OFF                              // apaga o cursor do CA-Clipper e
  MOUSECUR(.t.)                               // acende o cursor do mouse
  DO WHIL tecl!=K_ESC .AND. tecl!=K_ENTER
   clic=MOUSEGET(@li,@co)                     // capta coordenadas atuais
   tecl=IN_KEY()                              // verifica algo digitado
   IF clic=1 .OR. tecl=80 .OR. tecl=112       // se clicado botao esquerdo ou 'P`
    press=(SECONDS()>tpo+1)                   // tempo maximo retido = 1s
    IF tpo=0 .OR. press                       // se 1o. click ou tempo esgotado
     IF (li=13 .AND. co>28 .AND. co<49) .OR.; // verifica local clicado
        tecl=80 .OR. tecl=112                 // e muda a sensibilidade
      H=8; V=16                               // horizontal e vertical
     ELSEIF li=11 .AND. co>40 .AND. co<44
      H=H-IF(H>1,1,0)
     ELSEIF li=11 .AND. co>45 .AND. co<49
      H=H+IF(H<900,1,0)
     ELSEIF li=12 .AND. co>40 .AND. co<44
      V=V-IF(V>1,1,0)
     ELSEIF li=12 .AND. co>45 .AND. co<49
      V=V+IF(V<900,1,0)
     ELSEIF li=14 .AND. co>35 .AND. co<43     // clicou OK
      tecl=K_ENTER
     ENDI
     MOUSERAT(H,V)                            // ajusta sensibilidade escolhida
     MOUSECUR(.f.)                            // esconde cursor do mouse e
     @ 11,43 SAY LPAD(STR(H),3)               // mostra valores horizontal
     @ 12,43 SAY LPAD(STR(V),3)               // e vertical
     MOUSECUR(.t.)                            // exibe novamente o cursor
     tpo=IF(tpo=0,SECONDS(),tpo)              // reinicializa tempo max retencao
    ENDI
   ELSEIF clic=2                              // pressionou botao direito,
    tecl=K_ESC                                // entao forca retorno
   ELSEIF tecl=K_F1                           // se teclou f1,
    HELP()                                    // apresenta ajuda
   ELSE                                       // ou entao,
    tpo=0                                     // zera tempo de retencao
   ENDI
  ENDD
  MOUSECUR(.f.)                               // apaga o cursor do mouse
  COLORSELECT(COR_PADRAO)
  SET CURSOR ON                               // acende o cursor do CA-Clipper
  IF tecl=K_ESC                               // se abandonou,
   MOUSERAT(drvratH,drvratV)                  //  retorna sensibilidade original
  ELSE                                        // senao,
   drvratH=H; drvratV=V                       //  prepara gravacao dos valores
  ENDI                                        //  de sensibilidade escolhidos
 ENDI
#endi
RETU

PROC BROWSE_REL(arq_, l_sup_, c_sup_,l_inf_, c_inf_)
LOCAL cur_atual, cor_atual
PRIV l_arq[l_inf_-l_sup_+1], maxlin_, area_, tablin_, fim_arq_, offset_ini,;
     offset_fim, lsup_:=l_sup_+1, csup_:=c_sup_+1,linf_:=l_inf_-1, t_w, t_r, ;
     cinf_:= c_inf_-1, cod_sos:=55, t_c, t_s, t_d, t_3, t_4, t_7, t_9, t_10
t_w:=SETKEY(K_CTRL_W,NIL); t_r:=SETKEY(K_CTRL_R,NIL) // desabilita teclas
t_c:=SETKEY(K_CTRL_C,NIL); t_s:=SETKEY(K_CTRL_S,NIL) // cursoras
t_d:=SETKEY(K_CTRL_D,NIL)
t_3:=SETKEY(K_F3,NIL);  t_4:=SETKEY(K_F4,NIL)        // desabilita teclas
t_7:=SETKEY(K_F7,NIL);  t_9:=SETKEY(K_F9,NIL)        // de funcoes
t_10:=SETKEY(K_F10,NIL)
IF AT(".",arq_)=0               // se o arquivo nao tiver extensao
 arq_+=".prn"                   // vamos forcar ".prn"
ENDI
IF (area_:=FOPEN(arq_))<0       // abre arquivo modulo binario
 ALERTA(2)                      // arquivo nao foi aberto...
 msg="N„o foi possivel abrir o arquivo!"
 DBOX(msg,,,3,,"ATENCAO!")
 RETU
ENDI                            // moldura da janela
cor_atual=SETCOLOR(drvcortel)   // cor da janela do browse
cur_atual:=SETCURSOR(0)         // salva/apaga cursor
CAIXA(mold,l_sup_,c_sup_,l_inf_,c_inf_)

#ifdef COM_MOUSE
 msg=" "+CHR(174)+" "+CHR(175)+;// botoes do mouse
     " "+CHR(30)+" "+CHR(31)+;
     " "+CHR(24)+" "+CHR(26)+;
     " "+CHR(25)+" "+CHR(27)+" "
 posi_cur=c_inf_-c_sup_-17      // posicao onde eles comecam
 posi_cur=c_sup_+INT(posi_cur/2)
 IF drvmouse                    // se o mouse esta abilitado
  @ l_inf_,posi_cur SAY msg     // imprime msg no rodape da janela
 ENDI
#endi

maxlin_=linf_-lsup_+1           // qtde maxima de linhas da janela
AFILL(l_arq,"")                 // inicializa vetor das linhas mostradas
offset_ini:=offset_fim := 0     // inicializa ponteiros de inicio e
tablin_ = 1                     // da area mostrada
fim_arq_=FSEEK(area_,0,FS_END)  // tamanho do arquivo
FSEEK(area_,0)                  // volta para o topo do arquivo
MONTA_LIN(maxlin_,0)            // le/imprime as primeiras linhas
offset_ini=0                    // reinicializa offset de inicio
DO WHILE .t.

 #ifdef COM_MOUSE
  tecl_p=MOUSETECLA(l_inf_,posi_cur,;
                    l_inf_,posi_cur+16,; // aguarda com controle de mouse
                    .f.;
         )
 #else

  tecl_p=IN_KEY(0)              // espera tecla ser digitada

 #endi

 IF SETKEY(tecl_p)!=NIL         // executa funcao associada a
  EVAL(SETKEY(tecl_p))          // tecla digitada se existir
  tecl_p=0                      // nao faz mais nada depois
 ENDI
 DO CASE
  CASE tecl_p=K_ESC             // fim do browse no arquivo
   EXIT

  CASE tecl_p=K_DOWN            // seta para baixo
   MONTA_LIN(1,0)

  CASE tecl_p=K_UP              // seta para cima
   MONTA_LIN(-1,0)

  CASE tecl_p=K_CTRL_PGUP       // inicio do arquivo
   offset_ini:=offset_fim := 0
   AFILL(l_arq,"")
   MONTA_LIN(maxlin_,0)
   offset_ini=0

  CASE tecl_p=K_CTRL_PGDN       // fim do arquivo
   offset_ini:=offset_fim := fim_arq_
   AFILL(l_arq,CHR(0))
   @ l_sup_+1,c_sup_+1 CLEAR TO l_inf_-1,c_inf_-1
   MONTA_LIN(-1*(maxlin_),0)

  CASE tecl_p=K_RIGHT           // seta para direita
   MONTA_LIN(0,10)

  CASE tecl_p=K_LEFT            // seta para esquerda
   MONTA_LIN(0,-10)

  CASE tecl_p=K_PGDN            // pagina para baixo
   MONTA_LIN(maxlin_-1,0)

  CASE tecl_p=K_PGUP            // pagina cima/final do arquivo
   MONTA_LIN(-1*(maxlin_-1),0)

  CASE tecl_p=73.OR.tecl_p=105  // impressao do relatorio
   MONTA_IMP(cur_atual)

 END CASE
ENDD
FCLOSE(area_)                   // fecha arquivo .prn
SETKEY(K_CTRL_W,t_w); SETKEY(K_CTRL_R,t_r) // habilita teclas
SETKEY(K_CTRL_C,t_c); SETKEY(K_CTRL_S,t_s) // cursoras
SETKEY(K_CTRL_D,t_d)
SETKEY(K_F3,t_3); SETKEY(K_F4,t_4)         // habilita teclas
SETKEY(K_F7,t_7); SETKEY(K_F9,t_9)         // de funcoes
SETKEY(K_F10,t_10)

SETCURSOR(cur_atual)            // restaura cursor
SETCOLOR(cor_atual)             // e a cor
RETU

STATIC PROC MONTA_LIN(qtlin_,qttab_)  // le/imprime linhas do arquivo binario
LOCAL t_, i_, x_, j_, lin_, buf_, tambuf_, ini_, fim_, qts_:=0,;
      tp_cmd:="pcomtcompc20tc20pelitelipenftenfpexptexppde8tde8landport"
IF qtlin_!=0                           // quer le outras linhas?
 tambuf_=MIN(ABS(qtlin_)*2700,32000)   // buffer maximo do tamnho das linhas
 IF qtlin_<0 .AND. offset_ini>1        // quer voltar linhas e nao esta no topo
  IF offset_ini<tambuf_                // se o tamanho buffer e maior do que
   tambuf_=offset_ini                  // ja foi lido, ajusta seu tamanho
  ENDI
  FSEEK(area_,offset_ini-tambuf_)      // posiciona poteiro para a leitura
  buffer_=SPAC(tambuf_)                // inicializa o buffer e
  FREAD(area_,@buffer_,tambuf_)        // le o arquivo...
  buffer_=STRTRAN(buffer_,CHR(12)+CHR(13),CHR(13)+CHR(10))
  tambuf_++                            // incrementa tamanho do buffer
  buf_=tambuf_                         // salva tamanho original
  FOR t_ = qtlin_ TO -1                // faz p/ todas as linhas requeridas
   IF tambuf_ > 1                      // se nao esta no inicio do buffer
    tambuf_-=3                         // tira o CR+LF do fim da linha
    i_=tambuf_                         // acha o ultimo CR+LF
    tambuf_=RAT(CHR(13)+CHR(10),SUBS(buffer_,1,tambuf_))
    tambuf_=IF(tambuf_>0,tambuf_+2,1)  // se achou desconta o CR+LF
    IF l_arq[maxlin_]!=CHR(0)          // se a linha a excluir for do arquivo
     offset_fim-=LEN(l_arq[maxlin_])+2 // decrementa seu tamanho do offset do
    ENDI                               // fim do arquivo (acresentando o CR+LF)
    AINS(l_arq,1)                      // insere um linha no top do arranjo
    i_=i_-tambuf_+1
    l_arq[1]=SUBS(buffer_,tambuf_,i_)  // inicializa a linha com a linha do arq
    qts_--                             // qtde de linhas do scroll
   ELSE                                // se chegou no inicio do tamanho do
    EXIT                               // buffer lido, cai fora...
   ENDI
  NEXT
  offset_ini-=buf_-tambuf_             // ajusta offset da linha inicio da janela

 ELSEIF l_arq[2]!=CHR(0)               // quer avancar linhas e nao esta no fim do arq
  FSEEK(area_,offset_fim)              // posiciona o ponteiro na ultima lin lida
  IF offset_fim+tambuf_>fim_arq_       // se o resto do arquivo e menor do que
   tambuf_=fim_arq_-offset_fim         // o tamanho do buffer, ajusta seu tamanho
  ENDI
  buffer_=SPAC(tambuf_)                // inicializa o buffer e
  FREAD(area_,@buffer_,tambuf_)        // le o arquivo...
  buffer_=STRTRAN(buffer_,CHR(12)+CHR(13),CHR(13)+CHR(10))
  FOR t_ = 1 TO qtlin_                 // mostra proximas linhas requeridas
   IF l_arq[1]!=CHR(0)                 // se for uma linha lida do arquivo
    offset_ini+=LEN(l_arq[1])+2        // ajusta offset do inicio
   ENDI
   ADEL(l_arq,1)                       // apaga a 1a. linha do arranjo
   qts_++                              // qtde de linhas que sera feita o scroll
   IF LEN(buffer_)<3                   // se nao tem mais linha para montar a tela
    l_arq[maxlin_]=CHR(0)              // inicializa linha com CHR(0) (flag)
    IF l_arq[2]=CHR(0)                 // se o fim do arq esta na 1a. linha
     EXIT                              // nao tem mais linha para mostrar
    ENDI
   ELSE                                // caso contrario pega linha corrente
    l_arq[maxlin_]=PARSE(@buffer_,CHR(13)+CHR(10))
    offset_fim+=LEN(l_arq[maxlin_])+2  // ajusta offset do fim da janela
   ENDI
  NEXT
 ENDI
ENDI
i_=0
FOR t_ = 1 TO maxlin_                  // pega o tamanho da maior linha
 i_=MAX(i_,LEN(l_arq[t_]))
NEXT
IF (qttab_<0 .AND. tablin_>1) .OR.;    // quer rolar horizontalmente?
   (qttab_>0 .AND. tablin_<i_-10)
 tablin_+=qttab_                       // soma/diminui tabulacao atual
 qts_=maxlin_                          // forca remontagem de toda a janela
ENDI
IF qts_!=0                             // se leu alguma linha
 SCROLL(lsup_,csup_,linf_,cinf_,qts_)  // rola a tela
 ini_=IF(qts_>0,maxlin_-qts_+1,1)      // inicio e fim das linhas
 fim_=IF(qts_>0,maxlin_,ABS(qts_))     // que foram lidas
 i_=cinf_-csup_+1                      // tamanho da janela
 FOR t_=ini_ TO fim_                   // imprime linhas lidas
  lin_=l_arq[t_]
  IF !EMPTY(lin_).AND.!OK_PRINT(lin_)  // tem caraceter de controle?
   IF AT(" "+CHR(8),lin_)>0            // tira efeito especial da frente da linha
    lin_=SUBS(lin_,AT(" "+CHR(8),lin_)+2)
   ENDI
   FOR j_=1 TO 56 STEP 4               // testa todos os carc de controle
    x_="drv"+SUBS(tp_cmd,j_,4)         // monta o nome do efeito
    x_=&x_.
    IF !EMPTY(x_)                      // tem efeito configurado?
     lin_=STRTRAN(lin_,TRANS(&x_.,""),"") // retira-o da linha
    ENDI
   NEXT
  ENDI
  @ lsup_+t_-1,csup_ SAY SUBS(lin_,tablin_,i_)
 NEXT
ENDI
buffer_=""
RETU

STATIC PROC MONTA_IMP(cur_atual)  // imprime arquivo
LOCAL pgini_, tp, g_off_ini, g_off_fim, qt_lido, buf_, ctpag_, lin_, t_
SAVE SCREEN                                // salva tela
SETCURSOR(cur_atual)                       // acende cursor
pgini_=DBOX("P gina inicial:",1,45,,NAO_APAGA,"IMPRIME ARQUIVO",1,"99999")
SETCURSOR(0)                               // apaga cursor
IF pgini_>0
 porta=IMP_PORTA(drvporta,5,60,NAO_APAGA)  // escolhe para onde vai
 IF !EMPT(porta) .AND. LASTKEY()<>K_ESC
  IF PREPIMP()                             // pede para preparar impressora
   DBOX("AGUARDE!",,,,NAO_APAGA)           // mensagem ao usuaruio
   g_off_ini=offset_ini                    // salva ponteiros do arquivo
   g_off_fim=offset_fim
   SET ALTE TO (porta)                     // abre o dispositivo de impressao
   SET ALTE ON                             // liga gravacao
   SET CONS OFF                            // nao iremos exibir na tela
   FSEEK(area_,0)                          // inicio do arquivo
   qt_lido=200                             // qtde de bytes que vamos ler
   buf_=SPAC(200)                          // vamos ler os primeiros 200 bytes
   qt_lido=FREAD(area_,@buf_,200)          // para ver se tem efeito especial...
   IF LEN(buf_)>0                          // leu alguma coisa...
    IF AT(" "+CHR(8),buf_)>0               // se tem algum efetio vamos
     lin_=PARSE(buf_," "+CHR(8))           // extrai so o efeito e
     ? lin_                                // envia para a impressora
    ENDI
   ENDI
   FSEEK(area_,0)                          // inicio do arquivo
   qt_lido=10000                           // qtde de bytes que vamos ler
   buf_=""
   ctpag_=1                                // contador de pagina
   DO WHILE qt_lido=10000
    buffer_=SPAC(10000)                    // inicializa o buffer e le arquivo...
    qt_lido=FREAD(area_,@buffer_,10000)    // le o arquivo...
    buffer_=buf_+buffer_                   // soma o final do buffer anterior
    buf_=""                                // no buffer atual
    DO WHILE LEN(buffer_)>0                // imprime as linhas do buffer lido
     lin_=PARSE(@buffer_,CHR(13)+CHR(10))  // separa uma linha
     IF LEN(buffer_)>0 .OR. qt_lido<>10000 // se nao for a ultima do buffer
      IF ctpag_<pgini_                     // se esta pg nao podemos imprimir
       t_=AT(CHR(12)+CHR(13),lin_)         // verifica chr de salto de pg
       IF t_>0                             // tem?
        ctpag_++                           // soma no contador
        lin_=SUBS(lin_,t_+2)               // pega a linha de inicio da pg
       ENDI
      ENDI
      IF IN_KEY()=K_ESC                    // se quer cancelar
       IF canc()                           // pede confirmacao
        qt_lido=0                          // confirmou,
        EXIT                               // prepara para sair...
       ENDI
      ENDI
      IF ctpag_>=pgini_                    // se ja podemos imprimir
       ? lin_                              // grava no dispositivo de imprissao
      ENDI
     ELSE                                  // fimal do buffer a linha pode
      buf_=lin_                            // estar incompleta, salva o resto
     ENDI
    ENDD
   ENDD
   SET ALTE OFF                            // desliga a gravacao
   SET ALTE TO                             // fecha dispositivo de impressao
   SET CONS ON                             // reabilita o video
   offset_ini=g_off_ini                    // restaura ponteiros do arquivo
   offset_fim=g_off_fim
  ENDI
 ENDI
ENDI
REST SCREEN                                // restabelece tela
RETU

PROC DOSCOM    // Executa comandos do DOS (shell)
LOCAL dos_t:=SAVESCREEN(0,0,MAXROW(),79), cor_atual:=SETCOLOR("W+/N"),;
      cur_sor:=SETCURSOR(3)
CLS
QOUT("Digite EXIT para retornar")
! command                         // carrega copia do command.com
MUDAFONTE(drvfonte)               // troca a fonte de caracteres
NAOPISCA()                        // habilita 256 cores (ega/vga)
RESTSCREEN(0,0,MAXROW(),79,dos_t) // restaura tela e
SETCOLOR(cor_atual)               // o esquema de cor
SETCURSOR(cur_sor)
RETU

PROC PARAMETROS(db_, cp_,fr_)  // Atualiza arquivo de parƒmetros da aplica‡„o
LOCAL ar_:=SELECT(), i_
SELE 0

#ifdef COM_REDE
 USEARQ(db_,.f.,,,.f.)  // abre arquivo de parametro sem indice
#else
 USEARQ(db_)            // abre arquivo de parametro
#endi


/*
   se passou algum parametro entao atualiza o campo campo dentro do arquivo
   antes de inicializar sua variaveis
*/
IF cp_!=NIL .AND. fr_!=NIL

 #ifdef COM_REDE
  REPBLO(cp_,fr_)          // bloqueia e muda o campo
 #else
  REPL &cp_. WITH fr_
 #endi

ENDI

/*
   cria variaveis de memoria publicas identicas as de arquivo,
   para serem usadas por toda a aplicacao
*/
FOR i_=1 TO FCOU()
 msg=FIEL(i_)
 M->&msg.=&msg.
NEXT
USE                          // fecha arquivo de parametro e
SELE (ar_)                   // retorna para area anterior
RETU

PROC FILTRA(flg,ord)  // Monta sele‡„o de registros

/*
   Se flg=.t., cria indice temporario
   Se ord=.t., alem da filtragem, oferece ordenacao
*/
LOCAL m_campos, op_sis, getlist:={}, cn:=.f., filini:=.f., x_, k_, i_, cri_ant:=criterio, xx_
PRIV cod_sos:=12
cpsel:=criterio :="" ; selnum:=i :=0
op_sis=EVAL(qualsis,ALIAS())                     // subscricao do vetor sistema

/*
   enche m_campos com titulos dos campos (para menu)
*/
IF nivelop>=NIV_CRI_LIVRE                        // se usuario autorizado,
 m_campos="|* * Crit‚rio livre * *"              //  pode fazer filtragem livre
ELSE                                             // senao,
 m_campos=""                                     //  nao vai ter esta opcao
ENDI
IF LEN(cri_ant)>0                                   // se tem filtro anterior
 m_campos+="|* * Filtro anterior * *"               // deixa concatenar filtro
ENDI
x_=ALIAS()                         // monta menu de campos com
xx_="|"                            // campos do arquivo pricipal
DO WHIL LEN(x_)>0                  // todas os arquivos relacionadas
 k_=PARSE(@x_,"|")                 // arquivo atual
 nc=EVAL(&("{||"+k_+"->(FCOU())}"))// numero de campos do arquivo
 FOR i=1 TO nc                     // monta menu de campos, exceto invisivel
  IF !("I"==sistema[EVAL(qualsis,k_),O_CAMPO,i,O_CRIT])
   m_campos+="|"+sistema[EVAL(qualsis,k_),O_CAMPO,i,O_TITU]
   IF k_==ALIAS()                  // e' o arquivo atual
    xx_+=UPPER(FIEL(i))+"|"
   ENDI
  ENDI
 NEXT
 IF brw .AND. k_==ALIAS()            // veio da EDITA() e e' arq atual
  nc=br_w:colcount                   // numero de colunas para escolher
  FOR i=1 TO nc                      // monta menu de campos
   cargox=br_w:getcolumn(i):cargo    //  desmembra coluna em:
   cp_=PARSE(@cargox,"³")            //  nome do campo
   ms_=PARSE(@cargox,"³")            //  mascara
   ti_=PARSE(@cargox,"³")            //  titulo
   IF AT("|"+UPPER(cp_)+"|",xx_) = 0 // se nao for campo do arquivo atual
    m_campos+="|"+ti_                //  monta menu de campos
   ENDI
  NEXT
 ENDI
 i_=1                                  // pega nome dos arq relacionados
 DO WHIL LEN(&k_.->(DBRELATION(i_)))>0 // ao arq principal
  IF LEN(x_)>0
   x_+="|"
  ENDI
  x_+=&k_.->(ALIAS(DBRSELECT(i_)))     // nome do arq relacionado
  i_++                                 // proximo relacionamento
 ENDD
ENDD
m_campos=SUBS(m_campos,2)                        // despreza 1a. barra
op_6=1
m_criterio=""
DO WHIL selnum<10 .AND. cpsel!=SPAC(10)          // permite escolher somente 10 criterios
 selnum++                                        // contador de criterios
 IF selnum>1                                     // ja foi feito pelo menos um criterio
  m_tit="FILTRAGEM|OPERADORES L¢GICOS|*"+m_criterio
  op_2=DBOX("* Ok! *|E|OU",,,E_MENU,,m_tit)      // recebe operadores
  IF op_2=0                                      // cancelou
   criterio=""; cn=.t.                           // limpa criterio existente
   EXIT                                          // e retorna
  ENDI
  IF op_2=1                                      // criterio montado ok
   cpsel=SPAC(10)                                // prepara para sair
   LOOP
  ELSE
   op_2=TRIM(SUBS(".AND..OR. ",(op_2-1)*5-4,5))  // operador escolhido
   IF AT(".AND.",criterio)>0 .OR. AT(".OR.",criterio)>0
    criterio="("+criterio+")"                    // coloca parenteses
   ENDI
   criterio+=op_2                                // junta operador ao criterio
   m_criterio+="|"+op_2                          // monta titulo para proxima dbox()
  ENDI
 ENDI
 cpsel=SPAC(10) ; messaux=criterio
 m_tit="FILTRAGEM|CAMPOS DO ARQUIVO|*"+m_criterio
 op_1=DBOX(m_campos,,,E_MENU,,m_tit)             // escolhe campo para filtrar
 IF op_1=0                                       // cancelou
  criterio=""; cn=.t.                            // limpa criterio existente
  EXIT                                           // e retorna
 ENDI
 IF nivelop>=NIV_CRI_LIVRE                       // usuario pode fazer criterio livre
  IF op_1=1                                      // foi selecionado
   selnum=0 ; clivre=.t.
   EXIT
  ENDI
  op_1--                                         // com criterio livre, ha' mais um item
 ENDI                                            // no menu, portanto, ajusta op_1 para
 IF LEN(cri_ant)>0                               // se tem filtro anterior
  IF op_1=1                                      // e ele foi selecionado
   criterio+=cri_ant                             // monta o criterio final
   cpsel="Filtro anterior"                       // monta msg para dbox()
   m_criterio+="|"+cpsel
   LOOP
  ENDI
  op_1--                                         // com criterio livre, ha' mais um item
 ENDI
 ii=0
 cpsel=""                                       // inicializa campo esolhido
 x_=ALIAS()                                     // arquivo principal
 DO WHIL LEN(x_)>0                              // corre todas os arquivos
  k_=PARSE(@x_,"|")                             // para pegar campo escolhido
  nc = EVAL(&("{||"+k_+"->(FCOU())}"))          // numero de campos do arquivo
  FOR i=1 TO nc                                 // desprezando campo invisieis
   IF !("I"==sistema[EVAL(qualsis,k_),O_CAMPO,i,O_CRIT])
    ii++
   ENDI
   IF ii=op_1                                   // campo escolhido?
    IF k_==ALIAS()                              // se for o arq principal nao coloca alias()
     cpsel=FIEL(i)
    ELSE                                        // arq relacionado coloca o alias()
     cpsel=k_+"->"+&k_.->(FIEL(i))
    ENDI
    selpic=sistema[EVAL(qualsis,k_),O_CAMPO,i,O_MASC] // mascara do cp escolhido
    EXIT
   ENDI
  NEXT
  IF LEN(cpsel)>0                               // se ja achou o cp
   EXIT                                         // cai fora...
  ENDI
  IF brw                               // veio da EDITA
   IF k_==ALIAS()                      // e' o arquivo atual
    nc=br_w:colcount                   // numero de colunas para escolher
    FOR i=1 TO nc                      // monta menu de campos
     cargox=br_w:getcolumn(i):cargo    //  desmembra coluna em:
     cp_=PARSE(@cargox,"³")            //  nome do campo
     ms_=PARSE(@cargox,"³")            //  mascara
     IF AT("|"+UPPER(cp_)+"|",xx_) = 0 // se nao for campo do arquivo atual
      ii++                             // proxima opcao da dbox
     ENDI
     IF ii=op_1                        // coluna escolhida?
      cpsel=cp_                        // conteudo da coluna
      selpic=ms_                       // mascara da coluna
      IF LEFT(cpsel,5)="TRAN("         // vamos tirar a mascara
       i=RAT(",["+selpic+"])",cpsel)   // do conteudo para sabermos
       IF i>0                          // o tipo exato do dado da coluna
        cpsel=SUBSTR(cpsel,6,i-6)
       ENDI
      ENDI
      EXIT                             // cai fora...
     ENDI
    NEXT
    IF LEN(cpsel)>0                    // se ja achou o cp
     EXIT                              // cai fora...
    ENDI
   ENDI
  ENDI
  i_=1
  DO WHIL LEN(&k_.->(DBRELATION(i_)))>0         // pega todas as relacoes
   IF LEN(x_)>0                                 // deste arquivo
    x_+="|"
   ENDI
   x_+=&k_.->(ALIAS(DBRSELECT(i_)))             // nome do arq relacionado
   i_++                                         // nome da relacao
  ENDD
 ENDD
 tp_cp=VALTYPE(&cpsel.)                          // tipo do campo?
 m_tit="FILTRAGEM|OPERADORES RELACIONAIS|*"+;
       m_criterio+"|"+TRIM(cpsel)
 m_relac="=  Igual a      ÿ|"+;
         "#  Diferente de ÿ|"
 IF tp_cp!="L"                                   // logico so '= ou #`
  m_relac=m_relac+"<  Menor que    ÿ|"+;
                  "<= Menor ou igual|"+;
                  ">  Maior que    ÿ|"+;
                  ">= Maior ou igual"
 ENDI
 IF AT(tp_cp,"CM")>0                             // se tipo caracter ou memo tem $ (contem)
  m_relac=m_relac+"|$  Cont‚m       ÿ|!$ N„o cont‚m   ÿ"
 ENDI
 op_6=DBOX(m_relac,,,E_MENU,,m_tit)              // pega operando
 IF op_6=0                                       // cancelou com ESC
  criterio=""; cn=.t.                            // limpa criterio existente
  EXIT                                           // e retorna
 ENDI
 op_s=TRIM(SUBS("= # < <=> >=$ $ ",op_6*2-1,2))  // inicializa seg oper=tipo do campo
 IF tp_cp="D"
  oper_2=CTOD("")
 ELSEIF tp_cp="N"
  oper_2=0
 ELSEIF tp_cp="M"
  oper_2=SPAC(40)
 ELSE
  i=LEN(&cpsel.)
  oper_2=SPAC(i)
  IF i>50
   selpic="@S40"+selpic
  ENDI
 ENDI
 m_tit="FILTRAGEM: SEGUNDO OPERANDO|*"+m_criterio+"|"+TRIM(cpsel)+op_s
 oper_2=DBOX("Segundo operando (n„o use aspas):",,,,,m_tit,oper_2,selpic)
 IF LASTKEY()=K_ESC                              // cancelou
  selnum=0                                       // zera numero de criterios,
  criterio=""; cn=.t.                            // e o criterio parcialmente definido
  EXIT                                           // para retornar
 ENDI
 IF tp_cp="D"
  oper_2="CTOD(["+DTOC(oper_2)+"])"
 ELSEIF tp_cp="N"
  oper_2=LTRIM(TRAN(oper_2,""))
 ELSE
  IF EMPT(oper_2)
   oper_2="'"+oper_2+"'"
  ELSE
   oper_2="'"+TRIM(oper_2)+"'"
  ENDI
 ENDI
 IF op_6>6
  IF op_6=8                                      // operador "nao contem" (!$)
   cpsel="!("+oper_2+PADC(op_s,3)+;
         TRIM(cpsel)+")"
  ELSE
   cpsel=oper_2+PADC(op_s,3)+TRIM(cpsel)         // operador "contem" ($)
  ENDI
 ELSE
  cpsel=TRIM(cpsel)+op_s+oper_2                  // outros operadores
 ENDI
 criterio+=cpsel                                 // monta o criterio
 m_criterio+="|"+cpsel                           // monta msg para dbox()
ENDD
IF selnum>0 .AND. !cn                            // ha criterio feito
 IF flg                                          // vamos criar indice temporario
  IF ord!=NIL                                    // e possivelmente, ordenar
   ALERTA()
   cod_sos=21
   msg="Ordenar o arquivo|Prosseguir opera‡„o"   // ve se usuario quer ordenar
   op_=DBOX(msg,,,E_MENU,,"CLASSIFICA€ŽO DO ARQUIVO")
   IF op_=1                                      // sim! quer...
    cpord=""
    CLASS(.f.)                                   // entao, ordena
   ENDI
  ENDI
  FILTROINI(@filini)                             // concatena filtro inicial
  INDTMP()                                       // cria indice temporario
 ENDI
ELSEIF !cn
 IF clivre                                       // monta criterio livre
  criterio=SPAC(210)
  msg="A EXPRESSŽO ABAIXO DEVER ESTAR DE ACORDO COM|"+;
      "A SINTAXE DA LINGUAGEM PARA EVITAR ERRO DE PROCESSAMENTO|*|"+;
      "F10=CAMPOS DO ARQUIVO|*|INFORME A EXPRESSŽO FILTRO:"
  DO WHILE .t.
   SET KEY K_F10 TO ve_campos                    // F10 monta menu de campos
   criterio=DBOX(msg,,,,,SEPLETRA("* FILTRAGEM LIVRE *",1),criterio,"@S50")
   SET KEY K_F10 TO
   IF LASTKEY()=K_ESC                            // cancelou
    criterio=""; cn=.t.
    EXIT
   ENDI
   tp_crit=TYPE(criterio)                        // se a expressao=indeterminada
   IF tp_crit="UI"                               // existe funcao fora da clipper.lib na
    tp_crit=VALTYPE(&criterio.)                  // expressao, logo avalia o seu
   ENDI                                          // conteudo
   IF tp_crit="L"                                // se o tipo da expressao for
    EXIT                                         // logico, entao segue em frente
   ENDI
   ALERTA(3)
   DBOX("EXPRESSŽO ILEGAL",15)
  ENDD
  IF !cn
   criterio=ALLTRIM(criterio)                    // tira brancos da expressao
   IF !EMPT(criterio) .AND. flg                  // vai criar indice temporario
    IF ord!=NIL                                  // e ordenar o arquivo se quiser
     CLASS(.f.)
    ENDI
    FILTROINI(@filini)                           // concatena filtro inicial
    INDTMP()                                     // cria indice temporario
   ENDI
  ENDI
 ENDI
ENDI
IF flg .AND. EMPT(criterio) .AND.;               // se tirou o filtro
   INDEXKEY(0)="LTOC("                           // mas antes tinha
 FILTROINI(@filini)                              // concatena filtro inicial
 INDTMP()                                        // indexa o dbf novamente
ENDI
FILTROINI(@filini)                               // concatena filtro inicial
RETU

PROC FILTROINI(filini)    //concatena filtro inicial
IF brw .AND. filini=.f.   //se veio da funcao EDITA() e nao concatenou ainda...
 IF LEN(cr_ini)>0         //se existir filtro inicial, coloca
  criterio=cr_ini+IF(LEN(criterio)>0," .AND. ("+criterio+")","")
 ENDI
ENDI
filini=.t.                //flag: filtro ja' colocado
RETU

PROC VEOUTROS    // Abre op‡„o de consulta a outros arquivos
LOCAL op_a:=0, chvpesq, opm:=ARRAY(nss), db, tp, t_w, t_r, t_c, t_7, t_9,;
      v_:=SAVESCREEN(0,0,MAXROW(),79), reg_dbf:={}
PRIV cod_sos:=23, v_ar:=READVAR()
t_w:=SETKEY(K_CTRL_W,NIL)                        // desabilita e salva
t_r:=SETKEY(K_CTRL_R,NIL)                        // as teclas de controle
t_c:=SETKEY(K_CTRL_C,NIL)
t_7:=SETKEY(K_F7,NIL); t_9:=SETKEY(K_F9,NIL)
reg_dbf=POINTER_DBF()                            // salva situacao de todos dbf's
msg:=db := ""
FOR i=1 TO nss-3                                 // monta menu
 IF LEN(sistema[i,O_CPRELA])=0 .AND.;
    sistema[i,O_OUTROS,O_NIVEL]<=nivelop .AND.;
    LEN(sistema[i,O_INDIC])>0
  msg+="|"+sistema[i,O_MENU]                     // de nomes de arquivos
  db+=RIGHT(STR(1000+i),3)
 ENDI
NEXT
IF LEN(msg)>1
 op_a=DBOX(SUBS(msg,2),,3,E_MENU,,"BASE DE DADOS")// qual arquivo?
ENDI
IF op_a>0                                        // selecionado um...
 op_a=VAL(SUBS(db,op_a*3-2,3))
 db=sistema[op_a,O_ARQUI,O_NOME]                 // nome do arquivo (sem dir)
 tem_t=.f.
 IF !EMPTY(v_ar)                                 // alguma variavel pendente?
  IF  VALTYPE(&v_ar.) $ "CNDL"                   // se for caracter, numerica, data
   tem_t=!("OP_" $ UPPER(v_ar))                  // ou logica e nao for de menu,
   v_ar=TRANSCAMPO(.t.,v_ar)                     // pode transferir campos
  ENDI                                           // para o get pendente
 ENDI
 PTAB(IF(tem_t,v_ar,"^%"),db)                    // abre arquivo e tenta posicionar
                                                 // com conteudo do get pendente
 #ifdef COM_REDE
  IF NETERR()                                    // se deu erro de abertura,
   RETU                                          // retorna
  ENDI
 #endi

 SELE &db.                                       // seleciona o arquivo escolhido
 IF EOF()                                        // se fim de arquivo,
  GO TOP                                         // vai para o 1o. registro
 ENDI
 v_out=.t.
 cod_sos=8
 EDITA(09,10,MAXROW()-3,70)                      // consulta e faz projecoes
 v_out=.f.
ENDI
POINTER_DBF(reg_dbf)                             // restaura ponteiro dos dbf's
SETKEY(K_CTRL_W,t_w)                             // restaura teclas de controle
SETKEY(K_CTRL_R,t_r)
SETKEY(K_CTRL_C,t_c)
SETKEY(K_F7,t_7); SETKEY(K_F9,t_9)
RESTSCREEN(0,0,MAXROW(),79,v_)                   // restaura tela
RETU

PROC VE_CAMPOS   // Abre janela com nomes de campos
LOCAL ve_op:="", t_f10:=SETKEY(K_F10,NIL), ii                // evita recursividade
PRIV cod_sos:=26
FOR i=1 TO FCOU()                                            // monta menu com nomes e titulos
 IF !("I"==sistema[EVAL(qualsis,ALIAS()),O_CAMPO,i,O_CRIT])  //  exceto campos invisiveis
  ve_op+="|"+sistema[EVAL(qualsis,ALIAS()),O_CAMPO,i,O_TITU]+" ("+FIEL(i)+")"
 ENDI
NEXT
op_campo=DBOX(SUBS(ve_op,2),,50,E_MENU,,"CAMPOS DO ARQUIVO") // apresentar menu de campos
IF op_campo>0                                                // escolheu um campo
 ii=0
 FOR i=1 TO FCOU()                                           // sincriniza opcao escolhida
  IF !("I"==sistema[EVAL(qualsis,ALIAS()),O_CAMPO,i,O_CRIT]) // com o campo equivalente
   ii++
  ENDI
  IF ii=op_campo                                             // e este o campo
   KEYB ALLTRIM(FIEL(i))                                     // coloca no buffer do teclado
   EXIT                                                      // seu nome (nome em arquivo)
  ENDI
 NEXT
ENDI
SETKEY(K_F10,t_f10)                                          // reabilita F10
RETU

PROC INDTMP    // Cr¡a ¡ndices tempor rios
LOCAL op_sis, ind_ok, ind_an, arqtmp, cur_atual:=SETCURSOR(0), chv_, p_ , x_, ind01, ind02, ind03, ind04
op_sis=EVAL(qualsis,ALIAS())                   // subscricao do vetor sistema

/*
   se pediu ordenacao e nao e' indice de pesquisa ou ha filtragem,
   cria novo arquivo indice
*/

IF LEN(cpord)>1 .OR. !EMPT(criterio) .OR.;     // se tem ordenacao ou filtro
   INDEXORD()>LEN(sistema[op_sis,O_CHAVE])     // ou esta usando indice temporario
 arqtmp=drvntx+LEFT(ALIAS(),3)+;
        ide_maq+EXTENSAO()                     // nome arquivo ntx temporario
 ind_ok=0
 nord:=juncao_ := ""
 IF !EMPT(criterio)                            // tem filtro?
  nord="LTOC("+criterio+")"; juncao_="+"       // indexa pela condicao
 ENDI
 IF !EMPT(chv_rela)                            // a janela esta relacionada?
  chv_=INDEXKEY(0)                          // chave do indice atual
  IF chv_="LTOC("                              // se existir filtro na chave
   chv_=SUBS(chv_,6); x_=1                     // vamos tirar a sua expressao
   DO WHILE x_!=0                              // ltoc(...)+...
    p_=LEFT(chv_,1)
    x_=x_+IF(p_=")",-1,IF(p_="(",1,0))
    chv_=SUBS(chv_,2)
   ENDD
   chv_=SUBS(chv_,2)                           // retira o "+" da frente
  END IF
  p_=CONTA("+",chv_rela)+1                     // quantidade de campos da relacao
  DO WHILE p_-->0                              // extrai os campos do indice
   nord+=juncao_+PARSE(@chv_,"+"); juncao_="+" // monta expressao do indice
  ENDD
 ENDI
 IF LEN(cpord)>1                               // se escolheu outra ordenacao
  nord+=juncao_+cpord                          // vamos usa-la
 ELSEIF LEN(INDEXKEY(0))=0
  nord+=juncao_+UPPE(INDEXKEY(1))              // concatena com o indice basico
 ELSE
  nord+=juncao_+UPPE(INDEXKEY(0))              // concatena com o indice basico
 ENDI
 qt_ind=LEN(sistema[op_sis,O_INDIC])
 FOR t=1 TO qt_ind                             // ordem escolhida e' igual
  IF UPPE(INDEXKEY(t))=UPPE(nord)              // a algum indice de pesquisa?
   ind_ok=t                                    // sim! vamos usa'-lo
   EXIT
  ENDI
 NEXT
 IF ind_ok=0
  ind_t=SAVESCREEN(0,0,MAXROW(),79)            // sava tela e da msg
  ind_ok=qt_ind+1                           // ordem do indice a usar
  POE_GAUGE("Criando ¡ndice tempor rio")
  INDE ON &nord. TO (arqtmp) EVAL POE_GAUGE() EVERY (LASTREC()/20) // indexando...
  RESTSCREEN(0,0,MAXROW(),79,ind_t)
  ind01=sistema[op_sis,O_ARQUI,O_DIR_NTX]+sistema[op_sis,O_INDIC,1]
  IF qt_ind=1
   SET INDE TO (ind01), (arqtmp)
  ELSE
   ind02=sistema[op_sis,O_ARQUI,O_DIR_NTX]+sistema[op_sis,O_INDIC,2]
   IF qt_ind=2
    SET INDE TO (ind01), (ind02), (arqtmp)
   ELSE
    ind03=sistema[op_sis,O_ARQUI,O_DIR_NTX]+sistema[op_sis,O_INDIC,3]
    IF qt_ind=3
     SET INDE TO (ind01), (ind02), (ind03), (arqtmp)
    ELSE
     ind04=sistema[op_sis,O_ARQUI,O_DIR_NTX]+sistema[op_sis,O_INDIC,4]
     IF qt_ind=4
      SET INDE TO (ind01), (ind02), (ind03), (ind04), (arqtmp)
     ENDI
    ENDI
   ENDI
  ENDI
 ENDI
 DBSETORDER(ind_ok)                            // usa a ordem apropriada
 REGINICIO()                                   // verifica se reg esta' no filtro
ENDI
SETCURSOR(cur_atual)                           // retorna o cursor ao normal
RETU

PROC REP  // Liga/desliga repeti‡„o de registro
IF op_menu=INCLUSAO .AND. !EMPT(READVAR())
 fgrep=!fgrep
 im_aj_at_=1            // var usada dentro da GETSYS para
ENDI                    // imprimir informacoes no rodape'
RETU

PROC CONF  // Liga/desliga confirma‡„o em campos
IF op_menu=INCLUSAO .AND. !EMPT(READVAR())
 drvconf=!drvconf
 SET CONF (drvconf)     // ajusta SET CONFIRM
 im_aj_at_=1            // var usada dentro da GETSYS para
ENDI                    // imprimir informacoes no rodape'
RETU

PROC CLASS(conf_ord_)  //  Pega seqˆncia de campos para ordenar arquivo
LOCAL menucp:="", op_sis, clivre:=.f., msg, cpord_antes:=cpord,;
      qt_ind, op_ord:=0, tela_class:=SAVESCREEN(0,0,MAXROW(),79), x_, k_, i_
PRIV cod_sos:=14
op_sis=EVAL(qualsis,ALIAS())               // qual subsistema?
qt_ind=LEN(sistema[op_sis,O_CHAVE])        // qde de indices do arquivo
IF ATAIL(sistema[op_sis,O_CHAVE])="codlan" // ve se ultima chaves e' de relacionamento
 qt_ind--                                  // se for, nao pode ser escolhido
ENDI
IF qt_ind>1                                // se mais de um indice,
 msg=""                                    // escolhe por menu o conjunto
 FOR t=1 to qt_ind                         // de indice desejado para a
  msg+="|"+sistema[op_sis,O_CONSU,t]       // nova ordenacao
 NEXT
 msg+="|* OUTRA ORDEM *"                   // ou deixa escolher qualquer campo
 op_ord=DBOX(SUBS(msg,2),,,E_MENU,,"SELECIONE A ORDENA€ŽO")
 DO CASE
  CASE op_ord=0                            // quer abandonar...
   op_ord=1

  CASE op_ord=qt_ind+1                     // quer escolher qualquer campo
   op_ord=0

  OTHERWISE                                // escolheu um indice...
   cpord+=IF(LEN(cpord)>1,"+","")+;        // comcatena o indice com a
          sistema[op_sis,O_CHAVE,op_ord]   // ordenacao pre-definida
 ENDC
ENDI
IF op_ord=0                           // quer definir uma ordenacao...
 msg=IF(EMPTY(cpord),"","*"+cpord)
 IF nivelop>=NIV_CRI_LIVRE            // verifica se usuario autorizado a fazer
  menucp="|* * Ordena‡„o livre * *"   // ordenacao livre
 ENDI
 IF brw                              // veio da EDITA()
  nc=br_w:colcount                   // numero de campos para escolher
  FOR i=1 TO nc                      // monta menu de campos
   cargox=br_w:getcolumn(i):cargo    //  desmembra coluna em:
   cp_=PARSE(@cargox,"³")            //  nome do campo
   ms_=PARSE(@cargox,"³")            //  mascara
   ti_=PARSE(@cargox,"³")            //  titulo
   menucp+="|"+ti_                   //  monta menu de campos
  NEXT
 ELSE                                // ordenacao do relat¢rio
  x_=ALIAS()                         // monta menu de campos com
  DO WHIL LEN(x_)>0                  // todas os arquivos relacionadas
   k_=PARSE(@x_,"|")                 // arquivo atual
   nc=EVAL(&("{||"+k_+"->(FCOU())}"))// numero de campos do arquivo
   FOR i=1 TO nc                     // monta menu de campos, exceto invisivel
    IF !("I"==sistema[EVAL(qualsis,k_),O_CAMPO,i,O_CRIT])
     menucp+="|"+sistema[EVAL(qualsis,k_),O_CAMPO,i,O_TITU]
    ENDI
   NEXT
   i_=1                                  // pega nome dos arq relacionados
   DO WHIL LEN(&k_.->(DBRELATION(i_)))>0 // ao arq principal
    IF LEN(x_)>0
     x_+="|"
    ENDI
    x_+=&k_.->(ALIAS(DBRSELECT(i_)))     // nome do arq relacionado
    i_++                                 // proximo relacionamento
   ENDD
  ENDD
 ENDI
ENDI
DO WHIL op_ord=0
 IF LEN(msg)>0                        // mostra campos escolhidos
  op_0=DBOX(SUBS(msg,2),,50,,NAO_APAGA,"ORDENA€ŽO")
 ENDI
 op_0=DBOX(SUBS(menucp,2),,6,E_MENU,,"CAMPOS PARA ORDENAR|O ARQUIVO")
 IF op_0!=0                           // escolheu um campo
  op_1=op_0
  IF nivelop>=NIV_CRI_LIVRE           // se tem autorizacao para ordenacao
   IF op_1=1                          // livre, entao faz...
    clivre=.t.
    EXIT
   ENDI
   op_1--                             // faz op_1 a subscricao do campo ou coluna
  ENDI
  IF brw                              // se chamado da EDITA()
   cargox=br_w:getcolumn(op_1):cargo  // desmembra coluna em campo, mascara e titulo
   cp_=PARSE(@cargox,"³")
   ms_=PARSE(@cargox,"³")
   ti_=PARSE(@cargox,"³")
  ELSE
   ii=0
   cp_=""                             // inicializa campo escolhido
   x_=ALIAS()                         // acha campo escolhido
   DO WHIL LEN(x_)>0                  // considerando todas os arquivos relacionados
    k_=PARSE(@x_,"|")                 // arquivo atual
    nc=EVAL(&("{||"+k_+"->(FCOU())}"))// numero de campos do arquivo
    FOR i=1 TO nc                     // monta menu de campos, exceto invisivel
     IF !("I"==sistema[EVAL(qualsis,k_),O_CAMPO,i,O_CRIT])
      ii++
     ENDI
     IF ii=op_1                       // campo escolhido?
      IF k_==ALIAS()
       cp_=&k_.->(FIEL(i))
      ELSE
       cp_=k_+"->"+&k_.->(FIEL(i))
      ENDI
      ti_=sistema[EVAL(qualsis,k_),O_CAMPO,i,O_TITU]
      EXIT
     ENDI
    NEXT
    IF LEN(cp_)>0
     EXIT
    ENDI
    i_=1                                  // pega nome dos arq relacionados
    DO WHIL LEN(&k_.->(DBRELATION(i_)))>0 // ao arq principal
     IF LEN(x_)>0
      x_+="|"
     ENDI
     x_+=&k_.->(ALIAS(DBRSELECT(i_)))     // nome do arq relacionado
     i_++                                 // proximo relacionamento
    ENDD
   ENDD
  ENDI
  IF TYPE(cp_) $ "MLU"                     // se tipo MEMO, LOGICO ou INDEFINIDO...
   ALERTA(3)                               // ... nao da' para usar
   DBOX("Campo "+MAIUSC(ti_)+" n„o|pode ser usado para ordena‡„o",,,,,"ATEN€ŽO!")
   LOOP
  ENDI
  cp_=TRANSCAMPO(.f.,cp_)                  // transforma paara caracter
  msgt="ESCOLHA O SENTIDO DA ORDENA€ŽO|DO CAMPO "+MAIUSC(ti_)
  op=DBOX("Crescente|Decrescente",,,E_MENU,,msgt)
  msg +="|"+ti_
  IF op=2                                  // pediu ordem decrescente
   cp_="DESCEND("+cp_+")"
   msg+=" (Decrescente)"
  ENDI
  cpord+=IF(LEN(cpord)>1,"+","")+cp_       // concatena campos escolhidos
 ELSE
  EXIT
 ENDI
ENDD
IF clivre                                  // vai fazer ordenacao livre
 cpord=SPAC(210)
 msg="A EXPRESSŽO ABAIXO DEVER ESTAR DE ACORDO COM|"+;
     "A SINTAXE DA LINGUAGEM PARA EVITAR ERRO DE PROCESSAMENTO|*|"+;
     "F10=CAMPOS DO ARQUIVO|*|INFORME A EXPRESSŽO PARA ORDENA€ŽO"
 DO WHILE .T.
  SET KEY K_F10 TO ve_campos               // habilita F10 para ver campos DBF
  cpord=DBOX(msg,,,,,SEPLETRA("* ORDENA€ŽO  LIVRE *",1),cpord,"@S50")
  SET KEY K_F10 TO                         // desabilita F10
  IF LASTKEY()=K_ESC
   cpord=""                                // cancelou...
   EXIT
  ENDI
  tp_crit=TYPE(cpord)
  IF tp_crit="UI"                          // se expressao=indeterminado
   tp_crit=VALTYPE(&cpord.)                // existe funcao fora da clipper.lib
  ENDI                                     // entao avalia o conteudo da expressao
  IF tp_crit $ "CND"                       // so ordena tipos caracter/numerico/data
   IF tp_crit="N"                          // transf p/ caracter ordem tp numerica
    cpord="STR("+ALLTRIM(cpord)+")"
   ELSEIF tp_crit="D"                      // transf p/ caracter ordem tp data
    cpord="DTOS("+ALLTRIM(cpord)+")"
   ENDI
   EXIT                                    // vamos retornar, ordenacao ajustada
  ENDI
  ALERTA(3)                                // ordenacao livre invalida
  DBOX("EXPRESSŽO ILEGAL",15)              // vamos avisar...
 ENDD
 cpord=ALLTRIM(cpord)                      // tira brancos da expressao
ENDI
RESTSCREEN(0,0,MAXROW(),79,tela_class)     // restaura tela original
IF !EMPTY(cpord) .AND. conf_ord_ .AND.;    // mudou a ordenacao e quer
   cpord_antes!=cpord                      // que confirma a ordenacao?
 IF op_ord=0                               // se nao escolheu um ja existente
  ALERTA(1)                                // beep! e
  msg="Prosseguir|Cancelar"                // ve se usuario quer ordenar
  msgt="ORDENA€ŽO DO ARQUIVO"              // realmente o arquivo
  cod_sos=1
  ii=DBOX(msg,,,E_MENU,,msgt)
  IF ii!=1                                 // se desistiu,
   cpord=cpord_antes                       //  volta ordenacao anterior
  ELSE                                     // senao,
   INDTMP()                                //  cria indice temporario
  ENDI
 ELSE
  INDTMP()                                 // seleciona indice escolhido
 ENDI
ENDI
RETU

PROC CAPTURAARQ()  // captura arquivo da lista
LSTARQDIR(.t.)
RETU

PROC CAPTURADIR()  // captura diretorio da lista
LSTARQDIR(.f.)
RETU

PROC ESCOLHIDOUM()
_Escolheu=.t.
KEYB CHR(K_ENTER)
RETU

PROC LSTARQDIR(_comarq)
LOCAL t, op_a, dir_arq:={}, dir_, qt_dir, dir_base, v_ar:=READVAR(),;
      t_f10:=SETKEY(K_F10,NIL), msgt:=""     // evita recursividade
PRIVATE _Escolheu
IF !EMPTY(v_ar)                              // alguma variavel pendente?
 dir_base=ALLTRIM(&v_ar.)                    // pega dir default dela
ENDI
IF EMPTY(dir_base)                           // se nao pegou diretorio da var
 dir_base=drvdbf                             // o default sera o dos dbf's
ENDI
IF RIGHT(dir_base,1)<>"\"                    // se dirtorio nao terninar com \
 dir_base=dir_base+"\"                       // vamos colocar
ENDI
IF !criadrv(dir_base)                        // verifica/cria diretorio
 SETKEY(K_F10,t_f10)                         // cancelou... reabilita F10
 RETU                                        // e cai fora
ENDI
DO WHILE .t.
 _Escolheu=.f.
 IF _comarq
  dir_arq=DIRECTORY(dir_base+mask_)          // lst de arquivo desejados
  msgt=mask_
 ELSE
  dir_arq:={}
  msgt="|F10=Escolhe"
 ENDI
 dir_=DIRECTORY(dir_base+"*.*","D")          // lst de todos arq + diretorios
 qt_dir=1
 FOR t=1 TO LEN(dir_)                        // verifica quais dos arquivos
  IF dir_[t,5]="D" .AND. "."!=dir_[t,1]      // e' um diretorio e o
   AADD(dir_arq,{})                          // adiciona mais um na lst
   AINS(dir_arq,qt_dir)                      // insere na posicao certa
   ACOPY(dir_,dir_arq,t,1,qt_dir)            // copia todos os atributos
   qt_dir++                                  // qtde de diretorios
  ENDI
 NEXT
 FOR t=1 TO LEN(dir_arq)
  IF AT("~",dir_arq[t,1])>0
   dir_arq[t,1]=STRTRAN(dir_arq[t,1],"~","ô")
  ENDI
 NEXT
 IF _comarq=.f.
  SET KEY K_F10 TO ESCOLHIDOUM()
 ENDI
 op_a=DBOX(dir_arq,,,.T.,,dir_base+msgt)    // escolhe o arquivo desejado
 IF op_a=0                                   // abandonou
  EXIT                                       // entao, cai fora
 ENDI
 IF AT("ô",dir_arq[op_a,1])>0
  dir_arq[op_a,1]=STRTRAN(dir_arq[op_a,1],"ô","~")
 ENDI
 IF dir_arq[op_a,5]="D" .AND. _escolheu=.f.  // o arquivo escolhido e' um diretorio
  IF dir_arq[op_a,1]=".."                    // que voltar um diretorio
   dir_base=LEFT(dir_base,LEN(dir_base)-1)   // tira a "\" do final do diretorio
   dir_base=LEFT(dir_base,RAT("\",dir_base)) // tira o nome do ultimo diretorio
  ELSE                                       // escolheu um sub-diretorio
   dir_base=dir_base+dir_arq[op_a,1]+"\"     // vamos ate ele...
  ENDI
 ELSE                                        // coloca no buffer do teclado arq escolhido
  KEYB CHR(K_HOME)+CHR(K_CTRL_Y)+dir_base+IIF(dir_arq[op_a,1]="..","",dir_arq[op_a,1])
  EXIT                                       // e cai fora
 ENDI
ENDD
SETKEY(K_F10,t_f10)                          // reabilita F10
RETU

PROC POSI   // Recebe argumentos e pesquisa arquivo
LOCAL op_sis, i, ii, iii, tip, j_, msg, ind, qt_ind, ok_
PRIV cod_sos
op_sis=EVAL(qualsis,ALIAS())         // subscricao do vetor Sistema
ind=INDEXORD()                       // salva ordem atual
DO WHIL op_sis>0
 cod_sos=24
 qt_ind=LEN(sistema[op_sis,O_INDIC]) // qde de indices do arquivo
 chv=ATAIL(sistema[op_sis,O_CHAVE])  // pega ultimo elemento das chaves
 IF chv=="codlan"                    // e ve se e' ntx de relacionamento
  qt_ind--                           // se for, nao pode ser escolhido
 ENDI
 IF qt_ind>1                         // se mais de um,
  msg=""                             // escolhe por menu o conjunto de pesquisa
  FOR t=1 to qt_ind
   msg+="|"+sistema[op_sis,O_CONSU,t]
  NEXT
  op_posi=DBOX(SUBS(msg,2),,,E_MENU,,"SELECIONE A PESQUISA",,,op_posi)
  IF op_posi=0                       // cancelou
   DBSETORDER(ind)                   // restaura ordem anterior
   RETU                              // e retorna
  ENDI
 ELSE
  op_posi=1                          // so um indice, usa 1o. cj pesquisa
 ENDI
 DBSETORDER(op_posi)                 // usa o conjunto de pesquisa escolhido
 chvpesq:=msg:=""
 cod_sos=25

 /*
    Pega cada um dos campos chaves do conjunto de pesquisa selecionado.
    A variavel sistema[op_sis,O_ORDEM,1] possui, a cada dois digitos,
    os numeros de ordem dos campos escolhidos para chave.
    Exemplo: "010305"     (campos 1, 3 e 5 compoem a chave do conj pesquisa)
 */
 FOR i=1 TO LEN(sistema[op_sis,O_ORDEM,op_posi]) STEP 2   // para cada chave...
  ii=VAL(SUBS(sistema[op_sis,O_ORDEM,op_posi],i,2))       // ordem do campo
  tip=VALTYPE(&(FIELD(ii)))                               // tipo do campo
  IF tip="C"                                              // inicializa variavel
   chv=SPAC(LEN(&(FIELD(ii))))                            // p/ receber argumento
  ELSEIF tip="N"                                          // de acordo com o tipo
   chv=0                                                  // do campo
  ELSEIF tip="D"
   chv=CTOD('')
  ELSEIF tip="L"
   chv=.t.
  ENDI
  gab=sistema[op_sis,O_CAMPO,ii,O_MASC]                   // mascara do campo
  IF ii<=LEN(sistema[op_sis,O_CPRELA]) .AND.;             // se campo for de relacionamento
     sistema[op_sis,O_CAMPO,ii,O_CRIT]="I"                // e e' invisivel entao
   chv=&(sistema[op_sis,O_CPRELA,ii])                     // monta a chave automaticamente
  ELSE
   chv=DBOX(msg+"Informe "+;                              // recebe argumento de pesquisa
       sistema[op_sis,O_CAMPO,ii,O_TITU],,,,,"PROCURA REGISTRO",chv,gab)
  ENDI
  IF (EMPT(chv).AND.tip!="L") .OR. LASTKEY()=K_ESC        // cancelou ou informou parte
   EXIT
  ENDI
  msg=msg+sistema[op_sis,O_CAMPO,ii,O_TITU]+": "+;        // prepara mensagem do
      TRAN(chv,gab)+"||"                                  // titulo da janela
  chvpesq=chvpesq+TRANSCAMPO(.t.,"chv",ii)                // transforma p/ caracter
 NEXT
 chvpesq=TRIM(chvpesq)                                    // tira espacos
 IF EMPT(chvpesq) .OR. LASTKEY()=K_ESC                    // cancelou ou nao informou
  EXIT
 ENDI
 ultreg=RECN()                                            // salva registro corrente
 ok_=.f.
 SEEK chvpesq                                             // procura
 IF FOUND()                                               // achou?
  DO WHILE !EOF() .AND. &(INDEXKEY(op_posi))=chvpesq   // verifica se atende filtro
   IF &(INDEXKEY(ind))=IF(EMPT(criterio),"","T")+chv_1
    ok_=.t.                                               // ok...
    EXIT
   ELSE
    SKIP                                                  // tenta o proximo
   ENDI
  ENDD
 ENDI
 IF ok_
  EXIT                                                    // este serve...
 ELSE                                                     // nao serviu
  GO ultreg                                               // volta ao registro
  ALERTA(2)
  DBOX(msg+"n„o encontrado, "+usuario,,,2,,"ATEN€ŽO!")    // vamos avisar ao usuario
 ENDI
ENDD
DBSETORDER(ind)                                           // usa ordem original
RETU

PROC IMPRELA    // Imprime as telas dos arquivos relacionados
LOCAL i_, op_sy_, op_s:=op_sis, ar_db:=ALIAS(), ultreg, ord_ind, chv_, ;
      cor_ant:=SETCOLOR()
PRIV op_sis:=op_sis, corcampo:=corcampo, drvcortel:=drvcortel,;
     drvtittel:=drvtittel, l_s, c_s, l_i, c_i, vr_memo:=vr_memo,;
     chv_rela, chv_1, chv_2, criterio, cpord
IF !EMPTY(ar_db)                       // sava situacao atual
 ultreg =RECNO()                       // registro e
 ord_ind=INDEXORD()                 // indice utilizado
ENDI
op_sy_=PEGAPAI(op_sis)                 // pega o "pai" de todos
SELE (sistema[op_sy_,O_ARQUI,O_NOME])
drvcortel =drvcortna                   // cores de tela nao ativa
drvtittel:=corcampo := drvtittna
FOR op_sis=op_sy_ TO nss               // a partir do "pai" pega os "filhos"
 IF op_s!=op_sis                       // menos o arquivo atual
  IF op_sis>op_sy_                     // pode ser um "filho"
   IF PEGAPAI(op_sis)!=op_sy_ .OR.;    // se nao tem o mesmo "pai"
      sistema[op_sis,O_OUTROS,O_NIVEL]>5// ou nao tem tela
    EXIT                               // cai fora...
   ENDI
  ENDI

  #ifdef COM_REDE
   IF !USEARQ(sistema[op_sis,O_ARQUI,O_NOME],.f.,20,1)
    RETU                               // nao conseguiu abrir o arquivo
   ENDI
  #else
   USEARQ(sistema[op_sis,O_ARQUI,O_NOME])     // abre o arquivo
  #endi

  chv_rela=""                          // monta expressao de ligacao
  FOR i=1 TO LEN(sistema[op_sis,O_CPRELA])
   chv_rela+="+"+TRANSCAMPO(.f.,sistema[op_sis,O_CPRELA,i],i)
  NEXT
  chv_rela=IF(LEN(chv_rela)>2,SUBS(chv_rela,2),"")
  PEGACHV2()                           // acha o 1o. e ultimo reg da relacao
  cr_="cr_"+ALIAS()                    // filtro da janela
  or_="or_"+ALIAS()                    // ordem da janela
  IF TYPE(cr_)!="U"                    // se ja esta definido
   criterio=&cr_                       // pega o filtro e a
   cpord=&or_                          // ordem
  ELSE                                 // caso contrario
   criterio:=cpord := ""               // inicializa o filtro/ordem
  ENDI
  REGINICIO()                          // verif/posiciona no 1 reg que atende filtro
  l_s=Sistema[op_sis,O_TELA,O_LS]      // coordenadas da tela
  c_s=Sistema[op_sis,O_TELA,O_CS]
  l_i=Sistema[op_sis,O_TELA,O_LI]
  c_i=Sistema[op_sis,O_TELA,O_CI]
  NOVAPOSI(@l_s,@c_s,@l_i,@c_i)        // pega posicao atual da tela
  i_=LEFT(sistema[op_sis,O_ARQUI,O_NOME],3)
  EVAL(&("{||"+i_+"_gets()}"))         // imprime a tela/registro
 ENDI
NEXT
op_sis=op_s                            // retorna ao arquivo anterior
IF !EMPTY(ar_db)                       // se existia um dbf nesta area
 SELE (ar_db)                          // restabelece a area
 DBSETORDER(ord_ind)                   // indice usado
 GO ultreg                             // registro
ELSE                                   // senao, pode ser uma inclusao
 SELE 0                                // seleciona a 1a. area sem dbf
ENDI
SETCOLOR(cor_ant)                      // restaura cor original
RETU

PROC REIMPTEL    // reeimprime as telas dos arquivos relacionados
LOCAL tl_item_:=SAVESCREEN(l_s,c_s,l_i,c_i) // salva janela ativa
DISPBEGIN()                                 // montaremos na tela de traz
IMPRELA()                                   // reeimprime outras janelas
CAIXA(mold,l_s,c_s,l_i,c_i)                 // refaz a sombra janela atual
RESTSCREEN(l_s,c_s,l_i,c_i,tl_item_)        // restraura janela atual
DISPEND()                                   // mostra a nova tela
RETU

PROC EDIT   // Manuten‡„o de arquivos
LOCAL prgets, prget1, princl, li, co, tecl_p, msg, sos_cod:=cod_sos,;
      i, ii, ultreg, pri_vez:=.t., ord_dbf, t_w, t_r, t_c
PRIV  chv_1, chv_2, tem_borda, op_sis:=op_sis, chv_rela:="", chv_1:="", chv_2:="", l_a
edic=1
t_w:=SETKEY(K_CTRL_W,NIL)                               // desabilita e salva
t_r:=SETKEY(K_CTRL_R,NIL)                               // as teclas de controle
t_c:=SETKEY(K_CTRL_C,NIL)

/*
   Simplificando o CASE. A variavel tbtecla e' um vetor bidimensional
   que contem as teclas a serem testadas e suas respectivas acoes dentro
   do "code block" correspondente
*/
tbtecla={{K_LEFT,     {||op_edic:="A"}},;
         {K_RIGHT,    {||op_edic:="S"}},;
         {K_UP,       {||op_edic:="A"}},;
         {K_DOWN,     {||op_edic:="S"}},;
         {K_F9,       {||if(op_sis=nss .and. !eof(),trocasenha(.f.,DECRIPT(pw_nome)),veoutros())}},;
         {K_ALT_F8,   {||rola_t:=.t.,ROLATELA()}},;
         {K_CTRL_PGDN,{||FIM_ARQ()}},;
         {K_CTRL_PGUP,{||INI_ARQ()}};
        }

DO WHIL .t.
 SET CURS OFF
 IF pri_vez
  tbmenu="PSADCMERFOG"                         // letras iniciais das opcoes
  FOR i=1 TO LEN(exrot[op_sis])                // exclui comando da lista
   tbmenu=STRTRAN(tbmenu,SUBS(exrot[op_sis],i,1),"")
  NEXT
  IF AT("D",tbmenu)=0                             // se pode incluir deixa copiar
   tbmenu=STRTRAN(tbmenu,"C","")
  ENDI
  msg_menu=""
  msg_menu+=IF(AT("P",tbmenu)>0,"Procura|","") // variavel contendo opcoes
  msg_menu+=IF(AT("S",tbmenu)>0,"Seguinte|","")// do menu de edicao
  msg_menu+=IF(AT("A",tbmenu)>0,"Anterior|","")
  msg_menu+=IF(AT("D",tbmenu)>0,"Digita|Copia|","")
  msg_menu+=IF(AT("M",tbmenu)>0,"Modifica|","")
  msg_menu+=IF(AT("E",tbmenu)>0,"Exclui|","")
  msg_menu+=IF(AT("R",tbmenu)>0,"Recupera|","")
  msg_menu+=IF(AT("F",tbmenu)>0,"Filtra|","")
  msg_menu+=IF(AT("O",tbmenu)>0,"Ordena|","")
  msg_menu+=IF(AT("G",tbmenu)>0,"Global","")

  #ifdef COM_REDE
   IF !USEARQ(sistema[op_sis,O_ARQUI,O_NOME],.f.,20,1)// se nao abriu arquivo,
    RETU                                       // volta
   ENDI
  #else
   USEARQ(sistema[op_sis,O_ARQUI,O_NOME])      // abre DBF/NTX
  #endi

  prget1=LEFT(ALIAS(),3)+"_get1"               // nome prg para modificar o registro
  princl=LEFT(ALIAS(),3)+"_incl"               // nome prg para inclusao de registros

  /*
     compila code block em tempo de execucao para apresentar as telas/campos
  */
  prgets=&("{||"+LEFT(ALIAS(),3)+"_gets()}")
  chv_rela=""                                  // monta expressao de ligacao
  FOR i=1 TO LEN(sistema[op_sis,O_CPRELA])     // com a jenela superoir
   chv_rela+="+"+TRANSCAMPO(.f.,sistema[op_sis,O_CPRELA,i],i)
  NEXT
  chv_rela=IF(LEN(chv_rela)>2,SUBS(chv_rela,2),"")
  cr_="cr_"+ALIAS()
  or_="or_"+ALIAS()
  IF TYPE(cr_)!="U"
   criterio=&cr_
   cpord=&or_
  ELSE
   criterio:=cpord := ""
  ENDI
  PEGACHV2()                                   // acha o 1o. e ultimo reg da relacao
  DISPBEGIN()
  EVAL(Prgets)       // exibe tela e conteudo do registro
  IMPRELA()
  EVAL(Prgets)       // exibe tela e conteudo do registro
  INFOSIS(.f.)       // exibe informacao no rodape' da tela
  DISPEND()
  pri_vez=.f.
 ENDI
 cod_sos=sos_cod

 #ifdef COM_MOUSE
  tecl_p=MOUSETECLA()
  MOUSEGET(@li,@co)
  IF tecl_p=CLICK                            // clicou botao esquerdo
   IF li<l_s.OR.co<c_s.OR.li>l_i.OR.co>c_i
    IF LEN(sistema[op_sis,O_DBRELA])>0 .OR.; // e' um "pai" ou "filho"
       LEN(sistema[op_sis,O_CPRELA])>0
     pai_sis=PEGAPAI(op_sis)                 // ve se o clique do mouse
     ii=op_sis                               // esta dentro da area da
     FOR op_sis=pai_sis TO nss               // tela de qualquer um
      IF PEGAPAI(op_sis)=Pai_sis             // arquivo relacionado
       l_s=Sistema[op_sis,O_TELA,O_LS]       // coordenadas da tela
       c_s=Sistema[op_sis,O_TELA,O_CS]
       l_i=Sistema[op_sis,O_TELA,O_LI]
       c_i=Sistema[op_sis,O_TELA,O_CI]
       vr_memo=NOVAPOSI(@l_s,@c_s,@l_i,@c_i) // pega posicao atual da tela
       IF li>=l_s .AND. co>=c_s .AND.;       // esta' dentro desta tela...
          li<=l_i .AND. co<=c_i
        ii=op_sis
       ENDI
      ELSE
       EXIT
      ENDI
     NEXT
     op_sis=ii
     pri_vez=.t.
     l_a=NIL
    ENDI
    LOOP
   ENDI
   novapos=.t.
   KEYB CHR(77)            // coloca "M" no buffer para
   tecl_p=IN_KEY(0)        // fazer lastkey() != de ESC
  ENDI
 #else

  #ifdef COM_REDE
   tecl_p=IN_KEY(drvtempo)  // faz "refresh" da tela a cada drvtempo seg
  #else
   tecl_p=IN_KEY(0)         // aguarda usuario teclar algo
  #endi

 #endi

 IF SETKEY(tecl_p)!=NIL     // se tecla digitada tem funcao programada
  EVAL(SETKEY(tecl_p))      // executa programacao
  tecl_p=0
 ENDI
 SET CURS ON                              // acende o cursor
 op_edic=""
 nm=ASCAN(tbtecla,{|ve_a|tecl_p=ve_a[1]}) // procura tecla digitada no vetor tbtecla
 IF nm != 0                               // se achou,
  EVAL(tbtecla[nm,2])                     // entao executa
 ELSEIF tecl_p=K_PGDN .AND.;              // PgDn com scroll
        LEN(sistema[op_sis,O_TELA])>7
  IF MOV_PTR(sistema[op_sis,O_TELA,O_QTDE])=0
   ALERTA(2)                              // encontrado o final do
   DBOX("* FINAL DO ARQUIVO *",15,,1)     // arquivo, vamos avisar
  ENDI
 ELSEIF tecl_p=K_PGUP .AND.;              // PgUp com scroll
        LEN(sistema[op_sis,O_TELA])>7
  IF MOV_PTR(-1*sistema[op_sis,O_TELA,O_QTDE])=0
   ALERTA(2)                              // encontrado o inicio do
   DBOX("* INICIO DO ARQUIVO *",15,,1)    // arquivo, vamos avisar
  ENDI
 ELSEIF tecl_p=K_ESC                      // cancelou
  EXIT
 ELSEIF tecl_p=K_F8 .OR. tecl_p=K_TAB     // troca de janela so
  IF LEN(sistema[op_sis,O_DBRELA])>0.OR.; // se tem dbfs relacionados
     LEN(sistema[op_sis,O_CPRELA])>0
   pai_sis=PEGAPAI(op_sis)                // "pai" do arquivo
   ii=1
   IF tecl_p=K_F8                         // F8 monta menu de dbfs relacionados
    msg=SUBS(MENURELA(pai_sis),2)         // nome dos dbfs relacionados
    IF CONTA("|",msg)>0                   // mais de um dbf
     cod_sos=13
     ii=DBOX(msg,,3,E_MENU,,"ARQUIVOS")   // escolhe o arquivo
    ENDI
   ENDI
   IF ii>0
    IF tecl_p=K_TAB                       // TAB muda para proxima janela
     op_sis++
     DO WHILE op_sis<nss .AND. sistema[op_sis,O_OUTROS,O_NIVEL]>5
      op_sis++
     ENDD
     IF op_sis>nss .OR.;                  // se nao for filho volta
        PEGAPAI(op_sis)!=Pai_sis          // para o "pai de todos"
      op_sis=Pai_sis
     ENDI
    ELSE                                  // F8...
     IF CONTA("|",msg)>0                  // mais de um dbf relacionado
      op_sis=QUALRELA(pai_sis,ii,0)       // acha subscricao do dbf escolhido
     ELSE
      op_sis++
      DO WHILE op_sis<nss .AND. sistema[op_sis,O_OUTROS,O_NIVEL]>5
       op_sis++
      ENDD
      IF op_sis>nss .OR.;                 // se nao for filho volta
         PEGAPAI(op_sis)!=Pai_sis         // para o "pai de todos"
       op_sis=Pai_sis
      ENDI
     ENDI
    ENDI
   ENDI
   cr_="cr_"+ALIAS()
   or_="or_"+ALIAS()
   &cr_.=criterio
   &or_.=cpord
   pri_vez=.t.
   l_a=NIL
   LOOP
  ENDI
 ELSEIF tecl_p=K_F10                      // menu de opcoes
  op_edic=DBOX(msg_menu,2,67,E_MENU,,"MENU DE|EDI€ŽO",,,AT(op_edic,tbmenu))
  op_edic=SUBS(" "+tbmenu,op_edic+1,1)
 ELSE
  IF tecl_p>0
   op_edic=UPPER(CHR(tecl_p))             // converte tecla em letra
  ENDI
 ENDI
 IF AT(op_edic,"SA")=0 .AND. AT(op_edic,ALLTRIM(exrot[op_sis]))>0
  ALERTA()                                // se usuario nao tem permissao,
  DBOX(msg_auto,,,3)                      // beep, beep, beep
  LOOP                                    // exibe mensagem e
 ENDI                                     // volta ao menu
 ii=.f.
 IF LEN(sistema[op_sis,O_CPRELA])>0       // tem um "pai"....
  msg=LEFT(sistema[op_sis,O_CPRELA,1],AT("->",sistema[op_sis,O_CPRELA,1])-1)
  ii=(msg)->(EOF() .OR. BOF())            // o pai esta vazio!
  IF op_edic="D" .AND. (msg)->(DELE())    // nao deixa inclui se o "pai"
   ii=IF(ii,EVAL(qualsis,msg),op_sis)     // esta deletado
   msg="Registro excluido em "+ALLTRIM(sistema[ii,O_MENU])
   ALERTA()                               // 3 beeps
   DBOX(msg+", "+usuario)                 // para avisar
   LOOP                                   // e voltar...
  ENDI
 ENDI
 IF (EOF() .OR. BOF())                    // nao existe reg no arquivo
  IF (op_edic!="D" .OR. ii) .AND.;        // inibe todas as alternativas
     !EMPT(op_edic)                       // exceto a digitacao
   ii=IF(ii,EVAL(qualsis,msg),op_sis)
   msg="N„o h  registros em "+ALLTRIM(sistema[ii,O_MENU])
   ALERTA()                               // 3 beeps
   DBOX(msg+", "+usuario)                 // para avisar
   LOOP                                   // espera digitar outra tecla
  ENDI
 ENDI

 DO CASE
  CASE op_edic="P"                        // procura registro
   POSI()

  CASE op_edic="S"                        // registro seguinte
   SKIP                                   // as formulas se existirem
   IF EOF() .OR. &(INDEXKEY(0))!=IF(EMPT(criterio),"","T")+chv_1
    ALERTA(2)                             // encontrado o final do
    DBOX("* FINAL DO ARQUIVO *",15,,1)    // arquivo, da mensagem e
    FIM_ARQ()                             // posiciona no ultimo registro
   ENDI

  CASE op_edic="A"                        // registro anterior
   
   /*
      se inicio de arquivo ou, se ha filtro e nao atende, nao retrocede
      senao, retrocede um registro por vez
   */
   SKIP -1
   IF BOF().OR.&(INDEXKEY(0))!=IF(EMPT(criterio),"","T")+chv_1
    ALERTA(2)                             // encontrado o inicio do
    DBOX("* INICIO DO ARQUIVO *",15,,1)   // arquivo, da mensagem e
    INI_ARQ()                             // posiciona no primeiro registro
   ENDI

  CASE op_edic="M"                        // modifica registro
   IF !(EOF() .OR. BOF())                 // registro excluido, nao pode ser alterado

    #ifdef COM_REDE
     IF !BLOREG(3,.5)                     // se nao conseguiu bloquear o
      LOOP                                //  registro, volta ao menu
     ENDI
    #endi

    IF DELE()                             // registro esta escluido
     ALERTA()                             // vamos avisar
     DBOX("REGISTRO EXCLU¡DO",12,,1)

     #ifdef COM_MOUSE
      novapos=.f.                         // cancela clique do mouse no campo
     #endi

    ELSE
     IF CONFALT()                         // se o reg pode ser alterado
      &prget1.(FORM_INVERSA)              // processamento inverso, se houver
      INFOSIS(.t.)                        // exibe informacao no rodape' da tela
      &prget1.(INCLUI)                    // modif reg, com process dir, se houver
     ENDI

     #ifdef COM_MOUSE
      novapos=.f.                         // cancela clique do mouse no campo
     #endi

    ENDI

    #ifdef COM_REDE
     UNLOCK                               // libera registro
    #endi

    REGINICIO()                           // verifica se reg esta' no filtro
   ENDI

  CASE op_edic="D" .OR. op_edic="C"       // Inclusao de registros
   ord_dbf:=INDEXORD()                 // sava indice atual para incluirmos
   DBSETORDER(1)                       // inclusao sempre pelo indice 1
   IF op_edic="D" .OR. EOF() .OR. BOF()   // inclusao ou nao tem reg no dbf
    &PrIncl.()                            // chama programa de inclusao
   ELSE                                   // senao,
    &PrIncl.(RECNO())                     // chama programa de inclusao com repeticao
   ENDI
   DBSETORDER(ord_dbf)                    // retorna ao indice da consulta
   REGINICIO()                            // verifica se reg esta' no filtro

  CASE op_edic="E"                        // marca para exclusao

   #ifdef COM_REDE
    IF !BLOREG(3,.5)                      // se nao bloqueou o registro
     LOOP                                 // volta ao menu
    ENDI
   #endi

   IF !DELE()                             // ja esta excluido?
    IF CONFEXCL()                         // pede para confirmar
     &prget1.(EXCLUI)                     // exclui e processo inverso
    ENDI
   ENDI

   #ifdef COM_REDE
    UNLOCK                                // libera registro
   #endi

   DO WHILE !EOF() .AND. DELE() .AND.;    // acha o proximo
      SET(_SET_DELETED)                   // registro que nao
    SKIP                                  // esta excluido
   ENDD
   IF EOF() .OR. &(INDEXKEY(0))!=IF(EMPT(criterio),"","T")+chv_1
    FIM_ARQ()                             // forca eof()
   ENDI

  CASE op_edic="R"                        // recupera registro marcado

   #ifdef COM_REDE
    IF !BLOREG(3,.5)                      // tenta bloquear o registro
     LOOP
    ENDI
   #endi

   IF DELE()                              // o registro esta excluido?
    IF !EMPT(sistema[op_sis,O_CONDREC,1]) // se tem condicao de
     IF !&(sistema[op_sis,O_CONDREC,1])   // recuperacao e se esse
      ALERTA(2)                           // reg nao pode ser
      msg=sistema[op_sis,O_CONDREC,2]     // avisa o motivo
      DBOX(msg,,,,,"ATEN€ŽO!|IMPOSS¡VEL RECUPERAR")
      LOOP                                // e retorna
     ENDI
    ENDI
    &prget1.(RECUPERA)                    // recupera/processo direto, se houver
   ENDI

   #ifdef COM_REDE
    UNLOCK                                // libera o registro
   #endi


  CASE op_edic="F"
   FILTRA(.t.,.t.)                        // filtra (indexando, ordenando)

  CASE op_edic="O"                        // ordena o arquivo
   cpord=""                               // inicializa variavel
   CLASS(.t.)                             // escolhe ordenacao

  CASE op_edic="G"                        // processamento global
   ultreg=RECN()                          // salva registro
   GLOBAL()                               // prepara o processamento
   GO ultreg                              // retorna ao registro anterior
   REGINICIO()                            // verifica se reg esta' no filtro

 ENDC

 #ifdef COM_REDE
  IF op_edic!="S" .AND. op_edic!="A"
   COMMIT                                 // descarrega buffers
   GO RECNO()                             // ajusta ponteiro
  ENDI
 #endi

 DISPBEGIN()
 IF LEN(sistema[op_sis,O_DBRELA])>0
  IMPRELA()
 ENDI
 EVAL(prgets)                             // mostra registro que atende condicao
 INFOSIS(.f.)                             // exibe informacao no rodape' da tela
 DISPEND()
ENDD
criterio:=cpord := ""                     // reinicializa ordenacao e filtragem
SETKEY(K_CTRL_W,t_w)                      // restaura teclas de controle
SETKEY(K_CTRL_R,t_r)
SETKEY(K_CTRL_C,t_c)
RETU

PROC REGINICIO()   // posiciona no 1 reg do filtro
IF &(INDEXKEY(0))!=IF(EMPT(criterio),"","T")+chv_1 // esta fora do filtro/relacao
 INI_ARQ()                                         // forca inicio do arquivo
ENDI
RETU

PROC INI_ARQ()   // inicio do arquivo
LOCAL ch_:=IF(EMPTY(criterio),"","T")+; // monta expressao para achar
           IF(EMPTY(chv_rela),"",chv_1) // 1o. registro do filtro/relacao
IF EMPTY(ch_) .AND. EMPTY(chv_rela)     // nao tem filtro/relacao
 GO TOP                                 // vai para o 1o. reg do arquivo
ELSE                                    // senao,
 SEEK ch_                               // acha o 1o. que atenda a expressao
ENDI
RETU

PROC FIM_ARQ()   // final do arquivo
LOCAL cr_:=IF(EMPT(criterio),"","T")
IF EMPTY(chv_2) .AND. EMPTY(chv_rela)   // se nao estiver relacionado vai
 GO BOTT                                // para o ultimo reg do arquivo
ELSE                                    // caso contrario,
 SET SOFTSEEK ON                        // procura o ultimo registro
 SEEK cr_+chv_2                         // da relacao
 SET SOFTSEEK OFF                       // (desliga index mais proximo)
 SKIP -1                                // volta para dentro da relacao
 IF &(INDEXKEY(0))!=cr_+chv_1           // reg esta fora do filtro ou da
  GO BOTT                               // relacao, vai para o fimal
  SKIP                                  // do arquivo real
 ENDI
ENDI
RETU

PROC POSIPAI   // relaicona o "filho" com seus "pais"
LOCAL op_sy_, p_, i, ar_db:=ALIAS(), dbf_pais:=""
PRIV  db_, chv_rela
op_sy_=op_sis                               // subscricao do arquivo atual
DO WHILE LEN(sistema[op_sy_,O_CPRELA])>0    // se existir um pai...
 chv_rela=""
 p_=AT("->",sistema[op_sy_,O_CPRELA,1])+2   // separador de arquivo->campo
 db_=LEFT(sistema[op_sy_,O_CPRELA,1],p_-3)  // pega o nome do pai e a
 dbf_pais="|"+db_+dbf_pais                  // todos os pais
 FOR i=1 TO LEN(sistema[op_sy_,O_CPRELA])   // chave de ligacao
  chv_rela+=TRANSCAMPO(.t.,SUBS(sistema[op_sy_,O_CPRELA,i],p_),i)
 NEXT
 PTAB(chv_rela,db_,1)                       // abre/relaciona o pai
 op_sy_=EVAL(qualsis,db_)                   // sera que tem avo?...
ENDD
dbf_pais=SUBS(dbf_pais,2)                   // ajusta var com nome dos pais
DO WHILE LEN(dbf_pais)>0                    // tem mais uma pai?
 db_=PARSE(@dbf_pais,"|")                   // separa o nome deste
 SELE (db_)                                 // seleciona sua area
 db_=LEFT(db_,3)+"_get1"                    // e chama o programa xxx_get1
 &db_.(POSICIONA)                           // para abrir os arquivos
ENDD                                        // relacionados atraves de PTAB()
SELE (ar_db)                                // restabelece a area do dbf
RETU

PROC IMP_FORM(f_)  // imprime formula na tela
LOCAL l_, c_
IF VALTYPE(f_[O_LINHA])="B"  // a linhas esta variando (scroll)
 l_=l_s+EVAL(f_[O_LINHA])    // acha a nova posicao
ELSE
 l_=l_s+f_[O_LINHA]          // a linha e fixa na tela
ENDI
c_=c_s+f_[O_COLUNA]          // coluna
@ l_,c_ SAY &(f_[O_FORM])    // exibe formula
RETU

PROC PEGACHV2()  // inicializa chv_1 e chv_2
IF !EMPTY(chv_rela)                   // se existe alguma relacao
 chv_1 = &chv_rela.                   // chv_1 contera a chave da relacao
 chv_2 = LEFT(chv_1,LEN(chv_1)-1)+;   // chv_2 sera o mais proximo
         CHR(ASC(RIGHT(chv_1,1))+1)   // de chv_1
ELSE                                  // se nao existe relacao
 chv_1:=chv_2 := ""                   // inicializa vaiaveis
ENDI
RETU

PROC GLOBAL    // Processamento global de registros

/*
   dentro desta rotina, o usuario pode definir, em tempo de execucao,
   processamentos para alterar campos do arquivo. Nos comentarios a seguir
   nao confundir estes com os processamentos definidos em tempo de projeto
   da aplicacao, os quais sao aqui chamados de formulas direta e inversa
*/
LOCAL c_ampo:={}, exp_r:={}, cf_, a_ok, i:=0, getlist:={}, chv_x:="",;
      t_glob:=SAVESCREEN(0,0,MAXROW(),79), m_campos:="", dele_atu:=SET(_SET_DELETED)
PRIV cod_sos:=19

#ifdef COM_REDE
 IF !BLOARQ(3,.5)                                     // tenta bloquear o arquivo
  RETU                                                // se nao conseguiu, volta
 ENDI
#endi

ALERTA()
msg="Continuar processamento global|Cancelar a opera‡„o"
msgt=IF(EMPTY(criterio),"TODOS OS REGISTROS DO ARQUIVO!!!",;
        "SOMENTE OS REGISTROS FILTRADOS")
op=DBOX(msg,,,E_MENU,,"ATEN€ŽO, "+usuario+;           // aviso importante!
        "!|ESTA ROTINA ATINGIR|"+msgt+;
        "| ACONSELHAVEL FAZER 'BACKUP` ANTES!")
IF op!=1
 RETU                                                 // cancelou
ENDI
FOR i=1 TO FCOU()                                     // enche m_campos com os titulos
 IF !("I"==sistema[op_sis,O_CAMPO,i,O_CRIT])          // dos nomes dos campos do dbf
  m_campos+="|"+sistema[op_sis,O_CAMPO,i,O_TITU]      // excetos campos invisiveis
 ENDI
NEXT
m_campos=SUBS(m_campos,2)
op_o=1
msg="APAGA determinados registros|RECUPERA determinados registros|"+;
    "MODIFICA campos de determinados registros"
op_o=DBOX(msg,,,E_MENU,,"PROCESSAMENTO GLOBAL")       // menu dos processamentos
IF op_o>0
 IF op_o=3                                            // alteracao de campos
  DO WHIL LEN(c_ampo)<=FCOU()
   msg="PROCESSAMENTO GLOBAL|ESCOLHA O CAMPO PARA SER ALTERADO"
   op_1=DBOX(m_campos,,,E_MENU,,msg)
   IF op_1!=0
    ii=0
    FOR i=1 TO FCOU()                                 // acha campo escolhido
     IF !("I"==sistema[op_sis,O_CAMPO,i,O_CRIT])
      ii++                                            // desprezando campos
     ENDI                                             // invisiveis
     IF ii=op_1                                       // campo escolhido?
      cp_=FIEL(i)                                     // nome do campo
      msg=sistema[op_sis,O_CAMPO,i,O_CRIT]            // critica do campo
      EXIT
     ENDI
    NEXT
    IF TYPE(cp_)="M".OR.UPPER(cp_)$UPPE(INDEXKEY(1)); // nega processamento em campos
       .OR. msg=="V" .OR. msg=="I"                    // memo, nao editavel, invisivel
     msg="N„o permitido alterar campo|"+;             // ou que seja parte da chave
         "MEMO, INVIS¡VEL, NŽO EDITVEL ou CHAVE"
     ALERTA(3)
     DBOX(msg,,,3,,"ATEN€ŽO! "+usuario)
     LOOP
    ENDI
    IF ASCAN(c_ampo,cp_)>0                            // campo ja' tem um
     ALERTA(3)                                        // processamento definido
     DBOX("Campo j  foi selecionado",,,3,,"ATEN€ŽO! "+usuario)
     LOOP
    ENDI
    expg=SPAC(254)
    msg="A EXPRESSŽO ABAIXO DEVER OBEDECER A SINTAXE DA LINGUAGEM|*|"+;
        "F10=CAMPOS DO ARQUIVO|*|"+;
        "(Usar 'aspas' em constantes do tipo caracter)|*|"+;
        "Substituir "+cp_+" com"
    DO WHILE .t.
     SET KEY K_F10 TO ve_campos                       // f10 ve campos
     msgt="ALTERA€ŽO DE CAMPO"
     expg=DBOX(msg,,,,,msgt,expg,"@S54")              // capta processamento
     SET KEY K_F10 TO
     IF LASTKEY()=K_ESC                               // cancelou
      expg=""
     ELSEIF !CRIT("TYPE(expg)==TYPE(cp_)~"+;          // verifica se a expressao
                  "Express„o ilegal!",15)             // e do mesmo tipo do campo
      LOOP                                            // se nao for, sobe
     ENDI
     EXIT
    ENDD
    IF !EMPT(expg)                                    // se nao cancelou,
     AADD(c_ampo,cp_)                                 // coloca o campo e a
     AADD(exp_r,ALLTRIM(expg))                        // a expressao nos arranjos
    ENDI
   ELSE
    EXIT                                              // saindo...
   ENDI
  ENDD
 ENDI
 IF LEN(c_ampo)>0 .OR. op_o!=3                        // existe processo
  msg="Apaga   RecuperaAltera"                        // mglob=nome do processo
  mglob=TRIM(SUBS(msg,op_o*8-7,8))                    // que foi escolhido
  ALERTA(2)
  op_g=2
  msg="Confirma a cada registro|"+mglob+" sem confirmar"
  op_g=DBOX(msg,,,E_MENU,,UPPER(mglob))               // confirmar ou nao?
  IF op_g=0

   #ifdef COM_REDE
    UNLOCK                                            // desbloqueia o arquivo
   #endi

   RETU
  ELSE
   cf_=(op_g=1)                                       // cf_=.t., tem confirmacao
   op_a=2
   IF (op_o=1 .AND. !EMPT(sistema[op_sis,O_CONDEXC,1])) .OR. (op_o=3 .AND. !EMPT(sistema[op_sis,O_CONDALT,1])) .OR.  (op_o=2 .AND. !EMPT(sistema[op_sis,O_CONDREC,1]))
    ALERTA()
    msg="Obedecer condi‡”es|Ignorar condi‡”es"
    msgt="|EXISTEM CONDI€™ES ESPECIAIS|PARA ATUALIZACAO DESTE ARQUIVO"
    op_a=DBOX(msg,,,E_MENU,,"ATEN€ŽO, "+usuario+msgt)
    IF op_a=0

     #ifdef COM_REDE
      UNLOCK                                       // libera o registro
     #endi

     RETU
    ENDI
   ENDI
   getsx=LEFT(ALIAS(),3)+"_gets"
   get1x=LEFT(ALIAS(),3)+"_get1"
   SET DELE OFF                                       // excluidos ser„o vistos
   IF !cf_                                            // nao confirmado
    DBOX("Aguarde! ESC cancela",,,,NAO_APAGA)
   ELSEIF brw                                         // se veio da EDITA()
    CBC1()
   ENDI
   INI_ARQ()                                          // posiciona no inicio do arquivo
   DO WHIL !EOF() .AND. IN_KEY()!=K_ESC               // correndo o arquivo

    IF cf_                                            // se metodo confirmado
     DISPBEGIN()
     IF LEN(sistema[op_sis,O_DBRELA])>0
      IMPRELA()
     ENDI
     &getsx.()                                        // conteudo do registro
     DISPEND()
     ALERTA(1)                                        // beep!
     msg=mglob+"|N„o "+mglob+"|Cessa confirma‡„o|Cancela"
     op_g=DBOX(msg,0,2,E_MENU,,,,"SELECIONE",2)       // oferece confirmacao
     IF op_g=0 .OR. op_g=4                            // cancelou
      EXIT
     ENDI
     a_ok=(op_g!=2)                                   // a_ok=.t., pode processar!
     cf_=(op_g!=3)                                    // se cf_=.t., quer continuar
     IF !cf_                                          // confirmando os processos
      DBOX("Aguarde!  ESC cancela",,,,NAO_APAGA)
     ENDI
    ELSE                                              // metodo nao confirmado,
     a_ok=.t.
    ENDI
    IF op_o=1 .AND. op_a=1 .AND. a_ok                 // existe e quer testar
     a_ok=&(sistema[op_sis,O_CONDEXC,1])              // condicao de exclusao
    ENDI
    IF op_o=2 .AND. op_a=1 .AND. a_ok                 // existe e quer testar
     a_ok=&(sistema[op_sis,O_CONDREC,1])              // condicao de recuperacao
    ENDI
    IF op_o=3 .AND. op_a=1 .AND. a_ok                 // existe e quer testar
     a_ok=&(sistema[op_sis,O_CONDALT,1])              // condicao de alteracao
    ENDI
    IF a_ok                                           // vamos fazer o processo global

     IF op_o=1                                        // excluindo
      IF !DELE()                                      // (so se nao apagado)
       &get1x.(EXCLUI)                                // executa formula inversa,
      ENDI                                            // se existir e marca para apagar

     ELSEIF op_o=2                                    // recuperando
      IF DELE()                                       // (so os marcados)
       &get1x.(RECUPERA)                              // executa formula direta e
      ENDI                                            // desmarca o apagamento

     ELSEIF !DELE()                                   // alterando campos
      &get1x.(FORM_INVERSA)                           // executa formula inversa
      SKIP                                            // vamos salvar o prox registro
      proxreg=IF(EOF(),-1,RECN())                     // se estivermos alterando campo do
      SKIP -1                                         // componente do filtro ou ordenacao
      FOR i=1 TO LEN(c_ampo)                          // modifica os campos
       REPL &(c_ampo[i]) WITH &(exp_r[i])             // que foram escolhidos
      NEXT
      &get1x.(FORM_DIRETA)                            // executa a formula direta
      IF proxreg>0                                    // se nao for final do arquivo,
       GO proxreg                                     // reposiciona no proximo
       SKIP -1                                        // registro a ser alterado
      ELSE                                            // senao,
       GO BOTT                                        // forca fim do arquivo
      ENDI
     ENDI

    ENDI
    SKIP                                              // o proximo por favor...
    IF &(INDEXKEY(0))!=IF(EMPT(criterio),"","T")+chv_1 // esta fora do filtro ou relacao
     EXIT                                             // acabou o processo global
    ENDI
   ENDD
   RESTSCREEN(0,0,MAXROW(),79,t_glob)                 // restaura tela
  ENDI
 ENDI
ENDI

#ifdef COM_REDE
 UNLOCK                                               // libera arquivo
#endi

SET(_SET_DELETED,dele_atu)                            // retorna visibilidade
RETU

PROC SUBNIVEL(db_item)   // Inclus„o em arquivos subordinados
LOCAL ar_db, ultreg
PRIV op_sis, cod_sos
ultreg=RECN()                                         // salva registro atual e
ar_db=ALIAS()                                         // o nome do arquivo aberto
op_sis=EVAL(qualsis,db_item)

#ifdef COM_REDE
 IF !USEARQ(sistema[op_sis,O_ARQUI,O_NOME],.f.,20,1)  // se nao abriu arquivo, volta
  RETU
 ENDI
#else
 USEARQ(sistema[op_sis,O_ARQUI,O_NOME])               // abre DBF/NTX
#endi

IF op_menu=INCLUSAO
 EVAL(&("{||"+LEFT(db_item,3)+"_incl()}"))
ELSE
 EDIT()
ENDI
IF !EMPTY(ar_db)                                      // se havia arquivo aberto,
 SELE (ar_db)                                         //  seleciona-o e tambem
 GO ultreg                                            //  retorna ao registro
ELSE                                                  // senao,
 SELE 0                                               //  seleciona proxima area livre
ENDI
RETU .t.

PROC INTREF(oq_fazer) // Manipula integridade refencial de arquivos subordinados
LOCA statusdele, db_f:=ALIAS(), op_sy_:=EVAL(qualsis,ALIAS()),;
     chv_:=&(INDEXKEY(1)), i_, ind_ord, reg_
PRIV op_sis
statusdele=SET(_SET_DELETED,.f.)                 // reg excluidos serao vistos
FOR i_=1 TO LEN(sistema[op_sy_,O_DBRELA])        // para cada "filho" do arquivo
 op_sis=EVAL(qualsis,sistema[op_sy_,O_DBRELA,i_])// subscricao do vetor Sistema

 #ifdef COM_REDE
  IF !USEARQ(sistema[op_sis,O_ARQUI,O_NOME],.f.,20,1) // se nao abriu arquivo,
   RETU                                          // volta
  ENDI
 #else
  USEARQ(sistema[op_sis,O_ARQUI,O_NOME])         // abre DBF/NTX
 #endi

 ind_ord=INDEXORD()                              // sava indice atual
 DBSETORDER(1)                                   // seta indice principal
 reg_=RECNO()                                    // registro atual
 SEEK chv_                                       // acha o 1o. da relacao
 DO WHILE &(INDEXKEY(1))=chv_
  IF (oq_fazer=FORM_INVERSA .AND. !DELE()) .OR.; // para cada registro que
     (oq_fazer=FORM_DIRETA .AND. flag_excl!="*") // atende a relacao...

   #ifdef COM_REDE
    BLOREG(0,.5)                                 // bloqueia o registro
   #endi

   EVAL(&("{|o|"+LEFT(ALIAS(),3)+;
          "_get1(o,.t.)}"),oq_fazer)             // exclui ou recupera o registro

   #ifdef COM_REDE
    UNLOCK                                       // libera o registro
   #endi

  ENDI
  SKIP                                           // proximo...
 ENDD
 DBSETORDER(ind_ord)                             // volta ao indice em uso e
 GO reg_                                         // ao registro atual
NEXT
SET(_SET_DELETED,statusdele)                     // retaura o status do SET DELE
SELE (db_f)
RETU

PROC VE_REL()  // ve relatorio gravado em disco
PRIV cod_sos, cur_sor:=SETCURSOR(3)  // salva cursor/acende
SAVE SCREEN                          // salva tela
arq_=ARQGER()                        // pega nome do arquivo
IF !EMPTY(arq_)                      // se cancelou ou nao informou
 cod_sos=1
 BROWSE_REL(arq_,2,3,MAXROW()-2,78)  // mostra o arquivo gravado
ENDI
REST SCREEN                          // restaura a tela
SETCURSOR(cur_sor)                   // restabelece o cursor
RETU

PROC HELP    // Apresenta ajuda on-line
LOCAL tela_, txt, ctr, t, cor_, qdlin_, linf_, estr_db, pg_up, pg_dn,;
      tec_f3, tec_f4, tec_f9, tec_f8
SETKEY(K_F1,NIL)                                     // evita recursividade
pg_up =SETKEY(K_PGUP,NIL)                            // desabilita PgUp,
pg_dn =SETKEY(K_PGDN,NIL)                            // PgDn,
tec_f3=SETKEY(K_F3,NIL)                              // F3,
tec_f4=SETKEY(K_F4,NIL)                              // F4,
tec_f9=SETKEY(K_F9,NIL)                              // F9 e
tec_f8=SETKEY(K_ALT_F8,NIL)                          // ALT-F8
tela_=SAVESCREEN(0,0,MAXROW(),79)                    // salva a tela por baixo e
cor_=SETCOLOR(drvtithlp)                             // o esquema de cor vigente
IF !FILE(arq_sos)                                    // nao ha texto de ajuda...
 ALERTA()                                            // beep beep beep
 DBOX("O arquivo "+arq_sos+"|contendo o texto de "+;
      "ajuda|n„o foi encontrado",,,2,,"ATEN€ŽO,"+;   // avisa!
      usuario)
ELSE
 txt=LEMANU(arq_sos,cod_sos)                         // pega bloco de ajuda
 qdlin_=MLCOUNT(txt,56)                              // qde linhas
 maxlt_ =MAXROW()
 linf_ =IF(qdlin_>maxlt_-7,maxlt_-3,qdlin_+3)        // calcula linha inferior
 CAIXA(mold,2,10,linf_,69,392)                       // monta janela
 ctr=IF(qdlin_>maxlt_-6," "+CHR(K_CTRL_X)+" "+;      // monta teclas de controle
        CHR(K_CTRL_Y)+" PgUp PgDn","")+" ESC "       // disponiveis na janela
 @ linf_,(80-LEN(ctr))/2 SAY ctr                     // mostra teclas de controle
 SETCOLOR(drvcorhlp)

 #ifdef COM_TUTOR
  MEMOEDIT(txt,3,12,linf_-1,68,.f.,"mHelp")          // mostra o bloco de ajuda
 #else
  MEMOEDIT(txt,3,12,linf_-1,68,.f.)                  // mostra o bloco de ajuda
 #endi

ENDI
SETCOLOR(cor_)
RESTSCREEN(0,0,MAXROW(),79,tela_)
SETKEY(K_PGUP,pg_up)                                 // habilita teclas PgUp,
SETKEY(K_PGDN,pg_dn)                                 // PgDn,
SETKEY(K_F3,tec_f3)                                  // F3,
SETKEY(K_F4,tec_f4)                                  // F4,
SETKEY(K_F9,tec_f9)                                  // F9 e
SETKEY(K_ALT_F8,tec_f8)                              // ALT-F8
SET KEY K_F1 TO help                                 // habilita F1
RETU


#ifdef COM_TUTOR
 PROC mHelp  // grava/le teclas do tutorial
 PRIV  t_:=LASTKEY()                        // tecla digitado no help
 IF acao_mac $ "Gg"                         // se esta gravando macro
  KEYB_MAC(MONTA_BUFF(t_))                  // joga no buffer do teclado
  Q_TEC(0)                                  // para gravar a tecla
 ELSEIF acao_mac $ "LAC" .AND. t_!=K_ESC    // se esta lendo
  KEYB_MAC(MONTA_BUFF(Q_TEC(0)))            // le a tecla e joga no buffer
 ENDI                                       // do teclado
 RETURN
#endi


PROC NADAFAZ  // desativa ^W/PgUp/PgDn em inclusao
RETU

PROC INFOSIS(ed_)  // coloca informacao no rodape' da tela
LOCAL co_r:=SETCOLOR(drvcorenf), MsgEsq, MsgCen, MsgDir, i_
ed_=IF(ed_=NIL,.f.,ed_)                           // flag - esta editando?
IF op_menu=INCLUSAO                               // teclas disponiveis na
 MsgEsq="Inclui"                                  // inclusao
 MsgCen="F3,F4,F9"
ELSEIF op_menu=ALTERACAO                          // teclas disponiveis na
 MsgEsq="Altera"                                  // alteracao
 MsgCen=""
 IF (LEN(sistema[op_sis,O_DBRELA]) > 0 .OR.;      // tem dbfs relacionados?
    LEN(sistema[op_sis,O_CPRELA]) > 0) .AND. !ed_
  MsgCen="F8,"
 ENDI
 MsgCen+="F9"+IF(ed_,"",",F10")
ELSE                                              // teclas disponiveis na
 MsgEsq="Ve Global"                               // ve global da func EDITA()
 MsgCen=gcr
ENDI

#ifdef COM_MOUSE
 IF drvmouse .AND. op_menu=ALTERACAO              // teclas do mouse
  MsgCen+=" "+CHR(27)+" "+CHR(26)
 ENDI
#endi

IF op_menu=INCLUSAO                               // flags de repeticao e
 MsgDir=IF(fgrep," Rep",SPAC(4))+;                // confirmacao na inclusao
        IF(drvconf," Conf",SPAC(5))
ELSEIF DELE() .AND. EMPTY(READVAR()) .AND. !ed_   // coloca msg de EXCLUIDO
 MsgDir=" EXCLUIDO"                               // se for o caso...
ELSE
 MsgDir=SPACE(9)
ENDI
i_=c_i-c_s-3-LEN(MsgEsq)-LEN(MsgDir)
IF i_ > 2                                         // se msg cabe natela
 MsgCen=PADC(MsgCen,i_)                           // centraliza msg
 IF RIGHT(MsgCen,1)=","                           // msg foi truncada
  MsgCen=" "+LEFT(MsgCen,LEN(MsgCen)-1)           // tira virgula do final
 ENDI                                             // se existir
 MsgCen=" "+MsgEsq+MsgCen+MsgDir+" "
ELSE
 MsgCen=LEFT(" "+MsgEsq+MsgDir+" ",c_i-c_s-1)     // msg cabe toda na tela
ENDI
@ l_i,c_s+1 SAY MsgCen
SETCOLOR(co_r)
RETU

PROC TIRA_LANC(db_,lan_,for_inv_)  // Retira o lancamento feito no arquivo alvo
LOCAL ar_:=ALIAS(), prg_:=LEFT(db_,3)+"_get1", in_:=1, ord_
for_inv_=IF(for_inv_=NIL,.t.,for_inv_)
IF !EMPTY(SELECT(db_))                       // se o arquiov ja esta aberto
 SELE (db_)                                  // salva a ordem do indice
 in_=INDEXORD()                              // atual
ENDI
ord_=LEN(sistema[EVAL(qualsis,db_),O_CHAVE]) // ultimo indice do dbf (ind lancamento)
IF PTAB(lan_,db_,ord_,.t.)                   // procura o 1o. que existe
 SELE (db_)
 WHILE !EOF() .AND. codlan=lan_              // para todos os registros do lancamento

  #ifdef COM_REDE
   BLOREG(0,.5)                              // bloqueia para sempre
  #endi

  IF for_inv_
   &prg_.(FORM_INVERSA)
  ELSE
   DELE
  ENDI

  #ifdef COM_REDE
   UNLOCK                                    // libera registro
  #endi

  SKIP                                       // proximo registro
 ENDD
ELSE
 SELE (db_)
ENDI
DBSETORDER(in_)                              // retorna p/ o indice atual
IF !EMPTY(ar_)
 SELE (ar_)
ELSE
 SELE 0
ENDI
RETU

PROC FAZ_LANC(db_,lan_,com_seq)  // realiza lancamentos em arquivos
LOCAL ar_:=ALIAS(), dbf_eof

#ifdef COM_REDE
 PRIV  s_cria, s_gera, s_grava, s_arqu
#else
 PRIV  s_gera, s_grava
#endi

com_seq:=IF(com_seq=NIL,.f.,com_seq)
SELE (db_)                        // seleciona dbf alvo do lancamento
dbf_eof = EOF()
IF com_seq                        // existe cp sequencial?

 #ifdef COM_REDE
  s_cria=LEFT(db_,3)+"_CRIA_SEQ"  // prg que cria XXX_seq.dbf
  s_arqu=LEFT(db_,3)+"_SEQ"       // nome arq sequencial
 #endi

 s_gera=LEFT(db_,3)+"_GERA_SEQ"   // prg que gera campo sequencial
 s_grava=LEFT(db_,3)+"_GRAVA_SEQ" // prg que grava campo no arquivo
 FOR i=1 TO FCOU()                // cria/declara privadas as
  msg=FIEL(i)                     // variaveis de memoria com
  PRIV &msg.                      // o mesmo nome dos campos
 NEXT                             // do arquivo
ENDI

#ifdef COM_REDE
 IF com_seq .AND. dbf_eof         // se o dbf tem campo sequencial
  &s_cria.()                      // e vai criar um registro novo
  SELE (db_)                      // cria/seleciona dbf de controle
  &s_gera.()                      // e gera os sequenciais...
 ELSE                             // caso contrario
  com_seq=.f.                     // desabilita cp sequencial
 ENDI
 DO WHIL .t.
  IF dbf_eof                      // se for final do arquivo
   APPE BLAN                      // cria um novo registro
  ELSE
   BLOREG(0,.5)                   // bloqueia o registro
  ENDI
  IF NETERR()                     // erro...
   DBOX(ms_uso,20)                // mensagem ao usuario
   LOOP                           // e tenta novamente
  ENDI
  EXIT
 ENDD
#else
 IF dbf_eof                       // e final de arquivo
  IF com_seq                      // se o dbf tem campo sequencial
   &s_gera.()                     // gera os campos...
  ENDI
  APPE BLAN                       // cria um novo registro
 ELSE
  com_seq=.f.
 ENDI
#endi

IF DELE()                         // registro excluido?
 RECA                             // recupera-o
ENDI
REPL codlan WITH lan_             // atualiza o codigo do lancamento
IF com_seq                        // tem sequencial entao
 &s_grava.()                      // grava no arquivo

 #ifdef COM_REDE
  SELE (s_arqu)
  UNLOCK                          // libera DBF para outros usuarios
  COMMIT                          // atualiza cps sequenciais no disco
 #endi

ENDI
IF !EMPTY(ar_)                    // se existia dbf aberto na area
 SELE (ar_)                       // inicial, vamos seleciona-los
ELSE                              // caso contrario
 SELE 0                           // pega a primeira area livre
ENDI
RETU

PROC MASENHA(lin_menu,col_menu) // manutencao de senhas
PRIV op_sis, tela_fundo:=SAVESCREEN(0,0,MAXROW(),79)
IF nivelop<3                             // so pode trocar a senha
 TROCASENHA(.f.,usuario)                 // vamos trocar
 RETU
ENDI
op_sis=nss-2                             // gerente pode tudo
cn:=fgrep :=.f.
criterio=""
SELE A                                   // abre dbf de acesos da senhas

#ifdef COM_REDE
 IF !USEARQ(sistema[op_sis+1,O_ARQUI,O_NOME],.f.,20,1)
  RETU                                   // nao abriu... volta ao menu anterior
 ENDI
#else
 USEARQ(sistema[op_sis+1,O_ARQUI,O_NOME])
#endi

#ifdef COM_REDE
 IF !USEARQ(sistema[op_sis,O_ARQUI,O_NOME],.f.,20,1) // abre arq de grupos de senhas
  RETU                                   // falhou... cai fora
 ENDI
#else
 USEARQ(sistema[op_sis,O_ARQUI,O_NOME])
#endi

op_menu=ALTERACAO                        // vamos colocar em modo de alteracao
cod_sos=17
EDIT()                                   // altera dados da senhas
CLOS ALL                                 // fecha todos arquivos abertos
RETU

PROC PWG_incl(reg_cop)  // inclusao no arquivo PWGRUPOS (grupos)
LOCAL getlist:={},cabem:=1,rep:=ARRAY(FCOU()),ult_reg:=RECN(),dbfseq_,;
      ctl_r, ctl_c, ctl_w, t_f3_, t_f4_
PRIV op_menu:=INCLUSAO, sq_atual_, tem_borda, criterio:="", cpord:=""
FOR i=1 TO FCOU()                        // cria/declara privadas as
 msg=FIEL(i)                             // variaveis de memoria com
 PRIV &msg.                              // o mesmo nome dos campos
NEXT                                     // do arquivo
IF reg_cop!=NIL                          // quer repetir todo o reg atual
 FOR i=1 TO FCOU()                       // para cada campo,
  msg=FIEL(i)                            // salva o conteudo
  rep[i]=&msg.                           // para repetir
 NEXT
ELSE
 AFILL(rep,"")                           // eche com valor vazio
ENDI
t_f3_=SETKEY(K_F3,{||rep()})             // repeticao reg anterior
t_f4_=SETKEY(K_F4,{||conf()})            // confirma campos com ENTER
ctl_w=SETKEY(K_CTRL_W,{||nadafaz()})     // enganando o CA-Clipper...
ctl_c=SETKEY(K_CTRL_C,{||nadafaz()})
ctl_r=SETKEY(K_CTRL_R,{||nadafaz()})

DO WHIL cabem>0
 rola_t=.f.                              // flag se quer rolar a tela
 SELE PWGRUPOS
 M->pw_grupo="0001"                      // procura proximo numero do grupo
 GO TOP
 DO WHILE !EOF()                         // corre todo dbf e ve qual o valor do maior grupo
  IF VAL(DECRIPT(pw_grupo))>=VAL(M->pw_grupo)
   M->pw_grupo=LPAD(STR(VAL(DECRIPT(pw_grupo))+1),4,[0])
  ENDI
  SKIP                                   // proximo...
 ENDD
 
 /*
    cria variaveis de memoria identicas as de arquivo, para inclusao
    de registros
 */
 FOR i=2 TO FCOU()
  msg=FIEL(i)
  M->&msg.=IF((fgrep .OR. reg_cop!=NIL).AND.!EMPT(rep[1]),DECRIPT(rep[i]),&msg.)
 NEXT
 DISPBEGIN()                             // vamos apresentar a tela de uma vez so
 PWG_GETS()                              // mostra o grupo
 IMPRELA()                               // imprime telas dos filhos
 PWG_TELA()                              // tela do grupo
 INFOSIS(.t.)                            // exibe informacao no rodape' da tela
 DISPEND()                               // mostra a tela agora...

 cabem=DISKSPACE(;                       // da para incluir mais...
          IF(;
             LEN(sistema[op_sis,O_ARQUI,O_DIR_DBF])<2.OR.sistema[op_sis,O_ARQUI,O_DIR_DBF]="\",;
             0,;
             ASC(sistema[op_sis,O_ARQUI,O_DIR_DBF])-64;
          );
       )
 cabem=INT((cabem-2048)/PWGRUPOS->(RECSIZE()))
 IF cabem<1                              // mais nenhum!!!
  ALERTA()
  msg="Verifique ESPA€O EM DISCO, "+usuario
  DBOX(msg,,,,,"INCLUSŽO INTERROMPIDA!") // vamos parar por aqui!
  EXIT
 ENDI
 SELE 0                                  // torna visiveis variaveis de memoria
 PWG_GET1(INCLUI)                        // recebe campos
 SELE PWGRUPOS
 IF LASTKEY()=K_ESC                      // se cancelou
  cabem=0                                // prepara saida da inclusao
  LOOP
 ENDI

 #ifdef COM_REDE
  GO BOTT                                // vamos bloquear o final do
  SKIP                                   // arq para que nehum outro
  BLOREG(0,.5)                           // usuario possa incluir
 #endi

 APPEND BLANK                            // inclui reg em branco no dbf
 FOR i=1 TO FCOU()                       // para cada campo,
  msg=FIEL(i)                            // salva o conteudo
  rep[i]=M->&msg.                        // para repetir
  REPL &msg. WITH rep[i]                 // enche o campo do arquivo
 NEXT
 ult_reg=RECN()                          // ultimo registro digitado
 SELE PWTABELA
 FOR i=1 TO nss-3                        // inclui todos os dbf no arq de acessos

  #ifdef COM_REDE
   GO BOTT                               // vamos bloquear o final do
   SKIP                                  // arq para que nehum outro
   BLOREG(0,.5)                          // usuario possa incluir
  #endi

  APPEND BLANK                           // inclui reg em branco no dbf de acessos
  REPL pw_grupo WITH M->pw_grupo,;       // enche com o codigo do grupo
       pw_dbf WITH sistema[i,O_MENU]     // titulo do dbf
  REPL pw_dbf WITH ENCRIPT(pw_dbf),;
       pw_permis WITH ENCRIPT(pw_permis) // e as permissoes (todas)
 NEXT

 #ifdef COM_REDE
  UNLOCK                                 // libera o registro e
  COMMIT                                 // forca gravacao
 #else
  IF RECC()-INT(RECC()/20)*20=0          // a cada 20 registros
   COMMIT                                // digitados forca gravacao
  ENDI
 #endi

 SUBNIVEL("PWTABELA")                    // coloca permissoes nas tabelas
 SUBNIVEL("PWUSUA")                      // cadastra os usuarios no gupo
 IF reg_cop!=NIL                         // estava na consulta e quis rep o campo
  EXIT                                   // cai fora...
 ENDI
ENDD

GO ult_reg                               // move para o ultimo reg digitado
SETKEY(K_F3,t_f3_)                       // restaura teclas de funcoes
SETKEY(K_F4,t_f4_)
SETKEY(K_CTRL_W,ctl_w)
SETKEY(K_CTRL_C,ctl_c)
SETKEY(K_CTRL_R,ctl_r)
RETU

PROC PWG_tela     // tela do arquivo PWGRUPOS
tem_borda=.t.
l_s=Sistema[op_sis,O_TELA,O_LS]        // coordenadas da tela
c_s=Sistema[op_sis,O_TELA,O_CS]
l_i=Sistema[op_sis,O_TELA,O_LI]
c_i=Sistema[op_sis,O_TELA,O_CI]
SETCOLOR(drvtittel)
vr_memo=NOVAPOSI(@l_s,@c_s,@l_i,@c_i)  // pega posicao atual da tela
CAIXA(mold,l_s,c_s,l_i,c_i)            // monta caixa da tela
i=LEN(sistema[op_sis,O_MENS])/2
@ l_s,c_s-1+(c_i-c_s+1)/2-i SAY " "+MAIUSC(sistema[op_sis,O_MENS])+" "
SETCOLOR(drvcortel)
@ l_s+01,c_s+1 SAY "     C¢digo:              Nome:"
RETU

PROC PWG_gets     // mostra variaveis do arquivo PWGRUPOS
LOCAL getlist := {}
PRIV _grupo, _nogrupo
PWG_TELA()
SETCOLOR(drvcortel+","+drvcorget+",,,"+corcampo)
IF EMPTY(pw_grupo)              // se nao esta encriptado
 _grupo=pw_grupo                // aproveita o que esta no arquivo
 _nogrupo=pw_nogrupo
ELSE                            // esta encriptado
 _grupo=DECRIPT(pw_grupo)       // desencripta antes de mostrar
 _nogrupo=DECRIPT(pw_nogrupo)
ENDI
@ l_s+01 ,c_s+15 GET  _grupo;
                 PICT sistema[op_sis,O_CAMPO,01,O_MASC]

@ l_s+01 ,c_s+33 GET  _nogrupo;
                 PICT sistema[op_sis,O_CAMPO,02,O_MASC]

CLEAR GETS
RETU

PROC PWG_get1(tp_mov)     // capta variaveis do arquivo PWGRUPOS
LOCAL getlist := {}
PRIV _grupo, _nogrupo
IF tp_mov=INCLUI                  // esta incluindo ou alterando
 DO WHILE .t.
  rola_t=.f.
  SET KEY K_ALT_F8 TO ROLATELA    // permite mudar posicao da tela
  SETCOLOR(drvcortel+","+drvcorget+",,,"+corcampo)
  IF op_menu=ALTERACAO            // se esta alterando
   _grupo=DECRIPT(pw_grupo)       // desencripta o que esta no dbf
   _nogrupo=DECRIPT(pw_nogrupo)
  ELSE                            // esta incluindo
   _grupo=M->pw_grupo             // pega variaveis de memoria
   _nogrupo=M->pw_nogrupo         // ja desencriptadas
  ENDI
  @ l_s+01 ,c_s+15 GET _grupo;    // mostra codigo do grupo
                   PICT sistema[op_sis,O_CAMPO,01,O_MASC]
  CLEA GETS
  @ l_s+01 ,c_s+33 GET  _nogrupo; // recebe nome do grupo
                   PICT sistema[op_sis,O_CAMPO,02,O_MASC]
                   DEFINICAO 2

  READ
  SET KEY K_ALT_F8 TO             // desabilita alt+f8
  IF rola_t                       // quer rolar a tela
   ROLATELA()                     // entao deixa
   LOOP                           // volta para digiracao
  ENDI
  IF LASTKEY()!=K_ESC .AND. drvincl .AND. op_menu=INCLUSAO
   IF !CONFINCL()                 // confirma inclusao
    LOOP                          // nao confirmou...
   ENDI
  ENDI
  IF op_menu=ALTERACAO                    // na alteracao
   REPL pw_grupo WITH ENCRIPT(_grupo),;   // encripta os campos no dbf
        pw_nogrupo WITH ENCRIPT(_nogrupo)
  ELSE                                    // na inclusao
   M->pw_grupo=ENCRIPT(_grupo)            // encripta na memoria
   M->pw_nogrupo=ENCRIPT(_nogrupo)
  ENDI
  EXIT
 ENDD
ENDI
IF tp_mov=EXCLUI .OR. tp_mov=FORM_INVERSA
 INTREF(FORM_INVERSA)                     // exclui acessos e usualrios
 DELE
ELSEIF tp_mov=INCLUI .OR. tp_mov=RECUPERA .OR. tp_mov=FORM_DIRETA
 IF op_menu!=INCLUSAO                     // se nao esta incluindo
  RECA
  INTREF(FORM_DIRETA)                     // recupera todos os acessos e usuarios
 ENDI
ENDI
RETU

PROC PWT_incl(reg_cop)  // inclusao no arquivo PWTABELA. Nao tem...
RETU

PROC PWT_tela     // tela do arquivo PWTABELA
tem_borda=.t.
l_s=Sistema[op_sis,O_TELA,O_LS]        // coordenadas da tela
c_s=Sistema[op_sis,O_TELA,O_CS]
l_i=Sistema[op_sis,O_TELA,O_LI]
c_i=Sistema[op_sis,O_TELA,O_CI]
SETCOLOR(drvtittel)
vr_memo=NOVAPOSI(@l_s,@c_s,@l_i,@c_i)  // pega posicao atual da tela
CAIXA(mold,l_s,c_s,l_i,c_i)            // monta caixa da tela
i=LEN(sistema[op_sis,O_MENS])/2
@ l_s,c_s-1+(c_i-c_s+1)/2-i SAY " "+MAIUSC(sistema[op_sis,O_MENS])+" "
SETCOLOR(drvcortel)
@ l_s+01,c_s+1 SAY " Arquivo                     ³ Permiss”es"
@ l_s+02,c_s+1 SAY "ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ"
@ l_s+03,c_s+1 SAY "                             ³"
@ l_s+04,c_s+1 SAY "                             ³"
@ l_s+05,c_s+1 SAY "                             ³"
@ l_s+06,c_s+1 SAY "                             ³"
@ l_s+07,c_s+1 SAY "                             ³"
RETU

PROC PWT_gets     // mostra variaveis do arquivo PWTABELA
LOCAL getlist := {}, l_max, reg_atual:=RECNO()
PRIV  l_a:=Sistema[op_sis,O_TELA,O_SCROLL], _dbf, _permis
PWT_TELA()
l_max=l_s+Sistema[op_sis,O_TELA,O_SCROLL]+Sistema[op_sis,O_TELA,O_QTDE]
SETCOLOR(drvcortel+","+drvcorget+",,,"+corcampo)
DO WHILE !EOF() .AND. l_s+l_a<l_max .AND.;
   &(INDEXKEY(0))=IF(EMPT(criterio),"","T")+chv_1
 _dbf=DECRIPT(pw_dbf)
 _permis=DECRIPT(pw_permis)
 @ l_s+l_a,c_s+02 GET  _dbf;
                  PICT sistema[op_sis,O_CAMPO,02,O_MASC]

 @ l_s+l_a,c_s+32 GET  _permis;
                  PICT sistema[op_sis,O_CAMPO,03,O_MASC]

 SETCOLOR(drvcortel+","+drvcortel+",,,"+drvcortel)
 l_a++
 SKIP
ENDD
GO reg_atual
SETCOLOR(drvcortel+","+drvcorget+",,,"+corcampo)
CLEAR GETS
RETU

PROC PWT_get1(tp_mov, excl_rela)     // capta variaveis do arquivo PWTABELA
LOCAL getlist := {}
PRIV  _permis
excl_rela=IF(excl_rela=NIL,.f.,excl_rela) // exclusao do pai?
IF tp_mov=INCLUI
 IF TYPE("l_a")!="N"                      // linha atual do scroll
  l_a=Sistema[op_sis,O_TELA,O_SCROLL]
 ENDI
 DO WHILE .t.
  rola_t=.f.
  SET KEY K_ALT_F8 TO ROLATELA            // altera permissoes
  SETCOLOR(drvcortel+","+drvcorget+",,,"+corcampo)
  _permis=DECRIPT(pw_permis)
  @ l_s+l_a,c_s+32 GET  _permis;
                   PICT sistema[op_sis,O_CAMPO,03,O_MASC]
                   DEFINICAO 3

  READ
  SET KEY K_ALT_F8 TO                     // desabilita alt+f8
  IF rola_t                               // quer rolar a tela
   ROLATELA()                             // entao deixa
   LOOP                                   // volta para digiracao
  ENDI
  IF LASTKEY()!=K_ESC .AND. drvincl .AND. op_menu=INCLUSAO
   IF !CONFINCL()                         // confirma inclusao
    LOOP                                  // nao confirmou...
   ENDI
  ENDI
  REPL pw_permis WITH ENCRIPT(_permis)    // encripta permissoes
  EXIT
 ENDD
ENDI
IF tp_mov=EXCLUI .OR. tp_mov=FORM_INVERSA

 #ifdef COM_REDE
  IF !excl_rela                           // esta excluindo o pai
   REPL flag_excl WITH '*'                // coloca uma marca
  ENDI
 #else
  IF !excl_rela                           // esta excluindo o pai
   REPL flag_excl WITH '*'                // coloca uma marca
  ENDI
 #endi

 DELE
ELSEIF tp_mov=INCLUI .OR. tp_mov=RECUPERA .OR. tp_mov=FORM_DIRETA
 IF (op_menu=INCLUSAO .AND. LASTKEY()!=K_ESC) .OR. op_menu!=INCLUSAO
  IF tp_mov=RECUPERA .AND. op_menu!=INCLUSAO .AND. (PWGRUPOS->(DELE()))
   msg="|"+sistema[EVAL(qualsis,"PWGRUPOS"),O_MENU]
   ALERTA(2)                              // pai excuido
   DBOX("Registro exclu¡do em:"+msg+"|*",,,,,"IMPOSS¡VEL RECUPERAR!")
  ELSE
   IF !excl_rela                          // esta recuperando o pai
    IF op_menu=INCLUSAO                   // desfaz a flag
     flag_excl=' '
    ELSE
     REPL flag_excl WITH ' '
    ENDI
   ENDI
   IF op_menu!=INCLUSAO                   // se nao esta incluindo
    RECA                                  // recura o registro
   ENDI
  ENDI
 ENDI
ENDI
RETU

PROC ERRORSYS()   // Mensagem de erro durante a execucao da aplicacao
ERRORBLOCK({|erro| ERROMSG(erro)})
RETU

* \\ Final de ADR_PROC.PRG
/*
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
 \ Empresa.: PresServ Inform tica - Limeira (019)452.6623
 \ Programa: ADR_ATRI.PRG
 \ Data....: 29-06-98
 \ Sistema.: Administradora - RECEP€„O
 \ Funcao..: Define atributos dos arquivos (sistema[])
 \ Analista: Ademilson Pedro Bom
 \ Criacao.: GAS-Pro v3.0 
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/

#include "adrbig.ch"    // inicializa constantes manifestas


/*
   A adicao das  definicoes dos campos (mascara, titulo, cmd esp, when/defa,
   critica, ajuda) dentro do vetor sistema e' feita atraves da funcao AADD(),
   isto previne erro "memory overbooked" do CA-Clipper, durante a compilacao,
   devido a linha ser muito extensa
*/

sistema[01]={;
            "Recebimento de Taxas",;                        // opcao do menu
            "Recebimento de Taxas",;                        // titulo do sistema
            {"ano+numero","numop+ano+numero"},;             // chaves do arquivo
            {"p/ N£mero","p/O.P."},;                        // titulo dos indices para consulta
            {"0102","100102"},;                             // ordem campos chaves
            "BXREC",;                                       // nome do DBF
            {"BXREC1","BXREC2"},;                           // nomes dos NTX
            {},;                                            // nome dos dbf's relacionados
            {},;                                            // campos de relacionamento
            {1,1,3,11,23,62},;                              // num telas/tela atual/coordenadas
            {1,.t.},;                                       // nivel acesso/tp chave
            {},;                                            // campos do arquivo
            {},;                                            // formula mostradas
            {"nivelop>1","Permitido apenas a usu rios cadastrados|com n¡vel de Manuten‡„o ou Maior"},;// condicao de exclusao de registros
            {"nivelop=3","Para alterar este documento|chame o gerente de sistema"},;// condicao de alteracao de registros
            {"nivelop>1","Permitido apenas a usu rios cadastrados|com n¡vel de Manuten‡„o ou Maior"};// condicao de recupercao de registros
           }

AADD(sistema[01,O_CAMPO],{;            // BXREC
     /* mascara       */    "99",;
     /* titulo        */    "Ano",;
     /* cmd especial  */    "",;
     /* default       */    "RIGHT(DTOC(DATE()),2)",;
     /* pre-validacao */    "",;
     /* validacao     */    "V",;
     /* help do campo */    "";
                         };
)
AADD(sistema[01,O_CAMPO],{;            // BXREC
     /* mascara       */    "999999",;
     /* titulo        */    "Numero",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "V",;
     /* help do campo */    "";
                         };
)
AADD(sistema[01,O_CAMPO],{;            // BXREC
     /* mascara       */    "999999",;
     /* titulo        */    "Codigo",;
     /* cmd especial  */    "VDBF(6,3,20,77,'GRUPOS',{'codigo','grupo','nome','endereco'},1,'codigo',[])",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "bxr_07f9().AND.(PTAB(codigo,'TAXAS',1).OR.1=1).AND.CAD_04F9(op_menu)~Contrato inv lido |ou inexistente",;
     /* help do campo */    "Informe o n£mero do contrato";
                         };
)
AADD(sistema[01,O_CAMPO],{;            // BXREC
     /* mascara       */    "!",;
     /* titulo        */    "Tipo",;
     /* cmd especial  */    "BXR_06F9()",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    "Qual o tipo de lan‡amento";
                         };
)
AADD(sistema[01,O_CAMPO],{;            // BXREC
     /* mascara       */    "999",;
     /* titulo        */    "Circular",;
     /* cmd especial  */    "PTAB(codigo,'TAXAS',1).AND.VDBF(6,23,20,77,'TAXAS',{'codigo','circ','emissao_','valor','pgto_','valorpg'},1,'circ')",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "PTAB(codigo+tipo+circ,'TAXAS',1).AND.EMPT(TAXAS->valorpg)~Circular n„o cadastrada|ou|Taxa j  baixada",;
     /* help do campo */    "N£mero da Circular|Mantido pela emissao de recibos";
                         };
)
AADD(sistema[01,O_CAMPO],{;            // BXREC
     /* mascara       */    "@E 999,999.99",;
     /* titulo        */    "Valor pago",;
     /* cmd especial  */    "",;
     /* default       */    "BXR_02F9()",;
     /* pre-validacao */    "!EMPT(circ)",;
     /* validacao     */    "valorpg>0~VALOR PAGO n„o aceit vel|Digite o valor recebido",;
     /* help do campo */    "Informe o valor pago ou zeros se for retorno.";
                         };
)
AADD(sistema[01,O_CAMPO],{;            // BXREC
     /* mascara       */    "@E 999,999.99",;
     /* titulo        */    "Pago com...",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "valoraux>=valorpg~VALOR INSUFICIENTE para quitar o d‚bito|A T E N € Ç O",;
     /* help do campo */    "Informe o valor pago";
                         };
)
AADD(sistema[01,O_CAMPO],{;            // BXREC
     /* mascara       */    "@D",;
     /* titulo        */    "Emitido em",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "V",;
     /* help do campo */    "";
                         };
)
AADD(sistema[01,O_CAMPO],{;            // BXREC
     /* mascara       */    "",;
     /* titulo        */    "Por",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "V",;
     /* help do campo */    "";
                         };
)
AADD(sistema[01,O_CAMPO],{;            // BXREC
     /* mascara       */    "999999",;
     /* titulo        */    "N§ O.P.",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "V",;
     /* help do campo */    "";
                         };
)
AADD(sistema[01,O_CAMPO],{;            // BXREC
     /* mascara       */    "!9",;
     /* titulo        */    "Grupo",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[01,O_CAMPO],{;            // BXREC
     /* mascara       */    "@!",;
     /* titulo        */    "Filial",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[01,O_CAMPO],{;            // BXREC
     /* mascara       */    "99999999",;
     /* titulo        */    "Num.Lan‡amento",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[01,O_FORMULA],{;          // BXREC - Nome
     /* form mostrar  */    "LEFT(TRAN(GRUPOS->nome,[]),35)",;
     /* lin da formula*/    4,;
     /* col da formula*/    2;
                         };
)
AADD(sistema[01,O_FORMULA],{;          // BXREC - Circ 1 - 4
     /* form mostrar  */    "LEFT(TRAN(IIF(PTAB(codigo,'TAXAS',1).OR..t.,BXR_01F9(),[]),[]),48)",;
     /* lin da formula*/    12,;
     /* col da formula*/    3;
                         };
)
AADD(sistema[01,O_FORMULA],{;          // BXREC - Ult.Circular
     /* form mostrar  */    "LEFT(TRAN(GRUPOS->ultcirc,[999]),03)",;
     /* lin da formula*/    6,;
     /* col da formula*/    46;
                         };
)
AADD(sistema[01,O_FORMULA],{;          // BXREC - Situa‡„o
     /* form mostrar  */    "LEFT(TRAN(IIF(GRUPOS->situacao='2',[CANCELADO],[         ])+[ - Grupo ]+GRUPOS->grupo,[]),22)",;
     /* lin da formula*/    2,;
     /* col da formula*/    20;
                         };
)
AADD(sistema[01,O_FORMULA],{;          // BXREC - Admiss„o
     /* form mostrar  */    "LEFT(DTOC(GRUPOS->admissao),6)+RIGHT(DTOC(GRUPOS->admissao),2)",;
     /* lin da formula*/    8,;
     /* col da formula*/    12;
                         };
)
AADD(sistema[01,O_FORMULA],{;          // BXREC - Saitxa
     /* form mostrar  */    "LEFT(TRAN(GRUPOS->saitxa,[@R 99/99]),05)",;
     /* lin da formula*/    8,;
     /* col da formula*/    32;
                         };
)
AADD(sistema[01,O_FORMULA],{;          // BXREC - Cobrador
     /* form mostrar  */    "LEFT(TRAN(GRUPOS->cobrador,[!!!])+[-]+IIF(PTAB(GRUPOS->cobrador,[COBRADOR]),COBRADOR->nome,[]),19)",;
     /* lin da formula*/    9,;
     /* col da formula*/    19;
                         };
)
AADD(sistema[01,O_FORMULA],{;          // BXREC - Funerais
     /* form mostrar  */    "LEFT(TRAN(GRUPOS->funerais,[99]),02)",;
     /* lin da formula*/    9,;
     /* col da formula*/    09;
                         };
)
AADD(sistema[01,O_FORMULA],{;          // BXREC - Circ.Inicial
     /* form mostrar  */    "LEFT(TRAN(GRUPOS->circinic,[999]),03)",;
     /* lin da formula*/    5,;
     /* col da formula*/    46;
                         };
)
AADD(sistema[01,O_FORMULA],{;          // BXREC - Endere‡o
     /* form mostrar  */    "LEFT(TRAN(GRUPOS->endereco,[]),35)",;
     /* lin da formula*/    5,;
     /* col da formula*/    2;
                         };
)
AADD(sistema[01,O_FORMULA],{;          // BXREC - Bairro
     /* form mostrar  */    "LEFT(TRAN(GRUPOS->bairro,[]),25)",;
     /* lin da formula*/    6,;
     /* col da formula*/    2;
                         };
)
AADD(sistema[01,O_FORMULA],{;          // BXREC - Cidade
     /* form mostrar  */    "LEFT(TRAN(GRUPOS->cidade,[]),25)",;
     /* lin da formula*/    7,;
     /* col da formula*/    2;
                         };
)
AADD(sistema[01,O_FORMULA],{;          // BXREC - CEP
     /* form mostrar  */    "LEFT(TRAN(GRUPOS->cep,[@R 99999-999]),09)",;
     /* lin da formula*/    7,;
     /* col da formula*/    28;
                         };
)
AADD(sistema[01,O_FORMULA],{;          // BXREC - Regi„o
     /* form mostrar  */    "LEFT(TRAN(GRUPOS->regiao,[999]),03)",;
     /* lin da formula*/    6,;
     /* col da formula*/    34;
                         };
)
AADD(sistema[01,O_FORMULA],{;          // BXREC - endereco
     /* form mostrar  */    "LEFT(TRAN(IIF(PTAB(codigo,'ALENDER',1),[ENDERE€O ALTERADO ]+DTOC(ALENDER->data_),[ ]),[]),27)",;
     /* lin da formula*/    1,;
     /* col da formula*/    23;
                         };
)
AADD(sistema[01,O_FORMULA],{;          // BXREC - troco
     /* form mostrar  */    "LEFT(TRAN(valoraux-valorpg,[@E 999,999.99]),11)",;
     /* lin da formula*/    18,;
     /* col da formula*/    33;
                         };
)
AADD(sistema[01,O_FORMULA],{;          // BXREC - Filial
     /* form mostrar  */    "LEFT(TRAN(filial,[@!]),02)",;
     /* lin da formula*/    1,;
     /* col da formula*/    20;
                         };
)

sistema[02]={;
            "Endere‡os",;                                   // opcao do menu
            "Endere‡os",;                                   // titulo do sistema
            {"codigo"},;                                    // chaves do arquivo
            {"p/Contrato"},;                                // titulo dos indices para consulta
            {"01"},;                                        // ordem campos chaves
            "ALENDER",;                                     // nome do DBF
            {"ALENDER1"},;                                  // nomes dos NTX
            {},;                                            // nome dos dbf's relacionados
            {},;                                            // campos de relacionamento
            {1,1,9,2,17,77},;                               // num telas/tela atual/coordenadas
            {0,.t.},;                                       // nivel acesso/tp chave
            {},;                                            // campos do arquivo
            {},;                                            // formula mostradas
            {"nivelop>1","Permitido apenas a usu rios cadastrados|com n¡vel de Manuten‡„o ou Maior"},;// condicao de exclusao de registros
            {"nivelop>1","Permitido apenas a usu rios cadastrados|com n¡vel de Manuten‡„o ou Maior"},;// condicao de alteracao de registros
            {"nivelop>1","Permitido apenas a usu rios cadastrados|com n¡vel de Manuten‡„o ou Maior"};// condicao de recupercao de registros
           }

AADD(sistema[02,O_CAMPO],{;            // ALENDER
     /* mascara       */    "999999",;
     /* titulo        */    "Codigo",;
     /* cmd especial  */    "VDBF(6,31,20,77,'GRUPOS',{'codigo','nome'},4,'codigo')",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "PTAB(codigo,'GRUPOS',1).AND.ALE_01F9().AND.CAD_04F9(op_menu)~CODIGO n„o aceit vel|Tecle F8 para consulta",;
     /* help do campo */    "Entre com o n£mero do contrato|Tecle F8 para consulta";
                         };
)
AADD(sistema[02,O_CAMPO],{;            // ALENDER
     /* mascara       */    "",;
     /* titulo        */    "Endere‡o",;
     /* cmd especial  */    "",;
     /* default       */    "GRUPOS->endereco",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(endereco)~Necess rio informar ENDERE€O do Titular",;
     /* help do campo */    "Informe o Endere‡o para correspondˆncias.|Rua,n£mero,apto, blocl, etc...";
                         };
)
AADD(sistema[02,O_CAMPO],{;            // ALENDER
     /* mascara       */    "",;
     /* titulo        */    "Bairro",;
     /* cmd especial  */    "",;
     /* default       */    "GRUPOS->bairro",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(bairro)~Necess rio informar BAIRRO do Titular",;
     /* help do campo */    "";
                         };
)
AADD(sistema[02,O_CAMPO],{;            // ALENDER
     /* mascara       */    "",;
     /* titulo        */    "Cidade",;
     /* cmd especial  */    "",;
     /* default       */    "GRUPOS->cidade",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(cidade)~Necess rio informar MUNICIPIO para cobran‡a do Titular.",;
     /* help do campo */    "";
                         };
)
AADD(sistema[02,O_CAMPO],{;            // ALENDER
     /* mascara       */    "@R 99999-999",;
     /* titulo        */    "CEP",;
     /* cmd especial  */    "",;
     /* default       */    "GRUPOS->cep",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(cep)~Necess rio informar CEP do Titular |com 08 digitos",;
     /* help do campo */    "";
                         };
)
AADD(sistema[02,O_CAMPO],{;            // ALENDER
     /* mascara       */    "!!!",;
     /* titulo        */    "Cobrador",;
     /* cmd especial  */    "VDBF(6,39,20,77,'REGIAO',{'regiao','cobrador'},2,'cobrador',[!EMPT(cobrador)])",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "PTAB(cobrador,'COBRADOR',1).OR.EMPT(cobrador)~COBRADOR n„o existe na tabela",;
     /* help do campo */    "Digite o c¢digo do COBRADOR que|receber  as Taxas deste contrato,|Tecle F8 para consultar os cobradores.";
                         };
)
AADD(sistema[02,O_CAMPO],{;            // ALENDER
     /* mascara       */    "@D",;
     /* titulo        */    "Data_",;
     /* cmd especial  */    "",;
     /* default       */    "DATE()",;
     /* pre-validacao */    "",;
     /* validacao     */    "V",;
     /* help do campo */    "";
                         };
)
AADD(sistema[02,O_CAMPO],{;            // ALENDER
     /* mascara       */    "",;
     /* titulo        */    "Por",;
     /* cmd especial  */    "",;
     /* default       */    "M->usuario",;
     /* pre-validacao */    "",;
     /* validacao     */    "V",;
     /* help do campo */    "";
                         };
)
AADD(sistema[02,O_CAMPO],{;            // ALENDER
     /* mascara       */    "",;
     /* titulo        */    "Endere‡o",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "V",;
     /* help do campo */    "";
                         };
)
AADD(sistema[02,O_CAMPO],{;            // ALENDER
     /* mascara       */    "",;
     /* titulo        */    "Bairro",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "V",;
     /* help do campo */    "";
                         };
)
AADD(sistema[02,O_CAMPO],{;            // ALENDER
     /* mascara       */    "",;
     /* titulo        */    "Cidade",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "V",;
     /* help do campo */    "";
                         };
)
AADD(sistema[02,O_CAMPO],{;            // ALENDER
     /* mascara       */    "@R 99999-999",;
     /* titulo        */    "CEP",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "V",;
     /* help do campo */    "";
                         };
)
AADD(sistema[02,O_CAMPO],{;            // ALENDER
     /* mascara       */    "!!!",;
     /* titulo        */    "Cobrador",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "V",;
     /* help do campo */    "";
                         };
)
AADD(sistema[02,O_CAMPO],{;            // ALENDER
     /* mascara       */    "",;
     /* titulo        */    "Dgrupo",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "V",;
     /* help do campo */    "";
                         };
)
AADD(sistema[02,O_CAMPO],{;            // ALENDER
     /* mascara       */    "@D",;
     /* titulo        */    "Emitido",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "nivelop=3",;
     /* validacao     */    "",;
     /* help do campo */    "Data da emiss„o de solicita‡„o do endere‡o";
                         };
)
AADD(sistema[02,O_CAMPO],{;            // ALENDER
     /* mascara       */    "@!",;
     /* titulo        */    "Filial",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[02,O_FORMULA],{;          // ALENDER - Nome
     /* form mostrar  */    "LEFT(TRAN(GRUPOS->nome,[]),35)",;
     /* lin da formula*/    1,;
     /* col da formula*/    25;
                         };
)
AADD(sistema[02,O_FORMULA],{;          // ALENDER - Filial
     /* form mostrar  */    "LEFT(TRAN(filial,[@!]),02)",;
     /* lin da formula*/    1,;
     /* col da formula*/    22;
                         };
)


sistema[03]={;
            "Outros Recebimentos",;                         // opcao do menu
            "Outros Recebimentos",;                         // titulo do sistema
            {"ano+numero","numop+ano+numero"},;             // chaves do arquivo
            {"p/ N£mero","p/O.P."},;                        // titulo dos indices para consulta
            {"0102","090102"},;                             // ordem campos chaves
            "OBXEC",;                                       // nome do DBF
            {"OBXEC1","OBXEC2"},;                           // nomes dos NTX
            {},;                                            // nome dos dbf's relacionados
            {},;                                            // campos de relacionamento
            {1,1,3,11,23,64},;                              // num telas/tela atual/coordenadas
            {1,.t.},;                                       // nivel acesso/tp chave
            {},;                                            // campos do arquivo
            {},;                                            // formula mostradas
            {"nivelop>1","Permitido apenas a usu rios cadastrados|com n¡vel de Manuten‡„o ou Maior"},;// condicao de exclusao de registros
            {"nivelop=3","Para alterar este documento|Chame um gerente de sistema"},;// condicao de alteracao de registros
            {"nivelop>1","Permitido apenas a usu rios cadastrados|com n¡vel de Manuten‡„o ou Maior"};// condicao de recupercao de registros
           }

AADD(sistema[03,O_CAMPO],{;            // OBXEC
     /* mascara       */    "99",;
     /* titulo        */    "Ano",;
     /* cmd especial  */    "",;
     /* default       */    "RIGHT(DTOC(DATE()),2)",;
     /* pre-validacao */    "",;
     /* validacao     */    "V",;
     /* help do campo */    "";
                         };
)
AADD(sistema[03,O_CAMPO],{;            // OBXEC
     /* mascara       */    "999999",;
     /* titulo        */    "Numero",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "V",;
     /* help do campo */    "";
                         };
)
AADD(sistema[03,O_CAMPO],{;            // OBXEC
     /* mascara       */    "999999",;
     /* titulo        */    "Codigo",;
     /* cmd especial  */    "VDBF(6,26,20,77,'GRUPOS',{'grupo','codigo','nome'},1,'codigo')",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "(PTAB(codigo,'GRUPOS',1).AND.CAD_04F9(op_menu).AND.(PTAB(codigo,'TAXAS',1).OR.1=1)).OR.codigo='000000'~Contrato inv lido |ou inexistente",;
     /* help do campo */    "Informe o n£mero do contrato";
                         };
)
AADD(sistema[03,O_CAMPO],{;            // OBXEC
     /* mascara       */    "@S23",;
     /* titulo        */    "Ref",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(ref).AND.EMPT(VAL(ref))~Este recibo ‚ para que?|Certifique-se de baixar as Taxas |na rotina especifica.",;
     /* help do campo */    "Informe a que se refere este pagamento";
                         };
)
AADD(sistema[03,O_CAMPO],{;            // OBXEC
     /* mascara       */    "@E 999,999.99",;
     /* titulo        */    "Valor pago",;
     /* cmd especial  */    "",;
     /* default       */    "OBX_02F9()",;
     /* pre-validacao */    "",;
     /* validacao     */    "valorpg>0~VALOR PAGO n„o aceit vel|Digite o valor recebido",;
     /* help do campo */    "Informe o valor pago ou zeros se for retorno.";
                         };
)
AADD(sistema[03,O_CAMPO],{;            // OBXEC
     /* mascara       */    "@E 999,999.99",;
     /* titulo        */    "Pago com...",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "valoraux>=valorpg~VALOR INSUFICIENTE para quitar o d‚bito|A T E N € Ç O",;
     /* help do campo */    "Informe o valor pago";
                         };
)
AADD(sistema[03,O_CAMPO],{;            // OBXEC
     /* mascara       */    "@D",;
     /* titulo        */    "Emitido em",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "V",;
     /* help do campo */    "";
                         };
)
AADD(sistema[03,O_CAMPO],{;            // OBXEC
     /* mascara       */    "",;
     /* titulo        */    "Por",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "V",;
     /* help do campo */    "";
                         };
)
AADD(sistema[03,O_CAMPO],{;            // OBXEC
     /* mascara       */    "999999",;
     /* titulo        */    "N§ O.P.",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "V",;
     /* help do campo */    "";
                         };
)
AADD(sistema[03,O_CAMPO],{;            // OBXEC
     /* mascara       */    "!9",;
     /* titulo        */    "Grupo",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[03,O_CAMPO],{;            // OBXEC
     /* mascara       */    "@!",;
     /* titulo        */    "Filial",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[03,O_CAMPO],{;            // OBXEC
     /* mascara       */    "99999999",;
     /* titulo        */    "Num.Lan‡amento",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[03,O_FORMULA],{;          // OBXEC - Nome
     /* form mostrar  */    "LEFT(TRAN(GRUPOS->nome,[]),35)",;
     /* lin da formula*/    4,;
     /* col da formula*/    2;
                         };
)
AADD(sistema[03,O_FORMULA],{;          // OBXEC - Circ 1 - 4
     /* form mostrar  */    "LEFT(TRAN(IIF(PTAB(codigo,'TAXAS',1),oBX_01F9(),[]),[]),45)",;
     /* lin da formula*/    12,;
     /* col da formula*/    3;
                         };
)
AADD(sistema[03,O_FORMULA],{;          // OBXEC - Ult.Circular
     /* form mostrar  */    "LEFT(TRAN(GRUPOS->ultcirc,[999]),03)",;
     /* lin da formula*/    6,;
     /* col da formula*/    46;
                         };
)
AADD(sistema[03,O_FORMULA],{;          // OBXEC - Situa‡„o
     /* form mostrar  */    "LEFT(TRAN(IIF(GRUPOS->situacao='2',[CANCELADO],[         ])+[ - Grupo ]+GRUPOS->grupo,[]),22)",;
     /* lin da formula*/    2,;
     /* col da formula*/    22;
                         };
)
AADD(sistema[03,O_FORMULA],{;          // OBXEC - Admiss„o
     /* form mostrar  */    "LEFT(TRAN(GRUPOS->admissao,[@D]),08)",;
     /* lin da formula*/    8,;
     /* col da formula*/    12;
                         };
)
AADD(sistema[03,O_FORMULA],{;          // OBXEC - Saitxa
     /* form mostrar  */    "LEFT(TRAN(GRUPOS->saitxa,[@R 99/99]),05)",;
     /* lin da formula*/    8,;
     /* col da formula*/    32;
                         };
)
AADD(sistema[03,O_FORMULA],{;          // OBXEC - Cobrador
     /* form mostrar  */    "LEFT(TRAN(GRUPOS->cobrador,[!!!])+[-]+IIF(PTAB(GRUPOS->cobrador,[COBRADOR]),COBRADOR->nome,[]),19)",;
     /* lin da formula*/    9,;
     /* col da formula*/    19;
                         };
)
AADD(sistema[03,O_FORMULA],{;          // OBXEC - Funerais
     /* form mostrar  */    "LEFT(TRAN(GRUPOS->funerais,[99]),02)",;
     /* lin da formula*/    9,;
     /* col da formula*/    09;
                         };
)
AADD(sistema[03,O_FORMULA],{;          // OBXEC - Circ.Inicial
     /* form mostrar  */    "LEFT(TRAN(GRUPOS->circinic,[999]),03)",;
     /* lin da formula*/    5,;
     /* col da formula*/    46;
                         };
)
AADD(sistema[03,O_FORMULA],{;          // OBXEC - Endere‡o
     /* form mostrar  */    "LEFT(TRAN(GRUPOS->endereco,[]),35)",;
     /* lin da formula*/    5,;
     /* col da formula*/    2;
                         };
)
AADD(sistema[03,O_FORMULA],{;          // OBXEC - Bairro
     /* form mostrar  */    "LEFT(TRAN(GRUPOS->bairro,[]),25)",;
     /* lin da formula*/    6,;
     /* col da formula*/    2;
                         };
)
AADD(sistema[03,O_FORMULA],{;          // OBXEC - Cidade
     /* form mostrar  */    "LEFT(TRAN(GRUPOS->cidade,[]),25)",;
     /* lin da formula*/    7,;
     /* col da formula*/    2;
                         };
)
AADD(sistema[03,O_FORMULA],{;          // OBXEC - CEP
     /* form mostrar  */    "LEFT(TRAN(GRUPOS->cep,[@R 99999-999]),09)",;
     /* lin da formula*/    7,;
     /* col da formula*/    28;
                         };
)
AADD(sistema[03,O_FORMULA],{;          // OBXEC - Regi„o
     /* form mostrar  */    "LEFT(TRAN(GRUPOS->regiao,[999]),03)",;
     /* lin da formula*/    6,;
     /* col da formula*/    34;
                         };
)
AADD(sistema[03,O_FORMULA],{;          // OBXEC - endereco
     /* form mostrar  */    "LEFT(TRAN(IIF(PTAB(codigo,'ALENDER',1),[ENDERE€O ALTERADO ]+DTOC(ALENDER->data_),[ ]),[]),27)",;
     /* lin da formula*/    1,;
     /* col da formula*/    25;
                         };
)
AADD(sistema[03,O_FORMULA],{;          // OBXEC - troco
     /* form mostrar  */    "LEFT(TRAN(valoraux -valorpg,[@E 999,999.99]),11)",;
     /* lin da formula*/    18,;
     /* col da formula*/    33;
                         };
)
AADD(sistema[03,O_FORMULA],{;          // OBXEC - Qt.Circulares
     /* form mostrar  */    "LEFT(TRAN(GRUPOS->qtcircs,[999]),03)",;
     /* lin da formula*/    7,;
     /* col da formula*/    46;
                         };
)
AADD(sistema[03,O_FORMULA],{;          // OBXEC - Filial
     /* form mostrar  */    "LEFT(TRAN(filial,[@!]),02)",;
     /* lin da formula*/    1,;
     /* col da formula*/    22;
                         };
)


sistema[04]={;
            "Consulta Contratos",;                          // opcao do menu
            "Consulta contratos",;                          // titulo do sistema
            {"codigo","nome"},;// chaves do arquivo
            {"Contrato","p/Nome"},;// titulo dos indices para consulta
            {"01","04"},;          // ordem campos chaves
            "GRUPOS",;                                      // nome do DBF
            {"GRUPOS1","GRUPOS5"},;// nomes dos NTX
            {"TAXAS","ECOB","INSCRITS"},;                   // nome dos dbf's relacionados
            {},;                                            // campos de relacionamento
            {1,1,2,3,19,77},;                               // num telas/tela atual/coordenadas
            {1,.t.},;                                       // nivel acesso/tp chave
            {},;                                            // campos do arquivo
            {},;                                            // formula mostradas
            {"1=3","Mantido pelo sistema de Plano"},;       // condicao de exclusao de registros
            {"1=3","Mantido pelo sistema de Plano"},;       // condicao de alteracao de registros
            {"1=3","Mantido pelo sistema de Plano"};        // condicao de recupercao de registros
           }

AADD(sistema[04,O_CAMPO],{;            // GRUPOS
     /* mascara       */    "999999",;
     /* titulo        */    "Codigo",;
     /* cmd especial  */    "GRU_02F9()",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "PTAB('',[ARQGRUP],1).AND.GRU_01F9()~CODIGO n„o aceit vel|N„o cadastrado na tabela de grupos",;
     /* help do campo */    "Entre com o n£mero do contrato";
                         };
)
AADD(sistema[04,O_CAMPO],{;            // GRUPOS
     /* mascara       */    "!!",;
     /* titulo        */    "Grupo",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[04,O_CAMPO],{;            // GRUPOS
     /* mascara       */    "9",;
     /* titulo        */    "Situa‡„o",;
     /* cmd especial  */    "MTAB([1=Ativo|2=Cancelado],[SITUA€ŽO])",;
     /* default       */    "[1]",;
     /* pre-validacao */    "",;
     /* validacao     */    "situacao $ [12]~SITUA€ŽO n„o aceit vel",;
     /* help do campo */    "Digite 1 para ativo ou 2 para cancelado";
                         };
)
AADD(sistema[04,O_CAMPO],{;            // GRUPOS
     /* mascara       */    "@!",;
     /* titulo        */    "Nome",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(nome)~Necess rio informar NOME",;
     /* help do campo */    "";
                         };
)
AADD(sistema[04,O_CAMPO],{;            // GRUPOS
     /* mascara       */    "@D",;
     /* titulo        */    "Nascto",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    "Informe a data de nascimento do titular";
                         };
)
AADD(sistema[04,O_CAMPO],{;            // GRUPOS
     /* mascara       */    "!!",;
     /* titulo        */    "Est Civil",;
     /* cmd especial  */    "MTAB(tbestciv,[EST CIVIL])",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "(estcivil$tbestciv)~Informe Estado Civil|ou|Tecle F8 para consulta em tabela",;
     /* help do campo */    "Digite o Estado Civil do Titular|ou|Tecle F8 para consulta em tabela";
                         };
)
AADD(sistema[04,O_CAMPO],{;            // GRUPOS
     /* mascara       */    "@R 999.999.999-99",;
     /* titulo        */    "CPF",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "VDV2(cpf).OR.EMPT(cpf)~CPF nÆo aceit vel",;
     /* help do campo */    "Informe o CIC (CPF) do titular";
                         };
)
AADD(sistema[04,O_CAMPO],{;            // GRUPOS
     /* mascara       */    "@!",;
     /* titulo        */    "R.G.",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    "Informe o n£mero do documento do titular";
                         };
)
AADD(sistema[04,O_CAMPO],{;            // GRUPOS
     /* mascara       */    "@!",;
     /* titulo        */    "Endere‡o",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(endereco)~Este endere‡o ser  utilizado na emissÆo das Taxas|para cobran‡a e em todas as telas de consulta.",;
     /* help do campo */    "Informe o Endere‡o para correspondˆncias.|Rua,n£mero,apto, blocl, etc...";
                         };
)
AADD(sistema[04,O_CAMPO],{;            // GRUPOS
     /* mascara       */    "@!",;
     /* titulo        */    "Bairro",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(bairro)~Necess rio informar BAIRRO do Titular",;
     /* help do campo */    "Informe o bairro ou regi„o do titular do contrato";
                         };
)
AADD(sistema[04,O_CAMPO],{;            // GRUPOS
     /* mascara       */    "@!",;
     /* titulo        */    "Cidade",;
     /* cmd especial  */    "",;
     /* default       */    "M->p_cidade",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(cidade)~Necess rio informar MUNICIPIO para cobran‡a do Titular.",;
     /* help do campo */    "Digite a Cidade para correspondˆncia.";
                         };
)
AADD(sistema[04,O_CAMPO],{;            // GRUPOS
     /* mascara       */    "!!",;
     /* titulo        */    "UF",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "VUF(uf).OR.EMPT(UF)~UNIDADE DA FEDERA€ŽO inv lida",;
     /* help do campo */    "Qual ‚ o estado da federa‡„o";
                         };
)
AADD(sistema[04,O_CAMPO],{;            // GRUPOS
     /* mascara       */    "@R 99999-999",;
     /* titulo        */    "CEP",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(cep)~Necess rio informar CEP do Titular |com 08 digitos",;
     /* help do campo */    "Informe o CEP (8 digitos)|para facilitar a correspondˆncia";
                         };
)
AADD(sistema[04,O_CAMPO],{;            // GRUPOS
     /* mascara       */    "@K!",;
     /* titulo        */    "Naturalidade",;
     /* cmd especial  */    "",;
     /* default       */    "M->p_cidade",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    "Informe a naturalidade do titular";
                         };
)
AADD(sistema[04,O_CAMPO],{;            // GRUPOS
     /* mascara       */    "@!",;
     /* titulo        */    "Relig",;
     /* cmd especial  */    "__KEYBOARD([CATOLICO])",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    "Informe a religi„o do titular";
                         };
)
AADD(sistema[04,O_CAMPO],{;            // GRUPOS
     /* mascara       */    "@!",;
     /* titulo        */    "Contato",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    "Digite o nome da pessoa para contato|";
                         };
)
AADD(sistema[04,O_CAMPO],{;            // GRUPOS
     /* mascara       */    "@!",;
     /* titulo        */    "Telefone",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    "Informe o n£mero de telefone para|Contato com o contratante";
                         };
)
AADD(sistema[04,O_CAMPO],{;            // GRUPOS
     /* mascara       */    "99",;
     /* titulo        */    "TipCont",;
     /* cmd especial  */    "VDBF(6,20,20,77,'CLASSES',{'classcod','descricao','vljoia'},1,'classcod',[])",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "PTAB(tipcont,'CLASSES',1)~Informe a Classe deste contrato",;
     /* help do campo */    "Qual a categoria do Contrato?|Tecle F8 para consulta em tabela";
                         };
)
AADD(sistema[04,O_CAMPO],{;            // GRUPOS
     /* mascara       */    "",;
     /* titulo        */    "Vlcarne",;
     /* cmd especial  */    "VDBF(6,52,20,77,'TCARNES',{'tip','pari','vali','parf'},1,'tip',[])",;
     /* default       */    "",;
     /* pre-validacao */    "!(CLASSES->prior=[S])",;
     /* validacao     */    "",;
     /* help do campo */    "Qual o c¢digo de classifica‡Æo do valor do contrato?|Tecle F8 para consultar tabela|Obs.|Ser  preenchido quando for lan‡ada a|venda do contrato.";
                         };
)
AADD(sistema[04,O_CAMPO],{;            // GRUPOS
     /* mascara       */    "99",;
     /* titulo        */    "FormaPgto",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "CLASSES->prior=[S]",;
     /* validacao     */    "",;
     /* help do campo */    "Informe a forma de pagamento desejada|A Taxa de manuten‡Æo ser  emitida cada NN meses.";
                         };
)
AADD(sistema[04,O_CAMPO],{;            // GRUPOS
     /* mascara       */    "",;
     /* titulo        */    "Seguro",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[04,O_CAMPO],{;            // GRUPOS
     /* mascara       */    "@D",;
     /* titulo        */    "Admiss„o",;
     /* cmd especial  */    "DATE()",;
     /* default       */    "DATE()",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(admissao)~Necess rio informar DATA DE ADMISSŽO",;
     /* help do campo */    "Informe a data da Admiss„o neste contrato";
                         };
)
AADD(sistema[04,O_CAMPO],{;            // GRUPOS
     /* mascara       */    "@D",;
     /* titulo        */    "T.Carˆncia",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    "Informe a data de t‚rmino da Carˆncia";
                         };
)
AADD(sistema[04,O_CAMPO],{;            // GRUPOS
     /* mascara       */    "@R 99/99",;
     /* titulo        */    "Saitxa",;
     /* cmd especial  */    "",;
     /* default       */    "SUBSTR(DTOC(admissao+(CLASSES->nrparc*30)),4,2)+RIGHT(DTOC(admissao+(CLASSES->nrparc*30)),2)",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(saitxa).AND.MMAA(saitxa) .or.nivelop==3~Necess rio informar SAITXA (MM/AA)",;
     /* help do campo */    "Informe o Mˆs a sair a 1¦ Taxa.";
                         };
)
AADD(sistema[04,O_CAMPO],{;            // GRUPOS
     /* mascara       */    "99",;
     /* titulo        */    "Dia Pgto.",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "diapgto<[31]~DIA PGTO. n„o aceit vel|Digite um dia entre 01 e 30|ou|deixe com 00 para data igual ao grupo",;
     /* help do campo */    "Informe o melhor dia para pagamento";
                         };
)
AADD(sistema[04,O_CAMPO],{;            // GRUPOS
     /* mascara       */    "!!!",;
     /* titulo        */    "Vendedor",;
     /* cmd especial  */    "VDBF(6,7,20,77,'COBRADOR',{'cobrador','funcao','nome','cidade'},1,'cobrador')",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "PTAB(vendedor,'COBRADOR',1).OR.EMPT(vendedor)~VENDEDOR n„o existe na tabela",;
     /* help do campo */    "Informe o c¢digo do Vendedor|ou|Tecle F8 para consulta em arquivo";
                         };
)
AADD(sistema[04,O_CAMPO],{;            // GRUPOS
     /* mascara       */    "999",;
     /* titulo        */    "Regi„o",;
     /* cmd especial  */    "VDBF(6,38,20,77,'REGIAO',{'codigo','regiao'},1,'codigo')",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "PTAB(regiao,'REGIAO',1).OR.EMPT(VAL(regiao))~REGIŽO n„o existe na tabela",;
     /* help do campo */    "Informe a regi„o ou tecle F8 para busca em tabela";
                         };
)
AADD(sistema[04,O_CAMPO],{;            // GRUPOS
     /* mascara       */    "!!!",;
     /* titulo        */    "Cobrador",;
     /* cmd especial  */    "VDBF(6,39,20,77,'REGIAO',{'regiao','cobrador'},2,'cobrador',[!EMPT(cobrador)])",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "PTAB(cobrador,'COBRADOR',1)~COBRADOR n„o existe na tabela",;
     /* help do campo */    "Digite o c¢digo do COBRADOR que|receber  as Taxas deste contrato,|Tecle F8 para consultar os cobradores.";
                         };
)
AADD(sistema[04,O_CAMPO],{;            // GRUPOS
     /* mascara       */    "@S35",;
     /* titulo        */    "Obs",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    "";
                         };
)
AADD(sistema[04,O_CAMPO],{;            // GRUPOS
     /* mascara       */    "@D",;
     /* titulo        */    "Renovar",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    "Data final para renova‡Æo";
                         };
)
AADD(sistema[04,O_CAMPO],{;            // GRUPOS
     /* mascara       */    "99",;
     /* titulo        */    "Funerais",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "!(funerais<0)~FUNERAIS n„o aceit vel",;
     /* help do campo */    "N£mero de Funerais efetuados|para este processo";
                         };
)
AADD(sistema[04,O_CAMPO],{;            // GRUPOS
     /* mascara       */    "999",;
     /* titulo        */    "Circ.Inicial",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    "Informe o n£mero da 1¦ Circular|que saiu para este contrato.";
                         };
)
AADD(sistema[04,O_CAMPO],{;            // GRUPOS
     /* mascara       */    "999",;
     /* titulo        */    "Ult.Circular",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "PTAB(IIF(CLASSES->prior=[S],M->mgrupvip,grupo)+ultcirc,'CIRCULAR',1).OR.ultcirc=[000].or.nivelop==3~Necess rio informar ULT.CIRCULAR",;
     /* help do campo */    "Entre com o £ltimo n£mero de circular|deste contrato.";
                         };
)
AADD(sistema[04,O_CAMPO],{;            // GRUPOS
     /* mascara       */    "999",;
     /* titulo        */    "Qt.Circulares",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "!(qtcircs<0)~QT.CIRCULARES n„o aceit vel",;
     /* help do campo */    "";
                         };
)
AADD(sistema[04,O_CAMPO],{;            // GRUPOS
     /* mascara       */    "999",;
     /* titulo        */    "Circ.Pagas",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    "Informe a quantidade de Circulares|pagas/retornadas deste contrato";
                         };
)
AADD(sistema[04,O_CAMPO],{;            // GRUPOS
     /* mascara       */    "",;
     /* titulo        */    "Titular",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[04,O_CAMPO],{;            // GRUPOS
     /* mascara       */    "99",;
     /* titulo        */    "Part.Vivos",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[04,O_CAMPO],{;            // GRUPOS
     /* mascara       */    "99",;
     /* titulo        */    "Part.Falecidos",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[04,O_CAMPO],{;            // GRUPOS
     /* mascara       */    "99",;
     /* titulo        */    "N§ Depend.",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[04,O_CAMPO],{;            // GRUPOS
     /* mascara       */    "@D",;
     /* titulo        */    "Ult.Impress.",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[04,O_CAMPO],{;            // GRUPOS
     /* mascara       */    "@D",;
     /* titulo        */    "élt.alter.endere‡o",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[04,O_CAMPO],{;            // GRUPOS
     /* mascara       */    "",;
     /* titulo        */    "UltEnd",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[04,O_CAMPO],{;            // GRUPOS
     /* mascara       */    "@D",;
     /* titulo        */    "Em",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[04,O_CAMPO],{;            // GRUPOS
     /* mascara       */    "",;
     /* titulo        */    "Por",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[04,O_FORMULA],{;          // GRUPOS - Situacao
     /* form mostrar  */    "LEFT(TRAN(IIF(situacao=[2],[CANCELADO],[         ]),[]),09)",;
     /* lin da formula*/    1,;
     /* col da formula*/    62;
                         };
)
AADD(sistema[04,O_FORMULA],{;          // GRUPOS - Part.Vivos
     /* form mostrar  */    "LEFT(TRAN(particv,[99]),02)",;
     /* lin da formula*/    15,;
     /* col da formula*/    24;
                         };
)
AADD(sistema[04,O_FORMULA],{;          // GRUPOS - Part.Falecidos
     /* form mostrar  */    "LEFT(TRAN(particf,[99]),02)",;
     /* lin da formula*/    15,;
     /* col da formula*/    38;
                         };
)
AADD(sistema[04,O_FORMULA],{;          // GRUPOS - Nome do Cobrado
     /* form mostrar  */    "LEFT(TRAN(IIF(PTAB(cobrador,'COBRADOR',1),COBRADOR->nome,[ ]),[]),30)",;
     /* lin da formula*/    13,;
     /* col da formula*/    16;
                         };
)
AADD(sistema[04,O_FORMULA],{;          // GRUPOS - Nome do Vendedr
     /* form mostrar  */    "LEFT(TRAN(IIF(PTAB(vendedor,'COBRADOR',1),COBRADOR->nome,[ ]),[]),30)",;
     /* lin da formula*/    11,;
     /* col da formula*/    16;
                         };
)
AADD(sistema[04,O_FORMULA],{;          // GRUPOS - grupo
     /* form mostrar  */    "LEFT(TRAN(IIF(!EMPT(grupo),grupo,[  ]),[]),02)",;
     /* lin da formula*/    1,;
     /* col da formula*/    18;
                         };
)
AADD(sistema[04,O_FORMULA],{;          // GRUPOS - Descri‡„o Reg
     /* form mostrar  */    "LEFT(TRAN(REGIAO->regiao,[]),30)",;
     /* lin da formula*/    12,;
     /* col da formula*/    16;
                         };
)
AADD(sistema[04,O_FORMULA],{;          // GRUPOS - Est.Civil
     /* form mostrar  */    "LEFT(TRAN(IIF(!EMPT(estcivil),SUBS(tbestciv,AT(estcivil,tbestciv),11),[]),[]),11)",;
     /* lin da formula*/    4,;
     /* col da formula*/    13;
                         };
)
AADD(sistema[04,O_FORMULA],{;          // GRUPOS - N§ Depend.
     /* form mostrar  */    "LEFT(TRAN(nrdepend,[99]),02)",;
     /* lin da formula*/    15,;
     /* col da formula*/    54;
                         };
)
AADD(sistema[04,O_FORMULA],{;          // GRUPOS - Ult.Impress.
     /* form mostrar  */    "LEFT(TRAN(ultimp_,[@D]),08)",;
     /* lin da formula*/    16,;
     /* col da formula*/    54;
                         };
)
AADD(sistema[04,O_FORMULA],{;          // GRUPOS - élt.alter.ender
     /* form mostrar  */    "LEFT(TRAN(ender_,[@D]),08)",;
     /* lin da formula*/    16,;
     /* col da formula*/    17;
                         };
)
AADD(sistema[04,O_FORMULA],{;          // GRUPOS - UltEnd
     /* form mostrar  */    "LEFT(TRAN(ultend,[]),10)",;
     /* lin da formula*/    16,;
     /* col da formula*/    26;
                         };
)
AADD(sistema[04,O_FORMULA],{;          // GRUPOS - Seguro
     /* form mostrar  */    "LEFT(TRAN(IIF(seguro>0,'SEGURO ('+str(seguro,2)+')',[   ]),[]),12)",;
     /* lin da formula*/    1,;
     /* col da formula*/    29;
                         };
)
AADD(sistema[04,O_FORMULA],{;          // GRUPOS - Qt.Circulares
     /* form mostrar  */    "LEFT(TRAN(qtcircs,[999]),03)",;
     /* lin da formula*/    0,;
     /* col da formula*/    0;
                         };
)
AADD(sistema[04,O_FORMULA],{;          // GRUPOS - periodicidade
     /* form mostrar  */    "LEFT(TRAN(IIF(PTAB(tipcont,'CLASSES',1),ALLTRIM(CLASSES->descricao),[])+[ ]+IIF(formapgto$'01020304',SUBSTR(tbfpgto,(VAL(formapgto)-1)*13+1,13),[]),[]),35)",;
     /* lin da formula*/    9,;
     /* col da formula*/    39;
                         };
)
AADD(sistema[04,O_FORMULA],{;          // GRUPOS - Idade
     /* form mostrar  */    "LEFT(TRAN(IIF(!EMPT(nascto_),LEFT(DLAPSO(DATE(),nascto_),10),[          ]),[]),10)",;
     /* lin da formula*/    3,;
     /* col da formula*/    64;
                         };
)


sistema[05]={;
            "Taxas",;                                       // opcao do menu
            "Cadastro de Taxas",;                           // titulo do sistema
            {"codigo+tipo+circ","codlan"},;// chaves do arquivo
            {"Contrato/Circular","Cod.Lanc"},;// titulo dos indices para consulta
            {"010203","15"},;          // ordem campos chaves
            "TAXAS",;                                       // nome do DBF
            {"TAXAS1","TAXAS5"},;// nomes dos NTX
            {},;                                            // nome dos dbf's relacionados
            {"GRUPOS->codigo"},;                            // campos de relacionamento
            {1,1,13,1,23,77,3,7},;                          // num telas/tela atual/coordenadas/inicio scroll/qtde scroll
            {1,.t.},;                                       // nivel acesso/tp chave
            {},;                                            // campos do arquivo
            {},;                                            // formula mostradas
            {"",""},;                                       // condicao de exclusao de registros
            {"",""},;                                       // condicao de alteracao de registros
            {"",""};                                        // condicao de recupercao de registros
           }

AADD(sistema[05,O_CAMPO],{;            // TAXAS
     /* mascara       */    "999999",;
     /* titulo        */    "Codigo",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[05,O_CAMPO],{;            // TAXAS
     /* mascara       */    "!",;
     /* titulo        */    "Tipo",;
     /* cmd especial  */    "MTAB([1=J¢ia |2=Taxa |3=Carnˆ|6=J¢ia+Seguro|7=Taxa+Seguro|8=Carnˆ+Seguro],[TIPO])",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "tipo $ [1236789].AND.(PTAB(codigo,'GRUPOS',1).AND.PTAB(GRUPOS->tipcont,'CLASSES',1).OR.1=1)~TIPO n„o aceit vel",;
     /* help do campo */    "Qual o tipo de lan‡amento";
                         };
)
AADD(sistema[05,O_CAMPO],{;            // TAXAS
     /* mascara       */    "999",;
     /* titulo        */    "Circular",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(circ).AND.(tipo$[16].OR.PTAB(GRUPOS->grupo+circ,'CIRCULAR',1))~Necess rio informar CIRCULAR v lida",;
     /* help do campo */    "Informe o n£mero da circular a consultar";
                         };
)
AADD(sistema[05,O_CAMPO],{;            // TAXAS
     /* mascara       */    "@D",;
     /* titulo        */    "Emissao",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(emissao_)~Necess rio informar EMISSAO v lida",;
     /* help do campo */    "Data da Emiss„o da Circular|Mantido pela emissao do recibo";
                         };
)
AADD(sistema[05,O_CAMPO],{;            // TAXAS
     /* mascara       */    "@E 999,999.99",;
     /* titulo        */    "Valor",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "valor>0~VALOR n„o aceit vel",;
     /* help do campo */    "";
                         };
)
AADD(sistema[05,O_CAMPO],{;            // TAXAS
     /* mascara       */    "@D",;
     /* titulo        */    "Pagamento",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "nivelop=3",;
     /* validacao     */    "",;
     /* help do campo */    "Informe a data de pagamento/Baixa";
                         };
)
AADD(sistema[05,O_CAMPO],{;            // TAXAS
     /* mascara       */    "@E 999,999.99",;
     /* titulo        */    "Valor pago",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "nivelop=3",;
     /* validacao     */    "!(valorpg<0)~VALOR PAGO n„o aceit vel",;
     /* help do campo */    "Informe o valor pago/baixado";
                         };
)
AADD(sistema[05,O_CAMPO],{;            // TAXAS
     /* mascara       */    "!!!",;
     /* titulo        */    "Cobrador",;
     /* cmd especial  */    "VDBF(6,3,20,77,'COBRADOR',{'cobrador','funcao','nome','cidade','telefone'},1,'cobrador',[])",;
     /* default       */    "GRUPOS->cobrador",;
     /* pre-validacao */    "",;
     /* validacao     */    "PTAB(cobrador,'COBRADOR',1).AND.(PTAB(cobrador+M->mmesref,'FCCOB',1).OR.1=1)~Problemas encontrados no arquivo Cobrador ou |Circular do grupo n„o cadastrada para|este cobrador.",;
     /* help do campo */    "Informe o Cobrador que recebeu este.";
                         };
)
AADD(sistema[05,O_CAMPO],{;            // TAXAS
     /* mascara       */    "!",;
     /* titulo        */    "Forma",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "forma$[PR ]~FORMA n„o aceit vel",;
     /* help do campo */    "Esta lan‡amento foi Pago ou Cancelado|Deixe sem preencher se ainda em aberto";
                         };
)
AADD(sistema[05,O_CAMPO],{;            // TAXAS
     /* mascara       */    "@D",;
     /* titulo        */    "Baixa_",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[05,O_CAMPO],{;            // TAXAS
     /* mascara       */    "",;
     /* titulo        */    "Por",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[05,O_CAMPO],{;            // TAXAS
     /* mascara       */    "9",;
     /* titulo        */    "Status",;
     /* cmd especial  */    "MTAB([1=Gerada|2=Impressa|6=Pg Recep‡„o|7=Bx.p/FCC|9=Bx.Plano],[STATUS])",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "stat $ [12679]~STATUS n„o aceit vel",;
     /* help do campo */    "Informe a situa‡„o deste recibo|Tecle F8 para busca em tabela";
                         };
)
AADD(sistema[05,O_CAMPO],{;            // TAXAS
     /* mascara       */    "@!",;
     /* titulo        */    "Filial",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[05,O_CAMPO],{;            // TAXAS
     /* mascara       */    "!",;
     /* titulo        */    "Flag",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[05,O_CAMPO],{;            // TAXAS
     /* mascara       */    "!!!-99999999-999-999",;
     /* titulo        */    "Cod.Lan‡amento",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[05,O_FORMULA],{;          // TAXAS - Status
     /* form mostrar  */    "LEFT(TRAN(TAX_02F9(),[]),08)",;
     /* lin da formula*/    {||l_a},;
     /* col da formula*/    64;
                         };
)
AADD(sistema[05,O_FORMULA],{;          // TAXAS - Por
     /* form mostrar  */    "LEFT(TRAN(LEFT(por,9),[]),09)",;
     /* lin da formula*/    {||l_a},;
     /* col da formula*/    0;
                         };
)
AADD(sistema[05,O_FORMULA],{;          // TAXAS - Filial
     /* form mostrar  */    "LEFT(TRAN(filial,[@!]),02)",;
     /* lin da formula*/    {||l_a},;
     /* col da formula*/    73;
                         };
)
AADD(sistema[05,O_FORMULA],{;          // TAXAS - Tipo
     /* form mostrar  */    "LEFT(TRAN(SUBSTR('J¢ia Taxa Carnˆ          J+SegT+SegC+Seg',(VAL(tipo)-1)*5+1,5),[]),05)",;
     /* lin da formula*/    {||l_a},;
     /* col da formula*/    3;
                         };
)


sistema[06]={;
            "Outros Endere‡os",;                            // opcao do menu
            "Outros Endere‡os",;                            // titulo do sistema
            {"codigo+tipo"},;                               // chaves do arquivo
            {"Contrato"},;                                  // titulo dos indices para consulta
            {"0102"},;                                      // ordem campos chaves
            "ECOB",;                                        // nome do DBF
            {"ECOB1"},;                                     // nomes dos NTX
            {},;                                            // nome dos dbf's relacionados
            {"GRUPOS->codigo"},;                            // campos de relacionamento
            {1,1,8,17,16,65},;                              // num telas/tela atual/coordenadas
            {1,.t.},;                                       // nivel acesso/tp chave
            {},;                                            // campos do arquivo
            {},;                                            // formula mostradas
            {"",""},;                                       // condicao de exclusao de registros
            {"",""},;                                       // condicao de alteracao de registros
            {"",""};                                        // condicao de recupercao de registros
           }

AADD(sistema[06,O_CAMPO],{;            // ECOB
     /* mascara       */    "999999",;
     /* titulo        */    "Codigo",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[06,O_CAMPO],{;            // ECOB
     /* mascara       */    "!",;
     /* titulo        */    "Tipo",;
     /* cmd especial  */    "MTAB([Residˆncia|Trabalho|Outro],[TIPO])",;
     /* default       */    "[R]",;
     /* pre-validacao */    "MTAB([Residˆncia|Trabalho|Outro],[TIPO])",;
     /* validacao     */    "tipo $ [RTO]~TIPO n„o aceit vel|Apenas endere‡os de Residˆncia e Trabalho.",;
     /* help do campo */    "Informe que tipo de Endere‡o ‚ este.|R=Residˆncia, T=Trabalho";
                         };
)
AADD(sistema[06,O_CAMPO],{;            // ECOB
     /* mascara       */    "@!",;
     /* titulo        */    "Endere‡o",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(endereco)~Informe a localiza‡„o ou tecle ESC para cancelar",;
     /* help do campo */    "Informe o Endere‡o|Rua,n£mero,apto, blocl, etc...";
                         };
)
AADD(sistema[06,O_CAMPO],{;            // ECOB
     /* mascara       */    "@!",;
     /* titulo        */    "Bairro",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    "Digite o Bairro|ou complemento| do endere‡o";
                         };
)
AADD(sistema[06,O_CAMPO],{;            // ECOB
     /* mascara       */    "@R 99999-999",;
     /* titulo        */    "CEP",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    "Informe o CEP para facilitar a localiza‡„o";
                         };
)
AADD(sistema[06,O_CAMPO],{;            // ECOB
     /* mascara       */    "@!",;
     /* titulo        */    "Cidade",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    "Informe a Cidade/Municipio";
                         };
)
AADD(sistema[06,O_CAMPO],{;            // ECOB
     /* mascara       */    "!!",;
     /* titulo        */    "UF",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "VUF(uf).OR. EMPT(uf)~UNIDADE DA FEDERA€ŽO inv lida",;
     /* help do campo */    "Informe o Estado.|Ex.: SP,RJ,GO,AM,...";
                         };
)
AADD(sistema[06,O_CAMPO],{;            // ECOB
     /* mascara       */    "@!",;
     /* titulo        */    "Telefone",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    "Informe o n£mero do telefone para contato";
                         };
)
AADD(sistema[06,O_CAMPO],{;            // ECOB
     /* mascara       */    "",;
     /* titulo        */    "Obs",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    "";
                         };
)
AADD(sistema[06,O_CAMPO],{;            // ECOB
     /* mascara       */    "@D",;
     /* titulo        */    "Data",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[06,O_CAMPO],{;            // ECOB
     /* mascara       */    "!",;
     /* titulo        */    "Flag",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[06,O_FORMULA],{;          // ECOB - Tipo
     /* form mostrar  */    "LEFT(TRAN(IIF(tipo=[R],[Residˆncia],IIF(tipo=[T],[Trabalho],[Outro])),[]),12)",;
     /* lin da formula*/    1,;
     /* col da formula*/    15;
                         };
)
AADD(sistema[06,O_FORMULA],{;          // ECOB - Data
     /* form mostrar  */    "LEFT(TRAN(data_,[@D]),08)",;
     /* lin da formula*/    7,;
     /* col da formula*/    39;
                         };
)


sistema[07]={;
            "Inscritos",;                                   // opcao do menu
            "Inscritos",;                                   // titulo do sistema
	    {"codigo+grau+STR(seq,02,00)","LEFT(nome,17)"},;         // chaves do arquivo
            {"Contrato","p/Nome"},;                         // titulo dos indices para consulta
            {"010203","05"},;                               // ordem campos chaves
            "INSCRITS",;                                    // nome do DBF
            {"INSCRIT1","INSCRIT2"},;                       // nomes dos NTX
            {},;                                            // nome dos dbf's relacionados
            {"GRUPOS->codigo"},;                            // campos de relacionamento
            {1,1,17,3,23,77},;                              // num telas/tela atual/coordenadas
            {1,.t.},;                                       // nivel acesso/tp chave
            {},;                                            // campos do arquivo
            {},;                                            // formula mostradas
            {"",""},;                                       // condicao de exclusao de registros
            {"",""},;                                       // condicao de alteracao de registros
            {"",""};                                        // condicao de recupercao de registros
           }

AADD(sistema[07,O_CAMPO],{;            // INSCRITS
     /* mascara       */    "999999",;
     /* titulo        */    "Codigo",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[07,O_CAMPO],{;            // INSCRITS
     /* mascara       */    "9",;
     /* titulo        */    "Inscr.",;
     /* cmd especial  */    "MTAB(M->TBTIPGRAU,[INSCR.])",;
     /* default       */    "IIF(M->pgrau<[7],SUBSTR([234567],VAL(M->pgrau),1),M->pgrau)",;
     /* pre-validacao */    "MTAB(M->TBTIPGRAU,[INSCR.])",;
     /* validacao     */    "grau $ [12345678]~INSCR. n„o aceit vel",;
     /* help do campo */    "Informe o grau de liga‡„o deste com o|titular do contrato|ou|tecle F8 para consulta em tabela";
                         };
)
AADD(sistema[07,O_CAMPO],{;            // INSCRITS
     /* mascara       */    "99",;
     /* titulo        */    "Seq",;
     /* cmd especial  */    "",;
     /* default       */    "INS_01F9()",;
     /* pre-validacao */    "grau>[6]",;
     /* validacao     */    "seq>0~SEQ n„o aceit vel",;
     /* help do campo */    "";
                         };
)
AADD(sistema[07,O_CAMPO],{;            // INSCRITS
     /* mascara       */    "!",;
     /* titulo        */    "Titular?",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[07,O_CAMPO],{;            // INSCRITS
     /* mascara       */    "@!",;
     /* titulo        */    "Nome",;
     /* cmd especial  */    "",;
     /* default       */    "IIF(ehtitular=[S],GRUPOS->nome,[ ])",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(nome)~Necess rio informar NOME",;
     /* help do campo */    "";
                         };
)
AADD(sistema[07,O_CAMPO],{;            // INSCRITS
     /* mascara       */    "@D",;
     /* titulo        */    "Nascto",;
     /* cmd especial  */    "",;
     /* default       */    "IIF(ehtitular=[S],GRUPOS->nascto_,ctod('  /  /  '))",;
     /* pre-validacao */    "",;
     /* validacao     */    "INS_02F9()~NASCTO n„o aceit vel",;
     /* help do campo */    "Informe a Data de Nascimento deste Inscrito";
                         };
)
AADD(sistema[07,O_CAMPO],{;            // INSCRITS
     /* mascara       */    "",;
     /* titulo        */    "Est Civil",;
     /* cmd especial  */    "MTAB(tbestciv,[EST CIVIL])",;
     /* default       */    "IIF(grau<[7],[CA],[SO])",;
     /* pre-validacao */    "MTAB(tbestciv,[EST CIVIL])",;
     /* validacao     */    "(ESTCIVIL$tbestciv)~Necess rio informar ESTADO CIVIL|ou tecle F8",;
     /* help do campo */    "Digite o Estado Civil do Falecido";
                         };
)
AADD(sistema[07,O_CAMPO],{;            // INSCRITS
     /* mascara       */    "!",;
     /* titulo        */    "Interdito",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[07,O_CAMPO],{;            // INSCRITS
     /* mascara       */    "!",;
     /* titulo        */    "Sexo",;
     /* cmd especial  */    "",;
     /* default       */    "IIF(grau$[124],[M],IIF(grau$[356],[F],[ ]))",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    "Digite M ou F |(Masculino ou Feminino)";
                         };
)
AADD(sistema[07,O_CAMPO],{;            // INSCRITS
     /* mascara       */    "@D",;
     /* titulo        */    "T.Carˆncia",;
     /* cmd especial  */    "",;
     /* default       */    "IIF(GRUPOS->tcarencia>DATE(),GRUPOS->tcarencia,CTOD('  /  /  '))",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    "";
                         };
)
AADD(sistema[07,O_CAMPO],{;            // INSCRITS
     /* mascara       */    "@D",;
     /* titulo        */    "Lan‡to.",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[07,O_CAMPO],{;            // INSCRITS
     /* mascara       */    "!",;
     /* titulo        */    "V/F",;
     /* cmd especial  */    "MTAB([Vivo|Falecido],[V/F])",;
     /* default       */    "[V]",;
     /* pre-validacao */    "",;
     /* validacao     */    "vivofalec$[VF]~Necess rio informar VIVOFALEC",;
     /* help do campo */    "Vivo ou Falecido";
                         };
)
AADD(sistema[07,O_CAMPO],{;            // INSCRITS
     /* mascara       */    "@D",;
     /* titulo        */    "Falecto.",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "vivofalec==[F]",;
     /* validacao     */    "",;
     /* help do campo */    "Entre com a data de falecimento";
                         };
)
AADD(sistema[07,O_CAMPO],{;            // INSCRITS
     /* mascara       */    "!!!",;
     /* titulo        */    "Tipo",;
     /* cmd especial  */    "MTAB([Funeral|Auxilio],[TIPO])",;
     /* default       */    "",;
     /* pre-validacao */    "vivofalec==[F]",;
     /* validacao     */    "EMPTY(tipo).OR.UPPER(tipo) $ [FUN|AUX]~Necess rio informar TIPO",;
     /* help do campo */    "Com Direitos (Funeral) ou com Auxilio.";
                         };
)
AADD(sistema[07,O_CAMPO],{;            // INSCRITS
     /* mascara       */    "@R 99999/99",;
     /* titulo        */    "N§Processo",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "vivofalec==[F]",;
     /* validacao     */    "",;
     /* help do campo */    "Informe o n£mero do processo";
                         };
)
AADD(sistema[07,O_CAMPO],{;            // INSCRITS
     /* mascara       */    "",;
     /* titulo        */    "Por",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[07,O_CAMPO],{;            // INSCRITS
     /* mascara       */    "!",;
     /* titulo        */    "Flag",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[07,O_FORMULA],{;          // INSCRITS - graupart
     /* form mostrar  */    "LEFT(TRAN(SUBSTR([TitPaiMaeSgoSgaEspFilDep],(VAL(grau)-1)*3+1,3),[]),03)",;
     /* lin da formula*/    1,;
     /* col da formula*/    13;
                         };
)
AADD(sistema[07,O_FORMULA],{;          // INSCRITS - Lan‡to.
     /* form mostrar  */    "LEFT(TRAN(lancto_,[@D]),08)",;
     /* lin da formula*/    1,;
     /* col da formula*/    53;
                         };
)
AADD(sistema[07,O_FORMULA],{;          // INSCRITS - Por
     /* form mostrar  */    "LEFT(TRAN(por,[]),10)",;
     /* lin da formula*/    1,;
     /* col da formula*/    62;
                         };
)
AADD(sistema[07,O_FORMULA],{;          // INSCRITS - Idade
     /* form mostrar  */    "LEFT(TRAN(IIF(!EMPT(nascto_),LEFT(DLAPSO(DATE(),nascto_),12),[            ]),[]),12)",;
     /* lin da formula*/    3,;
     /* col da formula*/    62;
                         };
)


sistema[08]={;
            "Emiss„o de Guias",;                            // opcao do menu
            "Emiss„o de Guias",;                            // titulo do sistema
            {"ano+numero","numop+ano+numero"},;             // chaves do arquivo
            {"p/N£mero","p/N§Transf."},;                    // titulo dos indices para consulta
            {"0102","170102"},;                             // ordem campos chaves
            "GUIAS",;                                       // nome do DBF
            {"GUIAS1","GUIAS2"},;                           // nomes dos NTX
            {},;                                            // nome dos dbf's relacionados
            {},;                                            // campos de relacionamento
            {1,1,2,10,22,75},;                              // num telas/tela atual/coordenadas
            {1,.t.},;                                       // nivel acesso/tp chave
            {},;                                            // campos do arquivo
            {},;                                            // formula mostradas
            {"",""},;                                       // condicao de exclusao de registros
            {"",""},;                                       // condicao de alteracao de registros
            {"",""};                                        // condicao de recupercao de registros
           }

AADD(sistema[08,O_CAMPO],{;            // GUIAS
     /* mascara       */    "99",;
     /* titulo        */    "Ano",;
     /* cmd especial  */    "",;
     /* default       */    "RIGHT(DTOC(DATE()),2)",;
     /* pre-validacao */    "",;
     /* validacao     */    "V",;
     /* help do campo */    "";
                         };
)
AADD(sistema[08,O_CAMPO],{;            // GUIAS
     /* mascara       */    "99999",;
     /* titulo        */    "N£mero",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "V",;
     /* help do campo */    "";
                         };
)
AADD(sistema[08,O_CAMPO],{;            // GUIAS
     /* mascara       */    "@D",;
     /* titulo        */    "Emiss„o",;
     /* cmd especial  */    "",;
     /* default       */    "DATE()",;
     /* pre-validacao */    "",;
     /* validacao     */    "V",;
     /* help do campo */    "";
                         };
)
AADD(sistema[08,O_CAMPO],{;            // GUIAS
     /* mascara       */    "999999",;
     /* titulo        */    "N§ Contrato",;
     /* cmd especial  */    "VDBF(6,3,20,77,'GRUPOS',{'grupo','codigo','nome','endereco'},1,'codigo')",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "GUI_07F9().AND.CAD_04F9(op_menu).AND.((PTAB(contrato,'INSCRITS',1).and.PTAB(contrato,'TAXAS',1)).OR.1=1)~N£mero do contrato inv lido,|ou |Titular n„o cadastrado|Tecle F8 para consulta.",;
     /* help do campo */    "Entre com o c¢digo do contrato";
                         };
)
AADD(sistema[08,O_CAMPO],{;            // GUIAS
     /* mascara       */    "999",;
     /* titulo        */    "Circular",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[08,O_CAMPO],{;            // GUIAS
     /* mascara       */    "@!",;
     /* titulo        */    "Titular",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[08,O_CAMPO],{;            // GUIAS
     /* mascara       */    "@R 999999-9-99",;
     /* titulo        */    "N§ Contrato",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[08,O_CAMPO],{;            // GUIAS
     /* mascara       */    "@!",;
     /* titulo        */    "Nome",;
     /* cmd especial  */    "GUI_06F9()",;
     /* default       */    "GRUPOS->nome",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(nome).AND.(PTAB([],'MEDICOS',1).OR.1=1).and.gui_04f9()~Informar NOME",;
     /* help do campo */    "Informe o nome do benefici rio.";
                         };
)
AADD(sistema[08,O_CAMPO],{;            // GUIAS
     /* mascara       */    "@!",;
     /* titulo        */    "Institui‡„o",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[08,O_CAMPO],{;            // GUIAS
     /* mascara       */    "@!",;
     /* titulo        */    "M‚dico",;
     /* cmd especial  */    "VDBF(6,3,20,77,'MEDICOS',{'especialid','nome','cidade','endereco','telefone','mensagem','valorpart','ultvalor'},3,'crm',[])",;
     /* default       */    "",;
     /* pre-validacao */    "VDBF(6,3,20,77,'MEDICOS',{'especialid','nome','cidade','endereco','telefone','mensagem','valorpart','ultvalor'},3,'crm',[])",;
     /* validacao     */    "PTAB(medico,'MEDICOS',1).OR.GUI_08F9()~MDICO n„o existe na tabela",;
     /* help do campo */    "Informe o m‚dico";
                         };
)
AADD(sistema[08,O_CAMPO],{;            // GUIAS
     /* mascara       */    "@E 99,999,999.99",;
     /* titulo        */    "Valor",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[08,O_CAMPO],{;            // GUIAS
     /* mascara       */    "@E 99,999,999.99",;
     /* titulo        */    "Valor",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[08,O_CAMPO],{;            // GUIAS
     /* mascara       */    "@E 99,999,999.99",;
     /* titulo        */    "Valor",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[08,O_CAMPO],{;            // GUIAS
     /* mascara       */    "!",;
     /* titulo        */    "Guia Para",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[08,O_CAMPO],{;            // GUIAS
     /* mascara       */    "!",;
     /* titulo        */    "Pago",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[08,O_CAMPO],{;            // GUIAS
     /* mascara       */    "@E 99,999,999.99",;
     /* titulo        */    "Valor Pago",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[08,O_CAMPO],{;            // GUIAS
     /* mascara       */    "999999",;
     /* titulo        */    "N§ O.P.",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "V",;
     /* help do campo */    "";
                         };
)
AADD(sistema[08,O_CAMPO],{;            // GUIAS
     /* mascara       */    "@D",;
     /* titulo        */    "Quitado",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "V",;
     /* help do campo */    "";
                         };
)
AADD(sistema[08,O_CAMPO],{;            // GUIAS
     /* mascara       */    "999999",;
     /* titulo        */    "Quitado",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "V",;
     /* help do campo */    "";
                         };
)
AADD(sistema[08,O_CAMPO],{;            // GUIAS
     /* mascara       */    "@D",;
     /* titulo        */    "Dt.Prest.",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "V",;
     /* help do campo */    "";
                         };
)
AADD(sistema[08,O_CAMPO],{;            // GUIAS
     /* mascara       */    "",;
     /* titulo        */    "Por",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[08,O_CAMPO],{;            // GUIAS
     /* mascara       */    "99999999",;
     /* titulo        */    "Num.Lan‡amento",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[08,O_FORMULA],{;          // GUIAS - Grupo
     /* form mostrar  */    "LEFT(TRAN('-'+GRUPOS->grupo,[]),03)",;
     /* lin da formula*/    3,;
     /* col da formula*/    21;
                         };
)
AADD(sistema[08,O_FORMULA],{;          // GUIAS - circ 1-4
     /* form mostrar  */    "LEFT(TRAN(IIF(PTAB(contrato,'TAXAS',1),GUI_02F9(),[]),[]),45)",;
     /* lin da formula*/    6,;
     /* col da formula*/    15;
                         };
)
AADD(sistema[08,O_FORMULA],{;          // GUIAS - Nome do titular
     /* form mostrar  */    "LEFT(TRAN(GRUPOS->nome,[]),35)",;
     /* lin da formula*/    3,;
     /* col da formula*/    25;
                         };
)
AADD(sistema[08,O_FORMULA],{;          // GUIAS - Admiss„o
     /* form mostrar  */    "LEFT(TRAN(GRUPOS->admissao,[@D]),08)",;
     /* lin da formula*/    4,;
     /* col da formula*/    15;
                         };
)
AADD(sistema[08,O_FORMULA],{;          // GUIAS - Saitxa
     /* form mostrar  */    "LEFT(TRAN(GRUPOS->saitxa,[@R 99/99]),05)",;
     /* lin da formula*/    5,;
     /* col da formula*/    15;
                         };
)
AADD(sistema[08,O_FORMULA],{;          // GUIAS - Cobrador
     /* form mostrar  */    "LEFT(TRAN(GRUPOS->cobrador,[!!!])+[-]+IIF(PTAB(GRUPOS->cobrador,[COBRADOR]),COBRADOR->nome,[]),15)",;
     /* lin da formula*/    5,;
     /* col da formula*/    50;
                         };
)
AADD(sistema[08,O_FORMULA],{;          // GUIAS - Endere‡o contr
     /* form mostrar  */    "LEFT(TRAN(GRUPOS->endereco,[]),35)",;
     /* lin da formula*/    4,;
     /* col da formula*/    25;
                         };
)
AADD(sistema[08,O_FORMULA],{;          // GUIAS - Bairro contr
     /* form mostrar  */    "LEFT(TRAN(GRUPOS->bairro,[]),25)",;
     /* lin da formula*/    5,;
     /* col da formula*/    25;
                         };
)
AADD(sistema[08,O_FORMULA],{;          // GUIAS - Endere‡o
     /* form mostrar  */    "LEFT(TRAN(IIF(!EMPT(medico).AND.PTAB(medico,'MEDICOS',1),MEDICOS->endereco,SPACE(40)),[]),40)",;
     /* lin da formula*/    15,;
     /* col da formula*/    24;
                         };
)
AADD(sistema[08,O_FORMULA],{;          // GUIAS - Munic¡pio
     /* form mostrar  */    "LEFT(TRAN(IIF(PTAB(medico,'MEDICOS',1),MEDICOS->cidade,[]),[]),30)",;
     /* lin da formula*/    16,;
     /* col da formula*/    32;
                         };
)
AADD(sistema[08,O_FORMULA],{;          // GUIAS - Fone
     /* form mostrar  */    "LEFT(TRAN(IIF(!EMPT(medico),MEDICOS->telefone,SPACE(14)),[]),14)",;
     /* lin da formula*/    15,;
     /* col da formula*/    9;
                         };
)
AADD(sistema[08,O_FORMULA],{;          // GUIAS - Nome m‚dico
     /* form mostrar  */    "LEFT(TRAN(IIF(!EMPT(medico),MEDICOS->nome,SPACE(40)),[]),40)",;
     /* lin da formula*/    14,;
     /* col da formula*/    24;
                         };
)
AADD(sistema[08,O_FORMULA],{;          // GUIAS - Especialidade
     /* form mostrar  */    "LEFT(TRAN(IIF(!EMPT(medico),MEDICOS->especialid,SPACE(30)),[]),30)",;
     /* lin da formula*/    16,;
     /* col da formula*/    2;
                         };
)
AADD(sistema[08,O_FORMULA],{;          // GUIAS - Mensagem
     /* form mostrar  */    "LEFT(TRAN(IIF(!EMPT(medico),MEDICOS->mensagem,SPACE(60)),[]),60)",;
     /* lin da formula*/    17,;
     /* col da formula*/    2;
                         };
)
AADD(sistema[08,O_FORMULA],{;          // GUIAS - Valor Particula
     /* form mostrar  */    "LEFT(TRAN(IIF(!EMPT(medico),MEDICOS->valorpart,0),[@E 99,999,999.99]),13)",;
     /* lin da formula*/    18,;
     /* col da formula*/    23;
                         };
)
AADD(sistema[08,O_FORMULA],{;          // GUIAS - Valor c/Descont
     /* form mostrar  */    "LEFT(TRAN(IIF(!EMPT(medico),MEDICOS->ultvalor,0),[@E 99,999,999.99]),13)",;
     /* lin da formula*/    18,;
     /* col da formula*/    46;
                         };
)
AADD(sistema[08,O_FORMULA],{;          // GUIAS - Emiss„o
     /* form mostrar  */    "LEFT(TRAN(IIF(EMPT(emissao_),DATE(),emissao_),[@D]),08)",;
     /* lin da formula*/    1,;
     /* col da formula*/    43;
                         };
)
AADD(sistema[08,O_FORMULA],{;          // GUIAS - Por
     /* form mostrar  */    "LEFT(TRAN(IIF(EMPT(por),M->usuario,por),[]),10)",;
     /* lin da formula*/    1,;
     /* col da formula*/    52;
                         };
)
AADD(sistema[08,O_FORMULA],{;          // GUIAS - DC
     /* form mostrar  */    "LEFT(TRAN(GDV1(ano+numero),[9]),01)",;
     /* lin da formula*/    1,;
     /* col da formula*/    19;
                         };
)

* \\ Final de ADR_ATRI.PRG
/*
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
 \ Empresa.: PresServ Inform tica - Limeira (019)452.6623
 \ Programa: ADR_ESTR.PRG
 \ Data....: 29-01-04
 \ Sistema.: Administradora - RECEP€„O
 \ Funcao..: Cria estrutura dos arquivos
 \ Analista: Ademilson Pedro Bom
 \ Criacao.: GAS-Pro v4.0o
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/

#include "adrbig.ch"    // inicializa constantes manifestas

PROC BXR_estr     // estrutura do arquivo BXREC
DBCREATE(dbf,{;
               {"numero"    ,"C",  8, 0},; // 99999999
               {"codigo"    ,"C",  9, 0},; // @!
               {"cobranca"  ,"C", 18, 0},; // @!
               {"valorpg"   ,"N",  9, 2},; // @E 999,999.99
               {"valoraux"  ,"N",  9, 2},; // @E 999,999.99
               {"emitido_"  ,"D",  8, 0},; // @D
               {"por"       ,"C", 10, 0},; // 
               {"numop"     ,"C",  6, 0},; // 999999
               {"grupo"     ,"C",  2, 0},; // !9
               {"filial"    ,"C",  2, 0},; // @!
               {"intlan"    ,"C",  8, 0};  // 99999999
             };
)
RETU

PROC ALE_estr     // estrutura do arquivo ALENDER
DBCREATE(dbf,{;
               {"codigo"    ,"C",  9, 0},; // @!
               {"numero"    ,"C",  8, 0},; // 99999999
               {"endereco"  ,"C", 35, 0},; // 
               {"bairro"    ,"C", 25, 0},; // 
               {"cidade"    ,"C", 25, 0},; // 
               {"uf"        ,"C",  2, 0},; // !!
               {"cep"       ,"C",  8, 0},; // @R 99999-999
               {"telefone"  ,"C", 14, 0},; // @!
               {"cobrador"  ,"C",  3, 0},; // !!!
               {"data_"     ,"D",  8, 0},; // @D
               {"por"       ,"C", 10, 0},; // 
               {"dendereco" ,"C", 35, 0},; // 
               {"dbairro"   ,"C", 25, 0},; // 
               {"dcidade"   ,"C", 25, 0},; // 
               {"duf"       ,"C",  2, 0},; // !!
               {"dcep"      ,"C",  8, 0},; // @R 99999-999
               {"dtelefone" ,"C", 14, 0},; // @!
               {"dcobrador" ,"C",  3, 0},; // !!!
               {"dgrupo"    ,"C",  2, 0},; // 
               {"emitido_"  ,"D",  8, 0},; // @D
               {"filial"    ,"C",  2, 0};  // @!
             };
)
RETU

PROC OBX_estr     // estrutura do arquivo OBXEC
DBCREATE(dbf,{;
               {"numero"    ,"C",  8, 0},; // 99999999
               {"codigo"    ,"C",  9, 0},; // @!
	       {"cobranca"  ,"C", 25, 0},; // @!
               {"valorpg"   ,"N",  9, 2},; // @E 999,999.99
               {"valoraux"  ,"N",  9, 2},; // @E 999,999.99
               {"emitido_"  ,"D",  8, 0},; // @D
               {"por"       ,"C", 10, 0},; // 
               {"numop"     ,"C",  6, 0},; // 999999
               {"grupo"     ,"C",  2, 0},; // !9
               {"filial"    ,"C",  2, 0},; // @!
               {"intlan"    ,"C",  8, 0};  // 99999999
             };
)
RETU

PROC GRU_estr     // estrutura do arquivo GRUPOS
DBCREATE(dbf,{;
               {"codigo"    ,"C", 10, 0},; // @!
               {"grupo"     ,"C",  2, 0},; // !!
               {"situacao"  ,"C",  1, 0},; // 9
               {"nome"      ,"C", 35, 0},; // @!
               {"nascto_"   ,"D",  8, 0},; // @D
               {"estcivil"  ,"C",  2, 0},; // !!
               {"cpf"       ,"C", 11, 0},; // @R 999.999.999-99
               {"rg"        ,"C", 20, 0},; // @!
               {"endereco"  ,"C", 35, 0},; // @!
               {"bairro"    ,"C", 20, 0},; // @!
               {"cidade"    ,"C", 25, 0},; // @!
               {"uf"        ,"C",  2, 0},; // !!
               {"cep"       ,"C",  8, 0},; // @R 99999-999
               {"natural"   ,"C", 25, 0},; // @K!
               {"relig"     ,"C", 20, 0},; // @!
               {"contato"   ,"C", 25, 0},; // @!
               {"telefone"  ,"C", 14, 0},; // @!
               {"tipcont"   ,"C",  2, 0},; // 99
               {"vlcarne"   ,"C",  3, 0},; // 
               {"formapgto" ,"C",  2, 0},; // 99
               {"seguro"    ,"N",  2, 0},; // 
               {"admissao"  ,"D",  8, 0},; // @D
               {"tcarencia" ,"D",  8, 0},; // @D
               {"saitxa"    ,"C",  4, 0},; // @R 99/99
               {"diapgto"   ,"C",  2, 0},; // 99
               {"vendedor"  ,"C",  3, 0},; // !!!
               {"regiao"    ,"C",  3, 0},; // 999
               {"cobrador"  ,"C",  3, 0},; // !!!
               {"obs"       ,"M", 10, 0},; // @S35
               {"renovar"   ,"D",  8, 0},; // @D
               {"funerais"  ,"N",  2, 0},; // 99
               {"circinic"  ,"C",  3, 0},; // 999
               {"ultcirc"   ,"C",  3, 0},; // 999
               {"qtcircs"   ,"N",  3, 0},; // 999
               {"qtcircpg"  ,"N",  3, 0},; // 999
               {"titular"   ,"C",  3, 0},; // 
               {"particv"   ,"N",  2, 0},; // 99
               {"particf"   ,"N",  2, 0},; // 99
               {"nrdepend"  ,"N",  2, 0},; // 99
               {"ultimp_"   ,"D",  8, 0},; // @D
               {"ender_"    ,"D",  8, 0},; // @D
               {"ultend"    ,"C", 10, 0},; //
               {"em_"       ,"D",  8, 0},; // @D    ****
               {"por"       ,"C", 10, 0},; // @!    ****
               {"atend1"    ,"C", 15, 0},; // @!    ****
               {"atend2"    ,"C", 15, 0},; // @!    ****
               {"ultnraux"  ,"C",  3, 0},; // @!    ****
               {"ultdtaux"  ,"D",  8, 0},; // @!    ****
               {"ultvlaux"  ,"N", 11, 2},; // @!    ****
               {"email"     ,"C", 50, 0},; //
               {"segmesref" ,"D",  8, 0},; // @!    ****
               {"segcodcob" ,"C",  3, 0},; // @!    ****
               {"segservcod","C",  3, 0},; // @!    ****
               {"nrsorteio" ,"C",  6, 0};  //       ****
             };
)
RETU

PROC TAX_estr     // estrutura do arquivo TAXAS
DBCREATE(dbf,{;
      	       {"codigo"    ,"C", 15, 0},; // @!
               {"cobranca"  ,"C", 18, 0},; // @!
               {"tipo"      ,"C",  1, 0},; // !
               {"circ"      ,"C",  3, 0},; // 999
               {"emissao_"  ,"D",  8, 0},; // @D
               {"valor"     ,"N",  9, 2},; // @E 999,999.99
               {"pgto_"     ,"D",  8, 0},; // @D
               {"valorpg"   ,"N",  9, 2},; // @E 999,999.99
               {"cobrador"  ,"C",  3, 0},; // !!!
               {"forma"     ,"C",  1, 0},; // !
               {"baixa_"    ,"D",  8, 0},; // @D
               {"por"       ,"C", 10, 0},; //
               {"stat"      ,"C",  1, 0},; // 9
               {"filial"    ,"C",  2, 0},; // @!
               {"flag_excl" ,"C",  1, 0},; // !
               {"codlan"    ,"C", 20, 0};  // !!!-99999999-999-999
             };
)
RETU

PROC ECO_estr     // estrutura do arquivo ECOB
DBCREATE(dbf,{;
               {"codigo"    ,"C",  9, 0},; // @!
               {"tipo"      ,"C",  1, 0},; // !
               {"endereco"  ,"C", 35, 0},; // @!
               {"bairro"    ,"C", 20, 0},; // @!
               {"cep"       ,"C",  8, 0},; // @R 99999-999
               {"cidade"    ,"C", 25, 0},; // @!
               {"uf"        ,"C",  2, 0},; // !!
               {"telefone"  ,"C", 14, 0},; // @!
               {"obs"       ,"C", 20, 0},; // 
               {"data_"     ,"D",  8, 0},; // @D
               {"flag_excl" ,"C",  1, 0};  // !
             };
)
RETU

PROC INS_estr     // estrutura do arquivo INSCRITS
DBCREATE(dbf,{;
	       {"codigo"    ,"C", 15, 0},; // @!
	       {"grau"      ,"C",  1, 0},; // 9
               {"seq"       ,"N",  2, 0},; // 99
               {"ehtitular" ,"C",  1, 0},; // !
               {"nome"      ,"C", 35, 0},; // @!
               {"nascto_"   ,"D",  8, 0},; // @D
               {"estcivil"  ,"C",  2, 0},; // 
               {"interdito" ,"C",  1, 0},; // !
               {"sexo"      ,"C",  1, 0},; // !
               {"tcarencia" ,"D",  8, 0},; // @D
               {"lancto_"   ,"D",  8, 0},; // @D
               {"vivofalec" ,"C",  1, 0},; // !
               {"falecto_"  ,"D",  8, 0},; // @D
               {"tipo"      ,"C",  3, 0},; // !!!
               {"procnr"    ,"C",  7, 0},; // @R 99999/99
               {"por"       ,"C", 10, 0},; // 
               {"flag_excl" ,"C",  1, 0},; //
               {"cpf"       ,"C", 15, 0},; //
               {"segmesref" ,"D",  8, 0},; // @!    ****
               {"segpercen" ,"N",  6, 2},; // @!    ****
               {"segcodcob" ,"C",  3, 0},; // @!    ****
               {"segservcod","C",  3, 0};  // !
             };
)
RETU

PROC GUI_estr     // estrutura do arquivo GUIAS
DBCREATE(dbf,{;
               {"numero"    ,"C",  8, 0},; // 99999999
               {"data"      ,"D",  8, 0},; // @D
               {"hora"      ,"C",  5, 0},; // 99:99
               {"filial"    ,"C",  2, 0},; // 
               {"login"     ,"C", 10, 0},; // 
               {"contrato"  ,"C",  9, 0},; // @!
               {"nome"      ,"C", 35, 0},; // @!
               {"inscrito"  ,"C", 18, 0},; // @!
               {"medico"    ,"C", 10, 0},; // @!
               {"por"       ,"C", 10, 0},; // 
               {"intlan"    ,"C",  8, 0};  // 99999999
             };
)
RETU

PROC AFU_estr     // estrutura do arquivo AFUNER
DBCREATE(dbf,{;
               {"processo"  ,"C",  5, 0},; // 99999
               {"proc2"     ,"C",  2, 0},; // 99
               {"filial"    ,"C",  2, 0},; // @!
               {"ocorr_"    ,"D",  8, 0},; // @D
               {"categ"     ,"C",  2, 0},; // !!
               {"contrato"  ,"C",  9, 0},; // @!
               {"grauparcon","C", 10, 0},; // 
               {"nomedec"   ,"C", 35, 0},; // @!
               {"ruadec"    ,"C", 35, 0},; // @!
               {"fonedec"   ,"C", 14, 0},; // @!
	       {"codigofal" ,"C", 15, 0},; //
               {"falecido"  ,"C", 35, 0},; // 
               {"ruares"    ,"C", 30, 0},; // 
               {"baires"    ,"C", 25, 0},; // 
               {"munres"    ,"C", 25, 0},; // 
               {"estres"    ,"C",  2, 0},; // !!
               {"nascto_"   ,"D",  8, 0},; // @D
               {"falecto_"  ,"D",  8, 0},; // @D
               {"horafal"   ,"C",  5, 0},; // 99:99
               {"ruafal"    ,"C", 30, 0},; // 
               {"municfal"  ,"C", 25, 0},; // 
               {"estfal"    ,"C",  2, 0},; // !!
               {"sepult_"   ,"D",  8, 0},; // @D
               {"horasepult","C",  5, 0},; // 99:99
               {"cemitsep"  ,"C", 30, 0},; // 
               {"funcresp"  ,"C",  3, 0},; // 999
               {"procpagto_","D",  8, 0},; // @D
               {"vlauxilio" ,"N", 14, 2},; // 99999999999.99
               {"pagtoem_"  ,"D",  8, 0},; // @D
               {"intlan"    ,"C",  8, 0};  // 99999999
             };
)
RETU

PROC IMP_estr     // estrutura do arquivo IMPPAR
DBCREATE(dbf,{;
               {"idmaq"     ,"C",  4, 0},; // @!
               {"base"      ,"C",  3, 0},; // @!
               {"docto"     ,"C", 12, 0},; // 
               {"codlan"    ,"C", 20, 0};  // !!!-99999999-999-999
             };
)
RETU

PROC MED_estr     // estrutura do arquivo MEDICOS
DBCREATE(dbf,{;
               {"ai"        ,"C",  5, 0},; // 
               {"codbenefic","C", 10, 0},; // 
               {"oldescrito","C",  5, 0},; // 
               {"oldclasse" ,"C",  3, 0},; // 
               {"prioridade","C",  2, 0},; // 
               {"status"    ,"C",  2, 0},; // !!
               {"oldespec"  ,"C", 50, 0},; // @!
               {"detalhes"  ,"M", 10, 0},; // @S35
               {"vantagens" ,"M", 10, 0},; // @S35
               {"condicoes" ,"M", 10, 0},; // @S35
               {"informutil","M", 10, 0},; // @S35
               {"nome"      ,"C", 50, 0},; // 
               {"endereco"  ,"C", 50, 0},; // 
               {"bairro"    ,"C", 30, 0},; // @!
               {"cidade"    ,"C", 30, 0},; // @!
               {"uf"        ,"C",  2, 0},; // !!
               {"cep"       ,"C",  8, 0},; // @R 99999-999
               {"contato"   ,"C", 50, 0},; // @!
               {"fonecom1"  ,"C", 15, 0},; // 
               {"fonecom2"  ,"C", 15, 0},; // @!
               {"fonecel"   ,"C", 15, 0},; // @!
               {"foneres1"  ,"C", 15, 0},; // @!
               {"email"     ,"C", 50, 0},; // @!
               {"fax"       ,"C", 15, 0},; // @!
               {"bip"       ,"C", 15, 0},; // @!
               {"fonesdiv"  ,"C", 30, 0},; // @!
               {"datainc"   ,"D",  8, 0},; // @D
               {"dataalt"   ,"D",  8, 0},; // @D
               {"codcidade" ,"C",  4, 0},; // 
               {"contrato"  ,"C", 10, 0},; // 
               {"flagetq"   ,"C", 10, 0},; // 
               {"codclasse" ,"C",  6, 0},; // 
               {"intlan"    ,"C",  8, 0};  // 99999999
             };
)
RETU

PROC TES_estr     // estrutura do arquivo TESPEC
DBCREATE(dbf,{;
               {"especialid","C", 30, 0},; // @!
               {"codlan"    ,"C", 20, 0};  // !!!-99999999-999-999
             };
)
RETU

PROC JUR_estr     // estrutura do arquivo JUROS
DBCREATE(dbf,{;
               {"tipo"      ,"C",  1, 0},; // 9
               {"multa"     ,"N",  5, 2},; // 99.99
               {"mltcaren"  ,"N",  3, 0},; // 999
               {"juros"     ,"N",  5, 3},; // 9.999
               {"jrscaren"  ,"N",  3, 0};  // 999
             };
)
RETU

PROC TFI_estr     // estrutura do arquivo TFILIAIS
DBCREATE(dbf,{;
               {"codigo"    ,"C",  2, 0},; // @!
               {"abrev"     ,"C", 25, 0},; // 
               {"nome"      ,"C", 50, 0},; // @!
               {"endereco"  ,"C", 50, 0},; // @!
               {"cidade"    ,"C", 50, 0},; // @!
               {"ref"       ,"M", 10, 0},; // @S35
               {"contato"   ,"C", 20, 0};  // @!
             };
)
RETU

PROC ARQ_estr     // estrutura do arquivo ARQGRUP
DBCREATE(dbf,{;
               {"grup"      ,"C",  2, 0},; // !!
               {"classe"    ,"C",  2, 0},; // 99
               {"inicio"    ,"C",  6, 0},; // 999999
               {"final"     ,"C",  6, 0},; // 999999
               {"acumproc"  ,"N",  2, 0},; // 99
               {"maxproc"   ,"N",  2, 0},; // 99
               {"cpadmiss"  ,"C",  1, 0},; // !
               {"periodic"  ,"N",  3, 0},; // 999
               {"qtdremir"  ,"N",  3, 0},; // 999
               {"poratend"  ,"C",  1, 0},; // !
               {"ultcirc"   ,"C",  3, 0},; // 999
               {"emissao_"  ,"D",  8, 0},; // @D
               {"procpend"  ,"N",  3, 0},; // 999
               {"contrat"   ,"N",  6, 0},; // 999999
               {"partic"    ,"N",  6, 0},; // 999999
               {"proxcirc"  ,"C",  3, 0};  // 999
             };
)
RETU

PROC REG_estr     // estrutura do arquivo REGIAO
DBCREATE(dbf,{;
               {"codigo"    ,"C",  3, 0},; // 999
               {"regiao"    ,"C", 30, 0},; // 
               {"cobrador"  ,"C",  3, 0};  // !!!
             };
)
RETU

PROC COB_estr     // estrutura do arquivo COBRADOR
DBCREATE(dbf,{;
               {"cobrador"  ,"C",  3, 0},; // !!!
               {"funcao"    ,"C",  1, 0},; // !
               {"nome"      ,"C", 30, 0},; // 
               {"endereco"  ,"C", 30, 0},; // 
               {"bairro"    ,"C", 20, 0},; // 
               {"cidade"    ,"C", 25, 0},; // 
               {"telefone"  ,"C", 14, 0},; // 
               {"cpf"       ,"C", 11, 0},; // @R 999.999.999-99
               {"obs"       ,"M", 10, 0},; // @S35
               {"percent"   ,"N",  5, 1},; // 999.9
               {"superv"    ,"C",  3, 0};  // !!!
             };
)
RETU

PROC CLA_estr     // estrutura do arquivo CLASSES
DBCREATE(dbf,{;
               {"classcod"  ,"C",  2, 0},; // 99
               {"descricao" ,"C", 35, 0},; // @!
               {"contrat"   ,"N",  6, 0},; // 999999
               {"prior"     ,"C",  1, 0},; // !
               {"vljoia"    ,"N", 11, 2},; // 99999999.99
               {"nrparc"    ,"N",  2, 0},; // 99
               {"parcger"   ,"N",  2, 0},; // 99
               {"vlmensal"  ,"N", 11, 2},; // 99999999.99
               {"vldepend"  ,"N", 11, 2},; // 99999999.99
               {"nrmesval"  ,"N",  2, 0},; // 99
               {"renvenc"   ,"C",  1, 0},; // !
               {"renuso"    ,"C",  1, 0},; // !
               {"vltotal"   ,"N", 11, 2};  // @E 99,999,999.99
             };
)
RETU

PROC CIR_estr     // estrutura do arquivo CIRCULAR
DBCREATE(dbf,{;
               {"grupo"     ,"C",  2, 0},; // !!
               {"circ"      ,"C",  3, 0},; // 999
               {"procpend"  ,"N",  2, 0},; // 99
               {"emissao_"  ,"D",  8, 0},; // @D
               {"mesref"    ,"C",  4, 0},; // @R 99/99
               {"valor"     ,"N",  9, 2},; // @E 999,999.99
               {"menscirc"  ,"C", 60, 0},; // @S35
               {"menscirc1" ,"C", 35, 0},; // 
               {"menscirc2" ,"C", 35, 0},; // 
               {"emitidos"  ,"N",  6, 0},; // 999999
               {"pagos"     ,"N",  6, 0},; // 999999
               {"cancelados","N",  6, 0},; // 999999
               {"lancto_"   ,"D",  8, 0},; // @D
               {"funcionar" ,"C", 10, 0},; // 
               {"impress_"  ,"D",  8, 0};  // @D
             };
)
RETU

PROC CPR_estr     // estrutura do arquivo CPRCIRC
DBCREATE(dbf,{;
               {"grupo"     ,"C",  2, 0},; // !!
               {"circ"      ,"C",  3, 0},; // 999
               {"processo"  ,"C",  9, 0},; // @R 99999/99/!!
               {"categ"     ,"C",  2, 0},; // !!
               {"num"       ,"C",  6, 0},; // 999999
               {"fal"       ,"C", 35, 0},; // @!
               {"ends"      ,"C", 40, 0},; // @!
               {"cids"      ,"C", 15, 0},; // @!
               {"dfal"      ,"D",  8, 0},; // @D
               {"flag_excl" ,"C",  1, 0};  // !
             };
)
RETU

PROC PRC_estr     // estrutura do arquivo PRCESSOS
DBCREATE(dbf,{;
               {"processo"  ,"C",  9, 0},; // @R 99999/99/!!
               {"categ"     ,"C",  2, 0},; // !!
               {"saiu"      ,"C",  3, 0},; // 
               {"grup"      ,"C",  2, 0},; // !!
               {"num"       ,"C",  6, 0},; // 999999
               {"grau"      ,"C",  1, 0},; // 9
               {"seq"       ,"N",  2, 0},; // 99
               {"seg"       ,"C", 35, 0},; // @!
               {"ends"      ,"C", 40, 0},; // @!
               {"cids"      ,"C", 15, 0},; // @!
               {"fal"       ,"C", 35, 0},; // @!
               {"sep"       ,"C", 35, 0},; // @!
               {"dfal"      ,"D",  8, 0},; // @D
               {"codlan"    ,"C", 20, 0};  // !!!-99999999-999-999
             };
)
RETU

PROC FNC_estr     // estrutura do arquivo FNCS
DBCREATE(dbf,{;
               {"codigo"    ,"C",  3, 0},; // 
               {"nome"      ,"C", 35, 0},; // @!
               {"profiss"   ,"C", 15, 0},; // @!
               {"nacional"  ,"C", 15, 0},; // @!
               {"estciv"    ,"C",  2, 0},; // !A
               {"nascto_"   ,"D",  8, 0},; // @D
               {"endereco"  ,"C", 30, 0},; // @!
               {"bairro"    ,"C", 25, 0},; // @!
               {"cidade"    ,"C", 25, 0},; // @!
               {"cpf"       ,"C", 11, 0},; // @R 999.999.999-99
               {"telefone"  ,"C", 14, 0},; // 
               {"percent"   ,"N",  5, 1},; // 999.9
               {"obs"       ,"M", 10, 0};  // @S35
             };
)
RETU

PROC HIS_estr     // estrutura do arquivo HISTORIC
DBCREATE(dbf,{;
               {"historico" ,"C",  3, 0},; // 999
               {"descricao" ,"C", 40, 0},; // 
               {"tipo"      ,"C",  1, 0},; // !
               {"origem"    ,"C",  3, 0},; // !!!
               {"recdesp"   ,"C",  1, 0},; // !
               {"codigo"    ,"C",  6, 0},; // @!
               {"intlan"    ,"C",  8, 0},; // 99999999
               {"codlan"    ,"C", 20, 0};  // !!!-99999999-999-999
             };
)
RETU

PROC CST_estr     // estrutura do arquivo CSTSEG
DBCREATE(dbf,{;
               {"emissao_"  ,"D",  8, 0},; // @D
               {"hora"      ,"C",  5, 0},; // 99:99
               {"quem"      ,"C", 10, 0},; // 
               {"historic"  ,"C",  3, 0},; // 999
               {"contrato"  ,"C",  6, 0},; // 999999
               {"complement","C", 35, 0},; // @!
               {"qtdade"    ,"N",  5, 0},; // 99999
               {"valor"     ,"N",  9, 2},; // 999999.99
               {"tipo"      ,"C",  1, 0},; // 9
               {"circ"      ,"C",  3, 0};  // 999
             };
)
RETU

PROC MEN_estr     // estrutura do arquivo MENSAG
DBCREATE(dbf,{;
               {"seq"       ,"C",  6, 0},; // 999999
               {"filtro"    ,"C",210, 0},; // @S50
               {"mens1"     ,"M", 10, 0},; // @S50
               {"lancto_"   ,"D",  8, 0},; // @D
               {"por"       ,"C", 10, 0};  // 
             };
)
RETU

PROC ORD_estr     // estrutura do arquivo ORDPGRC
DBCREATE(dbf,{;
               {"numop"     ,"C",  6, 0},; // 999999
               {"origem"    ,"C",  3, 0},; // !!!
               {"lancto_"   ,"D",  8, 0},; // @D
               {"por"       ,"C", 10, 0},; // 
               {"numconta"  ,"C", 10, 0},; // @!
               {"historico" ,"C",  3, 0},; // 999
               {"debcred"   ,"C",  1, 0},; // !
               {"valortotal","N", 11, 2},; // 99999999.99
               {"vencto_"   ,"D",  8, 0},; // @D
               {"documento" ,"C", 12, 0},; // @!
               {"nrdoctos"  ,"N",  5, 0},; // 99999
               {"complement","C", 35, 0},; // @!
               {"fechto_"   ,"D",  8, 0},; // @D
               {"fechpor"   ,"C", 10, 0},; // 
               {"autoriz_"  ,"D",  8, 0},; // @D
               {"autorpor"  ,"C", 10, 0},; // 
               {"numos"     ,"C",  7, 0},; // 9999999
               {"intlan"    ,"C",  8, 0},; // 99999999
               {"codlan"    ,"C", 20, 0};  // !!!-99999999-999-999
             };
)
RETU

PROC PAR_estr     // estrutura do arquivo PAR_ADM
DBCREATE(dbf,{;
               {"pgrupo"    ,"C",  2, 0},; // !!
               {"p_filial"  ,"C",  2, 0},; // @!
               {"pcontrato" ,"C",  6, 0},; // 999999
               {"pgrau"     ,"C",  1, 0},; // 9
               {"pseq"      ,"N",  2, 0},; // 99
               {"pverpag"   ,"C",  1, 0},; // !
               {"preplanc"  ,"C",  1, 0},; // !
               {"lastcodigo","C",  6, 0},; // 999999
               {"nrcanc"    ,"N",  6, 0},; // 999999
               {"nrreint"   ,"N",  6, 0},; // 999999
               {"contarec"  ,"C",  5, 0},; // @!
               {"contapag"  ,"C",  5, 0},; // @!
               {"histrccar" ,"C",  3, 0},; // 999
               {"histrcfcc" ,"C",  3, 0},; // 999
               {"histrcrec" ,"C",  3, 0},; // 999
               {"histpg"    ,"C",  3, 0},; // 999
               {"nrauxrec"  ,"C",  8, 0},; // @R 99-999999
               {"mcodigo"   ,"C",  6, 0},; // 999999
               {"mtipo"     ,"C",  1, 0},; // !
               {"mcirc"     ,"C",  3, 0},; // 999
               {"mgrupvip"  ,"C",  2, 0},; // !!
               {"combarra"  ,"C",  1, 0},; // !
               {"cinscr"    ,"C",  1, 0},; // !
               {"comfalec"  ,"C",  1, 0},; // !
               {"mproc1"    ,"C",  5, 0},; // 99999
               {"mproc2"    ,"C",  2, 0},; // 99
               {"mproc3"    ,"C",  2, 0},; // !!
               {"impnrrec"  ,"C",  5, 0},; // 99999
               {"procimp"   ,"C",  9, 0},; // @R 99999/99/!!
               {"pvalor"    ,"N",  9, 2},; // @E 999,999.99
               {"pcob"      ,"C",  3, 0},; // !!!
               {"mmesref"   ,"C",  4, 0},; // @R 99/99
               {"pnumfcc"   ,"C",  8, 0},; // 
               {"p_cidade"  ,"C", 25, 0},; // @!
               {"p_recp"    ,"C",  1, 0},; // !
               {"setup1"    ,"C", 40, 0},; // 
               {"cgcsetup"  ,"C", 14, 0},; // @R 99.999.999/9999-99
               {"setup2"    ,"C", 50, 0},; // 
               {"setup3"    ,"C", 50, 0};  // 
             };
)
RETU

PROC MFI_estr     // estrutura do arquivo MFILIAL
DBCREATE(dbf,{;
               {"filial"    ,"C",  2, 0},; // @!
               {"seq0"      ,"C",  6, 0},; // 999999
               {"data_"     ,"D",  8, 0},; // @D
               {"por"       ,"C", 10, 0},; // 
               {"codigo"    ,"C",  9, 0},; // @!
               {"tcarenc_"  ,"D",  8, 0},; // @D
               {"obs1"      ,"C", 50, 0},; // @!
               {"obs2"      ,"C", 50, 0},; // @!
               {"obs3"      ,"C", 50, 0},; // @!
               {"idxd"      ,"C", 15, 0},; // @!
               {"idxm"      ,"C", 15, 0};  // @!
             };
)
RETU

* \\ Final de ADR_ESTR.PRG
GAS-Pro v2.0
016017023067001002001001018000176001
 Seqch ³ Banco ³ Agˆncia ³ Numcheq ³       Valor
ÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄ
       ³       ³         ³         ³
       ³       ³         ³         ³
       ³       ³         ³         ³
       ³       ³         ³         ³
[Ÿ]
Inclus„o~~26006
Manuten‡„o~~27007
Consulta~~28008
[Ÿ]
 6 
 1 
p/N£mero

 1 
 2 
[Ÿ]
Cheques
Cheques







005







 0 
 0 
-1 
-1 
-1 
-1 
-1 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
numero
C
I
9999999
 7 
 7 
 0 
 0 
 0 
Lan‡amento N§






-1 
 0 


seqch
C
V
999
 3 
 3 
 3 
 2 
 0 
Seqch






 0 
 1 


banco
C
E
9999
 4 
 4 
 3 
 10 
 0 
Banco

!EMPT(banco)
Necess rio informar BANCO

Entre com o n£mero do banco

 0 
 0 


agencia
C
E
9999
 4 
 4 
 3 
 18 
 0 
Agˆncia

!EMPT(agencia)
Necess rio informar AGENCIA

Informe a agˆncia do cheque

 0 
 0 


numcheq
C
E
 
 7 
 7 
 3 
 28 
 0 
Numcheq

!EMPT(numcheq)
Necess rio informar NUMCHEQ

Digite o n£mero do cheque

 0 
 0 


valorch
N
E
99999999.99
 11 
 11 
 3 
 38 
 2 
Valor

valorch>0
VALOR n„o aceit vel

Informe o valor do cheque

 0 
 0 


 0 
 1 
BAIXAS
vlpagcheq
BAIXAS->vlpagcheq+valorch
BAIXAS->vlpagcheq-valorch



 0 
 0 
 0 
GAS-Pro v2.0
005018023069001001002001006000176001
 Contrato:
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄ
                                     ³ Circulares
                                     ³  Ini
                           Reg.:     ³  £lt
                                     ³  Qtd
 Admiss„o:           Sai Taxa:       ³
 Funerais:           Cobrador:       ³  Pend
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄ
  Cir Emiss„o     Valor   Pago em     Valor
[Ÿ]
Inclus„o~~26006
[Ÿ]
 37 
 1 


 1 
[Ÿ]
Consulta Contrato
Consulta Contrato
GRUPOS






006







-1 
 1 
-1 
-1 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
 0 
codigo
C
E
999999
 6 
 6 
 1 
 13 
 0 
Codigo

GRU_01F9()
CODIGO n„o aceit vel|N„o cadastrado na tabela de grupos

Entre com o n£mero do contrato

 0 
 0 


grupo
C
E
!9
 2 
 2 
 0 
 0 
 0 
Grupo






 0 
 0 


situacao
C
E
9
 1 
 1 
 0 
 0 
 0 
Situa‡„o

situacao $ [12]
SITUA€ŽO n„o aceit vel
[1]
Digite 1 para ativo ou 2 para cancelado
MTAB([1=Ativo|2=Cancelado],[SITUA€ŽO])
 0 
 0 


nome
C
E
 
 35 
 35 
 0 
 0 
 0 
Nome

!EMPT(nome)
Necess rio informar NOME



 0 
 0 


nascto_
D
E
@D
 8 
 8 
 0 
 0 
 0 
Nascto

 


Informe a data de nascimento do titular

 0 
 0 


estcivil
C
E
!!
 2 
 2 
 0 
 0 
 0 
Est Civil

(estcivil$tbestciv)
Informe Estado Civil|ou|Tecle F8 para consulta em tabela

Digite o Estado Civil do Titular
MTAB(tbestciv,[EST CIVIL])
 0 
 0 


cpf
C
E
@R 999.999.999-99
 11 
 14 
 0 
 0 
 0 
CPF

VDV2(cpf).OR.EMPT(cpf)
CPF nÆo aceit vel

Informe o CIC (CPF) do titular

 0 
 0 


rg
C
E
@!
 20 
 20 
 0 
 0 
 0 
R.G.

 


Informe o n£mero do documento do titular

 0 
 0 


endereco
C
E
 
 35 
 35 
 0 
 0 
 0 
Endere‡o

!EMPT(endereco)
Necess rio informar ENDERE€O do Titular

Informe o Endere‡o para correspondˆncias.|Rua,n£mero,apto, blocl, etc...

 0 
 0 


bairro
C
E
 
 20 
 20 
 0 
 0 
 0 
Bairro

!EMPT(bairro)
Necess rio informar BAIRRO do Titular



 0 
 0 


cidade
C
E
 
 25 
 25 
 0 
 0 
 0 
Cidade

!EMPT(cidade)
Necess rio informar MUNICIPIO para cobran‡a do Titular.



 0 
 0 


cep
C
E
@R 99999-999
 8 
 9 
 0 
 0 
 0 
CEP

!EMPT(cep)
Necess rio informar CEP do Titular |com 08 digitos



 0 
 0 


contato
C
E
@!
 25 
 25 
 0 
 0 
 0 
Contato

 




 0 
 0 


tipcont
C
E
99
 2 
 2 
 0 
 0 
 0 
TipCont

 


Qual a categoria do Contrato?|Tecle F8 para consulta em tabela
VDBF(6,13,20,77,'CLASSES',('classcod','descricao','vljoia'),1,'classcod',[])
 0 
 0 


vlcarne
C
E
 
 3 
 3 
 0 
 0 
 0 
Vlcarne

 




 0 
 0 


formapgto
C
E
99
 2 
 2 
 0 
 0 
 0 
FormaPgto

 


Informe a forma de pagamento desejada

 0 
 0 


seguro
N
E
 
 2 
 0 
 0 
 0 
 0 
Seguro






 0 
 0 


admissao
D
E
@D
 8 
 8 
 0 
 0 
 0 
Admiss„o

!EMPT(admissao)
Necess rio informar DATA DE ADMISSŽO
DATE()
Informe a data da Admiss„o neste contrato
DATE()
 0 
 0 


tcarencia
D
E
@D
 8 
 8 
 0 
 0 
 0 
T.Carˆncia

 




 0 
 0 


saitxa
C
E
@R 99/99
 4 
 5 
 0 
 0 
 0 
Saitxa

!EMPT(saitxa).AND.MMAA(saitxa) .or.nivelop==3
Necess rio informar SAITXA (MM/AA)
SUBSTR(DTOC(admissao+120),4,2)+RIGHT(DTOC(admissao+120),2)
Informe o Mˆs a sair a 1¦ Taxa.

 0 
 0 


vendedor
C
E
!!
 2 
 2 
 0 
 0 
 0 
Vendedor

PTAB(vendedor,'COBRADOR',1).OR.EMPT(vendedor)
VENDEDOR n„o existe na tabela



 0 
 0 


regiao
C
E
999
 3 
 3 
 0 
 0 
 0 
Regi„o

PTAB(regiao,'REGIAO',1).OR.EMPT(regiao)
REGIŽO n„o existe na tabela

Informe a regi„o ou tecle F8 para busca em tabela
VDBF(6,38,20,77,'REGIAO',{'codigo','regiao'},1,'codigo')
 0 
 0 


cobrador
C
E
!!
 2 
 2 
 0 
 0 
 0 
Cobrador

PTAB(cobrador,'COBRADOR',1)
COBRADOR n„o existe na tabela

Digite o c¢digo do COBRADOR que|receber  as Taxas deste contrato,|Tecle F8 para consultar os cobradores.
VDBF(6,39,20,77,'REGIAO',{'regiao','cobrador'},2,'cobrador',[!EMPT(cobrador)])
 0 
 0 


obs
M
E

 10 
 35 
 0 
 0 
 0 
Obs

 




 0 
 0 


renovar
D
E
@D
 8 
 8 
 0 
 0 
 0 
Renovar

 


Data final para renova‡Æo

 0 
 0 


funerais
N
E
99
 2 
 2 
 0 
 0 
 0 
Funerais

!(funerais<0)
FUNERAIS n„o aceit vel

N£mero de Funerais efetuados|para este processo

 0 
 0 


circinic
C
E
999
 3 
 3 
 0 
 0 
 0 
Circ.Inicial

circinic <=ARQGRUP->ultcirc .or. nivelop==3
CIRC.INICIAL maior que a £ltima|emitida para este Grupo.

Informe o n£mero da 1¦ Circular|que saiu para este contrato.

 0 
 0 


ultcirc
C
E
999
 3 
 3 
 0 
 0 
 0 
Ult.Circular

PTAB(grupo+ultcirc,'CIRCULAR',1).OR.ultcirc=[000].or.nivelop==3
Necess rio informar ULT.CIRCULAR

Entre com o £ltimo n£mero de circular|deste contrato.

 0 
 0 


qtcircs
N
E
999
 3 
 3 
 0 
 0 
 0 
Qt.Circulares

 


Informe a quantidade de Circulares|emitidas para este contrato.

 0 
 0 


qtcircpg
N
E
999
 3 
 3 
 0 
 0 
 0 
Circ.Pagas

 


Informe a quantidade de Circulares|pagas/retornadas deste contrato

 0 
 0 


titular
C
E
 
 3 
 3 
 0 
 0 
 0 
Titular






 0 
 0 


particv
N
E
99
 2 
 2 
 0 
 0 
 0 
Part.Vivos






 0 
 0 


particf
N
E
99
 2 
 2 
 0 
 0 
 0 
Part.Falecidos






 0 
 0 


nrdepend
N
E
99
 2 
 2 
 0 
 0 
 0 
N§ Depend.






 0 
 0 


ultimp_
D
E
@D
 8 
 8 
 0 
 0 
 0 
Ult.Impress.






 0 
 0 


ender_
D
E
@D
 8 
 8 
 0 
 0 
 0 
élt.alter.endere‡o






 0 
 0 


ultend
C
E
 
 10 
 10 
 0 
 0 
 0 
UltEnd






 0 
 0 


 13 
Circulares
IIF(PTAB(codigo,'TAXAS',1),BXR_01F9(),[])

 11 
 3 
 40 

Nome
nome

 3 
 2 
 35 

Endere‡o
endereco

 4 
 2 
 35 

Bairro
bairro

 5 
 2 
 25 

Cidade
cidade

 6 
 2 
 25 

CEP
cep
@R 99999-999
 6 
 28 
 9 

Admiss„o
admissao
@D
 7 
 12 
 8 

Saitxa
saitxa
@R 99/99
 7 
 32 
 5 

Funerais
funerais
99
 8 
 12 
 2 

Cobrador
cobrador
!!
 8 
 32 
 2 

Circ.Inicial
circinic
999
 4 
 46 
 3 

Ult.Circular
ultcirc
999
 5 
 46 
 3 

Qt.Circulares
qtcircs
999
 6 
 46 
 3 

 0 
 0 
 0 
 0 
procedure adr_estr
/*
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
 \ Empresa.: PresServ Inform tica - Limeira (019)452.6623
 \ Programa: ADR_ESTR.PRG
 \ Data....: 29-01-04
 \ Sistema.: Administradora - RECEP€„O
 \ Funcao..: Cria estrutura dos arquivos
 \ Analista: Ademilson Pedro Bom
 \ Criacao.: GAS-Pro v4.0o
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/

#include "adrbig.ch"    // inicializa constantes manifestas

PROC BXR_estr     // estrutura do arquivo BXREC
DBCREATE(dbf,{;
               {"numero"    ,"C",  8, 0},; // 99999999
               {"codigo"    ,"C",  9, 0},; // @!
               {"cobranca"  ,"C", 18, 0},; // @!
               {"valorpg"   ,"N",  9, 2},; // @E 999,999.99
               {"valoraux"  ,"N",  9, 2},; // @E 999,999.99
               {"emitido_"  ,"D",  8, 0},; // @D
               {"por"       ,"C", 10, 0},; // 
               {"numop"     ,"C",  6, 0},; // 999999
               {"grupo"     ,"C",  2, 0},; // !9
               {"filial"    ,"C",  2, 0},; // @!
               {"intlan"    ,"C",  8, 0};  // 99999999
             };
)
RETU

PROC ALE_estr     // estrutura do arquivo ALENDER
DBCREATE(dbf,{;
               {"codigo"    ,"C",  9, 0},; // @!
               {"numero"    ,"C",  8, 0},; // 99999999
               {"endereco"  ,"C", 35, 0},; // 
               {"bairro"    ,"C", 25, 0},; // 
               {"cidade"    ,"C", 25, 0},; // 
               {"uf"        ,"C",  2, 0},; // !!
               {"cep"       ,"C",  8, 0},; // @R 99999-999
               {"telefone"  ,"C", 14, 0},; // @!
               {"cobrador"  ,"C",  3, 0},; // !!!
               {"data_"     ,"D",  8, 0},; // @D
               {"por"       ,"C", 10, 0},; // 
               {"dendereco" ,"C", 35, 0},; // 
               {"dbairro"   ,"C", 25, 0},; // 
               {"dcidade"   ,"C", 25, 0},; // 
               {"duf"       ,"C",  2, 0},; // !!
               {"dcep"      ,"C",  8, 0},; // @R 99999-999
               {"dtelefone" ,"C", 14, 0},; // @!
               {"dcobrador" ,"C",  3, 0},; // !!!
               {"dgrupo"    ,"C",  2, 0},; // 
               {"emitido_"  ,"D",  8, 0},; // @D
               {"filial"    ,"C",  2, 0};  // @!
             };
)
RETU

PROC OBX_estr     // estrutura do arquivo OBXEC
DBCREATE(dbf,{;
               {"numero"    ,"C",  8, 0},; // 99999999
               {"codigo"    ,"C",  9, 0},; // @!
	       {"cobranca"  ,"C", 25, 0},; // @!
               {"valorpg"   ,"N",  9, 2},; // @E 999,999.99
               {"valoraux"  ,"N",  9, 2},; // @E 999,999.99
               {"emitido_"  ,"D",  8, 0},; // @D
               {"por"       ,"C", 10, 0},; // 
               {"numop"     ,"C",  6, 0},; // 999999
               {"grupo"     ,"C",  2, 0},; // !9
               {"filial"    ,"C",  2, 0},; // @!
               {"intlan"    ,"C",  8, 0};  // 99999999
             };
)
RETU

PROC GRU_estr     // estrutura do arquivo GRUPOS
DBCREATE(dbf,{;
               {"codigo"    ,"C", 10, 0},; // @!
               {"grupo"     ,"C",  2, 0},; // !!
               {"situacao"  ,"C",  1, 0},; // 9
               {"nome"      ,"C", 35, 0},; // @!
               {"nascto_"   ,"D",  8, 0},; // @D
               {"estcivil"  ,"C",  2, 0},; // !!
               {"cpf"       ,"C", 11, 0},; // @R 999.999.999-99
               {"rg"        ,"C", 20, 0},; // @!
               {"endereco"  ,"C", 35, 0},; // @!
               {"bairro"    ,"C", 20, 0},; // @!
               {"cidade"    ,"C", 25, 0},; // @!
               {"uf"        ,"C",  2, 0},; // !!
               {"cep"       ,"C",  8, 0},; // @R 99999-999
               {"natural"   ,"C", 25, 0},; // @K!
               {"relig"     ,"C", 20, 0},; // @!
               {"contato"   ,"C", 25, 0},; // @!
               {"telefone"  ,"C", 14, 0},; // @!
               {"tipcont"   ,"C",  2, 0},; // 99
               {"vlcarne"   ,"C",  3, 0},; // 
               {"formapgto" ,"C",  2, 0},; // 99
               {"seguro"    ,"N",  2, 0},; // 
               {"admissao"  ,"D",  8, 0},; // @D
               {"tcarencia" ,"D",  8, 0},; // @D
               {"saitxa"    ,"C",  4, 0},; // @R 99/99
               {"diapgto"   ,"C",  2, 0},; // 99
               {"vendedor"  ,"C",  3, 0},; // !!!
               {"regiao"    ,"C",  3, 0},; // 999
               {"cobrador"  ,"C",  3, 0},; // !!!
               {"obs"       ,"M", 10, 0},; // @S35
               {"renovar"   ,"D",  8, 0},; // @D
               {"funerais"  ,"N",  2, 0},; // 99
               {"circinic"  ,"C",  3, 0},; // 999
               {"ultcirc"   ,"C",  3, 0},; // 999
               {"qtcircs"   ,"N",  3, 0},; // 999
               {"qtcircpg"  ,"N",  3, 0},; // 999
               {"titular"   ,"C",  3, 0},; // 
               {"particv"   ,"N",  2, 0},; // 99
               {"particf"   ,"N",  2, 0},; // 99
               {"nrdepend"  ,"N",  2, 0},; // 99
               {"ultimp_"   ,"D",  8, 0},; // @D
               {"ender_"    ,"D",  8, 0},; // @D
               {"ultend"    ,"C", 10, 0},; //
               {"em_"       ,"D",  8, 0},; // @D    ****
               {"por"       ,"C", 10, 0},; // @!    ****
               {"atend1"    ,"C", 15, 0},; // @!    ****
               {"atend2"    ,"C", 15, 0},; // @!    ****
               {"ultnraux"  ,"C",  3, 0},; // @!    ****
               {"ultdtaux"  ,"D",  8, 0},; // @!    ****
               {"ultvlaux"  ,"N", 11, 2},; // @!    ****
               {"email"     ,"C", 50, 0},; //
               {"segmesref" ,"D",  8, 0},; // @!    ****
               {"segcodcob" ,"C",  3, 0},; // @!    ****
               {"segservcod","C",  3, 0},; // @!    ****
               {"nrsorteio" ,"C",  6, 0};  //       ****
             };
)
RETU

PROC TAX_estr     // estrutura do arquivo TAXAS
DBCREATE(dbf,{;
      	       {"codigo"    ,"C", 15, 0},; // @!
               {"cobranca"  ,"C", 18, 0},; // @!
               {"tipo"      ,"C",  1, 0},; // !
               {"circ"      ,"C",  3, 0},; // 999
               {"emissao_"  ,"D",  8, 0},; // @D
               {"valor"     ,"N",  9, 2},; // @E 999,999.99
               {"pgto_"     ,"D",  8, 0},; // @D
               {"valorpg"   ,"N",  9, 2},; // @E 999,999.99
               {"cobrador"  ,"C",  3, 0},; // !!!
               {"forma"     ,"C",  1, 0},; // !
               {"baixa_"    ,"D",  8, 0},; // @D
               {"por"       ,"C", 10, 0},; //
               {"stat"      ,"C",  1, 0},; // 9
               {"filial"    ,"C",  2, 0},; // @!
               {"flag_excl" ,"C",  1, 0},; // !
               {"codlan"    ,"C", 20, 0};  // !!!-99999999-999-999
             };
)
RETU

PROC ECO_estr     // estrutura do arquivo ECOB
DBCREATE(dbf,{;
               {"codigo"    ,"C",  9, 0},; // @!
               {"tipo"      ,"C",  1, 0},; // !
               {"endereco"  ,"C", 35, 0},; // @!
               {"bairro"    ,"C", 20, 0},; // @!
               {"cep"       ,"C",  8, 0},; // @R 99999-999
               {"cidade"    ,"C", 25, 0},; // @!
               {"uf"        ,"C",  2, 0},; // !!
               {"telefone"  ,"C", 14, 0},; // @!
               {"obs"       ,"C", 20, 0},; // 
               {"data_"     ,"D",  8, 0},; // @D
               {"flag_excl" ,"C",  1, 0};  // !
             };
)
RETU

PROC INS_estr     // estrutura do arquivo INSCRITS
DBCREATE(dbf,{;
	       {"codigo"    ,"C", 15, 0},; // @!
	       {"grau"      ,"C",  1, 0},; // 9
               {"seq"       ,"N",  2, 0},; // 99
               {"ehtitular" ,"C",  1, 0},; // !
               {"nome"      ,"C", 35, 0},; // @!
               {"nascto_"   ,"D",  8, 0},; // @D
               {"estcivil"  ,"C",  2, 0},; // 
               {"interdito" ,"C",  1, 0},; // !
               {"sexo"      ,"C",  1, 0},; // !
               {"tcarencia" ,"D",  8, 0},; // @D
               {"lancto_"   ,"D",  8, 0},; // @D
               {"vivofalec" ,"C",  1, 0},; // !
               {"falecto_"  ,"D",  8, 0},; // @D
               {"tipo"      ,"C",  3, 0},; // !!!
               {"procnr"    ,"C",  7, 0},; // @R 99999/99
               {"por"       ,"C", 10, 0},; // 
               {"flag_excl" ,"C",  1, 0},; //
               {"cpf"       ,"C", 15, 0},; //
               {"segmesref" ,"D",  8, 0},; // @!    ****
               {"segpercen" ,"N",  6, 2},; // @!    ****
               {"segcodcob" ,"C",  3, 0},; // @!    ****
               {"segservcod","C",  3, 0};  // !
             };
)
RETU

PROC GUI_estr     // estrutura do arquivo GUIAS
DBCREATE(dbf,{;
               {"numero"    ,"C",  8, 0},; // 99999999
               {"data"      ,"D",  8, 0},; // @D
               {"hora"      ,"C",  5, 0},; // 99:99
               {"filial"    ,"C",  2, 0},; // 
               {"login"     ,"C", 10, 0},; // 
               {"contrato"  ,"C",  9, 0},; // @!
               {"nome"      ,"C", 35, 0},; // @!
               {"inscrito"  ,"C", 18, 0},; // @!
               {"medico"    ,"C", 10, 0},; // @!
               {"por"       ,"C", 10, 0},; // 
               {"intlan"    ,"C",  8, 0};  // 99999999
             };
)
RETU

PROC AFU_estr     // estrutura do arquivo AFUNER
DBCREATE(dbf,{;
               {"processo"  ,"C",  5, 0},; // 99999
               {"proc2"     ,"C",  2, 0},; // 99
               {"filial"    ,"C",  2, 0},; // @!
               {"ocorr_"    ,"D",  8, 0},; // @D
               {"categ"     ,"C",  2, 0},; // !!
               {"contrato"  ,"C",  9, 0},; // @!
               {"grauparcon","C", 10, 0},; // 
               {"nomedec"   ,"C", 35, 0},; // @!
               {"ruadec"    ,"C", 35, 0},; // @!
               {"fonedec"   ,"C", 14, 0},; // @!
	       {"codigofal" ,"C", 15, 0},; //
               {"falecido"  ,"C", 35, 0},; // 
               {"ruares"    ,"C", 30, 0},; // 
               {"baires"    ,"C", 25, 0},; // 
               {"munres"    ,"C", 25, 0},; // 
               {"estres"    ,"C",  2, 0},; // !!
               {"nascto_"   ,"D",  8, 0},; // @D
               {"falecto_"  ,"D",  8, 0},; // @D
               {"horafal"   ,"C",  5, 0},; // 99:99
               {"ruafal"    ,"C", 30, 0},; // 
               {"municfal"  ,"C", 25, 0},; // 
               {"estfal"    ,"C",  2, 0},; // !!
               {"sepult_"   ,"D",  8, 0},; // @D
               {"horasepult","C",  5, 0},; // 99:99
               {"cemitsep"  ,"C", 30, 0},; // 
               {"funcresp"  ,"C",  3, 0},; // 999
               {"procpagto_","D",  8, 0},; // @D
               {"vlauxilio" ,"N", 14, 2},; // 99999999999.99
               {"pagtoem_"  ,"D",  8, 0},; // @D
               {"intlan"    ,"C",  8, 0};  // 99999999
             };
)
RETU

PROC IMP_estr     // estrutura do arquivo IMPPAR
DBCREATE(dbf,{;
               {"idmaq"     ,"C",  4, 0},; // @!
               {"base"      ,"C",  3, 0},; // @!
               {"docto"     ,"C", 12, 0},; // 
               {"codlan"    ,"C", 20, 0};  // !!!-99999999-999-999
             };
)
RETU

PROC MED_estr     // estrutura do arquivo MEDICOS
DBCREATE(dbf,{;
               {"ai"        ,"C",  5, 0},; // 
               {"codbenefic","C", 10, 0},; // 
               {"oldescrito","C",  5, 0},; // 
               {"oldclasse" ,"C",  3, 0},; // 
               {"prioridade","C",  2, 0},; // 
               {"status"    ,"C",  2, 0},; // !!
               {"oldespec"  ,"C", 50, 0},; // @!
               {"detalhes"  ,"M", 10, 0},; // @S35
               {"vantagens" ,"M", 10, 0},; // @S35
               {"condicoes" ,"M", 10, 0},; // @S35
               {"informutil","M", 10, 0},; // @S35
               {"nome"      ,"C", 50, 0},; // 
               {"endereco"  ,"C", 50, 0},; // 
               {"bairro"    ,"C", 30, 0},; // @!
               {"cidade"    ,"C", 30, 0},; // @!
               {"uf"        ,"C",  2, 0},; // !!
               {"cep"       ,"C",  8, 0},; // @R 99999-999
               {"contato"   ,"C", 50, 0},; // @!
               {"fonecom1"  ,"C", 15, 0},; // 
               {"fonecom2"  ,"C", 15, 0},; // @!
               {"fonecel"   ,"C", 15, 0},; // @!
               {"foneres1"  ,"C", 15, 0},; // @!
               {"email"     ,"C", 50, 0},; // @!
               {"fax"       ,"C", 15, 0},; // @!
               {"bip"       ,"C", 15, 0},; // @!
               {"fonesdiv"  ,"C", 30, 0},; // @!
               {"datainc"   ,"D",  8, 0},; // @D
               {"dataalt"   ,"D",  8, 0},; // @D
               {"codcidade" ,"C",  4, 0},; // 
               {"contrato"  ,"C", 10, 0},; // 
               {"flagetq"   ,"C", 10, 0},; // 
               {"codclasse" ,"C",  6, 0},; // 
               {"intlan"    ,"C",  8, 0};  // 99999999
             };
)
RETU

PROC TES_estr     // estrutura do arquivo TESPEC
DBCREATE(dbf,{;
               {"especialid","C", 30, 0},; // @!
               {"codlan"    ,"C", 20, 0};  // !!!-99999999-999-999
             };
)
RETU

PROC JUR_estr     // estrutura do arquivo JUROS
DBCREATE(dbf,{;
               {"tipo"      ,"C",  1, 0},; // 9
               {"multa"     ,"N",  5, 2},; // 99.99
               {"mltcaren"  ,"N",  3, 0},; // 999
               {"juros"     ,"N",  5, 3},; // 9.999
               {"jrscaren"  ,"N",  3, 0};  // 999
             };
)
RETU

PROC TFI_estr     // estrutura do arquivo TFILIAIS
DBCREATE(dbf,{;
               {"codigo"    ,"C",  2, 0},; // @!
               {"abrev"     ,"C", 25, 0},; // 
               {"nome"      ,"C", 50, 0},; // @!
               {"endereco"  ,"C", 50, 0},; // @!
               {"cidade"    ,"C", 50, 0},; // @!
               {"ref"       ,"M", 10, 0},; // @S35
               {"contato"   ,"C", 20, 0};  // @!
             };
)
RETU

PROC ARQ_estr     // estrutura do arquivo ARQGRUP
DBCREATE(dbf,{;
               {"grup"      ,"C",  2, 0},; // !!
               {"classe"    ,"C",  2, 0},; // 99
               {"inicio"    ,"C",  6, 0},; // 999999
               {"final"     ,"C",  6, 0},; // 999999
               {"acumproc"  ,"N",  2, 0},; // 99
               {"maxproc"   ,"N",  2, 0},; // 99
               {"cpadmiss"  ,"C",  1, 0},; // !
               {"periodic"  ,"N",  3, 0},; // 999
               {"qtdremir"  ,"N",  3, 0},; // 999
               {"poratend"  ,"C",  1, 0},; // !
               {"ultcirc"   ,"C",  3, 0},; // 999
               {"emissao_"  ,"D",  8, 0},; // @D
               {"procpend"  ,"N",  3, 0},; // 999
               {"contrat"   ,"N",  6, 0},; // 999999
               {"partic"    ,"N",  6, 0},; // 999999
               {"proxcirc"  ,"C",  3, 0};  // 999
             };
)
RETU

PROC REG_estr     // estrutura do arquivo REGIAO
DBCREATE(dbf,{;
               {"codigo"    ,"C",  3, 0},; // 999
               {"regiao"    ,"C", 30, 0},; // 
               {"cobrador"  ,"C",  3, 0};  // !!!
             };
)
RETU

PROC COB_estr     // estrutura do arquivo COBRADOR
DBCREATE(dbf,{;
               {"cobrador"  ,"C",  3, 0},; // !!!
               {"funcao"    ,"C",  1, 0},; // !
               {"nome"      ,"C", 30, 0},; // 
               {"endereco"  ,"C", 30, 0},; // 
               {"bairro"    ,"C", 20, 0},; // 
               {"cidade"    ,"C", 25, 0},; // 
               {"telefone"  ,"C", 14, 0},; // 
               {"cpf"       ,"C", 11, 0},; // @R 999.999.999-99
               {"obs"       ,"M", 10, 0},; // @S35
               {"percent"   ,"N",  5, 1},; // 999.9
               {"superv"    ,"C",  3, 0};  // !!!
             };
)
RETU

PROC CLA_estr     // estrutura do arquivo CLASSES
DBCREATE(dbf,{;
               {"classcod"  ,"C",  2, 0},; // 99
               {"descricao" ,"C", 35, 0},; // @!
               {"contrat"   ,"N",  6, 0},; // 999999
               {"prior"     ,"C",  1, 0},; // !
               {"vljoia"    ,"N", 11, 2},; // 99999999.99
               {"nrparc"    ,"N",  2, 0},; // 99
               {"parcger"   ,"N",  2, 0},; // 99
               {"vlmensal"  ,"N", 11, 2},; // 99999999.99
               {"vldepend"  ,"N", 11, 2},; // 99999999.99
               {"nrmesval"  ,"N",  2, 0},; // 99
               {"renvenc"   ,"C",  1, 0},; // !
               {"renuso"    ,"C",  1, 0},; // !
               {"vltotal"   ,"N", 11, 2};  // @E 99,999,999.99
             };
)
RETU

PROC CIR_estr     // estrutura do arquivo CIRCULAR
DBCREATE(dbf,{;
               {"grupo"     ,"C",  2, 0},; // !!
               {"circ"      ,"C",  3, 0},; // 999
               {"procpend"  ,"N",  2, 0},; // 99
               {"emissao_"  ,"D",  8, 0},; // @D
               {"mesref"    ,"C",  4, 0},; // @R 99/99
               {"valor"     ,"N",  9, 2},; // @E 999,999.99
               {"menscirc"  ,"C", 60, 0},; // @S35
               {"menscirc1" ,"C", 35, 0},; // 
               {"menscirc2" ,"C", 35, 0},; // 
               {"emitidos"  ,"N",  6, 0},; // 999999
               {"pagos"     ,"N",  6, 0},; // 999999
               {"cancelados","N",  6, 0},; // 999999
               {"lancto_"   ,"D",  8, 0},; // @D
               {"funcionar" ,"C", 10, 0},; // 
               {"impress_"  ,"D",  8, 0};  // @D
             };
)
RETU

PROC CPR_estr     // estrutura do arquivo CPRCIRC
DBCREATE(dbf,{;
               {"grupo"     ,"C",  2, 0},; // !!
               {"circ"      ,"C",  3, 0},; // 999
               {"processo"  ,"C",  9, 0},; // @R 99999/99/!!
               {"categ"     ,"C",  2, 0},; // !!
               {"num"       ,"C",  6, 0},; // 999999
               {"fal"       ,"C", 35, 0},; // @!
               {"ends"      ,"C", 40, 0},; // @!
               {"cids"      ,"C", 15, 0},; // @!
               {"dfal"      ,"D",  8, 0},; // @D
               {"flag_excl" ,"C",  1, 0};  // !
             };
)
RETU

PROC PRC_estr     // estrutura do arquivo PRCESSOS
DBCREATE(dbf,{;
               {"processo"  ,"C",  9, 0},; // @R 99999/99/!!
               {"categ"     ,"C",  2, 0},; // !!
               {"saiu"      ,"C",  3, 0},; // 
               {"grup"      ,"C",  2, 0},; // !!
               {"num"       ,"C",  9, 0},; // 999999
               {"grau"      ,"C",  1, 0},; // 9
               {"seq"       ,"N",  2, 0},; // 99
               {"seg"       ,"C", 35, 0},; // @!
               {"ends"      ,"C", 40, 0},; // @!
               {"cids"      ,"C", 15, 0},; // @!
               {"fal"       ,"C", 35, 0},; // @!
               {"sep"       ,"C", 35, 0},; // @!
               {"dfal"      ,"D",  8, 0},; // @D
               {"codlan"    ,"C", 20, 0};  // !!!-99999999-999-999
             };
)
RETU

PROC FNC_estr     // estrutura do arquivo FNCS
DBCREATE(dbf,{;
               {"codigo"    ,"C",  3, 0},; // 
               {"nome"      ,"C", 35, 0},; // @!
               {"profiss"   ,"C", 15, 0},; // @!
               {"nacional"  ,"C", 15, 0},; // @!
               {"estciv"    ,"C",  2, 0},; // !A
               {"nascto_"   ,"D",  8, 0},; // @D
               {"endereco"  ,"C", 30, 0},; // @!
               {"bairro"    ,"C", 25, 0},; // @!
               {"cidade"    ,"C", 25, 0},; // @!
               {"cpf"       ,"C", 11, 0},; // @R 999.999.999-99
               {"telefone"  ,"C", 14, 0},; // 
               {"percent"   ,"N",  5, 1},; // 999.9
               {"obs"       ,"M", 10, 0};  // @S35
             };
)
RETU

PROC HIS_estr     // estrutura do arquivo HISTORIC
DBCREATE(dbf,{;
               {"historico" ,"C",  3, 0},; // 999
               {"descricao" ,"C", 40, 0},; // 
               {"tipo"      ,"C",  1, 0},; // !
               {"origem"    ,"C",  3, 0},; // !!!
               {"recdesp"   ,"C",  1, 0},; // !
               {"codigo"    ,"C",  6, 0},; // @!
               {"intlan"    ,"C",  8, 0},; // 99999999
               {"codlan"    ,"C", 20, 0};  // !!!-99999999-999-999
             };
)
RETU

PROC CST_estr     // estrutura do arquivo CSTSEG
DBCREATE(dbf,{;
               {"emissao_"  ,"D",  8, 0},; // @D
               {"hora"      ,"C",  5, 0},; // 99:99
               {"quem"      ,"C", 10, 0},; // 
               {"historic"  ,"C",  3, 0},; // 999
               {"contrato"  ,"C",  6, 0},; // 999999
               {"complement","C", 35, 0},; // @!
               {"qtdade"    ,"N",  5, 0},; // 99999
               {"valor"     ,"N",  9, 2},; // 999999.99
               {"tipo"      ,"C",  1, 0},; // 9
               {"circ"      ,"C",  3, 0};  // 999
             };
)
RETU

PROC MEN_estr     // estrutura do arquivo MENSAG
DBCREATE(dbf,{;
               {"seq"       ,"C",  6, 0},; // 999999
               {"filtro"    ,"C",210, 0},; // @S50
               {"mens1"     ,"M", 10, 0},; // @S50
               {"lancto_"   ,"D",  8, 0},; // @D
               {"por"       ,"C", 10, 0};  // 
             };
)
RETU

PROC ORD_estr     // estrutura do arquivo ORDPGRC
DBCREATE(dbf,{;
               {"numop"     ,"C",  6, 0},; // 999999
               {"origem"    ,"C",  3, 0},; // !!!
               {"lancto_"   ,"D",  8, 0},; // @D
               {"por"       ,"C", 10, 0},; // 
               {"numconta"  ,"C", 10, 0},; // @!
               {"historico" ,"C",  3, 0},; // 999
               {"debcred"   ,"C",  1, 0},; // !
               {"valortotal","N", 11, 2},; // 99999999.99
               {"vencto_"   ,"D",  8, 0},; // @D
               {"documento" ,"C", 12, 0},; // @!
               {"nrdoctos"  ,"N",  5, 0},; // 99999
               {"complement","C", 35, 0},; // @!
               {"fechto_"   ,"D",  8, 0},; // @D
               {"fechpor"   ,"C", 10, 0},; // 
               {"autoriz_"  ,"D",  8, 0},; // @D
               {"autorpor"  ,"C", 10, 0},; // 
               {"numos"     ,"C",  7, 0},; // 9999999
               {"intlan"    ,"C",  8, 0},; // 99999999
               {"codlan"    ,"C", 20, 0};  // !!!-99999999-999-999
             };
)
RETU

PROC PAR_estr     // estrutura do arquivo PAR_ADM
DBCREATE(dbf,{;
               {"pgrupo"    ,"C",  2, 0},; // !!
               {"p_filial"  ,"C",  2, 0},; // @!
               {"pcontrato" ,"C",  6, 0},; // 999999
               {"pgrau"     ,"C",  1, 0},; // 9
               {"pseq"      ,"N",  2, 0},; // 99
               {"pverpag"   ,"C",  1, 0},; // !
               {"preplanc"  ,"C",  1, 0},; // !
               {"lastcodigo","C",  6, 0},; // 999999
               {"nrcanc"    ,"N",  6, 0},; // 999999
               {"nrreint"   ,"N",  6, 0},; // 999999
               {"contarec"  ,"C",  5, 0},; // @!
               {"contapag"  ,"C",  5, 0},; // @!
               {"histrccar" ,"C",  3, 0},; // 999
               {"histrcfcc" ,"C",  3, 0},; // 999
               {"histrcrec" ,"C",  3, 0},; // 999
               {"histpg"    ,"C",  3, 0},; // 999
               {"nrauxrec"  ,"C",  8, 0},; // @R 99-999999
               {"mcodigo"   ,"C",  6, 0},; // 999999
               {"mtipo"     ,"C",  1, 0},; // !
               {"mcirc"     ,"C",  3, 0},; // 999
               {"mgrupvip"  ,"C",  2, 0},; // !!
               {"combarra"  ,"C",  1, 0},; // !
               {"cinscr"    ,"C",  1, 0},; // !
               {"comfalec"  ,"C",  1, 0},; // !
               {"mproc1"    ,"C",  5, 0},; // 99999
               {"mproc2"    ,"C",  2, 0},; // 99
               {"mproc3"    ,"C",  2, 0},; // !!
               {"impnrrec"  ,"C",  5, 0},; // 99999
               {"procimp"   ,"C",  9, 0},; // @R 99999/99/!!
               {"pvalor"    ,"N",  9, 2},; // @E 999,999.99
               {"pcob"      ,"C",  3, 0},; // !!!
               {"mmesref"   ,"C",  4, 0},; // @R 99/99
               {"pnumfcc"   ,"C",  8, 0},; // 
               {"p_cidade"  ,"C", 25, 0},; // @!
               {"p_recp"    ,"C",  1, 0},; // !
               {"setup1"    ,"C", 40, 0},; // 
               {"cgcsetup"  ,"C", 14, 0},; // @R 99.999.999/9999-99
               {"setup2"    ,"C", 50, 0},; // 
               {"setup3"    ,"C", 50, 0};  // 
             };
)
RETU

PROC MFI_estr     // estrutura do arquivo MFILIAL
DBCREATE(dbf,{;
               {"filial"    ,"C",  2, 0},; // @!
               {"seq0"      ,"C",  6, 0},; // 999999
               {"data_"     ,"D",  8, 0},; // @D
               {"por"       ,"C", 10, 0},; // 
               {"codigo"    ,"C",  9, 0},; // @!
               {"tcarenc_"  ,"D",  8, 0},; // @D
               {"obs1"      ,"C", 50, 0},; // @!
               {"obs2"      ,"C", 50, 0},; // @!
               {"obs3"      ,"C", 50, 0},; // @!
               {"idxd"      ,"C", 15, 0},; // @!
               {"idxm"      ,"C", 15, 0};  // @!
             };
)
RETU

* \\ Final de ADR_ESTR.PRG
/*
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
 \ Empresa.: Ind£stria de Urnas Bignotto Ltda
 \ Programa: ADM_R032.PRG
 \ Data....: 15-04-96
 \ Sistema.: Administradora de Funer rias
 \ Funcao..: Proc.Cancelamentos
 \ Analista: Ademilson Pedro Bom
 \ Criacao.: GAS-Pro v2.0d
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/

#include "admbig.ch"    // inicializa constantes manifestas

LOCAL dele_atu
PARA  lin_menu, col_menu
nucop=1

#ifdef COM_REDE
 IF !USEARQ("CANCELS",.t.,10,1)                    // se falhou a abertura do arq
  RETU                                             // volta ao menu anterior
 ENDI
#else
 USEARQ("CANCELS")                                 // abre o dbf e seus indices
#endi

titrel:=criterio:=cpord := ""                      // inicializa variaveis
titrel:=chv_rela:=chv_1:=chv_2 := ""
tps:=op_x:=ccop := 1
IF !opcoes_rel(lin_menu,col_menu,4,11)             // nao quis configurar...
 CLOS ALL                                          // fecha arquivos e
 RETU                                              // volta ao menu
ENDI
IF tps=2                                           // se vai para arquivo/video
 arq_=ARQGER()                                     // entao pega nome do arquivo
 IF EMPTY(arq_)                                    // se cancelou ou nao informou
  RETU                                             // retorna
 ENDI
ELSE
 arq_=drvporta                                     // porta de saida configurada
ENDI
SET PRINTER TO (arq_)                              // redireciona saida
criterio_=criterio                                 // salva criterio e ordenacao
cpord_=cpord                                       // definidos se huver
criterio=""

#ifdef COM_REDE
 IF !USEARQ("GRUPOS",.t.,10,1)                     // se falhou a abertura do arq
  RETU                                             // volta ao menu anterior
 ENDI
#else
 USEARQ("GRUPOS")                                  // abre o dbf e seus indices
#endi

PTAB(grupo,"ARQGRUP",1,.t.)                        // abre arquivo p/ o relacionamento
SET RELA TO grupo INTO ARQGRUP                     // relacionamento dos arquivos
cpord="cnumero"
INDTMP()

#ifdef COM_REDE
 IF !USEARQ("INSCRITS",.t.,10,1)                   // se falhou a abertura do arq
  RETU                                             // volta ao menu anterior
 ENDI
#else
 USEARQ("INSCRITS")                                // abre o dbf e seus indices
#endi

cpord="grupo+codigo"
INDTMP()

#ifdef COM_REDE
 IF !USEARQ("TAXAS",.t.,10,1)                      // se falhou a abertura do arq
  RETU                                             // volta ao menu anterior
 ENDI
#else
 USEARQ("TAXAS")                                   // abre o dbf e seus indices
#endi

PTAB(GRUPOS->grupo+circ,"CIRCULAR",1,.t.)          // abre arquivo p/ o relacionamento
PTAB(cobrador+CIRCULAR->mesref+GRUPOS->grupo+circ,"FCCOB",1,.t.)
SET RELA TO GRUPOS->grupo+circ INTO CIRCULAR,;     // relacionamento dos arquivos
         TO cobrador+CIRCULAR->mesref+GRUPOS->grupo+circ INTO FCCOB
cpord="codigo"
INDTMP()
criterio=criterio_                                 // restabelece criterio e
cpord=cpord_                                       // ordenacao definidos
SELE CANCELS
DBOX("[ESC] Interrompe",15,,,NAO_APAGA)
dele_atu:=SET(_SET_DELETED,.t.)                    // os excluidos nao servem...
SET DEVI TO PRIN                                   // inicia a impressao
maxli=62                                           // maximo de linhas no relatorio
BEGIN SEQUENCE
 DO WHIL ccop<=nucop                               // imprime qde copias pedida
  pg_=1; cl=999
  INI_ARQ()                                        // acha 1o. reg valido do arquivo
  ccop++                                           // incrementa contador de copias
  DO WHIL !EOF()
   IF INKEY()=K_ESC                                // se quer cancelar
    IF canc()                                      // pede confirmacao
     BREAK                                         // confirmou...
    ENDI
   ENDI
   IF EMPT(procto_)                                // se atender a condicao...
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY TRAN(cnumero,"999999")            // N£mero
    @ cl,007 SAY TRAN(cgrupo,"!9")                 // Grupo
    @ cl,013 SAY TRAN(ccodigo,"99999")             // Codigo
    @ cl,020 SAY TRAN(cmotivo,"!")                 // Motivo
    chv021=cgrupo+ccodigo
    SELE GRUPOS
    SEEK chv021
    IF FOUND()
     IF cl+2>maxli                                 // se cabecalho do arq filho
      REL_CAB(0)                                   // nao cabe nesta pagina
     ENDI                                          // salta para a proxima pagina
     cl+=1                                         // soma contador de linha
     @ cl,000 SAY REPL("-",78)
     DO WHIL ! EOF() .AND. chv021=LEFT(&(INDEXKEY(0)),LEN(chv021))
      IF INKEY()=K_ESC                             // se quer cancelar
       IF canc()                                   // pede confirmacao
        BREAK                                      // confirmou...
       ENDI
      ENDI
      IF GRUPOS->codigo==M->ccodigo                // se atender a condicao...
       REL_CAB(1)                                  // soma cl/imprime cabecalho
       IMPAC("Admiss„o......:",cl,000)
       @ cl,018 SAY TRAN(admissao,"@D")            // Admiss„o
       @ cl,028 SAY "Saitxa.:"
       @ cl,037 SAY TRAN(saitxa,"@R 99/99")        // Saitxa
       @ cl,044 SAY "Cobrador.:"
       @ cl,056 SAY cobrador                       // Cobrador
       REL_CAB(1)                                  // soma cl/imprime cabecalho
       @ cl,000 SAY "Funerais......:"
       @ cl,018 SAY TRAN(funerais,"99")            // Funerais
       @ cl,023 SAY "Vlcarne:"
       @ cl,032 SAY vlcarne                        // Vlcarne
       @ cl,037 SAY "Circ.Inicial.:"
       @ cl,052 SAY TRAN(circinic,"999")           // Circ.Inicial
       @ cl,057 SAY "Final.:"
       @ cl,065 SAY TRAN(ultcirc,"999")            // Ult.Circular
       REL_CAB(1)                                  // soma cl/imprime cabecalho
       IMPAC("Regi„o........:",cl,000)
       @ cl,018 SAY TRAN(regiao,"999")             // Regi„o
       @ cl,023 SAY "Circ.Emitidas:"
       @ cl,038 SAY TRAN(qtcircs,"999")            // Qt.Circulares
       @ cl,042 SAY "Pagas:"
       @ cl,049 SAY TRAN(qtcircpg,"999")           // Circ.Pagas
       REL_CAB(1)                                  // soma cl/imprime cabecalho
       @ cl,000 SAY "Titular.......:"
       @ cl,018 SAY titular                        // Titular
       @ cl,023 SAY "Nome...:"
       @ cl,032 SAY nome                           // Nome
       REL_CAB(1)                                  // soma cl/imprime cabecalho
       IMPAC("Endere‡o......:",cl,000)
       @ cl,018 SAY endereco                       // Endere‡o
       REL_CAB(1)                                  // soma cl/imprime cabecalho
       @ cl,000 SAY "Bairro........:"
       @ cl,018 SAY bairro                         // Bairro
       REL_CAB(1)                                  // soma cl/imprime cabecalho
       @ cl,000 SAY "Cidade........:"
       @ cl,018 SAY TRAN(cep,"@R 99999-999")       // CEP
       @ cl,029 SAY cidade                         // Cidade
       REL_CAB(1)                                  // soma cl/imprime cabecalho
       @ cl,000 SAY "Part.Vivos....:"
       @ cl,018 SAY TRAN(particv,"99")             // Part.Vivos
       @ cl,021 SAY "Part.Falecidos:"
       @ cl,039 SAY TRAN(particf,"99")             // Part.Falecidos
       chv022=grupo+codigo
       SELE INSCRITS
       SEEK chv022
       IF FOUND()
        IF cl+4>maxli                              // se cabecalho do arq filho
         REL_CAB(0)                                // nao cabe nesta pagina
        ENDI                                       // salta para a proxima pagina
        cl+=2                                      // soma contador de linha
        @ cl,000 SAY "Inscr. Seq Nome                                V/F Falecto. Tipo N§Processo"
        cl+=1                                      // soma contador de linha
        @ cl,000 SAY "====== === =================================== === ======== ==== =========="
        DO WHIL ! EOF() .AND. chv022=LEFT(&(INDEXKEY(0)),LEN(chv022))
         IF INKEY()=K_ESC                          // se quer cancelar
          IF canc()                                // pede confirmacao
           BREAK                                   // confirmou...
          ENDI
         ENDI
         REL_CAB(1)                                // soma cl/imprime cabecalho
         @ cl,000 SAY TRAN(grau,"9")               // Inscr.
         @ cl,008 SAY TRAN(seq,"99")               // Seq
         @ cl,011 SAY nome                         // Nome
         @ cl,047 SAY TRAN(vivofalec,"!")          // V/F
         @ cl,051 SAY TRAN(falecto_,"@D")          // Falecto.
         @ cl,060 SAY TRAN(tipo,"!!!")             // Tipo
         @ cl,065 SAY TRAN(procnr,"99999/99")      // N§Processo
         SKIP                                      // pega proximo registro
        ENDD
        cl+=3                                      // soma contador de linha
       ENDI
       SELE GRUPOS                                 // volta ao arquivo pai
       chv022=codigo
       SELE TAXAS
       SEEK chv022
       IF FOUND()
        IF cl+3>maxli                              // se cabecalho do arq filho
         REL_CAB(0)                                // nao cabe nesta pagina
        ENDI                                       // salta para a proxima pagina
        cl+=1                                      // soma contador de linha
        @ cl,000 SAY "Circular Emissao       Valor Pagamento Valor pago Cobrador Forma"
        cl+=1                                      // soma contador de linha
        @ cl,000 SAY "======== ======== ========== ========= ========== ======== ====="
        DO WHIL ! EOF() .AND. chv022=LEFT(&(INDEXKEY(0)),LEN(chv022))
         IF INKEY()=K_ESC                          // se quer cancelar
          IF canc()                                // pede confirmacao
           BREAK                                   // confirmou...
          ENDI
         ENDI
         REL_CAB(1)                                // soma cl/imprime cabecalho
         @ cl,000 SAY TRAN(circ,"999")             // Circular
         @ cl,009 SAY TRAN(emissao_,"@D")          // Emissao
         @ cl,018 SAY TRAN(valor,"@E 999,999.99")  // Valor
         @ cl,029 SAY TRAN(pgto_,"@D")             // Pagamento
         @ cl,039 SAY TRAN(valorpg,"@E 999,999.99")// Valor pago
         @ cl,050 SAY cobrador                     // Cobrador
         @ cl,059 SAY forma                        // Forma
         SKIP                                      // pega proximo registro
        ENDD
        cl+=3                                      // soma contador de linha
       ENDI
       SELE GRUPOS                                 // volta ao arquivo pai
       SKIP                                        // pega proximo registro
      ELSE                                         // se nao atende condicao
       SKIP                                        // pega proximo registro
      ENDI
     ENDD
     cl+=2                                         // soma contador de linha
    ENDI
    SELE CANCELS                                   // volta ao arquivo pai
    SKIP                                           // pega proximo registro
   ELSE                                            // se nao atende condicao
    SKIP                                           // pega proximo registro
   ENDI
  ENDD
 ENDD ccop
 EJEC                                              // salta pagina
END SEQUENCE
SET PRINTER TO (drvporta)                          // fecha arquivo gerado (se houver)
SET DEVI TO SCRE                                   // direciona saida p/ video
IF tps=2                                           // se vai para arquivo/video
 BROWSE_REL(arq_,2,3,MAXROW()-2,78)                // mostra o arquivo gravado
ENDI
GRELA(4)                                           // grava variacao do relatorio

#ifdef COM_REDE
 IF !USEARQ("CGRUPOS",.t.,10,1)                    // se falhou a abertura do arq
  RETU                                             // volta ao menu anterior
 ENDI
#else
 USEARQ("CGRUPOS")                                 // abre o dbf e seus indices
#endi


#ifdef COM_REDE
 IF !USEARQ("CINSCRIT",.t.,10,1)                   // se falhou a abertura do arq
  RETU                                             // volta ao menu anterior
 ENDI
#else
 USEARQ("CINSCRIT")                                // abre o dbf e seus indices
#endi


#ifdef COM_REDE
 IF !USEARQ("CTAXAS",.t.,10,1)                     // se falhou a abertura do arq
  RETU                                             // volta ao menu anterior
 ENDI
#else
 USEARQ("CTAXAS")                                  // abre o dbf e seus indices
#endi

msgt="PROCESSAMENTOS DO RELAT¢RIO|PROC.CANCELAMENTOS"
ALERTA()
op_=DBOX("Prosseguir|Cancelar opera‡„o",,,E_MENU,,msgt)
IF op_=1
 DBOX("Processando registros",,,,NAO_APAGA,"AGUARDE!")
 dele_atu:=SET(_SET_DELETED,.t.)                   // os excluidos nao servem...
 SELE CANCELS                                      // processamentos apos emissao
 INI_ARQ()                                         // acha 1o. reg valido do arquivo
 DO WHIL !EOF()
  IF EMPT(procto_)                                 // se atender a condicao...

   #ifdef COM_REDE
    REPBLO('CANCELS->procto_',date())
   #else
    REPL CANCELS->procto_ WITH date()
   #endi

   chv021=cgrupo+ccodigo
   SELE GRUPOS
   SEEK chv021
   IF FOUND()
    DO WHIL ! EOF() .AND. chv021=LEFT(&(INDEXKEY(0)),LEN(chv021))
     IF GRUPOS->codigo==M->ccodigo                 // se atender a condicao...
      SELE CGRUPOS                                 // arquivo alvo do lancamento

      #ifdef COM_REDE
       DO WHIL .t.
        APPE BLAN                                  // tenta abri-lo
        IF NETERR()                                // nao conseguiu
         DBOX(ms_uso,20)                           // avisa e
         LOOP                                      // tenta novamente
        ENDI
        EXIT                                       // ok. registro criado
       ENDD
      #else
       APPE BLAN                                   // cria registro em branco
      #endi

      SELE GRUPOS                                  // inicializa registro em branco
      REPL CGRUPOS->numero WITH M->cnumero,;
           CGRUPOS->grupo WITH M->cgrupo,;
           CGRUPOS->codigo WITH M->ccodigo,;
           CGRUPOS->situacao WITH [2],;
           CGRUPOS->motivo WITH M->cmotivo,;
           CGRUPOS->canclto_ WITH DATE(),;
           CGRUPOS->cancpor WITH M->usuario,;
           CGRUPOS->admissao WITH admissao,;
           CGRUPOS->saitxa WITH saitxa,;
           CGRUPOS->cobrador WITH cobrador,;
           CGRUPOS->funerais WITH funerais,;
           CGRUPOS->vlcarne WITH vlcarne,;
           CGRUPOS->circinic WITH circinic,;
           CGRUPOS->ultcirc WITH ultcirc,;
           CGRUPOS->regiao WITH regiao,;
           CGRUPOS->qtcircs WITH qtcircs,;
           CGRUPOS->qtcircpg WITH qtcircpg,;
           CGRUPOS->titular WITH titular,;
           CGRUPOS->nome WITH nome,;
           CGRUPOS->endereco WITH endereco,;
           CGRUPOS->bairro WITH bairro,;
           CGRUPOS->cidade WITH cidade,;
           CGRUPOS->cep WITH cep,;
           CGRUPOS->particv WITH particv,;
           CGRUPOS->particf WITH particf

      #ifdef COM_REDE
       CGRUPOS->(DBUNLOCK())                       // libera o registro
      #endi

       PARAMETROS('nrcanc',M->nrcanc+1)

      #ifdef COM_REDE
       REPBLO('ARQGRUP->contrat',ARQGRUP->contrat - 1)
       REPBLO('GRUPOS->situacao',[2])
       REPBLO('GRUPOS->admissao',CTOD([  /  /  ]))
       REPBLO('GRUPOS->cobrador',[ ])
       REPBLO('GRUPOS->titular',[ ])
       REPBLO('GRUPOS->nome',[ ])
       REPBLO('GRUPOS->endereco',[ ])
       REPBLO('GRUPOS->bairro',[ ])
       REPBLO('GRUPOS->cidade',[ ])
       REPBLO('GRUPOS->cep',[ ])
       REPBLO('GRUPOS->funerais',0)
       REPBLO('GRUPOS->qtcircs',0)
       REPBLO('GRUPOS->particv',0)
       REPBLO('GRUPOS->particf',0)
      #else
       PARAMETROS('nrcanc',M->nrcanc+1)
       REPL ARQGRUP->contrat WITH ARQGRUP->contrat - 1
       REPL GRUPOS->situacao WITH [2]
       REPL GRUPOS->admissao WITH CTOD([  /  /  ])
       REPL GRUPOS->cobrador WITH [ ]
       REPL GRUPOS->titular WITH [ ]
       REPL GRUPOS->nome WITH [ ]
       REPL GRUPOS->endereco WITH [ ]
       REPL GRUPOS->bairro WITH [ ]
       REPL GRUPOS->cidade WITH [ ]
       REPL GRUPOS->cep WITH [ ]
       REPL GRUPOS->funerais WITH 0
       REPL GRUPOS->qtcircs WITH 0
       REPL GRUPOS->particv WITH 0
       REPL GRUPOS->particf WITH 0
      #endi

      chv022=grupo+codigo
      SELE INSCRITS
      SEEK chv022
      IF FOUND()
       DO WHIL ! EOF() .AND. chv022=LEFT(&(INDEXKEY(0)),LEN(chv022))
        SELE CINSCRIT                              // arquivo alvo do lancamento

        #ifdef COM_REDE
         DO WHIL .t.
          APPE BLAN                                // tenta abri-lo
          IF NETERR()                              // nao conseguiu
           DBOX(ms_uso,20)                         // avisa e
           LOOP                                    // tenta novamente
          ENDI
          EXIT                                     // ok. registro criado
         ENDD
        #else
         APPE BLAN                                 // cria registro em branco
        #endi

        SELE INSCRITS                              // inicializa registro em branco
        REPL CINSCRIT->grupo WITH M->cgrupo,;
             CINSCRIT->codigo WITH M->Ccodigo,;
             CINSCRIT->grau WITH grau,;
             CINSCRIT->seq WITH seq,;
             CINSCRIT->nome WITH nome,;
             CINSCRIT->nascto_ WITH nascto_,;
             CINSCRIT->vivofalec WITH vivofalec,;
             CINSCRIT->falecto_ WITH falecto_,;
             CINSCRIT->tipo WITH tipo,;
             CINSCRIT->procnr WITH procnr

        #ifdef COM_REDE
         CINSCRIT->(DBUNLOCK())                    // libera o registro
        #endi


        #ifdef COM_REDE
         IF vivofalec=[V]
          REPBLO('ARQGRUP->partic',ARQGRUP->partic - 1)
         ENDI
        #else
         IF vivofalec=[V]
          REPL ARQGRUP->partic WITH ARQGRUP->partic - 1
         ENDI
        #endi

        DELE                                       // exclui registro processado
        SKIP                                       // pega proximo registro
       ENDD
      ENDI
      SELE GRUPOS                                  // volta ao arquivo pai
      chv022=codigo
      SELE TAXAS
      SEEK chv022
      IF FOUND()
       DO WHIL ! EOF() .AND. chv022=LEFT(&(INDEXKEY(0)),LEN(chv022))
        SELE CTAXAS                                // arquivo alvo do lancamento

        #ifdef COM_REDE
         DO WHIL .t.
          APPE BLAN                                // tenta abri-lo
          IF NETERR()                              // nao conseguiu
           DBOX(ms_uso,20)                         // avisa e
           LOOP                                    // tenta novamente
          ENDI
          EXIT                                     // ok. registro criado
         ENDD
        #else
         APPE BLAN                                 // cria registro em branco
        #endi

        SELE TAXAS                                 // inicializa registro em branco
        REPL CTAXAS->numero WITH M->cnumero,;
             CTAXAS->grupo WITH M->cgrupo,;
             CTAXAS->codigo WITH M->ccodigo,;
             CTAXAS->circ WITH circ,;
             CTAXAS->emissao_ WITH emissao_,;
             CTAXAS->valor WITH valor,;
             CTAXAS->pgto_ WITH IIF(EMPT(pgto_),DATE(),pgto_),;
             CTAXAS->valorpg WITH valorpg,;
             CTAXAS->cobrador WITH cobrador,;
             CTAXAS->forma WITH IIF(EMPT(forma),[C],forma),;
             CTAXAS->baixa_ WITH baixa_,;
             CTAXAS->por WITH por

        #ifdef COM_REDE
         CTAXAS->(DBUNLOCK())                      // libera o registro
        #endi


        #ifdef COM_REDE
         IF EMPT(pgto_)
          REPBLO('FCCOB->qtdret',FCCOB->qtdret + 1)
         ENDI
         IF EMPT(pgto_)
          REPBLO('CIRCULAR->cancelados',CIRCULAR->cancelados + 1)
         ENDI
        #else
         IF EMPT(pgto_)
          REPL FCCOB->qtdret WITH FCCOB->qtdret + 1
         ENDI
         IF EMPT(pgto_)
          REPL CIRCULAR->cancelados WITH CIRCULAR->cancelados + 1
         ENDI
        #endi

        DELE                                       // exclui registro processado
        SKIP                                       // pega proximo registro
       ENDD
      ENDI
      SELE GRUPOS                                  // volta ao arquivo pai
      SKIP                                         // pega proximo registro
     ELSE                                          // se nao atende condicao
      SKIP                                         // pega proximo registro
     ENDI
    ENDD
   ENDI
   SELE CANCELS                                    // volta ao arquivo pai
   SKIP                                            // pega proximo registro
  ELSE                                             // se nao atende condicao
   SKIP                                            // pega proximo registro
  ENDI
 ENDD
 SET(_SET_DELETED,.f.)                             // os excluidos serao vistos
 SELE INSCRITS                                     // arquivo origem do processamento
* PACK                                              // elimina os registros excluidos
 SELE TAXAS                                        // arquivo origem do processamento
* PACK                                              // elimina os registros excluidos
 ALERTA(2)
 DBOX("Processo terminado com sucesso!",,,,,msgt)
ENDI
SELE TAXAS                                         // salta pagina
SET RELA TO                                        // retira os relacionamentos
SELE GRUPOS                                        // salta pagina
SET RELA TO                                        // retira os relacionamentos
SET(_SET_DELETED,dele_atu)                         // os excluidos serao vistos
RETU

STATIC PROC REL_CAB(qt)                            // cabecalho do relatorio
IF qt>0                                            // se parametro maior que 0
 cl=cl+qt                                          // soma no contador de linhas
ENDI
IF cl>maxli .OR. qt=0                              // quebra de pagina
 IMPAC(nemp,0,000)                                 // nome da empresa
 @ 0,070 SAY "PAG"
 @ 0,074 SAY TRAN(pg_,'9999')                      // n£mero da p gina
 IMPAC(nsis,1,000)                                 // t¡tulo aplica‡„o
 @ 1,070 SAY "ADM_R032"                            // c¢digo relat¢rio
 @ 2,000 SAY "PROC.CANCELAMENTOS"
 @ 2,062 SAY NSEM(DATE())                          // dia da semana
 @ 2,070 SAY DTOC(DATE())                          // data do sistema
 @ 3,000 SAY titrel                                // t¡tulo a definir
 IMPAC("N£mero Grupo Codigo Motivo",4,000)
 @ 5,000 SAY REPL("-",78)
 cl=qt+5 ; pg_++
ENDI
RETU

* \\ Final de ADM_R032.PRG
#include "inkey.ch"
#include "setcurs.ch"
#include "dbinfo.ch"

* Esta rotina retorna apenas o caminho n„o retornando o drive
Static Static11,Static13:= {},Static14:= "1234567890ABCDEFGHIJKLMNOPQRSTUVWXYZ-. *$/+%",Static15:= {"412321214","214321214","414321212","212341214","412341212","214341212","212321414","412321412","214321412","212341412","412123214","214123214","414123212", ;
   "212143214","412143212","214143212","212123414","412123412","214123412","212143412","412121234","214121234","414121232","212141234","412141232","214141232","212121434","412121432","214121432","212141432","432121214","234121214","434121212", ;
   "232141214","432141212","234141212","232121414","432121412","234121412","232141412","232323212","232321232","232123232","212323232",Nil},Static16:= "0123456789",Static17:= "212",Static18:= "12121",Static19:= {"1112212","1122112","1121122","1222212", ;
   "1211122","1221112","1212222","1222122","1221222","1112122"},Static20:= {"1211222","1221122","1122122","1211112","1122212","1222112","1111212","1121112","1112112","1121222"},Static21:= {"2221121","2211221","2212211","2111121","2122211","2112221", ;
   "2121111","2111211","2112111","2221211"},Static22:= {"AAAAAA","AABABB","AABBAB","AABBBA","ABAABB","ABBAAB","ABBBAA","ABABAB","ABABBA","ABBABA"},Static23:= {"22442","42224","24224","44222","22424","42422","24422","22244","42242","24242",Nil}, ;
   Static24:= {"11331","31113","13113","33111","11313","31311","13311","11133","31131","13131",Nil}

*---------------------
*---------------------
function nomeexe()
local drive,path,exe
drive:=hb_curdrive()
path:=curdir()
exe=upper(alltrim(getenv("CMDLINE")))  // nao funciona
if " "$exe
   exe=left(exe,at(" ",exe))
endif
if !(".EXE"$exe .or. ".COM"$exe)
   if file(exe+".COM")
      exe=exe+".COM"
   else
      exe=exe+".EXE"
   endif
endif
return upper(drive+':\'+path+"\"+exe)

procedure setrhs
return .f.

procedure fileattrib
return 0

procedure impok
return .t.

procedure fontevga
return .t.

procedure fonetica
return ""

procedure conta
local i,quantos
quantos:=0
parameters oque,onde
for i=1 to len(onde)
   if substr(onde,i,len(oque))=oque
      quantos++
   end if
next
return quantos

procedure _conta
return


procedure ltoc(condicao)
if condicao
   return "T"
else
   return "F"
end if

procedure strseg
return 0

procedure string
return ""

procedure peek
return 0

procedure poke
return .t.

procedure ok_print(vlin)
if at('',vlin)>0 .or. at('',vlin)>0 .or.;
   at('',vlin)>0 .or. at('',vlin)>0 .or. at('',vlin)>0
   return .f.
else
   return .t.
endif

procedure callint
return .f.

function mkdir(vdiretorio) // falta
return .f. // dirmake(vdiretorio)==0

function rmdir(vdiretorio)
return dirremove(vdiretorio)

* procura a existencia de um diretorio
function chdir(vdiretorio)
return DirChange(vdiretorio)==0


procedure drive
return "AC"

procedure qdrive
return 2

procedure tamdisco
return 1000000 //DiskTotal()

procedure qualdir
return upper(LEFT(nomeexe(),RAT("\",nomeexe())))


function sepletra(string,espacos)
local resultado,i
resultado=""
for i=1 to len(string)
   resultado=resultado+substr(string,i,1)+space(espacos)
next
return resultado

procedure tamastr

procedure chdrive
return .f.

procedure hexa_dec

procedure alocamem

procedure qde_free

function vuf(estado)
if estado$"ACòALòAPòAMòBAòCEòDFòESòTOòGOòMAòMTòMSòMGòPAòPBòPRòPEòPIòRNòRSòRJòROòRRòSCòSPòSEòEX"
   return .t.
else
   return .f.
end if

procedure rwrite

return .f.

procedure ronly
return .f.

procedure dosdata(xdata)
* Seta a data do sistema
LOCAL cmd
cmd:="DATE "+xdata
RUN (cmd)
return DTOC(DATE())=xdata

procedure f_error
return 0

procedure is_ferror
return .f.

procedure clr_ferror
return .f.

procedure set_ferror
return .f.

Function BWISEAND(xArg1,xArg2)
   Local xVar1,xVar2
   xVar2:= {0,0,0,0,0,0,0,0}
   If (ValType(xArg1) = "C")
      xVar1:= Asc(xArg1)
   Else
      xVar1:= xArg1
   EndIf
   If (xVar1 >= 128)
      xVar2[8]:= 1
      xVar1:= xVar1-128
   EndIf
   If (xVar1 >= 64)
      xVar2[7]:= 1
      xVar1:= xVar1-64
   EndIf
   If (xVar1 >= 32)
      xVar2[6]:= 1
      xVar1:= xVar1-32
   EndIf
   If (xVar1 >= 16)
      xVar2[5]:= 1
      xVar1:= xVar1-16
   EndIf
   If (xVar1 >= 8)
      xVar2[4]:= 1
      xVar1:= xVar1-8
   EndIf
   If (xVar1 >= 4)
      xVar2[3]:= 1
      xVar1:= xVar1-4
   EndIf
   If (xVar1 >= 2)
      xVar2[2]:= 1
      xVar1:= xVar1-2
   EndIf
   If (xVar1 >= 1)
      xVar2[1]:= 1
   EndIf
   Return xVar2[xArg2+1]

Function DTOM(xArg1,xArg2)

   Local xVar1,xVar2,xVar3,xVar4,xVar5
   If (ValType(xArg1) = "D")
      xVar1:= DToC(xArg1)
   Else
      xVar1:= xArg1
   EndIf
   s_e_p:= SubStr(xVar1,3,1)
   If (Asc(s_e_p) >= 48 .AND. Asc(s_e_p) <= 57)
      s_e_p:= ""
   EndIf
   xVar2:= Val(SubStr(xVar1,1,2))
   xVar3:= Val(SubStr(xVar1,3+Len(s_e_p),2))
   xVar4:= Val(SubStr(xVar1,5+2*Len(s_e_p)))
   xVar5:= xVar4*365+Int((xVar4-1)/4)+(xVar3-1)*28+Val(SubStr("000303060811131619212426",(xVar3-1)*2+1,2))+xVar2
   If (xVar3 > 2 .AND. xVar4%4 = 0)
      xVar5++
   EndIf
   Return xVar5*1440+Val(Left(xArg2,2))*60+Val(SubStr(xArg2,4,2))

Function IMPGRANDE(xArg1,xArg2,xArg3,xArg4,xArg5,xArg6)
Return ""

Function EXTENSAO(xArg1)
Local xVar1
xVar1:= Upper(indexext())
xArg1:= IIf(xArg1 = Nil,.T.,xArg1)
If (!xArg1)
   If (xVar1 = ".NSX")  // de .CDX para .NSX
      xVar1:= ".SMT"    // de .FPT para .SMT
   Else
      xVar1:= ".DBT"
   EndIf
endIf
Return xVar1


Function IDATA(xArg1)
   Local xVar1,xVar2
   xArg1:= Trim(xArg1)
   xVar1:= Len(xArg1)
   If (xVar1 = 4)
      xVar2:= SubStr(xArg1,3,2)+SubStr(xArg1,1,2)
   Else
      If (xVar1 = 5)
         xVar2:= SubStr(xArg1,4,2)+SubStr(xArg1,3,1)+SubStr(xArg1,1,2)
      Else
         If (xVar1 = 6)
            If (Val(SubStr(xArg1,3,2)) > 12)
               xVar2:= SubStr(xArg1,3,4)+SubStr(xArg1,1,2)
            Else
               xVar2:= SubStr(xArg1,5,2)+SubStr(xArg1,3,2)+SubStr(xArg1,1,2)
            EndIf
         Else
            If (xVar1 = 7)
               xVar2:= SubStr(xArg1,4,4)+SubStr(xArg1,3,1)+SubStr(xArg1,1,2)
            Else
               If (xVar1 = 8)
                  If (Asc(SubStr(xArg1,3,1)) >= 48 .AND. Asc(SubStr(xArg1,3,1)) <= 57)
                     xVar2:= SubStr(xArg1,5,4)+SubStr(xArg1,3,2)+SubStr(xArg1,1,2)
                  Else
                     xVar2:= SubStr(xArg1,7,2)+SubStr(xArg1,3,1)+SubStr(xArg1,4,2)+SubStr(xArg1,3,1)+SubStr(xArg1,1,2)
                  EndIf
               Else
                  If (xVar1 = 10)
                     xVar2:= SubStr(xArg1,7,4)+SubStr(xArg1,3,1)+SubStr(xArg1,4,2)+SubStr(xArg1,3,1)+SubStr(xArg1,1,2)
                  Else
                     xVar2:= xArg1
                  EndIf
               EndIf
            EndIf
         EndIf
      EndIf
   EndIf
   Return xVar2

Function IMGPACK(xArg1)

   Local xVar1,xVar2,xVar3,xVar4,xVar5,xVar6,xVar7,xVar8,xVar9,xVar10,xVar11,xVar12
   xVar5:= xArg1+".dbi"
   xVar6:= xArg1+".bak"
   If (!file(xVar5))
      Return Nil
   EndIf
   xVar1:= fopen(xVar5)
   xVar2:= fcreate(xVar6)
   xVar11:= .T.
   Goto Top
   Do While (!EOF())
      For xVar4:= 1 To FCount()
         If (sistema[op_sis][12][xVar4][1] = "IMG" .AND. !Empty((xVar10:= FieldName(xVar4),&xVar10)))
            xVar12:= ""
            xVar3:= Asc(SubStr(&xVar10,5,1))*2+bin2l(Left(&xVar10,4))
            fseek(xVar1,xVar3)
            buffer_pcx:= Space(5)
            xVar7:= fread(xVar1,@buffer_pcx,5)
            If (xVar7 == 5)
               If (Asc(right(buffer_pcx,1)) == 0)
                  xVar8:= bin2l(Left(buffer_pcx,4))
                  xVar3:= fseek(xVar2,0,1)
                  xVar9:= Int(xVar3/2)
                  xVar3:= xVar3-xVar9*2
                  xVar12:= l2bin(xVar3)+Chr(xVar9)+Chr(0)
                  fwrite(xVar2,buffer_pcx,5)
                  For xVar9:= 1 To Int(xVar8/10000)
                     buffer_pcx:= Space(10000)
                     xVar7:= fread(xVar1,@buffer_pcx,10000)
                     If (xVar7 # 10000)
                        xVar12:= ""
                        Exit
                     EndIf
                     fwrite(xVar2,buffer_pcx,xVar7)
                  Next
                  xVar9:= xVar8-Int(xVar8/10000)*10000
                  buffer_pcx:= Space(xVar9)
                  xVar7:= fread(xVar1,@buffer_pcx,xVar9)
                  fwrite(xVar2,buffer_pcx,xVar7)
                  xVar11:= .F.
               EndIf
            EndIf
            Replace &xVar10 With xVar12
         EndIf
      Next
      Skip
   EndDo
   fclose(xVar1)
   fclose(xVar2)
   If (xVar11)
      Erase (xVar5)
   Else
      Copy File (xVar6) To (xVar5)
   EndIf
   Erase (xVar6)
   Return Nil

Function IMGEXTRAI()  // nao tratada
RETU ''

Function IMGGRAVA(xArg1,xArg2)

   Local xVar1,xVar2,xVar3,xVar4
   If (file(xArg1))
      xVar1:= fopen(xArg1,2)
   Else
      xVar1:= fcreate(xArg1)
   EndIf
   If (ferror() # 0)
      fclose(xVar1)
      Return "-1"
   EndIf
   fseek(xVar1,0,2)
   xVar3:= fseek(xVar1,0,1)
   xVar2:= fopen(xArg2)
   If (ferror() # 0)
      Return "-1"
   EndIf
   buffer_pcx:= Space(128)
   xVar4:= fread(xVar2,@buffer_pcx,128)
   If (xVar4 # 128 .AND. Asc(buffer_pcx) # 10 .AND. Asc(SubStr(buffer_pcx,3,1)) # 1)
      fclose(xVar1)
      fclose(xVar2)
      Return "-1"
   EndIf
   xVar4:= fseek(xVar2,0,2)
   fseek(xVar2,0)
   buffer_pcx:= l2bin(xVar4)+Chr(0)
   fwrite(xVar1,buffer_pcx,5)
   fseek(xVar2,0)
   xVar4:= 512
   Do While (xVar4 = 512)
      buffer_pcx:= Space(512)
      xVar4:= fread(xVar2,@buffer_pcx,512)
      fwrite(xVar1,buffer_pcx,xVar4)
   EndDo
   fclose(xVar1)
   fclose(xVar2)
   xVar4:= Int(xVar3/2)
   xVar3:= xVar3-xVar4*2
   Return l2bin(xVar3)+Chr(xVar4)+Chr(0)

Function CBEAN(xArg1,xArg2)

   Local xVar1,xVar2,xVar3,xVar4,xVar5
   xVar2:= "212"
   xVar3:= Len(xArg2)
   If (xArg1 == 1 .AND. !(xVar3 == 13))
      Return ""
   Else
      If (xArg1 == 2 .AND. !(xVar3 == 8))
         Return ""
      Else
         If (xArg1 == 3 .AND. !(xVar3 == 12))
            Return ""
         EndIf
      EndIf
   EndIf
   For xVar1:= 1 To xVar3
      If ((xVar4:= At(SubStr(xArg2,xVar1,1),Static16)) > 0)
         Do Case
         Case xArg1==1
            If (xVar1 == 1)
               xVar5:= Static22[xVar4]
            Else
               If (xVar1 <= 7)
                  If (SubStr(xVar5,xVar1-1,1) == "A")
                     xVar2:= xVar2+Static19[xVar4]
                  Else
                     xVar2:= xVar2+Static20[xVar4]
                  EndIf
               Else
                  If (xVar1 == 8)
                     xVar2:= xVar2+(Static18+Static21[xVar4])
                  Else
                     xVar2:= xVar2+Static21[xVar4]
                  EndIf
               EndIf
            EndIf
         Case xArg1==2
            If (xVar1 <= 4)
               xVar2:= xVar2+Static19[xVar4]
            Else
               If (xVar1 == 5)
                  xVar2:= xVar2+(Static18+Static21[xVar4])
               Else
                  xVar2:= xVar2+Static21[xVar4]
               EndIf
            EndIf
         Case xArg1==3
            If (xVar1 <= 6)
               xVar2:= xVar2+Static19[xVar4]
            Else
               If (xVar1 == 7)
                  xVar2:= xVar2+(Static18+Static21[xVar4])
               Else
                  xVar2:= xVar2+Static21[xVar4]
               EndIf
            EndIf
         EndCase
      EndIf
   Next
   xVar2:= xVar2+"212"
   Return LTrim(Str(xArg1))+xVar2

//-------------------------------------------------------------------
Function CB25INT(xArg1)

   Local xVar1,xVar2,xVar3,xVar4,xVar5,xVar6
   
   xVar2:= ""
   If (!(Int(Len(Trim(xArg1))%2) == 0))
      xArg1:= "0"+xArg1
   EndIf
   xVar3:= Len(xArg1)
   For xVar1:= 1 To xVar3 Step 2
      xVar5:= SubStr(xArg1,xVar1,1)
      xVar6:= SubStr(xArg1,xVar1+1,1)
      For xVar4:= 1 To 5
         xVar2:= xVar2+(SubStr(Static23[At(xVar5,Static16)],xVar4,1)+SubStr(Static24[At(xVar6,Static16)],xVar4,1))
      Next
   Next
   Return LTrim(Str(5))+"2121"+xVar2+"4121"

Function CB39(xArg1)

   Local xVar1,xVar2,xVar3,xVar4
   xVar2:= ""
   xArg1:= "*"+Upper(xArg1)+"*"
   xVar3:= Len(xArg1)
   For xVar1:= 1 To xVar3
      If ((xVar4:= At(SubStr(xArg1,xVar1,1),Static14)) > 0)
         xVar2:= xVar2+(Static15[xVar4]+"1")
      EndIf
   Next
   Return LTrim(Str(4))+xVar2

Function CODBARRAS(xArg1,xArg2,xArg3)

   Local xVar1,xVar2:= "",xVar3:= .T.,xVar4:= "",xVar5,xVar6,xVar7,xVar8,xVar9
   If (xArg2 == Nil)
      xArg2:= 10
   EndIf
   If (xArg3 == Nil)
      xArg3:= 6
   EndIf
   xArg3:= IIf(xArg3 = 6,12,9)
   xVar6:= IIf(drvpadrao < "4",240,IIf(drvpadrao == "4",180,300))
   nmesq:= Set(25)+xArg1[1][4]
   If (xVar3 = montabar(1))
      col_ant:= 0
      For xVar1:= 1 To Len(xArg1)
         xVar9:= 0
         If (xArg1[xVar1][2] == 1)
            xVar4:= cbean(1,xArg1[xVar1][1])
         Else
            If (xArg1[xVar1][2] == 2)
               xVar4:= cbean(2,xArg1[xVar1][1])
            Else
               If (xArg1[xVar1][2] == 3)
                  xVar4:= cb39(xArg1[xVar1][1])
               Else
                  If (xArg1[xVar1][2] == 4)
                     xVar4:= cb25int(xArg1[xVar1][1])
                  Else
                     If (xArg1[xVar1][2] == 5)
                        xVar4:= cbean(3,xArg1[xVar1][1])
                     EndIf
                  EndIf
               EndIf
            EndIf
         EndIf
         xVar5:= cbparc(xVar4,xArg1[xVar1][3],xArg2,xArg3,@xVar9)
         xVar2:= xVar2+xVar5
         If (xVar1 < Len(xArg1))
            xVar8:= xArg1[xVar1+1][4]-xArg1[xVar1][4]
            If (drvpadrao > "6")
               xVar2:= xVar2+(""+"&a+"+LTrim(Str(xVar8*720/xArg2-xVar9*10))+"H")
            Else
               If (drvpadrao = "4")
                  xVar2:= xVar2+Replicate(Chr(0)+Chr(0)+Chr(0),xVar8*xVar6/xArg2-Len(xVar5)/3)
               Else
                  If (drvpadrao $ "56")
                     xVar2:= xVar2+Replicate(Chr(0),xVar8*xVar6/xArg2-Len(xVar5)+4)
                  Else
                     xVar2:= xVar2+Replicate(Chr(0),xVar8*xVar6/xArg2-Len(xVar5))
                  EndIf
               EndIf
            EndIf
         EndIf
      Next
      If ((xVar3:= montabar(2,Chr(13)+Space(nmesq))) .AND. (xVar3:= codtudo(xVar2,nmesq,xArg2,xArg3,.F.)) .AND. xVar3)
         xVar3:= montabar(3)
      EndIf
      xVar7:= PRow()+1
      set_video:= Set(17,.F.)
      set_prn:= Set(23,.T.)
      For xVar1:= 1 To Len(Static13)
         ?? Static13[xVar1]
      Next
      If (drvpadrao > "6")
         ?
      EndIf
      Set Console (set_video)
      Set Printer (set_prn)
      setprc(xVar7,0)
   EndIf
   Return Nil

Function MAIUSC(xArg1)
   xArg1:= Upper(xArg1)
   For t:= 1 To 11
      xArg1:= strtran(xArg1,SubStr("‡ …ˆƒŠ‚„”¡",t,1),SubStr("€AEAEŽ™šI",t,1))
   Next
   Return xArg1

function paralela()
return .t.

function serial()
return .t.

function naopisca()
RETU NIL

Function NEXT_KEY
local x:= "POEHORA"
&x()
Return nextkey()

Function IN_KEY(xArg1)
   Local xVar1,xVar2,xVar3,xVar4,xVar5,xVar6,xVar7,xVar8,xVar9,xVar10,xVar11,xVar12,xVar13,xVar14,xVar15,xVar16,xVar17,xVar18
   xVar1:= 0
   Private msg_mac:= ""
   acao_mac:= IIf(Type("acao_mac") = "C",acao_mac,"!")
   If (acao_mac $ "LCA")
      Clear Typeahead
      If (fat_mac == 0)
         xVar1:= inky(0)
      Else
         If (fat_mac > 0 .AND. fat_mac < 10)
            xVar1:= inky(fat_mac*0.054)
         EndIf
      EndIf
      comando_ma(xVar1)
      If (acao_mac $ "Gg")
         xVar1:= 0
      Else
         buffer_mac:= "  "
         If (fread(handle_mac,@buffer_mac,2) # 2)
            fclose(handle_mac)
            If (acao_mac = "C")
               acao_mac:= "G"
               handle_mac:= fopen(arq_mac,1)
               fseek(handle_mac,0,2)
            Else
               acao_mac:= "D"
            EndIf
         Else
            keyb_mac(buffer_mac)
            xVar1:= nextkey()
            xVar5:= IIf(xArg1 = Nil,inky(),inky(xArg1))
            If (xVar1 = -39 .AND. Type("drvcorbox") = "C")
               tmp_mac:= " "
               xVar5:= fread(handle_mac,@tmp_mac,1)
               tmp_mac:= Asc(tmp_mac)-1
               msg_mac:= ""
               For j:= 1 To 512
                  buffer_mac:= " "
                  xVar5:= fread(handle_mac,@buffer_mac,1)
                  If (xVar5 = 1 .AND. Asc(buffer_mac) # 0)
                     msg_mac:= msg_mac+buffer_mac
                  Else
                     Exit
                  EndIf
               Next
               xVar17:= Row()
               xVar18:= Col()
               Save Screen
               alerta(1)
               xVar3:= acao_mac
               acao_mac:= "D"
               xVar4:= mold
               mold:= Replicate("Û",11)
               dbox(msg_mac,MaxRow()-3,Nil,tmp_mac)
               mold:= xVar4
               acao_mac:= xVar3
               Restore Screen
               @ xVar17,xVar18 Say ""
               xVar1:= IIf(LastKey() = 27,27,inky())
               comando_ma(xVar1)
               xVar1:= 0
            EndIf
         EndIf
      EndIf
   Else
      xVar1:= IIf(xArg1 = Nil,inky(),inky(xArg1))
      If (acao_mac $ "Gg")
         If (xVar1 == 10)
            alerta(1)
            acao_mac:= "D"
            fclose(handle_mac)
         Else
            If (xVar1 == 9)
               arq_i:= IIf("." $ arq_mac,Left(arq_mac,At(".",arq_mac)-1),arq_mac)+".$$$"
               If (file(arq_i))
                  pos_mac:= fseek(handle_mac,0,1)
                  handle_i:= fopen(arq_i,2)
                  xVar5:= 512
                  Do While (xVar5 = 512)
                     buffer_mac:= Space(512)
                     xVar5:= fread(handle_i,@buffer_mac,512)
                     fwrite(handle_mac,buffer_mac,xVar5)
                  EndDo
                  fclose(handle_mac)
                  fclose(handle_i)
                  Erase (arq_i)
                  handle_mac:= fopen(arq_mac,2)
                  fseek(handle_mac,pos_mac,0)
                  acao_mac:= "C"
               Else
                  acao_mac:= "G"
               EndIf
               xVar1:= 0
            Else
               fwrite(handle_mac,monta_buff(xVar1),2)
               If (xVar1 = -39 .AND. Type("drvcorbox") = "C")
                  xVar9:= SetKey(23,Nil)
                  xVar10:= SetKey(18,Nil)
                  xVar11:= SetKey(3,Nil)
                  xVar12:= SetKey(-6,Nil)
                  xVar13:= SetKey(-8,Nil)
                  xVar14:= SetKey(-7,Nil)
                  xVar15:= SetKey(19,Nil)
                  xVar16:= SetKey(4,Nil)
                  xVar3:= acao_mac
                  acao_mac:= "D"
                  xVar4:= mold
                  mold:= Replicate("Û",11)
                  msg_mac:= ""
                  xVar7:= brw
                  brw:= .T.
                  xVar17:= Row()
                  xVar18:= Col()
                  xVar8:= setcursor(3)
                  xVar6:= Select()
                  Select 0
                  Do While (.T.)
                     edimemo("msg_mac","MENSAGEM A SER APRESENTADA AO USURIO",15,5,23,76)
                     If (Len(msg_mac) > 0 .AND. LastKey() # 27)
                        msg1:= ""
                        For xVar5:= 1 To mlcount(msg_mac,70)
                           msg1:= msg1+("|"+alltrim(memoline(msg_mac,70,xVar5)))
                        Next
                        msg1:= SubStr(msg1,2)
                        If (Len(msg1) > 512 .OR. mlcount(msg_mac) > 20)
                           alerta(2)
                           dbox("M ximo de 512 caracteres ou 20 linhas!")
                           Loop
                        Else
                           xVar2:= dbox("Tempo de exposi‡„o",Nil,Nil,Nil,Nil,Nil,0,"99")
                           If (LastKey() == 27)
                              Loop
                           Else
                              msg1:= Chr(xVar2+1)+alltrim(msg1)+Chr(0)
                              If (fwrite(handle_mac,msg1) < Len(msg1))
                                 fclose(haldle_mac)
                                 Clear Screen
                                 readkill(.T.)
                                 getlist:= {}
                                 ? "Erro ao gravar mensagem na macro."
                                 Return
                              EndIf
                           EndIf
                        EndIf
                     EndIf
                     Exit
                  EndDo
                  Select (xVar6)
                  brw:= xVar7
                  mold:= xVar4
                  acao_mac:= xVar3
                  @ xVar17,xVar18 Say ""
                  setcursor(xVar8)
                  SetKey(23,xVar9)
                  SetKey(18,xVar10)
                  SetKey(3,xVar11)
                  SetKey(-6,xVar12)
                  SetKey(-8,xVar13)
                  SetKey(-7,xVar14)
                  SetKey(19,xVar15)
                  SetKey(4,xVar16)
               EndIf
            EndIf
         EndIf
      EndIf
   EndIf
   Return xVar1

//-------------------------------------------------------------------
Function INKY(xArg1)
   Local xVar1:= 0,xVar2,xVar3:= Seconds(),x
   Do While (.T.)
      xVar1:= InKey()
      x:= "POEHORA"
      &x()
      If (xArg1 = Nil .OR. xVar1 # 0)
         Exit
      Else
         If ((xVar2:= Seconds()-xVar3,xArg1 > 0 .AND. (xVar2 > xArg1 .OR. xVar2 < 0)))
            Exit
         EndIf
      EndIf
   EndDo

   Return xVar1

Procedure KEYB_MAC(xArg1)

//   poke(0,1050,30)
//   poke(0,1052,32)
//   poke(0,1054,Asc(xArg1))
//   poke(0,1055,Asc(SubStr(xArg1,2)))
   Return

Function MONTA_BUFF(xArg1)
   Local xVar1,xVar2
   If (xArg1 > 256)
      xVar1:= 0
      xVar2:= xArg1-256
   Else
      If (xArg1 > -1)
         xVar1:= xArg1
         xVar2:= 0
      Else
         If (xArg1 > -10)
            xVar1:= 0
            xVar2:= 59-xArg1
         Else
            If (xArg1 > -40)
               xVar1:= 0
               xVar2:= 74-xArg1
            Else
               xVar1:= 0
               xVar2:= 93-xArg1
            EndIf
         EndIf
      EndIf
   EndIf
   Return Chr(xVar1)+Chr(xVar2)

Procedure KEYBUFF(xArg1)

   If (IIf(Type("acao_mac") = "C",Upper(acao_mac) = "G" .OR. acao_mac = "D",.T.))
      Keyboard xArg1
   EndIf
   Return

Procedure POEHORA(xArg1,xArg2,xArg3)

   Local xVar1,xVar2,xVar3,xVar4
   If (Type("_ag_hora") = "C")
      If (Len(_ag_hora) == 0)
         _ag_hora:= "*"
         xVar4:= "ACAO_ALARME"
         &xVar4(.F.)
      Else
         If (_ag_hora # "*" .AND. Date() = _ag_data .AND. Left(Time(),5) >= _ag_hora)
            xVar4:= "ACAO_ALARME"
            &xVar4(.T.)
         EndIf
      EndIf
   EndIf
   If (xArg1 # Nil)
      xVar3:= .F.
      For xVar2:= 1 To Len(lin_h)
         If (lin_h[xVar2] = xArg1 .AND. col_h[xVar2] = xArg2)
            xVar3:= .T.
         EndIf
      Next
      If (!xVar3)
         AAdd(lin_h,xArg1)
         AAdd(col_h,xArg2)
         AAdd(for_h,xArg3)
         AAdd(tim_h,"")
      EndIf
   Else
      If (Type("lin_h") = "A" .AND. Len(lin_h) > 0)
         For xVar1:= 1 To Len(lin_h)
            If (tim_h[xVar1] # Left(Time(),for_h[xVar1]) .AND. (SubStr((xVar3:= SaveScreen(lin_h[xVar1],col_h[xVar1],lin_h[xVar1],col_h[xVar1]+for_h[xVar1]-1),xVar3),5,1) = ":" .OR. SubStr(xVar3,11,1) = ":"))
               tim_h[xVar1]:= Left(Time(),for_h[xVar1])
               For xVar2:= 0 To for_h[xVar1]-1
                  xVar4:= Asc(SubStr(xVar3,xVar2*2+1,1))
                  If (xVar4 >= 48 .AND. xVar4 <= 57)
                     xVar3:= Left(xVar3,xVar2*2)+SubStr(tim_h[xVar1],xVar2+1,1)+SubStr(xVar3,xVar2*2+2)
                  EndIf
               Next
               RestScreen(lin_h[xVar1],col_h[xVar1],lin_h[xVar1],col_h[xVar1]+for_h[xVar1]-1,xVar3)
            EndIf
         Next
      EndIf
   EndIf
   Return

Procedure RESTSCR(xArg1,xArg2,xArg3,xArg4,xArg5)

   Local xVar1,xVar2,xVar3,xVar4
   If (Type("lin_h") = "A" .AND. Len(lin_h) > 0)
      For xVar2:= 1 To Len(lin_h)
         If (!Empty(tim_h[xVar2]) .AND. xArg1 <= lin_h[xVar2] .AND. xArg3 >= lin_h[xVar2] .AND. xArg2 <= col_h[xVar2] .AND. xArg4 >= col_h[xVar2]+3 .AND. (SubStr((xVar3:= (xArg4-xArg2+1)*2,xVar4:= (lin_h[xVar2]-xArg1)*xVar3+1+(col_h[xVar2]-xArg2)*2, ;
               xArg5),xVar4+4) = ":" .OR. SubStr(xArg5,xVar4+10) = ":"))
            For xVar1:= 0 To for_h[xVar2]
               j:= Asc(SubStr(xArg5,xVar4+xVar1*2,1))
               If (j >= 48 .AND. j <= 57 .AND. !Empty(SubStr(tim_h[xVar2],xVar1+1,1)))
                  xArg5:= Left(xArg5,xVar4+xVar1*2-1)+SubStr(tim_h[xVar2],xVar1+1,1)+SubStr(xArg5,xVar4+xVar1*2+1)
               EndIf
            Next
         EndIf
      Next
   EndIf
   RestScreen(xArg1,xArg2,xArg3,xArg4,xArg5)
   Return

Function MUDA_PJ(xArg1,xArg2,xArg3,xArg4,xArg5,xArg6)
   Local xVar1:= cod_sos,xVar2:= "help",xVar3,xVar4:= SetColor(drvcorenf),xVar5
   drvmouse:= IIf(Type("drvmouse") # "L",.F.,drvmouse)
   l1:= c1:= li:= co:= 0
   cod_sos:= 1
   xVar3:= IIf(xArg6,0,1)
   xVar5:= SaveScreen(xArg1+xVar3,xArg2+xVar3,xArg3,xArg4-xVar3)
   dispbegin()
   Do While (.T.)
      @ MaxRow(), 0 Say padc("Utilize as setas para posicionar a janela. ("+gcr+" aceita posi‡„o)",80)
      dispend()
      If (drvmouse)
         l1:= xArg1+Int((xArg3-xArg1)/2)
         c1:= xArg2+Int((xArg4-xArg2)/2)
         mousebox(xArg1,xArg2,xArg3,xArg4)
         mousecur(.T.)
         te_:= 0
         mouseset(l1,c1)
         Do While (te_ = 0)
            pp:= mouseget(@li,@co)
            te_:= nextkey()
            If (pp = 1 .AND. te_ = 0)
               y_:= li-l1
               x_:= co-c1
               If (y_ > 0)
                  joganobuff("")
               Else
                  If (y_ < 0)
                     joganobuff("")
                  EndIf
               EndIf
               If (x_ > 0)
                  joganobuff("")
               Else
                  If (x_ < 0)
                     joganobuff("")
                  EndIf
               EndIf
            Else
               If (pp == 2)
                  joganobuff("")
               EndIf
            EndIf
         EndDo
         mousecur(.F.)
      EndIf
      If (Type("acao_mac") = "C")
         x:= "IN_KEY"
         te_:= &x(0)
      Else
         te_:= InKey(0)
      EndIf
      dispbegin()
      restscr(0,0,MaxRow(),79,xArg5)
      If (te_ = 27 .OR. te_ = 13)
         mon_jan_mo(xArg1,xVar3,xArg2,xArg3,xArg4,xVar5)
         dispend()
         Exit
      Else
         If (te_ = 19 .AND. xArg2 > 0)
            xArg2:= xArg2-1
            xArg4:= xArg4-1
         Else
            If (te_ = 4 .AND. xArg4 < 79)
               xArg2:= xArg2+1
               xArg4:= xArg4+1
            Else
               If (te_ = 5 .AND. xArg1 > 0)
                  xArg1:= xArg1-1
                  xArg3:= xArg3-1
               Else
                  If (te_ = 24 .AND. xArg3 < MaxRow())
                     xArg1:= xArg1+1
                     xArg3:= xArg3+1
                  Else
                     If (te_ = 28)
                        &xVar2()
                     EndIf
                  EndIf
               EndIf
            EndIf
         EndIf
      EndIf
      mon_jan_mo(xArg1,xVar3,xArg2,xArg3,xArg4,xVar5)
   EndDo
   Do While (mouseget(0,0) # 0)
   EndDo
   Set Color To (xVar4)
   cod_sos:= xVar1
   Return Nil

Procedure MON_JAN_MO(xArg1,xArg2,xArg3,xArg4,xArg5,xArg6)

   restscr(xArg1+xArg2,xArg3+xArg2,xArg4,xArg5-xArg2,xArg6)
   If (xArg3-1 >= 0 .AND. xArg4 < MaxRow())
      restscr(xArg1+1+xArg2,xArg3-1+xArg2,xArg4+1,xArg3-1+xArg2,Transform(SaveScreen(xArg1+1+xArg2,xArg3-1+xArg2,xArg4+1,xArg3-1+xArg2),Replicate("X",xArg4-xArg1+1+xArg2)))
      If (xArg3-2 >= 0)
         restscr(xArg1+1+xArg2,xArg3-2+xArg2,xArg4+1,xArg3-2+xArg2,Transform(SaveScreen(xArg1+1+xArg2,xArg3-2+xArg2,xArg4+1,xArg3-2+xArg2),Replicate("X",xArg4-xArg1+1+xArg2)))
      EndIf
      restscr(xArg4+1,xArg3+xArg2,xArg4+1,xArg5-2-xArg2,Transform(SaveScreen(xArg4+1,xArg3+xArg2,xArg4+1,xArg5-2+xArg2),Replicate("X",xArg5-xArg2-(xArg3+xArg2)-1)))
   EndIf
   Return

Function VDVCB(xArg1)
   Local xVar1,xVar2
   xVar1:= right(xArg1,1)
   xVar2:= Left(xArg1,Len(xArg1)-1)
   Return IIf(gdvcb(xVar2) = xVar1 .OR. Empty(xArg1),.T.,.F.)

Function GDVCB(xArg1)

   Local xVar1,xVar2,xVar3,xVar4
   xVar1:= xVar2:= xVar3:= 0
   xVar4:= Len(xArg1)
   For xVar1:= 1 To xVar4
      If (xVar1/2 = Int(xVar1/2))
         xVar3:= xVar3+Val(SubStr(xArg1,xVar1,1))
      Else
         xVar2:= xVar2+Val(SubStr(xArg1,xVar1,1))
      EndIf
   Next
   If (xVar4 == 7 .OR. xVar4 == 11)
      xVar2:= xVar2*3+xVar3
      xVar3:= Int((xVar2+9)/10)*10
      xVar4:= xVar3-xVar2
   Else
      xVar3:= xVar3*3+xVar2
      xVar2:= Int((xVar3+9)/10)*10
      xVar4:= xVar2-xVar3
   EndIf
   Return Str(xVar4,1)

Function INVCOR(xArg1)
   Return strtran(SubStr(xArg1,At("/",xArg1)+1),"*","+")+"/"+strtran(Left(xArg1,At("/",xArg1)-1),"+","*")

Function ERROMSG(xArg1)

   Local xVar1,xVar2,xVar3,xVar4,xVar5,xVar6,xVar7,xVar8,xVar9,xVar10,xVar11,xVar12,xVar13,xVar14[38],xVar15,xVar16:= IIf(Type("drvcorenf") = "C",drvcorenf,"W+/R")
   Private dbf_err,ntx_err
   If (xArg1:gencode() == 5)
      Return 0
   EndIf
   If ((xArg1:gencode() == 40 .OR. xArg1:gencode() == 21 .AND. xArg1:oscode() == 32) .AND. xArg1:candefault())
      neterr(.T.)
      Return .F.
   EndIf
   Do While (dispcount() > 0)
      dispend()
   EndDo
   xVar14:= sets()
   Set Console On
   Set Alternate To
   Set Alternate Off
   Set Device To Screen
   Set Printer Off
   Set Printer To
   Set Exact Off
   xVar3:= IIf(ValType(xArg1:subsystem()) == "C",xArg1:subsystem(),"????")
   xVar3:= xVar3+("/"+IIf(ValType(xArg1:subcode()) == "N",LTrim(Str(xArg1:subcode())),"/????"))
   xVar2:= IIf(xArg1:severity() > 1,"ERRO!","AVISO!")+"|"+xVar3
   al_hora:= "*"
   If (!Empty(xArg1:oscode()))
      xVar2:= xVar2+("|ERRO DO DOS N§ "+LTrim(Str(xArg1:oscode())))
   EndIf
   If (!Empty(xArg1:filename()))
      xVar2:= xVar2+("|Arquivo: "+xArg1:filename())
   Else
      If (!Empty(xArg1:operation()))
         xVar2:= xVar2+("|Vari vel/fun‡„o: "+xArg1:operation())
      EndIf
   EndIf
   dbf_err:= IIf(Type("drverr") = "C",drverr,"\")+"ERROS"
   xVar6:= "478"
   xVar6:= xVar6+xVar6
   xVar9:= xVar10:= ""
   If (file(dbf_err+".DBF"))
      If (xArg1:oscode() == 4)
         Close Databases
         Select 1
         Close Format
      EndIf
      xVar13:= Select()
      Select 0
      If (!file(dbf_err+extensao()))
         xVar15:= SaveScreen(0,0,MaxRow(),79)
         dbox("Indexando arquivo de erros",Nil,Nil,Nil,.F.,"AGUARDE!",Nil,Nil,Nil,xVar16)
         Use (dbf_err) Shared
         Index On codi_erro To (dbf_err)
         restscr(0,0,MaxRow(),79,xVar15)
      Else
         Use (dbf_err) Shared Index (dbf_err)
      EndIf
      xVar3:= encript(xVar3,xVar6)
      Seek xVar3
      If (Found())
         Do While (!EOF() .AND. codi_erro = xVar3)
            xVar7:= decript(msg_erro,xVar6)
            If (decript(tpmsg_erro,xVar6) = "C")
               xVar9:= xVar9+(alltrim(xVar7)+"|")
            Else
               xVar10:= xVar10+(alltrim(xVar7)+"|")
            EndIf
            Skip
         EndDo
      Else
         xVar9:= xVar10:= "ERRO NŽO IDENTIFICADO|"
      EndIf
      Close
      Select (xVar13)
   Else
      xVar9:= xVar10:= "Imposs¡vel dar esta informa‡„o pois,|arquivo ERROS.DBF n„o encontrado!|"
   EndIf
   xVar1:= 1
   xVar11:= ""
   Do While (!Empty(procname(xVar1)))
      xVar11:= xVar11+(padr(procname(xVar1),12)+"("+lpad(Str(procline(xVar1)),4,"0")+")|")
      xVar1++
   EndDo
   xVar4:= "|Poss¡veis causas|Solu‡„o/coment rios|Caminho (trace)|Cancelar opera‡„o"+IIf(xArg1:canretry(),"|Tentar novamente","")
   xVar5:= 0
   xVar15:= SaveScreen(0,0,MaxRow(),79)
   alerta()
   alerta()
   Do While (.T.)
      xVar5:= dbox(SubStr(xVar4,2),Nil,Nil,.T.,Nil,xVar2,Nil,Nil,Nil,xVar16)
      If (xVar5 = 0 .OR. xVar5 = 4)
         Close Databases
         Select 1
         Close Format
         readkill(.T.)
         getlist:= {}
         Break(xArg1)
      Else
         If (xVar5 == 1)
            dbox(xVar9+"*",Nil,Nil,Nil,Nil,"POSS¡VEL CAUSA",Nil,Nil,Nil,xVar16)
         Else
            If (xVar5 == 2)
               dbox(xVar10+"*",Nil,Nil,Nil,Nil,"COMENTRIOS/SOLU€ŽO",Nil,Nil,Nil,xVar16)
            Else
               If (xVar5 == 3)
                  dbox(xVar11+"*",Nil,Nil,Nil,Nil,"CAMINHO",Nil,Nil,Nil,xVar16)
               Else
                  If (xVar5 = 5 .AND. xArg1:canretry())
                     sets(xVar14)
                     al_hora:= ""
                     Return .T.
                  Else
                     sets(xVar14)
                     al_hora:= ""
                     Return .F.
                  EndIf
               EndIf
            EndIf
         EndIf
      EndIf
   EndDo

Function SETS(xArg1)

   Local xVar1[38],xVar2
   If (xArg1 # Nil)
      For xVar2:= 1 To 38
         xVar1[xVar2]:= Set(xVar2,xArg1[xVar2])
      Next
   Else
      For xVar2:= 1 To 38
         xVar1[xVar2]:= Set(xVar2)
      Next
   EndIf
   Return xVar1

Function LRELA(xArg1,xArg2,xArg3)

   Local xVar1,xVar2,xVar3,xVar4,xVar5,xVar6
   xArg3:= lpad(Str(xArg3,2),"0")
   xVar6:= 1
   If (!used())
      Return .F.
   EndIf
   xVar2:= drvdbf+"rl"+xArg3+"*."+arqgeral
   xVar5:= adir(xVar2)
   If (xVar5 > 0)
      xVar1:= SaveScreen(0,0,MaxRow(),79)
      dbox("AGUARDE!",9,Nil,Nil,.F.)
      Private l_arq[xVar5+1]
      adir(xVar2,l_arq)
      For i:= xVar5 To 1 Step -1
         xVar4:= drvdbf+l_arq[i]
         Restore From (xVar4) Additive
         l_arq[i+1]:= rl_aqcom+"³"+l_arq[i]
      Next
      l_arq[1]:= "* ESPECIFICAR NOVO RELAT¢RIO *"
      volta_ac:= .T.
      restscr(0,0,MaxRow(),79,xVar1)
      Do While (volta_ac)
         cod_sos:= 48
         volta_ac:= .F.
         msg:= ""
         aeval(l_arq,{|_1| IIf(_1 # Nil,msg+="|"+alltrim(parse(_1,"³")),"")})
         op_co:= dbox(SubStr(msg,2),xArg1,xArg2,.T.,Nil,"SELECIONE O RELAT¢RIO COM ,  e "+gcr+"|[DEL] APAGA O RELAT¢RIO DO CURSOR")
         If ((pos_:= rat("³",l_arq[op_co]),volta_ac .AND. pos_ > 3))
            xVar4:= drvdbf+SubStr(l_arq[op_co],pos_+1)
            id_op:= alltrim(Upper(Left(l_arq[op_co],pos_-1)))
            alerta()
            op:= dbox("Cancelar a opera‡„o|Apagar op‡„o",8,Nil,.T.,Nil,"ATEN€ŽO!|¯ "+id_op+"®")
            If (op == 2)
               Erase (xVar4)
               adel(l_arq,op_co)
            EndIf
         EndIf
      EndDo
      Release All Like rl_*
      If (op_co > 1)
         xVar6:= 2
         op_:= l_arq[op_co]
         ti_:= parse(@op_,"³")
         xVar3:= drvdbf+op_
         Restore From (xVar3) Additive
         cpord:= rl_cpord
         criterio:= rl_criteri
         titrel:= rl_titrel
         tps:= rl_tps
         nucop:= rl_nucop
      Else
         If (op_co == 0)
            xVar6:= 0
         EndIf
      EndIf
   EndIf
   Release All Like rl_*
   Return xVar6

Function GRELA(xArg1)

   xArg1:= lpad(Str(xArg1,2),"0")
   If (gr_rela .AND. !Empty(xArg1))
      rl_aqcom:= Left(titrel+Space(58),58)
      Do While (.T.)
         cod_sos:= 47
         hms:= Time()
         resaq:= xArg1+SubStr(hms,4,2)+right(hms,2)+"."+arqgeral
         aqrel:= drvdbf+"RL"+resaq
         If (!file("&aqrel."))
            Exit
         EndIf
      EndDo
      alerta(2)
      rl_aqcom:= dbox("Identifique-o para grava‡„o, ou pressione [ESC]",Nil,Nil,Nil,Nil,"GRAVA RELAT¢RIO",rl_aqcom)
      If (LastKey() # 27 .AND. !Empty(rl_aqcom))
         rl_cpord:= cpord
         rl_criteri:= criterio
         rl_titrel:= titrel
         rl_tps:= tps
         rl_nucop:= nucop
         Save All Like rl_* To (aqrel)
      EndIf
   EndIf
   gr_rela:= .F.
   Return Nil

Function PARSE(xArg1,xArg2)

   Local xVar1,xVar2
   If (PCount() < 2)
      xArg2:= ","
   EndIf
   xVar2:= At(xArg2,xArg1)
   If (xVar2 > 0)
      xVar1:= Left(xArg1,xVar2-1)
      xArg1:= SubStr(xArg1,xVar2+Len(xArg2))
   Else
      xVar1:= xArg1
      xArg1:= ""
   EndIf
   Return xVar1

Function BLOREG(xArg1,xArg2)

   Local xVar1,xVar2,xVar3,xVar4
   xArg1:= IIf(PCount() = 0,0,xArg1)
   xArg2:= IIf(PCount() < 2,1,xArg2)
   xVar1:= xArg1 = 0
   xVar2:= xArg1
   xVar3:= .F.
   xVar4:= nextkey()
   Do While (xArg1 >= 0 .AND. LastKey() # 27 .OR. xVar1)
      If (RLock())
         xVar3:= .T.
         Exit
      EndIf
      dbox("Tentando bloquear|"+IIf(xVar1,"(NŽO","(ESC")+" cancela)",15,Nil,xArg2,Nil,"OUTRO USURIO ACESSANDO|O REGISTRO")
      xArg1:= xArg1-xArg2
   EndDo
   If (xVar4 == 0)
      Clear Typeahead
   EndIf
   Return xVar3

Function ALERTA(xArg1)

   Local xVar1,xVar2
   xArg1:= IIf(PCount() = 0,3,IIf(xArg1 > 20,20,xArg1))
   xVar2:= IIf(Type("drvsom") == "L",drvsom,.T.)
   If (xVar2)
      If (xArg1 == 99)
         tone(600,1)
         tone(300,1)
         tone(600,1)
         tone(300,1)
         tone(600,1)
         tone(300,1)
         tone(600,1)
         tone(300,1)
      Else
         For xVar1:= 1 To xArg1
            tone(xVar1*500,0.3)
         Next
      EndIf
   EndIf
   Return Nil

Function LEMANU(xArg1,xArg2)

   Local xVar1,xVar2,xVar3,xVar4
   hind:= Left(xArg1,Len(xArg1)-3)+"INX"
   xVar4:= fopen(hind)
   If (ferror() == 0)
      xVar1:= Space(1920)
      fread(xVar4,@xVar1,1920)
      xVar1:= SubStr(xVar1,16*(xArg2-1)+1,16)
      xVar2:= Val(Left(xVar1,8))
      xVar3:= Val(right(xVar1,8))
      xVar1:= Space(xVar3)
      fclose(xVar4)
      xVar4:= fopen(xArg1)
      If (ferror() == 0)
         fseek(xVar4,xVar2)
         fread(xVar4,@xVar1,xVar3)
      EndIf
   Else
      xVar1:= ""
   EndIf
   fclose(xVar4)
   Return xVar1

function sgrafico  // deveria voltar se esta em modo grafico
return .f.

Function MUDAFONTE(xArg1)
Return ""

Func Mouse()  // verifica se tem mouse
Retu If( MPresent() , 1 , 0 )

Func MouseCur( Arg )  // mostra ou esconde o cursor do mouse
Arg := If( Arg = Nil , .f. , .t. )
If( Arg , MShow() , MHide() )
Retu Nil

Func MouseSet( Row , Col )  // posiciona o cursor


MSetPos( Row , Col )
Retu Nil

Func MouseBox( Arg1 , Arg2 , Arg3 , Arg4 )  // determina area de evento
Mou_Lin_S := Mou_Col_S := Mou_Lin_I := Mou_Col_I := 0
If Arg3 != MaxRow() .And. Arg4 != MaxCol()
 Mou_Lin_S := Arg1
 Mou_Col_S := Arg2
 Mou_Lin_I := Arg3
 Mou_Col_I := Arg4
ElseIf l_s != Nil .And. c_s != Nil .And. l_i != Nil .And. c_i != Nil
 Mou_Lin_S:=l_s
 Mou_Col_S:=c_s
 Mou_Lin_I:=l_i
 Mou_Col_I:=c_i
Endi
Retu Nil

Func MouseGet(Arg1,Arg2) // retorna botao esquerdo/direiro (enter/esc)
Loca nBotao:=0
If MLeftDown()
 nBotao:=1
ElseIf MRightDown()
 nBotao:=2
Endi
Retu (nBotao)

procedure mouserat
return



Function NARQ(xArg1)

   Local xVar1,xVar2,xVar3
   xArg1:= Trim(xArg1)
   xVar1:= "*+-,=?<>[]{};. "
   If (Empty(xArg1))
      Return .T.
   EndIf
   xVar2:= Asc(xArg1) < 65
   xVar3:= Asc(SubStr(xArg1,3,1)) < 65 .AND. SubStr(xArg1,2,1) = ":"
   For i:= 1 To Len(xVar1)
      If (SubStr(xVar1,i,1) $ xArg1)
         Return .F.
      EndIf
   Next
   Return IIf(xVar2 .OR. xVar3,.F.,.T.)


Function NSEM(xArg1)

   If (ValType(xArg1) = "D")
      xArg1:= DoW(xArg1)
   EndIf
   Return SubStr("DomingoSegundaTerca  Quarta Quinta Sexta  Sabado ",xArg1*7-6,7)

Function CAIXA(xArg1,xArg2,xArg3,xArg4,xArg5,xArg6,xArg7)

   Local xVar1,xVar2,xVar3,xVar4,xVar5,xVar6,xVar7

   If (Len(xArg1) = 8 .OR. Len(xArg1) = 11)
      xArg1:= Left(xArg1,8)+" "
   Else
      If (Len(xArg1) > 9)
         xArg1:= Left(xArg1,8)+right(xArg1,1)
      EndIf
   EndIf
   @ xArg2,xArg3,xArg4,xArg5 Box xArg1
   If (IIf(xArg7 = Nil,.T.,xArg7) .AND. xArg3 >= 1 .AND. xArg4 < MaxRow())
      restscr(xArg2+1,xArg3-1,xArg4+1,xArg3-1,Transform(SaveScreen(xArg2+1,xArg3-1,xArg4+1,xArg3-1),Replicate("X",xArg4-xArg2+1)))
      If (xArg3 > 1)
         restscr(xArg2+1,xArg3-2,xArg4+1,xArg3-2,Transform(SaveScreen(xArg2+1,xArg3-2,xArg4+1,xArg3-2),Replicate("X",xArg4-xArg2+1)))
      EndIf
      restscr(xArg4+1,xArg3,xArg4+1,xArg5-2,Transform(SaveScreen(xArg4+1,xArg3,xArg4+1,xArg5-2),Replicate("X",xArg5-xArg3-1)))
   EndIf
   If (xArg6 # Nil .AND. drvsom)
      tone(xArg6,0.5)
   EndIf

   Return Nil

Function LPAD(xArg1,xArg2,xArg3)

   xArg1:= IIf(ValType(xArg1) = "N",Str(xArg1),xArg1)
   If (xArg2 = Nil)
      xArg2:= Len(xArg1)
      xArg3:= " "
   Else
      If (xArg3 = Nil)
         If (ValType(xArg2) = "C")
            xArg3:= xArg2
            xArg2:= Len(xArg1)
         Else
            xArg3:= " "
         EndIf
      EndIf
   EndIf
   Return padl(alltrim(xArg1),xArg2,xArg3)

Function DBOX(xArg1,xArg2,xArg3,xArg4,xArg5,xArg6,xArg7,xArg8,xArg9,xArg10)

   Local xVar1,xVar2,xVar3,xVar4:= {},xVar5:= SetColor(),xVar6,xVar7,xVar8,xVar9:= 1,xVar10,xVar11:= .F.,xVar12,xVar13:= {},xVar14:= SaveScreen(0,0,MaxRow(),79),xVar15,xVar16,xVar17,xVar18:= Row(),xVar19:= Col(),xVar20:= SetKey(-37,Nil),xVar21:= ;
      Set(20),xVar22:= {},xVar23:= .F.,xVar24:= setcursor(0)
   Private l_msg:= {},l_opc:= {},ij,ca_m,cara_pesq:= "",cor_op:= xArg10,tit_op:= xArg10
   If (Type("pr_ok") = "C" .AND. Len(pr_ok) > 0)
      ? pr_ok
   Else
      drvmouse:= IIf(Type("drvmouse") # "L",.F.,drvmouse)
      If (drvmouse)
         x:= "MOUSEGET"
         Do While (&x(@xVar16,@xVar17) # 0)
         EndDo
      EndIf
      Set Device To Screen
      mold:= IIf(Type("mold") = "C",mold,"ÚÄ¿³ÙÄÀ³ÃÄ´")
      gcr:= IIf(Type("gcr") = "C",gcr,"<ENTER>")
      op_sis:= IIf(Type("op_sis") = "N",op_sis,1)
      xArg9:= IIf(xArg9 = Nil,1,xArg9)
      ca_m:= xArg7
      xArg4:= IIf(xArg4 = Nil,0,xArg4)
      xArg5:= IIf(xArg5 = Nil,.T.,xArg5)
      xVar8:= IIf(ValType(xArg4) = "L",xArg4 = .T.,.F.)
      epop_:= IIf(ValType(xArg4) = "L",xArg4 = .F.,.F.)
      xVar2:= xVar3:= 0
      If (ValType(xArg1) = "A")
         Do While (xVar3 < 4096 .AND. Len(xArg1) > xVar3)
            xVar3++
            If (ValType(xArg1[xVar3]) = "A")
               AAdd(l_msg,xArg1[xVar3][1])
            Else
               AAdd(l_msg,xArg1[xVar3])
            EndIf
            ij:= At("~",l_msg[xVar3])-1
            If (ij < 1)
               ij:= Len(l_msg[xVar3])
            EndIf
            xVar2:= IIf(ij > xVar2,ij,xVar2)
         EndDo
      Else
         Do While (xVar3 < 4096 .AND. Len(xArg1) > 0)
            AAdd(l_msg,parse(@xArg1,"|"))
            ij:= At("~",l_msg[Len(l_msg)])-1
            If (ij < 1)
               ij:= Len(l_msg[Len(l_msg)])
            EndIf
            xVar2:= IIf(ij > xVar2,ij,xVar2)
            xVar3++
         EndDo
      EndIf
      If ((xVar8 .OR. epop_) .AND. Len(l_msg) > 0)
         For ij:= 1 To Len(l_msg)
            If (At("~",l_msg[ij]) > 0)
               xVar6:= l_msg[ij]
               xVar7:= parse(@xVar6,"~")
               l_msg[ij]:= xVar7
               If (Val(xVar6) > 0)
                  AAdd(l_opc,Val(xVar6))
               Else
                  AAdd(l_opc,ij)
               EndIf
               xVar7:= parse(@xVar6,"~")
               AAdd(xVar22,xVar6)
               If (Len(xVar6) > 0)
                  xVar23:= .T.
               EndIf
            Else
               AAdd(l_opc,ij)
               AAdd(xVar22,"")
            EndIf
            If (l_opc[ij] = xArg9)
               xVar9:= ij
            EndIf
            If (At("ô",l_msg[ij]) > 0)
               l_msg[ij]:= strtran(l_msg[ij],"ô","~")
            EndIf
         Next
      EndIf
      If (xVar23)
         xVar2:= xVar2+7
      EndIf
      If (!epop_)
         If (xArg6 # Nil .AND. !Empty(xArg6) .AND. !epop_)
            xVar3++
            Do While (Len(xArg6) > 0)
               AAdd(xVar4,parse(@xArg6,"|"))
               ij:= Len(xVar4[Len(xVar4)])
               xVar2:= IIf(ij > xVar2,ij,xVar2)
               xVar3++
            EndDo
         EndIf
         xVar1:= IIf(ValType(xArg4) = "N" .AND. xArg5,IIf(xArg4 # 0,"","Pressione "+gcr),"")
         xVar2:= IIf(xVar2 < Len(xVar1),Len(xVar1)+2,xVar2+2)
         If (ca_m # Nil)
            tcam:= Len(Transform(ca_m,xArg8))
            xVar2:= IIf(xVar2 < tcam+4,tcam+4,xVar2)
         EndIf
         xVar3:= IIf(!Empty(xVar1) .OR. ca_m # Nil,xVar3+3,xVar3+1)
         If (xArg3 = Nil .OR. Empty(xArg3))
            xArg3:= Int((80-xVar2)/2)-1
         Else
            xArg3:= IIf(xArg3+xVar2+1 > 78,78-xVar2,xArg3)
         EndIf
         xVar3:= IIf(xVar3 > MaxRow()-1,MaxRow()-1,xVar3)
         If (xArg2 = Nil)
            xArg2:= Int((MaxRow()+1-xVar3)/2)-1
         Else
            xArg2:= IIf(xArg2+xVar3 > MaxRow()-1,MaxRow()-1-xVar3,xArg2)
         EndIf
      Else
         xArg3:= 0
         xVar2:= 78
         xVar3:= 0
      EndIf
      xVar12:= "drv"+alltrim(Str(Int(op_sis+(xArg2+MaxRow())*(xArg3+80)+25*((xArg2+MaxRow()+xVar3)*(xArg3+80+xVar2)))))
      If (Type(xVar12) = "C")
         xArg2:= Val(Left(&xVar12,2))
         xArg3:= Val(SubStr(&xVar12,3))
      EndIf
      If (cor_op = Nil)
         If (xVar8 .OR. epop_)
            cor_op:= drvcorget
            tit_op:= drvtitget
         Else
            If (ca_m # Nil)
               cor_op:= drvcormsg
               tit_op:= drvtitmsg
            Else
               If ((!Empty(xVar1) .OR. ValType(xArg4) = "N") .AND. xArg5)
                  cor_op:= drvcorenf
                  tit_op:= drvtitenf
               Else
                  cor_op:= drvcorbox
                  tit_op:= drvtitbox
               EndIf
            EndIf
         EndIf
      EndIf
      If (ca_m # Nil)
         cor_op:= cor_op+","+tit_op
      EndIf
      If (!epop_)
         For ij:= 1 To Len(l_msg)
            If (!(l_msg[ij] == "---"))
               If (Len(xVar22) > 0 .AND. Len(xVar22[ij]) > 0)
                  l_msg[ij]:= Left(l_msg[ij]+Space(xVar2),xVar2-2-Len(xVar22[ij]))+" "+xVar22[ij]
               EndIf
               If (!drvmenucen .AND. xVar8)
                  l_msg[ij]:= " "+Left(l_msg[ij]+Space(xVar2),xVar2-1)
               Else
                  l_msg[ij]:= padc(l_msg[ij],xVar2," ")
               EndIf
            EndIf
         Next
      EndIf
      Do While (.T.)
         rola_cx:= .F.
         If (!epop_)
            Set Color To (tit_op)
            caixa(mold,xArg2,xArg3,xArg2+xVar3,xArg3+xVar2+1)
            If (xArg6 # Nil .AND. Len(xVar4) > 0)
               For ij:= 1 To Len(xVar4)
                  @ xArg2+ij,xArg3+1 Say padc(xVar4[ij],xVar2)
               Next
               @ xArg2+ij,xArg3 Say SubStr(mold,9,1)+Replicate(SubStr(mold,10,1),xVar2)+SubStr(mold,11,1)
            EndIf
            xin:= IIf(xArg6 = Nil .OR. Len(xVar4) = 0,0,Len(xVar4)+1)
         Else
            xin:= 0
         EndIf
         If (drvmouse)
            x:= "MOUSEBOX"
            &x(xArg2,xArg3,xArg2+xVar3,xArg3+xVar2+1)
         EndIf
         Set Color To (cor_op)
         If (xVar8 .OR. epop_)
            acho_tela:= ""
            tec_ap:= .T.
            Do While tec_ap
               tec_ap:= .F.
               If xVar8
                  xVar9:= menuv(l_msg,l_opc,xVar9,xVar3-xin-1,xArg2+xin+1,xArg3+1,xVar2)
               Else
                  xVar9:= menuh(l_msg,l_opc,xVar9,xArg2)
               EndIf
            EndDo
         Else
            If (Len(l_msg) > 0)
               For ij:= 1 To Len(l_msg)
                  lin_:= xArg2+ij+xin
                  If (lin_ < xArg2+xVar3 .AND. lin_ < MaxRow())
                     @ lin_,xArg3+1 Say l_msg[ij]
                  EndIf
               Next
               xVar9:= alltrim(Str(lin_))+"|"+alltrim(Str(xArg3+(Len(l_msg[Len(l_msg)])-Len(Trim(l_msg[Len(l_msg)])))))
            Else
               lin_:= xArg2+xin
               ij:= 1
               xVar9:= alltrim(Str(lin_))+"|"+alltrim(Str(xArg3))
            EndIf
            If (ca_m # Nil)
               xVar10:= Int((xVar2-tcam)/2)
               @ xArg2+ij+xin+1,xArg3+xVar10 Say ">"+Space(tcam)+"<"
               If (xArg8 = Nil .OR. Empty(xArg8))
                  SetPos(xArg2+ij+xin+1,xArg3+xVar10+1)
                  AAdd(xVar13,__Get(Nil,"ca_m",Nil,Nil,Nil):display())
               Else
                  SetPos(xArg2+ij+xin+1,xArg3+xVar10+1)
                  AAdd(xVar13,__Get(Nil,"ca_m",xArg8,Nil,Nil):display())
               EndIf
               SetKey(-37,{|| (rola_cx:= .T.,joganobuff(Chr(13)))})
               setcursor(IIf(readinsert(),3,1))
               ReadModal(xVar13)
               xVar13:= {}
               xVar24:= setcursor(0)
               SetKey(-37,Nil)
               xVar9:= ca_m
            Else
               If ((!Empty(xVar1) .OR. ValType(xArg4) = "N") .AND. xArg5)
                  Set Color To (tit_op)
                  If (!Empty(xVar1))
                     @ xArg2+ij+xin,xArg3+1 Say padc("®¯",xVar2)
                     @ xArg2+ij+xin+1,xArg3+1 Say padc(xVar1,xVar2)
                  EndIf
                  If (drvmouse)
                     x:= "MOUSECUR"
                     &x(.T.)
                     tq:= ppp:= 0
                     i:= Seconds()+xArg4
                     Do While (tq = 0)
                        If (xArg4 > 0 .AND. Seconds() > i)
                           joganobuff(Chr(13))
                        EndIf
                        x:= "MOUSEGET"
                        pp:= &x(0,0)
                        x:= "POEHORA"
                        &x()
                        tq:= nextkey()
                        If (pp = 1 .AND. tq = 0)
                           ppp:= IIf(ppp = 0,Seconds(),ppp)
                           press:= Seconds() > ppp+0.5
                           If (press)
                              rola_cx:= .T.
                              joganobuff(Chr(13))
                           EndIf
                        Else
                           If (pp == 2)
                              joganobuff("")
                           Else
                              If (ppp > 0)
                                 joganobuff(Chr(13))
                              EndIf
                              ppp:= 0
                           EndIf
                        EndIf
                     EndDo
                     x:= "MOUSECUR"
                     &x(.F.)
                  EndIf
                  tq:= q_tec(xArg4)
                  If (tq == -37)
                     rola_cx:= .T.
                  Else
                     If ((xArg4 = 0 .OR. IIf(Type("acao_mac") = "C",!(acao_mac $ "DGg"),.F.)) .AND. LastKey() # 27 .AND. LastKey() # 13 .AND. LastKey() # 32 .AND. LastKey() # 9 .AND. LastKey() # 46)
                        joganobuff(Chr(LastKey()))
                     EndIf
                  EndIf
               EndIf
            EndIf
         EndIf
         If (rola_cx)
            muda_pj(@xArg2,@xArg3,xArg2+xVar3,xArg3+xVar2+1,xVar14,.T.)
            xVar11:= .T.
            Loop
         EndIf
         Exit
      EndDo
      If (xVar11 .AND. Type("arqconf") = "C")
         Public &xVar12:= Str(xArg2,2)+Str(xArg3,2)
         Save All Like drv* To (arqconf)
         Restore From (arqconf) Additive
      EndIf
      If (xArg5)
         restscr(0,0,MaxRow(),79,xVar14)
      EndIf
      Set Color To (xVar5)
      If (drvmouse)
         x:= "MOUSEGET"
         Do While (&x(0,0) # 0)
         EndDo
         x:= "MOUSEBOX"
         &x(0,0,MaxRow(),79)
         mouseset(xVar16,xVar17)
      EndIf
      SetKey(-37,xVar20)
      SetPos(xVar18,xVar19)
      Set(20,xVar21)
      setcursor(xVar24)
      Return xVar9
   EndIf

Procedure JOGANOBUFF(xArg1)

   If (Type("acao_mac") = "C")
      x:= "KEYBUFF"
      &x(xArg1)
   Else
      Keyboard xArg1
   EndIf
   Return

Function Q_TEC(xArg1)

   Local xVar1
   poehora()
   If (Type("acao_mac") = "C")
      x:= "IN_KEY"
      xVar1:= &x(xArg1)
   Else
      xVar1:= inky(xArg1)
   EndIf
   Return xVar1

Function NOVAPOSI(xArg1,xArg2,xArg3,xArg4)

   Local xVar1
   xVar1:= "drv"+alltrim(Str(Int(op_sis*80+(xArg1+MaxRow())*(xArg2+80)+25*((xArg3+MaxRow())*(xArg4+80)))))
   If (Type(xVar1) = "C")
      d_1:= xArg3-xArg1
      d_2:= xArg4-xArg2
      xArg1:= Val(Left(&xVar1,2))
      xArg2:= Val(SubStr(&xVar1,3))
      xArg3:= xArg1+d_1
      xArg4:= xArg2+d_2
   EndIf
   Return xVar1

Function REPBLO(xArg1,xArg2)

   Local xVar1,xVar2,xVar3,xVar4,xVar5
   xVar1:= alias()
   xVar3:= At("->",xArg1)
   xVar2:= IIf(xVar3 = 0,alias(),Left(xArg1,xVar3-1))
   xVar5:= "blk_"+xVar2
   If (Type(xVar5) # "L")
      Select (xVar2)
      bloreg(0,0.5)
      If (Empty(xVar1))
         Select 0
      Else
         Select (xVar1)
      EndIf
   EndIf
   xVar4:= IIf(ValType(xArg2) = "B",eval(xArg2),xArg2)
   Replace &xArg1 With xVar4
   If (Type(xVar5) # "L")
      Select (xVar2)
      Unlock
      If (Empty(xVar1))
         Select 0
      Else
         Select (xVar1)
      EndIf
   EndIf
   Return .T.

Function BLOARQ(xArg1,xArg2)

   Local xVar1,xVar2,xVar3
   xArg1:= IIf(PCount() = 0,0,xArg1)
   xArg2:= IIf(PCount() < 2,1,xArg2)
   xVar2:= xArg1
   xVar1:= xArg1 = 0
   xVar3:= .F.
   Do While (xArg1 >= 0 .OR. xVar1)
      If (FLock())
         xVar3:= .T.
         Exit
      EndIf
      dbox("Tentando bloquear|"+IIf(xVar1,"(NŽO","(ESC")+" cancela)",15,Nil,xArg2,Nil,"OUTRO USURIO ACESSANDO|O ARQUIVO")
      xArg1:= xArg1-xArg2
   EndDo
   Clear Typeahead
   Return xVar3

Function EXT(xArg1,xArg2,xArg3,xArg4,xArg5)

   xmsing_:= SubStr("$SIG$Real                    ",6)
   xmplur_:= SubStr("$PLU$Reais                   ",6)
   xArg2:= IIf(PCount() < 2 .OR. xArg2 = Nil,80,xArg2)
   cruz_:= IIf(xArg3 = Nil,.T.,.F.)
   xArg4:= IIf(xArg4 = Nil .OR. Empty(xArg4),xmsing_,padr(xArg4,24))
   xArg5:= IIf(xArg5 = Nil .OR. Empty(xArg5),xmplur_,padr(xArg5,24))
   sexo_:= IIf(Upper(right(Trim(xArg4),1)) = "A","a","o")
   silaba:= "zen.tro.cen.nhe.tec.toc.vec.tor.zes.set.zoi.nov.ren.que.sen.ten.ven.vos.t"+sexo_+"s.tav.zad"
   xArg1:= Abs(IIf(cruz_,xArg1,Int(xArg1)))
   tx_:= "Duzent#s     Trezent#s    Quatrocent#s Quinhent#s   "
   tcnd:= tx_+"Seiscent#s   Setecent#s   Oitocent#s   Novecent#s   "
   tcnd:= strtran(tcnd,"#",sexo_)
   tx_:= "Dez          Onze         Doze         Treze        "
   tx_:= tx_+"Quatorze     Quinze       Dezesseis    Dezessete    "
   tn_:= tx_+"Dezoito      Dezenove     "
   tx_:= "Vinte        Trinta       Quarenta     Cinquenta    "
   tndd:= tx_+"Sessenta     Setenta      Oitenta      Noventa      "
   tx_:= "Zero         Um           Dois         Tres         "
   tx_:= tx_+"Quatro       Cinco        Seis         Sete         "
   tnuu:= tx_+"Oito         Nove         "
   eh_:= " e "
   nn_:= Str(Int(xArg1),15)
   x1_:= x2_:= x3_:= x4_:= x5_:= scnd:= cnd:= "Zero"
   ni_:= Int(xArg1)
   jc_:= SubStr(Str(xArg1-ni_,4,2),3,2)
   dc_:= Val(SubStr(jc_,1,1))
   uc_:= Val(SubStr(jc_,2,1))
   nj_:= IIf(dc_ = 1,"1","0")
   ndc_:= IIf(dc_ = 1,Trim(SubStr(tn_,(uc_+1)*13-12,13)),Trim(SubStr(tndd,(dc_-1)*13-12,13)))
   nuc_:= Trim(SubStr(tnuu,(uc_+1)*13-12,13))
   If (nj_ = "1" .OR. dc_ # 0 .AND. uc_ = 0)
      sec_:= ndc_
   Else
      If (dc_ = 0)
         sec_:= nuc_
      Else
         If (dc_ # 0 .AND. uc_ # 0)
            sec_:= ndc_+eh_+nuc_
         EndIf
      EndIf
   EndIf
   If (Val(jc_) > 1)
      ce_:= sec_+" Centavos"
   Else
      If (Val(jc_) = 1)
         ce_:= sec_+" Centavo"
      Else
         ce_:= ""
      EndIf
   EndIf
   l:= 15
   nv:= 5
   ind_ext_:= 0
   Do While (nv > 0)
      If (SubStr(nn_,l-ind_ext_-2,3) = "   ")
         nv:= 0
         Loop
      EndIf
      n:= Val(SubStr(nn_,l-ind_ext_-0,1))
      nd:= Val(SubStr(nn_,l-ind_ext_-1,1))
      nc:= Val(SubStr(nn_,l-ind_ext_-2,1))
      If (nc > 1)
         cnd:= Trim(SubStr(tcnd,(nc-1)*13-12,13))
      EndIf
      bhx:= "0"
      If (nd = 1)
         bhx:= "1"
         ndd:= Trim(SubStr(tn_,(n+1)*13-12,13))
      Else
         If (nd > 1)
            ndd:= Trim(SubStr(tndd,(nd-1)*13-12,13))
         EndIf
      EndIf
      nuu:= Trim(SubStr(tnuu,(n+1)*13-12,13))
      If (bhx = "1" .OR. nd # 0 .AND. n = 0)
         snd:= ndd
      Else
         If (nd = 0)
            snd:= nuu
         Else
            If (nd # 0 .AND. n # 0)
               snd:= ndd+eh_+nuu
            EndIf
         EndIf
      EndIf
      If (nc = 1)
         scnd:= IIf(nd = 0 .AND. n = 0,"Cem","Cento e "+snd)
      Else
         If (nc = 0)
            scnd:= snd
         Else
            If (nc > 1 .AND. (nd # 0 .OR. n # 0))
               scnd:= cnd+eh_+snd
            Else
               If (nc > 1 .AND. nd = 0 .AND. n = 0)
                  scnd:= cnd
               EndIf
            EndIf
         EndIf
      EndIf
      If (ind_ext_ < 3)
         x1_:= scnd
      Else
         If (ind_ext_ > 2 .AND. ind_ext_ < 6)
            x2_:= scnd
         Else
            If (ind_ext_ > 5 .AND. ind_ext_ < 9)
               x3_:= scnd
            Else
               If (ind_ext_ > 8 .AND. ind_ext_ < 12)
                  x4_:= scnd
               Else
                  If (ind_ext_ > 11 .AND. ind_ext_ < 15)
                     x5_:= scnd
                  Else
                     If (ind_ext_ > 15)
                        Return "NUMERO MAIOR QUE 1 TRILHAO"
                     EndIf
                  EndIf
               EndIf
            EndIf
         EndIf
      EndIf
      nv:= nv-1
      ind_ext_:= ind_ext_+3
   EndDo
   nx_:= " "
   If (xArg1 > 999999999999 .AND. x5_ # "Zero")
      nx_:= IIf(x5_ = "Um",nx_+"Um Trilhao ",nx_+x5_+" Trilhoes ")
   EndIf
   If (x4_ # "Zero")
      nx_:= IIf(x4_ = "Um",nx_+"Um Bilhao ",nx_+x4_+" Bilhoes ")
   EndIf
   If (x3_ # "Zero")
      nx_:= IIf(x3_ = "Um",nx_+"Um Milhao ",nx_+x3_+" Milhoes ")
   EndIf
   If (x2_ # "Zero")
      nx_:= nx_+x2_+" Mil "
   EndIf
   If (x1_ # "Zero")
      nx_:= nx_+x1_
   EndIf
   If (cruz_)
      de_:= IIf(x1_ = "Zero" .AND. x2_ = "Zero"," de ","")
      If (ni_ > 0)
         cz_:= IIf(Int(xArg1) > 1,alltrim(xArg5),alltrim(xArg4))
         ec_:= IIf(xArg1-ni_ > 0," e ","")
      Else
         ec_:= cz_:= de_:= ""
      EndIf
   Else
      de_:= cz_:= ec_:= ce_:= ""
   EndIf
   nx_:= IIf(sexo_ = "a" .AND. right(nx_,2) = "Um",nx_+sexo_,nx_)
   nx_:= IIf(sexo_ = "a" .AND. right(nx_,4) = "Dois",Left(nx_,Len(nx_)-3)+"uas",nx_)
   nx_:= IIf(cruz_,Trim(nx_+de_+" "+cz_+ec_+ce_),Trim(nx_))
   nx_:= LTrim(nx_)
   If (xArg2 < 40)
      Return nx_
   EndIf
   If (Len(nx_) <= xArg2)
      nx_:= padr(nx_,xArg2,"/")
      Return padr(nx_,3*xArg2," ")
   Else
      e1:= ""
      Do While (Len(nx_) > xArg2)
         f1:= Left(nx_,xArg2+1)
         ij:= right(f1,3)
         Do While (!(ij $ silaba) .AND. right(f1,1) # " ")
            f1:= Left(f1,Len(f1)-1)
            ij:= right(f1,3)
         EndDo
         f1:= IIf(ij $ silaba,Left(f1,Len(f1)-3),Left(f1,Len(f1)-1))
         nx_:= LTrim(SubStr(nx_,Len(f1)+1))
         f1:= IIf(ij $ silaba,f1+"-",f1)
         If (Len(e1) < xArg2)
            f1:= lpad(f1,xArg2,"/")
         Else
            If (Len(f1) < xArg2)
               f1:= strtran(f1," ","  ",1,xArg2-Len(f1))
            EndIf
         EndIf
         e1:= e1+f1
      EndDo
      e1:= e1+padr(nx_,xArg2,"/")
   EndIf
   Return padr(e1,3*xArg2," ")

Function VCGC(xArg1)

   If (Empty(xArg1))
      Return .T.
   EndIf
   xArg1:= Trim(xArg1)
   If (Len(xArg1) # 14)
      Return .F.
   EndIf
   dv1_f:= Val(SubStr(xArg1,13,1))
   dv2_f:= Val(SubStr(xArg1,14,1))
   num_:= SubStr(xArg1,1,12)
   dv1_c:= 0
   posi_:= 12
   mu_:= "543298765432"
   Do While (posi_ > 0)
      dv1_c:= dv1_c+Val(SubStr(num_,posi_,1))*Val(SubStr(mu_,posi_,1))
      posi_--
   EndDo
   rest_:= dv1_c-Int(dv1_c/11)*11
   dv1_c:= IIf(rest_ < 2,0,11-rest_)
   dv_:= SubStr(Str(dv1_c,1),1)
   num_:= num_+dv_
   dv2_c:= 0
   mu_:= "6"+mu_
   posi_:= 13
   Do While (posi_ > 0)
      dv2_c:= dv2_c+Val(SubStr(num_,posi_,1))*Val(SubStr(mu_,posi_,1))
      posi_--
   EndDo
   rest_:= dv2_c-Int(dv2_c/11)*11
   dv2_c:= IIf(rest_ < 2,0,11-rest_)
   Return dv1_c = dv1_f .AND. dv1_c = dv1_f .AND. dv2_c = dv2_f

Function PCOND(xArg1,xArg2,xArg3)

   Local xVar1,xVar2,xVar3,xVar4
   xVar1:= alias()
   xVar2:= PCount() > 2
   xVar3:= LTrim(Str(Select(xArg2)))
   If (Val(xVar3) == 0)
//      xArg2:= xArg2
      Select 0
     // usearq(xArg2)
      use xArg2
   Else
      Select (xVar3)
   EndIf
   If (xVar2)
      Skip IIf(EOF(),0,1)
      Locate For &xArg1 While RecNo() <= LastRec()
   Else
      Locate For &xArg1
   EndIf
   xVar4:= IIf(Found() .AND. !Deleted(),.T.,.F.)
   If (Empty(xVar1))
      Select 0
   Else
      Select (xVar1)
   EndIf
   Return xVar4

Function GDV2(xArg1)

   Local xVar1,xVar2
   xArg1:= Trim(xArg1)
   xVar1:= xArg1
   xVar2:= gdv1(xVar1)
   xVar1:= xVar1+xVar2
   Return xVar2+gdv1(xVar1)

Function VDV2(xArg1)

   Local xVar1,xVar2,xVar3,xVar4
   xArg1:= Trim(xArg1)
   xVar1:= IIf(Asc(SubStr(xArg1,Len(xArg1)-2,1)) < 48,.T.,.F.)
   xVar2:= IIf(xVar1,SubStr(xArg1,1,Len(xArg1)-3),SubStr(xArg1,1,Len(xArg1)-2))
   xVar3:= Val(SubStr(xArg1,Len(xArg1)-1,2))
   xVar4:= gdv1(xVar2)
   xVar2:= xVar2+xVar4
   xVar4:= xVar4+gdv1(xVar2)
   Return IIf(Val(xVar4) = xVar3 .OR. Empty(xArg1),.T.,.F.)

Function VDV1(xArg1)

   Local xVar1,xVar2,xVar3
   xArg1:= Trim(xArg1)
   xVar1:= IIf(Asc(SubStr(xArg1,Len(xArg1)-1,1)) < 48,.T.,.F.)
   xVar2:= IIf(xVar1,SubStr(xArg1,1,Len(xArg1)-2),SubStr(xArg1,1,Len(xArg1)-1))
   xVar3:= Val(SubStr(xArg1,Len(xArg1),1))
   Return IIf(Val(gdv1(xVar2)) = xVar3 .OR. Empty(xArg1),.T.,.F.)

Function GDV1(xArg1)

   Local xVar1,xVar2,xVar3,xVar4,xVar5,xVar6
   xArg1:= Trim(xArg1)
   xVar1:= xArg1
   xVar2:= Len(xVar1)
   xVar5:= xVar6:= 0
   Do While (xVar6 < xVar2)
      xVar6++
      valo_:= Val(SubStr(xVar1,xVar2+1-xVar6,1))*(xVar6+1)
      xVar5:= xVar5+valo_
   EndDo
   xVar3:= xVar5%11
   dvc_:= IIf(xVar3 < 2,0,11-xVar3)
   Return LTrim(Str(dvc_,1))

Function DDMMAA(xArg1)

   Local xVar1,xVar2,xVar3,xVar4,xVar5
   If (Empty(xArg1) .OR. xArg1 = "  /  /  " .OR. xArg1 = "  /  /    ")
      Return .T.
   EndIf
   xArg1:= Trim(xArg1)
   xVar5:= Len(xArg1)
   If (xVar5 # 8 .AND. xVar5 # 6 .AND. xVar5 # 10)
      Return .F.
   EndIf
   xVar1:= Val(SubStr(xArg1,1,2))
   If (xVar5 = 6)
      xVar2:= Val(SubStr(xArg1,3,2))
   Else
      If (xVar5 = 8)
         If (Asc(SubStr(xArg1,3,1)) >= 48 .AND. Asc(SubStr(xArg1,3,1)) <= 57)
            xVar2:= Val(SubStr(xArg1,3,2))
         Else
            xVar2:= Val(SubStr(xArg1,4,2))
         EndIf
      Else
         If (xVar5 = 10)
            xVar2:= Val(SubStr(xArg1,4,2))
         Else
            xVar2:= 99
         EndIf
      EndIf
   EndIf
   xVar3:= Val(right(xArg1,2))
   If (Int(xVar2/2.0) = xVar2/2.0)
      xVar4:= IIf(xVar2 < 8,IIf(xVar2 = 2,IIf(Int(xVar3/4.0) = xVar3/4.0,29,28),30),31)
   Else
      xVar4:= IIf(xVar2 < 8,31,30)
   EndIf
   Return xVar1 > 0 .AND. xVar1 <= xVar4 .AND. xVar2 > 0 .AND. xVar2 < 13 .AND. xVar3 >= 0 .AND. xVar3 <= 99

//-------------------------------------------------------------------
Function MMAA(xArg1)

   Local xVar1,xVar2,xVar3
   If (Empty(xArg1) .OR. xArg1 = "  /  " .OR. xArg1 = "  /    ")
      Return .T.
   EndIf
   xArg1:= Trim(xArg1)
   xVar3:= Len(xArg1)
   If (xVar3 < 4 .OR. xVar3 > 7)
      Return .F.
   EndIf
   xVar1:= Val(SubStr(xArg1,1,2))
   xVar2:= Val(right(xArg1,2))
   Return xVar1 < 13 .AND. xVar1 > 0 .AND. xVar2 >= 0 .OR. xArg1 = Space(Len(xArg1))

Function DDMM(xArg1)

   Local xVar1,xVar2,xVar3,xVar4
   If (Empty(xArg1) .OR. xArg1 = "  /  ")
      Return .T.
   EndIf
   xArg1:= Trim(xArg1)
   If (Len(xArg1) # 5 .AND. Len(xArg1) # 4)
      Return .F.
   EndIf
   xVar1:= IIf(Len(Trim(xArg1)) = 4,3,4)
   xVar2:= Val(SubStr(xArg1,1,2))
   xVar3:= Val(SubStr(xArg1,xVar1,2))
   xVar4:= IIf(Int(xVar3/2.0) = xVar3/2.0,IIf(xVar3 < 8,IIf(xVar3 = 2,29,30),31),IIf(xVar3 < 8,31,30))
   Return xVar2 > 0 .AND. xVar2 <= xVar4 .AND. xVar3 > 0 .AND. xVar3 < 13 .OR. xArg1 = Space(Len(xArg1))

Function NMES(xArg1)

   If (ValType(xArg1) = "D")
      xArg1:= Month(xArg1)
   EndIf
   Return SubStr("Janeiro  FevereiroMarco    Abril    Maio     Junho    Julho    Agosto   Setembro Outubro  Novembro Dezembro ",xArg1*9-8,9)

Function CARDTYPE
return 3

procedure __pprj

Function TLAPSO(xArg1,xArg2)

   Local xVar1,xVar2,xVar3,xVar4,xVar5
   xVar5:= IIf(PCount() = 1,IIf(ValType(xArg1) == "N",hstring(xArg1),xArg1),elaptime(xArg1,xArg2))
   xVar5:= IIf(Len(xVar5) = 6,"00"+Transform(xVar5,"@R 99:99:99"),IIf(Len(xVar5) = 8,"00"+xVar5,xVar5))
   xVar2:= Val(Left(xVar5,4))
   xVar3:= Val(SubStr(xVar5,6,2))
   xVar4:= Val(right(xVar5,2))
   xVar1:= IIf(xVar2 > 0,Str(xVar2)+" hora"+IIf(xVar2 > 1,"s",""),"")+IIf(xVar4*xVar3*xVar2 # 0,", ","")+IIf(xVar4 # 0 .AND. xVar3 = 0 .AND. xVar2 # 0 .OR. xVar4 = 0 .AND. xVar3 # 0 .AND. xVar2 # 0," e ","")+IIf(xVar3 > 0,Str(xVar3,IIf(xVar3 > 9,2,1), ;
      0)+" minuto"+IIf(xVar3 > 1,"s","")+IIf(xVar4 > 0," e ",""),"")+IIf(xVar4 > 0,Str(xVar4,IIf(xVar4 > 9,2,1),0)+" segundo"+IIf(xVar4 > 1,"s",""),"")
   Return alltrim(xVar1)

//-------------------------------------------------------------------
Function HSTRING(xArg1)

   Return strzero(Int(xArg1/3600),4,0)+":"+strzero(Int(mod(xArg1/60,60)),2,0)+":"+strzero(Int(mod(xArg1,60)),2,0)

Function EDBF(xArg1,xArg2)

   Local xVar1,xVar2,xVar3,xVar4,xVar5,xVar6,xVar7,xVar8,xVar9
   If (ValType(xArg1) = "U")
      Return .F.
   EndIf
   xArg1:= IIf("." $ xArg1,xArg1,xArg1+".dbf")
   xVar9:= strtran(xArg1,".dbf",extensao(.F.))
   If (!rwrite(xArg1))
      Return .F.
   EndIf
   If (file(xVar9) .AND. !rwrite(xVar9))
      ronly(xArg1)
      Return .F.
   EndIf
   xVar2:= fopen(xArg1,2)
   xVar1:= Space(14)
   xVar3:= fread(xVar2,@xVar1,14)
   xVar4:= Asc(xVar1)
   xVar6:= Chr(0)+Chr(0)
   xVar5:= SubStr(xVar1,11,2)
   xVar7:= SubStr(xVar1,13,2)
   If (PCount() < 2)
      fclose(xVar2)
      If (!(xVar8:= (xVar4 == 3 .OR. xVar4 == 131) .AND. xVar7 = xVar6))
         ronly(xArg1)
         If (file(xVar9))
            ronly(xVar9)
         EndIf
      EndIf
      Return xVar8
   EndIf
   If (xArg2)
      If ((xVar4 == 3 .OR. xVar4 == 131) .AND. xVar5 == xVar6)
         xVar1:= stuff(xVar1,11,2,xVar7)
         xVar1:= stuff(xVar1,13,2,xVar6)
      EndIf
      If (xVar4 == 4 .OR. xVar4 == 132)
         xVar1:= stuff(xVar1,1,1,Chr(xVar4-1))
         xVar1:= stuff(xVar1,11,2,xVar7)
         xVar1:= stuff(xVar1,13,2,xVar6)
      EndIf
   Else
      If ((xVar1:= stuff(xVar1,1,1,Chr(xVar4+1)),(xVar4 == 3 .OR. xVar4 == 131) .AND. xVar5 # xVar6))
         xVar1:= stuff(xVar1,11,2,xVar6)
         xVar1:= stuff(xVar1,13,2,xVar5)
      EndIf
   EndIf
   fseek(xVar2,0,0)
   xVar3:= fwrite(xVar2,xVar1,14)
   fclose(xVar2)
   If (!xArg2)
      ronly(xArg1)
      If (file(xVar9))
         ronly(xVar9)
      EndIf
   EndIf
   Return .T.

//-------------------------------------------------------------------
Function PWORD(xArg1,xArg2,xArg3)

   Local xVar1,xVar2,xVar3,xVar4,xVar5,xVar6,xVar7,xVar8,xVar9,xVar10,xVar11,xVar12:= .F.,xVar13:= {}
   If (ValType(xArg1) == "C")
      xVar5:= xArg1
   Else
      Set Confirm Off
      xVar5:= ""
      xVar11:= SaveScreen(xArg1,xArg2,xArg1,xArg2+6)
      Do While (Len(xVar5) < 6)
         xVar3:= " "
         xVar6:= SetColor("7/0,/0")
         SetPos(xArg1,xArg2+Len(xVar5))
         AAdd(xVar13,__Get({|_1| IIf(_1 == Nil,xVar3,xVar3:= _1)},"pwi","!",Nil,Nil):display())
         ReadModal(xVar13)
         xVar13:= {}
         Set Color To (xVar6)
         If (LastKey() = 13 .AND. Len(xVar5) > 0)
            Exit
         EndIf
         If (LastKey() = 27 .OR. LastKey() = 13)
            If (Empty(xVar5))
               xVar12:= .T.
               Exit
            Else
               xVar5:= ""
               restscr(xArg1,xArg2,xArg1,xArg2+6,xVar11)
               Loop
            EndIf
         EndIf
         xVar5:= xVar5+xVar3
         @ xArg1,xArg2+Len(xVar5)-1 Say "þ"
      EndDo
   EndIf
   Return IIf(xVar12,"",encript(padr(xVar5,6)))

//-------------------------------------------------------------------
Function DLAPSO(xArg1,xArg2)

   Local xVar1,xVar2,xVar3,xVar4,xVar5,xVar6
   xVar6:= ""
   If (PCount() == 1)
      xArg1:= IIf(ValType(xArg1) == "N",xArg1,0)
   Else
      If (ValType(xArg1) == "C")
         xVar6:= SubStr(xArg1,3,1)
         If (Asc(xVar6) >= 48 .AND. Asc(xVar6) <= 57)
            xVar6:= ""
         EndIf
         xVar3:= SubStr(xArg1,1,2)
         xVar4:= SubStr(xArg1,3+Len(xVar6),2)
         xVar5:= SubStr(xArg1,5+2*Len(xVar6))
         d1_:= CToD(Transform(xVar3+xVar4+xVar5,"@R 99/99/9999"))
         xVar6:= SubStr(xArg2,3,1)
         If (Asc(xVar6) >= 48 .AND. Asc(xVar6) <= 57)
            xVar6:= ""
         EndIf
         xVar3:= SubStr(xArg2,1,2)
         xVar4:= SubStr(xArg2,3+Len(xVar6),2)
         xVar5:= SubStr(xArg2,5+2*Len(xVar6))
         d2_:= CToD(Transform(xVar3+xVar4+xVar5,"@R 99/99/9999"))
         xArg1:= d1_-d2_
      Else
         xArg1:= xArg1-xArg2
      EndIf
   EndIf
   xArg1:= Abs(xArg1)
   xVar1:= 0
   Do While (xArg1 >= 365)
      xArg1:= xArg1-365
      xVar1++
   EndDo
   xVar2:= xArg1/30.42
   Do While (xVar2 >= 10.0)
      xVar2:= xVar2-10.0
      xVar1++
   EndDo
   xArg1:= LTrim(Str(Int((xVar2-Int(xVar2))*30.42)))+" dia"
   xArg1:= xArg1+IIf(Val(xArg1) > 1,"s","")
   xVar2:= LTrim(Str(Int(xVar2)))+" mes"+IIf(Int(xVar2) > 1,"es","")
   xVar1:= LTrim(Str(xVar1))+" ano"+IIf(xVar1 > 1,"s","")
   cl_tp:= IIf(Val(xVar1) > 0,xVar1+IIf(Val(xVar2) # 0 .AND. Val(xArg1) # 0 .OR. Val(xVar2) = 0 .AND. Val(xArg1) = 0,", "," e "),"")+IIf(Val(xVar2) > 0,xVar2+IIf(Val(xArg1) > 0," e ",", "),"")+IIf(Val(xArg1) > 0,xArg1,"")
   Return IIf(right(cl_tp,1) = " ",Left(cl_tp,Len(cl_tp)-2),cl_tp)

Function VHORA(xArg1)

   Local xVar1
   xVar1:= IIf(Len(xArg1) = 4 .OR. Len(xArg1) = 6,3,4)
   Return Val(Left(xArg1,2)) < 24 .AND. Val(SubStr(xArg1,xVar1,2)) < 60 .AND. Val(right(xArg1,2)) < 60

Function MTAB(xArg1,xArg2,xArg3,xArg4)

   Local xVar1,xVar2,xVar3,xVar4,xVar5
   xVar3:= 1
   If (ValType(xArg1) = "A")
      xVar4:= xArg1
      xArg1:= ""
      For xVar5:= 1 To Len(xVar4)
         xArg1:= xArg1+"|"+xVar4[xVar5]
      Next
      xArg1:= SubStr(xArg1,2)
   EndIf
   vr_:= readvar()
   vvr_:= &vr_
   If (!Empty(vvr_))
      vvr_:= IIf(Type("vvr_") = "N",alltrim(Str(vvr_,10,0)),vvr_)
      If (Type("acao_mac") = "C")
         xVar4:= "KEYBUFF"
         &xVar4(vvr_)
      Else
         Keyboard vvr_
      EndIf
   EndIf
   xVar1:= dbox(xArg1,xArg3,xArg4,.T.,Nil,xArg2,Nil,Nil,xVar3)
   If (xVar1 > 0)
      For xVar5:= 1 To xVar1-1
         parse(@xArg1,"|")
      Next
      p:= At("|",xArg1)
      If (p > 0)
         xArg1:= Left(xArg1,p-1)
      EndIf
      xArg1:= alltrim(xArg1)
      If (Type("vvr_") = "N")
         xArg1:= alltrim(Str(Val(xArg1),10,0))
      Else
         t_vvr:= Len(vvr_)
         xArg1:= Left(xArg1+Space(t_vvr),t_vvr)
      EndIf
   Else
      xArg1:= ""
   EndIf
   Return xArg1

Function EDIMEMO(xArg1,xArg2,xArg3,xArg4,xArg5,xArg6)

   Local xVar1:= SetColor(),xVar2:= SaveScreen(0,0,MaxRow(),79),xVar3:= .F.,xVar4,xVar5, xVar6_
   Private letras:= "aeioucAEIOUC",tbacento:= " ‚¡¢£‡¡¢£€…Š•£‡¡¢£€ƒˆŒ“‡ŽEI™š€„‰i”‡ŽEI™š€",acento:= "'`^~,",t_w,t_r,t_c,t_t,t_7,cod_sos:= 20, xGravou2
   If (Abs(xArg5-xArg3) < 2 .OR. Abs(xArg6-xArg4) < 15 .OR. LastKey() = 5 .AND. !brw)
      Return .T.
   EndIf
   xArg3:= IIf(xArg3 < 1,1,xArg3)
   xArg5:= IIf(xArg5 > MaxRow(),MaxRow(),xArg5)
   t_w:= SetKey(23,Nil)
   t_r:= SetKey(18,Nil)
   t_c:= SetKey(3,Nil)
   t_t:= SetKey(9,Nil)
   t_7:= SetKey(-6,{|| joganobuff("")})
   x:= 0
   For t:= 1 To Len(xArg1)
      x:= Asc(SubStr(xArg1,t,1))+t
   Next
   xVar4:= novaposi(@xArg3,@xArg4,@xArg5,@xArg6)
   xVar5:= SetKey(-37,Nil)
   Do While (.T.)
      rola_cx:= .F.
      Set Color To (drvcorget)
      caixa(mold,xArg3,xArg4,xArg5,xArg6,78)
      Set Color To ("GR+"+SubStr(drvcorget,At("/",drvcorget)))
      @ xArg3,xArg4+1 Say " "+xArg2+" "
      @ xArg5,xArg4+1 Say " F7=grava, ESC=abandona "
      Set Color To (drvcorget)
      init_count:= 1
      ret_val:= 0
      i_n_s:= sep_pala:= .T.
      deja_vu:= memo_modif:= ins_on:= scrl_on:= .F.
      If (Type("acao_mac") = "C" .AND. acao_mac $ "LCA")
         Keyboard Chr(19)
      EndIf

      xGravou:=.t.
      xVar6_:=&xArg1.
      xVar6_:=memoedit(xVar6_,xArg3+1,xArg4+1,xArg5-1,xArg6-1,.T.,"MFUNC")

      If xGravou
         If (!Empty(alias()))
            Replace &xArg1 With xVar6_
         Else
            &xArg1:= xVar6_
         Endif
      Endif

      SetKey(-37,Nil)
      If (rola_cx)
         muda_pj(@xArg3,@xArg4,@xArg5,@xArg6,xVar2,.T.)
         xVar3:= .T.
         Loop
      EndIf
      Exit
   EndDo
   If (xVar3 .AND. Type("arqconf") = "C")
      Public &xVar4:= Str(xArg3,2)+Str(xArg4,2)
      Save All Like drv* To (arqconf)
      Restore From (arqconf) Additive
   EndIf
   SetKey(-37,xVar5)
   Set Color To (xVar1)
   restscr(0,0,MaxRow(),79,xVar2)
   SetKey(23,t_w)
   SetKey(18,t_r)
   SetKey(3,t_c)
   SetKey(9,t_t)
   SetKey(-6,t_7)
   If (!brw)
      joganobuff("{F7}")
   EndIf
   Return Nil

Function MFUNC

   Parameters mode,line,col
   Private t_e_c_l_a:= LastKey()
   If (IIf(Type("acao_mac") = "C",acao_mac $ "Gg" .AND. t_e_c_l_a # -6,.F.))
      x:= "MONTA_BUFF"
      keyb_mac(&x(t_e_c_l_a))
      q_tec(0)
   EndIf
   ret_val:= 0
   If (mode = 3)
      If (init_count == 1)
         ins_mode:= readinsert()
         If (ins_on .AND. !ins_mode .OR. !ins_on .AND. ins_mode)
            ret_val:= 22
         Else
            init_count:= 2
         EndIf
      EndIf
      If (init_count == 2)
         If ((!scrl_on .AND. !i_n_s .OR. scrl_on .AND. i_n_s) .AND. !deja_vu)
            deja_vu:= .T.
            ret_val:= 35
         Else
            init_count:= 3
            deja_vu:= .F.
         EndIf
      EndIf
      If (init_count == 3)
         If (!sep_pala .AND. !deja_vu)
            deja_vu:= .T.
            ret_val:= 34
         Else
            init_count:= 4
            deja_vu:= .F.
         EndIf
      EndIf
      If (init_count == 4)
         ret_val:= 0
      EndIf
   Else
      If (mode = 0)
         p1:= At(Chr(t_e_c_l_a),acento)
         If (p1 > 0 .AND. IIf(Type("acao_mac") = "C",acao_mac = "D",.T.))
            t_c_:= q_tec(0)
            If (IIf(p1 = 5,t_c_ = 67 .OR. t_c_ = 99,Chr(t_c_) $ letras))
               If (p1 == 5)
                  car:= IIf(t_c_ = 67,"€","‡")
               Else
                  p2:= At(Chr(t_c_),letras)
                  car:= SubStr(tbacento,p1*12-11+(p2-1),1)
               EndIf
               joganobuff(IIf(readinsert(),"","")+car)
            Else
               joganobuff(Chr(t_c_))
            EndIf
         EndIf
      Else
         t_e_c_l_a:= LastKey()
         If (mode == 2)
            memo_modif:= .T.
         EndIf
         If (t_e_c_l_a = -37)
            rola_cx:= .T.
            ret_val:= 23
         Else
            If (t_e_c_l_a = 23)
               If (!memo_modif)
               Else
                  ret_val:= 23
               EndIf
            Else
               If (t_e_c_l_a = 27)
                  If (!memo_modif)
                     xGravou:=.f.
                     ret_val:= 23
                  Else
                     op_mf:= dbox("Sim|N„o",Nil,Nil,.T.,Nil,"ABANDONAR ALTERA€ŽO")
                     If (op_mf == 1)
                        xGravou:=.f.
                        ret_val:= 23
                     Else
                        ret_val:= 32
                     EndIf
                  EndIf
               Else
                  If (t_e_c_l_a = -7 .AND. i_n_s)
                     sep_pala:= !sep_pala
                     ret_val:= 34
                  Else
                     If (t_e_c_l_a = -9)
                        scrl_on:= !scrl_on
                        ret_val:= 35
                     Else
                        If ((t_e_c_l_a = 279 .OR. t_e_c_l_a = 22) .AND. i_n_s)
                           ins_on:= !ins_on
                           ret_val:= 22
                        EndIf
                     EndIf
                  EndIf
               EndIf
            EndIf
         EndIf
      EndIf
   EndIf
   If (IIf(Type("acao_mac") = "C",acao_mac $ "LAC" .AND. t_e_c_l_a # -6,.F.))
      x:= "MONTA_BUFF"
      keyb_mac(&x(q_tec(0)))
   EndIf
   Return ret_val

Function CALCDATA(xArg1,xArg2)

   Local xVar1,xVar2,xVar3,xVar4,xVar5,xVar6
   xVar6:= ""
   Set Date British
   If (Type("d_t") == "D")
      xVar1:= xArg1+xArg2
   Else
      xVar6:= SubStr(xArg1,3,1)
      If (Asc(xVar6) >= 48 .AND. Asc(xVar6) <= 57)
         xVar6:= ""
      EndIf
      xVar3:= SubStr(xArg1,1,2)
      xVar4:= SubStr(xArg1,3+Len(xVar6),2)
      xVar5:= SubStr(xArg1,5+2*Len(xVar6))
      d1_:= CToD(Transform(xVar3+xVar4+xVar5,"@R 99/99/9999"))
      d1_:= d1_+xArg2
      d1_:= DToS(d1_)
      xVar1:= SubStr(d1_,7,2)+xVar6+SubStr(d1_,5,2)+xVar6+right(SubStr(d1_,1,4),Len(xVar5))
   EndIf
   Return xVar1

Function IMPAC(xArg1,xArg2,xArg3,xArg4)

   Local xVar1:= "aeioucAEIOUC",xVar2:= " ‚¡¢£‡¡¢£€ÿ…Š•£‡¡¢£€ÿ„‰ÿ”‡Žÿÿ™š€ÿƒˆŒ“‡Žÿÿ™š€",xVar3:= "'`~^",xVar4,xVar5,xVar6,xVar7
   xVar6:= IIf(Type("tps") == "N",tps = 1,.T.)
   xVar6:= IIf(Type("drvpadrao") == "C",Val(drvpadrao) < 5 .AND. xVar6,xVar6)
   xArg4:= IIf(xArg3 = Nil,xArg2,xArg4)
   xArg4:= IIf(ValType(xArg4) = "L",xArg4,.F.)
   If (xArg4 .AND. At(" ",Trim(xArg1)) > 0 .AND. right(Trim(xArg1),1) # ".")
      xArg4:= Len(xArg1)
      xVar4:= " "
      xArg1:= Trim(xArg1)
      Do While (xArg4-Len(xArg1) > 0)
         xVar5:= xArg4-Len(xArg1)
         If (xVar5 > 0)
            xArg1:= strtran(xArg1,xVar4,xVar4+" ",1,xVar5)
         EndIf
      EndDo
   EndIf
   ts_:= Len(xArg1)
   If (xVar6)
      For xVar7:= 1 To Len(xArg1)
         xVar5:= At(SubStr(xArg1,xVar7,1),xVar2)
         If (xVar5 > 0)
            If (SubStr(xArg1,xVar7,1) $ "€‡")
               xVar4:= IIf(SubStr(xArg1,xVar7,1) = "€","C","c")+""+","
            Else
               xVar4:= SubStr(xVar1,xVar5%13,1)+""+SubStr(xVar3,Int(xVar5/13)+1,1)
            EndIf
            xArg1:= Left(xArg1,xVar7-1)+xVar4+SubStr(xArg1,xVar7+1)
            xVar7:= xVar7+2
         EndIf
      Next
   EndIf
   If (xArg3 # Nil)
      @ xArg2,xArg3 Say xArg1
      setprc(xArg2,xArg3+ts_+Set(25))
   EndIf
   Return xArg1

Static Function ACHAPOIN(xArg1,xArg2)

   Local xVar1,xVar2
   xVar2:= 2
   poin:= 1
   For xVar1:= 1 To Len(xArg1)
      If (xVar2+Len(xArg1[xVar1])+2 > 78)
         poin:= xVar1
         xVar2:= 2
      EndIf
      xVar2:= xVar2+(Len(xArg1[xVar1])+2)
      If (xVar1 = xArg2)
         Exit
      EndIf
   Next
   Return poin

Static Function MENUV(xArg1,xArg2,xArg3,xArg4,xArg5,xArg6,xArg7)

   Local xVar1,xVar2,xVar3,xVar4,xVar5,xVar6,xVar7,xVar8,xVar9,xVar10,xVar11,xVar12,xVar13,xVar14,xVar15,xVar16,xVar17,xVar18
   xVar17:= .T.
   xVar13:= Len(xArg1)
   xArg3:= Int(IIf(xArg3 = Nil .OR. xArg3 < 1,1,IIf(xArg3 > xVar13,xVar13,xArg3)))
   xArg4:= IIf(xVar13 < xArg4,xVar13,xArg4)-1
   xVar1:= 0
   xVar2:= xArg5+1
   If (drvmouse)
      x:= "MOUSEBOX"
      &x(xArg5,xArg6,xArg5+xArg4,xArg6+xArg7-IIf(xVar13-1 = xArg4,1,0))
   EndIf
   If (xVar13-1 > xArg4)
      @ xArg5,xArg6+xArg7 Say ""
      @ xArg5+xArg4,xArg6+xArg7 Say ""
      For xVar3:= 1 To xArg4-1
         @ xArg5+xVar3,xArg6+xArg7 Say "±"
      Next
   EndIf
   xVar4:= ""
   xVar5:= Len(xVar4)+1
   If (xArg3 <= xArg4+1)
      xVar6:= 1
      xVar7:= xArg3
   Else
      xVar6:= xArg3-xArg4
      xVar7:= xArg4+1
   EndIf
   Do While (xArg1[xArg3] == "---")
      If (xVar7 <= xArg4)
         xArg3++
         xVar7++
      Else
         If (xArg3 < xVar13)
            xVar6++
            xArg3++
            xVar17:= .T.
         Else
            Exit
         EndIf
      EndIf
   EndDo
   xVar8:= xVar14:= xVar15:= ppp:= 0
   xVar16:= invcor(drvcorget)
   Do While (xVar8 # 13 .AND. xArg3 # 0)
      If (xVar17)
         xVar10:= xArg5
         For xVar9:= xVar6 To xVar6+xArg4
            Set Color To (tit_op)
            If (xArg1[xVar9] == "---")
               @ xVar10,xArg6-1 Say SubStr(mold,9,1)+Replicate(SubStr(mold,10,1),xArg7)
               If (xVar13-1 <= xArg4)
                  @ xVar10,xArg6+xArg7 Say SubStr(mold,11,1)
               EndIf
            Else
               @ xVar10,xArg6-1 Say SubStr(mold,8,1)
               If (xVar13-1 <= xArg4)
                  @ xVar10,xArg6+xArg7 Say SubStr(mold,4,1)
               EndIf
               If (xVar9 = xArg3)
                  Set Color To (xVar16)
               Else
                  Set Color To (cor_op)
               EndIf
               @ xVar10,xArg6 Say xArg1[xVar9]
               ki:= Left(LTrim(xArg1[xVar9]),Len(xVar4))
               If (Upper(ki) = xVar4 .AND. xVar9 = xArg3)
                  px:= Len(xArg1[xVar9])-Len(LTrim(xArg1[xVar9]))
                  Set Color To (drvcorenf)
                  @ xVar10,xArg6+px Say ki
               EndIf
            EndIf
            xVar10++
         Next
         Set Color To (cor_op)
         xVar17:= .F.
      EndIf
      If (xVar13 > xArg4+1)
         Set Color To (cor_op)
         @ xVar2,xArg6+xArg7 Say "±"
         xVar2:= xArg5+1+Int(xArg3/(xVar13/(xArg4-2)))
         @ xVar2,xArg6+xArg7 Say "Û"
      EndIf
      If (drvmouse)
         x:= "MOUSECUR"
         &x(.T.)
         xVar8:= 0
         Do While (xVar8 = 0)
            xVar18:= xVar14
            x:= "MOUSEGET"
            pp:= &x(@xVar14,@xVar15)
            x:= "POEHORA"
            &x()
            xVar8:= nextkey()
            If (pp = 1 .AND. xVar8 = 0)
               ppp:= IIf(xVar18 # xVar14,0,ppp)
               press:= Seconds() > ppp+0.5
               If ((ppp = 0 .OR. press) .AND. xVar14 >= xArg5 .AND. xVar14 <= xArg5+xArg4 .AND. xVar15 >= xArg6 .AND. xVar15 <= xArg6+xArg7-IIf(xVar13-1 = xArg4,1,0))
                  If (xVar14 = xArg5 .AND. xVar15 = xArg6+xArg7)
                     joganobuff("")
                  Else
                     If (xVar14 = xArg5+xArg4 .AND. xVar15 = xArg6+xArg7)
                        joganobuff("")
                     Else
                        If (xVar15 = xArg6+xArg7)
                           joganobuff(Chr(IIf(xVar14 > xVar2,3,18)))
                        Else
                           xVar3:= xArg3
                           If (!(xArg1[xVar6+xVar14-xArg5] == "---"))
                              xArg3:= xVar6+xVar14-xArg5
                              xVar7:= xVar14-xArg5+1
                              If (ppp # 0)
                                 rola_cx:= .T.
                                 joganobuff(Chr(13))
                              Else
                                 If (xVar3 = xArg3)
                                    joganobuff(Chr(13))
                                 Else
                                    x:= "MOUSECUR"
                                    &x(.F.)
                                    @ xVar3+xArg5-xVar6,xArg6 Say xArg1[xVar3]
                                    Set Color To (xVar16)
                                    @ xArg3+xArg5-xVar6,xArg6 Say xArg1[xArg3]
                                    Set Color To (cor_op)
                                    x:= "MOUSECUR"
                                    &x(.T.)
                                 EndIf
                              EndIf
                           EndIf
                        EndIf
                     EndIf
                  EndIf
               EndIf
               ppp:= IIf(ppp = 0,Seconds(),ppp)
            Else
               If (pp == 2)
                  joganobuff("")
               Else
                  If (pp == 0)
                     ppp:= 0
                  EndIf
               EndIf
            EndIf
         EndDo
         x:= "MOUSECUR"
         &x(.F.)
      EndIf
      xVar8:= q_tec(0)
      If (xVar8 > 31 .AND. xVar8 < 127)
         xVar4:= xVar4+Upper(Chr(xVar8))
         Do While (.T.)
            For xVar9:= 1 To xVar13
               If ((xVar12:= Upper(Left((xVar11:= alltrim(xArg1[xVar9]),xVar11),xVar5)),xVar1:= xVar4 = xVar12,!(xArg1[xVar9] == "---") .AND. xVar1))
                  xArg3:= xVar9
                  xVar5++
                  xVar9:= 999
                  If (xArg3 <= xArg4+1)
                     xVar6:= 1
                     xVar7:= xArg3
                  Else
                     xVar6:= xArg3-xArg4
                     xVar7:= xArg4+1
                  EndIf
               EndIf
            Next
            If (xVar9 = xVar13+1 .AND. Len(xVar4) > 1)
               xVar4:= right(xVar4,1)
               xVar5:= 1
            Else
               Exit
            EndIf
         EndDo
         xVar17:= .T.
      Else
//        If ((eval(SetKey(xVar8)),SetKey(xVar8) # Nil .AND. drvmouse))
//           x:= "MOUSEBOX"
//           &x(xArg5,xArg6,xArg5+xArg4,xArg6+xArg7-IIf(xVar13-1 = xArg4,1,0))
//        EndIf
         If SetKey(xVar8)<>Nil
            EVAL(SetKey(xVar8))
         endi
         If (xVar8 == 27)
            xArg3:= 0
            Exit
         EndIf
         If (xVar8 == 7)
            volta_ac:= .T.
            Exit
         EndIf
         xVar4:= ""
         xVar5:= 1
         @ xArg3+xArg5-xVar6,xArg6 Say xArg1[xArg3]
         If (xVar8 == -30)
            drvautohelp:= !drvautohelp
         EndIf
         If (xVar8 == 24)
            Do While (.T.)
               If (xVar7 <= xArg4)
                  xArg3++
                  xVar7++
               Else
                  If (xArg3 < xVar13)
                     xVar6++
                     xArg3++
                     xVar17:= .T.
                  Else
                     xVar8:= IIf(Set(35),1,xVar8)
                  EndIf
               EndIf
               If (xVar8 # 24 .OR. !(xArg1[xArg3] == "---"))
                  Exit
               EndIf
            EndDo
         EndIf
         If (xVar8 == -37)
            rola_cx:= .T.
            xVar8:= 13
         EndIf
         If (xVar8 == 1)
            xVar7:= 1
            xVar6:= 1
            xArg3:= 1
            xVar17:= .T.
            Do While (xArg1[xArg3] == "---")
               If (xVar7 <= xArg4)
                  xArg3++
                  xVar7++
               Else
                  If (xArg3 < xVar13)
                     xVar6++
                     xArg3++
                     xVar17:= .T.
                  Else
                     Exit
                  EndIf
               EndIf
            EndDo
         EndIf
         If (xVar8 == 5)
            Do While (.T.)
               If (xVar7 > 1)
                  xArg3--
                  xVar7--
               Else
                  If (xArg3 > 1)
                     xVar6--
                     xArg3--
                     xVar17:= .T.
                  Else
                     xVar8:= IIf(Set(35),6,xVar8)
                  EndIf
               EndIf
               If (xVar8 # 5 .OR. !(xArg1[xArg3] == "---"))
                  Exit
               EndIf
            EndDo
         EndIf
         If (xVar8 == 6)
            xVar7:= xArg4+1
            xArg3:= xVar13
            xVar6:= xVar13-xArg4
            xVar17:= .T.
            Do While (xArg1[xArg3] == "---")
               If (xVar7 > 1)
                  xArg3--
                  xVar7--
               Else
                  If (xArg3 > 1)
                     xVar6--
                     xArg3--
                     xVar17:= .T.
                  Else
                     Exit
                  EndIf
               EndIf
            EndDo
         EndIf
         If (xVar8 == 3)
            xVar7:= xArg4+1
            xVar6:= xVar6+xArg4
            If (xVar6 > xVar13-xArg4)
               xVar6:= xVar13-xArg4
            EndIf
            xArg3:= xVar6+xVar7-1
            xVar17:= .T.
         EndIf
         If (xVar8 == 18)
            xVar7:= 1
            xVar6:= xVar6-xArg4
            If (xVar6 < 1)
               xVar6:= 1
            EndIf
            xArg3:= xVar6+xVar7-1
            xVar17:= .T.
         EndIf
         If (!xVar17)
            Set Color To (xVar16)
            @ xArg3+xArg5-xVar6,xArg6 Say xArg1[xArg3]
            Set Color To (cor_op)
         EndIf
      EndIf
   EndDo
   xVar4:= ""
   Return IIf(xArg3 > 0,xArg2[xArg3],0)

Static Function MENUH(xArg1,xArg2,xArg3,xArg4)

   Local xVar1,xVar2,xVar3:= "",xVar4:= 1,xVar5,xVar6,xVar7,xVar8,xVar9,xVar10,xVar11:= 0,xVar12,xVar13,xVar14
   xVar10:= Len(xArg1)
   xArg3:= Int(IIf(xArg3 = Nil .OR. xArg3 < 1,1,IIf(xArg3 > xVar10,xVar10,xArg3)))
   For xVar2:= 1 To xVar10
      xVar11:= xVar11+(Len(xArg1[xVar2])+2)
   Next
   xVar5:= achapoin(xArg1,xArg3)
   xVar1:= 0
   If (drvmouse)
      x:= "MOUSEBOX"
      &x(xArg4,0,xArg4,79)
   EndIf
   xVar14:= invcor(drvcorget)
   Do While (xVar6 # 13 .AND. xArg3 # 0)
      @ xArg4, 0
      colj:= 2
      For xVar7:= xVar5 To xVar10
         If (colj+Len(xArg1[xVar7])+2 > 78)
            Exit
         EndIf
         If (xVar7 = xArg3)
            Set Color To (xVar14)
            colopsel:= colj
         Else
            Set Color To (cor_op)
         EndIf
         @ xArg4,colj Say xArg1[xVar7]
         If (Len(xVar3) > 0 .AND. xVar7 = xArg3 .AND. Upper((xVar8:= Left(xArg1[xVar7],Len(xVar3)),xVar8)) = xVar3)
            Set Color To (drvcorenf)
            @ xArg4,colj Say xVar8
         EndIf
         colj:= colj+(Len(xArg1[xVar7])+2)
         pofn:= xVar7
      Next
      Set Color To (cor_op)
      If (xVar11 > 78)
         @ xArg4, 0 Say ""
         @ xArg4,79 Say Chr(26)
      EndIf
      If (drvmouse)
         x:= "MOUSETECLA"
         xVar6:= &x(xArg4,0,xArg4,79)
         x:= "MOUSEGET"
         &x(@xVar12,@xVar13)
      Else
         xVar6:= q_tec(0)
      EndIf
      If (xVar6 > 31 .AND. xVar6 < 127)
         xVar3:= xVar3+Upper(Chr(xVar6))
         Do While (.T.)
            For xVar7:= 1 To xVar10
               xVar8:= xArg1[xVar7]
               xVar9:= Upper(Left(xVar8,xVar4))
               xVar1:= xVar3 = xVar9
               If (xVar1)
                  xArg3:= xVar7
                  xVar4++
                  xVar7:= 999
                  xVar5:= achapoin(xArg1,xArg3)
               EndIf
            Next
            If (xVar7 = xVar10+1 .AND. Len(xVar3) > 1)
               xVar3:= right(xVar3,1)
               xVar4:= 1
            Else
               Exit
            EndIf
         EndDo
      Else
         If (SetKey(xVar6) # Nil)
            eval(SetKey(xVar6))
         EndIf
         If (xVar6 == 27)
            xArg3:= 0
            Exit
         EndIf
         If (xVar6 # 13)
            xVar3:= ""
            xVar4:= 1
            @ xArg4,colopsel Say xArg1[xArg3]
         EndIf
         If (xVar6 == -100)
            colj:= 2
            For xVar2:= xVar5 To pofn
               If (xVar13 >= colj .AND. xVar13 <= colj+Len(xArg1[xVar2]))
                  If (xArg3 = xVar2)
                     xVar6:= 13
                  Else
                     xArg3:= xVar2
                  EndIf
                  Exit
               EndIf
               colj:= colj+(Len(xArg1[xVar2])+2)
            Next
         EndIf
         If (xVar6 = 24 .OR. xVar6 = 4)
            If (xArg3 < xVar10)
               xArg3++
               If (xArg3 > pofn)
                  xVar5:= achapoin(xArg1,xArg3)
               EndIf
            Else
               If (Set(35))
                  xVar6:= 1
               EndIf
            EndIf
         EndIf
         If (xVar6 == -30)
            drvautohelp:= !drvautohelp
         EndIf
         If (xVar6 == -37)
            rola_cx:= .T.
            xVar6:= 13
         EndIf
         If (xVar6 == 1)
            xVar5:= 1
            xArg3:= 1
         EndIf
         If (xVar6 = 5 .OR. xVar6 = 19)
            If (xArg3 > 1)
               xArg3--
               If (xArg3 < xVar5)
                  xVar5:= achapoin(xArg1,xArg3)
               EndIf
            Else
               If (Set(35))
                  xVar6:= 6
               EndIf
            EndIf
         EndIf
         If (xVar6 == 6)
            xArg3:= xVar10
            xVar5:= achapoin(xArg1,xArg3)
         EndIf
      EndIf
   EndDo
   xVar3:= ""
   Return IIf(xArg3 > 0,xArg2[xArg3],0)

Static Function DIVISORINT(xArg1,xArg2)

   Local xVar1,xVar2
   xVar2:= Int(xArg1/xArg2)
   xVar1:= xArg1/xArg2-xVar2
   If (xVar1 > 0)
      xVar2++
   EndIf
   Return xVar2*xArg2

Static Procedure COMANDO_MA(xArg1)

   Local xVar1,xVar2,xVar3,xVar4
   If (xArg1 > 47 .AND. xArg1 < 58)
      fat_mac:= xArg1-48
   Else
      If (xArg1 == 42)
         fat_mac:= 100
      Else
         If ((xArg1 = 46 .OR. xArg1 = 9) .AND. acao_mac = "C")
            If (xArg1 == 9)
               xVar2:= IIf("." $ arq_mac,Left(arq_mac,At(".",arq_mac)-1),arq_mac)+".$$$"
               If (file(xVar2))
                  Erase (xVar2)
               EndIf
               xVar4:= fseek(handle_mac,0,1)
               xVar3:= fcreate(xVar2)
               xVar1:= 512
               Do While (xVar1 = 512)
                  buffer_mac:= Space(512)
                  xVar1:= fread(handle_mac,@buffer_mac,512)
                  fwrite(xVar3,buffer_mac,xVar1)
               EndDo
               fclose(xVar3)
               fseek(handle_mac,xVar4,0)
               acao_mac:= "g"
            Else
               acao_mac:= "G"
            EndIf
            fwrite(handle_mac,"")
            fclose(handle_mac)
            handle_mac:= fopen(arq_mac,1)
            fseek(handle_mac,0,2)
            xArg1:= 0
         Else
            If (xArg1 == 27)
               acao_mac:= "D"
               fclose(handle_mac)
            EndIf
         EndIf
      EndIf
   EndIf
   Return

Static Function BARRACHEIA(xArg1,xArg2)

   Local xVar1
   xVar1:= ""
   If (drvpadrao == "1" .OR. drvpadrao == "2" .OR. drvpadrao == "3")
      xVar1:= Replicate("ÿ",Round(xArg1*(240/72),0))
   Else
      If (drvpadrao == "4")
         xVar1:= Replicate("ÿÿü",Round(xArg1*(180/72),0))
      Else
         If (drvpadrao == "5" .OR. drvpadrao == "6")
            xVar1:= Replicate("1",Round(300/72*xArg1,0))
         Else
            If (drvpadrao == "7" .OR. drvpadrao == "8")
               xVar1:= ""+"&f0S"+""+"&a-"+LTrim(Str(xArg2*10*0.75))+"V"+""+"*c"+LTrim(Str(xArg1*10))+"H"+""+"*c"+LTrim(Str(xArg2*10))+"V"+""+"*c0P"+""+"&f1S"+""+"&a+"+LTrim(Str(xArg1*10))+"H"
            EndIf
         EndIf
      EndIf
   EndIf
   Return xVar1

//-------------------------------------------------------------------

Static Function CBPARC(xArg1,xArg2,xArg3,xArg4,xArg5)

   Local xVar1,xVar2,xVar3,xVar4,xVar5,xVar6,xVar7,xVar8,xVar9,xVar10
   xVar2:= 0
   xVar10:= Val(SubStr(xArg1,1,1))
   xArg1:= SubStr(xArg1,2)
   xVar5:= Len(xArg1)
   For xVar3:= 1 To xVar5
      If (SubStr(xArg1,xVar3,1) == "1" .OR. SubStr(xArg1,xVar3,1) == "2")
         xVar2++
      Else
         Do Case
         Case xVar10==4
            xVar2:= xVar2+2.52
         Case xVar10==5
            xVar2:= xVar2+2.0
         EndCase
      EndIf
   Next
   xVar4:= IIf(xVar2 # 0,72/xArg3*xArg2/xVar2,0)
   xVar6:= barravazia(xVar4)
   xVar7:= barracheia(xVar4,xArg4)
   Do Case
   Case xVar10==4
      xVar8:= barravazia(xVar4*2.52)
      xVar9:= barracheia(xVar4*2.52,xArg4)
   Case xVar10==5
      xVar8:= barravazia(xVar4*2.0)
      xVar9:= barracheia(xVar4*2.0,xArg4)
   EndCase
   xVar1:= ""
   For xVar3:= 1 To xVar5
      If (SubStr(xArg1,xVar3,1) == "1")
         xVar1:= xVar1+xVar6
         xArg5:= xArg5+xVar4
      Else
         If (SubStr(xArg1,xVar3,1) == "2")
            xVar1:= xVar1+xVar7
            xArg5:= xArg5+xVar4
         Else
            If (SubStr(xArg1,xVar3,1) == "3")
               xVar1:= xVar1+xVar8
               xArg5:= xArg5+xVar4*IIf(xVar10 == 4,2.52,2)
            Else
               If (SubStr(xArg1,xVar3,1) == "4")
                  xVar1:= xVar1+xVar9
                  xArg5:= xArg5+xVar4*IIf(xVar10 == 4,2.52,2)
               EndIf
            EndIf
         EndIf
      EndIf
   Next
   Return xVar1

//-------------------------------------------------------------------
Static Function CVBINT(xArg1)

   Local xVar1,xVar2:= 0,xVar3:= Len(xArg1)
   For xVar1:= xVar3 To 1 Step -1
      If (SubStr(xArg1,xVar1,1) == "1")
         xVar2:= xVar2+2^(xVar3-xVar1)
      EndIf
   Next
   Return xVar2

//-------------------------------------------------------------------
Static Function BARRAVAZIA(xArg1)

   Local xVar1
   xVar1:= ""
   If (drvpadrao == "1" .OR. drvpadrao == "2" .OR. drvpadrao == "3")
      xVar1:= Replicate(Chr(0),Round(xArg1*(240/72),0))
   Else
      If (drvpadrao == "4")
         xVar1:= Replicate(Chr(0)+Chr(0)+Chr(0),Round(xArg1*(180/72),0))
      Else
         If (drvpadrao == "5" .OR. drvpadrao == "6")
            xVar1:= Replicate("0",Round(300/72*xArg1,0))
         Else
            If (drvpadrao == "7" .OR. drvpadrao == "8")
               xVar1:= ""+"&a+"+LTrim(Str(xArg1*10))+"H"
            EndIf
         EndIf
      EndIf
   EndIf
   Return xVar1

//-------------------------------------------------------------------
Static Function MONTABAR(xArg1,xArg2)

   Do Case
   Case xArg1==1
      Static13:= {}
      AAdd(Static13,"")
   Case xArg1==2
      If (Len(ATail(Static13))+Len(xArg2) < 50000.0)
         Static13[Len(Static13)]:= Static13[Len(Static13)]+xArg2
      Else
         AAdd(Static13,xArg2)
      EndIf
   Case xArg1==3
   EndCase
   Return .T.

//-------------------------------------------------------------------
Static Function CODTUDO(xArg1,xArg2,xArg3,xArg4,xArg5)

   Local xVar1:= "",xVar2,xVar3,xVar4,xVar5,xVar6:= .T.
   If (drvpadrao == "1" .OR. drvpadrao == "2" .OR. drvpadrao == "3")
      xVar6:= montabar(2, ;
         "UZ"+Chr(Len(xArg1)%256)+Chr(Int(Len(xArg1)/256))+xArg1+""+"J"+""+Chr(13)+Space(xArg2)+""+"Z"+Chr(Len(xArg1)%256)+Chr(Int(Len(xArg1)/256))+xArg1+""+"J"+Chr((xArg4-8)*3-1)+Chr(13)+Space(xArg2)+""+"Z"+Chr(Len(xArg1)%256)+Chr(Int(Len(xArg1)/256))+xArg1+""+"J"+""+Chr(13)+Space(xArg2)+""+"Z"+Chr(Len(xArg1)%256)+Chr(Int(Len(xArg1)/256))+xArg1+""+"J"+""+Chr(13)+""+"U"+Chr(0))
   Else
      If (drvpadrao == "4")
         If (xVar6:= montabar(2,"U*'"+Chr(Len(xArg1)/3%256)+Chr(Int(Len(xArg1)/3/256))+xArg1))
            If (xArg4 == 12)
               xVar6:= montabar(2,"J"+Chr(10)+Chr(13)+Space(xArg2)+""+"*"+"'"+Chr(Len(xArg1)/3%256)+Chr(Int(Len(xArg1)/3/256))+xArg1+""+"J"+""+Chr(13))
            Else
               xVar6:= montabar(2,Chr(13)+Chr(10))
            EndIf
            If (xVar6)
               xVar6:= montabar(2,"U"+Chr(0))
            EndIf
         EndIf
      Else
         If (drvpadrao == "5" .OR. drvpadrao == "6")
            xVar2:= divisorint(Len(xArg1),8)
            xArg1:= xArg1+Replicate("0",xVar2+Len(xArg1))
            For xVar4:= 1 To xVar2 Step 8
               xVar5:= SubStr(xArg1,xVar4,8)
               If (xVar5 == "00000000")
                  xVar1:= xVar1+Chr(0)
               Else
                  If (xVar5 == "11111111")
                     xVar1:= xVar1+"ÿ"
                  Else
                     xVar1:= xVar1+Chr(cvbint(SubStr(xArg1,xVar4,8)))
                  EndIf
               EndIf
            Next
            If (drvpadrao == "5")
               xVar1:= Replicate(Chr(0),Int(300/xArg3*xArg2/8))+xVar1
               xVar1:= "*b"+LTrim(Str(Len(xVar1)))+"W"+xVar1
            Else
               xVar1:= "*b"+LTrim(Str(Len(xVar1)))+"W"+xVar1
               xVar1:= "*b"+LTrim(Str(300/xArg3*xArg2))+"X"+xVar1
            EndIf
            xVar3:= Round(300/72*xArg4,0)
            If (xVar6:= montabar(2,"*t300R"+"&a-"+LTrim(Str(xArg4*10*0.75))+"V"+""+"*r0A"))
               For xVar4:= 1 To xVar3
                  If (!(xVar6:= montabar(2,xVar1)))
                     Exit
                  EndIf
               Next
               If (xVar6 .AND. (xVar6:= montabar(2,"*rB"+"&a-"+LTrim(Str(xArg4*10*0.25))+"V"+""+"&a"+LTrim(Str(xArg2))+"C")))
                  xVar6:= montabar(2,Chr(13)+Chr(10))
               EndIf
            EndIf
         Else
            If (drvpadrao == "7" .OR. drvpadrao == "8")
               If ((xVar6:= montabar(2,"*t300R"+"&f0S"+xArg1+""+"&f1S")) .AND. xArg5)
                  xVar6:= montabar(2,Chr(13)+Chr(10))
               EndIf
            Else
               xVar6:= montabar(2,Chr(13)+Chr(10))
            EndIf
         EndIf
      EndIf
   EndIf
   Return xVar6

Function __XRESTSCR

   If (Static11 # Nil)
      Restore Screen From Static11[3]
      SetPos(Static11[1],Static11[2])
   EndIf
   Static11:= Nil
   Return Nil

Function __XSAVESCR

   Static11:= {Row(),Col(),SaveScreen(0,0,MaxRow(),MaxCol())}
   Return Nil

//Function TSTRING(xArg1)
// Return strzero(Int(mod(xArg1/3600,24)),2,0)+":"+strzero(Int(mod(xArg1/60,60)),2,0)+":"+strzero(Int(mod(xArg1,60)),2,0)

FUNCTION VAL_AX
RETURN 0

FUNCTION VAL_BX
RETURN 0


function encript(frase)
frase:=CRIPTOGRAFA(frase,"teste", .T.)
return frase

function decript(frase)
frase:=CRIPTOGRAFA(frase,"teste", .F.)
return frase


Function CRIPTOGRAFA(Pstr, Psenha, Pencript)
LOCAL Tcript, Tx, Tascii
LOCAL Tlensenha
Tlensenha = Len(AllTrim(Psenha))
Tcript = ""
For Tx = 1 To Len(Pstr)
   If Pencript   // Criptografa
      Tascii = Asc(Subs(Pstr, Tx, 1)) + ;
                             Asc(Subs(Psenha, ((Tx + 77) % Tlensenha) + 1, 1))
   Else          // DesCriptografa
      Tascii = Asc(Subs(Pstr, Tx, 1)) - ;
                             Asc(Subs(Psenha, ((Tx + 77) % Tlensenha) + 1, 1))
   EndIf
   Tcript = Tcript + Chr(Tascii)
Next
Return(Tcript)

function odometer
IF !(ntx = aGauge_alias)
 aGauge_alias:=ntx
 aGauge_count:=0
 aGauge := GaugeNew( 13, 10, 15, 60, "W/B", "W+/B" )
 GaugeDisplay( aGauge )
ENDI
//nPercent:=(aGauge_count++/lastrec())
IF (ide_maq$aGauge_alias)
 GaugeUpdate( aGauge, (aGauge_count++/lastrec()) )
ELSE
 GaugeUpdate( aGauge, (recno()/lastrec()) )
ENDI
retu .t. 

function freetslice
retu .t.

/*
 * $Id: testgaug.prg 9198 2008-08-20 09:56:47Z vszakats $
 */

/* Testing Harbour's Gauge */

/***
*
*  Gauge.prg
*
*  Sample functions to create, display, and update a percentage completed
*  progress gauge.  This function can be used for creating user interface 
*  options such as a status bar to indicate the current status of a process.
*
*  Copyright (c) 1993, Computer Associates International Inc.
*  All rights reserved.
*
*  Note: Compile with /W /N options
*
*/

// Box array definitions
#define B_LEN           9
#define B_TOP           1
#define B_LEFT          2
#define B_BOTTOM        3
#define B_RIGHT         4
#define B_BACKCOLOR     5
#define B_BARCOLOR      6
#define B_DISPLAYNUM    7
#define B_BARCHAR       8
#define B_PERCENT       9

#define B_BOXLINES      "ÚÄ¿³ÙÄÀ³"


/***
*  GaugeNew( <nRowTop>, <nColumnTop>, <nRowBottom>, <nColumnBottom>, 
*     [<cBackgroundColor>], 
*     [<cGaugeColor>], 
*     [<cGaugeCharacter>] ) --> aGauge
*
*  Create a new gauge array
*
*/
FUNCTION GaugeNew( nTop, nLeft, nBottom, nRight, ;
                 cBackColor, cBarColor, cBarCharacter )

   LOCAL aHandle[ B_LEN ]     // Contains info about the gauge

   // Assign default values
   aHandle[ B_TOP ]        := nTop
   aHandle[ B_LEFT ]       := nLeft
   aHandle[ B_BOTTOM ]     := nBottom
   aHandle[ B_RIGHT ]      := nRight
   aHandle[ B_BACKCOLOR ]  := "W/N"
   aHandle[ B_BARCOLOR ]   := "W+/N"
   aHandle[ B_DISPLAYNUM ] := .T.
   aHandle[ B_BARCHAR ]    := CHR( 219 )
   aHandle[ B_PERCENT ]    := 0

   // Resolve parameters
   IF cBackColor <> NIL
      aHandle[ B_BACKCOLOR ] := cBackColor
   ENDIF

   IF cBarColor <> NIL
      aHandle[ B_BARCOLOR ] := cBarColor
   ENDIF

   IF cBarCharacter <> NIL
      aHandle[ B_BARCHAR ] := cBarCharacter
   ENDIF

   // OK, the defaults are set, now let's make sure it will fit on the
   // screen correctly
   IF aHandle[ B_RIGHT ] < aHandle[ B_LEFT ] + 4
      aHandle[ B_RIGHT ] := aHandle[ B_LEFT ] + 4
   ENDIF

   IF aHandle[ B_BOTTOM ] < aHandle[ B_TOP ] + 2
      aHandle[ B_BOTTOM ] := aHandle[ B_TOP ] + 2
   ENDIF

   // Determine if we can fit the bracketed number on top of the graph
   IF aHandle[ B_RIGHT ] < aHandle[ B_LEFT ] + 9
      aHandle[ B_DISPLAYNUM ] := .F.
   ENDIF

   RETURN( aHandle )



/***
*
*  GaugeDisplay( aGauge ) --> aGauge
*
*  Display a gauge array to the screen
*
*/
FUNCTION GaugeDisplay( aHandle )
   
   LOCAL nCenter   := ROUND( (aHandle[B_RIGHT] - aHandle[B_LEFT]) / 2, 0) + 1
   LOCAL cOldColor := SETCOLOR( aHandle[ B_BACKCOLOR ] )

   @ aHandle[ B_TOP ], aHandle[ B_LEFT ] CLEAR TO ;
     aHandle[ B_BOTTOM ], aHandle[ B_RIGHT ]

   @ aHandle[ B_TOP ], aHandle[ B_LEFT ], ;
     aHandle[ B_BOTTOM ], aHandle[ B_RIGHT ] BOX B_BOXLINES

   IF aHandle[ B_DISPLAYNUM ]
    IF .T. // !(TYPE(ntx) == "U" )
      @ aHandle[ B_TOP ], aHandle[ B_LEFT ]+3 SAY "[      ] "+ntx //DbOrderinfo( DBOI_FULLPATH,,INDEXORD() )
	ELSE
      @ aHandle[ B_TOP ], aHandle[ B_LEFT ]+3 SAY "[      ] "
	ENDI
   ENDIF

   SETCOLOR( cOldColor )

   // Draw bar to show current percent
   GaugeUpdate( aHandle, aHandle[ B_PERCENT ] )

   RETURN( aHandle )



/***
*
*  GaugeUpdate( aGauge, nPercent ) --> aGauge
*
*  Updates a gauge with a new progress value and redisplays the gauge 
*  to the screen to the screen
*
*/
FUNCTION GaugeUpdate( aHandle, nPercent )
   
   LOCAL nCenter   := ROUND( (aHandle[B_RIGHT] - aHandle[B_LEFT]) / 2, 0) + 1
   LOCAL cOldColor := SETCOLOR( aHandle[ B_BARCOLOR ] )
   LOCAL nBarRatio := (aHandle[ B_RIGHT ]) - (aHandle[ B_LEFT ] + 1)
   LOCAL nRow      := 0
   LOCAL nCols     := 0

   IF aHandle[ B_DISPLAYNUM ]
      @ aHandle[ B_TOP ], aHandle[ B_LEFT ]+5 SAY STR( nPercent * 100, 3 ) + "%"
   ENDIF

   IF nPercent > 1
      nPercent := 1
   ENDIF

   IF nPercent < 0
      nPercent := 0
   ENDIF

   nCols := ROUND( nPercent * nBarRatio, 0 )

   //@ aHandle[ B_TOP ] + 1, aHandle[ B_LEFT ] + 1 CLEAR TO ;
   //  aHandle[ B_BOTTOM ] - 1, aHandle[ B_RIGHT ] - 1

   FOR nRow := 1 TO (aHandle[ B_BOTTOM ] - aHandle[ B_TOP ] - 1)
      @ nRow + aHandle[ B_TOP ], aHandle[ B_LEFT ] + 1 SAY ;
        REPLICATE( aHandle[ B_BARCHAR ], nCols )
   NEXT

   SETCOLOR( cOldColor )

   RETURN( aHandle )



/*
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
 \ Empresa.: PresServ Inform tica - Limeira (019)452.6623
 \ Programa: ADR_ATR1.PRG
 \ Data....: 29-01-04
 \ Sistema.: Administradora - RECEP€„O
 \ Funcao..: Define atributos dos arquivos (sistema[])
 \ Analista: Ademilson Pedro Bom
 \ Criacao.: GAS-Pro v4.0o
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/

#include "adrbig.ch"    // inicializa constantes manifestas


sistema[009]={;
            "Lan‡amento Aux.Funeral",;                      // opcao do menu
            "Aux¡lio Funeral",;                             // titulo do sistema
	    {"processo+proc2+filial+categ","falecido+processo","ruafal"},;// chaves do arquivo
	    {"Processo","Nome Falecido","Data e Local Fal."},;// titulo dos indices para consulta
	    {"01020305","1201","20"},;                          // ordem campos chaves
            {"AFUNER",drvdbf,drvntx},;                      // nome do DBF
            {"AFUNER1","AFUNER2","AFUNER3"},;               // nomes dos NTX
            {},;                                            // nome dos dbf's relacionados
            {},;                                            // campos de relacionamento
            {1,1,3,1,22,78},;                               // num telas/tela atual/coordenadas
            {1,.t.,.f.},;                                   // nivel acesso/tp chave/pede dir
            {},;                                            // campos do arquivo
            {},;                                            // formula mostradas
            {"nivelop>1","Permitido apenas a usu rios cadastrados|com n¡vel de Manuten‡„o ou Maior"},;// condicao de exclusao de registros
            {"nivelop>1","Permitido apenas a usu rios cadastrados|com n¡vel de Manuten‡„o ou Maior"},;// condicao de alteracao de registros
            {"nivelop>1","Permitido apenas a usu rios cadastrados|com n¡vel de Manuten‡„o ou Maior"};// condicao de recupercao de registros
           }

AADD(sistema[009,O_CAMPO],{;            // AFUNER
     /* mascara       */    "99999",;
     /* titulo        */    "Processo",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(PROCESSO)~Este ‚ um campo obrigat¢rio!|Ele ‚ usado como chave principal|para localiza‡„o dos documentos.",;
     /* help do campo */    "Digite neste campo o n£mero de|identifica‡„o do processo";
                         };
)
AADD(sistema[009,O_CAMPO],{;            // AFUNER
     /* mascara       */    "99",;
     /* titulo        */    "Ano",;
     /* cmd especial  */    "",;
     /* default       */    "RIGHT(DTOC(DATE()),2)",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(proc2)~Necess rio informar ANO",;
     /* help do campo */    "Informe o ano correspondente ao processo.";
			 };
)
AADD(sistema[009,O_CAMPO],{;            // AFUNER
     /* mascara       */    "@!",;
     /* titulo        */    "Filial",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[009,O_CAMPO],{;            // AFUNER
     /* mascara       */    "@D",;
     /* titulo        */    "Data ocorrˆncia",;
     /* cmd especial  */    "",;
     /* default       */    "DATE()",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPTY(ocorr_)~DATA OCORRENCIA n„o pode estar vazia",;
     /* help do campo */    "Entre com a Data de Ocorrˆncia";
                         };
)
AADD(sistema[009,O_CAMPO],{;            // AFUNER
     /* mascara       */    "!!",;
     /* titulo        */    "Categoria",;
     /* cmd especial  */    "MTAB([PL=Plano|PD=Plano c/Diferen‡a|AF=Auxilio],[CATEGORIA])",;
     /* default       */    "[AF]",;
     /* pre-validacao */    "",;
     /* validacao     */    "categ $ [PL|PD|AF]~CATEGORIA n„o aceit vel",;
     /* help do campo */    "Preencha com:|PL para Plano,| PD p/Diferen‡a ou |AX para Aux.Funeral";
                         };
)
AADD(sistema[009,O_CAMPO],{;            // AFUNER
     /* mascara       */    "@!",;
     /* titulo        */    "Contrato",;
     /* cmd especial  */    "VDBF(6,3,20,77,'GRUPOS',{'codigo','grupo','nome','endereco'},1,'codigo',[])",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "PTAB(contrato,'GRUPOS',1).AND.CAD_04F9(op_menu).AND.(PTAB(contrato,'TAXAS',1).OR.PTAB(GRUPOS->grupo,'ARQGRUP',1).OR.1=1)~CONTRATO n„o existe em arquivo de tabela",;
     /* help do campo */    "Informe o n£mero do contrato";
                         };
)
AADD(sistema[009,O_CAMPO],{;            // AFUNER
     /* mascara       */    "",;
     /* titulo        */    "Parentesco",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    "Informe o grau de parentesco deste com o falecido.";
                         };
)
AADD(sistema[009,O_CAMPO],{;            // AFUNER
     /* mascara       */    "@!",;
     /* titulo        */    "Nome",;
     /* cmd especial  */    "",;
     /* default       */    "GRUPOS->nome",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(nomedec)~Necess rio informar NOME",;
     /* help do campo */    "Entre com o nome do declarante";
                         };
)
AADD(sistema[009,O_CAMPO],{;            // AFUNER
     /* mascara       */    "@!",;
     /* titulo        */    "Rua Declarante",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    "Entre com o endere‡o do respons vel";
                         };
)
AADD(sistema[009,O_CAMPO],{;            // AFUNER
     /* mascara       */    "@!",;
     /* titulo        */    "Fone",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    "Informe o n£mero do Telefone para contato|com o respons vel pela solicita‡„o do A.F.";
                         };
)
AADD(sistema[009,O_CAMPO],{;            // AFUNER
     /* mascara       */    "",;
     /* titulo        */    "Falecido",;
     /* cmd especial  */    "VDBF(6,3,20,77,'INSCRITS',{'codigo','nome','nascto_'},1,'kinscf9()',[])",;
     /* default       */    "ALLTRIM(contrato)",;
     /* pre-validacao */    "",;
     /* validacao     */    "PTAB(codigofal,'INSCRITS',1).OR.EMPT(codigofal)~Necess rio informar C¢digo do FALECIDO ou|Tecle F8 para consulta.",;
     /* help do campo */    "Entre com o c¢digo do falecido";
                         };
)
AADD(sistema[009,O_CAMPO],{;            // AFUNER
     /* mascara       */    "",;
     /* titulo        */    "Nome do falecido",;
     /* cmd especial  */    "",;
     /* default       */    "IIF(PTAB(codigofal,'INSCRITS',1),INSCRITS->nome,[])",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(falecido)~Necess rio informar NOME DO FALECIDO",;
     /* help do campo */    "Entre com o nome do falecido";
                         };
)
AADD(sistema[009,O_CAMPO],{;            // AFUNER
     /* mascara       */    "",;
     /* titulo        */    "Rua Residˆncia",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    "Entre com o endere‡o de residˆncia do Falecido";
                         };
)
AADD(sistema[009,O_CAMPO],{;            // AFUNER
     /* mascara       */    "",;
     /* titulo        */    "Bairro Residˆncia",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    "Entre com o bairro de residˆncia";
                         };
)
AADD(sistema[009,O_CAMPO],{;            // AFUNER
     /* mascara       */    "",;
     /* titulo        */    "Munic¡pio de residˆncia",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    "Entre com o nome do Munic¡pio de residˆncia";
                         };
)
AADD(sistema[009,O_CAMPO],{;            // AFUNER
     /* mascara       */    "!!",;
     /* titulo        */    "UF Residˆncia",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "EMPTY(ESTRES).OR.VUF(ESTRES)~ESTADO RESIDENCIA N„o aceit vel",;
     /* help do campo */    "Entre com o estado de Residˆncia";
                         };
)
AADD(sistema[009,O_CAMPO],{;            // AFUNER
     /* mascara       */    "@D",;
     /* titulo        */    "Nascimento",;
     /* cmd especial  */    "",;
     /* default       */    "IIF(PTAB(codigofal,'INSCRITS',1),INSCRITS->nascto_,CTOD([  /  /  ]))",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    "Informe a data de nascimento do falecido.";
                         };
)
AADD(sistema[009,O_CAMPO],{;            // AFUNER
     /* mascara       */    "@D",;
     /* titulo        */    "Data falcto.",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "falecto_<=DATE()~Informe uma data v lida para falecimento|Verifique a data do sistema.",;
     /* help do campo */    "Entre com a data de falecimento";
                         };
)
AADD(sistema[009,O_CAMPO],{;            // AFUNER
     /* mascara       */    "99:99",;
     /* titulo        */    "Hora Falcto.",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "!EMPTY(falecto_)",;
     /* validacao     */    "VHORA(horafal+':00')~HORA FALCTO. n„o aceit vel|Digite uma hora correta",;
     /* help do campo */    "";
                         };
)
AADD(sistema[009,O_CAMPO],{;            // AFUNER
     /* mascara       */    "",;
     /* titulo        */    "Rua Falecimento",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    "Entre com o endere‡o (Rua) onde|ocorreu o falecimento";
                         };
)
AADD(sistema[009,O_CAMPO],{;            // AFUNER
     /* mascara       */    "",;
     /* titulo        */    "Munic¡pio de falecimento",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    "Entre com o nome do munic¡pio";
                         };
)
AADD(sistema[009,O_CAMPO],{;            // AFUNER
     /* mascara       */    "!!",;
     /* titulo        */    "UF falecto",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "EMPTY(ESTFAL) .OR.VUF(ESTFAL)~ESTADO FALECIMENTO N„o aceit vel",;
     /* help do campo */    "Entre com o Estado onde ocorreu o falecimento";
			 };
)
AADD(sistema[009,O_CAMPO],{;            // AFUNER
     /* mascara       */    "@D",;
     /* titulo        */    "Data Sepultamento",;
     /* cmd especial  */    "",;
     /* default       */    "DATE()",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    "Informe a data do sepultamento";
                         };
)
AADD(sistema[009,O_CAMPO],{;            // AFUNER
     /* mascara       */    "99:99",;
     /* titulo        */    "Hora sepult.",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "VHORA(horasepult+':00')~HORA SEPULT. n„o aceit vel|digite uma hora correta",;
     /* help do campo */    "Informe a hora do sepultamento";
                         };
)
AADD(sistema[009,O_CAMPO],{;            // AFUNER
     /* mascara       */    "",;
     /* titulo        */    "Cemit‚rio Sepultamento",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    "Entre com o n£mero do cemit‚rio de sepultamento";
                         };
)
AADD(sistema[009,O_CAMPO],{;            // AFUNER
     /* mascara       */    "999",;
     /* titulo        */    "Func.Respons vel",;
     /* cmd especial  */    "VDBF(6,15,20,77,'FNCS',{'codigo','nome','profiss'},1,'codigo',[])",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "PTAB(funcresp,'FNCS',1).OR.EMPTY(funcresp)~Funcion rio n„o existe na tabela",;
     /* help do campo */    "Informe o funcion rio far |o registro ou F8 para consulta em tabela";
                         };
)
AADD(sistema[009,O_CAMPO],{;            // AFUNER
     /* mascara       */    "@D",;
     /* titulo        */    "Proc.pagto em",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    "Processar pagamento em...";
                         };
)
AADD(sistema[009,O_CAMPO],{;            // AFUNER
     /* mascara       */    "99999999999.99",;
     /* titulo        */    "Valor Auxilio",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    "Informe o valor do Auxilio Funeral";
                         };
)
AADD(sistema[009,O_CAMPO],{;            // AFUNER
     /* mascara       */    "@D",;
     /* titulo        */    "Pago em",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    "";
                         };
)
AADD(sistema[009,O_CAMPO],{;            // AFUNER
     /* mascara       */    "99999999",;
     /* titulo        */    "Num.Lan‡amento",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[009,O_FORMULA],{;          // AFUNER - Contratante
     /* form mostrar  */    "LEFT(TRAN(IIF(PTAB(contrato,'GRUPOS',1),GRUPOS->nome,[]),[]),30)",;
     /* lin da formula*/    3,;
     /* col da formula*/    28;
                         };
)
AADD(sistema[009,O_FORMULA],{;          // AFUNER - Endere‡o Contr.
     /* form mostrar  */    "LEFT(TRAN(IIF(PTAB(contrato,'GRUPOS',1),GRUPOS->endereco,[]),[]),35)",;
     /* lin da formula*/    4,;
     /* col da formula*/    28;
                         };
)
AADD(sistema[009,O_FORMULA],{;          // AFUNER - Func.Resp.
     /* form mostrar  */    "LEFT(TRAN(IIF(PTAB(funcresp,[FNCS]),FNCS->nome,[ ]),[]),30)",;
     /* lin da formula*/    16,;
     /* col da formula*/    32;
                         };
)
AADD(sistema[009,O_FORMULA],{;          // AFUNER - Categoria
     /* form mostrar  */    "LEFT(TRAN(IIF(categ=[PD],[Plano c/Difer. ],IIF(categ=[PL],[Atend.Plano],[Auxilio Funeral  ])),[]),18)",;
     /* lin da formula*/    1,;
     /* col da formula*/    56;
                         };
)
AADD(sistema[009,O_FORMULA],{;          // AFUNER - Filial
     /* form mostrar  */    "LEFT(TRAN(IIF(EMPT(filial),M->p_filial,filial),[@!]),02)",;
     /* lin da formula*/    1,;
     /* col da formula*/    23;
                         };
)
AADD(sistema[009,O_FORMULA],{;          // AFUNER - Seguro?
     /* form mostrar  */    "LEFT(filial,02)",;
     /* lin da formula*/    1,;
     /* col da formula*/    23;
                         };
)


sistema[010]={;
            "Documento … Imprimir",;                        // opcao do menu
            "Documento … Imprimir",;                        // titulo do sistema
            {"idmaq+base","codlan"},;                       // chaves do arquivo
            {"Esta‡„o","Cod.Lanc"},;                        // titulo dos indices para consulta
            {"0102","04"},;                                 // ordem campos chaves
            {"IMPPAR",drvdbf,drvntx},;                      // nome do DBF
            {"IMPPAR1","IMPPAR2"},;                         // nomes dos NTX
            {},;                                            // nome dos dbf's relacionados
            {},;                                            // campos de relacionamento
            {1,1,8,8,19,72,3,8},;                           // num telas/tela atual/coordenadas/inicio scroll/qtde scroll
            {1,.t.,.f.},;                                   // nivel acesso/tp chave/pede dir
            {},;                                            // campos do arquivo
	    {},;                                            // formula mostradas
            {"",""},;                                       // condicao de exclusao de registros
            {"",""},;                                       // condicao de alteracao de registros
            {"",""};                                        // condicao de recupercao de registros
           }

AADD(sistema[010,O_CAMPO],{;            // IMPPAR
     /* mascara       */    "@!",;
     /* titulo        */    "Esta‡„o",;
     /* cmd especial  */    "M->ide_maq",;
     /* default       */    "PADR(SUBSTR(M->ide_maq,2),4)",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(idmaq)~Necess rio informar Esta‡„o|Tecle F8",;
     /* help do campo */    "Informe o nome da esta‡„o|tecle F8 para preencher autom tico";
                         };
)
AADD(sistema[010,O_CAMPO],{;            // IMPPAR
     /* mascara       */    "@!",;
     /* titulo        */    "Base",;
     /* cmd especial  */    "MTAB([AFU-Aux.funeral|BXR-Baixa Recep‡„o|OBX-Outros Receb.],[BASE])",;
     /* default       */    "[BXR]",;
     /* pre-validacao */    "",;
     /* validacao     */    "base $ [AFU|BXR|OBX]~BASE n„o aceit vel,tecle F8",;
     /* help do campo */    "Informe a Base de Dados|tecle F8 para busca em tabela";
                         };
)
AADD(sistema[010,O_CAMPO],{;            // IMPPAR
     /* mascara       */    "",;
     /* titulo        */    "Documento",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    "Digite neste campo o n£mero de|identifica‡„o do documento|(N„o utilize barras nem tra‡os)";
                         };
)
AADD(sistema[010,O_CAMPO],{;            // IMPPAR
     /* mascara       */    "!!!-99999999-999-999",;
     /* titulo        */    "Cod.Lan‡amento",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[010,O_FORMULA],{;          // IMPPAR - processo falec.
     /* form mostrar  */    "LEFT(TRAN(IMP_01F9(),[]),35)",;
     /* lin da formula*/    {||l_a},;
     /* col da formula*/    28;
                         };
)


sistema[011]={;
            "Credenciados",;                                // opcao do menu
            "Cadastro de Credenciados",;                    // titulo do sistema
	    {"codbenefic","nome","oldespec+cidade+nome"},;               // chaves do arquivo
	    {"Codigo","M‚dico","Especialidade"},;            // titulo dos indices para consulta
	    {"02","12","071512"},;                            // ordem campos chaves
	    {"MEDICOS",drvdbf,drvntx},;                     // nome do DBF
	    {"MEDICOS1","MEDICOS2","MEDICOS3"},;            // nomes dos NTX
            {},;                                            // nome dos dbf's relacionados
            {},;                                            // campos de relacionamento
            {1,1,0,8,24,73},;                               // num telas/tela atual/coordenadas
            {1,.t.,.f.},;                                   // nivel acesso/tp chave/pede dir
            {},;                                            // campos do arquivo
            {},;                                            // formula mostradas
            {"",""},;                                       // condicao de exclusao de registros
            {"",""},;                                       // condicao de alteracao de registros
            {"",""};                                        // condicao de recupercao de registros
           }

AADD(sistema[011,O_CAMPO],{;            // MEDICOS
     /* mascara       */    "",;
     /* titulo        */    "Ai",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(ai)~Necess rio informar AI",;
     /* help do campo */    "";
                         };
)
AADD(sistema[011,O_CAMPO],{;            // MEDICOS
     /* mascara       */    "",;
     /* titulo        */    "Codbenefic",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(codbenefic)~Necess rio informar CODBENEFIC",;
     /* help do campo */    "";
                         };
)
AADD(sistema[011,O_CAMPO],{;            // MEDICOS
     /* mascara       */    "",;
     /* titulo        */    "Oldescrito",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(oldescrito)~Necess rio informar OLDESCRITO",;
     /* help do campo */    "";
                         };
)
AADD(sistema[011,O_CAMPO],{;            // MEDICOS
     /* mascara       */    "",;
     /* titulo        */    "Oldclasse",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(oldclasse)~Necess rio informar OLDCLASSE",;
     /* help do campo */    "";
			 };
)
AADD(sistema[011,O_CAMPO],{;            // MEDICOS
     /* mascara       */    "",;
     /* titulo        */    "Prioridade",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(prioridade)~Necess rio informar PRIORIDADE",;
     /* help do campo */    "";
                         };
)
AADD(sistema[011,O_CAMPO],{;            // MEDICOS
     /* mascara       */    "!!",;
     /* titulo        */    "Situa‡„o",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(status)~Necess rio informar SITUA€ŽO",;
     /* help do campo */    "";
                         };
)
AADD(sistema[011,O_CAMPO],{;            // MEDICOS
     /* mascara       */    "@!",;
     /* titulo        */    "Oldespec",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(oldespec)~Necess rio informar OLDESPEC",;
     /* help do campo */    "";
                         };
)
AADD(sistema[011,O_CAMPO],{;            // MEDICOS
     /* mascara       */    "@S35",;
     /* titulo        */    "Detalhes",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(detalhes)~Necess rio informar DETALHES",;
     /* help do campo */    "";
                         };
)
AADD(sistema[011,O_CAMPO],{;            // MEDICOS
     /* mascara       */    "@S35",;
     /* titulo        */    "Vantagens",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(vantagens)~Necess rio informar VANTAGENS",;
     /* help do campo */    "";
                         };
)
AADD(sistema[011,O_CAMPO],{;            // MEDICOS
     /* mascara       */    "@S35",;
     /* titulo        */    "Condicoes",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(condicoes)~Necess rio informar CONDICOES",;
     /* help do campo */    "";
                         };
)
AADD(sistema[011,O_CAMPO],{;            // MEDICOS
     /* mascara       */    "@S35",;
     /* titulo        */    "Informutil",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(informutil)~Necess rio informar INFORMUTIL",;
     /* help do campo */    "";
                         };
)
AADD(sistema[011,O_CAMPO],{;            // MEDICOS
     /* mascara       */    "",;
     /* titulo        */    "Nome",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(nome)~Necess rio informar NOME",;
     /* help do campo */    "Informe o nome do M‚dico";
                         };
)
AADD(sistema[011,O_CAMPO],{;            // MEDICOS
     /* mascara       */    "",;
     /* titulo        */    "Endere‡o",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    "";
                         };
)
AADD(sistema[011,O_CAMPO],{;            // MEDICOS
     /* mascara       */    "@!",;
     /* titulo        */    "Bairro",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(bairro)~Necess rio informar BAIRRO",;
     /* help do campo */    "";
                         };
)
AADD(sistema[011,O_CAMPO],{;            // MEDICOS
     /* mascara       */    "@!",;
     /* titulo        */    "Cidade",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    "";
                         };
)
AADD(sistema[011,O_CAMPO],{;            // MEDICOS
     /* mascara       */    "!!",;
     /* titulo        */    "UF",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "VUF(uf)~UNIDADE DA FEDERA€ŽO inv lida",;
     /* help do campo */    "";
                         };
)
AADD(sistema[011,O_CAMPO],{;            // MEDICOS
     /* mascara       */    "@R 99999-999",;
     /* titulo        */    "CEP",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(cep)~Necess rio informar CEP",;
     /* help do campo */    "";
                         };
)
AADD(sistema[011,O_CAMPO],{;            // MEDICOS
     /* mascara       */    "@!",;
     /* titulo        */    "Contato",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(contato)~Necess rio informar CONTATO",;
     /* help do campo */    "";
                         };
)
AADD(sistema[011,O_CAMPO],{;            // MEDICOS
     /* mascara       */    "",;
     /* titulo        */    "Telefone",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(fonecom1)~Necess rio informar TELEFONE",;
     /* help do campo */    "";
                         };
)
AADD(sistema[011,O_CAMPO],{;            // MEDICOS
     /* mascara       */    "@!",;
     /* titulo        */    "Fonecom2",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(fonecom2)~Necess rio informar FONECOM2",;
     /* help do campo */    "";
                         };
)
AADD(sistema[011,O_CAMPO],{;            // MEDICOS
     /* mascara       */    "@!",;
     /* titulo        */    "Fonecel",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(fonecel)~Necess rio informar FONECEL",;
     /* help do campo */    "";
                         };
)
AADD(sistema[011,O_CAMPO],{;            // MEDICOS
     /* mascara       */    "@!",;
     /* titulo        */    "Foneres1",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(foneres1)~Necess rio informar FONERES1",;
     /* help do campo */    "";
                         };
)
AADD(sistema[011,O_CAMPO],{;            // MEDICOS
     /* mascara       */    "@!",;
     /* titulo        */    "Email",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(email)~Necess rio informar EMAIL",;
     /* help do campo */    "";
                         };
)
AADD(sistema[011,O_CAMPO],{;            // MEDICOS
     /* mascara       */    "@!",;
     /* titulo        */    "Fax",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(fax)~Necess rio informar FAX",;
     /* help do campo */    "";
                         };
)
AADD(sistema[011,O_CAMPO],{;            // MEDICOS
     /* mascara       */    "@!",;
     /* titulo        */    "Bip",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(bip)~Necess rio informar BIP",;
     /* help do campo */    "";
                         };
)
AADD(sistema[011,O_CAMPO],{;            // MEDICOS
     /* mascara       */    "@!",;
     /* titulo        */    "Fonesdiv",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(fonesdiv)~Necess rio informar FONESDIV",;
     /* help do campo */    "";
                         };
)
AADD(sistema[011,O_CAMPO],{;            // MEDICOS
     /* mascara       */    "@D",;
     /* titulo        */    "Datainc",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(datainc)~Necess rio informar DATAINC",;
     /* help do campo */    "";
                         };
)
AADD(sistema[011,O_CAMPO],{;            // MEDICOS
     /* mascara       */    "@D",;
     /* titulo        */    "Dataalt",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(dataalt)~Necess rio informar DATAALT",;
     /* help do campo */    "";
                         };
)
AADD(sistema[011,O_CAMPO],{;            // MEDICOS
     /* mascara       */    "",;
     /* titulo        */    "Codcidade",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(codcidade)~Necess rio informar CODCIDADE",;
     /* help do campo */    "";
                         };
)
AADD(sistema[011,O_CAMPO],{;            // MEDICOS
     /* mascara       */    "",;
     /* titulo        */    "Contrato",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(contrato)~Necess rio informar CONTRATO",;
     /* help do campo */    "";
                         };
)
AADD(sistema[011,O_CAMPO],{;            // MEDICOS
     /* mascara       */    "",;
     /* titulo        */    "Flagetq",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(flagetq)~Necess rio informar FLAGETQ",;
     /* help do campo */    "";
                         };
)
AADD(sistema[011,O_CAMPO],{;            // MEDICOS
     /* mascara       */    "",;
     /* titulo        */    "Codclasse",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(codclasse)~Necess rio informar CODCLASSE",;
     /* help do campo */    "";
                         };
)
AADD(sistema[011,O_CAMPO],{;            // MEDICOS
     /* mascara       */    "99999999",;
     /* titulo        */    "Num.Lan‡amento",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[011,O_FORMULA],{;          // MEDICOS - porc.desconto
     /* form mostrar  */    "LEFT(TRAN(STR(ultvalor/valorpart*100,6,2),[]),06)",;
     /* lin da formula*/    0,;
     /* col da formula*/    0;
                         };
)


sistema[012]={;
            "Especialidades",;                              // opcao do menu
            "Especialidades",;                              // titulo do sistema
            {"especialid","codlan"},;                       // chaves do arquivo
            {"Por Especialidade","Cod.Lanc"},;              // titulo dos indices para consulta
            {"01","02"},;                                   // ordem campos chaves
            {"TESPEC",drvdbf,drvntx},;                      // nome do DBF
            {"TESPEC1","TESPEC2"},;                         // nomes dos NTX
            {},;                                            // nome dos dbf's relacionados
            {},;                                            // campos de relacionamento
            {1,1,8,20,21,61,3,10},;                         // num telas/tela atual/coordenadas/inicio scroll/qtde scroll
            {1,.t.,.f.},;                                   // nivel acesso/tp chave/pede dir
            {},;                                            // campos do arquivo
            {},;                                            // formula mostradas
            {"",""},;                                       // condicao de exclusao de registros
            {"",""},;                                       // condicao de alteracao de registros
            {"",""};                                        // condicao de recupercao de registros
           }

AADD(sistema[012,O_CAMPO],{;            // TESPEC
     /* mascara       */    "@!",;
     /* titulo        */    "Especialidade",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(especialid)~Necess rio informar ESPECIALIDADE",;
     /* help do campo */    "Informe a|Especialidade/Categoria Profissional.";
                         };
)
AADD(sistema[012,O_CAMPO],{;            // TESPEC
     /* mascara       */    "!!!-99999999-999-999",;
     /* titulo        */    "Cod.Lan‡amento",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)


sistema[013]={;
            "Parƒmetro de Juros",;                          // opcao do menu
            "Parƒmetro de Juros",;                          // titulo do sistema
            {"tipo"},;                                      // chaves do arquivo
            {"Tipo"},;                                      // titulo dos indices para consulta
            {"01"},;                                        // ordem campos chaves
            {"JUROS",drvdbf,drvntx},;                       // nome do DBF
            {"JUROS1"},;                                    // nomes dos NTX
            {},;                                            // nome dos dbf's relacionados
            {},;                                            // campos de relacionamento
            {1,1,8,17,17,66,4,5},;                          // num telas/tela atual/coordenadas/inicio scroll/qtde scroll
            {3,.t.,.f.},;                                   // nivel acesso/tp chave/pede dir
            {},;                                            // campos do arquivo
            {},;                                            // formula mostradas
            {"",""},;                                       // condicao de exclusao de registros
            {"",""},;                                       // condicao de alteracao de registros
            {"",""};                                        // condicao de recupercao de registros
           }

AADD(sistema[013,O_CAMPO],{;            // JUROS
     /* mascara       */    "9",;
     /* titulo        */    "Tipo",;
     /* cmd especial  */    "MTAB([1=J¢ia |2=Taxa |3=Carnˆ|4=Acerto],[TIPO])",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(tipo)~TIPO n„o aceit vel|Deve ser n£mero positivo",;
     /* help do campo */    "Qual o tipo de lan‡amento";
                         };
)
AADD(sistema[013,O_CAMPO],{;            // JUROS
     /* mascara       */    "99.99",;
     /* titulo        */    "Multa %",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "multa>=0~MULTA % n„o aceit vel",;
     /* help do campo */    "Informe a porcentagem de multa";
                         };
)
AADD(sistema[013,O_CAMPO],{;            // JUROS
     /* mascara       */    "999",;
     /* titulo        */    "Carˆncia",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "mltcaren>=0~CARENCIA n„o aceit vel",;
     /* help do campo */    "Informe a carˆncia para a |aplica‡„o da multa|em dias.";
                         };
)
AADD(sistema[013,O_CAMPO],{;            // JUROS
     /* mascara       */    "9.999",;
     /* titulo        */    "Juros %",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "juros>=0~JUROS % n„o aceit vel|deve ser maior ou igual a zeros|(Juros Di rios)",;
     /* help do campo */    "Informe a porcentagem do Juros di rios";
                         };
)
AADD(sistema[013,O_CAMPO],{;            // JUROS
     /* mascara       */    "999",;
     /* titulo        */    "Carˆncia",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "jrscaren>=0~CARENCIA n„o aceit vel|deve ser maior ou igual a zeros",;
     /* help do campo */    "Informe a carˆncia para a |aplica‡„o do juros|em dias.";
                         };
)


sistema[014]={;
            "Filiais",;                                     // opcao do menu
            "Filiais",;                                     // titulo do sistema
            {"codigo"},;                                    // chaves do arquivo
            {"C¢digo"},;                                    // titulo dos indices para consulta
            {"01"},;                                        // ordem campos chaves
            {"TFILIAIS",drvdbf,drvntx},;                    // nome do DBF
            {"TFILIAI1"},;                                  // nomes dos NTX
            {},;                                            // nome dos dbf's relacionados
            {},;                                            // campos de relacionamento
            {1,1,8,8,16,74},;                               // num telas/tela atual/coordenadas
            {1,.t.,.f.},;                                   // nivel acesso/tp chave/pede dir
            {},;                                            // campos do arquivo
            {},;                                            // formula mostradas
            {"nivelop>1","Permitido apenas a usu rios cadastrados|com n¡vel de Manuten‡„o ou Maior"},;// condicao de exclusao de registros
            {"nivelop>1","Permitido apenas a usu rios cadastrados|com n¡vel de Manuten‡„o ou Maior"},;// condicao de alteracao de registros
            {"nivelop>1","Permitido apenas a usu rios cadastrados|com n¡vel de Manuten‡„o ou Maior"};// condicao de recupercao de registros
           }

AADD(sistema[014,O_CAMPO],{;            // TFILIAIS
     /* mascara       */    "@!",;
     /* titulo        */    "C¢digo",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(codigo)~Necess rio informar C¢DIGO",;
     /* help do campo */    "Informe o c¢digo da filial";
                         };
)
AADD(sistema[014,O_CAMPO],{;            // TFILIAIS
     /* mascara       */    "",;
     /* titulo        */    "Abreviatura",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(abrev)~Necess rio informar ABREVIATURA",;
     /* help do campo */    "Dˆ um nome abreviado para a filial|Ser  utilizada para identifica‡Æo nas telas";
                         };
)
AADD(sistema[014,O_CAMPO],{;            // TFILIAIS
     /* mascara       */    "@!",;
     /* titulo        */    "Nome",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(nome)~Necess rio informar NOME",;
     /* help do campo */    "Entre com o nome da filial";
                         };
)
AADD(sistema[014,O_CAMPO],{;            // TFILIAIS
     /* mascara       */    "@!",;
     /* titulo        */    "Endereco",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    "";
                         };
)
AADD(sistema[014,O_CAMPO],{;            // TFILIAIS
     /* mascara       */    "@!",;
     /* titulo        */    "Cidade",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    "";
                         };
)
AADD(sistema[014,O_CAMPO],{;            // TFILIAIS
     /* mascara       */    "@S35",;
     /* titulo        */    "Ref",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    "";
                         };
)
AADD(sistema[014,O_CAMPO],{;            // TFILIAIS
     /* mascara       */    "@!",;
     /* titulo        */    "Contato",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(contato)~Necess rio informar CONTATO",;
     /* help do campo */    "";
                         };
)


sistema[015]={;
            "Grupos",;                                      // opcao do menu
            "Grupos",;                                      // titulo do sistema
            {"grup"},;                                      // chaves do arquivo
            {"Grupo"},;                                     // titulo dos indices para consulta
            {"01"},;                                        // ordem campos chaves
            {"ARQGRUP",drvdbf,drvntx},;                     // nome do DBF
            {"ARQGRUP1"},;                                  // nomes dos NTX
            {},;                                            // nome dos dbf's relacionados
            {},;                                            // campos de relacionamento
            {1,1,4,15,22,62},;                              // num telas/tela atual/coordenadas
            {1,.t.,.f.},;                                   // nivel acesso/tp chave/pede dir
            {},;                                            // campos do arquivo
            {},;                                            // formula mostradas
            {"",""},;                                       // condicao de exclusao de registros
            {"",""},;                                       // condicao de alteracao de registros
            {"",""};                                        // condicao de recupercao de registros
           }

AADD(sistema[015,O_CAMPO],{;            // ARQGRUP
     /* mascara       */    "!!",;
     /* titulo        */    "Grupo",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(grup)~Necess rio informar GRUPO",;
     /* help do campo */    "Entre com o c¢digo do Grupo";
                         };
)
AADD(sistema[015,O_CAMPO],{;            // ARQGRUP
     /* mascara       */    "99",;
     /* titulo        */    "Classe",;
     /* cmd especial  */    "VDBF(6,38,20,77,'CLASSES',{'classcod','descricao','contrat'},1,'classcod',[])",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "PTAB(classe,'CLASSES',1)~CLASSE n„o existe na tabela",;
     /* help do campo */    "Informe a categoria dos planos deste grupo.|Para grupo VIP, digite 00";
                         };
)
AADD(sistema[015,O_CAMPO],{;            // ARQGRUP
     /* mascara       */    "999999",;
     /* titulo        */    "Nr.Inicial",;
     /* cmd especial  */    "",;
     /* default       */    "IF(classe=[00],[000001],STRZERO(VAL(M->lastcodigo)+1,6))",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    "";
                         };
)
AADD(sistema[015,O_CAMPO],{;            // ARQGRUP
     /* mascara       */    "999999",;
     /* titulo        */    "Nr.Final",;
     /* cmd especial  */    "",;
     /* default       */    "IIF(classe=[00],[999999],STRZERO(VAL(inicio)+CLASSES->contrat-1,6))",;
     /* pre-validacao */    "",;
     /* validacao     */    "VAL(final)>VAL(inicio)~NR.FINAL n„o aceit vel",;
     /* help do campo */    "";
                         };
)
AADD(sistema[015,O_CAMPO],{;            // ARQGRUP
     /* mascara       */    "99",;
     /* titulo        */    "N§.Processos",;
     /* cmd especial  */    "",;
     /* default       */    "INT((1+VAL(final)-VAL(inicio))/50)",;
     /* pre-validacao */    "!(CLASSES->prior=[S])",;
     /* validacao     */    "!(acumproc<0)~N§.PROCESSOS n„o aceit vel",;
     /* help do campo */    "Informe quantos processos s„o nescess rios|para se emitir recibos.";
                         };
)
AADD(sistema[015,O_CAMPO],{;            // ARQGRUP
     /* mascara       */    "99",;
     /* titulo        */    "N§.Processos",;
     /* cmd especial  */    "",;
     /* default       */    "acumproc",;
     /* pre-validacao */    "!(CLASSES->prior=[S])",;
     /* validacao     */    "maxproc>=acumproc~N§.PROCESSOS n„o aceit vel|Informe o n£mero m ximo de processos |a se incluir na circular",;
     /* help do campo */    "Informe o n£mero m ximo de processos|para se emitir na cobran‡a.";
                         };
)
AADD(sistema[015,O_CAMPO],{;            // ARQGRUP
     /* mascara       */    "!",;
     /* titulo        */    "Comp.AdmissXAtend.",;
     /* cmd especial  */    "",;
     /* default       */    "[S]",;
     /* pre-validacao */    "acumproc<maxproc",;
     /* validacao     */    "cpadmiss$[SN]~Digite S ou N|S, n„o ser„o incluidos atendimentos|efetuados antes da admiss„o do contrato.",;
     /* help do campo */    "Se digitar S, n„o ser„o incluidos atendimentos|efetuados antes da admiss„o do contrato|quando da 1¦Cobran‡a.";
                         };
)
AADD(sistema[015,O_CAMPO],{;            // ARQGRUP
     /* mascara       */    "999",;
     /* titulo        */    "Periodicidade",;
     /* cmd especial  */    "",;
     /* default       */    "IIF(CLASSES->prior=[S],30,INT((VAL(final)-VAL(inicio)+1)*90/500))",;
     /* pre-validacao */    "",;
     /* validacao     */    "!(periodic<0)~PERIODICIDADE n„o aceit vel",;
     /* help do campo */    "Informe o intervalo m¡nimo em dias entre circulares.";
                         };
)
AADD(sistema[015,O_CAMPO],{;            // ARQGRUP
     /* mascara       */    "999",;
     /* titulo        */    "Remido",;
     /* cmd especial  */    "",;
     /* default       */    "acumproc*5",;
     /* pre-validacao */    "",;
     /* validacao     */    "!(qtdremir<0)~REMIDO n„o aceit vel",;
     /* help do campo */    "Entre com o n§ de taxas nescess rias para que|o processo fique remido.";
                         };
)
AADD(sistema[015,O_CAMPO],{;            // ARQGRUP
     /* mascara       */    "!",;
     /* titulo        */    "P/Atend.",;
     /* cmd especial  */    "",;
     /* default       */    "[S]",;
     /* pre-validacao */    "",;
     /* validacao     */    "poratend$[SN]~Digite|S para deixar de ser remido na utiliza‡„o|ou|N para continuar remido.",;
     /* help do campo */    "Digite S para considerar uma quantidade|a ser paga por atendimento efetuado|ou N para considerar quantidade total.";
                         };
)
AADD(sistema[015,O_CAMPO],{;            // ARQGRUP
     /* mascara       */    "999",;
     /* titulo        */    "Ultcirc",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[015,O_CAMPO],{;            // ARQGRUP
     /* mascara       */    "@D",;
     /* titulo        */    "Emissao",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[015,O_CAMPO],{;            // ARQGRUP
     /* mascara       */    "999",;
     /* titulo        */    "Processos",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[015,O_CAMPO],{;            // ARQGRUP
     /* mascara       */    "999999",;
     /* titulo        */    "Contratos",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[015,O_CAMPO],{;            // ARQGRUP
     /* mascara       */    "999999",;
     /* titulo        */    "Partic.",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[015,O_CAMPO],{;            // ARQGRUP
     /* mascara       */    "999",;
     /* titulo        */    "N§Proxima Circ.",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "nivelop=3",;
     /* validacao     */    "proxcirc>=ultcirc.OR.proxcirc=[000]~A Pr¢xima circular deve ser maior|ou igual a| £ltima emitida ou zeros p/ n„o emitir.",;
     /* help do campo */    "Entre com o n£mero da pr¢xima circular ou|zeros se n„o for emitir.";
                         };
)
AADD(sistema[015,O_FORMULA],{;          // ARQGRUP - Classe/Categor.
     /* form mostrar  */    "LEFT(TRAN(CLASSES->descricao,[]),25)",;
     /* lin da formula*/    2,;
     /* col da formula*/    17;
                         };
)
AADD(sistema[015,O_FORMULA],{;          // ARQGRUP - Ultcirc
     /* form mostrar  */    "LEFT(TRAN(ultcirc,[999]),03)",;
     /* lin da formula*/    13,;
     /* col da formula*/    19;
                         };
)
AADD(sistema[015,O_FORMULA],{;          // ARQGRUP - Emissao
     /* form mostrar  */    "LEFT(TRAN(emissao_,[@D]),08)",;
     /* lin da formula*/    13,;
     /* col da formula*/    33;
                         };
)
AADD(sistema[015,O_FORMULA],{;          // ARQGRUP - Processos
     /* form mostrar  */    "LEFT(TRAN(procpend,[999]),03)",;
     /* lin da formula*/    15,;
     /* col da formula*/    10;
                         };
)
AADD(sistema[015,O_FORMULA],{;          // ARQGRUP - Contratos
     /* form mostrar  */    "LEFT(TRAN(contrat,[999999]),06)",;
     /* lin da formula*/    14,;
     /* col da formula*/    2;
                         };
)
AADD(sistema[015,O_FORMULA],{;          // ARQGRUP - Partic.
     /* form mostrar  */    "LEFT(TRAN(partic,[999999]),06)",;
     /* lin da formula*/    14,;
     /* col da formula*/    27;
                         };
)


sistema[016]={;
            "Regi”es",;                                     // opcao do menu
            "Regi”es",;                                     // titulo do sistema
            {"codigo","regiao"},;                           // chaves do arquivo
            {"p/C¢digo","Nome"},;                           // titulo dos indices para consulta
            {"01","02"},;                                   // ordem campos chaves
            {"REGIAO",drvdbf,drvntx},;                      // nome do DBF
            {"REGIAO1","REGIAO2"},;                         // nomes dos NTX
            {},;                                            // nome dos dbf's relacionados
            {},;                                            // campos de relacionamento
            {1,1,8,14,15,67,3,4},;                          // num telas/tela atual/coordenadas/inicio scroll/qtde scroll
            {1,.t.,.f.},;                                   // nivel acesso/tp chave/pede dir
            {},;                                            // campos do arquivo
            {},;                                            // formula mostradas
            {"nivelop>1","Permitido apenas a usu rios cadastrados|com n¡vel de Manuten‡„o ou Maior"},;// condicao de exclusao de registros
            {"nivelop>1","Permitido apenas a usu rios cadastrados|com n¡vel de Manuten‡„o ou Maior"},;// condicao de alteracao de registros
            {"nivelop>1","Permitido apenas a usu rios cadastrados|com n¡vel de Manuten‡„o ou Maior"};// condicao de recupercao de registros
           }

AADD(sistema[016,O_CAMPO],{;            // REGIAO
     /* mascara       */    "999",;
     /* titulo        */    "C¢digo",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "V",;
     /* help do campo */    "";
                         };
)
AADD(sistema[016,O_CAMPO],{;            // REGIAO
     /* mascara       */    "",;
     /* titulo        */    "Descri‡„o",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(regiao)~Necess rio informar a REGIAO",;
     /* help do campo */    "Informe o nome do bairro, distrito ou regi„o";
                         };
)
AADD(sistema[016,O_CAMPO],{;            // REGIAO
     /* mascara       */    "!!!",;
     /* titulo        */    "Cobrador",;
     /* cmd especial  */    "VDBF(6,11,20,77,'COBRADOR',{'cobrador','nome','cidade'},1,'cobrador')",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "PTAB(cobrador,'COBRADOR',1).OR.EMPT(cobrador)~Necess rio informar COBRADOR",;
     /* help do campo */    "Informe o c¢digo do cobrador.|F8 consulta em tabela.";
                         };
)


sistema[017]={;
            "Cobradores/Vendedores",;                       // opcao do menu
            "Cobradores/Vendedores",;                       // titulo do sistema
            {"cobrador"},;                                  // chaves do arquivo
            {"C¢digo"},;                                    // titulo dos indices para consulta
            {"01"},;                                        // ordem campos chaves
            {"COBRADOR",drvdbf,drvntx},;                    // nome do DBF
            {"COBRADO1"},;                                  // nomes dos NTX
            {},;                                            // nome dos dbf's relacionados
            {},;                                            // campos de relacionamento
            {1,1,6,15,16,66},;                              // num telas/tela atual/coordenadas
            {1,.t.,.f.},;                                   // nivel acesso/tp chave/pede dir
            {},;                                            // campos do arquivo
            {},;                                            // formula mostradas
            {"",""},;                                       // condicao de exclusao de registros
            {"",""},;                                       // condicao de alteracao de registros
            {"",""};                                        // condicao de recupercao de registros
           }

AADD(sistema[017,O_CAMPO],{;            // COBRADOR
     /* mascara       */    "!!!",;
     /* titulo        */    "Cobrador",;
     /* cmd especial  */    "COB_01F9()",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(cobrador)~Necess rio informar COBRADOR",;
     /* help do campo */    "Informe um c¢digo para o cobrador.";
                         };
)
AADD(sistema[017,O_CAMPO],{;            // COBRADOR
     /* mascara       */    "!",;
     /* titulo        */    "Fun‡„o",;
     /* cmd especial  */    "MTAB([Cobrador|Vendedor|Supervisor],[FUN€ŽO])",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "funcao $ [CVS]~FUN€ŽO n„o aceit vel",;
     /* help do campo */    "Informe se ‚ um Cobrador ou Vendedor|";
                         };
)
AADD(sistema[017,O_CAMPO],{;            // COBRADOR
     /* mascara       */    "",;
     /* titulo        */    "Nome do Cobrador",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(nome)~Necess rio informar NOME DO COBRADOR",;
     /* help do campo */    "";
                         };
)
AADD(sistema[017,O_CAMPO],{;            // COBRADOR
     /* mascara       */    "",;
     /* titulo        */    "Endere‡o",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    "";
                         };
)
AADD(sistema[017,O_CAMPO],{;            // COBRADOR
     /* mascara       */    "",;
     /* titulo        */    "Bairro",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    "";
                         };
)
AADD(sistema[017,O_CAMPO],{;            // COBRADOR
     /* mascara       */    "",;
     /* titulo        */    "Cidade",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    "";
                         };
)
AADD(sistema[017,O_CAMPO],{;            // COBRADOR
     /* mascara       */    "",;
     /* titulo        */    "Telefone",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    "";
                         };
)
AADD(sistema[017,O_CAMPO],{;            // COBRADOR
     /* mascara       */    "@R 999.999.999-99",;
     /* titulo        */    "CPF",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "VDV2(cpf).OR.EMPT(cpf)~CPF n„o aceit vel",;
     /* help do campo */    "";
                         };
)
AADD(sistema[017,O_CAMPO],{;            // COBRADOR
     /* mascara       */    "@S35",;
     /* titulo        */    "Observa‡Æo",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    "";
                         };
)
AADD(sistema[017,O_CAMPO],{;            // COBRADOR
     /* mascara       */    "999.9",;
     /* titulo        */    "Percentual",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "!(percent<0).AND.!(percent>100)~PERCENTUAL n„o aceit vel",;
     /* help do campo */    "Informe o percentual de comiss„o";
                         };
)
AADD(sistema[017,O_CAMPO],{;            // COBRADOR
     /* mascara       */    "!!!",;
     /* titulo        */    "Supervisor",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    "Digite o c¢digo do SUPERVISOR deste cobrador";
                         };
)
AADD(sistema[017,O_FORMULA],{;          // COBRADOR - Fun‡„o
     /* form mostrar  */    "LEFT(TRAN(SUBSTR([Cobrador  |Vendedor  |Supervisor],AT(funcao,[Cobrador  |Vendedor  |Supervisor]),10),[]),10)",;
     /* lin da formula*/    1,;
     /* col da formula*/    35;
                         };
)


sistema[018]={;
            "Categoria dos Planos",;                        // opcao do menu
            "Categoria dos Planos",;                        // titulo do sistema
            {"classcod"},;                                  // chaves do arquivo
            {"Classe"},;                                    // titulo dos indices para consulta
            {"01"},;                                        // ordem campos chaves
            {"CLASSES",drvdbf,drvntx},;                     // nome do DBF
            {"CLASSES1"},;                                  // nomes dos NTX
            {},;                                            // nome dos dbf's relacionados
            {},;                                            // campos de relacionamento
            {1,1,4,12,21,68},;                              // num telas/tela atual/coordenadas
            {1,.t.,.f.},;                                   // nivel acesso/tp chave/pede dir
            {},;                                            // campos do arquivo
            {},;                                            // formula mostradas
            {"",""},;                                       // condicao de exclusao de registros
            {"",""},;                                       // condicao de alteracao de registros
            {"",""};                                        // condicao de recupercao de registros
           }

AADD(sistema[018,O_CAMPO],{;            // CLASSES
     /* mascara       */    "99",;
     /* titulo        */    "C¢digo",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(classcod)~Necess rio informar C¢DIGO",;
     /* help do campo */    "Informe um c¢digo para esta categoria";
                         };
)
AADD(sistema[018,O_CAMPO],{;            // CLASSES
     /* mascara       */    "@!",;
     /* titulo        */    "Descri‡„o",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(descricao)~Informe uma descri‡„o deste tipo de contrato.",;
     /* help do campo */    "Informe o nome desta categoria. Ex.: POPULAR, ESPECIAL,...";
                         };
)
AADD(sistema[018,O_CAMPO],{;            // CLASSES
     /* mascara       */    "999999",;
     /* titulo        */    "Contratos",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    "Informe o n£mero de contratos desta categoria|Para categoria VIP, desconsidere esta informa‡„o";
                         };
)
AADD(sistema[018,O_CAMPO],{;            // CLASSES
     /* mascara       */    "!",;
     /* titulo        */    "Prior",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "prior$' SN'~Necess rio informar PRIORIDADE",;
     /* help do campo */    "Os contratos enquadrados nesta categoria|ter„o cobran‡as emitidas periodicamente,|independente de n§ de falecimentos do grupo?";
                         };
)
AADD(sistema[018,O_CAMPO],{;            // CLASSES
     /* mascara       */    "99999999.99",;
     /* titulo        */    "Valor da J¢ia",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "!(VLjoia<0.00)~Valor da j¢ia deve ser positivo",;
     /* help do campo */    "Informe o valor da J¢ia do contrato";
                         };
)
AADD(sistema[018,O_CAMPO],{;            // CLASSES
     /* mascara       */    "99",;
     /* titulo        */    "N§Parcelas",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "vljoia>0",;
     /* validacao     */    "!(nrparc<0)~NR.Parcelas n„o aceit vel",;
     /* help do campo */    "A j¢ia pode ser parcelada em quantas vezes?";
                         };
)
AADD(sistema[018,O_CAMPO],{;            // CLASSES
     /* mascara       */    "99",;
     /* titulo        */    "N§Parcelas",;
     /* cmd especial  */    "",;
     /* default       */    "1",;
     /* pre-validacao */    "vljoia>0",;
     /* validacao     */    "!(parcger<1 .OR. parcger>nrparc)~NR.Parcelas a gerar n„o aceit vel|",;
     /* help do campo */    "Gerar a partir da parcela de J¢ia de n§...";
                         };
)
AADD(sistema[018,O_CAMPO],{;            // CLASSES
     /* mascara       */    "99999999.99",;
     /* titulo        */    "Valor Mensal",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "!(VLmensal<0.00)~Valor da mensal deve ser positivo",;
     /* help do campo */    "Informe o valor mensal do contrato";
                         };
)
AADD(sistema[018,O_CAMPO],{;            // CLASSES
     /* mascara       */    "99999999.99",;
     /* titulo        */    "V.p/Dependente",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "!(VLdepend<0.00)~Valor mensal cobrado a mais por|dependente deve ser maior ou igual a zeros",;
     /* help do campo */    "Informe o valor a ser acrescido por dependente";
                         };
)
AADD(sistema[018,O_CAMPO],{;            // CLASSES
     /* mascara       */    "99",;
     /* titulo        */    "V lidade",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "!(nrmesval<0)~Validade n„o aceit vel",;
     /* help do campo */    "Contratos v lidos por quantos meses?";
                         };
)
AADD(sistema[018,O_CAMPO],{;            // CLASSES
     /* mascara       */    "!",;
     /* titulo        */    "RenVencto",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "renvenc$[ SN]~RENVENCTO n„o aceit vel",;
     /* help do campo */    "Os contratos terÆo|renova‡Æo automatica no vencimento?";
                         };
)
AADD(sistema[018,O_CAMPO],{;            // CLASSES
     /* mascara       */    "!",;
     /* titulo        */    "RenUso",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "renuso$[ SN]~RENUSO n„o aceit vel",;
     /* help do campo */    "Os contratos terÆo|renova‡Æo automatica quando|utilizarem os servi‡os de atendimento/Auxilio?";
                         };
)
AADD(sistema[018,O_CAMPO],{;            // CLASSES
     /* mascara       */    "@E 99,999,999.99",;
     /* titulo        */    "Valor",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[018,O_FORMULA],{;          // CLASSES - Valor
     /* form mostrar  */    "LEFT(TRAN(vltotal,[@E 99,999,999.99]),13)",;
     /* lin da formula*/    16,;
     /* col da formula*/    39;
                         };
)
AADD(sistema[018,O_FORMULA],{;          // CLASSES - Valor da J¢ia
     /* form mostrar  */    "LEFT(TRAN((vljoia/vltotal)*100,[999.99]),06)",;
     /* lin da formula*/    9,;
     /* col da formula*/    29;
                         };
)
AADD(sistema[018,O_FORMULA],{;          // CLASSES - Valor Mensal
     /* form mostrar  */    "LEFT(TRAN((vlmensal/vltotal)*100,[999.99]),06)",;
     /* lin da formula*/    11,;
     /* col da formula*/    29;
                         };
)
AADD(sistema[018,O_FORMULA],{;          // CLASSES - V.p/Dependente
     /* form mostrar  */    "LEFT(TRAN((vldepend/vltotal)*100,[999.99]),06)",;
     /* lin da formula*/    12,;
     /* col da formula*/    29;
                         };
)


sistema[019]={;
            "Circulares",;                                  // opcao do menu
            "Circulares",;                                  // titulo do sistema
            {"grupo+circ"},;                                // chaves do arquivo
            {"Grupo/Circular"},;                            // titulo dos indices para consulta
            {"0102"},;                                      // ordem campos chaves
            {"CIRCULAR",drvdbf,drvntx},;                    // nome do DBF
            {"CIRCULA1"},;                                  // nomes dos NTX
            {"CPRCIRC"},;                                   // nome dos dbf's relacionados
            {},;                                            // campos de relacionamento
            {1,1,7,15,18,66},;                              // num telas/tela atual/coordenadas
            {1,.t.,.f.},;                                   // nivel acesso/tp chave/pede dir
            {},;                                            // campos do arquivo
            {},;                                            // formula mostradas
            {"",""},;                                       // condicao de exclusao de registros
            {"",""},;                                       // condicao de alteracao de registros
            {"",""};                                        // condicao de recupercao de registros
           }

AADD(sistema[019,O_CAMPO],{;            // CIRCULAR
     /* mascara       */    "!!",;
     /* titulo        */    "Grupo",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "PTAB(grupo,'ARQGRUP',1).and.PTAB(ARQGRUP->classe,'CLASSES',1)~GRUPO ou Classe lan‡ada no Grupo|n„o existe na tabela.",;
     /* help do campo */    "Informe o grupo";
                         };
)
AADD(sistema[019,O_CAMPO],{;            // CIRCULAR
     /* mascara       */    "999",;
     /* titulo        */    "Circular",;
     /* cmd especial  */    "STRZERO(VAL(ARQGRUP->proxcirc),3)",;
     /* default       */    "STRZERO(VAL(ARQGRUP->proxcirc),3)",;
     /* pre-validacao */    "nivelop=3",;
     /* validacao     */    "",;
     /* help do campo */    "Informe o n£mero da CIRCULAR a emitir.";
                         };
)
AADD(sistema[019,O_CAMPO],{;            // CIRCULAR
     /* mascara       */    "99",;
     /* titulo        */    "Procpend",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "V",;
     /* help do campo */    "";
                         };
)
AADD(sistema[019,O_CAMPO],{;            // CIRCULAR
     /* mascara       */    "@D",;
     /* titulo        */    "Emiss„o",;
     /* cmd especial  */    "",;
     /* default       */    "DATE()",;
     /* pre-validacao */    "",;
     /* validacao     */    "!EMPT(emissao_)~Necess rio informar EMISSŽO",;
     /* help do campo */    "Data da Emiss„o da Circular";
                         };
)
AADD(sistema[019,O_CAMPO],{;            // CIRCULAR
     /* mascara       */    "@R 99/99",;
     /* titulo        */    "Mˆs Ref.",;
     /* cmd especial  */    "",;
     /* default       */    "SUBSTR(DTOC(emissao_),4,2)+RIGHT(DTOC(emissao_),2)",;
     /* pre-validacao */    "",;
     /* validacao     */    "MMAA(mesref)~MES REF. n„o aceit vel",;
     /* help do campo */    "Entre com o mˆs de referˆncia desta circular.";
                         };
)
AADD(sistema[019,O_CAMPO],{;            // CIRCULAR
     /* mascara       */    "@E 999,999.99",;
     /* titulo        */    "Valor",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "valor>0~VALOR n„o aceit vel",;
     /* help do campo */    "";
                         };
)
AADD(sistema[019,O_CAMPO],{;            // CIRCULAR
     /* mascara       */    "@S35",;
     /* titulo        */    "Mensagem",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    "Entre com uma mensagem exclusiva … ‚sta circular.";
                         };
)
AADD(sistema[019,O_CAMPO],{;            // CIRCULAR
     /* mascara       */    "",;
     /* titulo        */    "Mensagem",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    "Entre com uma mensagem exclusiva … ‚sta circular.";
                         };
)
AADD(sistema[019,O_CAMPO],{;            // CIRCULAR
     /* mascara       */    "",;
     /* titulo        */    "Mensagem",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "",;
     /* help do campo */    "Entre com uma mensagem exclusiva … ‚sta circular.";
                         };
)
AADD(sistema[019,O_CAMPO],{;            // CIRCULAR
     /* mascara       */    "999999",;
     /* titulo        */    "Emitidos",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[019,O_CAMPO],{;            // CIRCULAR
     /* mascara       */    "999999",;
     /* titulo        */    "Pagos",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[019,O_CAMPO],{;            // CIRCULAR
     /* mascara       */    "999999",;
     /* titulo        */    "Cancelados",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "I",;
     /* help do campo */    "";
                         };
)
AADD(sistema[019,O_CAMPO],{;            // CIRCULAR
     /* mascara       */    "@D",;
     /* titulo        */    "Lancamento",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "V",;
     /* help do campo */    "";
                         };
)
AADD(sistema[019,O_CAMPO],{;            // CIRCULAR
     /* mascara       */    "",;
     /* titulo        */    "Usu rio",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "V",;
     /* help do campo */    "";
                         };
)
AADD(sistema[019,O_CAMPO],{;            // CIRCULAR
     /* mascara       */    "@D",;
     /* titulo        */    "Impress„o",;
     /* cmd especial  */    "",;
     /* default       */    "",;
     /* pre-validacao */    "",;
     /* validacao     */    "V",;
     /* help do campo */    "";
                         };
)
AADD(sistema[019,O_FORMULA],{;          // CIRCULAR - Descri‡„o
     /* form mostrar  */    "LEFT(TRAN(IIF(CLASSES->prior=[S],[Valor por mˆs......:],IIF(ARQGRUP->maxproc>ARQGRUP->acumproc,[Valor p/atendimento:],[Valor da circular.:])),[]),18)",;
     /* lin da formula*/    3,;
     /* col da formula*/    2;
                         };
)

* \\ Final de ADR_ATR1.PRG
procedure v02301f9
/*
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
 \ Empresa.: PresServ Inform tica-Limeira (019)452.6623
 \ Programa: V02301F9.PRG
 \ Data....: 26-05-97
 \ Sistema.: Administradora - RECEP€„O
 \ Funcao..: Valida‡„o da variavel CONFIRME, relatorio ADM_R023
 \ Analista: Ademilson Pedro Bom
 \ Criacao.: Programado manualmente pelo analista
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/

#include "adrbig.ch"    // inicializa constantes manifestas

  IF !PTAB(PADR(SUBSTR(M->ide_maq,2),4)+[OBX],[IMPPAR],1)
   ord_=LEN(sistema[EVAL(qualsis,"IMPPAR"),O_CHAVE])
   FAZ_LANC("IMPPAR",[ ])
   REPL IMPPAR->idmaq WITH PADR(SUBSTR(M->ide_maq,2),4),;
   IMPPAR->base WITH [OBX]
  ENDI
   #ifdef COM_REDE
    IMPPAR->(DBUNLOCK())                           // libera o registro
   #endi

   IF PTAB(PADR(SUBSTR(M->ide_maq,2),4)+[OBX],[IMPPAR],1)
    REPBLO('IMPPAR->docto',{||rnumero})
   ENDI

RETU .t.       // <- deve retornar um valor L¢GICO

* \\ Final de V02301F9.PRG
arj a -v1440 -r -g? adriv5 -x*.obj -x*.exe -x*.a0? -x*.arj -x*.prn -x*.zip -x*.sos -x*.dbf -x*.ntx -x*.bak -y
cls

/*
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
 \ Empresa.: PresServ Inform tica-Limeira (019)452.6623
 \ Programa: ADM_R020.PRG
 \ Data....: 22-09-97
 \ Sistema.: Administradora - RECEP€„O
 \ Funcao..: Impress„o Aux.Funeral 1
 \ Analista: Ademilson Pedro Bom
 \ Criacao.: GAS-Pro v3.0 
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/

#include "adrbig.ch"    // inicializa constantes manifestas

LOCAL dele_atu, getlist:={}, so_um_reg, sit_dbf:=POINTER_DBF()
PARA  lin_menu, col_menu, imp_reg
PRIV  tem_borda:=.t., op_menu:=VAR_COMPL, l_s:=10, c_s:=20, l_i:=13, c_i:=61, tela_fundo:=SAVESCREEN(0,0,MAXROW(),79)
nucop=1
so_um_reg=(PCOU()>2)
IF !so_um_reg                             // vai receber a variaveis?
 SETCOLOR(drvtittel)
 vr_memo=NOVAPOSI(@l_s,@c_s,@l_i,@c_i)    // pega posicao atual da tela
 CAIXA(mold,l_s,c_s,l_i,c_i)              // monta caixa da tela
 @ l_s,c_s+10 SAY " IMPRESSŽO AUX.FUNERAL "
 SETCOLOR(drvcortel)
 @ l_s+01,c_s+1 SAY " Processo:"
 @ l_s+02,c_s+1 SAY " Confirme:"
ENDI
rproc=SPAC(11)                                     // Processo
confirme=SPAC(1)                                   // Confirme
DO WHILE .t.
 rola_t=.f.
 cod_sos=56
 IF !so_um_reg
  SET KEY K_ALT_F8 TO ROLATELA
  SETCOLOR(drvcortel+","+drvcorget+",,,"+corcampo)
  @ l_s+01 ,c_s+12 GET  rproc;
                   PICT "@R 99999/9999-99";
                   VALI CRIT("!EMPT(RPROC).AND.PTAB(rproc,[AFUNER],1)~Campo utilizado para localiza‡„o dos documentos.|Tecle F8 para busca em tabela")
                   DEFAULT "IIF(PTAB(PADR(SUBSTR(M->ide_maq,2),4)+[AFU],[IMPPAR],1),ALLTRIM(IMPPAR->docto),[])"
                   AJUDA "Digite neste campo o n£mero de|identifica‡„o do processo"
                   CMDF8 "VDBF(6,12,20,77,'AFUNER',{'processo','proc2','categ','contrato','falecido'},1,'V02001F9()',[])"

  @ l_s+02 ,c_s+12 GET  confirme;
                   PICT "!";
                   VALI CRIT("confirme='S'.AND.V02002F9()~CONFIRME n„o aceit vel|Digite S para confirmar|ou|Tecle ESC para cancelar")
                   AJUDA "Digite S para confirmar|ou|tecle ESC para cancelar"

  READ
  SET KEY K_ALT_F8 TO
  IF rola_t
   ROLATELA(.f.)
   LOOP
  ENDI
  IF LASTKEY()=K_ESC                               // se quer cancelar
   RETU                                            // retorna
  ENDI
 ENDI

 #ifdef COM_REDE
  IF !USEARQ("AFUNER",.f.,10,1)                    // se falhou a abertura do arq
   RETU                                            // volta ao menu anterior
  ENDI
 #else
  USEARQ("AFUNER")                                 // abre o dbf e seus indices
 #endi

 PTAB(contrato,"GRUPOS",1,.t.)                     // abre arquivo p/ o relacionamento
 PTAB(contrato,"INSCRITS",1,.t.)
 SET RELA TO contrato INTO GRUPOS,;                // relacionamento dos arquivos
          TO contrato INTO INSCRITS
 titrel:=criterio:=cpord := ""                     // inicializa variaveis
 titrel:=chv_rela:=chv_1:=chv_2 := ""
 tps:=op_x:=ccop := 1
 arq_=drvporta                                     // porta de saida configurada
 IF !so_um_reg
  IF !opcoes_rel(lin_menu,col_menu,1,11)           // nao quis configurar...
   CLOS ALL                                        // fecha arquivos e
   LOOP                                            // volta ao menu
  ENDI

 #ifdef COM_REDE

  ELSE

   tps=lin_menu

 #endi

 ENDI
 IF tps=2                                          // se vai para arquivo/video
  arq_=ARQGER()                                    // entao pega nome do arquivo
  IF EMPTY(arq_)                                   // se cancelou ou nao informou
   LOOP                                            // retorna
  ENDI
 ELSE
  arq_=drvporta                                    // porta de saida configurada
 ENDI
 IF "4WIN"$UPPER(drvmarca) // nome da configuracao/marca impressora
    arq_:=drvdbf+"WIN"+ide_maq
    tps:=3                                          // se vai para arquivo/video
 ENDIF
 SET PRINTER TO (arq_)                             // redireciona saida
 EXIT
ENDD
DBOX("[ESC] Interrompe",15,,,NAO_APAGA)
dele_atu:=SET(_SET_DELETED,.t.)                    // os excluidos nao servem...
SET DEVI TO PRIN                                   // inicia a impressao
maxli=62                                           // maximo de linhas no relatorio
BEGIN SEQUENCE
 DO WHIL ccop<=nucop                               // imprime qde copias pedida
  pg_=1; cl=999
  IF so_um_reg
   GO imp_reg
  ELSE
   INI_ARQ()                                       // acha 1o. reg valido do arquivo
   IF PTAB(PADR(SUBSTR(M->ide_maq,2),4)+[AFU],[IMPPAR],1)
    PTAB(LEFT(IMPPAR->docto,11),'AFUNER',1)
   ENDI
  ENDI
  ccop++                                           // incrementa contador de copias
  DO WHIL !EOF().AND.(!so_um_reg.OR.imp_reg=RECN())
   #ifdef COM_TUTOR
    IF IN_KEY()=K_ESC                              // se quer cancelar
   #else
    IF INKEY()=K_ESC                               // se quer cancelar
   #endi
    IF canc()                                      // pede confirmacao
     BREAK                                         // confirmou...
    ENDI
   ENDI
   IF (PTAB(PADR(SUBSTR(M->ide_maq,2),4)+[AFU],[IMPPAR],1).and.processo+proc2+filial+categ=ALLTRIM(IMPPAR->docto)) .OR. so_um_reg// se atender a condicao...
    PTAB(contrato+[1 0],[INSCRITS])
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,049 SAY "N§ do Processo"
    IMPCTL(drvpenf)
    @ cl,064 SAY TRAN(processo+proc2+filial,"@R 99999/99/!!")// Nr.Processo
    IMPCTL(drvtenf)
    REL_CAB(2)                                     // soma cl/imprime cabecalho
    @ cl,001 SAY "Contratante:"
    IMPCTL(drvpenf)
    @ cl,014 SAY TRAN(GRUPOS->nome,"@!")// Nome do contratante
    IMPCTL(drvtenf)
    @ cl,053 SAY "Docto:"
    @ cl,060 SAY GRUPOS->rg// rg contratante
    REL_CAB(2)                                     // soma cl/imprime cabecalho
    IMPAC("Endere‡o...:",cl,001)
    @ cl,014 SAY TRAN(GRUPOS->endereco,"@!")       // Endereco contratante
    @ cl,055 SAY TRAN(GRUPOS->cidade,"@!")         // cidade contratante
//    @ cl,076 SAY TRAN(GRUPOS->estado,"!!")// Estado Contratante
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,001 SAY "Contrato...:"
    IMPCTL(drvpenf)
    @ cl,014 SAY GRUPOS->grupo                     // grupo
    IMPCTL(drvtenf)
    @ cl,017 SAY contrato                          // contrato numero
    IMPAC("Admiss:",cl,028)
    @ cl,036 SAY GRUPOS->admissao                  // data admissao
    @ cl,047 SAY "Est.Civil:"
    @ cl,058 SAY TRAN(IIF(INSCRITS->(EOF()),[ ],subst(tbestciv,AT(INSCRITS->estcivil,tbestciv),10)),"@!")// Est.Civil contratante
    REL_CAB(3)                                     // soma cl/imprime cabecalho
    IMPAC("Vem mui respeitosamente a presen‡a de V.S., atrav‚s deste,",cl,013)
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,001 SAY "requerer que se digne autorizar o pagamento da cota denominada AUXILIO"
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    IMPAC("FUNERAL, conforme cl usulas contratuais no valor abaixo  especificado,",cl,001)
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    IMPAC("e tamb‚m afirmar que estou ciente quanto as minhas responsabilidades na",cl,001)
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    IMPAC("cobertura deste Aux¡lio recebido.",cl,001)
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,001 SAY "Valor em Reais....R$"
    IMPCTL(drvpenf)
    @ cl,021 SAY ALLTRIM(TRAN(vlauxilio,'@E 99,999,999.99'))// Valor
    IMPCTL(drvtenf)
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,003 SAY [(]+SUBSTR(EXT(vlauxilio),1,AT('/',EXT(vlauxilio))-1)+[)]// Valor extenso
    REL_CAB(2)                                     // soma cl/imprime cabecalho
    @ cl,020 SAY "D A D O S   D O   F A L E C I D O"
    REL_CAB(2)                                     // soma cl/imprime cabecalho
    @ cl,004 SAY "Nome do falecido.......:"
    IMPCTL(drvpenf)
    @ cl,029 SAY TRAN(falecido,"@!")               // nome do falecido
    IMPCTL(drvtenf)
    REL_CAB(2)                                     // soma cl/imprime cabecalho
    @ cl,004 SAY "End. do falecido.......:"
    @ cl,029 SAY TRAN(ALLTRIM(ruares)+[, ]+ALLTRIM(baires),"@!")// Endereco falecido
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,004 SAY "Cidade.................:"
    @ cl,029 SAY municfal                          // Cidade Falecimento
    @ cl,056 SAY "Estado:"
    @ cl,064 SAY TRAN(estfal,"!!")                 // UF falecimento
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,004 SAY "Local do Falecimento...:"
    @ cl,029 SAY ALLTRIM(ruafal)                   // local falecimento
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    IMPAC("Cemit‚rio de sepulta/to:",cl,004)
    @ cl,029 SAY cemitsep                          // Cemit‚rio sepultamento
    @ cl,064 SAY "Horas:"
    @ cl,071 SAY TRAN(horasepult,"99:99")          // Hora sepultamento
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,004 SAY "Inscrito Contrato como.:"
    @ cl,029 SAY grauparcon                        // Inscrito na qualidade de
    @ cl,047 SAY "Faleceu em"
    @ cl,058 SAY DTOC(falecto_)+[, ]+horafal +[ hs]// obs.:
    REL_CAB(2)                                     // soma cl/imprime cabecalho
    @ cl,016 SAY "D O C U M E N T O S   A P R E S E N T A D O S"
    REL_CAB(2)                                     // soma cl/imprime cabecalho
    IMPAC("1§.Certid„o de Nascimento ou Casamento do Falecido...:",cl,004)
    @ cl,059 SAY [S] //TRAN(doc1,"!")                    // Cert.nasc.
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    IMPAC("2§.Certid„o de ¢bito do Falecido.....................:",cl,004)
    @ cl,059 SAY [S] //TRAN(doc2,"!")                    // Cert.¢bito
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,004 SAY "3§.Nota Fiscal da Empresa que executou o Funeral.....:"
    @ cl,059 SAY [S] //TRAN(doc3,"!")                    // Nota Fiscal
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,004 SAY "4§.Recibo da Empresa que executou o Funeral..........:"
    @ cl,059 SAY [N] //TRAN(doc4,"!")                    // Recibo
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,004 SAY "5§.Taxa de Sepultamento ou Recibo da Prefeitura......:"
    @ cl,059 SAY [N] //TRAN(doc5,"!")                    // Taxa Sepult.
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY "" //chr(15)                           // comprimir
    IMPCTL(drvpcom)
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    IMPAC("DECLARA€ŽO - Declaro que me responsabilizo pelas declara‡”es aqui prestadas, CIENTE de que qualquer declara‡„o FALSA importa",cl,000)
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    IMPAC("em responsabilidade criminal, nos termos do Artigo 299 do C¢digo Penal, declarando ainda que, se constatada a inexatid„o  das",cl,000)
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    IMPAC("declara‡”es prestadas do compromisso ora assumido, al‚m de  obrigar a devolu‡„o compuls¢ria da importƒncia recebida indevidamente,",cl,000)
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    IMPAC("sujeitar-me-ei  s penalidades previstas no artigo 171 do C¢digo Penal.",cl,000)
    @ cl,071 SAY "" //chr(18)                           // normal
    IMPCTL(drvtcom)
    @ cl,076 SAY "Data:"
    @ cl,082 SAY TRAN(DATE(),"@D")                 // data
    REL_CAB(2)                                     // soma cl/imprime cabecalho
    IMPCTL(drvpenf)
    @ cl,000 SAY [PROCESSAR PAGAMENTO EM : ]+ DTOC(procpagto_)// processar pgto em
    IMPCTL(drvtenf)
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,042 SAY REPL("-",30)
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,042 SAY "Ass. do Requerente declarante"
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY REPL("-",72)
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    IMPEXP(cl,000,[R E C I B O],24)                // R E C I B O
    REL_CAB(2)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY R02BP1F9()                        // recibo
    REL_CAB(2)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY "Data:"
    @ cl,006 SAY TRAN(DATE(),"@D")                 // data
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,042 SAY REPL("-",30)
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,042 SAY "Ass. do Requerente declarante"
    SKIP                                           // pega proximo registro
    cl=999                                         // forca salto de pagina
   ELSE                                            // se nao atende condicao
    SKIP                                           // pega proximo registro
   ENDI
   EJEC
   EXIT
  ENDD
 ENDD ccop
END SEQUENCE
SET PRINTER TO (drvporta)                          // fecha arquivo gerado (se houver)
SET DEVI TO SCRE                                   // direciona saida p/ video
IF tps=2                                           // se vai para arquivo/video
 BROWSE_REL(arq_,2,3,MAXROW()-2,78)
ENDI                                               // mostra o arquivo gravado
GRELA(1)                                           // grava variacao do relatorio
SELE AFUNER                                        // salta pagina
SET RELA TO                                        // retira os relacionamentos
SET(_SET_DELETED,dele_atu)                         // os excluidos serao vistos
IF so_um_reg
 POINTER_DBF(sit_dbf)
ENDI
RETU

STATIC PROC REL_CAB(qt)                            // cabecalho do relatorio
IF qt>0                                            // se parametro maior que 0
 cl=cl+qt                                          // soma no contador de linhas
ENDI
IF cl>maxli .OR. qt=0                              // quebra de pagina
 @ 1,001 SAY TRAN(setup1,"@!")                     // Administradora
 @ 2,000 SAY REPL("-",72)
 @ 3,004 SAY "R E Q U E R I M E N T O   D E   A U X I L I O   F U N E R A L"

 nucop:=1

 @ 3,067 SAY STR(ccop-1,1)+[¦ Via]  // ccop contˆn o n£mero da via + 1.
 @ 4,000 SAY REPL("-",72)
 cl=qt+4 ; pg_++
ENDI
RETU

* \\ Final de ADM_R020.PRG
FUNC R02BP1F9()
 LOCAL ar_db:=ALIAS(), ultreg, ord_ind
 LOCAL tit:=[Sra.], tit1:=[a]
 LOCAL li_:=PROW(), co_:=PCOL(), nrdec_:=[]

 li_aux:=space(1024)
 li_aux:=[Recebi da ]+ALLTRIM(M->setup1)+;
  [, a importƒncia supra de R$]+ALLTRIM(TRAN(vlauxilio,[@E 999,999.99]))+;
  [ (]+LEFT(EXT(vlauxilio),AT([/],EXT(vlauxilio))-1)+[)]
 li_aux+=[ referente ao AUXILIO FUNERAL por ocasi„o do falecimento acima mencionado ]+;
  [ conforme requerimento anexo.]
 li_aux+=CHR(13)+CHR(10)+[Para clareza legal, firmo o presente, da qual dou f‚.]
 li_m:=-1
 qli_m:=MLCOUNT(li_aux,70)-1                  // quantas linhas a imprimir?
 DO WHIL .t.                                     // imprime linhas do memo
  li_m++
  cl++
  IF li_m>qli_m                                  // fim do memo
   EXIT
  ENDI
  IMPMEMO(li_aux,70,1+li_m,cl,005,.t.)       // imprime...
  IF INKEY()=K_ESC                               // se quer cancelar
   IF canc()                                     // pede confirmacao
    BREAK                                        // confirmou...
   ENDI
  ENDI
 ENDD
 cl:=56
RETU [ ]       // <- deve retornar um valor qualquer
€	 ORDPGRC_–H ORDPGRCCODEORD_INCLCODE
ORD_ANT_SECODE
ORD_CRIA_SCODE
ORD_GERA_SCODE
ORD_GRAVA_CODEORD_TELACODEORD_GETSCODEORD_GET1CODEC_ETEXTENDCODE	_SYMSTARTSYMSTARTSYMBOLSSYMBOLS_SYMENDSYMENDNULLBEGDATA_DATADATA_SYMPBDATA_SYMPDATA_SYMPEDATA_CONSTCONST_MSGMSG_BEGBSSBEGBSS_BSSBSS_ENDBSSENDBSSDGROUPi˜ @õ$˜ @ƒŒ˜ @| —˜ @H	Æ˜ @ê 
!˜ @2 Õ˜ @g™˜ @Ñ*˜ @o…˜ H  ï˜ h  Ë˜ `8˜ h               6  pw_grupo+pw_codigo                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         p €    ° À Ð à ð   0@P`p€ °ÀÐàð  0@P`p€ °ÀÐàð  0@P`p€ °ÀÐ       ¤•¤–¤•¤–                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                procedure con_rx01
/*
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
 \ Empresa.: Ind£stria de Urnas Bignotto Ltda
 \ Programa: CON_R001.PRG
 \ Data....: 15-05-97
 \ Sistema.: Controle de Convˆnios
 \ Funcao..: Emiss„o Guias 1¦ Parte
 \ Analista: Ademilson Pedro Bom
 \ Criacao.: GAS-Pro v3.0
 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
*/

#include "adrbig.ch"    // inicializa constantes manifestas

LOCAL dele_atu, getlist:={}, so_um_reg, sit_dbf:=POINTER_DBF()
PARA  lin_menu, col_menu, imp_reg
PRIV  tem_borda:=.t., op_menu:=VAR_COMPL, l_s:=11, c_s:=20, l_i:=14, c_i:=61, tela_fundo:=SAVESCREEN(0,0,MAXROW(),79)
nucop=1
so_um_reg=(PCOU()>2)
IF !so_um_reg                             // vai receber a variaveis?
 SETCOLOR(drvtittel)
 vr_memo=NOVAPOSI(@l_s,@c_s,@l_i,@c_i)    // pega posicao atual da tela
 CAIXA(mold,l_s,c_s,l_i,c_i)              // monta caixa da tela
 @ l_s,c_s+12 SAY " EMISSŽO DE GUIAS "
 SETCOLOR(drvcortel)
 @ l_s+01,c_s+1 SAY " N£mero:"
ENDI
gnumero=SPAC(8)                                    // N£mero
DO WHILE .t.
 rola_t=.f.
 cod_sos=56
 IF !so_um_reg
  SET KEY K_ALT_F8 TO ROLATELA
  SETCOLOR(drvcortel+","+drvcorget+",,,"+corcampo)
  @ l_s+01 ,c_s+10 GET  gnumero;
		   PICT "@R 99-999999";
		   VALI CRIT("PTAB(gnumero,'GUIAS',1).AND.V00101F9()~N£MERO n„o existe na tabela")
		   DEFAULT "IIF(PTAB(PADR(SUBSTR(M->ide_maq,2),4)+[GUI],[IMPPAR],1),ALLTRIM(IMPPAR->docto),[])"
		   AJUDA "Emitir a guia de n£mero?"
		   CMDF8 "VDBF(6,8,20,77,'GUIAS',{'numero','contrato','nome'},1,'numero')"
		   MOSTRA {"LEFT(TRAN(GUIAS->nome,[@!]),35)", 2 , 5 }

  READ
  SET KEY K_ALT_F8 TO
  IF rola_t
   ROLATELA(.f.)
   LOOP
  ENDI
  IF LASTKEY()=K_ESC                               // se quer cancelar
   RETU                                            // retorna
  ENDI
 ENDI

 #ifdef COM_REDE
  IF !USEARQ("GUIAS",.f.,10,1)                     // se falhou a abertura do arq
   RETU                                            // volta ao menu anterior
  ENDI
 #else
  USEARQ("GUIAS")                                  // abre o dbf e seus indices
 #endi

 PTAB(medico,"MEDICOS",1,.t.)                      // abre arquivo p/ o relacionamento
 PTAB(contrato,"GRUPOS",1,.t.)                      // abre arquivo p/ o relacionamento
 PTAB(GRUPOS->tipcont,"CLASSES",1,.t.)                      // abre arquivo p/ o relacionamento
 SET RELA TO medico INTO MEDICOS                 // relacionamento dos arquivos

 titrel:=criterio:=cpord := ""                     // inicializa variaveis
 titrel:=chv_rela:=chv_1:=chv_2 := ""
 tps:=op_x:=ccop := 1
 arq_=drvporta                                     // porta de saida configurada
 IF !so_um_reg
  IF !opcoes_rel(lin_menu,col_menu,7,11)           // nao quis configurar...
   CLOS ALL                                        // fecha arquivos e
   LOOP                                            // volta ao menu
  ENDI

 #ifdef COM_REDE

  ELSE

   tps=lin_menu

 #endi

 ENDI
 IF tps=2                                          // se vai para arquivo/video
  arq_=ARQGER()                                    // entao pega nome do arquivo
  IF EMPTY(arq_)                                   // se cancelou ou nao informou
   LOOP                                            // retorna
  ENDI
 ELSE
  arq_=drvporta                                    // porta de saida configurada
 ENDI
 IF "4WIN"$UPPER(drvmarca) // nome da configuracao/marca impressora
    arq_:=drvdbf+"WIN"+ide_maq
    tps:=3                                          // se vai para arquivo/video
 ENDIF
 SET PRINTER TO (arq_)                             // redireciona saida
 EXIT
ENDD
IF !EMPTY(drvtapg)                                 // existe configuracao de tam pag?
 op_=AT("NNN",drvtapg)                             // se o codigo que altera
 IF op_=0                                          // o tamanho da pagina
  msg="Configura‡„o do tamanho da p gina!"         // foi informado errado
  DBOX(msg,,,,,"ERRO!")                            // avisa
  CLOSE ALL                                        // fecha todos arquivos abertos
  RETU                                             // e cai fora...
 ENDI                                              // codigo para setar/resetar tam pag
 lpp_024=LEFT(drvtapg,op_-1)+"033"+SUBS(drvtapg,op_+3)
 lpp_066=LEFT(drvtapg,op_-1)+"066"+SUBS(drvtapg,op_+3)
ELSE
 lpp_024:=lpp_066 :=""                             // nao ira mudara o tamanho da pag
ENDI
DBOX("[ESC] Interrompe",15,,,NAO_APAGA)
dele_atu:=SET(_SET_DELETED,.t.)                    // os excluidos nao servem...
SET DEVI TO PRIN                                   // inicia a impressao
maxli=17                                           // maximo de linhas no relatorio
IMPCTL(lpp_024)                                    // seta pagina com 24 linhas
SET MARG TO 1                                      // ajusta a margem esquerda
IF tps=2
 IMPCTL("' '+CHR(8)")
ENDI
BEGIN SEQUENCE
 DO WHIL ccop<=nucop				// imprime qde copias pedida
  pg_=1; cl=999
  IF so_um_reg
   GO imp_reg
  ELSE
   INI_ARQ()                                       // acha 1o. reg valido do arquivo
   IF PTAB(PADR(SUBSTR(M->ide_maq,2),4)+[GUI],[IMPPAR],1)
    SEEK ALLTRIM(IMPPAR->docto)
   ENDI
  ENDI
  ccop++                                           // incrementa contador de copias
  ult_imp=0                                        // ultimo reg impresso
  DO WHIL !EOF().AND.(!so_um_reg.OR.imp_reg=RECN())
   #ifdef COM_TUTOR
    IF IN_KEY()=K_ESC                              // se quer cancelar
   #else
    IF INKEY()=K_ESC                               // se quer cancelar
   #endi
    IF canc()                                      // pede confirmacao
     BREAK                                         // confirmou...
    ENDI
   ENDI
   IF (PTAB(PADR(SUBSTR(M->ide_maq,2),4)+[GUI],[IMPPAR],1).AND.numero=LEFT(IMPPAR->docto,7)) .OR. so_um_reg// se atender a condicao...
    PTAB(contrato,"GRUPOS",1,.t.)                      // abre arquivo p/ o relacionamento
    PTAB(GRUPOS->tipcont,"CLASSES",1,.t.)                      // abre arquivo p/ o relacionamento

    REL_CAB(1,.t.)                                 // soma cl/imprime cabecalho
    @ cl,000 SAY "GUIA DE IDENTIFICACAO  N§:"
    @ cl,027 SAY numero   // N£mero
//    @ cl,043 SAY IIF(guiapara='C',[Consulta],IIF(guiapara='E',[Exame],IIF(guiapara='I',[Interna‡„o],[     ])))// Guia Para
    IF M->combarra=[S]
     CODBARRAS({{numero+GDV1(numero),4,10,64}},10,6)
    ENDI
    ult_imp=RECNO()                                // ultimo reg impresso
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY "Para:"
    @ cl,008 SAY TRAN(MEDICOS->oldespec,"@!")    // Especialidade
    IF M->combarra=[S]
     CODBARRAS({{numero+GDV1(numero),4,10,64}},10,6)
    ENDI
    REL_CAB(2)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY "Nome ..................:"
    @ cl,025 SAY ALLTRIM(MEDICOS->nome)+[ (]+ALLTRIM(medico)+[) ]+;// M‚dico
		 [ tel: ]+ ALLTRIM(MEDICOS->fonesdiv)
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    IMPAC("Endere‡o...............:",cl,000)
    @ cl,025 SAY MEDICOS->endereco// Endere‡o
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY "Data...................:"
    @ cl,025 SAY TRAN(data,"@D")               // Emiss„o
    IMPAC("(V lido at‚ 30 dias)",cl,036)
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    IMPAC("Benefici rio principal.:",cl,000)
    @ cl,025 SAY TRAN([ (]+ALLTRIM(GRUPOS->nome)+[ / ]+ALLTRIM(contrato)+[)],"@!")+;// Titular
	 [ ] +&drvpcom+ALLTRIM(CLASSES->descricao)+&drvtcom
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY "Benefici rio..........:"
    IMPCTL(drvpenf)
    @ cl,025 SAY TRAN(nome,"@!")                   // Nome
    IMPCTL(drvtenf)
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    @ cl,000 SAY REPL("-",60)
    REL_CAB(1)                                     // soma cl/imprime cabecalho
    SKIP                                           // pega proximo registro
    cl=999                                         // forca salto de pagina
   ELSE                                            // se nao atende condicao
    SKIP                                           // pega proximo registro
   ENDI
   exit
  ENDD
  REL_RDP(.t.)                                     // imprime rodape' do relatorio
 ENDD ccop
 EJEC                                              // salta pagina
END SEQUENCE
SET MARG TO                                        // coloca margem esquerda = 0
IMPCTL(lpp_066)                                    // seta pagina com 66 linhas
SET PRINTER TO (drvporta)                          // fecha arquivo gerado (se houver)
SET DEVI TO SCRE                                   // direciona saida p/ video
IF tps=2                                           // se vai para arquivo/video
 BROWSE_REL(arq_,2,3,MAXROW()-2,78)
ENDI                                               // mostra o arquivo gravado
GRELA(7)                                           // grava variacao do relatorio
SELE GUIAS                                         // salta pagina
SET RELA TO                                        // retira os relacionamentos
SET(_SET_DELETED,dele_atu)                         // os excluidos serao vistos
IF so_um_reg
 POINTER_DBF(sit_dbf)
ENDI
RETU

STATIC PROC REL_RDP(volta_reg)                     // rodape'
LOCAL reg_atual:=RECNO()
IF volta_reg
 GO ult_imp                                        // ajusta reg p/ imp de campos no rodape'
ENDI
@ 16,000 SAY "" //chr(15)                               // comprime
IMPCTL(drvpcom)
@ 16,002 SAY [IMPORTANTE:- Esta guia tem a finalidade principal de identificar o benefici rio em dia, ou seja,]// Mensagem 1
@ 17,002 SAY [sem pendencias, n„o sendo cobrado nenhum valor pela sua emiss„o.]// Mensagem 2
@ 18,002 SAY [ - Esta guia s¢ ter  validade com o carimbo e assinatura do respons vel pela emiss„o.]// Mensagem 4
@ 19,002 SAY [ ] //A BOM PASTOR n„o se responsabiliza por procedimentos medicos e outros, visto ser de]
@ 20,002 SAY [ ] //  livre escolha do associado.]
@ 21,000 SAY "" //chr(18)                               // normal
IMPCTL(drvtcom)
@ 22,060 SAY [FR-OPE-0017]
@ 23,001 SAY replicate('- ',36)                    // traco
IF volta_reg
 GO reg_atual                                      // retorna reg a posicao original
ENDI
RETU

STATIC PROC REL_CAB(qt, volta_reg)                 // cabecalho do relatorio
volta_reg=IF(volta_reg=NIL,.f.,volta_reg)
IF qt>0                                            // se parametro maior que 0
 cl=cl+qt                                          // soma no contador de linhas
ENDI
IF cl>maxli .OR. qt=0                              // quebra de pagina
 IF pg_>1
  REL_RDP(volta_reg)                               // imprime rodape' do relatorio
 ENDI
 IMPCTL(drvpenf)
 IMPEXP(0,000,LEFT(M->setup1,38),76)               // Setup1
 IMPCTL(drvtenf)
// @ 1,000 SAY M->defconv                            // Defconv
 @ 2,000 SAY M->setup2                             // setup2
 @ 3,000 SAY M->setup3                             // Setup3
 @ 4,000 SAY REPL("-",60)
 cl=qt+4 ; pg_++
ENDI
RETU

* \\ Final de CON_R001.PRG
FUNC R001GF9
RETURN numero

 Volume in drive Y is /sys
 Directory of  Y:\PEDRO\PRJBPV4\IV\REC

.            <DIR>         20/12/05 13:32 
..           <DIR>          1/11/05 12:04 
ORDPGRC  PRG        20.056 22/03/04  9:29 
R02501F9 PRG           647 20/03/98 19:59 
ALENDER  PRG        17.185  4/11/03 15:48 
CONTAB1  PRG        21.898 28/06/01 19:21 
ADM_R023 OK         10.865 23/05/01  0:51 
V02001F9 PRG           650 20/03/98 19:59 
PRCESSOS PRG        18.761  4/11/03 15:48 
ADM_R033 OK1        12.217 12/11/96 13:05 
ORDPGRC  ATR         3.642 12/11/03 10:21 
ADM_R019 REL         1.149 20/10/97 21:31 
ADM_R018 ATR         1.174 20/10/97 21:33 
ADM_R022 PRG         9.838  4/11/03 15:48 
ADR_ATR1 PRG        77.582 11/06/04 10:16 
AFUNER   PRG        28.762  7/10/04 16:30 
V01801F9 PRG         1.047 28/10/03 14:07 
FNCS     SMT           512 21/10/03 12:15 
COBRADOR PRG        14.291  4/11/03 15:48 
CON_R001 CAP        11.928 22/05/01 21:51 
MEDICOS  ATR         5.159  6/01/04  9:32 
ADM_RV33 OK         14.797  3/09/97  8:27 
CAD_04F9 OLD         1.701 26/10/99  9:34 
ADMBIG   PRG        29.121 20/03/98 19:59 
V02002F9 PRG         1.101 20/03/98 19:59 
GRUPAO   ATR         1.668  4/04/95 21:19 
ADM_R021 ATR           643 20/11/95 13:04 
DCI_P001 GLO           366 12/11/03 10:21 
GUI_08F9 OLD         1.185 19/07/98 21:29 
LIMPAD   BAT           275 22/05/01 21:51 
CPRCIRC  ATR         1.906 28/10/97 23:00 
CON_P003 GLO           242 22/05/01 21:51 
R03001F9 PRG           591 24/05/98 12:14 
ADR_ATRI OLD        91.282 29/06/99 15:17 
R00601F9 PRG         2.149 20/03/98 19:59 
ADRBIG   CH          6.639 29/01/04 14:21 
INICIA                 372  3/09/03 14:02 
GUI_04F9 PRG           962 23/05/98 17:30 
CONVERT  PHP         3.336 15/10/03 11:14 
CTAINSC  CEX         1.190 10/01/97  8:18 
REGIAO   PRG        14.591  4/11/03 15:48 
ADM_R040 REL         1.217 27/06/97 21:15 
CON_R001 001         9.141 23/06/98 11:15 
CSEGURO  CEX         1.742  8/08/97 13:47 
RX2901F9 PRG         1.290 20/03/98 19:59 
R01801F9 PRG        25.656 20/03/98 19:59 
TAXAS    ATR         3.312  4/11/03 15:28 
CGRUPOS  PRG        56.390 19/11/99 12:46 
CSTSEG   PRG        11.859  4/11/03 15:48 
ADM_R018 REL         3.826 20/10/97 21:33 
CONFIG   INC            89  3/09/03 14:02 
ADRBIG   LNK         1.399  5/05/04 10:29 
V03001F9 PRG           713 20/03/98 19:59 
ADM_R033 ATR         1.301 18/11/96 14:31 
REC_01F9 PRG           702 20/03/98 19:59 
ADM_R033 OK         12.913 18/11/96  9:50 
CSEGURO  PRG         2.976 20/03/98 19:59 
ADR_R029 REL         4.642 12/11/03 10:21 
CL       BAT            55  2/09/03 17:55 
BXREC    ATR         5.541 17/06/04 11:07 
CON_RX01 PRG        11.429 22/11/04 20:22 
ADR_PROC PRG       112.532 29/01/04 14:22 
ADM_E001 ETQ           917  1/04/96  8:50 
CON_R001 EXT         9.204 22/05/01 21:51 
ADM_R022 OK         24.078 18/06/96  8:00 
OBX_01F9 PRG         2.639  7/10/04 16:26 
LEIAME   TXT         2.030 29/01/04 16:27 
GRCOMPL  PRG         7.509 20/03/98 19:59 
ADR_ADAP PRG        31.140 29/01/04 12:47 
GRU_01F9 PRG           947 24/05/98 12:13 
ADM_R033 REL         3.545 15/12/96  9:42 
ADR_OUTR PRG        11.702  2/03/04 14:02 
ADRBIG   PRO         4.025 17/06/04 11:07 
ADM_R021 REL         1.775 12/11/03 10:21 
ADR_P005 GLO           341  2/04/97  1:10 
BXR_01F9 PRG         2.637  7/10/04 16:26 
ADM_R020 OK         14.077 20/03/98 19:59 
ADR_ROOT SYS         2.184 21/10/03 13:15 
GUI_03F9 PRG           962 23/05/98 17:30 
ADRBIG   MAP        95.814 21/12/05  5:45 
ADM_R027 OK          7.241 28/01/96 12:15 
CON_RX41 PRG             0 12/01/04 10:23 
POSCOP   BAT           283 12/11/03 10:13 
ARQGRUP  ATR         4.397 12/11/03 10:21 
ADM_R039 REL         1.830 12/11/03 10:21 
AFUNER   ATR         9.019 12/11/03 10:21 
GRUPOS   ATR         9.907 29/01/04 12:45 
DCI_P001 PRG         5.086  4/11/03 15:48 
ADR_LNK  OK            395  2/09/03 14:31 
TESPEC   PRG        13.652  4/11/03 15:48 
MENSAG   SMT           512 21/10/03 12:15 
BX_BXREC BIF           360  3/05/99 13:26 
CON_R001 BRO        12.282 30/07/02 13:10 
CTAINSC  PRG         2.868 12/11/03 10:42 
CX       BAT            54  8/01/04  7:51 
DCI04F9  PRG         1.641 20/03/98 19:59 
ADR_MAC  BAT         3.034 29/01/04 14:22 
ADR_ADAP LNK            91 29/01/04 12:47 
PAR_ADM  ATR         7.961 12/11/03 10:21 
CLASSES  ATR         3.740 12/11/03 10:21 
ADR_RX68 PRG        10.332  2/05/03  0:38 
ADM_R020 PRG        16.299  4/01/05  7:34 
R02002F9 PRG         1.547 20/03/98 19:59 
SIN_01F9 PRG           799 20/03/98 19:59 
ADM_R020 ATR         1.025 30/06/97  8:52 
TFILIAIS ATR         1.767 12/11/03 10:21 
X        BAT            89 20/11/01 14:06 
GUI_06F9 PRG         1.272 15/10/03  5:43 
ADM_RS18 PRG        13.357 14/06/04 17:53 
BXR_018  PRG           804  7/12/95  8:54 
TFILIAIS SMT           512 21/10/03 12:15 
ADRRMK   OK          2.947  7/08/98 18:47 
FNCS     PRG        18.382  4/11/03 15:48 
ADP_P007 PRG         7.359 20/03/98 19:59 
ADM_R018 OK         11.183 24/11/96 19:11 
ADM_R026 REL         2.724 12/11/03 10:21 
R02901F9 PRG         1.298 20/03/98 19:59 
BXR_06F9 PRG         2.717 12/01/04  9:42 
ADM_R039 ATR           797 12/02/97 14:22 
CTXAS    CEX           880 12/02/97 15:04 
ADM_R041 BP         14.484 22/05/01 21:50 
MVC-010S JPG        36.071 20/10/03 13:12 
MEDICOS  SMT           512 21/10/03 12:15 
GUIAS    ATR         3.396 12/01/04 10:36 
CONTAB1  RMK           359 28/06/01 18:51 
R08703F9 PRG         1.006 20/03/98 19:59 
CON_R001 OSS         9.113 22/05/01 21:51 
R00201F9 PRG           939 20/03/98 19:59 
ADM_RS18 ATR         1.014 28/10/03 14:04 
TFILIAIS PRG        14.005  4/11/03 15:48 
PAR_ADM  PRG         9.963  4/11/03 15:48 
V02301F9 PRG         1.049 14/06/04 18:00 
CON_R001 REL         2.667 15/10/03  6:53 
INSCRITS ATR         3.788 12/11/03 10:13 
GRUPOAO  ATR           127  4/04/95 21:18 
ADM_R020 REL         4.644 12/11/03 10:21 
R04201F9 PRG           924 22/05/01 21:51 
DCI03F9  PRG         1.349 20/03/98 19:59 
DCI01F9  PRG         2.368 20/03/98 19:59 
CODBAR   PRG           574 22/05/01 21:51 
ADM_R039 PRG        14.500 14/01/05  9:56 
ADM_R026 PRG         9.747  4/01/05  7:41 
ADR_RX29 PRG        13.461  4/01/05  7:36 
HISTORIC ATR         3.255 12/11/03 10:21 
COBRADOR SMT           512 21/10/03 12:15 
ADM_R039 OK         14.970  9/08/96 22:17 
V02201F9 PRG           633 20/03/98 19:59 
CAD_04F9 PRG         1.887 19/04/05 17:42 
MEN_01F9 PRG           782 26/10/99 13:05 
ADR_ADAP MAP        75.816 12/11/03 10:27 
ADR_RX29 ATR         1.023 22/09/97 14:18 
BXR_07F9 PRG         2.551 19/04/05 18:13 
RECMENS  PRG           278 22/05/01 21:51 
ADM_ESTR PRG        17.465 20/03/98 19:59 
GRU_02F9 PRG         1.458  2/05/98 13:28 
ADRBIG   RMK         2.455 29/01/04 15:01 
ADR_PUBL CH          1.307 16/01/97 21:53 
R08701F9 PRG         1.313 20/03/98 19:59 
V87001F9 PRG           996 20/03/98 19:59 
TESPEC   ATR           753 12/11/03 10:21 
ECOB     ATR         2.125  4/11/03 15:27 
ADR_ATR1 OLD        81.808 27/04/99  9:13 
OBX_07F9 PRG         1.816 29/01/04 15:08 
DCI_P001 ATR         1.023 22/02/98  8:50 
KINSCF9  PRG           616 15/10/03  6:01 
FINAL    PRG         1.230 12/11/03 10:15 
JUROS    ATR         1.691 12/11/03 10:21 
ADP_R066 OK         13.438 16/06/97 13:21 
DCI_P001 FOR           665 29/08/97 14:23 
GRUPOS   PRG        63.659 12/11/03 10:42 
BXROSS   PRG        22.466 13/04/98 20:46 
ADR_R029 ATR         1.023 22/09/97 14:18 
V02401F9 PRG         1.075 20/03/98 19:59 
ADR_FUNC PRG       146.700 29/01/04 14:22 
ADR_MENU PRG        11.898 29/01/04 14:22 
ADM_R020 FAC        14.077 20/03/98 19:59 
ADM_RX20 PRG        14.289  4/01/05  7:36 
ACCAIXA  PRG         2.223 26/10/98 16:38 
ALE_01F9 PRG           807 15/10/03  5:39 
GUI_07F9 OLD         1.475 15/08/98  9:52 
ADR_PCXB GLO           234 29/06/98 20:16 
ADM_R022 REL         2.569 12/11/03 10:21 
ARQGRUP  PRG        15.471  4/11/03 15:48 
ADM_R041 PRG        15.869 22/05/01 21:51 
RX2002F9 PRG         1.544 20/03/98 19:59 
COB_01F9 PRG           705 24/05/98 12:14 
GUI_07F9 PRG         2.358 17/01/05 11:56 
ADM_RS18 REL         4.668 12/11/03 10:21 
CHEQUES  ATR         1.454 15/08/95 22:28 
ADR_ATRI PRG        84.702  8/06/05 14:58 
SQL2DBF  PHP         4.439 28/10/03  5:39 
ADM_R029 OLD        10.533 20/03/98 19:59 
ADM_RX20 REL         4.522 12/11/03 10:21 
CSTSEG   ATR         2.575 12/11/03 10:21 
ABOUT    PRG         1.711 26/02/04 13:19 
BX_BXREC PRG           826  3/05/99 13:23 
MENSAG   ATR         1.898 12/11/03 10:21 
PROCESSA PRG           932 12/11/03 10:14 
COBRADOR ATR         2.184 12/11/03 10:21 
ADM_R026 ATR         1.028 30/06/97 12:35 
ADR_ADAP RMK           222 29/01/04 12:47 
ADM_R050 OK         13.744  9/08/96 22:17 
GRCOMPL  ATR         6.666 25/09/96 13:03 
BX_BXREC RMK           107 26/01/99 10:30 
ADM_R026 POC        10.502 16/09/97 16:27 
R02001F9 PRG         1.417 24/05/98 12:14 
ADM_R034 REL         1.164 18/11/96 14:25 
MENSAG   PRG        16.216  4/11/03 15:48 
TAX_01F9 PRG           958 20/03/98 19:59 
OBXEC    PRG        22.753 21/12/05  5:44 
JUROS    PRG        14.722  4/11/03 15:48 
C        BAT           112 22/05/01 21:51 
R00202F9 PRG         1.572 20/03/98 19:59 
ADRBIG   CAB         3.835 22/08/98 11:06 
ADR_ESTR PRG        23.426 11/06/04 10:18 
ADM_R033 PRG        12.924 20/03/98 19:59 
OBX_018  PRG           804 25/07/96  9:09 
GUIAS    PRG        16.331  2/03/04 14:54 
ADM_R023 PRG        13.138 20/12/05 16:41 
PRCESSOS ATR         3.563 12/11/03 10:21 
ADR_FUNC OK        148.244  2/12/97 18:14 
Y        BAT            35 20/11/01 14:06 
CONTAB1  LNK           471 28/06/01 18:51 
ADM_R029 ATR         1.028 30/06/97 12:33 
ADMBIG   CH          5.638 29/09/96 21:43 
ADR_RX29 REL         4.637 12/11/03 10:21 
ADRBIG   INX         1.920 29/01/04 14:22 
ADR_ATR2 PRG        72.896  5/05/04 10:21 
ADM_R~2P PRG        15.121 21/02/00 22:49 
CTCGRUP  PRG         3.359  6/01/00 22:05 
ADR_R029 PRG        14.869  4/01/05  7:35 
BEN_01F9 PRG           962 29/05/01  8:41 
CLASSES  PRG        18.866  4/11/03 15:48 
IMP_01F9 PRG         1.034 20/03/98 19:59 
OBX_02F9 PRG           673 24/05/98 12:13 
COPNET   BAT           936 12/11/03 10:15 
CON_R001 PRG        13.408 15/03/04  9:20 
R06601F9 PRG           944 20/03/98 19:59 
INS_02F9 PRG           820  2/05/98 13:28 
ADP_R044 OK1        13.968  4/05/97  9:33 
ADM_R024 OK         23.591  5/03/96 20:34 
ADM_R023 REL         4.423 29/01/04 12:42 
ADM_R021 PRG         6.926  4/01/05  7:45 
ADM_R022 ATR           979 25/07/97  9:18 
ADRBIG   PRG        27.266 14/01/05 10:03 
CIRCULAR ATR         2.794 12/11/03 10:21 
CON_R001 ATR           806 15/10/03  6:52 
IMPPAR   PRG        12.658  4/11/03 15:48 
DSK~00   ___           126 30/09/02 10:15 
ACINS03  PRG         1.056 15/10/03 17:03 
ADRBIG   BIF         7.176 10/08/98 16:52 
OBXEC    OK         18.176  9/08/96 21:48 
RX2001F9 PRG         1.400 24/05/98 12:14 
LIXO     TXT            70 21/12/05  5:45 
HISTORIC PRG        20.352  4/11/03 15:48 
CGR_02F9 PRG           679 19/11/99 12:41 
CONTAB   PRG           783 28/06/01 18:03 
R02701F9 PRG           939 20/03/98 19:59 
V03301F9 PRG           629 18/11/96 14:34 
INS_01F9 PRG           645 24/05/98 12:13 
ADP_R044 OK         14.097 21/07/97 12:25 
ADRBIG   CA2         4.104  1/09/03 11:32 
BXREC    PRG        23.842 17/01/05 11:12 
FNCS     ATR         3.175 12/11/03 10:21 
ARJOK    BAT           118 22/11/04 20:30 
GUI_05F9 PRG           634 23/05/98 17:22 
CON_R001 BAL        12.206 22/05/01 21:51 
MVC-027S JPG        34.921 20/10/03 13:12 
GRUPOS   SMT           512 21/10/03 13:15 
ADM_R023 ATR         1.157 23/05/01  0:51 
REGIAO   ATR         1.631 12/11/03 10:21 
ADM_R029 PRG        10.478  4/11/03 15:48 
MVC-028S JPG        66.232 20/10/03 13:10 
ADM_RS18 OK         11.537 24/11/96 19:12 
DCI_P002 GLO           517 31/08/97 17:28 
CON_P003 PRG         6.085 22/05/01 21:51 
ADM_R026 FAC         9.867 20/03/98 19:59 
BXR_02F9 PRG           985  8/01/04  8:10 
CIRCULAR PRG        27.695  4/11/03 15:48 
ADR_ATR3 PRG        47.163 27/08/98 15:54 
MEDICOS  PRG        22.380  4/11/03 15:48 
GUI_02F9 PRG         2.064 12/01/04 10:37 
ADM_R018 PRG        13.512 20/03/98 19:59 
R08702F9 PRG         2.017 20/03/98 19:59 
ATUAL    BAT            64  8/01/04  8:41 
V00101F9 PRG         1.077 23/06/98 11:10 
TXA_01F9 PRG           998 20/03/98 19:59 
BX_BXREC LNK           324 26/01/99 10:30 
CON_R027 PRG         5.662 22/05/01 21:51 
TAX_02F9 PRG           835 20/03/98 19:59 
GUI_08F9 PRG         1.350 15/03/05 15:17 
CON_R001 BP         11.605  3/12/98  8:37 
CTXAS    PRG         2.631 12/11/03 10:42 
OBXEC    ATR         5.181 29/01/04 16:26 
CONF     PHP           354 21/10/03  7:15 
ADRBIG   MAN        76.519 13/11/97 17:32 
IMPPAR   ATR         1.262 12/11/03 10:21 
ADM_R029 REL         3.543 12/11/03 10:21 
ADMBIG   CAB           622 16/09/96 15:51 
ADRLNK   OK          1.352 21/10/03 13:14 
ADR_FUN2 PRG        85.204 29/01/04 14:22 
ALENDER  ATR         4.183 12/11/03 10:21 
R00101F9 PRG         1.119 15/10/03  6:40 
ADR_R068 PRG        10.848 22/05/01 21:51 
ADRBIG   OLD        27.216 11/05/04 10:13 
AFUNER   OLD        28.762  1/07/04  8:49 
ADRBIG   OBJ        14.820 15/03/05 15:17 
BXR_07F9 OBJ         2.465 19/04/05 18:13 
BXR_06F9 OBJ         2.231 23/11/04 10:49 
BXR_02F9 OBJ         1.147 23/11/04 10:49 
BXR_01F9 OBJ         2.538 23/11/04 10:49 
BXREC    OBJ        14.221 15/03/05 15:17 
ALE_01F9 OBJ         1.012 23/11/04 10:49 
ALENDER  OBJ        11.186 23/11/04 10:49 
OBX_07F9 OBJ         1.938 23/11/04 10:49 
OBX_01F9 OBJ         2.538 23/11/04 10:49 
OBXEC    OBJ        13.913 21/12/05  5:45 
GRU_01F9 OBJ         1.061 23/11/04 10:49 
GRU_02F9 OBJ         1.380 23/11/04 10:49 
GRUPOS   OBJ        33.898 23/11/04 10:49 
CTAINSC  OBJ         1.814 23/11/04 10:49 
CTXAS    OBJ         1.703 23/11/04 10:49 
TAX_02F9 OBJ           885 23/11/04 10:49 
INS_01F9 OBJ           781 23/11/04 10:49 
INS_02F9 OBJ           905 23/11/04 10:49 
GUI_07F9 OBJ         2.188 15/03/05 15:17 
GUI_06F9 OBJ         1.522 23/11/04 10:49 
GUI_08F9 OBJ         1.355 15/03/05 15:17 
GUI_02F9 OBJ         2.124 23/11/04 10:49 
GUIAS    OBJ        10.716 23/11/04 10:49 
CAD_04F9 OBJ         2.020 19/04/05 17:43 
KINSCF9  OBJ           687 23/11/04 10:49 
AFUNER   OBJ        17.566 23/11/04 10:49 
R02001F9 OBJ         1.574 23/11/04 10:49 
R02002F9 OBJ         1.645 23/11/04 10:49 
ADM_R020 OBJ        10.310  4/01/05  7:46 
V02001F9 OBJ           759 23/11/04 10:49 
V02002F9 OBJ         1.290 23/11/04 10:49 
R02901F9 OBJ         1.444 23/11/04 10:49 
ADR_R029 OBJ         8.892  4/01/05  7:46 
RX2001F9 OBJ         1.550 23/11/04 10:49 
RX2002F9 OBJ         1.642 23/11/04 10:49 
ADM_RX20 OBJ         8.407  4/01/05  7:46 
RX2901F9 OBJ         1.434 23/11/04 10:49 
ADR_RX29 OBJ         8.378  4/01/05  7:46 
ADM_R029 OBJ         7.147 23/11/04 10:49 
ADM_R026 OBJ         6.578  4/01/05  7:46 
ADM_R021 OBJ         4.871  4/01/05  7:46 
DCI_P001 OBJ         4.311 23/11/04 10:49 
DCI01F9  OBJ         2.563 23/11/04 10:49 
DCI03F9  OBJ         1.181 23/11/04 10:49 
DCI04F9  OBJ         1.626 23/11/04 10:49 
ADM_RS18 OBJ         8.425 23/11/04 10:49 
V01801F9 OBJ         1.202 23/11/04 10:49 
ADM_R023 OBJ         7.923 21/12/05  5:45 
V02301F9 OBJ         1.202 23/11/04 10:49 
ADM_R022 OBJ         6.691 23/11/04 10:49 
R03001F9 OBJ           678 23/11/04 10:49 
ADM_R039 OBJ         7.829 15/03/05 15:17 
IMP_01F9 OBJ         1.160 23/11/04 10:49 
IMPPAR   OBJ         7.705 23/11/04 10:49 
MEDICOS  OBJ        14.861  1/03/05 14:13 
TESPEC   OBJ         7.766 23/11/04 10:49 
JUROS    OBJ         8.685 23/11/04 10:49 
TFILIAIS OBJ         8.580 23/11/04 10:49 
ARQGRUP  OBJ         9.866 23/11/04 10:49 
REGIAO   OBJ         9.002 23/11/04 10:49 
COB_01F9 OBJ           806 23/11/04 10:49 
COBRADOR OBJ         9.170 23/11/04 10:49 
CLASSES  OBJ        11.414 23/11/04 10:49 
CIRCULAR OBJ        15.204 23/11/04 10:49 
PRCESSOS OBJ        11.217 23/11/04 10:49 
FNCS     OBJ        11.112 23/11/04 10:49 
HISTORIC OBJ        11.579 23/11/04 10:49 
CSTSEG   OBJ         7.956 23/11/04 10:49 
MEN_01F9 OBJ           979 23/11/04 10:49 
MENSAG   OBJ         9.447 23/11/04 10:49 
ORDPGRC  OBJ        12.069 23/11/04 10:49 
PAR_ADM  OBJ         8.388 23/11/04 10:49 
ADR_ESTR OBJ        12.939 23/11/04 10:49 
ADR_ATRI OBJ        23.202  8/06/05 14:58 
ADR_ATR1 OBJ        20.829 23/11/04 10:49 
ADR_ATR2 OBJ        20.148 23/11/04 10:49 
ADR_MENU OBJ         8.580 23/11/04 10:49 
CON_RX01 OBJ         7.287 23/11/04 10:49 
ABOUT    OBJ         2.042 23/11/04 10:49 
ADR_PROC OBJ        47.063 23/11/04 10:49 
ADR_FUNC OBJ        54.238 23/11/04 10:49 
ADR_FUN2 OBJ        40.918 23/11/04 10:49 
ADR_OUTR OBJ         7.358 23/11/04 10:49 
ADRBIG   EXE             0 21/12/05  5:45 
OBXEC    BAK        22.670 20/12/05 16:18 
ADRIV5   ARJ       903.811 15/08/05 10:41 
ADM_R026 BAK         9.747  4/01/05  7:41 
ADM_R021 BAK         6.926 14/12/04 10:25 
ADM_R020 BAK        16.301 15/03/99 13:44 
ADR_R029 BAK        14.869 15/03/99 13:52 
ADM_RX20 BAK        14.289  5/01/99 13:44 
ADR_RX29 BAK        13.461  5/01/99 13:44 
GUI_08F9 BAK         1.350  8/06/04  9:32 
CAD_04F9 BAK         1.771  4/11/03 13:43 
BXR_07F9 BAK         2.553 17/01/05 11:55 
ADR_ATRI BAK        84.682 17/01/05 11:51 
ADM_R023 BAK        13.031 29/01/04 16:16 
      404 File(s)     4.902.330 bytes
                  2.147.450.880 bytes free
